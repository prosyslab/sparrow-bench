/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 220 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct obj {
   unsigned long m_flags ;
   char const   *damage ;
   short quantity ;
   short ichar ;
   short kill_exp ;
   short is_protected ;
   short is_cursed ;
   short class ;
   short identified ;
   unsigned short which_kind ;
   short o_row ;
   short o_col ;
   short o ;
   short row ;
   short col ;
   short d_enchant ;
   short quiver ;
   short trow ;
   short tcol ;
   short hit_enchant ;
   unsigned short what_is ;
   short picked_up ;
   unsigned short in_use_flags ;
   struct obj *next_object ;
};
#line 243 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
typedef struct obj object;
#line 256 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct fightr {
   object *armor ;
   object *weapon ;
   object *left_ring ;
   object *right_ring ;
   short hp_current ;
   short hp_max ;
   short str_current ;
   short str_max ;
   object pack ;
   long gold ;
   short exp ;
   long exp_points ;
   short row ;
   short col ;
   short fchar ;
   short moves_left ;
};
#line 273 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
typedef struct fightr fighter;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 192 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct id {
   short value ;
   char title[64] ;
   char const   *real ;
   unsigned short id_status ;
};
#line 275 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct dr {
   short oth_room ;
   short oth_row ;
   short oth_col ;
   short door_row ;
   short door_col ;
};
#line 283 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
typedef struct dr door;
#line 285 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct rm {
   short bottom_row ;
   short right_col ;
   short left_col ;
   short top_row ;
   door doors[4] ;
   unsigned short is_room ;
};
#line 291 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
typedef struct rm room;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 332 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct tr {
   short trap_type ;
   short trap_row ;
   short trap_col ;
};
#line 337 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
typedef struct tr trap;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 157 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
struct id_com_s {
   short com_char ;
   char const   *com_desc ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
struct option {
   char const   *prompt ;
   char is_bool ;
   char **strval ;
   char *bval ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_40 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_41 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_40 __wait_terminated ;
   struct __anonstruct___wait_stopped_41 __wait_stopped ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 427 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct rogue_time {
   short year ;
   short month ;
   short day ;
   short hour ;
   short minute ;
   short second ;
};
#line 339
fighter rogue ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 449 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object *get_letter_object(int ch ) ;
#line 478
void check_message(void) ;
#line 483
int coin_toss(void) ;
#line 492
void do_put_on(object *ring , char on_left ) ;
#line 519
void get_desc(object const   *obj , char *desc ) ;
#line 530
int get_rand(int x , int y ) ;
#line 544
void gr_ring(object *ring , char assign_wk ) ;
#line 567
void inv_rings(void) ;
#line 601
void message(char const   *msg , char intrpt ) ;
#line 627
short pack_letter(char const   *prompt , unsigned short mask ) ;
#line 638
void print_stats(int stat_mask ) ;
#line 645
void put_on_ring(void) ;
#line 661
char reg_move(void) ;
#line 662
void relight(void) ;
#line 664
void remove_ring(void) ;
#line 667
int rgetchar(void) ;
#line 668
void ring_stats(char pr ) ;
#line 713
void un_put_on(object *ring ) ;
#line 750 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char maintain_armor  ;
#line 755 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char r_see_invisible  ;
#line 756 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char r_teleport  ;
#line 760 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char sustain_strength  ;
#line 762
char wizard ;
#line 768
char const   *curse_message ;
#line 779 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short add_strength  ;
#line 780 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short auto_search  ;
#line 786 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short e_rings  ;
#line 796 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short r_rings  ;
#line 797 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short regeneration  ;
#line 798 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short ring_exp  ;
#line 799 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short stealthy  ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
char const   *left_or_right  =    "left or right hand?";
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
char const   *no_ring  =    "there\'s no ring on that hand";
#line 72 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void put_on_ring(void) 
{ 
  short ch ;
  char desc[80] ;
  object *ring ;
  int tmp ;

  {
#line 79
  if ((int )r_rings == 2) {
    {
#line 80
    message("wearing two rings already", (char)0);
    }
#line 81
    return;
  }
  {
#line 83
  ch = pack_letter("put on what?", (unsigned short)128);
  }
#line 83
  if ((int )ch == 27) {
#line 84
    return;
  }
  {
#line 86
  ring = get_letter_object((int )ch);
  }
#line 86
  if (! ring) {
    {
#line 87
    message("no such item.", (char)0);
    }
#line 88
    return;
  }
#line 90
  if (! ((int )ring->what_is & 128)) {
    {
#line 91
    message("that\'s not a ring", (char)0);
    }
#line 92
    return;
  }
#line 94
  if ((int )ring->in_use_flags & 12) {
    {
#line 95
    message("that ring is already being worn", (char)0);
    }
#line 96
    return;
  }
#line 98
  if ((int )r_rings == 1) {
#line 99
    if (rogue.left_ring) {
#line 99
      ch = (short )'r';
    } else {
#line 99
      ch = (short )'l';
    }
  } else {
    {
#line 101
    message(left_or_right, (char)0);
    }
    {
#line 102
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 103
      tmp = rgetchar();
#line 103
      ch = (short )tmp;
      }
#line 102
      if ((int )ch != 27) {
#line 102
        if ((int )ch != 108) {
#line 102
          if ((int )ch != 114) {
#line 102
            if ((int )ch != 10) {
#line 102
              if (! ((int )ch != 13)) {
#line 102
                goto while_break;
              }
            } else {
#line 102
              goto while_break;
            }
          } else {
#line 102
            goto while_break;
          }
        } else {
#line 102
          goto while_break;
        }
      } else {
#line 102
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 107
  if ((int )ch != 108) {
#line 107
    if ((int )ch != 114) {
      {
#line 108
      check_message();
      }
#line 109
      return;
    }
  }
#line 111
  if ((int )ch == 108) {
#line 111
    if (rogue.left_ring) {
      {
#line 112
      check_message();
#line 113
      message("there\'s already a ring on that hand", (char)0);
      }
#line 114
      return;
    } else {
#line 111
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 111
  if ((int )ch == 114) {
#line 111
    if (rogue.right_ring) {
      {
#line 112
      check_message();
#line 113
      message("there\'s already a ring on that hand", (char)0);
      }
#line 114
      return;
    }
  }
#line 116
  if ((int )ch == 108) {
    {
#line 117
    do_put_on(ring, (char)1);
    }
  } else {
    {
#line 119
    do_put_on(ring, (char)0);
    }
  }
  {
#line 121
  ring_stats((char)1);
#line 122
  check_message();
#line 123
  get_desc((object const   *)ring, desc);
#line 124
  message((char const   *)(desc), (char)0);
#line 125
  reg_move();
  }
#line 126
  return;
}
}
#line 133 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void do_put_on(object *ring , char on_left ) 
{ 


  {
#line 138
  if (on_left) {
#line 139
    ring->in_use_flags = (unsigned short )((int )ring->in_use_flags | 4);
#line 140
    rogue.left_ring = ring;
  } else {
#line 142
    ring->in_use_flags = (unsigned short )((int )ring->in_use_flags | 8);
#line 143
    rogue.right_ring = ring;
  }
#line 145
  return;
}
}
#line 147 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void remove_ring(void) 
{ 
  char left ;
  char right ;
  short ch ;
  char buf[80] ;
  object *ring ;
  int tmp ;

  {
#line 150
  left = (char)0;
#line 150
  right = (char)0;
#line 155
  ring = (object *)((void *)0);
#line 156
  if ((int )r_rings == 0) {
    {
#line 157
    inv_rings();
    }
  } else
#line 158
  if (rogue.left_ring) {
#line 158
    if (! rogue.right_ring) {
#line 159
      left = (char)1;
    } else {
#line 158
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 160
  if (! rogue.left_ring) {
#line 160
    if (rogue.right_ring) {
#line 161
      right = (char)1;
    } else {
#line 160
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 163
    message(left_or_right, (char)0);
    }
    {
#line 164
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 165
      tmp = rgetchar();
#line 165
      ch = (short )tmp;
      }
#line 164
      if ((int )ch != 27) {
#line 164
        if ((int )ch != 108) {
#line 164
          if ((int )ch != 114) {
#line 164
            if ((int )ch != 10) {
#line 164
              if (! ((int )ch != 13)) {
#line 164
                goto while_break;
              }
            } else {
#line 164
              goto while_break;
            }
          } else {
#line 164
            goto while_break;
          }
        } else {
#line 164
          goto while_break;
        }
      } else {
#line 164
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 168
    left = (char )((int )ch == 108);
#line 169
    right = (char )((int )ch == 114);
#line 170
    check_message();
    }
  }
#line 172
  if (left) {
#line 172
    goto _L___1;
  } else
#line 172
  if (right) {
    _L___1: /* CIL Label */ 
#line 173
    if (left) {
#line 174
      if (rogue.left_ring) {
#line 175
        ring = rogue.left_ring;
      } else {
        {
#line 177
        message(no_ring, (char)0);
        }
      }
    } else
#line 180
    if (rogue.right_ring) {
#line 181
      ring = rogue.right_ring;
    } else {
      {
#line 183
      message(no_ring, (char)0);
      }
    }
#line 186
    if (ring->is_cursed) {
      {
#line 187
      message(curse_message, (char)0);
      }
    } else {
      {
#line 189
      un_put_on(ring);
#line 190
      strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"removed ");
#line 191
      get_desc((object const   *)ring, buf + 8);
#line 192
      message((char const   *)(buf), (char)0);
#line 193
      reg_move();
      }
    }
  }
#line 196
  return;
}
}
#line 198 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void un_put_on(object *ring ) 
{ 


  {
#line 202
  if (ring) {
#line 202
    if ((int )ring->in_use_flags & 4) {
#line 203
      ring->in_use_flags = (unsigned short )((int )ring->in_use_flags & -5);
#line 204
      rogue.left_ring = (object *)0;
    } else {
#line 202
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 205
  if (ring) {
#line 205
    if ((int )ring->in_use_flags & 8) {
#line 206
      ring->in_use_flags = (unsigned short )((int )ring->in_use_flags & -9);
#line 207
      rogue.right_ring = (object *)0;
    }
  }
  {
#line 209
  ring_stats((char)1);
  }
#line 210
  return;
}
}
#line 212 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void gr_ring(object *ring , char assign_wk ) 
{ 
  int tmp ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 217
  ring->what_is = (unsigned short)128;
#line 218
  if (assign_wk) {
    {
#line 219
    tmp = get_rand(0, 10);
#line 219
    ring->which_kind = (unsigned short )tmp;
    }
  }
#line 221
  ring->class = (short)0;
  {
#line 240
  if ((int )ring->which_kind == 1) {
#line 240
    goto case_1;
  }
#line 244
  if ((int )ring->which_kind == 6) {
#line 244
    goto case_6;
  }
#line 244
  if ((int )ring->which_kind == 4) {
#line 244
    goto case_6;
  }
#line 248
  if ((int )ring->which_kind == 7) {
#line 248
    goto case_7;
  }
#line 223
  goto switch_break;
  case_1: /* CIL Label */ 
#line 241
  ring->is_cursed = (short)1;
#line 242
  goto switch_break;
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 245
    tmp___1 = get_rand(0, 4);
#line 245
    tmp___0 = (short )(tmp___1 - 2);
#line 245
    ring->class = tmp___0;
    }
#line 245
    if (! ((int )tmp___0 == 0)) {
#line 245
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  ring->is_cursed = (short )((int )ring->class < 0);
#line 247
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 249
  tmp___2 = coin_toss();
#line 249
  ring->is_cursed = (short )tmp___2;
  }
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 254 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void inv_rings(void) 
{ 
  char buf[80] ;

  {
#line 259
  if ((int )r_rings == 0) {
    {
#line 260
    message("not wearing any rings", (char)0);
    }
  } else {
#line 262
    if (rogue.left_ring) {
      {
#line 263
      get_desc((object const   *)rogue.left_ring, buf);
#line 264
      message((char const   *)(buf), (char)0);
      }
    }
#line 266
    if (rogue.right_ring) {
      {
#line 267
      get_desc((object const   *)rogue.right_ring, buf);
#line 268
      message((char const   *)(buf), (char)0);
      }
    }
  }
#line 271
  if (wizard) {
    {
#line 272
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"ste %d, r_r %d, e_r %d, r_t %d, s_s %d, a_s %d, reg %d, r_e %d, s_i %d, m_a %d, aus %d",
            (int )stealthy, (int )r_rings, (int )e_rings, (int )r_teleport, (int )sustain_strength,
            (int )add_strength, (int )regeneration, (int )ring_exp, (int )r_see_invisible,
            (int )maintain_armor, (int )auto_search);
#line 276
    message((char const   *)(buf), (char)0);
    }
  }
#line 278
  return;
}
}
#line 280 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/ring.c"
void ring_stats(char pr ) 
{ 
  short i ;
  object *ring ;

  {
#line 287
  stealthy = (short)0;
#line 288
  r_rings = (short)0;
#line 289
  e_rings = (short)0;
#line 290
  r_teleport = (char)0;
#line 291
  sustain_strength = (char)0;
#line 292
  add_strength = (short)0;
#line 293
  regeneration = (short)0;
#line 294
  ring_exp = (short)0;
#line 295
  r_see_invisible = (char)0;
#line 296
  maintain_armor = (char)0;
#line 297
  auto_search = (short)0;
#line 299
  i = (short)0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! ((int )i < 2)) {
#line 299
      goto while_break;
    }
#line 300
    if ((int )i == 0) {
#line 300
      ring = rogue.left_ring;
    } else {
#line 300
      ring = rogue.right_ring;
    }
#line 300
    if (! ring) {
#line 301
      goto __Cont;
    }
#line 303
    r_rings = (short )((int )r_rings + 1);
#line 304
    e_rings = (short )((int )e_rings + 1);
    {
#line 306
    if ((int )ring->which_kind == 0) {
#line 306
      goto case_0;
    }
#line 309
    if ((int )ring->which_kind == 1) {
#line 309
      goto case_1;
    }
#line 312
    if ((int )ring->which_kind == 2) {
#line 312
      goto case_2;
    }
#line 315
    if ((int )ring->which_kind == 3) {
#line 315
      goto case_3;
    }
#line 318
    if ((int )ring->which_kind == 4) {
#line 318
      goto case_4;
    }
#line 321
    if ((int )ring->which_kind == 5) {
#line 321
      goto case_5;
    }
#line 324
    if ((int )ring->which_kind == 6) {
#line 324
      goto case_6;
    }
#line 327
    if ((int )ring->which_kind == 7) {
#line 327
      goto case_7;
    }
#line 329
    if ((int )ring->which_kind == 8) {
#line 329
      goto case_8;
    }
#line 332
    if ((int )ring->which_kind == 9) {
#line 332
      goto case_9;
    }
#line 335
    if ((int )ring->which_kind == 10) {
#line 335
      goto case_10;
    }
#line 305
    goto switch_break;
    case_0: /* CIL Label */ 
#line 307
    stealthy = (short )((int )stealthy + 1);
#line 308
    goto switch_break;
    case_1: /* CIL Label */ 
#line 310
    r_teleport = (char)1;
#line 311
    goto switch_break;
    case_2: /* CIL Label */ 
#line 313
    regeneration = (short )((int )regeneration + 1);
#line 314
    goto switch_break;
    case_3: /* CIL Label */ 
#line 316
    e_rings = (short )((int )e_rings - 2);
#line 317
    goto switch_break;
    case_4: /* CIL Label */ 
#line 319
    add_strength = (short )((int )add_strength + (int )ring->class);
#line 320
    goto switch_break;
    case_5: /* CIL Label */ 
#line 322
    sustain_strength = (char)1;
#line 323
    goto switch_break;
    case_6: /* CIL Label */ 
#line 325
    ring_exp = (short )((int )ring_exp + (int )ring->class);
#line 326
    goto switch_break;
    case_7: /* CIL Label */ 
#line 328
    goto switch_break;
    case_8: /* CIL Label */ 
#line 330
    r_see_invisible = (char)1;
#line 331
    goto switch_break;
    case_9: /* CIL Label */ 
#line 333
    maintain_armor = (char)1;
#line 334
    goto switch_break;
    case_10: /* CIL Label */ 
#line 336
    auto_search = (short )((int )auto_search + 2);
#line 337
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 299
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  if (pr) {
    {
#line 341
    print_stats(8);
#line 342
    relight();
    }
  }
#line 344
  return;
}
}
#line 343 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object level_objects ;
#line 824 "/usr/include/curses.h"
extern int wmove(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 470 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void c_object_for_wizard(void) ;
#line 471
void call_it(void) ;
#line 479
int check_up(void) ;
#line 493
void do_shell(void) ;
#line 498
void draw_magic_map(void) ;
#line 500
void drop(void) ;
#line 501
int drop_check(void) ;
#line 503
void eat(void) ;
#line 504
void edit_opts(void) ;
#line 507
extern void fight(int  ) ;
#line 558
void id_com(void) ;
#line 559
void id_trap(void) ;
#line 560
void id_type(void) ;
#line 566
void inv_armor_weapon(char is_weapon ) ;
#line 568
void inventory(object const   *pack , unsigned short mask ) ;
#line 570
extern char is_digit(int  ) ;
#line 575
void kick_into_pack(void) ;
#line 610
void move_onto(void) ;
#line 612
void multiple_move_rogue(short dirch ) ;
#line 621
int one_move_rogue(short dirch , short pickup ) ;
#line 633
void play_level(void) ;
#line 649
void quaff(void) ;
#line 650
void quit(char from_intrpt ) ;
#line 658
void read_scroll(void) ;
#line 663
void remessage(short c___0 ) ;
#line 665
void rest(int count ) ;
#line 681
void save_game(void) ;
#line 684
void search(short n___0 , char is_auto ) ;
#line 688
void show_average_hp(void) ;
#line 689
void show_monsters(void) ;
#line 690
void show_objects(void) ;
#line 691
void show_traps(void) ;
#line 692
void single_inv(short ichar ) ;
#line 703
void take_off(void) ;
#line 706
void throw(void) ;
#line 727
void wear(void) ;
#line 728
void wield(void) ;
#line 730
void wizardize(void) ;
#line 736
void zapp(void) ;
#line 747
char interrupted ;
#line 761
char trap_door ;
#line 763
char hit_message[80] ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/play.c"
char interrupted  =    (char)0;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/play.c"
char const   *unknown_command  =    "unknown command";
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/play.c"
void play_level(void) 
{ 
  short ch ;
  int count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char tmp___7 ;

  {
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    interrupted = (char)0;
#line 69
    if (hit_message[0]) {
      {
#line 70
      message((char const   *)(hit_message), (char)1);
#line 71
      hit_message[0] = (char)0;
      }
    }
#line 73
    if (trap_door) {
#line 74
      trap_door = (char)0;
#line 75
      return;
    }
    {
#line 77
    wmove(stdscr, (int )rogue.row, (int )rogue.col);
#line 78
    wrefresh(stdscr);
#line 80
    tmp = rgetchar();
#line 80
    ch = (short )tmp;
    }
    CMCH: 
    {
#line 82
    check_message();
#line 83
    count = 0;
    }
    CH: 
    {
#line 86
    if ((int )ch == 46) {
#line 86
      goto case_46;
    }
#line 89
    if ((int )ch == 115) {
#line 89
      goto case_115;
    }
#line 92
    if ((int )ch == 105) {
#line 92
      goto case_105;
    }
#line 95
    if ((int )ch == 102) {
#line 95
      goto case_102;
    }
#line 98
    if ((int )ch == 70) {
#line 98
      goto case_70;
    }
#line 108
    if ((int )ch == 98) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 110) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 117) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 121) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 108) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 107) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 106) {
#line 108
      goto case_98;
    }
#line 108
    if ((int )ch == 104) {
#line 108
      goto case_98;
    }
#line 126
    if ((int )ch == 2) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 14) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 21) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 25) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 12) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 11) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 10) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 8) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 78) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 85) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 89) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 66) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 76) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 75) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 74) {
#line 126
      goto case_2;
    }
#line 126
    if ((int )ch == 72) {
#line 126
      goto case_2;
    }
#line 129
    if ((int )ch == 101) {
#line 129
      goto case_101;
    }
#line 132
    if ((int )ch == 113) {
#line 132
      goto case_113;
    }
#line 135
    if ((int )ch == 114) {
#line 135
      goto case_114;
    }
#line 138
    if ((int )ch == 109) {
#line 138
      goto case_109;
    }
#line 141
    if ((int )ch == 44) {
#line 141
      goto case_44;
    }
#line 144
    if ((int )ch == 100) {
#line 144
      goto case_100;
    }
#line 147
    if ((int )ch == 80) {
#line 147
      goto case_80;
    }
#line 150
    if ((int )ch == 82) {
#line 150
      goto case_82;
    }
#line 153
    if ((int )ch == 16) {
#line 153
      goto case_16;
    }
#line 160
    if ((int )ch == 23) {
#line 160
      goto case_23;
    }
#line 163
    if ((int )ch == 62) {
#line 163
      goto case_62;
    }
#line 168
    if ((int )ch == 60) {
#line 168
      goto case_60;
    }
#line 174
    if ((int )ch == 93) {
#line 174
      goto case_93;
    }
#line 174
    if ((int )ch == 41) {
#line 174
      goto case_93;
    }
#line 177
    if ((int )ch == 61) {
#line 177
      goto case_61;
    }
#line 180
    if ((int )ch == 94) {
#line 180
      goto case_94;
    }
#line 183
    if ((int )ch == 47) {
#line 183
      goto case_47;
    }
#line 186
    if ((int )ch == 63) {
#line 186
      goto case_63;
    }
#line 189
    if ((int )ch == 33) {
#line 189
      goto case_33;
    }
#line 192
    if ((int )ch == 111) {
#line 192
      goto case_111;
    }
#line 195
    if ((int )ch == 73) {
#line 195
      goto case_73;
    }
#line 198
    if ((int )ch == 84) {
#line 198
      goto case_84;
    }
#line 201
    if ((int )ch == 87) {
#line 201
      goto case_87;
    }
#line 204
    if ((int )ch == 119) {
#line 204
      goto case_119;
    }
#line 207
    if ((int )ch == 99) {
#line 207
      goto case_99;
    }
#line 210
    if ((int )ch == 122) {
#line 210
      goto case_122;
    }
#line 213
    if ((int )ch == 116) {
#line 213
      goto case_116;
    }
#line 216
    if ((int )ch == 118) {
#line 216
      goto case_118;
    }
#line 219
    if ((int )ch == 81) {
#line 219
      goto case_81;
    }
#line 230
    if ((int )ch == 57) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 56) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 55) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 54) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 53) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 52) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 51) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 50) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 49) {
#line 230
      goto case_57;
    }
#line 230
    if ((int )ch == 48) {
#line 230
      goto case_57;
    }
#line 243
    if ((int )ch == 32) {
#line 243
      goto case_32;
    }
#line 245
    if ((int )ch == 9) {
#line 245
      goto case_9;
    }
#line 252
    if ((int )ch == 19) {
#line 252
      goto case_19;
    }
#line 259
    if ((int )ch == 20) {
#line 259
      goto case_20;
    }
#line 266
    if ((int )ch == 15) {
#line 266
      goto case_15;
    }
#line 273
    if ((int )ch == 1) {
#line 273
      goto case_1;
    }
#line 276
    if ((int )ch == 3) {
#line 276
      goto case_3;
    }
#line 283
    if ((int )ch == 13) {
#line 283
      goto case_13;
    }
#line 290
    if ((int )ch == 83) {
#line 290
      goto case_83;
    }
#line 293
    goto switch_default;
    case_46: /* CIL Label */ 
#line 87
    if (count > 0) {
#line 87
      tmp___0 = count;
    } else {
#line 87
      tmp___0 = 1;
    }
    {
#line 87
    rest(tmp___0);
    }
#line 88
    goto switch_break;
    case_115: /* CIL Label */ 
#line 90
    if (count > 0) {
#line 90
      tmp___1 = count;
    } else {
#line 90
      tmp___1 = 1;
    }
    {
#line 90
    search((short )tmp___1, (char)0);
    }
#line 91
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 93
    inventory((object const   *)(& rogue.pack), (unsigned short)511);
    }
#line 94
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 96
    fight(0);
    }
#line 97
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 99
    fight(1);
    }
#line 100
    goto switch_break;
    case_98: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 109
    one_move_rogue(ch, (short)1);
    }
#line 110
    goto switch_break;
    case_2: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_72: /* CIL Label */ 
    {
#line 127
    multiple_move_rogue(ch);
    }
#line 128
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 130
    eat();
    }
#line 131
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 133
    quaff();
    }
#line 134
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 136
    read_scroll();
    }
#line 137
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 139
    move_onto();
    }
#line 140
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 142
    kick_into_pack();
    }
#line 143
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 145
    drop();
    }
#line 146
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 148
    put_on_ring();
    }
#line 149
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 151
    remove_ring();
    }
#line 152
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 155
      tmp___2 = count;
#line 155
      count ++;
#line 155
      remessage((short )tmp___2);
#line 156
      tmp___3 = rgetchar();
#line 156
      ch = (short )tmp___3;
      }
#line 154
      if (! ((int )ch == 16)) {
#line 154
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 158
    goto CMCH;
#line 159
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 161
    wizardize();
    }
#line 162
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 164
    tmp___4 = drop_check();
    }
#line 164
    if (tmp___4) {
#line 165
      return;
    }
#line 167
    goto switch_break;
    case_60: /* CIL Label */ 
    {
#line 169
    tmp___5 = check_up();
    }
#line 169
    if (tmp___5) {
#line 170
      return;
    }
#line 172
    goto switch_break;
    case_93: /* CIL Label */ 
    case_41: /* CIL Label */ 
    {
#line 175
    inv_armor_weapon((char )((int )ch == 41));
    }
#line 176
    goto switch_break;
    case_61: /* CIL Label */ 
    {
#line 178
    inv_rings();
    }
#line 179
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 181
    id_trap();
    }
#line 182
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 184
    id_type();
    }
#line 185
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 187
    id_com();
    }
#line 188
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 190
    do_shell();
    }
#line 191
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 193
    edit_opts();
    }
#line 194
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 196
    single_inv((short)0);
    }
#line 197
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 199
    take_off();
    }
#line 200
    goto switch_break;
    case_87: /* CIL Label */ 
    {
#line 202
    wear();
    }
#line 203
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 205
    wield();
    }
#line 206
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 208
    call_it();
    }
#line 209
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 211
    zapp();
    }
#line 212
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 214
    throw();
    }
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 217
    message("rogue-clone: Version III. (Tim Stoehr was here), tektronix!zeus!tims",
            (char)0);
    }
#line 218
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 220
    quit((char)0);
    }
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 231
    wmove(stdscr, (int )rogue.row, (int )rogue.col);
#line 232
    wrefresh(stdscr);
    }
    {
#line 233
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 234
      if (count < 100) {
#line 235
        count = 10 * count + ((int )ch - 48);
      }
      {
#line 237
      tmp___6 = rgetchar();
#line 237
      ch = (short )tmp___6;
#line 233
      tmp___7 = is_digit((int )ch);
      }
#line 233
      if (! tmp___7) {
#line 233
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 239
    if ((int )ch != 27) {
#line 240
      goto CH;
    }
#line 242
    goto switch_break;
    case_32: /* CIL Label */ 
#line 244
    goto switch_break;
    case_9: /* CIL Label */ 
#line 246
    if (wizard) {
      {
#line 247
      inventory((object const   *)(& level_objects), (unsigned short)511);
      }
    } else {
      {
#line 249
      message(unknown_command, (char)0);
      }
    }
#line 251
    goto switch_break;
    case_19: /* CIL Label */ 
#line 253
    if (wizard) {
      {
#line 254
      draw_magic_map();
      }
    } else {
      {
#line 256
      message(unknown_command, (char)0);
      }
    }
#line 258
    goto switch_break;
    case_20: /* CIL Label */ 
#line 260
    if (wizard) {
      {
#line 261
      show_traps();
      }
    } else {
      {
#line 263
      message(unknown_command, (char)0);
      }
    }
#line 265
    goto switch_break;
    case_15: /* CIL Label */ 
#line 267
    if (wizard) {
      {
#line 268
      show_objects();
      }
    } else {
      {
#line 270
      message(unknown_command, (char)0);
      }
    }
#line 272
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 274
    show_average_hp();
    }
#line 275
    goto switch_break;
    case_3: /* CIL Label */ 
#line 277
    if (wizard) {
      {
#line 278
      c_object_for_wizard();
      }
    } else {
      {
#line 280
      message(unknown_command, (char)0);
      }
    }
#line 282
    goto switch_break;
    case_13: /* CIL Label */ 
#line 284
    if (wizard) {
      {
#line 285
      show_monsters();
      }
    } else {
      {
#line 287
      message(unknown_command, (char)0);
      }
    }
#line 289
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 291
    save_game();
    }
#line 292
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 294
    message(unknown_command, (char)0);
    }
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 340 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
room rooms[9] ;
#line 342
unsigned short dungeon[24][80] ;
#line 345
struct id id_scrolls[13] ;
#line 346
struct id id_potions[14] ;
#line 353
object level_monsters ;
#line 785 "/usr/include/curses.h"
extern int waddch(WINDOW * , chtype const    ) ;
#line 814
extern chtype winch(WINDOW * ) ;
#line 448 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char const   *get_ench_color(void) ;
#line 459
char const   *name_of(object const   *obj ) ;
#line 460
object *object_at(object *pack , short row___0 , short col___0 ) ;
#line 462
void add_exp(int e , char promotion ) ;
#line 465
void aggravate(void) ;
#line 482
void cnfs(void) ;
#line 486
void create_monster(void) ;
#line 488
void darken_room(short rn ) ;
#line 513
void free_object(object *obj ) ;
#line 522
char get_dungeon_char(short row___0 , short col___0 ) ;
#line 531
short get_room_number(int row___0 , int col___0 ) ;
#line 538
void go_blind(void) ;
#line 542
char gr_obj_char(void) ;
#line 550
void hallucinate(void) ;
#line 555
void hold_monster(void) ;
#line 561
void idntfy(void) ;
#line 578
void light_passage(int row___0 , int col___0 ) ;
#line 579
void light_up_room(int rn ) ;
#line 599
void md_sleep(int nsecs ) ;
#line 615
void mv_mons(void) ;
#line 635
void potion_heal(int extra ) ;
#line 646
void put_player(short nr ) ;
#line 655
int rand_percent(int percentage ) ;
#line 701
void take_a_nap(void) ;
#line 702
void take_from_pack(object *obj , object *pack ) ;
#line 704
void tele(void) ;
#line 714
void unblind(void) ;
#line 715
void unconfuse(void) ;
#line 716
void uncurse_all(void) ;
#line 717
void unhallucinate(void) ;
#line 718
void unwear(object *obj ) ;
#line 719
void unwield(object *obj ) ;
#line 720
void vanish(object *obj , short rm , object *pack ) ;
#line 738
struct id *get_id_table(object const   *obj ) ;
#line 742
char being_held ;
#line 744
char con_mon ;
#line 745
char detect_monster ;
#line 759
char see_invisible ;
#line 765
char hunger_str[8] ;
#line 770
char *fruit ;
#line 777
char const   *you_can_move_again ;
#line 778
long const   level_points[21] ;
#line 781
short bear_trap ;
#line 782
short blind ;
#line 783
short confused ;
#line 785
short cur_room ;
#line 787
short extra_hp ;
#line 789
short halluc ;
#line 790
short haste_self ;
#line 792
short levitate ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short halluc  =    (short)0;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short blind  =    (short)0;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short confused  =    (short)0;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short levitate  =    (short)0;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short haste_self  =    (short)0;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
char see_invisible  =    (char)0;
#line 64 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
short extra_hp  =    (short)0;
#line 65 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
char detect_monster  =    (char)0;
#line 66 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
char con_mon  =    (char)0;
#line 67 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
char const   *strange_feeling  =    "you have a strange feeling for a moment, then it passes";
#line 69 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void quaff(void) 
{ 
  short ch ;
  char buf[80] ;
  object *obj ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 76
  ch = pack_letter("quaff what?", (unsigned short)8);
  }
#line 78
  if ((int )ch == 27) {
#line 79
    return;
  }
  {
#line 81
  obj = get_letter_object((int )ch);
  }
#line 81
  if (! obj) {
    {
#line 82
    message("no such item.", (char)0);
    }
#line 83
    return;
  }
#line 85
  if ((int )obj->what_is != 8) {
    {
#line 86
    message("you can\'t drink that", (char)0);
    }
#line 87
    return;
  }
  {
#line 90
  if ((int )obj->which_kind == 0) {
#line 90
    goto case_0;
  }
#line 98
  if ((int )obj->which_kind == 1) {
#line 98
    goto case_1;
  }
#line 102
  if ((int )obj->which_kind == 2) {
#line 102
    goto case_2;
  }
#line 106
  if ((int )obj->which_kind == 3) {
#line 106
    goto case_3;
  }
#line 110
  if ((int )obj->which_kind == 4) {
#line 110
    goto case_4;
  }
#line 122
  if ((int )obj->which_kind == 5) {
#line 122
    goto case_5;
  }
#line 127
  if ((int )obj->which_kind == 6) {
#line 127
    goto case_6;
  }
#line 130
  if ((int )obj->which_kind == 7) {
#line 130
    goto case_7;
  }
#line 134
  if ((int )obj->which_kind == 8) {
#line 134
    goto case_8;
  }
#line 140
  if ((int )obj->which_kind == 9) {
#line 140
    goto case_9;
  }
#line 149
  if ((int )obj->which_kind == 10) {
#line 149
    goto case_10;
  }
#line 154
  if ((int )obj->which_kind == 11) {
#line 154
    goto case_11;
  }
#line 159
  if ((int )obj->which_kind == 12) {
#line 159
    goto case_12;
  }
#line 166
  if ((int )obj->which_kind == 13) {
#line 166
    goto case_13;
  }
#line 89
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 91
  message("you feel stronger now, what bulging muscles!", (char)0);
#line 93
  rogue.str_current = (short )((int )rogue.str_current + 1);
  }
#line 94
  if ((int )rogue.str_current > (int )rogue.str_max) {
#line 95
    rogue.str_max = rogue.str_current;
  }
#line 97
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 99
  rogue.str_current = rogue.str_max;
#line 100
  message("this tastes great, you feel warm all over", (char)0);
  }
#line 101
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 103
  message("you begin to feel better", (char)0);
#line 104
  potion_heal(0);
  }
#line 105
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 107
  message("you begin to feel much better", (char)0);
#line 108
  potion_heal(1);
  }
#line 109
  goto switch_break;
  case_4: /* CIL Label */ 
#line 111
  if (! sustain_strength) {
    {
#line 112
    tmp = get_rand(1, 3);
#line 112
    rogue.str_current = (short )((int )rogue.str_current - tmp);
    }
#line 113
    if ((int )rogue.str_current < 1) {
#line 114
      rogue.str_current = (short)1;
    }
  }
  {
#line 117
  message("you feel very sick now", (char)0);
  }
#line 118
  if (halluc) {
    {
#line 119
    unhallucinate();
    }
  }
#line 121
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 123
  rogue.exp_points = (long )level_points[(int )rogue.exp - 1];
#line 124
  message("you suddenly feel much more skillful", (char)0);
#line 125
  add_exp(1, (char)1);
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 128
  go_blind();
  }
#line 129
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 131
  message("oh wow, everything seems so cosmic", (char)0);
#line 132
  tmp___0 = get_rand(500, 800);
#line 132
  halluc = (short )((int )halluc + tmp___0);
  }
#line 133
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 135
  show_monsters();
  }
#line 136
  if (! level_monsters.next_object) {
    {
#line 137
    message(strange_feeling, (char)0);
    }
  }
#line 139
  goto switch_break;
  case_9: /* CIL Label */ 
#line 141
  if (level_objects.next_object) {
#line 142
    if (! blind) {
      {
#line 143
      show_objects();
      }
    }
  } else {
    {
#line 146
    message(strange_feeling, (char)0);
    }
  }
#line 148
  goto switch_break;
  case_10: /* CIL Label */ 
#line 150
  if (halluc) {
#line 150
    tmp___1 = "what a trippy feeling";
  } else {
#line 150
    tmp___1 = "you feel confused";
  }
  {
#line 150
  message(tmp___1, (char)0);
#line 152
  cnfs();
  }
#line 153
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 155
  message("you start to float in the air", (char)0);
#line 156
  tmp___2 = get_rand(15, 30);
#line 156
  levitate = (short )((int )levitate + tmp___2);
#line 157
  bear_trap = (short)0;
#line 157
  being_held = (char )bear_trap;
  }
#line 158
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 160
  message("you feel yourself moving much faster", (char)0);
#line 161
  tmp___3 = get_rand(11, 21);
#line 161
  haste_self = (short )((int )haste_self + tmp___3);
  }
#line 162
  if (! ((int )haste_self % 2)) {
#line 163
    haste_self = (short )((int )haste_self + 1);
  }
#line 165
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 167
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"hmm, this potion tastes like %sjuice",
          fruit);
#line 168
  message((char const   *)(buf), (char)0);
  }
#line 169
  if (blind) {
    {
#line 170
    unblind();
    }
  }
  {
#line 172
  see_invisible = (char)1;
#line 173
  relight();
  }
#line 174
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 176
  print_stats(12);
  }
#line 177
  if ((int )id_potions[obj->which_kind].id_status != 2) {
#line 178
    id_potions[obj->which_kind].id_status = (unsigned short)1;
  }
  {
#line 180
  vanish(obj, (short)1, & rogue.pack);
  }
#line 181
  return;
}
}
#line 183 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void read_scroll(void) 
{ 
  short ch ;
  object *obj ;
  char msg[80] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 190
  ch = pack_letter("read what?", (unsigned short)4);
  }
#line 192
  if ((int )ch == 27) {
#line 193
    return;
  }
  {
#line 195
  obj = get_letter_object((int )ch);
  }
#line 195
  if (! obj) {
    {
#line 196
    message("no such item.", (char)0);
    }
#line 197
    return;
  }
#line 199
  if ((int )obj->what_is != 4) {
    {
#line 200
    message("you can\'t read that", (char)0);
    }
#line 201
    return;
  }
  {
#line 204
  if ((int )obj->which_kind == 7) {
#line 204
    goto case_7;
  }
#line 208
  if ((int )obj->which_kind == 1) {
#line 208
    goto case_1;
  }
#line 211
  if ((int )obj->which_kind == 2) {
#line 211
    goto case_2;
  }
#line 230
  if ((int )obj->which_kind == 3) {
#line 230
    goto case_3;
  }
#line 242
  if ((int )obj->which_kind == 4) {
#line 242
    goto case_4;
  }
#line 248
  if ((int )obj->which_kind == 5) {
#line 248
    goto case_5;
  }
#line 251
  if ((int )obj->which_kind == 6) {
#line 251
    goto case_6;
  }
#line 255
  if ((int )obj->which_kind == 0) {
#line 255
    goto case_0;
  }
#line 264
  if ((int )obj->which_kind == 8) {
#line 264
    goto case_8;
  }
#line 270
  if ((int )obj->which_kind == 9) {
#line 270
    goto case_9;
  }
#line 273
  if ((int )obj->which_kind == 10) {
#line 273
    goto case_10;
  }
#line 276
  if ((int )obj->which_kind == 11) {
#line 276
    goto case_11;
  }
#line 280
  if ((int )obj->which_kind == 12) {
#line 280
    goto case_12;
  }
#line 203
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 205
  message("you hear a maniacal laughter in the distance", (char)0);
  }
#line 207
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 209
  hold_monster();
  }
#line 210
  goto switch_break;
  case_2: /* CIL Label */ 
#line 212
  if (rogue.weapon) {
#line 213
    if ((int )(rogue.weapon)->what_is == 2) {
      {
#line 214
      tmp = get_ench_color();
      }
#line 214
      if ((int )(rogue.weapon)->quantity <= 1) {
#line 214
        tmp___0 = "s";
      } else {
#line 214
        tmp___0 = "";
      }
      {
#line 214
      tmp___1 = name_of((object const   *)rogue.weapon);
#line 214
      sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"your %sglow%s %sfor a moment",
              tmp___1, tmp___0, tmp);
#line 218
      message((char const   *)(msg), (char)0);
#line 219
      tmp___2 = coin_toss();
      }
#line 219
      if (tmp___2) {
#line 220
        (rogue.weapon)->hit_enchant = (short )((int )(rogue.weapon)->hit_enchant + 1);
      } else {
#line 222
        (rogue.weapon)->d_enchant = (short )((int )(rogue.weapon)->d_enchant + 1);
      }
    }
#line 225
    (rogue.weapon)->is_cursed = (short)0;
  } else {
    {
#line 227
    message("your hands tingle", (char)0);
    }
  }
#line 229
  goto switch_break;
  case_3: /* CIL Label */ 
#line 231
  if (rogue.armor) {
    {
#line 232
    tmp___3 = get_ench_color();
#line 232
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"your armor glows %sfor a moment",
            tmp___3);
#line 234
    message((char const   *)(msg), (char)0);
#line 235
    (rogue.armor)->d_enchant = (short )((int )(rogue.armor)->d_enchant + 1);
#line 236
    (rogue.armor)->is_cursed = (short)0;
#line 237
    print_stats(16);
    }
  } else {
    {
#line 239
    message("your skin crawls", (char)0);
    }
  }
#line 241
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 243
  message("this is a scroll of identify", (char)0);
#line 244
  obj->identified = (short)1;
#line 245
  id_scrolls[obj->which_kind].id_status = (unsigned short)1;
#line 246
  idntfy();
  }
#line 247
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 249
  tele();
  }
#line 250
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 252
  message("you fall asleep", (char)0);
#line 253
  take_a_nap();
  }
#line 254
  goto switch_break;
  case_0: /* CIL Label */ 
#line 256
  if (rogue.armor) {
    {
#line 257
    message("your armor is covered by a shimmering gold shield", (char)0);
#line 258
    (rogue.armor)->is_protected = (short)1;
#line 259
    (rogue.armor)->is_cursed = (short)0;
    }
  } else {
    {
#line 261
    message("your acne seems to have disappeared", (char)0);
    }
  }
#line 263
  goto switch_break;
  case_8: /* CIL Label */ 
#line 265
  if (! halluc) {
#line 265
    tmp___4 = "you feel as though someone is watching over you";
  } else {
#line 265
    tmp___4 = "you feel in touch with the universal oneness";
  }
  {
#line 265
  message(tmp___4, (char)0);
#line 268
  uncurse_all();
  }
#line 269
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 271
  create_monster();
  }
#line 272
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 274
  aggravate();
  }
#line 275
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 277
  message("this scroll seems to have a map on it", (char)0);
#line 278
  draw_magic_map();
  }
#line 279
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 281
  con_mon = (char)1;
#line 282
  tmp___5 = get_ench_color();
#line 282
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"your hands glow %sfor a moment",
          tmp___5);
#line 283
  message((char const   *)(msg), (char)0);
  }
#line 284
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 286
  if ((int )id_scrolls[obj->which_kind].id_status != 2) {
#line 287
    id_scrolls[obj->which_kind].id_status = (unsigned short)1;
  }
  {
#line 289
  vanish(obj, (short )((int )obj->which_kind != 6), & rogue.pack);
  }
#line 290
  return;
}
}
#line 296 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void vanish(object *obj , short rm , object *pack ) 
{ 


  {
#line 302
  if ((int )obj->quantity > 1) {
#line 303
    obj->quantity = (short )((int )obj->quantity - 1);
  } else {
#line 305
    if ((int )obj->in_use_flags & 1) {
      {
#line 306
      unwield(obj);
      }
    } else
#line 307
    if ((int )obj->in_use_flags & 2) {
      {
#line 308
      unwear(obj);
      }
    } else
#line 309
    if ((int )obj->in_use_flags & 12) {
      {
#line 310
      un_put_on(obj);
      }
    }
    {
#line 312
    take_from_pack(obj, pack);
#line 313
    free_object(obj);
    }
  }
#line 315
  if (rm) {
    {
#line 316
    reg_move();
    }
  }
#line 318
  return;
}
}
#line 320 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void potion_heal(int extra ) 
{ 
  float ratio ;
  short add ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 327
  rogue.hp_current = (short )((int )rogue.hp_current + (int )rogue.exp);
#line 329
  ratio = (float )rogue.hp_current / (float )rogue.hp_max;
#line 331
  if ((double )ratio >= 1.00) {
#line 332
    if (extra) {
#line 332
      tmp = 2;
    } else {
#line 332
      tmp = 1;
    }
#line 332
    rogue.hp_max = (short )((int )rogue.hp_max + tmp);
#line 333
    if (extra) {
#line 333
      tmp___0 = 2;
    } else {
#line 333
      tmp___0 = 1;
    }
#line 333
    extra_hp = (short )((int )extra_hp + tmp___0);
#line 334
    rogue.hp_current = rogue.hp_max;
  } else
#line 335
  if ((double )ratio >= 0.90) {
#line 336
    if (extra) {
#line 336
      tmp___1 = 1;
    } else {
#line 336
      tmp___1 = 0;
    }
#line 336
    rogue.hp_max = (short )((int )rogue.hp_max + tmp___1);
#line 337
    if (extra) {
#line 337
      tmp___2 = 1;
    } else {
#line 337
      tmp___2 = 0;
    }
#line 337
    extra_hp = (short )((int )extra_hp + tmp___2);
#line 338
    rogue.hp_current = rogue.hp_max;
  } else {
#line 340
    if ((double )ratio < 0.33) {
#line 341
      ratio = (float )0.33;
    }
#line 343
    if (extra) {
#line 344
      ratio += ratio;
    }
#line 346
    add = (short )(ratio * ((float )rogue.hp_max - (float )rogue.hp_current));
#line 347
    rogue.hp_current = (short )((int )rogue.hp_current + (int )add);
#line 348
    if ((int )rogue.hp_current > (int )rogue.hp_max) {
#line 349
      rogue.hp_current = rogue.hp_max;
    }
  }
#line 352
  if (blind) {
    {
#line 353
    unblind();
    }
  }
#line 355
  if (confused) {
#line 355
    if (extra) {
      {
#line 356
      unconfuse();
      }
    } else {
#line 355
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 357
  if (confused) {
#line 358
    confused = (short )((int )confused / 2 + 1);
  }
#line 360
  if (halluc) {
#line 360
    if (extra) {
      {
#line 361
      unhallucinate();
      }
    } else {
#line 360
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 362
  if (halluc) {
#line 363
    halluc = (short )((int )halluc / 2 + 1);
  }
#line 365
  return;
}
}
#line 367 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void idntfy(void) 
{ 
  short ch ;
  object *obj ;
  struct id *id_table ;
  char desc[80] ;

  {
  AGAIN: 
  {
#line 375
  ch = pack_letter("what would you like to identify?", (unsigned short)511);
  }
#line 377
  if ((int )ch == 27) {
#line 378
    return;
  }
  {
#line 380
  obj = get_letter_object((int )ch);
  }
#line 380
  if (! obj) {
    {
#line 381
    message("no such item, try again", (char)0);
#line 382
    message("", (char)0);
#line 383
    check_message();
    }
#line 384
    goto AGAIN;
  }
#line 386
  obj->identified = (short)1;
#line 387
  if ((int )obj->what_is & 207) {
    {
#line 388
    id_table = get_id_table((object const   *)obj);
#line 389
    (id_table + obj->which_kind)->id_status = (unsigned short)1;
    }
  }
  {
#line 391
  get_desc((object const   *)obj, desc);
#line 392
  message((char const   *)(desc), (char)0);
  }
#line 393
  return;
}
}
#line 395 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void eat(void) 
{ 
  short ch ;
  short moves ;
  object *obj ;
  char buf[70] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 403
  ch = pack_letter("eat what?", (unsigned short)32);
  }
#line 405
  if ((int )ch == 27) {
#line 406
    return;
  }
  {
#line 408
  obj = get_letter_object((int )ch);
  }
#line 408
  if (! obj) {
    {
#line 409
    message("no such item.", (char)0);
    }
#line 410
    return;
  }
#line 412
  if ((int )obj->what_is != 32) {
    {
#line 413
    message("you can\'t eat that", (char)0);
    }
#line 414
    return;
  }
#line 416
  if ((int )obj->which_kind == 1) {
#line 416
    goto _L;
  } else {
    {
#line 416
    tmp___1 = rand_percent(60);
    }
#line 416
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 417
      tmp = get_rand(950, 1150);
#line 417
      moves = (short )tmp;
      }
#line 418
      if ((int )obj->which_kind == 0) {
        {
#line 419
        message("yum, that tasted good", (char)0);
        }
      } else {
        {
#line 421
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"my, that was a yummy %s",
                fruit);
#line 422
        message((char const   *)(buf), (char)0);
        }
      }
    } else {
      {
#line 425
      tmp___0 = get_rand(750, 950);
#line 425
      moves = (short )tmp___0;
#line 426
      message("yuk, that food tasted awful", (char)0);
#line 427
      add_exp(2, (char)1);
      }
    }
  }
  {
#line 429
  rogue.moves_left = (short )((int )rogue.moves_left / 3);
#line 430
  rogue.moves_left = (short )((int )rogue.moves_left + (int )moves);
#line 431
  hunger_str[0] = (char)0;
#line 432
  print_stats(64);
#line 434
  vanish(obj, (short)1, & rogue.pack);
  }
#line 435
  return;
}
}
#line 437 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void hold_monster(void) 
{ 
  short i ;
  short j ;
  short mcount ;
  object *monster ;
  short row___0 ;
  short col___0 ;

  {
#line 441
  mcount = (short)0;
#line 445
  i = (short)-2;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! ((int )i <= 2)) {
#line 445
      goto while_break;
    }
#line 446
    j = (short)-2;
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 446
      if (! ((int )j <= 2)) {
#line 446
        goto while_break___0;
      }
#line 447
      row___0 = (short )((int )rogue.row + (int )i);
#line 448
      col___0 = (short )((int )rogue.col + (int )j);
#line 449
      if ((int )row___0 < 1) {
#line 451
        goto __Cont;
      } else
#line 449
      if ((int )row___0 > 22) {
#line 451
        goto __Cont;
      } else
#line 449
      if ((int )col___0 < 0) {
#line 451
        goto __Cont;
      } else
#line 449
      if ((int )col___0 > 79) {
#line 451
        goto __Cont;
      }
#line 453
      if ((int )dungeon[row___0][col___0] & 2) {
        {
#line 454
        monster = object_at(& level_monsters, row___0, col___0);
#line 455
        monster->m_flags |= 8UL;
#line 456
        monster->m_flags &= 0xffffffffffffffefUL;
#line 457
        mcount = (short )((int )mcount + 1);
        }
      }
      __Cont: /* CIL Label */ 
#line 446
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 445
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  if ((int )mcount == 0) {
    {
#line 462
    message("you feel a strange sense of loss", (char)0);
    }
  } else
#line 463
  if ((int )mcount == 1) {
    {
#line 464
    message("the monster freezes", (char)0);
    }
  } else {
    {
#line 466
    message("the monsters around you freeze", (char)0);
    }
  }
#line 468
  return;
}
}
#line 470 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void tele(void) 
{ 
  char tmp ;
  int tmp___0 ;
  short tmp___1 ;

  {
  {
#line 473
  tmp___0 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 473
  if (! (tmp___0 == -1)) {
    {
#line 473
    tmp = get_dungeon_char(rogue.row, rogue.col);
#line 473
    waddch(stdscr, (chtype const   )tmp);
    }
  }
#line 475
  if ((int )cur_room >= 0) {
    {
#line 476
    darken_room(cur_room);
    }
  }
  {
#line 478
  tmp___1 = get_room_number((int )rogue.row, (int )rogue.col);
#line 478
  put_player(tmp___1);
#line 479
  being_held = (char)0;
#line 480
  bear_trap = (short)0;
  }
#line 481
  return;
}
}
#line 483 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void hallucinate(void) 
{ 
  object *obj ;
  object *monster ;
  short ch ;
  chtype tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  chtype tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 489
  if (blind) {
#line 489
    return;
  }
#line 491
  obj = level_objects.next_object;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! obj) {
#line 493
      goto while_break;
    }
    {
#line 494
    tmp___1 = wmove(stdscr, (int )obj->row, (int )obj->col);
    }
#line 494
    if (tmp___1 == -1) {
#line 494
      ch = (short )((chtype )-1);
    } else {
      {
#line 494
      tmp___0 = winch(stdscr);
#line 494
      ch = (short )tmp___0;
      }
    }
#line 495
    if ((int )ch < 65) {
#line 495
      goto _L___0;
    } else
#line 495
    if ((int )ch > 90) {
      _L___0: /* CIL Label */ 
#line 495
      if ((int )obj->row != (int )rogue.row) {
#line 495
        goto _L;
      } else
#line 495
      if ((int )obj->col != (int )rogue.col) {
        _L: /* CIL Label */ 
#line 497
        if ((int )ch != 32) {
#line 497
          if ((int )ch != 46) {
#line 497
            if ((int )ch != 35) {
#line 497
              if ((int )ch != 43) {
                {
#line 498
                tmp___2 = gr_obj_char();
#line 498
                waddch(stdscr, (chtype const   )tmp___2);
                }
              }
            }
          }
        }
      }
    }
#line 500
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  monster = level_monsters.next_object;
  {
#line 504
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 504
    if (! monster) {
#line 504
      goto while_break___0;
    }
    {
#line 505
    tmp___5 = wmove(stdscr, (int )monster->row, (int )monster->col);
    }
#line 505
    if (tmp___5 == -1) {
#line 505
      ch = (short )((chtype )-1);
    } else {
      {
#line 505
      tmp___4 = winch(stdscr);
#line 505
      ch = (short )tmp___4;
      }
    }
#line 506
    if ((int )ch >= 65) {
#line 506
      if ((int )ch <= 90) {
        {
#line 507
        tmp___6 = get_rand('A', 'Z');
#line 507
        waddch(stdscr, (chtype const   )tmp___6);
        }
      }
    }
#line 509
    monster = monster->next_object;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 511
  return;
}
}
#line 513 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void unhallucinate(void) 
{ 


  {
  {
#line 516
  halluc = (short)0;
#line 517
  relight();
#line 518
  message("everything looks SO boring now", (char)1);
  }
#line 519
  return;
}
}
#line 521 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void unblind(void) 
{ 


  {
  {
#line 524
  blind = (short)0;
#line 525
  message("the veil of darkness lifts", (char)1);
#line 526
  relight();
  }
#line 527
  if (halluc) {
    {
#line 528
    hallucinate();
    }
  }
#line 530
  if (detect_monster) {
    {
#line 531
    show_monsters();
    }
  }
#line 533
  return;
}
}
#line 535 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void relight(void) 
{ 
  int tmp ;

  {
#line 538
  if ((int )cur_room == -3) {
    {
#line 539
    light_passage((int )rogue.row, (int )rogue.col);
    }
  } else {
    {
#line 541
    light_up_room((int )cur_room);
    }
  }
  {
#line 543
  tmp = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 543
  if (! (tmp == -1)) {
    {
#line 543
    waddch(stdscr, (chtype const   )rogue.fchar);
    }
  }
#line 544
  return;
}
}
#line 546 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void take_a_nap(void) 
{ 
  short i ;
  int tmp ;
  short tmp___0 ;

  {
  {
#line 551
  tmp = get_rand(2, 5);
#line 551
  i = (short )tmp;
#line 552
  md_sleep(1);
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    tmp___0 = i;
#line 554
    i = (short )((int )i - 1);
#line 554
    if (! tmp___0) {
#line 554
      goto while_break;
    }
    {
#line 555
    mv_mons();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 557
  md_sleep(1);
#line 558
  message(you_can_move_again, (char)0);
  }
#line 559
  return;
}
}
#line 561 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void go_blind(void) 
{ 
  short i ;
  short j ;
  int tmp ;
  object *monster ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 566
  if (! blind) {
    {
#line 567
    message("a cloak of darkness falls around you", (char)0);
    }
  }
  {
#line 569
  tmp = get_rand(500, 800);
#line 569
  blind = (short )((int )blind + tmp);
  }
#line 571
  if (detect_monster) {
#line 574
    monster = level_monsters.next_object;
    {
#line 576
    while (1) {
      while_continue: /* CIL Label */ ;
#line 576
      if (! monster) {
#line 576
        goto while_break;
      }
      {
#line 577
      tmp___0 = wmove(stdscr, (int )monster->row, (int )monster->col);
      }
#line 577
      if (! (tmp___0 == -1)) {
        {
#line 577
        waddch(stdscr, (chtype const   )monster->d_enchant);
        }
      }
#line 578
      monster = monster->next_object;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 581
  if ((int )cur_room >= 0) {
#line 582
    i = (short )((int )rooms[cur_room].top_row + 1);
    {
#line 582
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 582
      if (! ((int )i < (int )rooms[cur_room].bottom_row)) {
#line 582
        goto while_break___0;
      }
#line 584
      j = (short )((int )rooms[cur_room].left_col + 1);
      {
#line 584
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 584
        if (! ((int )j < (int )rooms[cur_room].right_col)) {
#line 584
          goto while_break___1;
        }
        {
#line 586
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 586
        if (! (tmp___1 == -1)) {
          {
#line 586
          waddch(stdscr, (chtype const   )' ');
          }
        }
#line 584
        j = (short )((int )j + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 582
      i = (short )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 590
  tmp___2 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 590
  if (! (tmp___2 == -1)) {
    {
#line 590
    waddch(stdscr, (chtype const   )rogue.fchar);
    }
  }
#line 591
  return;
}
}
#line 593 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
char const   *get_ench_color(void) 
{ 
  int tmp ;

  {
#line 596
  if (halluc) {
    {
#line 597
    tmp = get_rand(0, 13);
    }
#line 597
    return ((char const   *)(id_potions[tmp].title));
  } else
#line 598
  if (con_mon) {
#line 599
    return ("red ");
  }
#line 601
  return ("blue ");
}
}
#line 604 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void cnfs(void) 
{ 
  int tmp ;

  {
  {
#line 607
  tmp = get_rand(12, 22);
#line 607
  confused = (short )((int )confused + tmp);
  }
#line 608
  return;
}
}
#line 610 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void unconfuse(void) 
{ 
  char msg[80] ;
  char const   *tmp ;

  {
#line 615
  confused = (short)0;
#line 616
  if (halluc) {
#line 616
    tmp = "trippy";
  } else {
#line 616
    tmp = "confused";
  }
  {
#line 616
  sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"you feel less %s now",
          tmp);
#line 617
  message((char const   *)(msg), (char)1);
  }
#line 618
  return;
}
}
#line 620 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/use.c"
void uncurse_all(void) 
{ 
  object *obj ;

  {
#line 625
  obj = rogue.pack.next_object;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! obj) {
#line 627
      goto while_break;
    }
#line 628
    obj->is_cursed = (short)0;
#line 629
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return;
}
}
#line 673 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
long rrandom(void) ;
#line 695
void srrandom(int x ) ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static long rntb[32]  = 
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
  {      3L,      2586939449L,      853131300L,      2607165826L, 
        1570894658L,      3728441824L,      3742003125L,      4043553794L, 
        1223901435L,      1950999915L,      3199327152L,      2874956056L, 
        2489668861L,      2351851535L,      3946674591L,      2971590839L, 
        759393158L,      3664195114L,      361286280L,      3815338845L, 
        2421110263L,      3608514518L,      1873211473L,      1634626454L, 
        2895441884L,      910245779L,      3324166808L,      4121176760L, 
        2324223867L,      4121795854L,      2308514315L,      670779321L};
#line 68 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static long *fptr  =    & rntb[4];
#line 69 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static long *rptr  =    & rntb[1];
#line 70 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static long *state  =    & rntb[1];
#line 71 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static int rand_type  =    3;
#line 72 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static int rand_deg  =    31;
#line 73 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static int rand_sep  =    3;
#line 74 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
static long *end_ptr  =    & rntb[32];
#line 76 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
void srrandom(int x ) 
{ 
  int i ;

  {
#line 82
  *(state + 0) = (long )x;
#line 83
  if (rand_type != 0) {
#line 84
    i = 1;
    {
#line 84
    while (1) {
      while_continue: /* CIL Label */ ;
#line 84
      if (! (i < rand_deg)) {
#line 84
        goto while_break;
      }
#line 85
      *(state + i) = 1103515245L * *(state + (i - 1)) + 12345L;
#line 84
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 87
    fptr = state + rand_sep;
#line 88
    rptr = state + 0;
#line 89
    i = 0;
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 89
      if (! (i < 10 * rand_deg)) {
#line 89
        goto while_break___0;
      }
      {
#line 90
      rrandom();
#line 89
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 93
  return;
}
}
#line 95 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
long rrandom(void) 
{ 
  long i ;
  long tmp ;

  {
#line 100
  if (rand_type == 0) {
#line 101
    tmp = (*(state + 0) * 1103515245L + 12345L) & 2147483647L;
#line 101
    *(state + 0) = tmp;
#line 101
    i = tmp;
  } else {
#line 103
    *fptr += *rptr;
#line 104
    i = (*fptr >> 1) & 2147483647L;
#line 105
    fptr ++;
#line 105
    if ((unsigned long )fptr >= (unsigned long )end_ptr) {
#line 106
      fptr = state;
#line 107
      rptr ++;
    } else {
#line 109
      rptr ++;
#line 109
      if ((unsigned long )rptr >= (unsigned long )end_ptr) {
#line 110
        rptr = state;
      }
    }
  }
#line 114
  return (i);
}
}
#line 117 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
int get_rand(int x , int y ) 
{ 
  int r ;
  int t ;
  long lr ;

  {
#line 124
  if (x > y) {
#line 125
    t = y;
#line 126
    y = x;
#line 127
    x = t;
  }
  {
#line 129
  lr = rrandom();
#line 130
  lr &= 16383L;
#line 131
  r = (int )lr;
#line 132
  r = r % ((y - x) + 1) + x;
  }
#line 133
  return (r);
}
}
#line 136 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
int rand_percent(int percentage ) 
{ 
  int tmp ;

  {
  {
#line 140
  tmp = get_rand(1, 100);
  }
#line 140
  return (tmp <= percentage);
}
}
#line 143 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/random.c"
int coin_toss(void) 
{ 
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 146
  tmp___1 = rrandom();
  }
#line 146
  if (tmp___1 & 1L) {
#line 146
    tmp___0 = 1;
  } else {
#line 146
    tmp___0 = 0;
  }
#line 146
  return (tmp___0);
}
}
#line 464 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void add_traps(void) ;
#line 481
void clear_level(void) ;
#line 514
void free_stuff(object *objlist ) ;
#line 563
int init(int argc , char **argv ) ;
#line 581
void make_level(void) ;
#line 643
void put_mons(void) ;
#line 644
void put_objects(void) ;
#line 648
void put_stairs(void) ;
#line 795
short party_room ;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/main.c"
int main(int argc , char **argv ) ;
#line 65 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/main.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = init(argc, argv);
  }
#line 70
  if (tmp) {
#line 71
    goto PL;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    clear_level();
#line 76
    make_level();
#line 77
    put_objects();
#line 78
    put_stairs();
#line 79
    add_traps();
#line 80
    put_mons();
#line 81
    put_player(party_room);
#line 82
    print_stats(255);
    }
    PL: 
    {
#line 84
    play_level();
#line 85
    free_stuff(& level_objects);
#line 86
    free_stuff(& level_monsters);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 461 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object *pick_up(int row___0 , int col___0 , short *status ) ;
#line 472
char can_move(int row1 , int col1 , int row2 , int col2 ) ;
#line 473
char can_turn(short nrow , short ncol ) ;
#line 476
char check_hunger(char msg_only ) ;
#line 521
void get_dir_rc(short dir , short *row___0 , short *col___0 , short allow_off_screen ) ;
#line 541
char gr_dir(void) ;
#line 553
void heal(void) ;
#line 571
char is_direction(short c___0 , short *d ) ;
#line 573
char is_passable(int row___0 , int col___0 ) ;
#line 576
 __attribute__((__noreturn__)) void killed_by(object const   *monster , short other ) ;
#line 618
char next_to_something(int drow , int dcol ) ;
#line 671
void rogue_hit(object *monster , char force_hit ) ;
#line 693
void sound_bell(void) ;
#line 710
extern void trap_player(int  , int  ) ;
#line 712
void turn_passage(short dir , char fast ) ;
#line 723
void wake_room(short rn , char entering , short row___0 , short col___0 ) ;
#line 725
void wanderer(void) ;
#line 749
char jump ;
#line 754
char passgo ;
#line 784
short cur_level ;
#line 793
short m_moves ;
#line 794
short max_level ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
short m_moves  =    (short)0;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char jump  =    (char)0;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char const   *you_can_move_again  =    "you can move again";
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
int one_move_rogue(short dirch , short pickup ) 
{ 
  short row___0 ;
  short col___0 ;
  object *obj ;
  char desc[80] ;
  short n___0 ;
  short status ;
  short d ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;
  object *tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char tmp___7 ;
  int tmp___8 ;

  {
#line 71
  row___0 = rogue.row;
#line 72
  col___0 = rogue.col;
#line 74
  if (confused) {
    {
#line 75
    tmp = gr_dir();
#line 75
    dirch = (short )tmp;
    }
  }
  {
#line 77
  is_direction(dirch, & d);
#line 78
  get_dir_rc(d, & row___0, & col___0, (short)1);
#line 80
  tmp___0 = can_move((int )rogue.row, (int )rogue.col, (int )row___0, (int )col___0);
  }
#line 80
  if (! tmp___0) {
#line 81
    return (-1);
  }
#line 83
  if (being_held) {
#line 83
    goto _L;
  } else
#line 83
  if (bear_trap) {
    _L: /* CIL Label */ 
#line 84
    if (! ((int )dungeon[row___0][col___0] & 2)) {
#line 85
      if (being_held) {
        {
#line 86
        message("you are being held", (char)1);
        }
      } else {
        {
#line 88
        message("you are still stuck in the bear trap", (char)0);
#line 89
        reg_move();
        }
      }
#line 91
      return (-1);
    }
  }
#line 94
  if (r_teleport) {
    {
#line 95
    tmp___1 = rand_percent(8);
    }
#line 95
    if (tmp___1) {
      {
#line 96
      tele();
      }
#line 97
      return (-2);
    }
  }
#line 100
  if ((int )dungeon[row___0][col___0] & 2) {
    {
#line 101
    tmp___2 = object_at(& level_monsters, row___0, col___0);
#line 101
    rogue_hit(tmp___2, (char)0);
#line 102
    reg_move();
    }
#line 103
    return (-1);
  }
#line 105
  if ((int )dungeon[row___0][col___0] & 32) {
#line 106
    if ((int )cur_room == -3) {
      {
#line 107
      cur_room = get_room_number((int )row___0, (int )col___0);
#line 108
      light_up_room((int )cur_room);
#line 109
      wake_room(cur_room, (char)1, row___0, col___0);
      }
    } else {
      {
#line 111
      light_passage((int )row___0, (int )col___0);
      }
    }
  } else
#line 113
  if ((int )dungeon[rogue.row][rogue.col] & 32) {
#line 113
    if ((int )dungeon[row___0][col___0] & 128) {
      {
#line 115
      light_passage((int )row___0, (int )col___0);
#line 116
      wake_room(cur_room, (char)0, rogue.row, rogue.col);
#line 117
      darken_room(cur_room);
#line 118
      cur_room = (short)-3;
      }
    } else {
#line 113
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 119
  if ((int )dungeon[row___0][col___0] & 128) {
    {
#line 120
    light_passage((int )row___0, (int )col___0);
    }
  }
  {
#line 122
  tmp___4 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 122
  if (! (tmp___4 == -1)) {
    {
#line 122
    tmp___3 = get_dungeon_char(rogue.row, rogue.col);
#line 122
    waddch(stdscr, (chtype const   )tmp___3);
    }
  }
  {
#line 123
  tmp___5 = wmove(stdscr, (int )row___0, (int )col___0);
  }
#line 123
  if (! (tmp___5 == -1)) {
    {
#line 123
    waddch(stdscr, (chtype const   )rogue.fchar);
    }
  }
#line 125
  if (! jump) {
    {
#line 126
    wrefresh(stdscr);
    }
  }
#line 128
  rogue.row = row___0;
#line 129
  rogue.col = col___0;
#line 130
  if ((int )dungeon[row___0][col___0] & 1) {
#line 131
    if (levitate) {
#line 131
      if (pickup) {
#line 132
        return (-2);
      }
    }
#line 134
    if (pickup) {
#line 134
      if (! levitate) {
        {
#line 135
        obj = pick_up((int )row___0, (int )col___0, & status);
        }
#line 135
        if ((unsigned long )obj != (unsigned long )((void *)0)) {
          {
#line 136
          get_desc((object const   *)obj, desc);
          }
#line 137
          if ((int )obj->what_is == 16) {
            {
#line 138
            free_object(obj);
            }
#line 139
            goto NOT_IN_PACK;
          }
        } else
#line 141
        if (! status) {
#line 142
          goto MVED;
        } else {
#line 144
          goto MOVE_ON;
        }
      } else {
#line 134
        goto MOVE_ON;
      }
    } else {
      MOVE_ON: 
      {
#line 148
      obj = object_at(& level_objects, row___0, col___0);
#line 149
      strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"moved onto ");
#line 150
      get_desc((object const   *)obj, desc + 11);
      }
#line 151
      goto NOT_IN_PACK;
    }
    {
#line 153
    tmp___6 = strlen((char const   *)(desc));
#line 153
    n___0 = (short )tmp___6;
#line 154
    desc[n___0] = (char )'(';
#line 155
    desc[(int )n___0 + 1] = (char )obj->ichar;
#line 156
    desc[(int )n___0 + 2] = (char )')';
#line 157
    desc[(int )n___0 + 3] = (char)0;
    }
    NOT_IN_PACK: 
    {
#line 159
    message((char const   *)(desc), (char)1);
#line 160
    reg_move();
    }
#line 161
    return (-2);
  }
#line 163
  if ((int )dungeon[row___0][col___0] & 292) {
#line 164
    if (! levitate) {
#line 164
      if ((int )dungeon[row___0][col___0] & 256) {
        {
#line 165
        trap_player((int )row___0, (int )col___0);
        }
      }
    }
    {
#line 167
    reg_move();
    }
#line 168
    return (-2);
  }
  MVED: 
  {
#line 170
  tmp___7 = reg_move();
  }
#line 170
  if (tmp___7) {
#line 171
    return (-2);
  }
#line 173
  if (confused) {
#line 173
    tmp___8 = -2;
  } else {
#line 173
    tmp___8 = 0;
  }
#line 173
  return (tmp___8);
}
}
#line 176 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
void multiple_move_rogue(short dirch ) 
{ 
  short row___0 ;
  short col___0 ;
  short m ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
  {
#line 191
  if ((int )dirch == 2) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 14) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 21) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 25) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 12) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 11) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 10) {
#line 191
    goto case_2;
  }
#line 191
  if ((int )dirch == 8) {
#line 191
    goto case_2;
  }
#line 213
  if ((int )dirch == 78) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 85) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 89) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 66) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 76) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 75) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 74) {
#line 213
    goto case_78;
  }
#line 213
  if ((int )dirch == 72) {
#line 213
    goto case_78;
  }
#line 183
  goto switch_break;
  case_2: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    row___0 = rogue.row;
#line 194
    col___0 = rogue.col;
#line 195
    tmp = one_move_rogue((short )((int )dirch + 96), (short)1);
#line 195
    m = (short )tmp;
    }
#line 195
    if ((int )m == -1) {
#line 198
      goto while_break;
    } else
#line 195
    if ((int )m == -2) {
#line 198
      goto while_break;
    } else
#line 195
    if (interrupted) {
#line 198
      goto while_break;
    }
    {
#line 192
    tmp___0 = next_to_something((int )row___0, (int )col___0);
    }
#line 192
    if (tmp___0) {
#line 192
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  if (! interrupted) {
#line 201
    if (passgo) {
#line 201
      if ((int )m == -1) {
#line 201
        if ((int )dungeon[rogue.row][rogue.col] & 128) {
          {
#line 203
          turn_passage((short )((int )dirch + 96), (char)0);
          }
        }
      }
    }
  }
#line 205
  goto switch_break;
  case_78: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_72: /* CIL Label */ 
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 214
    if (! interrupted) {
      {
#line 214
      tmp___1 = one_move_rogue((short )((int )dirch + 32), (short)1);
      }
#line 214
      if (! (tmp___1 == 0)) {
#line 214
        goto while_break___0;
      }
    } else {
#line 214
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  if (! interrupted) {
#line 216
    if (passgo) {
#line 216
      if ((int )dungeon[rogue.row][rogue.col] & 128) {
        {
#line 218
        turn_passage((short )((int )dirch + 32), (char)1);
        }
      }
    }
  }
#line 220
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 224 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char is_passable(int row___0 , int col___0 ) 
{ 
  int tmp ;

  {
#line 228
  if (row___0 < 1) {
#line 230
    return ((char)0);
  } else
#line 228
  if (row___0 > 22) {
#line 230
    return ((char)0);
  } else
#line 228
  if (col___0 < 0) {
#line 230
    return ((char)0);
  } else
#line 228
  if (col___0 > 79) {
#line 230
    return ((char)0);
  }
#line 232
  if ((int )dungeon[row___0][col___0] & 512) {
#line 233
    if ((int )dungeon[row___0][col___0] & 256) {
#line 233
      tmp = 1;
    } else {
#line 233
      tmp = 0;
    }
#line 233
    return ((char )tmp);
  }
#line 235
  return ((char )((int )dungeon[row___0][col___0] & 484));
}
}
#line 238 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char next_to_something(int drow , int dcol ) 
{ 
  short i ;
  short j ;
  short i_end ;
  short j_end ;
  short row___0 ;
  short col___0 ;
  short pass_count ;
  unsigned short s___0 ;

  {
#line 243
  pass_count = (short)0;
#line 246
  if (confused) {
#line 247
    return ((char)1);
  }
#line 249
  if (blind) {
#line 250
    return ((char)0);
  }
#line 252
  if ((int )rogue.row < 22) {
#line 252
    i_end = (short)1;
  } else {
#line 252
    i_end = (short)0;
  }
#line 253
  if ((int )rogue.col < 79) {
#line 253
    j_end = (short)1;
  } else {
#line 253
    j_end = (short)0;
  }
#line 255
  if ((int )rogue.row > 1) {
#line 255
    i = (short)-1;
  } else {
#line 255
    i = (short)0;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((int )i <= (int )i_end)) {
#line 255
      goto while_break;
    }
#line 256
    if ((int )rogue.col > 0) {
#line 256
      j = (short)-1;
    } else {
#line 256
      j = (short)0;
    }
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! ((int )j <= (int )j_end)) {
#line 256
        goto while_break___0;
      }
#line 257
      if ((int )i == 0) {
#line 257
        if ((int )j == 0) {
#line 258
          goto __Cont;
        }
      }
#line 260
      if ((int )rogue.row + (int )i == drow) {
#line 260
        if ((int )rogue.col + (int )j == dcol) {
#line 261
          goto __Cont;
        }
      }
#line 263
      row___0 = (short )((int )rogue.row + (int )i);
#line 264
      col___0 = (short )((int )rogue.col + (int )j);
#line 265
      s___0 = dungeon[row___0][col___0];
#line 266
      if ((int )s___0 & 512) {
#line 267
        goto __Cont;
      }
#line 271
      if ((int )s___0 & 7) {
#line 272
        if ((int )row___0 == drow) {
#line 272
          goto _L;
        } else
#line 272
        if ((int )col___0 == dcol) {
          _L: /* CIL Label */ 
#line 272
          if (! ((int )row___0 == (int )rogue.row)) {
#line 272
            if (! ((int )col___0 == (int )rogue.col)) {
#line 274
              goto __Cont;
            }
          }
        }
#line 276
        return ((char)1);
      }
#line 278
      if ((int )s___0 & 256) {
#line 279
        if (! ((int )s___0 & 512)) {
#line 280
          if ((int )row___0 == drow) {
#line 280
            goto _L___0;
          } else
#line 280
          if ((int )col___0 == dcol) {
            _L___0: /* CIL Label */ 
#line 280
            if (! ((int )row___0 == (int )rogue.row)) {
#line 280
              if (! ((int )col___0 == (int )rogue.col)) {
#line 282
                goto __Cont;
              }
            }
          }
#line 284
          return ((char)1);
        }
      }
#line 287
      if ((int )i - (int )j == 1) {
#line 287
        goto _L___1;
      } else
#line 287
      if ((int )i - (int )j == -1) {
        _L___1: /* CIL Label */ 
#line 287
        if ((int )s___0 & 128) {
#line 288
          pass_count = (short )((int )pass_count + 1);
#line 288
          if ((int )pass_count > 1) {
#line 289
            return ((char)1);
          }
        }
      }
#line 292
      if ((int )s___0 & 32) {
#line 292
        if ((int )i == 0) {
#line 293
          return ((char)1);
        } else
#line 292
        if ((int )j == 0) {
#line 293
          return ((char)1);
        }
      }
      __Cont: /* CIL Label */ 
#line 256
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 255
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return ((char)0);
}
}
#line 300 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char can_move(int row1 , int col1 , int row2 , int col2 ) 
{ 
  char tmp ;

  {
  {
#line 304
  tmp = is_passable(row2, col2);
  }
#line 304
  if (! tmp) {
#line 305
    return ((char)0);
  }
#line 307
  if (row1 != row2) {
#line 307
    if (col1 != col2) {
#line 308
      if ((int )dungeon[row1][col1] & 32) {
#line 309
        return ((char)0);
      } else
#line 308
      if ((int )dungeon[row2][col2] & 32) {
#line 309
        return ((char)0);
      }
#line 311
      if (! dungeon[row1][col2]) {
#line 312
        return ((char)0);
      } else
#line 311
      if (! dungeon[row2][col1]) {
#line 312
        return ((char)0);
      }
    }
  }
#line 315
  return ((char)1);
}
}
#line 318 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
void move_onto(void) 
{ 
  short ch ;
  short d ;
  char first_miss ;
  int tmp ;
  char tmp___0 ;

  {
#line 322
  first_miss = (char)1;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    tmp = rgetchar();
#line 324
    ch = (short )tmp;
#line 324
    tmp___0 = is_direction(ch, & d);
    }
#line 324
    if (tmp___0) {
#line 324
      goto while_break;
    }
    {
#line 325
    sound_bell();
    }
#line 326
    if (first_miss) {
      {
#line 327
      message("direction? ", (char)0);
#line 328
      first_miss = (char)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 331
  check_message();
  }
#line 332
  if ((int )ch != 27) {
    {
#line 333
    one_move_rogue(ch, (short)0);
    }
  }
#line 335
  return;
}
}
#line 337 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char is_direction(short c___0 , short *d ) 
{ 


  {
  {
#line 343
  if ((int )c___0 == 104) {
#line 343
    goto case_104;
  }
#line 346
  if ((int )c___0 == 106) {
#line 346
    goto case_106;
  }
#line 349
  if ((int )c___0 == 107) {
#line 349
    goto case_107;
  }
#line 352
  if ((int )c___0 == 108) {
#line 352
    goto case_108;
  }
#line 355
  if ((int )c___0 == 98) {
#line 355
    goto case_98;
  }
#line 358
  if ((int )c___0 == 121) {
#line 358
    goto case_121;
  }
#line 361
  if ((int )c___0 == 117) {
#line 361
    goto case_117;
  }
#line 364
  if ((int )c___0 == 110) {
#line 364
    goto case_110;
  }
#line 367
  if ((int )c___0 == 27) {
#line 367
    goto case_27;
  }
#line 369
  goto switch_default;
  case_104: /* CIL Label */ 
#line 344
  *d = (short)6;
#line 345
  goto switch_break;
  case_106: /* CIL Label */ 
#line 347
  *d = (short)4;
#line 348
  goto switch_break;
  case_107: /* CIL Label */ 
#line 350
  *d = (short)0;
#line 351
  goto switch_break;
  case_108: /* CIL Label */ 
#line 353
  *d = (short)2;
#line 354
  goto switch_break;
  case_98: /* CIL Label */ 
#line 356
  *d = (short)5;
#line 357
  goto switch_break;
  case_121: /* CIL Label */ 
#line 359
  *d = (short)7;
#line 360
  goto switch_break;
  case_117: /* CIL Label */ 
#line 362
  *d = (short)1;
#line 363
  goto switch_break;
  case_110: /* CIL Label */ 
#line 365
  *d = (short)3;
#line 366
  goto switch_break;
  case_27: /* CIL Label */ 
#line 368
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 370
  return ((char)0);
  switch_break: /* CIL Label */ ;
  }
#line 372
  return ((char)1);
}
}
#line 375 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char check_hunger(char msg_only ) 
{ 
  short i ;
  short n___0 ;
  char fainted ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 380
  fainted = (char)0;
#line 382
  if ((int )rogue.moves_left == 300) {
    {
#line 383
    strcpy((char */* __restrict  */)(hunger_str), (char const   */* __restrict  */)"hungry");
#line 384
    message((char const   *)(hunger_str), (char)0);
#line 385
    print_stats(64);
    }
  }
#line 387
  if ((int )rogue.moves_left == 150) {
    {
#line 388
    strcpy((char */* __restrict  */)(hunger_str), (char const   */* __restrict  */)"weak");
#line 389
    message((char const   *)(hunger_str), (char)1);
#line 390
    print_stats(64);
    }
  }
#line 392
  if ((int )rogue.moves_left <= 20) {
#line 393
    if ((int )rogue.moves_left == 20) {
      {
#line 394
      strcpy((char */* __restrict  */)(hunger_str), (char const   */* __restrict  */)"faint");
#line 395
      message((char const   *)(hunger_str), (char)1);
#line 396
      print_stats(64);
      }
    }
    {
#line 398
    tmp = get_rand(0, 20 - (int )rogue.moves_left);
#line 398
    n___0 = (short )tmp;
    }
#line 399
    if ((int )n___0 > 0) {
      {
#line 400
      fainted = (char)1;
#line 401
      tmp___0 = rand_percent(40);
      }
#line 401
      if (tmp___0) {
#line 402
        rogue.moves_left = (short )((int )rogue.moves_left + 1);
      }
      {
#line 404
      message("you faint", (char)1);
#line 405
      i = (short)0;
      }
      {
#line 405
      while (1) {
        while_continue: /* CIL Label */ ;
#line 405
        if (! ((int )i < (int )n___0)) {
#line 405
          goto while_break;
        }
        {
#line 406
        tmp___1 = coin_toss();
        }
#line 406
        if (tmp___1) {
          {
#line 407
          mv_mons();
          }
        }
#line 405
        i = (short )((int )i + 1);
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 410
      message(you_can_move_again, (char)1);
      }
    }
  }
#line 413
  if (msg_only) {
#line 414
    return (fainted);
  }
#line 416
  if ((int )rogue.moves_left <= 0) {
    {
#line 417
    killed_by((object const   *)((object *)0), (short)2);
    }
  }
  {
#line 424
  if ((int )e_rings == -1) {
#line 424
    goto case_neg_1;
  }
#line 427
  if ((int )e_rings == 0) {
#line 427
    goto case_0;
  }
#line 430
  if ((int )e_rings == 1) {
#line 430
    goto case_1;
  }
#line 435
  if ((int )e_rings == 2) {
#line 435
    goto case_2;
  }
#line 420
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 425
  rogue.moves_left = (short )((int )rogue.moves_left - (int )m_moves % 2);
#line 426
  goto switch_break;
  case_0: /* CIL Label */ 
#line 428
  rogue.moves_left = (short )((int )rogue.moves_left - 1);
#line 429
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 431
  rogue.moves_left = (short )((int )rogue.moves_left - 1);
#line 432
  check_hunger((char)1);
#line 433
  rogue.moves_left = (short )((int )rogue.moves_left - (int )m_moves % 2);
  }
#line 434
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 436
  rogue.moves_left = (short )((int )rogue.moves_left - 1);
#line 437
  check_hunger((char)1);
#line 438
  rogue.moves_left = (short )((int )rogue.moves_left - 1);
  }
#line 439
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 441
  return (fainted);
}
}
#line 444 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char reg_move(void) 
{ 
  char fainted ;

  {
#line 449
  if ((int )rogue.moves_left <= 300) {
    {
#line 450
    fainted = check_hunger((char)0);
    }
  } else
#line 449
  if ((int )cur_level >= (int )max_level) {
    {
#line 450
    fainted = check_hunger((char)0);
    }
  } else {
#line 452
    fainted = (char)0;
  }
  {
#line 455
  mv_mons();
#line 457
  m_moves = (short )((int )m_moves + 1);
  }
#line 457
  if ((int )m_moves >= 120) {
    {
#line 458
    m_moves = (short)0;
#line 459
    wanderer();
    }
  }
#line 461
  if (halluc) {
#line 462
    halluc = (short )((int )halluc - 1);
#line 462
    if (halluc) {
      {
#line 465
      hallucinate();
      }
    } else {
      {
#line 463
      unhallucinate();
      }
    }
  }
#line 468
  if (blind) {
#line 469
    blind = (short )((int )blind - 1);
#line 469
    if (! blind) {
      {
#line 470
      unblind();
      }
    }
  }
#line 473
  if (confused) {
#line 474
    confused = (short )((int )confused - 1);
#line 474
    if (! confused) {
      {
#line 475
      unconfuse();
      }
    }
  }
#line 478
  if (bear_trap) {
#line 479
    bear_trap = (short )((int )bear_trap - 1);
  }
#line 481
  if (levitate) {
#line 482
    levitate = (short )((int )levitate - 1);
#line 482
    if (! levitate) {
      {
#line 483
      message("you float gently to the ground", (char)1);
      }
#line 484
      if ((int )dungeon[rogue.row][rogue.col] & 256) {
        {
#line 485
        trap_player((int )rogue.row, (int )rogue.col);
        }
      }
    }
  }
#line 489
  if (haste_self) {
#line 490
    haste_self = (short )((int )haste_self - 1);
#line 490
    if (! haste_self) {
      {
#line 491
      message("you feel yourself slowing down", (char)0);
      }
    }
  }
  {
#line 494
  heal();
  }
#line 495
  if ((int )auto_search > 0) {
    {
#line 496
    search(auto_search, (char )auto_search);
    }
  }
#line 498
  return (fainted);
}
}
#line 501 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
void rest(int count ) 
{ 
  int i ;

  {
#line 507
  interrupted = (char)0;
#line 509
  i = 0;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! (i < count)) {
#line 509
      goto while_break;
    }
#line 510
    if (interrupted) {
#line 511
      goto while_break;
    }
    {
#line 513
    reg_move();
#line 509
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return;
}
}
#line 517 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char gr_dir(void) 
{ 
  short d ;
  int tmp ;

  {
  {
#line 522
  tmp = get_rand(1, 8);
#line 522
  d = (short )tmp;
  }
  {
#line 525
  if ((int )d == 1) {
#line 525
    goto case_1;
  }
#line 528
  if ((int )d == 2) {
#line 528
    goto case_2;
  }
#line 531
  if ((int )d == 3) {
#line 531
    goto case_3;
  }
#line 534
  if ((int )d == 4) {
#line 534
    goto case_4;
  }
#line 537
  if ((int )d == 5) {
#line 537
    goto case_5;
  }
#line 540
  if ((int )d == 6) {
#line 540
    goto case_6;
  }
#line 543
  if ((int )d == 7) {
#line 543
    goto case_7;
  }
#line 546
  if ((int )d == 8) {
#line 546
    goto case_8;
  }
#line 524
  goto switch_break;
  case_1: /* CIL Label */ 
#line 526
  d = (short )'j';
#line 527
  goto switch_break;
  case_2: /* CIL Label */ 
#line 529
  d = (short )'k';
#line 530
  goto switch_break;
  case_3: /* CIL Label */ 
#line 532
  d = (short )'l';
#line 533
  goto switch_break;
  case_4: /* CIL Label */ 
#line 535
  d = (short )'h';
#line 536
  goto switch_break;
  case_5: /* CIL Label */ 
#line 538
  d = (short )'y';
#line 539
  goto switch_break;
  case_6: /* CIL Label */ 
#line 541
  d = (short )'u';
#line 542
  goto switch_break;
  case_7: /* CIL Label */ 
#line 544
  d = (short )'b';
#line 545
  goto switch_break;
  case_8: /* CIL Label */ 
#line 547
  d = (short )'n';
#line 548
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 550
  return ((char )d);
}
}
#line 556 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
static short heal_exp  =    (short)-1;
#line 556 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
static short n  ;
#line 556 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
static short c  =    (short)0;
#line 557 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
static char alt  ;
#line 553 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
void heal(void) 
{ 


  {
#line 559
  if ((int )rogue.hp_current == (int )rogue.hp_max) {
#line 560
    c = (short)0;
#line 561
    return;
  }
#line 563
  if ((int )rogue.exp != (int )heal_exp) {
#line 564
    heal_exp = rogue.exp;
    {
#line 567
    if ((int )heal_exp == 1) {
#line 567
      goto case_1;
    }
#line 570
    if ((int )heal_exp == 2) {
#line 570
      goto case_2;
    }
#line 573
    if ((int )heal_exp == 3) {
#line 573
      goto case_3;
    }
#line 576
    if ((int )heal_exp == 4) {
#line 576
      goto case_4;
    }
#line 579
    if ((int )heal_exp == 5) {
#line 579
      goto case_5;
    }
#line 582
    if ((int )heal_exp == 6) {
#line 582
      goto case_6;
    }
#line 585
    if ((int )heal_exp == 7) {
#line 585
      goto case_7;
    }
#line 588
    if ((int )heal_exp == 8) {
#line 588
      goto case_8;
    }
#line 591
    if ((int )heal_exp == 9) {
#line 591
      goto case_9;
    }
#line 594
    if ((int )heal_exp == 10) {
#line 594
      goto case_10;
    }
#line 597
    if ((int )heal_exp == 11) {
#line 597
      goto case_11;
    }
#line 601
    goto switch_default;
    case_1: /* CIL Label */ 
#line 568
    n = (short)20;
#line 569
    goto switch_break;
    case_2: /* CIL Label */ 
#line 571
    n = (short)18;
#line 572
    goto switch_break;
    case_3: /* CIL Label */ 
#line 574
    n = (short)17;
#line 575
    goto switch_break;
    case_4: /* CIL Label */ 
#line 577
    n = (short)14;
#line 578
    goto switch_break;
    case_5: /* CIL Label */ 
#line 580
    n = (short)13;
#line 581
    goto switch_break;
    case_6: /* CIL Label */ 
#line 583
    n = (short)10;
#line 584
    goto switch_break;
    case_7: /* CIL Label */ 
#line 586
    n = (short)9;
#line 587
    goto switch_break;
    case_8: /* CIL Label */ 
#line 589
    n = (short)8;
#line 590
    goto switch_break;
    case_9: /* CIL Label */ 
#line 592
    n = (short)7;
#line 593
    goto switch_break;
    case_10: /* CIL Label */ 
#line 595
    n = (short)4;
#line 596
    goto switch_break;
    case_11: /* CIL Label */ 
#line 598
    n = (short)3;
#line 599
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 602
    n = (short)2;
    switch_break: /* CIL Label */ ;
    }
  }
#line 605
  c = (short )((int )c + 1);
#line 605
  if ((int )c >= (int )n) {
#line 606
    c = (short)0;
#line 607
    rogue.hp_current = (short )((int )rogue.hp_current + 1);
#line 608
    alt = (char )(! alt);
#line 608
    if ((int )alt != 0) {
#line 609
      rogue.hp_current = (short )((int )rogue.hp_current + 1);
    }
#line 611
    rogue.hp_current = (short )((int )rogue.hp_current + (int )regeneration);
#line 611
    if ((int )rogue.hp_current > (int )rogue.hp_max) {
#line 612
      rogue.hp_current = rogue.hp_max;
    }
    {
#line 614
    print_stats(4);
    }
  }
#line 616
  return;
}
}
#line 618 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
char can_turn(short nrow , short ncol ) 
{ 
  char tmp ;

  {
#line 622
  if ((int )dungeon[nrow][ncol] & 128) {
    {
#line 622
    tmp = is_passable((int )nrow, (int )ncol);
    }
#line 622
    if (tmp) {
#line 623
      return ((char)1);
    }
  }
#line 625
  return ((char)0);
}
}
#line 628 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/move.c"
void turn_passage(short dir , char fast ) 
{ 
  short crow ;
  short ccol ;
  short turns ;
  short ndir ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;

  {
#line 633
  crow = rogue.row;
#line 633
  ccol = rogue.col;
#line 633
  turns = (short)0;
#line 634
  ndir = (short)0;
#line 636
  if ((int )dir != 104) {
    {
#line 636
    tmp = can_turn(crow, (short )((int )ccol + 1));
    }
#line 636
    if (tmp) {
#line 637
      turns = (short )((int )turns + 1);
#line 638
      ndir = (short )'l';
    }
  }
#line 640
  if ((int )dir != 108) {
    {
#line 640
    tmp___0 = can_turn(crow, (short )((int )ccol - 1));
    }
#line 640
    if (tmp___0) {
#line 641
      turns = (short )((int )turns + 1);
#line 642
      ndir = (short )'h';
    }
  }
#line 644
  if ((int )dir != 107) {
    {
#line 644
    tmp___1 = can_turn((short )((int )crow + 1), ccol);
    }
#line 644
    if (tmp___1) {
#line 645
      turns = (short )((int )turns + 1);
#line 646
      ndir = (short )'j';
    }
  }
#line 648
  if ((int )dir != 106) {
    {
#line 648
    tmp___2 = can_turn((short )((int )crow - 1), ccol);
    }
#line 648
    if (tmp___2) {
#line 649
      turns = (short )((int )turns + 1);
#line 650
      ndir = (short )'k';
    }
  }
#line 652
  if ((int )turns == 1) {
#line 653
    if (fast) {
#line 653
      tmp___3 = 32;
    } else {
#line 653
      tmp___3 = 96;
    }
    {
#line 653
    multiple_move_rogue((short )((int )ndir - tmp___3));
    }
  }
#line 655
  return;
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 446 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object *alloc_object(void) ;
#line 450
object *get_thrown_at_monster(object *obj , short dir , short *row___0 , short *col___0 ) ;
#line 475
void check_gold_seeker(object *monster ) ;
#line 512
void flop_weapon(object *weapon , short row___0 , short col___0 ) ;
#line 525
int get_hit_chance(object const   *weapon ) ;
#line 527
char get_mask_char(unsigned short mask ) ;
#line 535
int get_weapon_damage(object const   *weapon ) ;
#line 562
extern char imitating(int  , int  ) ;
#line 605
int mon_damage(object *monster , short damage ) ;
#line 614
void mv_aquatars(void) ;
#line 631
void place_at(object *obj , int row___0 , int col___0 ) ;
#line 654
void rand_around(short i , short *r , short *c___0 ) ;
#line 669
int rogue_can_see(int row___0 , int col___0 ) ;
#line 678
void s_con_mon(object *monster ) ;
#line 707
char throw_at_monster(object *monster , object *weapon ) ;
#line 724
void wake_up(object *monster ) ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
void throw(void) 
{ 
  short wch ;
  short d ;
  char first_miss ;
  object *weapon ;
  short dir ;
  short row___0 ;
  short col___0 ;
  object *monster ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;

  {
#line 62
  first_miss = (char)1;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp = rgetchar();
#line 67
    dir = (short )tmp;
#line 67
    tmp___0 = is_direction(dir, & d);
    }
#line 67
    if (tmp___0) {
#line 67
      goto while_break;
    }
    {
#line 68
    sound_bell();
    }
#line 69
    if (first_miss) {
      {
#line 70
      message("direction? ", (char)0);
#line 71
      first_miss = (char)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 74
  check_message();
  }
#line 75
  if ((int )dir == 27) {
#line 76
    return;
  }
  {
#line 78
  wch = pack_letter("throw what?", (unsigned short)2);
  }
#line 78
  if ((int )wch == 27) {
#line 79
    return;
  }
  {
#line 81
  check_message();
#line 83
  weapon = get_letter_object((int )wch);
  }
#line 83
  if (! weapon) {
    {
#line 84
    message("no such item.", (char)0);
    }
#line 85
    return;
  }
#line 87
  if ((int )weapon->in_use_flags & 15) {
#line 87
    if (weapon->is_cursed) {
      {
#line 88
      message(curse_message, (char)0);
      }
#line 89
      return;
    }
  }
#line 91
  row___0 = rogue.row;
#line 91
  col___0 = rogue.col;
#line 93
  if ((int )weapon->in_use_flags & 1) {
#line 93
    if ((int )weapon->quantity <= 1) {
      {
#line 94
      unwield(rogue.weapon);
      }
    } else {
#line 93
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 95
  if ((int )weapon->in_use_flags & 2) {
    {
#line 96
    mv_aquatars();
#line 97
    unwear(rogue.armor);
#line 98
    print_stats(16);
    }
  } else
#line 99
  if ((int )weapon->in_use_flags & 12) {
    {
#line 100
    un_put_on(weapon);
    }
  }
  {
#line 102
  monster = get_thrown_at_monster(weapon, d, & row___0, & col___0);
#line 103
  tmp___1 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 103
  if (! (tmp___1 == -1)) {
    {
#line 103
    waddch(stdscr, (chtype const   )rogue.fchar);
    }
  }
  {
#line 104
  wrefresh(stdscr);
#line 106
  tmp___4 = rogue_can_see((int )row___0, (int )col___0);
  }
#line 106
  if (tmp___4) {
#line 106
    if ((int )row___0 != (int )rogue.row) {
#line 106
      goto _L___0;
    } else
#line 106
    if ((int )col___0 != (int )rogue.col) {
      _L___0: /* CIL Label */ 
      {
#line 107
      tmp___3 = wmove(stdscr, (int )row___0, (int )col___0);
      }
#line 107
      if (! (tmp___3 == -1)) {
        {
#line 107
        tmp___2 = get_dungeon_char(row___0, col___0);
#line 107
        waddch(stdscr, (chtype const   )tmp___2);
        }
      }
    }
  }
#line 109
  if (monster) {
    {
#line 110
    wake_up(monster);
#line 111
    check_gold_seeker(monster);
#line 113
    tmp___5 = throw_at_monster(monster, weapon);
    }
#line 113
    if (! tmp___5) {
      {
#line 114
      flop_weapon(weapon, row___0, col___0);
      }
    }
  } else {
    {
#line 117
    flop_weapon(weapon, row___0, col___0);
    }
  }
  {
#line 119
  vanish(weapon, (short)1, & rogue.pack);
  }
#line 120
  return;
}
}
#line 122 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
char throw_at_monster(object *monster , object *weapon ) 
{ 
  short damage ;
  short hit_chance ;
  short t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 129
  tmp = get_hit_chance((object const   *)weapon);
#line 129
  hit_chance = (short )tmp;
#line 130
  tmp___0 = get_weapon_damage((object const   *)weapon);
#line 130
  damage = (short )tmp___0;
  }
#line 131
  if ((int )weapon->which_kind == 2) {
#line 131
    if (rogue.weapon) {
#line 131
      if ((int )(rogue.weapon)->which_kind == 0) {
        {
#line 133
        tmp___1 = get_weapon_damage((object const   *)rogue.weapon);
#line 133
        damage = (short )((int )damage + tmp___1);
#line 134
        damage = (short )(((int )damage * 2) / 3);
#line 135
        hit_chance = (short )((int )hit_chance + (int )hit_chance / 3);
        }
      } else {
#line 131
        goto _L;
      }
    } else {
#line 131
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 136
  if ((int )weapon->in_use_flags & 1) {
#line 136
    if ((int )weapon->which_kind == 3) {
#line 140
      damage = (short )(((int )damage * 3) / 2);
#line 141
      hit_chance = (short )((int )hit_chance + (int )hit_chance / 3);
    } else
#line 136
    if ((int )weapon->which_kind == 4) {
#line 140
      damage = (short )(((int )damage * 3) / 2);
#line 141
      hit_chance = (short )((int )hit_chance + (int )hit_chance / 3);
    } else
#line 136
    if ((int )weapon->which_kind == 1) {
#line 140
      damage = (short )(((int )damage * 3) / 2);
#line 141
      hit_chance = (short )((int )hit_chance + (int )hit_chance / 3);
    }
  }
  {
#line 143
  t = weapon->quantity;
#line 144
  weapon->quantity = (short)1;
#line 145
  tmp___2 = name_of((object const   *)weapon);
#line 145
  sprintf((char */* __restrict  */)(hit_message), (char const   */* __restrict  */)"the %s",
          tmp___2);
#line 146
  weapon->quantity = t;
#line 148
  tmp___3 = rand_percent((int )hit_chance);
  }
#line 148
  if (! tmp___3) {
    {
#line 149
    strcat((char */* __restrict  */)(hit_message), (char const   */* __restrict  */)"misses  ");
    }
#line 150
    return ((char)0);
  }
  {
#line 152
  s_con_mon(monster);
#line 153
  strcat((char */* __restrict  */)(hit_message), (char const   */* __restrict  */)"hit  ");
#line 154
  mon_damage(monster, damage);
  }
#line 155
  return ((char)1);
}
}
#line 158 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
object *get_thrown_at_monster(object *obj , short dir , short *row___0 , short *col___0 ) 
{ 
  short orow ;
  short ocol ;
  short i ;
  short ch ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  object *tmp___5 ;
  char tmp___6 ;

  {
  {
#line 167
  orow = *row___0;
#line 167
  ocol = *col___0;
#line 169
  tmp = get_mask_char(obj->what_is);
#line 169
  ch = (short )tmp;
#line 171
  i = (short)0;
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((int )i < 24)) {
#line 171
      goto while_break;
    }
    {
#line 172
    get_dir_rc(dir, row___0, col___0, (short)0);
    }
#line 173
    if ((int )*col___0 <= 0) {
#line 177
      *row___0 = orow;
#line 178
      *col___0 = ocol;
#line 179
      return ((object *)0);
    } else
#line 173
    if ((int )*col___0 >= 79) {
#line 177
      *row___0 = orow;
#line 178
      *col___0 = ocol;
#line 179
      return ((object *)0);
    } else
#line 173
    if ((int )dungeon[*row___0][*col___0] == 0) {
#line 177
      *row___0 = orow;
#line 178
      *col___0 = ocol;
#line 179
      return ((object *)0);
    } else
#line 173
    if ((int )dungeon[*row___0][*col___0] & 536) {
#line 173
      if (! ((int )dungeon[*row___0][*col___0] & 256)) {
#line 177
        *row___0 = orow;
#line 178
        *col___0 = ocol;
#line 179
        return ((object *)0);
      }
    }
#line 181
    if ((int )i != 0) {
      {
#line 181
      tmp___2 = rogue_can_see((int )orow, (int )ocol);
      }
#line 181
      if (tmp___2) {
        {
#line 182
        tmp___1 = wmove(stdscr, (int )orow, (int )ocol);
        }
#line 182
        if (! (tmp___1 == -1)) {
          {
#line 182
          tmp___0 = get_dungeon_char(orow, ocol);
#line 182
          waddch(stdscr, (chtype const   )tmp___0);
          }
        }
      }
    }
    {
#line 184
    tmp___4 = rogue_can_see((int )*row___0, (int )*col___0);
    }
#line 184
    if (tmp___4) {
#line 185
      if (! ((int )dungeon[*row___0][*col___0] & 2)) {
        {
#line 186
        tmp___3 = wmove(stdscr, (int )*row___0, (int )*col___0);
        }
#line 186
        if (! (tmp___3 == -1)) {
          {
#line 186
          waddch(stdscr, (chtype const   )ch);
          }
        }
      }
      {
#line 188
      wrefresh(stdscr);
      }
    }
#line 190
    orow = *row___0;
#line 190
    ocol = *col___0;
#line 191
    if ((int )dungeon[*row___0][*col___0] & 2) {
      {
#line 192
      tmp___6 = imitating((int )*row___0, (int )*col___0);
      }
#line 192
      if (! tmp___6) {
        {
#line 193
        tmp___5 = object_at(& level_monsters, *row___0, *col___0);
        }
#line 193
        return (tmp___5);
      }
    }
#line 196
    if ((int )dungeon[*row___0][*col___0] & 128) {
#line 197
      i = (short )((int )i + 2);
    }
#line 171
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return ((object *)0);
}
}
#line 203 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
void flop_weapon(object *weapon , short row___0 , short col___0 ) 
{ 
  object *new_weapon ;
  object *monster ;
  short i ;
  char msg[80] ;
  char found ;
  short mch ;
  short dch ;
  unsigned short mon ;
  short tmp ;
  char tmp___0 ;
  chtype tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  short t ;
  char const   *tmp___7 ;

  {
#line 209
  i = (short)0;
#line 211
  found = (char)0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if ((int )i < 9) {
#line 215
      if (! ((int )dungeon[row___0][col___0] & -227)) {
#line 215
        goto while_break;
      }
    } else {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp = i;
#line 216
    i = (short )((int )i + 1);
#line 216
    rand_around(tmp, & row___0, & col___0);
    }
#line 217
    if ((int )row___0 > 22) {
#line 220
      goto while_continue;
    } else
#line 217
    if ((int )row___0 < 1) {
#line 220
      goto while_continue;
    } else
#line 217
    if ((int )col___0 > 79) {
#line 220
      goto while_continue;
    } else
#line 217
    if ((int )col___0 < 0) {
#line 220
      goto while_continue;
    } else
#line 217
    if (! dungeon[row___0][col___0]) {
#line 220
      goto while_continue;
    } else
#line 217
    if ((int )dungeon[row___0][col___0] & -227) {
#line 220
      goto while_continue;
    }
#line 222
    found = (char)1;
#line 223
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  if (found) {
#line 226
    goto _L___1;
  } else
#line 226
  if ((int )i == 0) {
    _L___1: /* CIL Label */ 
    {
#line 227
    new_weapon = alloc_object();
#line 228
    *new_weapon = *weapon;
#line 229
    new_weapon->in_use_flags = (unsigned short)0;
#line 230
    new_weapon->quantity = (short)1;
#line 231
    new_weapon->ichar = (short )'L';
#line 232
    place_at(new_weapon, (int )row___0, (int )col___0);
#line 233
    tmp___6 = rogue_can_see((int )row___0, (int )col___0);
    }
#line 233
    if (tmp___6) {
#line 233
      if ((int )row___0 != (int )rogue.row) {
#line 233
        goto _L___0;
      } else
#line 233
      if ((int )col___0 != (int )rogue.col) {
        _L___0: /* CIL Label */ 
        {
#line 235
        mon = (unsigned short )((int )dungeon[row___0][col___0] & 2);
#line 236
        dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -3);
#line 237
        tmp___0 = get_dungeon_char(row___0, col___0);
#line 237
        dch = (short )tmp___0;
        }
#line 238
        if (mon) {
          {
#line 239
          tmp___3 = wmove(stdscr, (int )row___0, (int )col___0);
          }
#line 239
          if (tmp___3 == -1) {
#line 239
            mch = (short )((chtype )-1);
          } else {
            {
#line 239
            tmp___2 = winch(stdscr);
#line 239
            mch = (short )tmp___2;
            }
          }
          {
#line 240
          monster = object_at(& level_monsters, row___0, col___0);
          }
#line 240
          if ((unsigned long )monster != (unsigned long )((void *)0)) {
#line 242
            monster->d_enchant = dch;
          }
#line 244
          if ((int )mch < 65) {
#line 244
            goto _L;
          } else
#line 244
          if ((int )mch > 90) {
            _L: /* CIL Label */ 
            {
#line 245
            tmp___4 = wmove(stdscr, (int )row___0, (int )col___0);
            }
#line 245
            if (! (tmp___4 == -1)) {
              {
#line 245
              waddch(stdscr, (chtype const   )dch);
              }
            }
          }
        } else {
          {
#line 248
          tmp___5 = wmove(stdscr, (int )row___0, (int )col___0);
          }
#line 248
          if (! (tmp___5 == -1)) {
            {
#line 248
            waddch(stdscr, (chtype const   )dch);
            }
          }
        }
#line 250
        dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | (int )mon);
      }
    }
  } else {
    {
#line 255
    t = weapon->quantity;
#line 256
    weapon->quantity = (short)1;
#line 257
    tmp___7 = name_of((object const   *)weapon);
#line 257
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"the %svanishes as it hits the ground",
            tmp___7);
#line 259
    weapon->quantity = t;
#line 260
    message((char const   *)(msg), (char)0);
    }
  }
#line 262
  return;
}
}
#line 268 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
static char pos[10]  = 
#line 268
  {      (char )'\b',      (char )'\a',      (char )'\001',      (char )'\003', 
        (char )'\004',      (char )'\005',      (char )'\002',      (char )'\006', 
        (char )'\000',      (char )'\000'};
#line 269 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
static short row  ;
#line 269 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
static short col  ;
#line 264 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/throw.c"
void rand_around(short i , short *r , short *c___0 ) 
{ 
  short j ;
  short x ;
  short y ;
  short o ;
  short t ;
  int tmp ;
  int tmp___0 ;

  {
#line 272
  if ((int )i == 0) {
    {
#line 275
    row = *r;
#line 276
    col = *c___0;
#line 278
    tmp = get_rand(1, 8);
#line 278
    o = (short )tmp;
#line 280
    j = (short)0;
    }
    {
#line 280
    while (1) {
      while_continue: /* CIL Label */ ;
#line 280
      if (! ((int )j < 5)) {
#line 280
        goto while_break;
      }
      {
#line 281
      tmp___0 = get_rand(0, 8);
#line 281
      x = (short )tmp___0;
#line 282
      y = (short )(((int )x + (int )o) % 9);
#line 283
      t = (short )pos[x];
#line 284
      pos[x] = pos[y];
#line 285
      pos[y] = (char )t;
#line 280
      j = (short )((int )j + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 289
  if ((int )((short )pos[i]) == 0) {
#line 289
    goto case_0;
  }
#line 293
  if ((int )((short )pos[i]) == 1) {
#line 293
    goto case_1;
  }
#line 297
  if ((int )((short )pos[i]) == 2) {
#line 297
    goto case_2;
  }
#line 301
  if ((int )((short )pos[i]) == 3) {
#line 301
    goto case_3;
  }
#line 305
  if ((int )((short )pos[i]) == 4) {
#line 305
    goto case_4;
  }
#line 309
  if ((int )((short )pos[i]) == 5) {
#line 309
    goto case_5;
  }
#line 313
  if ((int )((short )pos[i]) == 6) {
#line 313
    goto case_6;
  }
#line 317
  if ((int )((short )pos[i]) == 7) {
#line 317
    goto case_7;
  }
#line 321
  if ((int )((short )pos[i]) == 8) {
#line 321
    goto case_8;
  }
#line 288
  goto switch_break;
  case_0: /* CIL Label */ 
#line 290
  *r = (short )((int )row + 1);
#line 291
  *c___0 = (short )((int )col + 1);
#line 292
  goto switch_break;
  case_1: /* CIL Label */ 
#line 294
  *r = (short )((int )row + 1);
#line 295
  *c___0 = (short )((int )col - 1);
#line 296
  goto switch_break;
  case_2: /* CIL Label */ 
#line 298
  *r = (short )((int )row - 1);
#line 299
  *c___0 = (short )((int )col + 1);
#line 300
  goto switch_break;
  case_3: /* CIL Label */ 
#line 302
  *r = (short )((int )row - 1);
#line 303
  *c___0 = (short )((int )col - 1);
#line 304
  goto switch_break;
  case_4: /* CIL Label */ 
#line 306
  *r = row;
#line 307
  *c___0 = (short )((int )col + 1);
#line 308
  goto switch_break;
  case_5: /* CIL Label */ 
#line 310
  *r = (short )((int )row + 1);
#line 311
  *c___0 = col;
#line 312
  goto switch_break;
  case_6: /* CIL Label */ 
#line 314
  *r = row;
#line 315
  *c___0 = col;
#line 316
  goto switch_break;
  case_7: /* CIL Label */ 
#line 318
  *r = (short )((int )row - 1);
#line 319
  *c___0 = col;
#line 320
  goto switch_break;
  case_8: /* CIL Label */ 
#line 322
  *r = row;
#line 323
  *c___0 = (short )((int )col - 1);
#line 324
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 352 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object mon_tab[26] ;
#line 353 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object level_monsters  ;
#line 452
object *gr_monster(object *monster , int mn ) ;
#line 458
char const   *mon_name(object const   *monster ) ;
#line 466
void aim_monster(object *monster ) ;
#line 496
void dr_course(object *monster , char entering , short row___0 , short col___0 ) ;
#line 510
char flame_broil(object *monster ) ;
#line 511
int flit(object *monster ) ;
#line 536
char gmc(object *monster ) ;
#line 537
char gmc_row_col(int row___0 , int col___0 ) ;
#line 546
void gr_row_col(short *row___0 , short *col___0 , unsigned short mask ) ;
#line 580
char m_confuse(object *monster ) ;
#line 604
int mon_can_go(object const   *monster , short row___0 , short col___0 ) ;
#line 606
void mon_hit(object *monster ) ;
#line 607
char mon_sees(object const   *monster , int row___0 , int col___0 ) ;
#line 608
int move_confused(object *monster ) ;
#line 609
void move_mon_to(object *monster , short row___0 , short col___0 ) ;
#line 611
int mtry(object *monster , short row___0 , short col___0 ) ;
#line 613
void mv_1_monster(object *monster , short row___0 , short col___0 ) ;
#line 620
int no_room_for_monster(int rn ) ;
#line 629
void party_monsters(int rn , int n___0 ) ;
#line 642
void put_m_at(short row___0 , short col___0 , object *monster ) ;
#line 672
int rogue_is_around(int row___0 , int col___0 ) ;
#line 685
char seek_gold(object *monster ) ;
#line 737
object *add_to_pack(object *obj , object *pack , int condense ) ;
#line 751 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char mon_disappeared  ;
#line 771
char const   * const  m_names[26] ;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char const   * const  m_names[26]  = 
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
  {      (char const   */* const  */)"aquator",      (char const   */* const  */)"bat",      (char const   */* const  */)"centaur",      (char const   */* const  */)"dragon", 
        (char const   */* const  */)"emu",      (char const   */* const  */)"venus fly-trap",      (char const   */* const  */)"griffin",      (char const   */* const  */)"hobgoblin", 
        (char const   */* const  */)"ice monster",      (char const   */* const  */)"jabberwock",      (char const   */* const  */)"kestrel",      (char const   */* const  */)"leprechaun", 
        (char const   */* const  */)"medusa",      (char const   */* const  */)"nymph",      (char const   */* const  */)"orc",      (char const   */* const  */)"phantom", 
        (char const   */* const  */)"quagga",      (char const   */* const  */)"rattlesnake",      (char const   */* const  */)"snake",      (char const   */* const  */)"troll", 
        (char const   */* const  */)"black unicorn",      (char const   */* const  */)"vampire",      (char const   */* const  */)"wraith",      (char const   */* const  */)"xeroc", 
        (char const   */* const  */)"yeti",      (char const   */* const  */)"zombie"};
#line 90 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
object mon_tab[26]  = 
#line 90
  {      {1080UL, "0d0", (short)25, (short )'A', (short)20, (short)9, (short)18, (short)100,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {232UL, "1d3", (short)10, (short )'B', (short)2, (short)1, (short)8, (short)60,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {40UL, "3d3/2d5", (short)32, (short )'C', (short)15, (short)7, (short)16, (short)85,
      (short)0, (unsigned short)10, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {8388632UL, "4d6/4d9", (short)145, (short )'D', (short)5000, (short)21, (short)126,
      (short)100, (short)0, (unsigned short)90, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {24UL, "1d3", (short)11, (short )'E', (short)2, (short)1, (short)7, (short)65,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {16779264UL, "5d5", (short)73, (short )'F', (short)91, (short)12, (short)126,
      (short)80, (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {120UL, "5d5/5d5", (short)115, (short )'G', (short)2000, (short)20, (short)126,
      (short)85, (short)0, (unsigned short)10, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {56UL, "1d3/1d2", (short)15, (short )'H', (short)3, (short)1, (short)10, (short)67,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {4104UL, "0d0", (short)15, (short )'I', (short)5, (short)2, (short)11, (short)68,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {40UL, "3d10/4d5", (short)132, (short )'J', (short)3000, (short)21, (short)126,
      (short)100, (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {120UL, "1d4", (short)10, (short )'K', (short)2, (short)1, (short)6, (short)60,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {8200UL, "0d0", (short)25, (short )'L', (short)21, (short)6, (short)16, (short)75,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {2097208UL, "4d4/3d7", (short)97, (short )'M', (short)250, (short)18, (short)126,
      (short)85, (short)0, (unsigned short)25, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {16392UL, "0d0", (short)25, (short )'N', (short)39, (short)10, (short)19, (short)75,
      (short)0, (unsigned short)100, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {262200UL, "1d6", (short)25, (short )'O', (short)5, (short)4, (short)13, (short)70,
      (short)0, (unsigned short)10, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {172UL, "5d4", (short)76, (short )'P', (short)120, (short)15, (short)24, (short)80,
      (short)0, (unsigned short)50, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {56UL, "3d5", (short)30, (short )'Q', (short)20, (short)8, (short)17, (short)78,
      (short)0, (unsigned short)20, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {32824UL, "2d5", (short)19, (short )'R', (short)10, (short)3, (short)12, (short)70,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {56UL, "1d3", (short)8, (short )'S', (short)2, (short)1, (short)9, (short)50,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {56UL, "4d6/1d4", (short)75, (short )'T', (short)125, (short)13, (short)22, (short)75,
      (short)0, (unsigned short)33, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {56UL, "4d10", (short)90, (short )'U', (short)200, (short)17, (short)26, (short)85,
      (short)0, (unsigned short)33, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {65592UL, "1d14/1d4", (short)55, (short )'V', (short)350, (short)19, (short)126,
      (short)85, (short)0, (unsigned short)18, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {131112UL, "2d8", (short)45, (short )'W', (short)55, (short)14, (short)23, (short)75,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {4194312UL, "4d6", (short)42, (short )'X', (short)110, (short)16, (short)25,
      (short)75, (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0,
      (short)0, (unsigned short)0, (struct obj *)0}, 
        {40UL, "3d6", (short)35, (short )'Y', (short)50, (short)11, (short)20, (short)80,
      (short)0, (unsigned short)20, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}, 
        {56UL, "1d7", (short)21, (short )'Z', (short)8, (short)5, (short)14, (short)69,
      (short)0, (unsigned short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
      (short)0, (short)0, (short)0, (short)0, (short)0, (unsigned short)0, (short)0,
      (unsigned short)0, (struct obj *)0}};
#line 123 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void put_mons(void) 
{ 
  short i ;
  short n___0 ;
  object *monster ;
  short row___0 ;
  short col___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 131
  tmp = get_rand(4, 6);
#line 131
  n___0 = (short )tmp;
#line 133
  i = (short)0;
  }
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((int )i < (int )n___0)) {
#line 133
      goto while_break;
    }
    {
#line 134
    monster = gr_monster((object *)0, 0);
    }
#line 135
    if (monster->m_flags & 32UL) {
      {
#line 135
      tmp___0 = coin_toss();
      }
#line 135
      if (tmp___0) {
        {
#line 136
        wake_up(monster);
        }
      }
    }
    {
#line 138
    gr_row_col(& row___0, & col___0, (unsigned short)197);
#line 139
    put_m_at((int )row___0, (int )col___0, monster);
#line 133
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 143 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
object *gr_monster(object *monster , int mn ) 
{ 
  char tmp ;

  {
#line 148
  if (! monster) {
    {
#line 149
    monster = alloc_object();
    }
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 152
      mn = get_rand(0, 25);
      }
#line 153
      if ((int )cur_level >= (int )mon_tab[mn].is_protected) {
#line 153
        if ((int )cur_level <= (int )mon_tab[mn].is_cursed) {
#line 155
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 159
  *monster = mon_tab[mn];
#line 160
  if (monster->m_flags & 4194304UL) {
    {
#line 161
    tmp = gr_obj_char();
#line 161
    monster->what_is = (unsigned short )tmp;
    }
  }
#line 163
  if ((int )cur_level > 28) {
#line 164
    monster->m_flags |= 1UL;
  }
#line 166
  monster->trow = (short)-1;
#line 167
  return (monster);
}
}
#line 170 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void mv_mons(void) 
{ 
  object *monster ;
  object *next_object ;
  object *test_mons ;
  char flew ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 176
  if ((int )haste_self % 2) {
#line 177
    return;
  }
#line 180
  monster = level_monsters.next_object;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! monster) {
#line 182
      goto while_break;
    }
#line 183
    next_object = monster->next_object;
#line 184
    mon_disappeared = (char)0;
#line 185
    if (monster->m_flags & 1UL) {
      {
#line 186
      mv_1_monster(monster, (int )rogue.row, (int )rogue.col);
      }
#line 187
      if (mon_disappeared) {
#line 188
        goto NM;
      }
    } else
#line 190
    if (monster->m_flags & 2UL) {
#line 191
      monster->quiver = (short )(! monster->quiver);
#line 192
      if (monster->quiver) {
#line 193
        goto NM;
      }
    }
#line 196
    if (monster->m_flags & 512UL) {
      {
#line 196
      tmp = move_confused(monster);
      }
#line 196
      if (tmp) {
#line 197
        goto NM;
      }
    }
#line 199
    flew = (char)0;
#line 200
    if (monster->m_flags & 64UL) {
#line 200
      if (! (monster->m_flags & 33554432UL)) {
        {
#line 200
        tmp___0 = mon_can_go((object const   *)monster, (int )rogue.row, (int )rogue.col);
        }
#line 200
        if (! tmp___0) {
          {
#line 203
          flew = (char)1;
#line 204
          mv_1_monster(monster, (int )rogue.row, (int )rogue.col);
          }
#line 205
          if (mon_disappeared) {
#line 206
            goto NM;
          }
        }
      }
    }
#line 209
    if (flew) {
      {
#line 209
      tmp___1 = mon_can_go((object const   *)monster, (int )rogue.row, (int )rogue.col);
      }
#line 209
      if (! tmp___1) {
        {
#line 210
        mv_1_monster(monster, (int )rogue.row, (int )rogue.col);
        }
      }
    } else {
      {
#line 210
      mv_1_monster(monster, (int )rogue.row, (int )rogue.col);
      }
    }
    NM: 
#line 212
    test_mons = level_monsters.next_object;
#line 213
    monster = (object *)((void *)0);
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! test_mons) {
#line 214
        goto while_break___0;
      }
#line 216
      if ((unsigned long )next_object == (unsigned long )test_mons) {
#line 218
        monster = next_object;
#line 219
        goto while_break___0;
      }
#line 221
      test_mons = test_mons->next_object;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 226 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void party_monsters(int rn , int n___0 ) 
{ 
  short i ;
  short j ;
  short row___0 ;
  short col___0 ;
  object *monster ;
  char found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 235
  col___0 = (short)0;
#line 235
  row___0 = col___0;
#line 236
  n___0 += n___0;
#line 238
  i = (short)0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((int )i < 26)) {
#line 238
      goto while_break;
    }
#line 239
    mon_tab[i].is_protected = (short )((int )mon_tab[i].is_protected - (int )cur_level % 3);
#line 238
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  i = (short)0;
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 241
    if (! ((int )i < n___0)) {
#line 241
      goto while_break___0;
    }
    {
#line 242
    tmp = no_room_for_monster(rn);
    }
#line 242
    if (tmp) {
#line 243
      goto while_break___0;
    }
#line 245
    found = (char)0;
#line 245
    j = (short )found;
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (! found) {
#line 245
        if (! ((int )j < 250)) {
#line 245
          goto while_break___1;
        }
      } else {
#line 245
        goto while_break___1;
      }
      {
#line 246
      tmp___0 = get_rand((int )rooms[rn].top_row + 1, (int )rooms[rn].bottom_row - 1);
#line 246
      row___0 = (short )tmp___0;
#line 248
      tmp___1 = get_rand((int )rooms[rn].left_col + 1, (int )rooms[rn].right_col - 1);
#line 248
      col___0 = (short )tmp___1;
      }
#line 250
      if (! ((int )dungeon[row___0][col___0] & 2)) {
#line 250
        if ((int )dungeon[row___0][col___0] & 192) {
#line 252
          found = (char)1;
        }
      }
#line 245
      j = (short )((int )j + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 255
    if (found) {
      {
#line 256
      monster = gr_monster((object *)0, 0);
      }
#line 257
      if (! (monster->m_flags & 4194304UL)) {
#line 258
        monster->m_flags |= 16UL;
      }
      {
#line 260
      put_m_at((int )row___0, (int )col___0, monster);
      }
    }
#line 241
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  i = (short)0;
  {
#line 263
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 263
    if (! ((int )i < 26)) {
#line 263
      goto while_break___2;
    }
#line 264
    mon_tab[i].is_protected = (short )((int )mon_tab[i].is_protected + (int )cur_level % 3);
#line 263
    i = (short )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 266
  return;
}
}
#line 268 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char gmc_row_col(int row___0 , int col___0 ) 
{ 
  object *monster ;

  {
  {
#line 274
  monster = object_at(& level_monsters, (short )row___0, (short )col___0);
  }
#line 274
  if ((unsigned long )monster != (unsigned long )((void *)0)) {
#line 275
    if (detect_monster) {
#line 275
      goto _L___0;
    } else
#line 275
    if (see_invisible) {
#line 275
      goto _L___0;
    } else
#line 275
    if (r_see_invisible) {
      _L___0: /* CIL Label */ 
#line 275
      if (blind) {
#line 277
        return ((char )monster->d_enchant);
      }
    } else
#line 275
    if (monster->m_flags & 4UL) {
#line 277
      return ((char )monster->d_enchant);
    } else {
#line 275
      goto _L___0;
    }
#line 279
    if (monster->m_flags & 4194304UL) {
#line 280
      return ((char )monster->what_is);
    }
#line 282
    return ((char )monster->ichar);
  } else {
#line 284
    return ((char )'&');
  }
}
}
#line 288 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char gmc(object *monster ) 
{ 


  {
#line 292
  if (detect_monster) {
#line 292
    goto _L___0;
  } else
#line 292
  if (see_invisible) {
#line 292
    goto _L___0;
  } else
#line 292
  if (r_see_invisible) {
    _L___0: /* CIL Label */ 
#line 292
    if (blind) {
#line 295
      return ((char )monster->d_enchant);
    }
  } else
#line 292
  if (monster->m_flags & 4UL) {
#line 295
    return ((char )monster->d_enchant);
  } else {
#line 292
    goto _L___0;
  }
#line 297
  if (monster->m_flags & 4194304UL) {
#line 298
    return ((char )monster->what_is);
  }
#line 300
  return ((char )monster->ichar);
}
}
#line 303 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void mv_1_monster(object *monster , short row___0 , short col___0 ) 
{ 
  short i ;
  short n___0 ;
  char tried[6] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  int tmp___5 ;
  char tmp___6 ;
  char tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char tmp___20 ;

  {
#line 311
  if (monster->m_flags & 8UL) {
#line 312
    if (monster->m_flags & 33554432UL) {
#line 313
      monster->picked_up = (short )((int )monster->picked_up - 1);
#line 313
      if ((int )monster->picked_up <= 0) {
#line 314
        monster->m_flags &= 0xfffffffffdfffff7UL;
      }
#line 316
      return;
    }
#line 318
    if (monster->m_flags & 16UL) {
      {
#line 318
      tmp = rogue_is_around((int )monster->row, (int )monster->col);
      }
#line 318
      if (tmp) {
#line 318
        if ((int )stealthy > 0) {
#line 318
          tmp___0 = 45 / (3 + (int )stealthy);
        } else {
#line 318
          tmp___0 = 45;
        }
        {
#line 318
        tmp___1 = rand_percent(tmp___0);
        }
#line 318
        if (tmp___1) {
          {
#line 323
          wake_up(monster);
          }
        }
      }
    }
#line 325
    return;
  } else
#line 326
  if (monster->m_flags & 67108864UL) {
#line 327
    monster->m_flags &= 0xfffffffffbffffffUL;
#line 328
    return;
  }
#line 330
  if (monster->m_flags & 128UL) {
    {
#line 330
    tmp___2 = flit(monster);
    }
#line 330
    if (tmp___2) {
#line 331
      return;
    }
  }
#line 333
  if (monster->m_flags & 16777216UL) {
    {
#line 333
    tmp___3 = mon_can_go((object const   *)monster, (int )rogue.row, (int )rogue.col);
    }
#line 333
    if (! tmp___3) {
#line 335
      return;
    }
  }
#line 337
  if (monster->m_flags & 524288UL) {
#line 338
    return;
  }
#line 340
  if (monster->m_flags & 2097152UL) {
    {
#line 340
    tmp___4 = m_confuse(monster);
    }
#line 340
    if (tmp___4) {
#line 341
      return;
    }
  }
  {
#line 343
  tmp___5 = mon_can_go((object const   *)monster, (int )rogue.row, (int )rogue.col);
  }
#line 343
  if (tmp___5) {
    {
#line 344
    mon_hit(monster);
    }
#line 345
    return;
  }
#line 347
  if (monster->m_flags & 8388608UL) {
    {
#line 347
    tmp___6 = flame_broil(monster);
    }
#line 347
    if (tmp___6) {
#line 348
      return;
    }
  }
#line 350
  if (monster->m_flags & 262144UL) {
    {
#line 350
    tmp___7 = seek_gold(monster);
    }
#line 350
    if (tmp___7) {
#line 351
      return;
    }
  }
#line 353
  if ((int )monster->trow == (int )monster->row) {
#line 353
    if ((int )monster->tcol == (int )monster->col) {
#line 355
      monster->trow = (short)-1;
    } else {
#line 353
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 356
  if ((int )monster->trow != -1) {
#line 357
    row___0 = monster->trow;
#line 358
    col___0 = monster->tcol;
  }
#line 360
  if ((int )monster->row > (int )row___0) {
#line 361
    row___0 = (short )((int )monster->row - 1);
  } else
#line 362
  if ((int )monster->row < (int )row___0) {
#line 363
    row___0 = (short )((int )monster->row + 1);
  }
#line 365
  if ((int )dungeon[row___0][monster->col] & 32) {
    {
#line 365
    tmp___8 = mtry(monster, (int )row___0, (int )monster->col);
    }
#line 365
    if (tmp___8) {
#line 367
      return;
    }
  }
#line 369
  if ((int )monster->col > (int )col___0) {
#line 370
    col___0 = (short )((int )monster->col - 1);
  } else
#line 371
  if ((int )monster->col < (int )col___0) {
#line 372
    col___0 = (short )((int )monster->col + 1);
  }
#line 374
  if ((int )dungeon[monster->row][col___0] & 32) {
    {
#line 374
    tmp___9 = mtry(monster, (int )monster->row, (int )col___0);
    }
#line 374
    if (tmp___9) {
#line 376
      return;
    }
  }
  {
#line 378
  tmp___10 = mtry(monster, (int )row___0, (int )col___0);
  }
#line 378
  if (tmp___10) {
#line 379
    return;
  }
#line 382
  i = (short)0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! ((int )i <= 5)) {
#line 382
      goto while_break;
    }
#line 382
    tried[i] = (char)0;
#line 382
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  i = (short)0;
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! ((int )i < 6)) {
#line 384
      goto while_break___0;
    }
    NEXT_TRY: 
    {
#line 385
    tmp___11 = get_rand(0, 5);
#line 385
    n___0 = (short )tmp___11;
    }
    {
#line 387
    if ((int )n___0 == 0) {
#line 387
      goto case_0;
    }
#line 392
    if ((int )n___0 == 1) {
#line 392
      goto case_1;
    }
#line 397
    if ((int )n___0 == 2) {
#line 397
      goto case_2;
    }
#line 402
    if ((int )n___0 == 3) {
#line 402
      goto case_3;
    }
#line 407
    if ((int )n___0 == 4) {
#line 407
      goto case_4;
    }
#line 412
    if ((int )n___0 == 5) {
#line 412
      goto case_5;
    }
#line 386
    goto switch_break;
    case_0: /* CIL Label */ 
#line 388
    if (! tried[n___0]) {
      {
#line 388
      tmp___12 = mtry(monster, (int )row___0, (int )monster->col - 1);
      }
#line 388
      if (tmp___12) {
#line 389
        goto O;
      }
    }
#line 391
    goto switch_break;
    case_1: /* CIL Label */ 
#line 393
    if (! tried[n___0]) {
      {
#line 393
      tmp___13 = mtry(monster, (int )row___0, (int )monster->col);
      }
#line 393
      if (tmp___13) {
#line 394
        goto O;
      }
    }
#line 396
    goto switch_break;
    case_2: /* CIL Label */ 
#line 398
    if (! tried[n___0]) {
      {
#line 398
      tmp___14 = mtry(monster, (int )row___0, (int )monster->col + 1);
      }
#line 398
      if (tmp___14) {
#line 399
        goto O;
      }
    }
#line 401
    goto switch_break;
    case_3: /* CIL Label */ 
#line 403
    if (! tried[n___0]) {
      {
#line 403
      tmp___15 = mtry(monster, (int )monster->row - 1, (int )col___0);
      }
#line 403
      if (tmp___15) {
#line 404
        goto O;
      }
    }
#line 406
    goto switch_break;
    case_4: /* CIL Label */ 
#line 408
    if (! tried[n___0]) {
      {
#line 408
      tmp___16 = mtry(monster, (int )monster->row, (int )col___0);
      }
#line 408
      if (tmp___16) {
#line 409
        goto O;
      }
    }
#line 411
    goto switch_break;
    case_5: /* CIL Label */ 
#line 413
    if (! tried[n___0]) {
      {
#line 413
      tmp___17 = mtry(monster, (int )monster->row + 1, (int )col___0);
      }
#line 413
      if (tmp___17) {
#line 414
        goto O;
      }
    }
#line 416
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 418
    if (! tried[n___0]) {
#line 419
      tried[n___0] = (char)1;
    } else {
#line 421
      goto NEXT_TRY;
    }
#line 384
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  O: 
#line 425
  if ((int )monster->row == (int )monster->o_row) {
#line 425
    if ((int )monster->col == (int )monster->o_col) {
#line 426
      monster->o = (short )((int )monster->o + 1);
#line 426
      if ((int )monster->o > 4) {
#line 427
        if ((int )monster->trow == -1) {
          {
#line 427
          tmp___20 = mon_sees((object const   *)monster, (int )rogue.row, (int )rogue.col);
          }
#line 427
          if (tmp___20) {
#line 432
            monster->trow = (short)-1;
#line 433
            monster->o = (short)0;
          } else {
            {
#line 429
            tmp___18 = get_rand(1, 22);
#line 429
            monster->trow = (short )tmp___18;
#line 430
            tmp___19 = get_rand(0, 79);
#line 430
            monster->tcol = (short )tmp___19;
            }
          }
        } else {
#line 432
          monster->trow = (short)-1;
#line 433
          monster->o = (short)0;
        }
      }
    } else {
#line 437
      monster->o_row = monster->row;
#line 438
      monster->o_col = monster->col;
#line 439
      monster->o = (short)0;
    }
  } else {
#line 437
    monster->o_row = monster->row;
#line 438
    monster->o_col = monster->col;
#line 439
    monster->o = (short)0;
  }
#line 441
  return;
}
}
#line 443 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int mtry(object *monster , short row___0 , short col___0 ) 
{ 
  int tmp ;

  {
  {
#line 448
  tmp = mon_can_go((object const   *)monster, (int )row___0, (int )col___0);
  }
#line 448
  if (tmp) {
    {
#line 449
    move_mon_to(monster, (int )row___0, (int )col___0);
    }
#line 450
    return (1);
  }
#line 452
  return (0);
}
}
#line 455 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void move_mon_to(object *monster , short row___0 , short col___0 ) 
{ 
  short c___0 ;
  int mrow ;
  int mcol ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  chtype tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  short tmp___13 ;
  int tmp___14 ;

  {
  {
#line 463
  mrow = (int )monster->row;
#line 464
  mcol = (int )monster->col;
#line 466
  dungeon[mrow][mcol] = (unsigned short )((int )dungeon[mrow][mcol] & -3);
#line 467
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 2);
#line 469
  tmp___1 = wmove(stdscr, mrow, mcol);
  }
#line 469
  if (tmp___1 == -1) {
#line 469
    c___0 = (short )((chtype )-1);
  } else {
    {
#line 469
    tmp___0 = winch(stdscr);
#line 469
    c___0 = (short )tmp___0;
    }
  }
#line 471
  if ((int )c___0 >= 65) {
#line 471
    if ((int )c___0 <= 90) {
#line 472
      if (! detect_monster) {
        {
#line 473
        tmp___2 = wmove(stdscr, mrow, mcol);
        }
#line 473
        if (! (tmp___2 == -1)) {
          {
#line 473
          waddch(stdscr, (chtype const   )monster->d_enchant);
          }
        }
      } else {
        {
#line 475
        tmp___5 = rogue_can_see(mrow, mcol);
        }
#line 475
        if (tmp___5) {
          {
#line 476
          tmp___3 = wmove(stdscr, mrow, mcol);
          }
#line 476
          if (! (tmp___3 == -1)) {
            {
#line 476
            waddch(stdscr, (chtype const   )monster->d_enchant);
            }
          }
        } else {
#line 478
          if ((int )monster->d_enchant == 46) {
#line 479
            monster->d_enchant = (short )' ';
          }
          {
#line 481
          tmp___4 = wmove(stdscr, mrow, mcol);
          }
#line 481
          if (! (tmp___4 == -1)) {
            {
#line 481
            waddch(stdscr, (chtype const   )monster->d_enchant);
            }
          }
        }
      }
    }
  }
  {
#line 485
  tmp___8 = wmove(stdscr, (int )row___0, (int )col___0);
  }
#line 485
  if (tmp___8 == -1) {
#line 485
    monster->d_enchant = (short )((chtype )-1);
  } else {
    {
#line 485
    tmp___7 = winch(stdscr);
#line 485
    monster->d_enchant = (short )tmp___7;
    }
  }
#line 486
  if (! blind) {
#line 486
    if (detect_monster) {
#line 486
      goto _L___1;
    } else {
      {
#line 486
      tmp___11 = rogue_can_see((int )row___0, (int )col___0);
      }
#line 486
      if (tmp___11) {
        _L___1: /* CIL Label */ 
#line 487
        if (! (monster->m_flags & 4UL)) {
#line 487
          goto _L___0;
        } else
#line 487
        if (detect_monster) {
#line 487
          goto _L___0;
        } else
#line 487
        if (see_invisible) {
#line 487
          goto _L___0;
        } else
#line 487
        if (r_see_invisible) {
          _L___0: /* CIL Label */ 
          {
#line 489
          tmp___10 = wmove(stdscr, (int )row___0, (int )col___0);
          }
#line 489
          if (! (tmp___10 == -1)) {
            {
#line 489
            tmp___9 = gmc(monster);
#line 489
            waddch(stdscr, (chtype const   )tmp___9);
            }
          }
        }
      }
    }
  }
#line 492
  if ((int )dungeon[row___0][col___0] & 32) {
    {
#line 492
    tmp___13 = get_room_number((int )row___0, (int )col___0);
    }
#line 492
    if ((int )tmp___13 != (int )cur_room) {
#line 492
      if ((int )dungeon[mrow][mcol] == 64) {
#line 492
        if (! blind) {
          {
#line 495
          tmp___12 = wmove(stdscr, mrow, mcol);
          }
#line 495
          if (! (tmp___12 == -1)) {
            {
#line 495
            waddch(stdscr, (chtype const   )' ');
            }
          }
        }
      }
    }
  }
#line 497
  if ((int )dungeon[row___0][col___0] & 32) {
#line 498
    if ((int )dungeon[mrow][mcol] & 128) {
#line 498
      tmp___14 = 1;
    } else {
#line 498
      tmp___14 = 0;
    }
    {
#line 498
    dr_course(monster, (char )tmp___14, row___0, col___0);
    }
  } else {
#line 501
    monster->row = row___0;
#line 502
    monster->col = col___0;
  }
#line 504
  return;
}
}
#line 506 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int mon_can_go(object const   *monster , short row___0 , short col___0 ) 
{ 
  object *obj ;
  short dr ;
  short dc ;
  char tmp ;

  {
#line 514
  dr = (short )((int const   )monster->row - (int const   )row___0);
#line 515
  if ((int )dr >= 2) {
#line 516
    return (0);
  } else
#line 515
  if ((int )dr <= -2) {
#line 516
    return (0);
  }
#line 518
  dc = (short )((int const   )monster->col - (int const   )col___0);
#line 519
  if ((int )dc >= 2) {
#line 520
    return (0);
  } else
#line 519
  if ((int )dc <= -2) {
#line 520
    return (0);
  }
#line 522
  if (! dungeon[monster->row][col___0]) {
#line 523
    return (0);
  } else
#line 522
  if (! dungeon[row___0][monster->col]) {
#line 523
    return (0);
  }
  {
#line 525
  tmp = is_passable((int )row___0, (int )col___0);
  }
#line 525
  if (tmp) {
#line 525
    if ((int )dungeon[row___0][col___0] & 2) {
#line 526
      return (0);
    }
  } else {
#line 526
    return (0);
  }
#line 528
  if ((int const   )monster->row != (int const   )row___0) {
#line 528
    if ((int const   )monster->col != (int const   )col___0) {
#line 528
      if ((int )dungeon[row___0][col___0] & 32) {
#line 530
        return (0);
      } else
#line 528
      if ((int )dungeon[monster->row][monster->col] & 32) {
#line 530
        return (0);
      }
    }
  }
#line 532
  if (! (monster->m_flags & 896UL)) {
#line 532
    if ((int const   )monster->trow == -1) {
#line 534
      if ((int const   )monster->row < (int const   )rogue.row) {
#line 534
        if ((int )row___0 < (int )monster->row) {
#line 534
          return (0);
        }
      }
#line 535
      if ((int const   )monster->row > (int const   )rogue.row) {
#line 535
        if ((int )row___0 > (int )monster->row) {
#line 535
          return (0);
        }
      }
#line 536
      if ((int const   )monster->col < (int const   )rogue.col) {
#line 536
        if ((int )col___0 < (int )monster->col) {
#line 536
          return (0);
        }
      }
#line 537
      if ((int const   )monster->col > (int const   )rogue.col) {
#line 537
        if ((int )col___0 > (int )monster->col) {
#line 537
          return (0);
        }
      }
    }
  }
#line 539
  if ((int )dungeon[row___0][col___0] & 1) {
    {
#line 540
    obj = object_at(& level_objects, row___0, col___0);
    }
#line 541
    if ((int )obj->what_is == 4) {
#line 541
      if ((int )obj->which_kind == 7) {
#line 542
        return (0);
      }
    }
  }
#line 545
  return (1);
}
}
#line 548 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void wake_up(object *monster ) 
{ 


  {
#line 552
  if (! (monster->m_flags & 33554432UL)) {
#line 553
    monster->m_flags &= 0xffffffffffbfffe7UL;
  }
#line 555
  return;
}
}
#line 557 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void wake_room(short rn , char entering , short row___0 , short col___0 ) 
{ 
  object *monster ;
  short wake_percent ;
  char in_room ;
  short tmp ;
  int tmp___0 ;
  short tmp___1 ;

  {
#line 567
  if ((int )rn == (int )party_room) {
#line 567
    wake_percent = (short)75;
  } else {
#line 567
    wake_percent = (short)45;
  }
#line 568
  if ((int )stealthy > 0) {
#line 569
    wake_percent = (short )((int )wake_percent / (3 + (int )stealthy));
  }
#line 572
  monster = level_monsters.next_object;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! monster) {
#line 574
      goto while_break;
    }
    {
#line 575
    tmp = get_room_number((int )monster->row, (int )monster->col);
#line 575
    in_room = (char )((int )rn == (int )tmp);
    }
#line 576
    if (in_room) {
#line 577
      if (entering) {
#line 578
        monster->trow = (short)-1;
      } else {
#line 580
        monster->trow = row___0;
#line 581
        monster->tcol = col___0;
      }
    }
#line 584
    if (monster->m_flags & 16UL) {
      {
#line 584
      tmp___1 = get_room_number((int )monster->row, (int )monster->col);
      }
#line 584
      if ((int )rn == (int )tmp___1) {
        {
#line 586
        tmp___0 = rand_percent((int )wake_percent);
        }
#line 586
        if (tmp___0) {
          {
#line 587
          wake_up(monster);
          }
        }
      }
    }
#line 590
    monster = monster->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  return;
}
}
#line 594 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char const   *mon_name(object const   *monster ) 
{ 
  short ch ;
  int tmp ;

  {
#line 600
  if (blind) {
#line 602
    return ("something");
  } else
#line 600
  if (monster->m_flags & 4UL) {
#line 600
    if (! detect_monster) {
#line 600
      if (! see_invisible) {
#line 600
        if (! r_see_invisible) {
#line 602
          return ("something");
        }
      }
    }
  }
#line 604
  if (halluc) {
    {
#line 605
    tmp = get_rand('A', 'Z');
#line 605
    ch = (short )(tmp - 65);
    }
#line 606
    return ((char const   *)m_names[ch]);
  }
#line 608
  ch = (short )((int const   )monster->ichar - 65);
#line 609
  return ((char const   *)m_names[ch]);
}
}
#line 612 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int rogue_is_around(int row___0 , int col___0 ) 
{ 
  short rdif ;
  short cdif ;
  short retval ;
  int tmp ;

  {
#line 618
  rdif = (short )(row___0 - (int )rogue.row);
#line 619
  cdif = (short )(col___0 - (int )rogue.col);
#line 621
  if ((int )rdif >= -1) {
#line 621
    if ((int )rdif <= 1) {
#line 621
      if ((int )cdif >= -1) {
#line 621
        if ((int )cdif <= 1) {
#line 621
          tmp = 1;
        } else {
#line 621
          tmp = 0;
        }
      } else {
#line 621
        tmp = 0;
      }
    } else {
#line 621
      tmp = 0;
    }
  } else {
#line 621
    tmp = 0;
  }
#line 621
  retval = (short )tmp;
#line 622
  return ((int )retval);
}
}
#line 625 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void wanderer(void) 
{ 
  object *monster ;
  short row___0 ;
  short col___0 ;
  short i ;
  char found ;
  int tmp ;

  {
#line 630
  found = (char)0;
#line 632
  i = (short)0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if ((int )i < 15) {
#line 632
      if (! (! found)) {
#line 632
        goto while_break;
      }
    } else {
#line 632
      goto while_break;
    }
    {
#line 633
    monster = gr_monster((object *)0, 0);
    }
#line 634
    if (! (monster->m_flags & 48UL)) {
      {
#line 635
      free_object(monster);
      }
    } else {
#line 637
      found = (char)1;
    }
#line 632
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (found) {
    {
#line 641
    found = (char)0;
#line 642
    wake_up(monster);
#line 643
    i = (short)0;
    }
    {
#line 643
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 643
      if ((int )i < 25) {
#line 643
        if (! (! found)) {
#line 643
          goto while_break___0;
        }
      } else {
#line 643
        goto while_break___0;
      }
      {
#line 644
      gr_row_col(& row___0, & col___0, (unsigned short)197);
#line 645
      tmp = rogue_can_see((int )row___0, (int )col___0);
      }
#line 645
      if (! tmp) {
        {
#line 646
        put_m_at((int )row___0, (int )col___0, monster);
#line 647
        found = (char)1;
        }
      }
#line 643
      i = (short )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 650
    if (! found) {
      {
#line 651
      free_object(monster);
      }
    }
  }
#line 654
  return;
}
}
#line 656 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void show_monsters(void) 
{ 
  object *monster ;
  int tmp ;

  {
#line 661
  detect_monster = (char)1;
#line 663
  if (blind) {
#line 664
    return;
  }
#line 666
  monster = level_monsters.next_object;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! monster) {
#line 668
      goto while_break;
    }
    {
#line 669
    tmp = wmove(stdscr, (int )monster->row, (int )monster->col);
    }
#line 669
    if (! (tmp == -1)) {
      {
#line 669
      waddch(stdscr, (chtype const   )monster->ichar);
      }
    }
#line 670
    if (monster->m_flags & 4194304UL) {
#line 671
      monster->m_flags &= 0xffffffffffbfffffUL;
#line 672
      monster->m_flags |= 16UL;
    }
#line 674
    monster = monster->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 676
  return;
}
}
#line 678 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void create_monster(void) 
{ 
  short row___0 ;
  short col___0 ;
  short i ;
  char found ;
  object *monster ;
  char tmp ;
  int tmp___0 ;

  {
#line 683
  found = (char)0;
#line 686
  row___0 = rogue.row;
#line 687
  col___0 = rogue.col;
#line 689
  i = (short)0;
  {
#line 689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 689
    if (! ((int )i < 9)) {
#line 689
      goto while_break;
    }
    {
#line 690
    rand_around(i, & row___0, & col___0);
    }
#line 691
    if ((int )row___0 == (int )rogue.row) {
#line 691
      col___0 = rogue.col;
#line 691
      if (col___0) {
#line 694
        goto __Cont;
      } else {
#line 691
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 691
    if ((int )row___0 < 1) {
#line 694
      goto __Cont;
    } else
#line 691
    if ((int )row___0 > 22) {
#line 694
      goto __Cont;
    } else
#line 691
    if ((int )col___0 < 0) {
#line 694
      goto __Cont;
    } else
#line 691
    if ((int )col___0 > 79) {
#line 694
      goto __Cont;
    }
#line 696
    if (! ((int )dungeon[row___0][col___0] & 2)) {
#line 696
      if ((int )dungeon[row___0][col___0] & 228) {
#line 698
        found = (char)1;
#line 699
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 689
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 702
  if (found) {
    {
#line 703
    monster = gr_monster((object *)0, 0);
#line 704
    put_m_at((int )row___0, (int )col___0, monster);
#line 705
    tmp___0 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 705
    if (! (tmp___0 == -1)) {
      {
#line 705
      tmp = gmc(monster);
#line 705
      waddch(stdscr, (chtype const   )tmp);
      }
    }
#line 706
    if (monster->m_flags & 48UL) {
      {
#line 707
      wake_up(monster);
      }
    }
  } else {
    {
#line 710
    message("you hear a faint cry of anguish in the distance", (char)0);
    }
  }
#line 712
  return;
}
}
#line 714 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void put_m_at(short row___0 , short col___0 , object *monster ) 
{ 
  chtype tmp___0 ;
  int tmp___1 ;

  {
  {
#line 719
  monster->row = row___0;
#line 720
  monster->col = col___0;
#line 721
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 2);
#line 722
  tmp___1 = wmove(stdscr, (int )row___0, (int )col___0);
  }
#line 722
  if (tmp___1 == -1) {
#line 722
    monster->d_enchant = (short )((chtype )-1);
  } else {
    {
#line 722
    tmp___0 = winch(stdscr);
#line 722
    monster->d_enchant = (short )tmp___0;
    }
  }
  {
#line 723
  add_to_pack(monster, & level_monsters, 0);
#line 724
  aim_monster(monster);
  }
#line 725
  return;
}
}
#line 727 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void aim_monster(object *monster ) 
{ 
  short i ;
  short rn ;
  short d ;
  short r ;
  int tmp ;

  {
  {
#line 733
  rn = get_room_number((int )monster->row, (int )monster->col);
#line 734
  tmp = get_rand(0, 12);
#line 734
  r = (short )tmp;
#line 736
  i = (short)0;
  }
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! ((int )i < 4)) {
#line 736
      goto while_break;
    }
#line 737
    d = (short )(((int )r + (int )i) % 4);
#line 738
    if ((int )rooms[rn].doors[d].oth_room != -1) {
#line 739
      monster->trow = rooms[rn].doors[d].door_row;
#line 740
      monster->tcol = rooms[rn].doors[d].door_col;
#line 741
      goto while_break;
    }
#line 736
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 746 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int rogue_can_see(int row___0 , int col___0 ) 
{ 
  int retval ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 752
  if (! blind) {
    {
#line 752
    tmp = get_room_number(row___0, col___0);
    }
#line 752
    if ((int )tmp == (int )cur_room) {
#line 752
      if (! ((int )rooms[cur_room].is_room & 4)) {
#line 752
        tmp___1 = 1;
      } else {
#line 752
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 752
      tmp___0 = rogue_is_around(row___0, col___0);
      }
#line 752
      if (tmp___0) {
#line 752
        tmp___1 = 1;
      } else {
#line 752
        tmp___1 = 0;
      }
    }
  } else {
#line 752
    tmp___1 = 0;
  }
#line 752
  retval = tmp___1;
#line 757
  return (retval);
}
}
#line 760 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int move_confused(object *monster ) 
{ 
  short i ;
  short row___0 ;
  short col___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 766
  if (! (monster->m_flags & 8UL)) {
#line 767
    monster->hit_enchant = (short )((int )monster->hit_enchant - 1);
#line 767
    if ((int )monster->hit_enchant <= 0) {
#line 768
      monster->m_flags &= 0xfffffffffffffdffUL;
    }
#line 770
    if (monster->m_flags & 16777216UL) {
      {
#line 771
      tmp___1 = coin_toss();
      }
#line 771
      if (tmp___1) {
#line 771
        tmp___0 = 1;
      } else {
#line 771
        tmp___0 = 0;
      }
#line 771
      return (tmp___0);
    } else {
      {
#line 772
      tmp___2 = rand_percent(15);
      }
#line 772
      if (tmp___2) {
#line 773
        return (1);
      }
    }
#line 775
    row___0 = monster->row;
#line 776
    col___0 = monster->col;
#line 778
    i = (short)0;
    {
#line 778
    while (1) {
      while_continue: /* CIL Label */ ;
#line 778
      if (! ((int )i < 9)) {
#line 778
        goto while_break;
      }
      {
#line 779
      rand_around(i, & row___0, & col___0);
      }
#line 780
      if ((int )row___0 == (int )rogue.row) {
#line 780
        if ((int )col___0 == (int )rogue.col) {
#line 781
          return (0);
        }
      }
      {
#line 783
      tmp___3 = mtry(monster, row___0, col___0);
      }
#line 783
      if (tmp___3) {
#line 784
        return (1);
      }
#line 778
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 788
  return (0);
}
}
#line 791 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int flit(object *monster ) 
{ 
  short i ;
  short row___0 ;
  short col___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 797
  if (monster->m_flags & 64UL) {
#line 797
    tmp = 20;
  } else {
#line 797
    tmp = 0;
  }
  {
#line 797
  tmp___0 = rand_percent(40 + tmp);
  }
#line 797
  if (! tmp___0) {
#line 798
    return (0);
  }
  {
#line 800
  tmp___1 = rand_percent(10);
  }
#line 800
  if (tmp___1) {
#line 801
    return (1);
  }
#line 803
  row___0 = monster->row;
#line 804
  col___0 = monster->col;
#line 806
  i = (short)0;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! ((int )i < 9)) {
#line 806
      goto while_break;
    }
    {
#line 807
    rand_around(i, & row___0, & col___0);
    }
#line 808
    if ((int )row___0 == (int )rogue.row) {
#line 808
      if ((int )col___0 == (int )rogue.col) {
#line 809
        goto __Cont;
      }
    }
    {
#line 811
    tmp___2 = mtry(monster, row___0, col___0);
    }
#line 811
    if (tmp___2) {
#line 812
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 806
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 815
  return (1);
}
}
#line 818 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char gr_obj_char(void) 
{ 
  short r ;
  char const   *rs ;
  int tmp ;

  {
  {
#line 822
  rs = "%!?]=/):*";
#line 824
  tmp = get_rand(0, 8);
#line 824
  r = (short )tmp;
  }
#line 826
  return ((char )*(rs + r));
}
}
#line 829 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
int no_room_for_monster(int rn ) 
{ 
  short i ;
  short j ;

  {
#line 835
  i = (short )((int )rooms[rn].top_row + 1);
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! ((int )i < (int )rooms[rn].bottom_row)) {
#line 835
      goto while_break;
    }
#line 836
    j = (short )((int )rooms[rn].left_col + 1);
    {
#line 836
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 836
      if (! ((int )j < (int )rooms[rn].right_col)) {
#line 836
        goto while_break___0;
      }
#line 837
      if (! ((int )dungeon[i][j] & 2)) {
#line 838
        return (0);
      }
#line 836
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 835
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  return (1);
}
}
#line 845 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void aggravate(void) 
{ 
  object *monster ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 850
  message("you hear a high pitched humming noise", (char)0);
#line 852
  monster = level_monsters.next_object;
  }
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! monster) {
#line 854
      goto while_break;
    }
    {
#line 855
    wake_up(monster);
#line 856
    monster->m_flags &= 0xffffffffffbfffffUL;
#line 857
    tmp___0 = rogue_can_see((int )monster->row, (int )monster->col);
    }
#line 857
    if (tmp___0) {
      {
#line 858
      tmp = wmove(stdscr, (int )monster->row, (int )monster->col);
      }
#line 858
      if (! (tmp == -1)) {
        {
#line 858
        waddch(stdscr, (chtype const   )monster->ichar);
        }
      }
    }
#line 860
    monster = monster->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  return;
}
}
#line 864 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
char mon_sees(object const   *monster , int row___0 , int col___0 ) 
{ 
  short rn ;
  short rdif ;
  short cdif ;
  short retval ;
  short tmp ;
  int tmp___0 ;

  {
  {
#line 871
  rn = get_room_number(row___0, col___0);
  }
#line 873
  if ((int )rn != -1) {
    {
#line 873
    tmp = get_room_number((int )monster->row, (int )monster->col);
    }
#line 873
    if ((int )rn == (int )tmp) {
#line 873
      if (! ((int )rooms[rn].is_room & 4)) {
#line 876
        return ((char)1);
      }
    }
  }
#line 878
  rdif = (short )(row___0 - (int )monster->row);
#line 879
  cdif = (short )(col___0 - (int )monster->col);
#line 881
  if ((int )rdif >= -1) {
#line 881
    if ((int )rdif <= 1) {
#line 881
      if ((int )cdif >= -1) {
#line 881
        if ((int )cdif <= 1) {
#line 881
          tmp___0 = 1;
        } else {
#line 881
          tmp___0 = 0;
        }
      } else {
#line 881
        tmp___0 = 0;
      }
    } else {
#line 881
      tmp___0 = 0;
    }
  } else {
#line 881
    tmp___0 = 0;
  }
#line 881
  retval = (short )tmp___0;
#line 882
  return ((char )retval);
}
}
#line 885 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/monster.c"
void mv_aquatars(void) 
{ 
  object *monster ;
  int tmp ;

  {
#line 890
  monster = level_monsters.next_object;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (! monster) {
#line 892
      goto while_break;
    }
#line 893
    if ((int )monster->ichar == 65) {
      {
#line 893
      tmp = mon_can_go((object const   *)monster, rogue.row, rogue.col);
      }
#line 893
      if (tmp) {
        {
#line 895
        mv_1_monster(monster, rogue.row, rogue.col);
#line 896
        monster->m_flags |= 67108864UL;
        }
      }
    }
#line 898
    monster = monster->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return;
}
}
#line 447 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object *check_duplicate(object *obj , object *pack ) ;
#line 494
void do_wear(object *obj ) ;
#line 495
void do_wield(object *obj ) ;
#line 526
int get_input_line(char const   *prompt , char const   *insert , char *buf , char const   *if_cancelled ,
                   char add_blank , char do_echo ) ;
#line 551
char has_amulet(void) ;
#line 572
char is_pack_letter(short *c___0 , unsigned short *mask ) ;
#line 586
char mask_pack(object const   *pack , unsigned short mask ) ;
#line 617
short next_avail_ichar(void) ;
#line 626
short pack_count(object const   *new_obj ) ;
#line 722
void wait_for_ack(void) ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
char const   *curse_message  =    "you can\'t, it appears to be cursed";
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
object *add_to_pack(object *obj , object *pack , int condense ) 
{ 
  object *op ;

  {
#line 67
  if (condense) {
    {
#line 68
    op = check_duplicate(obj, pack);
    }
#line 68
    if ((unsigned long )op != (unsigned long )((void *)0)) {
      {
#line 69
      free_object(obj);
      }
#line 70
      return (op);
    } else {
      {
#line 72
      obj->ichar = next_avail_ichar();
      }
    }
  }
#line 75
  if ((unsigned long )pack->next_object == (unsigned long )((struct obj *)0)) {
#line 76
    pack->next_object = obj;
  } else {
#line 78
    op = pack->next_object;
    {
#line 80
    while (1) {
      while_continue: /* CIL Label */ ;
#line 80
      if (! op->next_object) {
#line 80
        goto while_break;
      }
#line 81
      op = op->next_object;
    }
    while_break: /* CIL Label */ ;
    }
#line 83
    op->next_object = obj;
  }
#line 85
  obj->next_object = (struct obj *)0;
#line 86
  return (obj);
}
}
#line 89 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void take_from_pack(object *obj , object *pack ) 
{ 


  {
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((unsigned long )pack->next_object != (unsigned long )obj)) {
#line 93
      goto while_break;
    }
#line 94
    pack = pack->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  pack->next_object = (pack->next_object)->next_object;
#line 97
  return;
}
}
#line 103 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
object *pick_up(int row___0 , int col___0 , short *status ) 
{ 
  object *obj ;
  short tmp ;

  {
#line 110
  *status = (short)1;
#line 112
  if (levitate) {
    {
#line 113
    message("you\'re floating in the air!", (char)0);
    }
#line 114
    return ((object *)0);
  }
  {
#line 116
  obj = object_at(& level_objects, (short )row___0, (short )col___0);
  }
#line 117
  if (! obj) {
    {
#line 118
    message("pick_up(): inconsistent", (char)1);
    }
#line 119
    return (obj);
  }
#line 121
  if ((int )obj->what_is == 4) {
#line 121
    if ((int )obj->which_kind == 7) {
#line 121
      if (obj->picked_up) {
        {
#line 124
        message("the scroll turns to dust as you pick it up", (char)0);
#line 125
        dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -2);
#line 126
        vanish(obj, (short)0, & level_objects);
#line 127
        *status = (short)0;
        }
#line 128
        if ((int )id_scrolls[7].id_status == 0) {
#line 129
          id_scrolls[7].id_status = (unsigned short)1;
        }
#line 131
        return ((object *)0);
      }
    }
  }
#line 133
  if ((int )obj->what_is == 16) {
    {
#line 134
    rogue.gold += (long )obj->quantity;
#line 135
    dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -2);
#line 136
    take_from_pack(obj, & level_objects);
#line 137
    print_stats(2);
    }
#line 138
    return (obj);
  }
  {
#line 140
  tmp = pack_count((object const   *)obj);
  }
#line 140
  if ((int )tmp >= 24) {
    {
#line 141
    message("pack too full", (char)1);
    }
#line 142
    return ((object *)0);
  }
  {
#line 144
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -2);
#line 145
  take_from_pack(obj, & level_objects);
#line 146
  obj = add_to_pack(obj, & rogue.pack, 1);
#line 147
  obj->picked_up = (short)1;
  }
#line 148
  return (obj);
}
}
#line 151 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void drop(void) 
{ 
  object *obj ;
  object *new ;
  short ch ;
  char desc[80] ;

  {
#line 158
  if ((int )dungeon[rogue.row][rogue.col] & 261) {
    {
#line 159
    message("there\'s already something there", (char)0);
    }
#line 160
    return;
  }
#line 162
  if (! rogue.pack.next_object) {
    {
#line 163
    message("you have nothing to drop", (char)0);
    }
#line 164
    return;
  }
  {
#line 166
  ch = pack_letter("drop what?", (unsigned short)511);
  }
#line 166
  if ((int )ch == 27) {
#line 167
    return;
  }
  {
#line 169
  obj = get_letter_object((int )ch);
  }
#line 169
  if (! obj) {
    {
#line 170
    message("no such item.", (char)0);
    }
#line 171
    return;
  }
#line 173
  if ((int )obj->in_use_flags & 1) {
#line 174
    if (obj->is_cursed) {
      {
#line 175
      message(curse_message, (char)0);
      }
#line 176
      return;
    }
    {
#line 178
    unwield(rogue.weapon);
    }
  } else
#line 179
  if ((int )obj->in_use_flags & 2) {
#line 180
    if (obj->is_cursed) {
      {
#line 181
      message(curse_message, (char)0);
      }
#line 182
      return;
    }
    {
#line 184
    mv_aquatars();
#line 185
    unwear(rogue.armor);
#line 186
    print_stats(16);
    }
  } else
#line 187
  if ((int )obj->in_use_flags & 12) {
#line 188
    if (obj->is_cursed) {
      {
#line 189
      message(curse_message, (char)0);
      }
#line 190
      return;
    }
    {
#line 192
    un_put_on(obj);
    }
  }
#line 194
  obj->row = rogue.row;
#line 195
  obj->col = rogue.col;
#line 197
  if ((int )obj->quantity > 1) {
#line 197
    if ((int )obj->what_is != 2) {
      {
#line 198
      obj->quantity = (short )((int )obj->quantity - 1);
#line 199
      new = alloc_object();
#line 200
      *new = *obj;
#line 201
      new->quantity = (short)1;
#line 202
      obj = new;
      }
    } else {
      {
#line 204
      obj->ichar = (short )'L';
#line 205
      take_from_pack(obj, & rogue.pack);
      }
    }
  } else {
    {
#line 204
    obj->ichar = (short )'L';
#line 205
    take_from_pack(obj, & rogue.pack);
    }
  }
  {
#line 207
  place_at(obj, (int )rogue.row, (int )rogue.col);
#line 208
  strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"dropped ");
#line 209
  get_desc((object const   *)obj, desc + 8);
#line 210
  message((char const   *)(desc), (char)0);
#line 211
  reg_move();
  }
#line 212
  return;
}
}
#line 214 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
object *check_duplicate(object *obj , object *pack ) 
{ 
  object *op ;

  {
#line 220
  if (! ((int )obj->what_is & 46)) {
#line 221
    return ((object *)0);
  }
#line 223
  if ((int )obj->what_is == 32) {
#line 223
    if ((int )obj->which_kind == 1) {
#line 224
      return ((object *)0);
    }
  }
#line 226
  op = pack->next_object;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! op) {
#line 228
      goto while_break;
    }
#line 229
    if ((int )op->what_is == (int )obj->what_is) {
#line 229
      if ((int )op->which_kind == (int )obj->which_kind) {
#line 232
        if ((int )obj->what_is != 2) {
#line 239
          op->quantity = (short )((int )op->quantity + (int )obj->quantity);
#line 240
          return (op);
        } else
#line 232
        if ((int )obj->what_is == 2) {
#line 232
          if ((int )obj->which_kind == 2) {
#line 232
            goto _L;
          } else
#line 232
          if ((int )obj->which_kind == 3) {
#line 232
            goto _L;
          } else
#line 232
          if ((int )obj->which_kind == 1) {
#line 232
            goto _L;
          } else
#line 232
          if ((int )obj->which_kind == 4) {
            _L: /* CIL Label */ 
#line 232
            if ((int )obj->quiver == (int )op->quiver) {
#line 239
              op->quantity = (short )((int )op->quantity + (int )obj->quantity);
#line 240
              return (op);
            }
          }
        }
      }
    }
#line 243
    op = op->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return ((object *)0);
}
}
#line 248 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
short next_avail_ichar(void) 
{ 
  object *obj ;
  int i ;
  char ichars[26] ;

  {
#line 255
  i = 0;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < 26)) {
#line 255
      goto while_break;
    }
#line 256
    ichars[i] = (char)0;
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  obj = rogue.pack.next_object;
  {
#line 259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 259
    if (! obj) {
#line 259
      goto while_break___0;
    }
#line 260
    ichars[(int )obj->ichar - 97] = (char)1;
#line 261
    obj = obj->next_object;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 263
    if (! (i < 26)) {
#line 263
      goto while_break___1;
    }
#line 264
    if (! ichars[i]) {
#line 265
      return ((short )(i + 97));
    }
#line 263
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 268
  return ((short )'?');
}
}
#line 271 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void wait_for_ack(void) 
{ 
  int tmp ;

  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 274
    tmp = rgetchar();
    }
#line 274
    if (! (tmp != 32)) {
#line 274
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 277 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
short pack_letter(char const   *prompt , unsigned short mask ) 
{ 
  short ch ;
  unsigned short tmask ;
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;

  {
  {
#line 283
  tmask = mask;
#line 285
  tmp = mask_pack((object const   *)(& rogue.pack), mask);
  }
#line 285
  if (! tmp) {
    {
#line 286
    message("nothing appropriate", (char)0);
    }
#line 287
    return ((short )'\033');
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 291
    message(prompt, (char)0);
    }
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 294
      tmp___0 = rgetchar();
#line 294
      ch = (short )tmp___0;
#line 295
      tmp___1 = is_pack_letter(& ch, & mask);
      }
#line 295
      if (tmp___1) {
#line 298
        goto while_break___0;
      } else {
        {
#line 296
        sound_bell();
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 302
    if ((int )ch == 42) {
      {
#line 303
      check_message();
#line 304
      mask = tmask;
#line 305
      inventory((object const   *)(& rogue.pack), mask);
      }
    } else {
#line 307
      goto while_break;
    }
#line 309
    mask = tmask;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  check_message();
  }
#line 312
  return (ch);
}
}
#line 315 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void take_off(void) 
{ 
  char desc[80] ;
  object *obj ;

  {
#line 321
  if (rogue.armor) {
#line 322
    if ((rogue.armor)->is_cursed) {
      {
#line 323
      message(curse_message, (char)0);
      }
    } else {
      {
#line 325
      mv_aquatars();
#line 326
      obj = rogue.armor;
#line 327
      unwear(rogue.armor);
#line 328
      strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"was wearing ");
#line 329
      get_desc((object const   *)obj, desc + 12);
#line 330
      message((char const   *)(desc), (char)0);
#line 331
      print_stats(16);
#line 332
      reg_move();
      }
    }
  } else {
    {
#line 335
    message("not wearing any", (char)0);
    }
  }
#line 337
  return;
}
}
#line 339 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void wear(void) 
{ 
  short ch ;
  object *obj ;
  char desc[80] ;

  {
#line 346
  if (rogue.armor) {
    {
#line 347
    message("your already wearing some", (char)0);
    }
#line 348
    return;
  }
  {
#line 350
  ch = pack_letter("wear what?", (unsigned short)1);
  }
#line 352
  if ((int )ch == 27) {
#line 353
    return;
  }
  {
#line 355
  obj = get_letter_object((int )ch);
  }
#line 355
  if (! obj) {
    {
#line 356
    message("no such item.", (char)0);
    }
#line 357
    return;
  }
#line 359
  if ((int )obj->what_is != 1) {
    {
#line 360
    message("you can\'t wear that", (char)0);
    }
#line 361
    return;
  }
  {
#line 363
  obj->identified = (short)1;
#line 364
  strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"wearing ");
#line 365
  get_desc((object const   *)obj, desc + 8);
#line 366
  message((char const   *)(desc), (char)0);
#line 367
  do_wear(obj);
#line 368
  print_stats(16);
#line 369
  reg_move();
  }
#line 370
  return;
}
}
#line 372 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void unwear(object *obj ) 
{ 


  {
#line 376
  if (obj) {
#line 377
    obj->in_use_flags = (unsigned short )((int )obj->in_use_flags & -3);
  }
#line 379
  rogue.armor = (object *)0;
#line 380
  return;
}
}
#line 382 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void do_wear(object *obj ) 
{ 


  {
#line 386
  rogue.armor = obj;
#line 387
  obj->in_use_flags = (unsigned short )((int )obj->in_use_flags | 2);
#line 388
  obj->identified = (short)1;
#line 389
  return;
}
}
#line 391 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void wield(void) 
{ 
  short ch ;
  object *obj ;
  char desc[80] ;
  char const   *tmp ;

  {
#line 398
  if (rogue.weapon) {
#line 398
    if ((rogue.weapon)->is_cursed) {
      {
#line 399
      message(curse_message, (char)0);
      }
#line 400
      return;
    }
  }
  {
#line 402
  ch = pack_letter("wield what?", (unsigned short)2);
  }
#line 404
  if ((int )ch == 27) {
#line 405
    return;
  }
  {
#line 407
  obj = get_letter_object((int )ch);
  }
#line 407
  if (! obj) {
    {
#line 408
    message("No such item.", (char)0);
    }
#line 409
    return;
  }
#line 411
  if ((int )obj->what_is & 129) {
#line 412
    if ((int )obj->what_is == 1) {
#line 412
      tmp = "armor";
    } else {
#line 412
      tmp = "rings";
    }
    {
#line 412
    sprintf((char */* __restrict  */)(desc), (char const   */* __restrict  */)"you can\'t wield %s",
            tmp);
#line 414
    message((char const   *)(desc), (char)0);
    }
#line 415
    return;
  }
#line 417
  if ((int )obj->in_use_flags & 1) {
    {
#line 418
    message("in use", (char)0);
    }
  } else {
    {
#line 420
    unwield(rogue.weapon);
#line 421
    strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"wielding ");
#line 422
    get_desc((object const   *)obj, desc + 9);
#line 423
    message((char const   *)(desc), (char)0);
#line 424
    do_wield(obj);
#line 425
    reg_move();
    }
  }
#line 427
  return;
}
}
#line 429 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void do_wield(object *obj ) 
{ 


  {
#line 433
  rogue.weapon = obj;
#line 434
  obj->in_use_flags = (unsigned short )((int )obj->in_use_flags | 1);
#line 435
  return;
}
}
#line 437 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void unwield(object *obj ) 
{ 


  {
#line 441
  if (obj) {
#line 442
    obj->in_use_flags = (unsigned short )((int )obj->in_use_flags & -2);
  }
#line 444
  rogue.weapon = (object *)0;
#line 445
  return;
}
}
#line 447 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void call_it(void) 
{ 
  short ch ;
  object *obj ;
  struct id *id_table ;
  char buf[32] ;
  int tmp ;

  {
  {
#line 455
  ch = pack_letter("call what?", (unsigned short)204);
  }
#line 457
  if ((int )ch == 27) {
#line 458
    return;
  }
  {
#line 460
  obj = get_letter_object((int )ch);
  }
#line 460
  if (! obj) {
    {
#line 461
    message("no such item.", (char)0);
    }
#line 462
    return;
  }
#line 464
  if (! ((int )obj->what_is & 204)) {
    {
#line 465
    message("surely you already know what that\'s called", (char)0);
    }
#line 466
    return;
  }
  {
#line 468
  id_table = get_id_table((object const   *)obj);
#line 470
  tmp = get_input_line("call it:", "", buf, (char const   *)((id_table + obj->which_kind)->title),
                       (char)1, (char)1);
  }
#line 470
  if (tmp) {
    {
#line 471
    (id_table + obj->which_kind)->id_status = (unsigned short)2;
#line 472
    strcpy((char */* __restrict  */)((id_table + obj->which_kind)->title), (char const   */* __restrict  */)(buf));
    }
  }
#line 474
  return;
}
}
#line 476 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
short pack_count(object const   *new_obj ) 
{ 
  object *obj ;
  short count ;

  {
#line 481
  count = (short)0;
#line 483
  obj = rogue.pack.next_object;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! obj) {
#line 485
      goto while_break;
    }
#line 486
    if ((int )obj->what_is != 2) {
#line 487
      count = (short )((int )count + (int )obj->quantity);
    } else
#line 488
    if (! new_obj) {
#line 489
      count = (short )((int )count + 1);
    } else
#line 490
    if ((int const   )new_obj->what_is != 2) {
#line 497
      count = (short )((int )count + 1);
    } else
#line 490
    if ((int )obj->which_kind != 2) {
#line 490
      if ((int )obj->which_kind != 3) {
#line 490
        if ((int )obj->which_kind != 1) {
#line 490
          if ((int )obj->which_kind != 4) {
#line 497
            count = (short )((int )count + 1);
          } else {
#line 490
            goto _L___1;
          }
        } else {
#line 490
          goto _L___1;
        }
      } else {
#line 490
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 490
    if ((int const   )new_obj->which_kind != (int const   )obj->which_kind) {
#line 497
      count = (short )((int )count + 1);
    } else
#line 490
    if ((int )obj->quiver != (int )new_obj->quiver) {
#line 497
      count = (short )((int )count + 1);
    }
#line 499
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  return (count);
}
}
#line 504 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
char mask_pack(object const   *pack , unsigned short mask ) 
{ 


  {
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! pack->next_object) {
#line 509
      goto while_break;
    }
#line 510
    pack = (object const   *)pack->next_object;
#line 511
    if ((int const   )pack->what_is & (int const   )mask) {
#line 512
      return ((char)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return ((char)0);
}
}
#line 518 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
char is_pack_letter(short *c___0 , unsigned short *mask ) 
{ 
  int tmp ;

  {
#line 523
  if ((int )*c___0 == 63) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 33) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 58) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 61) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 41) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 93) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 47) {
#line 523
    goto _L;
  } else
#line 523
  if ((int )*c___0 == 44) {
    _L: /* CIL Label */ 
    {
#line 526
    if ((int )*c___0 == 63) {
#line 526
      goto case_63;
    }
#line 529
    if ((int )*c___0 == 33) {
#line 529
      goto case_33;
    }
#line 532
    if ((int )*c___0 == 58) {
#line 532
      goto case_58;
    }
#line 535
    if ((int )*c___0 == 41) {
#line 535
      goto case_41;
    }
#line 538
    if ((int )*c___0 == 93) {
#line 538
      goto case_93;
    }
#line 541
    if ((int )*c___0 == 47) {
#line 541
      goto case_47;
    }
#line 544
    if ((int )*c___0 == 61) {
#line 544
      goto case_61;
    }
#line 547
    if ((int )*c___0 == 44) {
#line 547
      goto case_44;
    }
#line 525
    goto switch_break;
    case_63: /* CIL Label */ 
#line 527
    *mask = (unsigned short)4;
#line 528
    goto switch_break;
    case_33: /* CIL Label */ 
#line 530
    *mask = (unsigned short)8;
#line 531
    goto switch_break;
    case_58: /* CIL Label */ 
#line 533
    *mask = (unsigned short)32;
#line 534
    goto switch_break;
    case_41: /* CIL Label */ 
#line 536
    *mask = (unsigned short)2;
#line 537
    goto switch_break;
    case_93: /* CIL Label */ 
#line 539
    *mask = (unsigned short)1;
#line 540
    goto switch_break;
    case_47: /* CIL Label */ 
#line 542
    *mask = (unsigned short)64;
#line 543
    goto switch_break;
    case_61: /* CIL Label */ 
#line 545
    *mask = (unsigned short)128;
#line 546
    goto switch_break;
    case_44: /* CIL Label */ 
#line 548
    *mask = (unsigned short)256;
#line 549
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 551
    *c___0 = (short )'*';
#line 552
    return ((char)1);
  }
#line 554
  if ((int )*c___0 >= 97) {
#line 554
    if ((int )*c___0 <= 122) {
#line 554
      tmp = 1;
    } else {
#line 554
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 554
  if ((int )*c___0 == 27) {
#line 554
    tmp = 1;
  } else
#line 554
  if ((int )*c___0 == 42) {
#line 554
    tmp = 1;
  } else {
#line 554
    tmp = 0;
  }
#line 554
  return ((char )tmp);
}
}
#line 557 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
char has_amulet(void) 
{ 
  char tmp ;

  {
  {
#line 560
  tmp = mask_pack((object const   *)(& rogue.pack), (unsigned short)256);
  }
#line 560
  return (tmp);
}
}
#line 563 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/pack.c"
void kick_into_pack(void) 
{ 
  object *obj ;
  char desc[80] ;
  short n___0 ;
  short stat___0 ;
  size_t tmp ;

  {
#line 570
  if (! ((int )dungeon[rogue.row][rogue.col] & 1)) {
    {
#line 571
    message("nothing here", (char)0);
    }
  } else {
    {
#line 573
    obj = pick_up((int )rogue.row, (int )rogue.col, & stat___0);
    }
#line 573
    if ((unsigned long )obj != (unsigned long )((void *)0)) {
      {
#line 574
      get_desc((object const   *)obj, desc);
      }
#line 575
      if ((int )obj->what_is == 16) {
        {
#line 576
        message((char const   *)(desc), (char)0);
#line 577
        free_object(obj);
        }
      } else {
        {
#line 579
        tmp = strlen((char const   *)(desc));
#line 579
        n___0 = (short )tmp;
#line 580
        desc[n___0] = (char )'(';
#line 581
        desc[(int )n___0 + 1] = (char )obj->ichar;
#line 582
        desc[(int )n___0 + 2] = (char )')';
#line 583
        desc[(int )n___0 + 3] = (char)0;
#line 584
        message((char const   *)(desc), (char)0);
        }
      }
    }
#line 587
    if (obj) {
      {
#line 588
      reg_move();
      }
    } else
#line 587
    if (! stat___0) {
      {
#line 588
      reg_move();
      }
    }
  }
#line 591
  return;
}
}
#line 341 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
trap traps[10]  ;
#line 518
int get_damage(char const   *ds , char r ) ;
#line 674
void rust(object *monster ) ;
#line 709
short trap_at(int row___0 , int col___0 ) ;
#line 773
char const   *new_level_message ;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
char trap_door  =    (char)0;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
short bear_trap  =    (short)0;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
char const   * const  trap_strings[12]  = 
#line 62
  {      (char const   */* const  */)"trap door",      (char const   */* const  */)"you fell down a trap",      (char const   */* const  */)"bear trap",      (char const   */* const  */)"you are caught in a bear trap", 
        (char const   */* const  */)"teleport trap",      (char const   */* const  */)"teleport",      (char const   */* const  */)"poison dart trap",      (char const   */* const  */)"a small dart just hit you in the shoulder", 
        (char const   */* const  */)"sleeping gas trap",      (char const   */* const  */)"a strange white mist envelops you and you fall asleep",      (char const   */* const  */)"rust trap",      (char const   */* const  */)"a gush of water hits you on the head"};
#line 77 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
short trap_at(int row___0 , int col___0 ) 
{ 
  short i ;

  {
#line 83
  i = (short)0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if ((int )i < 10) {
#line 83
      if (! ((int )traps[i].trap_type != -1)) {
#line 83
        goto while_break;
      }
    } else {
#line 83
      goto while_break;
    }
#line 84
    if ((int )traps[i].trap_row == row___0) {
#line 84
      if ((int )traps[i].trap_col == col___0) {
#line 85
        return (traps[i].trap_type);
      }
    }
#line 83
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return ((short)-1);
}
}
#line 91 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
void trap_player(short row___0 , short col___0 ) 
{ 
  short t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 97
  t = trap_at((int )row___0, (int )col___0);
  }
#line 97
  if ((int )t == -1) {
#line 98
    return;
  }
  {
#line 100
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -513);
#line 101
  tmp = rand_percent((int )rogue.exp + (int )ring_exp);
  }
#line 101
  if (tmp) {
    {
#line 102
    message("the trap failed", (char)1);
    }
#line 103
    return;
  }
  {
#line 106
  if ((int )t == 0) {
#line 106
    goto case_0;
  }
#line 110
  if ((int )t == 1) {
#line 110
    goto case_1;
  }
#line 114
  if ((int )t == 2) {
#line 114
    goto case_2;
  }
#line 118
  if ((int )t == 3) {
#line 118
    goto case_3;
  }
#line 133
  if ((int )t == 4) {
#line 133
    goto case_4;
  }
#line 137
  if ((int )t == 5) {
#line 137
    goto case_5;
  }
#line 105
  goto switch_break;
  case_0: /* CIL Label */ 
#line 107
  trap_door = (char)1;
#line 108
  new_level_message = (char const   *)trap_strings[(int )t * 2 + 1];
#line 109
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 111
  message((char const   *)trap_strings[(int )t * 2 + 1], (char)1);
#line 112
  tmp___0 = get_rand(4, 7);
#line 112
  bear_trap = (short )tmp___0;
  }
#line 113
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 115
  tmp___1 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 115
  if (! (tmp___1 == -1)) {
    {
#line 115
    waddch(stdscr, (chtype const   )'^');
    }
  }
  {
#line 116
  tele();
  }
#line 117
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 119
  message((char const   *)trap_strings[(int )t * 2 + 1], (char)1);
#line 120
  tmp___2 = get_damage("1d6", (char)1);
#line 120
  rogue.hp_current = (short )((int )rogue.hp_current - tmp___2);
  }
#line 121
  if ((int )rogue.hp_current <= 0) {
#line 122
    rogue.hp_current = (short)0;
  }
#line 124
  if (! sustain_strength) {
    {
#line 124
    tmp___3 = rand_percent(40);
    }
#line 124
    if (tmp___3) {
#line 124
      if ((int )rogue.str_current >= 3) {
#line 126
        rogue.str_current = (short )((int )rogue.str_current - 1);
      }
    }
  }
  {
#line 128
  print_stats(12);
  }
#line 129
  if ((int )rogue.hp_current <= 0) {
    {
#line 130
    killed_by((object const   *)((object *)0), (short)3);
    }
  }
#line 132
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 134
  message((char const   *)trap_strings[(int )t * 2 + 1], (char)1);
#line 135
  take_a_nap();
  }
#line 136
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 138
  message((char const   *)trap_strings[(int )t * 2 + 1], (char)1);
#line 139
  rust((object *)0);
  }
#line 140
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
void add_traps(void) 
{ 
  short i ;
  short n___0 ;
  short tries ;
  short row___0 ;
  short col___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 147
  tries = (short)0;
#line 150
  if ((int )cur_level <= 2) {
#line 151
    n___0 = (short)0;
  } else
#line 152
  if ((int )cur_level <= 7) {
    {
#line 153
    tmp = get_rand(0, 2);
#line 153
    n___0 = (short )tmp;
    }
  } else
#line 154
  if ((int )cur_level <= 11) {
    {
#line 155
    tmp___0 = get_rand(1, 2);
#line 155
    n___0 = (short )tmp___0;
    }
  } else
#line 156
  if ((int )cur_level <= 16) {
    {
#line 157
    tmp___1 = get_rand(2, 3);
#line 157
    n___0 = (short )tmp___1;
    }
  } else
#line 158
  if ((int )cur_level <= 21) {
    {
#line 159
    tmp___2 = get_rand(2, 4);
#line 159
    n___0 = (short )tmp___2;
    }
  } else
#line 160
  if ((int )cur_level <= 28) {
    {
#line 161
    tmp___3 = get_rand(3, 5);
#line 161
    n___0 = (short )tmp___3;
    }
  } else {
    {
#line 163
    tmp___4 = get_rand(5, 10);
#line 163
    n___0 = (short )tmp___4;
    }
  }
#line 165
  i = (short)0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((int )i < (int )n___0)) {
#line 165
      goto while_break;
    }
    {
#line 166
    tmp___5 = get_rand(0, 5);
#line 166
    traps[i].trap_type = (short )tmp___5;
    }
#line 168
    if ((int )i == 0) {
#line 168
      if ((int )party_room != -1) {
        {
#line 169
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 170
          tmp___6 = get_rand((int )rooms[party_room].top_row + 1, (int )rooms[party_room].bottom_row - 1);
#line 170
          row___0 = (short )tmp___6;
#line 172
          tmp___7 = get_rand((int )rooms[party_room].left_col + 1, (int )rooms[party_room].right_col - 1);
#line 172
          col___0 = (short )tmp___7;
#line 174
          tries = (short )((int )tries + 1);
          }
#line 169
          if ((int )dungeon[row___0][col___0] & 389) {
#line 169
            goto _L;
          } else
#line 169
          if ((int )dungeon[row___0][col___0] == 0) {
            _L: /* CIL Label */ 
#line 169
            if (! ((int )tries < 15)) {
#line 169
              goto while_break___0;
            }
          } else {
#line 169
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 177
        if ((int )tries >= 15) {
          {
#line 178
          gr_row_col(& row___0, & col___0, (unsigned short)66);
          }
        }
      } else {
        {
#line 181
        gr_row_col(& row___0, & col___0, (unsigned short)66);
        }
      }
    } else {
      {
#line 181
      gr_row_col(& row___0, & col___0, (unsigned short)66);
      }
    }
#line 183
    traps[i].trap_row = row___0;
#line 184
    traps[i].trap_col = col___0;
#line 185
    dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 768);
#line 165
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
void id_trap(void) 
{ 
  short dir ;
  short row___0 ;
  short col___0 ;
  short d ;
  short t ;
  int tmp ;
  char tmp___0 ;

  {
  {
#line 194
  message("direction? ", (char)0);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp = rgetchar();
#line 196
    dir = (short )tmp;
#line 196
    tmp___0 = is_direction(dir, & d);
    }
#line 196
    if (tmp___0) {
#line 196
      goto while_break;
    }
    {
#line 197
    sound_bell();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  check_message();
  }
#line 201
  if ((int )dir == 27) {
#line 202
    return;
  }
  {
#line 204
  row___0 = rogue.row;
#line 205
  col___0 = rogue.col;
#line 207
  get_dir_rc(d, & row___0, & col___0, (short)0);
  }
#line 209
  if ((int )dungeon[row___0][col___0] & 256) {
#line 209
    if (! ((int )dungeon[row___0][col___0] & 512)) {
      {
#line 210
      t = trap_at((int )row___0, (int )col___0);
#line 211
      message((char const   *)trap_strings[(int )t * 2], (char)0);
      }
    } else {
      {
#line 213
      message("no trap there", (char)0);
      }
    }
  } else {
    {
#line 213
    message("no trap there", (char)0);
    }
  }
#line 215
  return;
}
}
#line 217 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
void show_traps(void) 
{ 
  short i ;
  short j ;
  int tmp ;

  {
#line 222
  i = (short)0;
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! ((int )i < 24)) {
#line 222
      goto while_break;
    }
#line 223
    j = (short)0;
    {
#line 223
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 223
      if (! ((int )j < 80)) {
#line 223
        goto while_break___0;
      }
#line 224
      if ((int )dungeon[i][j] & 256) {
        {
#line 225
        tmp = wmove(stdscr, (int )i, (int )j);
        }
#line 225
        if (! (tmp == -1)) {
          {
#line 225
          waddch(stdscr, (chtype const   )'^');
          }
        }
      }
#line 223
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 222
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 238 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
static char reg_search  ;
#line 231 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/trap.c"
void search(short n___0 , char is_auto ) 
{ 
  short s___0 ;
  short i ;
  short j ;
  short row___0 ;
  short col___0 ;
  short t ;
  short shown ;
  short found ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 237
  shown = (short)0;
#line 237
  found = (short)0;
#line 240
  i = (short)-1;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((int )i <= 1)) {
#line 240
      goto while_break;
    }
#line 241
    j = (short)-1;
    {
#line 241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 241
      if (! ((int )j <= 1)) {
#line 241
        goto while_break___0;
      }
#line 242
      row___0 = (short )((int )rogue.row + (int )i);
#line 243
      col___0 = (short )((int )rogue.col + (int )j);
#line 244
      if ((int )row___0 < 1) {
#line 246
        goto __Cont;
      } else
#line 244
      if ((int )row___0 >= 23) {
#line 246
        goto __Cont;
      } else
#line 244
      if ((int )col___0 < 0) {
#line 246
        goto __Cont;
      } else
#line 244
      if ((int )col___0 >= 80) {
#line 246
        goto __Cont;
      }
#line 248
      if ((int )dungeon[row___0][col___0] & 512) {
#line 249
        found = (short )((int )found + 1);
      }
      __Cont: /* CIL Label */ 
#line 241
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 240
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  s___0 = (short)0;
  {
#line 253
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 253
    if (! ((int )s___0 < (int )n___0)) {
#line 253
      goto while_break___1;
    }
#line 254
    i = (short)-1;
    {
#line 254
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 254
      if (! ((int )i <= 1)) {
#line 254
        goto while_break___2;
      }
#line 255
      j = (short)-1;
      {
#line 255
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 255
        if (! ((int )j <= 1)) {
#line 255
          goto while_break___3;
        }
#line 256
        row___0 = (short )((int )rogue.row + (int )i);
#line 257
        col___0 = (short )((int )rogue.col + (int )j);
#line 258
        if ((int )row___0 < 1) {
#line 260
          goto __Cont___0;
        } else
#line 258
        if ((int )row___0 >= 23) {
#line 260
          goto __Cont___0;
        } else
#line 258
        if ((int )col___0 < 0) {
#line 260
          goto __Cont___0;
        } else
#line 258
        if ((int )col___0 >= 80) {
#line 260
          goto __Cont___0;
        }
#line 262
        if ((int )dungeon[row___0][col___0] & 512) {
          {
#line 263
          tmp___1 = rand_percent(17 + ((int )rogue.exp + (int )ring_exp));
          }
#line 263
          if (tmp___1) {
#line 264
            dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -513);
#line 265
            if (! blind) {
#line 265
              if ((int )row___0 != (int )rogue.row) {
#line 265
                goto _L;
              } else
#line 265
              if ((int )col___0 != (int )rogue.col) {
                _L: /* CIL Label */ 
                {
#line 267
                tmp___0 = wmove(stdscr, (int )row___0, (int )col___0);
                }
#line 267
                if (! (tmp___0 == -1)) {
                  {
#line 267
                  tmp = get_dungeon_char(row___0, col___0);
#line 267
                  waddch(stdscr, (chtype const   )tmp);
                  }
                }
              }
            }
#line 269
            shown = (short )((int )shown + 1);
#line 270
            if ((int )dungeon[row___0][col___0] & 256) {
              {
#line 271
              t = trap_at((int )row___0, (int )col___0);
#line 272
              message((char const   *)trap_strings[(int )t * 2], (char)1);
              }
            }
          }
        }
#line 276
        if ((int )shown == (int )found) {
#line 276
          if ((int )found > 0) {
#line 277
            return;
          } else {
#line 276
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 276
        if (interrupted) {
#line 277
          return;
        }
        __Cont___0: /* CIL Label */ 
#line 255
        j = (short )((int )j + 1);
      }
      while_break___3: /* CIL Label */ ;
      }
#line 254
      i = (short )((int )i + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 281
    if (! is_auto) {
#line 281
      reg_search = (char )(! reg_search);
#line 281
      if (reg_search) {
        {
#line 282
        reg_move();
        }
      }
    }
#line 253
    s___0 = (short )((int )s___0 + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 285
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 347 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
struct id id_wands[11] ;
#line 348
struct id id_rings[11] ;
#line 349
struct id id_weapons[8] ;
#line 350
struct id id_armors[7] ;
#line 788 "/usr/include/curses.h"
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 727 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setegid)(__gid_t __gid ) ;
#line 474 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void center(short row___0 , char const   *buf ) ;
#line 480
 __attribute__((__noreturn__)) void clean_up(char const   *estr ) ;
#line 532
int get_value(object const   *obj ) ;
#line 557
void id_all(void) ;
#line 565
void insert_score(char (*scores)[82] , char (*n_names)[30] , char const   *n_name ,
                  short rank , short n___0 , object const   *monster , int other ) ;
#line 574
char is_vowel(short ch ) ;
#line 577
long lget_number(char const   *s___0 ) ;
#line 594
void md_heed_signals(void) ;
#line 595
void md_ignore_signals(void) ;
#line 597
void md_lock(char l ) ;
#line 616
int name_cmp(char *s1 , char const   *s2 ) ;
#line 619
void nickize(char *buf , char const   *score , char const   *n_name ) ;
#line 647
 __attribute__((__noreturn__)) void put_scores(object const   *monster , short other ) ;
#line 686
void sell_pack(void) ;
#line 687
 __attribute__((__noreturn__)) void sf_error(void) ;
#line 729
 __attribute__((__noreturn__)) void win(void) ;
#line 733
long xxx(char st ) ;
#line 734
void xxxx(char *buf , short n___0 ) ;
#line 752
char msg_cleared ;
#line 753
char no_skull ;
#line 758
char score_only ;
#line 766
char login_name[40] ;
#line 767
char const   *byebye_string ;
#line 774
char *nick_name ;
#line 800
gid_t gid ;
#line 801
gid_t egid ;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
 __attribute__((__noreturn__)) void killed_by(object const   *monster , short other ) ;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void killed_by(object const   *monster , short other ) 
{ 
  char buf[128] ;
  char tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 67
  md_ignore_signals();
  }
#line 69
  if ((int )other != 4) {
#line 70
    rogue.gold = (rogue.gold * 9L) / 10L;
  }
#line 73
  if (other) {
    {
#line 75
    if ((int )other == 1) {
#line 75
      goto case_1;
    }
#line 78
    if ((int )other == 2) {
#line 78
      goto case_2;
    }
#line 81
    if ((int )other == 3) {
#line 81
      goto case_3;
    }
#line 84
    if ((int )other == 4) {
#line 84
      goto case_4;
    }
#line 87
    if ((int )other == 6) {
#line 87
      goto case_6;
    }
#line 74
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 76
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"died of hypothermia");
    }
#line 77
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 79
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"died of starvation");
    }
#line 80
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 82
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"killed by a dart");
    }
#line 83
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 85
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"quit");
    }
#line 86
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 88
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"killed by fire");
    }
#line 89
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 92
    strcpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Killed by ");
#line 93
    tmp = is_vowel((short )*(m_names[(int const   )monster->ichar - 65] + 0));
    }
#line 93
    if (tmp) {
      {
#line 94
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"an ");
      }
    } else {
      {
#line 96
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"a ");
      }
    }
    {
#line 98
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)m_names[(int const   )monster->ichar - 65]);
    }
  }
  {
#line 100
  strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)" with ");
#line 101
  tmp___0 = strlen((char const   *)(buf));
#line 101
  sprintf((char */* __restrict  */)(buf + tmp___0), (char const   */* __restrict  */)"%ld gold",
          rogue.gold);
  }
#line 102
  if (! other) {
#line 102
    if (! no_skull) {
      {
#line 103
      wclear(stdscr);
#line 104
      tmp___1 = wmove(stdscr, 4, 32);
      }
#line 104
      if (! (tmp___1 == -1)) {
        {
#line 104
        waddnstr(stdscr, "__---------__", -1);
        }
      }
      {
#line 105
      tmp___2 = wmove(stdscr, 5, 30);
      }
#line 105
      if (! (tmp___2 == -1)) {
        {
#line 105
        waddnstr(stdscr, "_~             ~_", -1);
        }
      }
      {
#line 106
      tmp___3 = wmove(stdscr, 6, 29);
      }
#line 106
      if (! (tmp___3 == -1)) {
        {
#line 106
        waddnstr(stdscr, "/                 \\", -1);
        }
      }
      {
#line 107
      tmp___4 = wmove(stdscr, 7, 28);
      }
#line 107
      if (! (tmp___4 == -1)) {
        {
#line 107
        waddnstr(stdscr, "~                   ~", -1);
        }
      }
      {
#line 108
      tmp___5 = wmove(stdscr, 8, 27);
      }
#line 108
      if (! (tmp___5 == -1)) {
        {
#line 108
        waddnstr(stdscr, "/                     \\", -1);
        }
      }
      {
#line 109
      tmp___6 = wmove(stdscr, 9, 27);
      }
#line 109
      if (! (tmp___6 == -1)) {
        {
#line 109
        waddnstr(stdscr, "|    XXXX     XXXX    |", -1);
        }
      }
      {
#line 110
      tmp___7 = wmove(stdscr, 10, 27);
      }
#line 110
      if (! (tmp___7 == -1)) {
        {
#line 110
        waddnstr(stdscr, "|    XXXX     XXXX    |", -1);
        }
      }
      {
#line 111
      tmp___8 = wmove(stdscr, 11, 27);
      }
#line 111
      if (! (tmp___8 == -1)) {
        {
#line 111
        waddnstr(stdscr, "|    XXX       XXX    |", -1);
        }
      }
      {
#line 112
      tmp___9 = wmove(stdscr, 12, 28);
      }
#line 112
      if (! (tmp___9 == -1)) {
        {
#line 112
        waddnstr(stdscr, "\\         @         /", -1);
        }
      }
      {
#line 113
      tmp___10 = wmove(stdscr, 13, 29);
      }
#line 113
      if (! (tmp___10 == -1)) {
        {
#line 113
        waddnstr(stdscr, "--\\     @@@     /--", -1);
        }
      }
      {
#line 114
      tmp___11 = wmove(stdscr, 14, 30);
      }
#line 114
      if (! (tmp___11 == -1)) {
        {
#line 114
        waddnstr(stdscr, "| |    @@@    | |", -1);
        }
      }
      {
#line 115
      tmp___12 = wmove(stdscr, 15, 30);
      }
#line 115
      if (! (tmp___12 == -1)) {
        {
#line 115
        waddnstr(stdscr, "| |           | |", -1);
        }
      }
      {
#line 116
      tmp___13 = wmove(stdscr, 16, 30);
      }
#line 116
      if (! (tmp___13 == -1)) {
        {
#line 116
        waddnstr(stdscr, "| vvVvvvvvvvVvv |", -1);
        }
      }
      {
#line 117
      tmp___14 = wmove(stdscr, 17, 30);
      }
#line 117
      if (! (tmp___14 == -1)) {
        {
#line 117
        waddnstr(stdscr, "|  ^^^^^^^^^^^  |", -1);
        }
      }
      {
#line 118
      tmp___15 = wmove(stdscr, 18, 31);
      }
#line 118
      if (! (tmp___15 == -1)) {
        {
#line 118
        waddnstr(stdscr, "\\_           _/", -1);
        }
      }
      {
#line 119
      tmp___16 = wmove(stdscr, 19, 33);
      }
#line 119
      if (! (tmp___16 == -1)) {
        {
#line 119
        waddnstr(stdscr, "~---------~", -1);
        }
      }
      {
#line 120
      center((short)21, (char const   *)nick_name);
#line 121
      center((short)22, (char const   *)(buf));
      }
    } else {
      {
#line 123
      message((char const   *)(buf), (char)0);
      }
    }
  } else {
    {
#line 123
    message((char const   *)(buf), (char)0);
    }
  }
  {
#line 125
  message("", (char)0);
#line 126
  put_scores(monster, other);
  }
}
}
#line 129
 __attribute__((__noreturn__)) void win(void) ;
#line 129 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void win(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 132
  unwield(rogue.weapon);
#line 133
  unwear(rogue.armor);
#line 134
  un_put_on(rogue.left_ring);
#line 135
  un_put_on(rogue.right_ring);
#line 137
  wclear(stdscr);
#line 138
  tmp = wmove(stdscr, 10, 11);
  }
#line 138
  if (! (tmp == -1)) {
    {
#line 138
    waddnstr(stdscr, "@   @  @@@   @   @      @  @  @   @@@   @   @   @", -1);
    }
  }
  {
#line 139
  tmp___0 = wmove(stdscr, 11, 11);
  }
#line 139
  if (! (tmp___0 == -1)) {
    {
#line 139
    waddnstr(stdscr, " @ @  @   @  @   @      @  @  @  @   @  @@  @   @", -1);
    }
  }
  {
#line 140
  tmp___1 = wmove(stdscr, 12, 11);
  }
#line 140
  if (! (tmp___1 == -1)) {
    {
#line 140
    waddnstr(stdscr, "  @   @   @  @   @      @  @  @  @   @  @ @ @   @", -1);
    }
  }
  {
#line 141
  tmp___2 = wmove(stdscr, 13, 11);
  }
#line 141
  if (! (tmp___2 == -1)) {
    {
#line 141
    waddnstr(stdscr, "  @   @   @  @   @      @  @  @  @   @  @  @@", -1);
    }
  }
  {
#line 142
  tmp___3 = wmove(stdscr, 14, 11);
  }
#line 142
  if (! (tmp___3 == -1)) {
    {
#line 142
    waddnstr(stdscr, "  @    @@@    @@@        @@ @@    @@@   @   @   @", -1);
    }
  }
  {
#line 143
  tmp___4 = wmove(stdscr, 17, 11);
  }
#line 143
  if (! (tmp___4 == -1)) {
    {
#line 143
    waddnstr(stdscr, "Congratulations,  you have  been admitted  to  the", -1);
    }
  }
  {
#line 144
  tmp___5 = wmove(stdscr, 18, 11);
  }
#line 144
  if (! (tmp___5 == -1)) {
    {
#line 144
    waddnstr(stdscr, "Fighters\' Guild.   You return home,  sell all your", -1);
    }
  }
  {
#line 145
  tmp___6 = wmove(stdscr, 19, 11);
  }
#line 145
  if (! (tmp___6 == -1)) {
    {
#line 145
    waddnstr(stdscr, "treasures at great profit and retire into comfort.", -1);
    }
  }
  {
#line 146
  message("", (char)0);
#line 147
  message("", (char)0);
#line 148
  id_all();
#line 149
  sell_pack();
#line 150
  put_scores((object const   *)((object *)0), (short)5);
  }
}
}
#line 153 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void quit(char from_intrpt ) 
{ 
  char buf[128] ;
  short i ;
  short orow ;
  short ocol ;
  char mc ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 161
  ocol = (short)0;
#line 161
  orow = ocol;
#line 162
  mc = (char)0;
#line 163
  md_ignore_signals();
  }
#line 165
  if (from_intrpt) {
#line 166
    orow = rogue.row;
#line 167
    ocol = rogue.col;
#line 169
    mc = msg_cleared;
#line 171
    i = (short)0;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! ((int )i < 80)) {
#line 171
        goto while_break;
      }
      {
#line 172
      tmp___1 = wmove(stdscr, 0, (int )i);
      }
#line 172
      if (tmp___1 == -1) {
#line 172
        buf[i] = (char )((chtype )-1);
      } else {
        {
#line 172
        tmp___0 = winch(stdscr);
#line 172
        buf[i] = (char )tmp___0;
        }
      }
#line 171
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 175
  check_message();
#line 176
  message("really quit?", (char)1);
#line 177
  tmp___3 = rgetchar();
  }
#line 177
  if (tmp___3 != 121) {
    {
#line 178
    md_heed_signals();
#line 179
    check_message();
    }
#line 180
    if (from_intrpt) {
#line 181
      i = (short)0;
      {
#line 181
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 181
        if (! ((int )i < 80)) {
#line 181
          goto while_break___0;
        }
        {
#line 182
        tmp___2 = wmove(stdscr, 0, (int )i);
        }
#line 182
        if (! (tmp___2 == -1)) {
          {
#line 182
          waddch(stdscr, (chtype const   )buf[i]);
          }
        }
#line 181
        i = (short )((int )i + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 184
      msg_cleared = mc;
#line 185
      wmove(stdscr, (int )orow, (int )ocol);
#line 186
      wrefresh(stdscr);
      }
    }
#line 188
    return;
  }
#line 190
  if (from_intrpt) {
    {
#line 191
    clean_up(byebye_string);
    }
  }
  {
#line 193
  check_message();
#line 194
  killed_by((object const   *)((object *)0), (short)4);
  }
}
}
#line 197
 __attribute__((__noreturn__)) void put_scores(object const   *monster , short other ) ;
#line 197 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void put_scores(object const   *monster , short other ) 
{ 
  short i ;
  short n___0 ;
  short rank ;
  short x ;
  short ne ;
  short found_player ;
  char scores[10][82] ;
  char n_names[10][30] ;
  char buf[128] ;
  FILE *fp ;
  long s___0 ;
  char dopause ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 202
  rank = (short)10;
#line 202
  ne = (short)0;
#line 202
  found_player = (short)-1;
#line 208
  dopause = score_only;
#line 210
  md_lock((char)1);
#line 212
  setegid(egid);
#line 213
  fp = fopen((char const   */* __restrict  */)"/var/games/bsdgames-nonfree/rogue.scores",
             (char const   */* __restrict  */)"r+");
  }
#line 213
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 213
    fp = fopen((char const   */* __restrict  */)"/var/games/bsdgames-nonfree/rogue.scores",
               (char const   */* __restrict  */)"w+");
    }
#line 213
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 215
      setegid(gid);
#line 216
      message("cannot read/write/create score file", (char)0);
#line 217
      sf_error();
      }
    }
  }
  {
#line 219
  setegid(gid);
#line 220
  rewind(fp);
#line 221
  xxx((char)1);
#line 223
  i = (short)0;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((int )i < 10)) {
#line 223
      goto while_break;
    }
    {
#line 224
    tmp___0 = fread((void */* __restrict  */)(scores[i]), sizeof(char ), (size_t )80,
                    (FILE */* __restrict  */)fp);
#line 224
    n___0 = (short )tmp___0;
    }
#line 224
    if ((int )n___0 < 80) {
#line 224
      if ((int )n___0 != 0) {
        {
#line 225
        sf_error();
        }
      } else {
#line 224
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 226
    if ((int )n___0 != 0) {
      {
#line 227
      xxxx(scores[i], (short)80);
#line 228
      tmp = fread((void */* __restrict  */)(n_names[i]), sizeof(char ), (size_t )30,
                  (FILE */* __restrict  */)fp);
#line 228
      n___0 = (short )tmp;
      }
#line 228
      if ((int )n___0 < 30) {
        {
#line 229
        sf_error();
        }
      }
      {
#line 231
      xxxx(n_names[i], (short)30);
      }
    } else {
#line 233
      goto while_break;
    }
#line 235
    ne = (short )((int )ne + 1);
#line 236
    if (! score_only) {
#line 236
      if ((int )found_player == -1) {
        {
#line 237
        tmp___1 = name_cmp(scores[i] + 15, (char const   *)(login_name));
        }
#line 237
        if (! tmp___1) {
#line 238
          x = (short)5;
          {
#line 239
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 239
            if (! ((int )scores[i][x] == 32)) {
#line 239
              goto while_break___0;
            }
#line 240
            x = (short )((int )x + 1);
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 242
          s___0 = lget_number((char const   *)(scores[i] + (int )x));
          }
#line 243
          if (rogue.gold < s___0) {
#line 244
            score_only = (char)1;
          } else {
#line 246
            found_player = i;
          }
        }
      }
    }
#line 223
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  if ((int )found_player != -1) {
#line 252
    ne = (short )((int )ne - 1);
#line 253
    i = found_player;
    {
#line 253
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 253
      if (! ((int )i < (int )ne)) {
#line 253
        goto while_break___1;
      }
      {
#line 254
      strcpy((char */* __restrict  */)(scores[i]), (char const   */* __restrict  */)(scores[(int )i + 1]));
#line 255
      strcpy((char */* __restrict  */)(n_names[i]), (char const   */* __restrict  */)(n_names[(int )i + 1]));
#line 253
      i = (short )((int )i + 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 258
  if (! score_only) {
#line 259
    i = (short)0;
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 259
      if (! ((int )i < (int )ne)) {
#line 259
        goto while_break___2;
      }
#line 260
      x = (short)5;
      {
#line 261
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 261
        if (! ((int )scores[i][x] == 32)) {
#line 261
          goto while_break___3;
        }
#line 262
        x = (short )((int )x + 1);
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 264
      s___0 = lget_number((char const   *)(scores[i] + (int )x));
      }
#line 266
      if (rogue.gold >= s___0) {
#line 267
        rank = i;
#line 268
        goto while_break___2;
      }
#line 259
      i = (short )((int )i + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 271
    if ((int )ne == 0) {
#line 272
      rank = (short)0;
    } else
#line 273
    if ((int )ne < 10) {
#line 273
      if ((int )rank == 10) {
#line 274
        rank = ne;
      }
    }
#line 276
    if ((int )rank < 10) {
      {
#line 277
      insert_score(scores, n_names, (char const   *)nick_name, rank, ne, monster,
                   (int )other);
      }
#line 279
      if ((int )ne < 10) {
#line 280
        ne = (short )((int )ne + 1);
      }
    }
    {
#line 283
    rewind(fp);
    }
  }
  {
#line 286
  wclear(stdscr);
#line 287
  tmp___2 = wmove(stdscr, 3, 30);
  }
#line 287
  if (! (tmp___2 == -1)) {
    {
#line 287
    waddnstr(stdscr, "Top  Ten  Rogueists", -1);
    }
  }
  {
#line 288
  tmp___3 = wmove(stdscr, 8, 0);
  }
#line 288
  if (! (tmp___3 == -1)) {
    {
#line 288
    waddnstr(stdscr, "Rank   Score   Name", -1);
    }
  }
  {
#line 290
  md_ignore_signals();
#line 292
  xxx((char)1);
#line 294
  i = (short)0;
  }
  {
#line 294
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 294
    if (! ((int )i < (int )ne)) {
#line 294
      goto while_break___4;
    }
#line 295
    if ((int )i == (int )rank) {
#line 296
      if (stdscr) {
#line 296
        stdscr->_attrs = 1UL << 16;
      }
    }
#line 298
    if ((int )i == 9) {
#line 299
      scores[i][0] = (char )'1';
#line 300
      scores[i][1] = (char )'0';
    } else {
#line 302
      scores[i][0] = (char )' ';
#line 303
      scores[i][1] = (char )((int )i + 49);
    }
    {
#line 305
    nickize(buf, (char const   *)(scores[i]), (char const   *)(n_names[i]));
#line 306
    tmp___4 = wmove(stdscr, (int )i + 10, 0);
    }
#line 306
    if (! (tmp___4 == -1)) {
      {
#line 306
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
#line 307
    if ((int )rank < 10) {
      {
#line 308
      xxxx(scores[i], (short)80);
#line 309
      fwrite((void const   */* __restrict  */)(scores[i]), sizeof(char ), (size_t )80,
             (FILE */* __restrict  */)fp);
#line 310
      xxxx(n_names[i], (short)30);
#line 311
      fwrite((void const   */* __restrict  */)(n_names[i]), sizeof(char ), (size_t )30,
             (FILE */* __restrict  */)fp);
      }
    }
#line 313
    if ((int )i == (int )rank) {
#line 314
      if (stdscr) {
#line 314
        stdscr->_attrs = 0UL;
      }
    }
#line 294
    i = (short )((int )i + 1);
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 317
  md_lock((char)0);
#line 318
  wrefresh(stdscr);
#line 319
  fclose(fp);
#line 320
  message("", (char)0);
  }
#line 321
  if (dopause) {
    {
#line 322
    message("", (char)0);
    }
  }
  {
#line 324
  clean_up("");
  }
}
}
#line 327 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void insert_score(char (*scores)[82] , char (*n_names)[30] , char const   *n_name ,
                  short rank , short n___0 , object const   *monster , int other ) 
{ 
  short i ;
  char buf[128] ;
  char tmp ;
  size_t tmp___0 ;
  char tmp___1 ;
  size_t tmp___2 ;

  {
#line 339
  if ((int )n___0 > 0) {
#line 340
    i = n___0;
    {
#line 340
    while (1) {
      while_continue: /* CIL Label */ ;
#line 340
      if (! ((int )i > (int )rank)) {
#line 340
        goto while_break;
      }
#line 341
      if ((int )i < 10) {
#line 341
        if ((int )i > 0) {
          {
#line 342
          strcpy((char */* __restrict  */)(*(scores + i)), (char const   */* __restrict  */)(*(scores + ((int )i - 1))));
#line 343
          strcpy((char */* __restrict  */)(*(n_names + i)), (char const   */* __restrict  */)(*(n_names + ((int )i - 1))));
          }
        }
      }
#line 340
      i = (short )((int )i - 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 347
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%2d    %6ld   %s: ",
          (int )rank + 1, rogue.gold, login_name);
  }
#line 350
  if (other) {
    {
#line 352
    if (other == 1) {
#line 352
      goto case_1;
    }
#line 355
    if (other == 2) {
#line 355
      goto case_2;
    }
#line 358
    if (other == 3) {
#line 358
      goto case_3;
    }
#line 361
    if (other == 4) {
#line 361
      goto case_4;
    }
#line 364
    if (other == 5) {
#line 364
      goto case_5;
    }
#line 367
    if (other == 6) {
#line 367
      goto case_6;
    }
#line 351
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 353
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"died of hypothermia");
    }
#line 354
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 356
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"died of starvation");
    }
#line 357
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 359
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"killed by a dart");
    }
#line 360
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 362
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"quit");
    }
#line 363
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 365
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"a total winner");
    }
#line 366
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 368
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"killed by fire");
    }
#line 369
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 372
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"killed by ");
#line 373
    tmp = is_vowel((short )*(m_names[(int const   )monster->ichar - 65] + 0));
    }
#line 373
    if (tmp) {
      {
#line 374
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"an ");
      }
    } else {
      {
#line 376
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"a ");
      }
    }
    {
#line 378
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)m_names[(int const   )monster->ichar - 65]);
    }
  }
  {
#line 380
  tmp___0 = strlen((char const   *)(buf));
#line 380
  sprintf((char */* __restrict  */)(buf + tmp___0), (char const   */* __restrict  */)" on level %d ",
          (int )max_level);
  }
#line 381
  if (other != 5) {
    {
#line 381
    tmp___1 = has_amulet();
    }
#line 381
    if (tmp___1) {
      {
#line 382
      strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"with amulet");
      }
    }
  }
  {
#line 384
  tmp___2 = strlen((char const   *)(buf));
#line 384
  i = (short )tmp___2;
  }
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! ((int )i < 79)) {
#line 384
      goto while_break___0;
    }
#line 385
    buf[i] = (char )' ';
#line 384
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 387
  buf[79] = (char)0;
#line 388
  strcpy((char */* __restrict  */)(*(scores + rank)), (char const   */* __restrict  */)(buf));
#line 389
  strcpy((char */* __restrict  */)(*(n_names + rank)), (char const   */* __restrict  */)n_name);
  }
#line 390
  return;
}
}
#line 392 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
char is_vowel(short ch ) 
{ 
  int tmp ;

  {
#line 396
  if ((int )ch == 97) {
#line 396
    tmp = 1;
  } else
#line 396
  if ((int )ch == 101) {
#line 396
    tmp = 1;
  } else
#line 396
  if ((int )ch == 105) {
#line 396
    tmp = 1;
  } else
#line 396
  if ((int )ch == 111) {
#line 396
    tmp = 1;
  } else
#line 396
  if ((int )ch == 117) {
#line 396
    tmp = 1;
  } else {
#line 396
    tmp = 0;
  }
#line 396
  return ((char )tmp);
}
}
#line 403 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void sell_pack(void) 
{ 
  object *obj ;
  short row___0 ;
  short val ;
  char buf[80] ;
  int tmp ;
  int tmp___0 ;
  short tmp___1 ;
  int tmp___2 ;

  {
  {
#line 407
  row___0 = (short)2;
#line 410
  obj = rogue.pack.next_object;
#line 412
  wclear(stdscr);
#line 413
  tmp = wmove(stdscr, 1, 0);
  }
#line 413
  if (! (tmp == -1)) {
    {
#line 413
    waddnstr(stdscr, "Value      Item", -1);
    }
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! obj) {
#line 415
      goto while_break;
    }
#line 416
    if ((int )obj->what_is != 32) {
      {
#line 417
      obj->identified = (short)1;
#line 418
      tmp___0 = get_value((object const   *)obj);
#line 418
      val = (short )tmp___0;
#line 419
      rogue.gold += (long )val;
      }
#line 421
      if ((int )row___0 < 24) {
        {
#line 422
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%5d      ",
                (int )val);
#line 423
        get_desc((object const   *)obj, buf + 11);
#line 424
        tmp___1 = row___0;
#line 424
        row___0 = (short )((int )row___0 + 1);
#line 424
        tmp___2 = wmove(stdscr, (int )tmp___1, 0);
        }
#line 424
        if (! (tmp___2 == -1)) {
          {
#line 424
          waddnstr(stdscr, (char const   *)(buf), -1);
          }
        }
      }
    }
#line 427
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 429
  wrefresh(stdscr);
  }
#line 430
  if (rogue.gold > 999999L) {
#line 431
    rogue.gold = 999999L;
  }
  {
#line 433
  message("", (char)0);
  }
#line 434
  return;
}
}
#line 436 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
int get_value(object const   *obj ) 
{ 
  short wc ;
  int val ;

  {
#line 443
  val = 0;
#line 444
  wc = (short )obj->which_kind;
  {
#line 447
  if ((int const   )obj->what_is == 2) {
#line 447
    goto case_2;
  }
#line 456
  if ((int const   )obj->what_is == 1) {
#line 456
    goto case_1;
  }
#line 463
  if ((int const   )obj->what_is == 64) {
#line 463
    goto case_64;
  }
#line 466
  if ((int const   )obj->what_is == 4) {
#line 466
    goto case_4;
  }
#line 469
  if ((int const   )obj->what_is == 8) {
#line 469
    goto case_8;
  }
#line 472
  if ((int const   )obj->what_is == 256) {
#line 472
    goto case_256;
  }
#line 475
  if ((int const   )obj->what_is == 128) {
#line 475
    goto case_128;
  }
#line 446
  goto switch_break;
  case_2: /* CIL Label */ 
#line 448
  val = (int )id_weapons[wc].value;
#line 449
  if ((int )wc == 2) {
#line 451
    val *= (int )obj->quantity;
  } else
#line 449
  if ((int )wc == 3) {
#line 451
    val *= (int )obj->quantity;
  } else
#line 449
  if ((int )wc == 4) {
#line 451
    val *= (int )obj->quantity;
  } else
#line 449
  if ((int )wc == 1) {
#line 451
    val *= (int )obj->quantity;
  }
#line 453
  val += (int )((int const   )obj->d_enchant * 85);
#line 454
  val += (int )((int const   )obj->hit_enchant * 85);
#line 455
  goto switch_break;
  case_1: /* CIL Label */ 
#line 457
  val = (int )id_armors[wc].value;
#line 458
  val += (int )((int const   )obj->d_enchant * 75);
#line 459
  if (obj->is_protected) {
#line 460
    val += 200;
  }
#line 462
  goto switch_break;
  case_64: /* CIL Label */ 
#line 464
  val = (int )id_wands[wc].value * (int )((int const   )obj->class + 1);
#line 465
  goto switch_break;
  case_4: /* CIL Label */ 
#line 467
  val = (int )id_scrolls[wc].value * (int )obj->quantity;
#line 468
  goto switch_break;
  case_8: /* CIL Label */ 
#line 470
  val = (int )id_potions[wc].value * (int )obj->quantity;
#line 471
  goto switch_break;
  case_256: /* CIL Label */ 
#line 473
  val = 5000;
#line 474
  goto switch_break;
  case_128: /* CIL Label */ 
#line 476
  val = (int )id_rings[wc].value * (int )((int const   )obj->class + 1);
#line 477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 479
  if (val <= 0) {
#line 480
    val = 10;
  }
#line 482
  return (val);
}
}
#line 485 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void id_all(void) 
{ 
  short i ;

  {
#line 490
  i = (short)0;
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! ((int )i < 13)) {
#line 490
      goto while_break;
    }
#line 491
    id_scrolls[i].id_status = (unsigned short)1;
#line 490
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  i = (short)0;
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (! ((int )i < 8)) {
#line 493
      goto while_break___0;
    }
#line 494
    id_weapons[i].id_status = (unsigned short)1;
#line 493
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 496
  i = (short)0;
  {
#line 496
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 496
    if (! ((int )i < 7)) {
#line 496
      goto while_break___1;
    }
#line 497
    id_armors[i].id_status = (unsigned short)1;
#line 496
    i = (short )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 499
  i = (short)0;
  {
#line 499
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 499
    if (! ((int )i < 11)) {
#line 499
      goto while_break___2;
    }
#line 500
    id_wands[i].id_status = (unsigned short)1;
#line 499
    i = (short )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 502
  i = (short)0;
  {
#line 502
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 502
    if (! ((int )i < 14)) {
#line 502
      goto while_break___3;
    }
#line 503
    id_potions[i].id_status = (unsigned short)1;
#line 502
    i = (short )((int )i + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 505
  return;
}
}
#line 507 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
int name_cmp(char *s1 , char const   *s2 ) 
{ 
  short i ;
  int r ;

  {
#line 512
  i = (short)0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! ((int )*(s1 + i) != 58)) {
#line 515
      goto while_break;
    }
#line 516
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 518
  *(s1 + i) = (char)0;
#line 519
  r = strcmp((char const   *)s1, s2);
#line 520
  *(s1 + i) = (char )':';
  }
#line 521
  return (r);
}
}
#line 524 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void xxxx(char *buf , short n___0 ) 
{ 
  short i ;
  unsigned char c___0 ;
  long tmp ;

  {
#line 532
  i = (short)0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((int )i < (int )n___0)) {
#line 532
      goto while_break;
    }
    {
#line 535
    tmp = xxx((char)0);
#line 535
    c___0 = (unsigned char )tmp;
#line 537
    *(buf + i) = (char )((int )*(buf + i) ^ (int )c___0);
#line 532
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 545 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
static long f  ;
#line 545 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
static long s  ;
#line 541 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
long xxx(char st ) 
{ 
  long r ;

  {
#line 548
  if (st) {
#line 549
    f = 37L;
#line 550
    s = 7L;
#line 551
    return (0L);
  }
#line 553
  r = (f * s + 9337L) % 8887L;
#line 554
  f = s;
#line 555
  s = r;
#line 556
  return (r);
}
}
#line 559 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void nickize(char *buf , char const   *score , char const   *n_name ) 
{ 
  short i ;
  short j ;
  size_t tmp ;
  short tmp___0 ;
  short tmp___1 ;

  {
#line 564
  i = (short)15;
#line 566
  if (! *(n_name + 0)) {
    {
#line 567
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)score);
    }
  } else {
    {
#line 569
    strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)score,
            (size_t )16);
    }
    {
#line 571
    while (1) {
      while_continue: /* CIL Label */ ;
#line 571
      if (! ((int const   )*(score + i) != 58)) {
#line 571
        goto while_break;
      }
#line 572
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 575
    strcpy((char */* __restrict  */)(buf + 15), (char const   */* __restrict  */)n_name);
#line 576
    tmp = strlen((char const   *)buf);
#line 576
    j = (short )tmp;
    }
    {
#line 578
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 578
      if (! *(score + i)) {
#line 578
        goto while_break___0;
      }
#line 579
      tmp___0 = j;
#line 579
      j = (short )((int )j + 1);
#line 579
      tmp___1 = i;
#line 579
      i = (short )((int )i + 1);
#line 579
      *(buf + tmp___0) = (char )*(score + tmp___1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 581
    *(buf + j) = (char)0;
#line 582
    *(buf + 79) = (char)0;
  }
#line 584
  return;
}
}
#line 586 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void center(short row___0 , char const   *buf ) 
{ 
  short margin ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 593
  tmp = strlen(buf);
#line 593
  margin = (short )((80UL - tmp) / 2UL);
#line 594
  tmp___0 = wmove(stdscr, (int )row___0, (int )margin);
  }
#line 594
  if (! (tmp___0 == -1)) {
    {
#line 594
    waddnstr(stdscr, buf, -1);
    }
  }
#line 595
  return;
}
}
#line 597
 __attribute__((__noreturn__)) void sf_error(void) ;
#line 597 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/score.c"
void sf_error(void) 
{ 


  {
  {
#line 600
  md_lock((char)0);
#line 601
  message("", (char)1);
#line 602
  clean_up("sorry, score file is out of order");
  }
}
}
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 803 "/usr/include/curses.h"
extern int wclrtoeol(WINDOW * ) ;
#line 1392
extern int LINES ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 516 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
int get_armor_class(object const   *obj ) ;
#line 517
int get_com_id(int *indexp , short ch ) ;
#line 534
void get_wand_and_ring_materials(void) ;
#line 585
void make_scroll_titles(void) ;
#line 602
void mix_colors(void) ;
#line 636
int pr_com_id(int ch ) ;
#line 637
int pr_motion_char(int ch ) ;
#line 748 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char is_wood[11]  ;
#line 772
char const   *more ;
#line 775
char const   *press_space ;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
char const   *press_space  =    " --press space to continue--";
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
char const   * const  wand_materials[30]  = 
#line 61
  {      (char const   */* const  */)"steel ",      (char const   */* const  */)"bronze ",      (char const   */* const  */)"gold ",      (char const   */* const  */)"silver ", 
        (char const   */* const  */)"copper ",      (char const   */* const  */)"nickel ",      (char const   */* const  */)"cobalt ",      (char const   */* const  */)"tin ", 
        (char const   */* const  */)"iron ",      (char const   */* const  */)"magnesium ",      (char const   */* const  */)"chrome ",      (char const   */* const  */)"carbon ", 
        (char const   */* const  */)"platinum ",      (char const   */* const  */)"silicon ",      (char const   */* const  */)"titanium ",      (char const   */* const  */)"teak ", 
        (char const   */* const  */)"oak ",      (char const   */* const  */)"cherry ",      (char const   */* const  */)"birch ",      (char const   */* const  */)"pine ", 
        (char const   */* const  */)"cedar ",      (char const   */* const  */)"redwood ",      (char const   */* const  */)"balsa ",      (char const   */* const  */)"ivory ", 
        (char const   */* const  */)"walnut ",      (char const   */* const  */)"maple ",      (char const   */* const  */)"mahogany ",      (char const   */* const  */)"elm ", 
        (char const   */* const  */)"palm ",      (char const   */* const  */)"wooden "};
#line 95 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
char const   * const  gems[14]  = 
#line 95
  {      (char const   */* const  */)"diamond ",      (char const   */* const  */)"stibotantalite ",      (char const   */* const  */)"lapi-lazuli ",      (char const   */* const  */)"ruby ", 
        (char const   */* const  */)"emerald ",      (char const   */* const  */)"sapphire ",      (char const   */* const  */)"amethyst ",      (char const   */* const  */)"quartz ", 
        (char const   */* const  */)"tiger-eye ",      (char const   */* const  */)"opal ",      (char const   */* const  */)"agate ",      (char const   */* const  */)"turquoise ", 
        (char const   */* const  */)"pearl ",      (char const   */* const  */)"garnet "};
#line 112 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
char const   * const  syllables[40]  = 
#line 112
  {      (char const   */* const  */)"blech ",      (char const   */* const  */)"foo ",      (char const   */* const  */)"barf ",      (char const   */* const  */)"rech ", 
        (char const   */* const  */)"bar ",      (char const   */* const  */)"blech ",      (char const   */* const  */)"quo ",      (char const   */* const  */)"bloto ", 
        (char const   */* const  */)"oh ",      (char const   */* const  */)"caca ",      (char const   */* const  */)"blorp ",      (char const   */* const  */)"erp ", 
        (char const   */* const  */)"festr ",      (char const   */* const  */)"rot ",      (char const   */* const  */)"slie ",      (char const   */* const  */)"snorf ", 
        (char const   */* const  */)"iky ",      (char const   */* const  */)"yuky ",      (char const   */* const  */)"ooze ",      (char const   */* const  */)"ah ", 
        (char const   */* const  */)"bahl ",      (char const   */* const  */)"zep ",      (char const   */* const  */)"druhl ",      (char const   */* const  */)"flem ", 
        (char const   */* const  */)"behil ",      (char const   */* const  */)"arek ",      (char const   */* const  */)"mep ",      (char const   */* const  */)"zihr ", 
        (char const   */* const  */)"grit ",      (char const   */* const  */)"kona ",      (char const   */* const  */)"kini ",      (char const   */* const  */)"ichi ", 
        (char const   */* const  */)"tims ",      (char const   */* const  */)"ogr ",      (char const   */* const  */)"oo ",      (char const   */* const  */)"ighr ", 
        (char const   */* const  */)"coph ",      (char const   */* const  */)"swerr ",      (char const   */* const  */)"mihln ",      (char const   */* const  */)"poxi "};
#line 162 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
struct id_com_s  const  com_id_tab[48]  = 
#line 162
  {      {(short )'?', "?       prints help"}, 
        {(short )'r', "r       read scroll"}, 
        {(short )'/', "/       identify object"}, 
        {(short )'e', "e       eat food"}, 
        {(short )'h', "h       left "}, 
        {(short )'w', "w       wield a weapon"}, 
        {(short )'j', "j       down"}, 
        {(short )'W', "W       wear armor"}, 
        {(short )'k', "k       up"}, 
        {(short )'T', "T       take armor off"}, 
        {(short )'l', "l       right"}, 
        {(short )'P', "P       put on ring"}, 
        {(short )'y', "y       up & left"}, 
        {(short )'R', "R       remove ring"}, 
        {(short )'u', "u       up & right"}, 
        {(short )'d', "d       drop object"}, 
        {(short )'b', "b       down & left"}, 
        {(short )'c', "c       call object"}, 
        {(short )'n', "n       down & right"}, 
        {(short )'\000', "<SHIFT><dir>: run that way"}, 
        {(short )')', ")       print current weapon"}, 
        {(short )'\000', "<CTRL><dir>: run till adjacent"}, 
        {(short )']', "]       print current armor"}, 
        {(short )'f', "f<dir>  fight till death or near death"}, 
        {(short )'=', "=       print current rings"}, 
        {(short )'t', "t<dir>  throw something"}, 
        {(short )'\001', "^A      print Hp-raise average"}, 
        {(short )'m', "m<dir>  move onto without picking up"}, 
        {(short )'z', "z<dir>  zap a wand in a direction"}, 
        {(short )'o', "o       examine/set options"}, 
        {(short )'^', "^<dir>  identify trap type"}, 
        {(short )'\022', "^R      redraw screen"}, 
        {(short )'&', "&       save screen into \'rogue.screen\'"}, 
        {(short )'s', "s       search for trap/secret door"}, 
        {(short )'\020', "^P      repeat last message"}, 
        {(short )'>', ">       go down a staircase"}, 
        {(short )'\033', "^[      cancel command"}, 
        {(short )'<', "<       go up a staircase"}, 
        {(short )'S', "S       save game"}, 
        {(short )'.', ".       rest for a turn"}, 
        {(short )'Q', "Q       quit"}, 
        {(short )',', ",       pick something up"}, 
        {(short )'!', "!       shell escape"}, 
        {(short )'i', "i       inventory"}, 
        {(short )'F', "F<dir>  fight till either of you dies"}, 
        {(short )'I', "I       inventory single item"}, 
        {(short )'v', "v       print version number"}, 
        {(short )'q', "q       quaff potion"}};
#line 213 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void inventory(object const   *pack , unsigned short mask ) 
{ 
  object *obj ;
  short i ;
  short j ;
  short maxlen ;
  short n___0 ;
  char descs[25][80] ;
  short row___0 ;
  short col___0 ;
  size_t tmp ;
  short tmp___0 ;
  chtype tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 219
  i = (short)0;
#line 219
  maxlen = (short)0;
#line 223
  obj = (object *)pack->next_object;
#line 225
  if (! obj) {
    {
#line 226
    message("your pack is empty", (char)0);
    }
#line 227
    return;
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! obj) {
#line 229
      goto while_break;
    }
#line 230
    if ((int )obj->what_is & (int )mask) {
#line 231
      descs[i][0] = (char )' ';
#line 232
      descs[i][1] = (char )obj->ichar;
#line 233
      if ((int )obj->what_is & 1) {
#line 233
        if (obj->is_protected) {
#line 233
          descs[i][2] = (char )'}';
        } else {
#line 233
          descs[i][2] = (char )')';
        }
      } else {
#line 233
        descs[i][2] = (char )')';
      }
      {
#line 235
      descs[i][3] = (char )' ';
#line 236
      get_desc((object const   *)obj, descs[i] + 4);
#line 237
      tmp = strlen((char const   *)(descs[i]));
#line 237
      n___0 = (short )tmp;
      }
#line 237
      if ((int )n___0 > (int )maxlen) {
#line 238
        maxlen = n___0;
      }
#line 240
      i = (short )((int )i + 1);
    }
#line 242
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  tmp___0 = i;
#line 244
  i = (short )((int )i + 1);
#line 244
  strcpy((char */* __restrict  */)(descs[tmp___0]), (char const   */* __restrict  */)press_space);
  }
#line 245
  if ((int )maxlen < 27) {
#line 245
    maxlen = (short)27;
  }
#line 246
  col___0 = (short )(80 - ((int )maxlen + 2));
#line 248
  row___0 = (short)0;
  {
#line 248
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 248
    if ((int )row___0 < (int )i) {
#line 248
      if (! ((int )row___0 < 24)) {
#line 248
        goto while_break___0;
      }
    } else {
#line 248
      goto while_break___0;
    }
#line 249
    if ((int )row___0 > 0) {
#line 250
      j = col___0;
      {
#line 250
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 250
        if (! ((int )j < 80)) {
#line 250
          goto while_break___1;
        }
        {
#line 251
        tmp___3 = wmove(stdscr, (int )row___0, (int )j);
        }
#line 251
        if (tmp___3 == -1) {
#line 251
          descs[(int )row___0 - 1][(int )j - (int )col___0] = (char )((chtype )-1);
        } else {
          {
#line 251
          tmp___2 = winch(stdscr);
#line 251
          descs[(int )row___0 - 1][(int )j - (int )col___0] = (char )tmp___2;
          }
        }
#line 250
        j = (short )((int )j + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 253
      descs[(int )row___0 - 1][(int )j - (int )col___0] = (char)0;
    }
    {
#line 255
    tmp___4 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 255
    if (! (tmp___4 == -1)) {
      {
#line 255
      waddnstr(stdscr, (char const   *)(descs[row___0]), -1);
      }
    }
    {
#line 256
    wclrtoeol(stdscr);
#line 248
    row___0 = (short )((int )row___0 + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 258
  wrefresh(stdscr);
#line 259
  wait_for_ack();
#line 261
  wmove(stdscr, 0, 0);
#line 262
  wclrtoeol(stdscr);
#line 264
  j = (short)1;
  }
  {
#line 264
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 264
    if ((int )j < (int )i) {
#line 264
      if (! ((int )j < 24)) {
#line 264
        goto while_break___2;
      }
    } else {
#line 264
      goto while_break___2;
    }
    {
#line 265
    tmp___5 = wmove(stdscr, (int )j, (int )col___0);
    }
#line 265
    if (! (tmp___5 == -1)) {
      {
#line 265
      waddnstr(stdscr, (char const   *)(descs[(int )j - 1]), -1);
      }
    }
#line 264
    j = (short )((int )j + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 269 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void id_com(void) 
{ 
  int ch ;
  short i ;
  short j ;
  short k ;
  char save[25][80] ;
  short rows ;
  char need_two_screens ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 272
  ch = 0;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (ch != 27)) {
#line 275
      goto while_break;
    }
    {
#line 276
    check_message();
#line 277
    message("Character you want help for (* for all):", (char)0);
#line 279
    wrefresh(stdscr);
#line 280
    ch = getchar();
    }
    {
#line 283
    if (ch == 42) {
#line 283
      goto case_42;
    }
#line 333
    goto switch_default;
    case_42: /* CIL Label */ 
#line 286
    rows = (short)25;
#line 287
    need_two_screens = (char)0;
#line 289
    if ((int )rows > LINES) {
#line 290
      need_two_screens = (char)1;
#line 291
      rows = (short )LINES;
    }
#line 293
    k = (short)0;
#line 295
    i = (short)0;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! ((int )i < (int )rows)) {
#line 295
        goto while_break___0;
      }
#line 296
      j = (short)0;
      {
#line 296
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 296
        if (! ((int )j < 80)) {
#line 296
          goto while_break___1;
        }
        {
#line 297
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 297
        if (tmp___1 == -1) {
#line 297
          save[i][j] = (char )((chtype )-1);
        } else {
          {
#line 297
          tmp___0 = winch(stdscr);
#line 297
          save[i][j] = (char )tmp___0;
          }
        }
#line 296
        j = (short )((int )j + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
#line 295
      i = (short )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    MORE: 
#line 301
    i = (short)0;
    {
#line 301
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 301
      if (! ((int )i < (int )rows)) {
#line 301
        goto while_break___2;
      }
      {
#line 302
      wmove(stdscr, (int )i, 0);
#line 303
      wclrtoeol(stdscr);
#line 301
      i = (short )((int )i + 1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 305
    i = (short)0;
    {
#line 305
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 305
      if (! ((int )i < (int )rows - 1)) {
#line 305
        goto while_break___3;
      }
#line 306
      if ((int )i < LINES - 1) {
#line 307
        if ((int )i + (int )i < 48) {
#line 307
          if (((int )i + (int )i) + (int )k < 48) {
            {
#line 308
            tmp___2 = wmove(stdscr, (int )i, 0);
            }
#line 308
            if (! (tmp___2 == -1)) {
              {
#line 308
              waddnstr(stdscr, (char const   *)com_id_tab[((int )i + (int )i) + (int )k].com_desc,
                       -1);
              }
            }
          }
        }
#line 310
        if (((int )i + (int )i) + 1 < 48) {
#line 310
          if ((((int )i + (int )i) + (int )k) + 1 < 48) {
            {
#line 311
            tmp___3 = wmove(stdscr, (int )i, 40);
            }
#line 311
            if (! (tmp___3 == -1)) {
              {
#line 311
              waddnstr(stdscr, (char const   *)com_id_tab[(((int )i + (int )i) + (int )k) + 1].com_desc,
                       -1);
              }
            }
          }
        }
      }
#line 305
      i = (short )((int )i + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 316
    tmp___5 = wmove(stdscr, (int )rows - 1, 0);
    }
#line 316
    if (! (tmp___5 == -1)) {
#line 316
      if (need_two_screens) {
#line 316
        tmp___4 = more;
      } else {
#line 316
        tmp___4 = press_space;
      }
      {
#line 316
      waddnstr(stdscr, tmp___4, -1);
      }
    }
    {
#line 317
    wrefresh(stdscr);
#line 318
    wait_for_ack();
    }
#line 320
    if (need_two_screens) {
#line 321
      k = (short )((int )k + ((int )rows - 1) * 2);
#line 322
      need_two_screens = (char)0;
#line 323
      goto MORE;
    }
#line 325
    i = (short)0;
    {
#line 325
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 325
      if (! ((int )i < (int )rows)) {
#line 325
        goto while_break___4;
      }
      {
#line 326
      wmove(stdscr, (int )i, 0);
#line 327
      j = (short)0;
      }
      {
#line 327
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 327
        if (! ((int )j < 80)) {
#line 327
          goto while_break___5;
        }
        {
#line 328
        waddch(stdscr, (chtype const   )save[i][j]);
#line 327
        j = (short )((int )j + 1);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 325
      i = (short )((int )i + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 332
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 334
    tmp___7 = pr_com_id(ch);
    }
#line 334
    if (! tmp___7) {
      {
#line 335
      tmp___6 = pr_motion_char(ch);
      }
#line 335
      if (! tmp___6) {
        {
#line 336
        check_message();
#line 337
        message("unknown character", (char)0);
        }
      }
    }
#line 340
    ch = '\033';
#line 341
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return;
}
}
#line 346 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
int pr_com_id(int ch ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 352
  tmp = get_com_id(& i, (short )ch);
  }
#line 352
  if (! tmp) {
#line 353
    return (0);
  }
  {
#line 355
  check_message();
#line 356
  message((char const   *)com_id_tab[i].com_desc, (char)0);
  }
#line 357
  return (1);
}
}
#line 360 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
int get_com_id(int *indexp , short ch ) 
{ 
  short i ;

  {
#line 367
  i = (short)0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((int )i < 48)) {
#line 367
      goto while_break;
    }
#line 368
    if ((int const   )com_id_tab[i].com_char == (int const   )ch) {
#line 369
      *indexp = (int )i;
#line 370
      return (1);
    }
#line 367
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return (0);
}
}
#line 376 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
int pr_motion_char(int ch ) 
{ 
  char until[18] ;
  char buf[80] ;
  int n___0 ;

  {
#line 380
  if (ch == 74) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 75) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 76) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 72) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 89) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 85) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 78) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 66) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 10) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 11) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 8) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 12) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 21) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 25) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 14) {
#line 380
    goto _L;
  } else
#line 380
  if (ch == 2) {
    _L: /* CIL Label */ 
#line 399
    if (ch <= 25) {
      {
#line 400
      ch += 96;
#line 401
      strcpy((char */* __restrict  */)(until), (char const   */* __restrict  */)"until adjascent");
      }
    } else {
#line 403
      ch += 32;
#line 404
      until[0] = (char )'\000';
    }
    {
#line 406
    get_com_id(& n___0, (short )ch);
#line 407
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"run %s %s",
            com_id_tab[n___0].com_desc + 8, until);
#line 408
    check_message();
#line 409
    message((char const   *)(buf), (char)0);
    }
#line 410
    return (1);
  } else {
#line 412
    return (0);
  }
}
}
#line 416 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void mix_colors(void) 
{ 
  short i ;
  short j ;
  short k ;
  char t[64] ;
  int tmp ;
  int tmp___0 ;

  {
#line 422
  i = (short)0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! ((int )i <= 32)) {
#line 422
      goto while_break;
    }
    {
#line 423
    tmp = get_rand(0, 13);
#line 423
    j = (short )tmp;
#line 424
    tmp___0 = get_rand(0, 13);
#line 424
    k = (short )tmp___0;
#line 425
    memcpy((void */* __restrict  */)(t), (void const   */* __restrict  */)(id_potions[j].title),
           (size_t )64);
#line 426
    memcpy((void */* __restrict  */)(id_potions[j].title), (void const   */* __restrict  */)(id_potions[k].title),
           (size_t )64);
#line 427
    memcpy((void */* __restrict  */)(id_potions[k].title), (void const   */* __restrict  */)(t),
           (size_t )64);
#line 422
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return;
}
}
#line 431 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void make_scroll_titles(void) 
{ 
  short i ;
  short j ;
  short n___0 ;
  short sylls ;
  short s___0 ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 437
  i = (short)0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! ((int )i < 13)) {
#line 437
      goto while_break;
    }
    {
#line 438
    tmp = get_rand(2, 5);
#line 438
    sylls = (short )tmp;
#line 439
    strcpy((char */* __restrict  */)(id_scrolls[i].title), (char const   */* __restrict  */)"\'");
#line 441
    j = (short)0;
    }
    {
#line 441
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 441
      if (! ((int )j < (int )sylls)) {
#line 441
        goto while_break___0;
      }
      {
#line 442
      tmp___0 = get_rand(1, 39);
#line 442
      s___0 = (short )tmp___0;
#line 443
      strcat((char */* __restrict  */)(id_scrolls[i].title), (char const   */* __restrict  */)syllables[s___0]);
#line 441
      j = (short )((int )j + 1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 445
    tmp___1 = strlen((char const   *)(id_scrolls[i].title));
#line 445
    n___0 = (short )tmp___1;
#line 446
    strcpy((char */* __restrict  */)(id_scrolls[i].title + ((int )n___0 - 1)), (char const   */* __restrict  */)"\' ");
#line 437
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return;
}
}
#line 450 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void get_desc(object const   *obj , char *desc ) 
{ 
  char const   *item_name ;
  struct id *id_table ;
  char more_info[32] ;
  short i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  char tmp___8 ;
  int tmp___9 ;

  {
#line 460
  if ((int const   )obj->what_is == 256) {
    {
#line 461
    strcpy((char */* __restrict  */)desc, (char const   */* __restrict  */)"the amulet of Yendor ");
    }
#line 462
    return;
  }
  {
#line 464
  item_name = name_of(obj);
  }
#line 466
  if ((int const   )obj->what_is == 16) {
    {
#line 467
    sprintf((char */* __restrict  */)desc, (char const   */* __restrict  */)"%d pieces of gold",
            (int const   )obj->quantity);
    }
#line 468
    return;
  }
#line 471
  if ((int const   )obj->what_is != 1) {
#line 472
    if ((int const   )obj->quantity == 1) {
      {
#line 473
      strcpy((char */* __restrict  */)desc, (char const   */* __restrict  */)"a ");
      }
    } else {
      {
#line 475
      sprintf((char */* __restrict  */)desc, (char const   */* __restrict  */)"%d ",
              (int const   )obj->quantity);
      }
    }
  }
#line 478
  if ((int const   )obj->what_is == 32) {
#line 479
    if ((int const   )obj->which_kind == 0) {
#line 480
      if ((int const   )obj->quantity > 1) {
        {
#line 481
        sprintf((char */* __restrict  */)desc, (char const   */* __restrict  */)"%d rations of ",
                (int const   )obj->quantity);
        }
      } else {
        {
#line 483
        strcpy((char */* __restrict  */)desc, (char const   */* __restrict  */)"some ");
        }
      }
    } else {
      {
#line 486
      strcpy((char */* __restrict  */)desc, (char const   */* __restrict  */)"a ");
      }
    }
    {
#line 488
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
    }
#line 489
    goto ANA;
  }
  {
#line 491
  id_table = get_id_table(obj);
  }
#line 493
  if (wizard) {
#line 494
    goto ID;
  }
#line 496
  if ((int const   )obj->what_is & 195) {
#line 497
    goto CHECK;
  }
  {
#line 501
  if ((int )(id_table + obj->which_kind)->id_status == 0) {
#line 501
    goto CHECK;
  }
#line 539
  if ((int )(id_table + obj->which_kind)->id_status == 2) {
#line 539
    goto CALL;
  }
#line 551
  if ((int )(id_table + obj->which_kind)->id_status == 1) {
#line 551
    goto ID;
  }
#line 500
  goto switch_break;
  CHECK: 
  case_0: /* CIL Label */ 
  {
#line 504
  if ((int const   )obj->what_is == 4) {
#line 504
    goto case_4;
  }
#line 509
  if ((int const   )obj->what_is == 8) {
#line 509
    goto case_8;
  }
#line 514
  if ((int const   )obj->what_is == 128) {
#line 514
    goto case_128;
  }
#line 514
  if ((int const   )obj->what_is == 64) {
#line 514
    goto case_128;
  }
#line 525
  if ((int const   )obj->what_is == 1) {
#line 525
    goto case_1;
  }
#line 531
  if ((int const   )obj->what_is == 2) {
#line 531
    goto case_2;
  }
#line 503
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 505
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
#line 506
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"entitled: ");
#line 507
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
  }
#line 508
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 510
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
#line 511
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
  }
#line 512
  goto switch_break___0;
  case_128: /* CIL Label */ 
  case_64: /* CIL Label */ 
#line 515
  if (obj->identified) {
#line 517
    goto ID;
  } else
#line 515
  if ((int )(id_table + obj->which_kind)->id_status == 1) {
#line 517
    goto ID;
  }
#line 519
  if ((int )(id_table + obj->which_kind)->id_status == 2) {
#line 520
    goto CALL;
  }
  {
#line 522
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
#line 523
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
  }
#line 524
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 526
  if (obj->identified) {
#line 527
    goto ID;
  }
  {
#line 529
  strcpy((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
  }
#line 530
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 532
  if (obj->identified) {
#line 533
    goto ID;
  }
  {
#line 535
  tmp = name_of(obj);
#line 535
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)tmp);
  }
#line 536
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 538
  goto switch_break;
  CALL: 
  case_2___0: /* CIL Label */ 
  {
#line 544
  if ((int const   )obj->what_is == 128) {
#line 544
    goto case_128___0;
  }
#line 544
  if ((int const   )obj->what_is == 64) {
#line 544
    goto case_128___0;
  }
#line 544
  if ((int const   )obj->what_is == 8) {
#line 544
    goto case_128___0;
  }
#line 544
  if ((int const   )obj->what_is == 4) {
#line 544
    goto case_128___0;
  }
#line 540
  goto switch_break___1;
  case_128___0: /* CIL Label */ 
  case_64___0: /* CIL Label */ 
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 545
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
#line 546
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"called ");
#line 547
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
  }
#line 548
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 550
  goto switch_break;
  ID: 
  case_1___0: /* CIL Label */ 
  {
#line 554
  if ((int const   )obj->what_is == 8) {
#line 554
    goto case_8___1;
  }
#line 554
  if ((int const   )obj->what_is == 4) {
#line 554
    goto case_8___1;
  }
#line 558
  if ((int const   )obj->what_is == 128) {
#line 558
    goto case_128___1;
  }
#line 570
  if ((int const   )obj->what_is == 64) {
#line 570
    goto case_64___1;
  }
#line 578
  if ((int const   )obj->what_is == 1) {
#line 578
    goto case_1___1;
  }
#line 585
  if ((int const   )obj->what_is == 2) {
#line 585
    goto case_2___1;
  }
#line 552
  goto switch_break___2;
  case_8___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  {
#line 555
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
#line 556
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(id_table + obj->which_kind)->real);
  }
#line 557
  goto switch_break___2;
  case_128___1: /* CIL Label */ 
#line 559
  if (wizard) {
#line 559
    goto _L___0;
  } else
#line 559
  if (obj->identified) {
    _L___0: /* CIL Label */ 
#line 560
    if ((int const   )obj->which_kind == 6) {
#line 560
      goto _L;
    } else
#line 560
    if ((int const   )obj->which_kind == 4) {
      _L: /* CIL Label */ 
#line 562
      if ((int const   )obj->class > 0) {
#line 562
        tmp___0 = "+";
      } else {
#line 562
        tmp___0 = "";
      }
      {
#line 562
      sprintf((char */* __restrict  */)(more_info), (char const   */* __restrict  */)"%s%d ",
              tmp___0, (int const   )obj->class);
#line 564
      strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(more_info));
      }
    }
  }
  {
#line 567
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
#line 568
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(id_table + obj->which_kind)->real);
  }
#line 569
  goto switch_break___2;
  case_64___1: /* CIL Label */ 
  {
#line 571
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)item_name);
#line 572
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(id_table + obj->which_kind)->real);
  }
#line 573
  if (wizard) {
    {
#line 574
    sprintf((char */* __restrict  */)(more_info), (char const   */* __restrict  */)"[%d]",
            (int const   )obj->class);
#line 575
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(more_info));
    }
  } else
#line 573
  if (obj->identified) {
    {
#line 574
    sprintf((char */* __restrict  */)(more_info), (char const   */* __restrict  */)"[%d]",
            (int const   )obj->class);
#line 575
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(more_info));
    }
  }
#line 577
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
#line 579
  if ((int const   )obj->d_enchant >= 0) {
#line 579
    tmp___1 = "+";
  } else {
#line 579
    tmp___1 = "";
  }
  {
#line 579
  sprintf((char */* __restrict  */)desc, (char const   */* __restrict  */)"%s%d ",
          tmp___1, (int const   )obj->d_enchant);
#line 581
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)((id_table + obj->which_kind)->title));
#line 582
  tmp___2 = get_armor_class(obj);
#line 582
  sprintf((char */* __restrict  */)(more_info), (char const   */* __restrict  */)"[%d] ",
          tmp___2);
#line 583
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)(more_info));
  }
#line 584
  goto switch_break___2;
  case_2___1: /* CIL Label */ 
#line 586
  if ((int const   )obj->d_enchant >= 0) {
#line 586
    tmp___3 = "+";
  } else {
#line 586
    tmp___3 = "";
  }
#line 586
  if ((int const   )obj->hit_enchant >= 0) {
#line 586
    tmp___4 = "+";
  } else {
#line 586
    tmp___4 = "";
  }
  {
#line 586
  tmp___5 = strlen((char const   *)desc);
#line 586
  sprintf((char */* __restrict  */)(desc + tmp___5), (char const   */* __restrict  */)"%s%d,%s%d ",
          tmp___4, (int const   )obj->hit_enchant, tmp___3, (int const   )obj->d_enchant);
#line 589
  tmp___6 = name_of(obj);
#line 589
  strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)tmp___6);
  }
#line 590
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 592
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  ANA: 
  {
#line 595
  tmp___9 = strncmp((char const   *)desc, "a ", (size_t )2);
  }
#line 595
  if (! tmp___9) {
    {
#line 596
    tmp___8 = is_vowel((short )*(desc + 2));
    }
#line 596
    if (tmp___8) {
      {
#line 597
      tmp___7 = strlen((char const   *)desc);
#line 597
      i = (short )(tmp___7 + 1UL);
      }
      {
#line 597
      while (1) {
        while_continue: /* CIL Label */ ;
#line 597
        if (! ((int )i > 1)) {
#line 597
          goto while_break;
        }
#line 598
        *(desc + i) = *(desc + ((int )i - 1));
#line 597
        i = (short )((int )i - 1);
      }
      while_break: /* CIL Label */ ;
      }
#line 600
      *(desc + 1) = (char )'n';
    }
  }
#line 603
  if ((int const   )obj->in_use_flags & 1) {
    {
#line 604
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"in hand");
    }
  } else
#line 605
  if ((int const   )obj->in_use_flags & 2) {
    {
#line 606
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"being worn");
    }
  } else
#line 607
  if ((int const   )obj->in_use_flags & 4) {
    {
#line 608
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"on left hand");
    }
  } else
#line 609
  if ((int const   )obj->in_use_flags & 8) {
    {
#line 610
    strcat((char */* __restrict  */)desc, (char const   */* __restrict  */)"on right hand");
    }
  }
#line 612
  return;
}
}
#line 614 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void get_wand_and_ring_materials(void) 
{ 
  short i ;
  short j ;
  char used[30] ;
  int tmp ;
  int tmp___0 ;

  {
#line 620
  i = (short)0;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! ((int )i < 30)) {
#line 620
      goto while_break;
    }
#line 621
    used[i] = (char)0;
#line 620
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  i = (short)0;
  {
#line 623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 623
    if (! ((int )i < 11)) {
#line 623
      goto while_break___0;
    }
    {
#line 624
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 625
      tmp = get_rand(0, 29);
#line 625
      j = (short )tmp;
      }
#line 624
      if (! used[j]) {
#line 624
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 627
    used[j] = (char)1;
#line 628
    strcpy((char */* __restrict  */)(id_wands[i].title), (char const   */* __restrict  */)wand_materials[j]);
#line 629
    is_wood[i] = (char )((int )j > 14);
#line 623
    i = (short )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 631
  i = (short)0;
  {
#line 631
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 631
    if (! ((int )i < 14)) {
#line 631
      goto while_break___2;
    }
#line 632
    used[i] = (char)0;
#line 631
    i = (short )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
#line 634
  i = (short)0;
  {
#line 634
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 634
    if (! ((int )i < 11)) {
#line 634
      goto while_break___3;
    }
    {
#line 635
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 636
      tmp___0 = get_rand(0, 13);
#line 636
      j = (short )tmp___0;
      }
#line 635
      if (! used[j]) {
#line 635
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 638
    used[j] = (char)1;
#line 639
    strcpy((char */* __restrict  */)(id_rings[i].title), (char const   */* __restrict  */)gems[j]);
#line 634
    i = (short )((int )i + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 641
  return;
}
}
#line 643 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void single_inv(short ichar ) 
{ 
  short ch ;
  char desc[80] ;
  object *obj ;
  short tmp ;

  {
#line 651
  if (ichar) {
#line 651
    ch = ichar;
  } else {
    {
#line 651
    tmp = pack_letter("inventory what?", (unsigned short)511);
#line 651
    ch = tmp;
    }
  }
#line 653
  if ((int )ch == 27) {
#line 654
    return;
  }
  {
#line 656
  obj = get_letter_object((int )ch);
  }
#line 656
  if (! obj) {
    {
#line 657
    message("no such item.", (char)0);
    }
#line 658
    return;
  }
#line 660
  desc[0] = (char )ch;
#line 661
  if ((int )obj->what_is & 1) {
#line 661
    if (obj->is_protected) {
#line 661
      desc[1] = (char )'}';
    } else {
#line 661
      desc[1] = (char )')';
    }
  } else {
#line 661
    desc[1] = (char )')';
  }
  {
#line 662
  desc[2] = (char )' ';
#line 663
  desc[3] = (char)0;
#line 664
  get_desc((object const   *)obj, desc + 3);
#line 665
  message((char const   *)(desc), (char)0);
  }
#line 666
  return;
}
}
#line 668 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
struct id *get_id_table(object const   *obj ) 
{ 


  {
  {
#line 673
  if ((int const   )obj->what_is == 4) {
#line 673
    goto case_4;
  }
#line 675
  if ((int const   )obj->what_is == 8) {
#line 675
    goto case_8;
  }
#line 677
  if ((int const   )obj->what_is == 64) {
#line 677
    goto case_64;
  }
#line 679
  if ((int const   )obj->what_is == 128) {
#line 679
    goto case_128;
  }
#line 681
  if ((int const   )obj->what_is == 2) {
#line 681
    goto case_2;
  }
#line 683
  if ((int const   )obj->what_is == 1) {
#line 683
    goto case_1;
  }
#line 672
  goto switch_break;
  case_4: /* CIL Label */ 
#line 674
  return (id_scrolls);
  case_8: /* CIL Label */ 
#line 676
  return (id_potions);
  case_64: /* CIL Label */ 
#line 678
  return (id_wands);
  case_128: /* CIL Label */ 
#line 680
  return (id_rings);
  case_2: /* CIL Label */ 
#line 682
  return (id_weapons);
  case_1: /* CIL Label */ 
#line 684
  return (id_armors);
  switch_break: /* CIL Label */ ;
  }
#line 686
  return ((struct id *)0);
}
}
#line 689 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void inv_armor_weapon(char is_weapon ) 
{ 


  {
#line 693
  if (is_weapon) {
#line 694
    if (rogue.weapon) {
      {
#line 695
      single_inv((rogue.weapon)->ichar);
      }
    } else {
      {
#line 697
      message("not wielding anything", (char)0);
      }
    }
  } else
#line 700
  if (rogue.armor) {
    {
#line 701
    single_inv((rogue.armor)->ichar);
    }
  } else {
    {
#line 703
    message("not wearing anything", (char)0);
    }
  }
#line 706
  return;
}
}
#line 708 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/inventory.c"
void id_type(void) 
{ 
  char const   *id ;
  int ch ;
  char buf[80] ;

  {
  {
#line 715
  message("what do you want identified?", (char)0);
#line 717
  ch = rgetchar();
  }
#line 719
  if (ch >= 65) {
#line 719
    if (ch <= 90) {
#line 720
      id = (char const   *)m_names[ch - 65];
    } else {
#line 719
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 721
  if (ch < 32) {
    {
#line 722
    check_message();
    }
#line 723
    return;
  } else {
    {
#line 726
    if (ch == 64) {
#line 726
      goto case_64;
    }
#line 729
    if (ch == 37) {
#line 729
      goto case_37;
    }
#line 732
    if (ch == 94) {
#line 732
      goto case_94;
    }
#line 735
    if (ch == 43) {
#line 735
      goto case_43;
    }
#line 739
    if (ch == 124) {
#line 739
      goto case_124;
    }
#line 739
    if (ch == 45) {
#line 739
      goto case_124;
    }
#line 742
    if (ch == 46) {
#line 742
      goto case_46;
    }
#line 745
    if (ch == 35) {
#line 745
      goto case_35;
    }
#line 748
    if (ch == 32) {
#line 748
      goto case_32;
    }
#line 751
    if (ch == 61) {
#line 751
      goto case_61;
    }
#line 754
    if (ch == 63) {
#line 754
      goto case_63;
    }
#line 757
    if (ch == 33) {
#line 757
      goto case_33;
    }
#line 760
    if (ch == 47) {
#line 760
      goto case_47;
    }
#line 763
    if (ch == 41) {
#line 763
      goto case_41;
    }
#line 766
    if (ch == 93) {
#line 766
      goto case_93;
    }
#line 769
    if (ch == 42) {
#line 769
      goto case_42;
    }
#line 772
    if (ch == 58) {
#line 772
      goto case_58;
    }
#line 775
    if (ch == 44) {
#line 775
      goto case_44;
    }
#line 778
    goto switch_default;
    case_64: /* CIL Label */ 
#line 727
    id = "you";
#line 728
    goto switch_break;
    case_37: /* CIL Label */ 
#line 730
    id = "staircase";
#line 731
    goto switch_break;
    case_94: /* CIL Label */ 
#line 733
    id = "trap";
#line 734
    goto switch_break;
    case_43: /* CIL Label */ 
#line 736
    id = "door";
#line 737
    goto switch_break;
    case_124: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 740
    id = "wall of a room";
#line 741
    goto switch_break;
    case_46: /* CIL Label */ 
#line 743
    id = "floor";
#line 744
    goto switch_break;
    case_35: /* CIL Label */ 
#line 746
    id = "passage";
#line 747
    goto switch_break;
    case_32: /* CIL Label */ 
#line 749
    id = "solid rock";
#line 750
    goto switch_break;
    case_61: /* CIL Label */ 
#line 752
    id = "ring";
#line 753
    goto switch_break;
    case_63: /* CIL Label */ 
#line 755
    id = "scroll";
#line 756
    goto switch_break;
    case_33: /* CIL Label */ 
#line 758
    id = "potion";
#line 759
    goto switch_break;
    case_47: /* CIL Label */ 
#line 761
    id = "wand or staff";
#line 762
    goto switch_break;
    case_41: /* CIL Label */ 
#line 764
    id = "weapon";
#line 765
    goto switch_break;
    case_93: /* CIL Label */ 
#line 767
    id = "armor";
#line 768
    goto switch_break;
    case_42: /* CIL Label */ 
#line 770
    id = "gold";
#line 771
    goto switch_break;
    case_58: /* CIL Label */ 
#line 773
    id = "food";
#line 774
    goto switch_break;
    case_44: /* CIL Label */ 
#line 776
    id = "the Amulet of Yendor";
#line 777
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 779
    id = "unknown character";
#line 780
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 783
  check_message();
#line 784
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"\'%c\': %s",
          ch, id);
#line 785
  message((char const   *)(buf), (char)0);
  }
#line 786
  return;
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 1390
extern int COLS ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 454 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char *md_getenv(char const   *name ) ;
#line 455
char const   *md_gln(void) ;
#line 457
char *md_malloc(int n___0 ) ;
#line 469
void byebye(int dummy  __attribute__((__unused__)) ) ;
#line 490
void do_args(int argc , char **argv ) ;
#line 491
void do_opts(void) ;
#line 505
void env_get_value(char **s___0 , char *e , char add_blank ) ;
#line 506
 __attribute__((__noreturn__)) void error_save(int dummy  __attribute__((__unused__)) ) ;
#line 524
void get_food(object *obj , char force_ration ) ;
#line 564
void init_str(char **str , char const   *dflt ) ;
#line 589
 __attribute__((__noreturn__)) void md_exit(int status ) ;
#line 593
int md_gseed(void) ;
#line 622
void onintr(int dummy  __attribute__((__unused__)) ) ;
#line 634
void player_init(void) ;
#line 666
void restore(char const   *fname ) ;
#line 682
void save_into_file(char const   *sfile ) ;
#line 696
void start_window(void) ;
#line 700
void stop_window(void) ;
#line 741
char ask_quit ;
#line 743
char cant_int ;
#line 746
char did_int ;
#line 757
char save_is_interactive ;
#line 758 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char score_only  ;
#line 766 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char login_name[40]  ;
#line 769
char const   *error_file ;
#line 776
char *save_file ;
#line 800 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
gid_t gid  ;
#line 801 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
gid_t egid  ;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char *nick_name  =    (char *)0;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char *rest_file  =    (char *)0;
#line 64 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char cant_int  =    (char)0;
#line 65 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char did_int  =    (char)0;
#line 67 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char init_curses  =    (char)0;
#line 68 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char save_is_interactive  =    (char)1;
#line 69 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char ask_quit  =    (char)1;
#line 70 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char no_skull  =    (char)0;
#line 71 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char passgo  =    (char)0;
#line 72 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char const   *error_file  =    "rogue.esave";
#line 73 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
char const   *byebye_string  =    "Okay, bye bye!";
#line 76 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
int init(int argc , char **argv ) 
{ 
  char const   *pn ;
  int seed ;
  int fd___0 ;
  size_t tmp ;

  {
  {
#line 85
  gid = getgid();
#line 86
  egid = getegid();
#line 87
  setegid(gid);
#line 89
  fd___0 = open("/dev/null", 0);
  }
#line 90
  if (fd___0 < 3) {
    {
#line 91
    exit(1);
    }
  }
  {
#line 92
  close(fd___0);
#line 94
  seed = 0;
#line 95
  pn = md_gln();
  }
#line 96
  if (! pn) {
    {
#line 97
    clean_up("Hey!  Who are you?");
    }
  } else {
    {
#line 96
    tmp = strlen(pn);
    }
#line 96
    if (tmp >= 40UL) {
      {
#line 97
      clean_up("Hey!  Who are you?");
      }
    }
  }
  {
#line 99
  strcpy((char */* __restrict  */)(login_name), (char const   */* __restrict  */)pn);
#line 101
  do_args(argc, argv);
#line 102
  do_opts();
  }
#line 104
  if (! score_only) {
#line 104
    if (! rest_file) {
      {
#line 105
      printf((char const   */* __restrict  */)"Hello %s, just a moment while I dig the dungeon...",
             nick_name);
#line 107
      fflush(stdout);
      }
    }
  }
  {
#line 110
  initscr();
  }
#line 111
  if (LINES < 24) {
    {
#line 112
    clean_up("must be played on 24 x 80 screen");
    }
  } else
#line 111
  if (COLS < 80) {
    {
#line 112
    clean_up("must be played on 24 x 80 screen");
    }
  }
  {
#line 114
  start_window();
#line 115
  init_curses = (char)1;
#line 117
  md_heed_signals();
  }
#line 119
  if (score_only) {
    {
#line 120
    put_scores((object const   *)((object *)0), (short)0);
    }
  }
  {
#line 122
  seed = md_gseed();
#line 123
  srrandom(seed);
  }
#line 124
  if (rest_file) {
    {
#line 125
    restore((char const   *)rest_file);
    }
#line 126
    return (1);
  }
  {
#line 128
  mix_colors();
#line 129
  get_wand_and_ring_materials();
#line 130
  make_scroll_titles();
#line 132
  level_objects.next_object = (object *)0;
#line 133
  level_monsters.next_object = (object *)0;
#line 134
  player_init();
#line 135
  ring_stats((char)0);
  }
#line 136
  return (0);
}
}
#line 139 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void player_init(void) 
{ 
  object *obj ;
  short tmp ;
  int tmp___0 ;

  {
  {
#line 144
  rogue.pack.next_object = (object *)0;
#line 146
  obj = alloc_object();
#line 147
  get_food(obj, (char)1);
#line 148
  add_to_pack(obj, & rogue.pack, 1);
#line 150
  obj = alloc_object();
#line 151
  obj->what_is = (unsigned short)1;
#line 152
  obj->which_kind = (unsigned short)1;
#line 153
  obj->class = (short)3;
#line 154
  obj->is_protected = (short)0;
#line 155
  obj->d_enchant = (short)1;
#line 156
  add_to_pack(obj, & rogue.pack, 1);
#line 157
  do_wear(obj);
#line 159
  obj = alloc_object();
#line 160
  obj->what_is = (unsigned short)2;
#line 161
  obj->which_kind = (unsigned short)5;
#line 162
  obj->damage = "2d3";
#line 163
  tmp = (short)1;
#line 163
  obj->d_enchant = tmp;
#line 163
  obj->hit_enchant = tmp;
#line 164
  obj->identified = (short)1;
#line 165
  add_to_pack(obj, & rogue.pack, 1);
#line 166
  do_wield(obj);
#line 168
  obj = alloc_object();
#line 169
  obj->what_is = (unsigned short)2;
#line 170
  obj->which_kind = (unsigned short)0;
#line 171
  obj->damage = "1d1";
#line 172
  obj->hit_enchant = (short)1;
#line 173
  obj->d_enchant = (short)0;
#line 174
  obj->identified = (short)1;
#line 175
  add_to_pack(obj, & rogue.pack, 1);
#line 177
  obj = alloc_object();
#line 178
  obj->what_is = (unsigned short)2;
#line 179
  obj->which_kind = (unsigned short)2;
#line 180
  tmp___0 = get_rand(25, 35);
#line 180
  obj->quantity = (short )tmp___0;
#line 181
  obj->damage = "1d2";
#line 182
  obj->hit_enchant = (short)0;
#line 183
  obj->d_enchant = (short)0;
#line 184
  obj->identified = (short)1;
#line 185
  add_to_pack(obj, & rogue.pack, 1);
  }
#line 186
  return;
}
}
#line 188
 __attribute__((__noreturn__)) void clean_up(char const   *estr ) ;
#line 188 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void clean_up(char const   *estr ) 
{ 


  {
#line 192
  if (save_is_interactive) {
#line 193
    if (init_curses) {
      {
#line 194
      wmove(stdscr, 23, 0);
#line 195
      wrefresh(stdscr);
#line 196
      stop_window();
      }
    }
    {
#line 198
    printf((char const   */* __restrict  */)"\n%s\n", estr);
    }
  }
  {
#line 200
  md_exit(0);
  }
}
}
#line 203 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void start_window(void) 
{ 


  {
  {
#line 206
  cbreak();
#line 207
  noecho();
#line 209
  nonl();
  }
#line 211
  return;
}
}
#line 213 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void stop_window(void) 
{ 


  {
  {
#line 216
  endwin();
  }
#line 217
  return;
}
}
#line 219 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void byebye(int dummy  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 223
  md_ignore_signals();
  }
#line 224
  if (ask_quit) {
    {
#line 225
    quit((char)1);
    }
  } else {
    {
#line 227
    clean_up(byebye_string);
    }
  }
  {
#line 229
  md_heed_signals();
  }
#line 230
  return;
}
}
#line 232 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void onintr(int dummy  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 236
  md_ignore_signals();
  }
#line 237
  if (cant_int) {
#line 238
    did_int = (char)1;
  } else {
    {
#line 240
    check_message();
#line 241
    message("interrupt", (char)1);
    }
  }
  {
#line 243
  md_heed_signals();
  }
#line 244
  return;
}
}
#line 246
 __attribute__((__noreturn__)) void error_save(int dummy  __attribute__((__unused__)) ) ;
#line 246 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void error_save(int dummy  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 250
  save_is_interactive = (char)0;
#line 251
  save_into_file(error_file);
#line 252
  clean_up("");
  }
}
}
#line 255 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void do_args(int argc , char **argv ) 
{ 
  short i ;
  short j ;

  {
#line 262
  i = (short)1;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! ((int )i < argc)) {
#line 262
      goto while_break;
    }
#line 263
    if ((int )*(*(argv + i) + 0) == 45) {
#line 264
      j = (short)1;
      {
#line 264
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 264
        if (! *(*(argv + i) + j)) {
#line 264
          goto while_break___0;
        }
        {
#line 266
        if ((int )*(*(argv + i) + j) == 115) {
#line 266
          goto case_115;
        }
#line 265
        goto switch_break;
        case_115: /* CIL Label */ 
#line 267
        score_only = (char)1;
#line 268
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 264
        j = (short )((int )j + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 272
      rest_file = *(argv + i);
    }
#line 262
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 277 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void do_opts(void) 
{ 
  char *eptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 282
  eptr = md_getenv("ROGUEOPTS");
  }
#line 282
  if ((unsigned long )eptr != (unsigned long )((void *)0)) {
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 284
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 284
        if (! ((int )*eptr == 32)) {
#line 284
          goto while_break___0;
        }
#line 285
        eptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 287
      if (! *eptr) {
#line 288
        goto while_break;
      }
      {
#line 290
      tmp___6 = strncmp((char const   *)eptr, "fruit=", (size_t )6);
      }
#line 290
      if (tmp___6) {
        {
#line 293
        tmp___5 = strncmp((char const   *)eptr, "file=", (size_t )5);
        }
#line 293
        if (tmp___5) {
          {
#line 296
          tmp___4 = strncmp((char const   *)eptr, "jump", (size_t )4);
          }
#line 296
          if (tmp___4) {
            {
#line 298
            tmp___3 = strncmp((char const   *)eptr, "name=", (size_t )5);
            }
#line 298
            if (tmp___3) {
              {
#line 301
              tmp___2 = strncmp((char const   *)eptr, "noaskquit", (size_t )9);
              }
#line 301
              if (tmp___2) {
                {
#line 303
                tmp___0 = strncmp((char const   *)eptr, "noskull", (size_t )5);
                }
#line 303
                if (tmp___0) {
                  {
#line 303
                  tmp___1 = strncmp((char const   *)eptr, "notomb", (size_t )6);
                  }
#line 303
                  if (tmp___1) {
                    {
#line 306
                    tmp = strncmp((char const   *)eptr, "passgo", (size_t )5);
                    }
#line 306
                    if (! tmp) {
#line 307
                      passgo = (char)1;
                    }
                  } else {
#line 305
                    no_skull = (char)1;
                  }
                } else {
#line 305
                  no_skull = (char)1;
                }
              } else {
#line 302
                ask_quit = (char)0;
              }
            } else {
              {
#line 299
              eptr += 5;
#line 300
              env_get_value(& nick_name, eptr, (char)0);
              }
            }
          } else {
#line 297
            jump = (char)1;
          }
        } else {
          {
#line 294
          eptr += 5;
#line 295
          env_get_value(& save_file, eptr, (char)0);
          }
        }
      } else {
        {
#line 291
        eptr += 6;
#line 292
        env_get_value(& fruit, eptr, (char)1);
        }
      }
      {
#line 309
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 309
        if (*eptr) {
#line 309
          if (! ((int )*eptr != 44)) {
#line 309
            goto while_break___1;
          }
        } else {
#line 309
          goto while_break___1;
        }
#line 310
        eptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 312
      tmp___7 = eptr;
#line 312
      eptr ++;
#line 312
      if (! *tmp___7) {
#line 313
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 320
  init_str(& nick_name, (char const   *)(login_name));
#line 321
  init_str(& save_file, "rogue.save");
#line 322
  init_str(& fruit, "slime-mold");
  }
#line 323
  return;
}
}
#line 325 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void env_get_value(char **s___0 , char *e , char add_blank ) 
{ 
  short i ;
  char const   *t ;
  short tmp ;

  {
#line 330
  i = (short)0;
#line 333
  t = (char const   *)e;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (*e) {
#line 335
      if (! ((int )*e != 44)) {
#line 335
        goto while_break;
      }
    } else {
#line 335
      goto while_break;
    }
#line 336
    if ((int )*e == 58) {
#line 337
      *e = (char )';';
    }
#line 339
    e ++;
#line 340
    i = (short )((int )i + 1);
#line 340
    if ((int )i >= 40) {
#line 341
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  *s___0 = md_malloc(42);
  }
#line 345
  if ((unsigned long )*s___0 == (unsigned long )((void *)0)) {
    {
#line 346
    clean_up("out of memory");
    }
  }
  {
#line 347
  strncpy((char */* __restrict  */)*s___0, (char const   */* __restrict  */)t, (size_t )i);
  }
#line 348
  if (add_blank) {
#line 349
    tmp = i;
#line 349
    i = (short )((int )i + 1);
#line 349
    *(*s___0 + tmp) = (char )' ';
  }
#line 351
  *(*s___0 + i) = (char )'\000';
#line 352
  return;
}
}
#line 354 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/init.c"
void init_str(char **str , char const   *dflt ) 
{ 


  {
#line 359
  if (! *str) {
    {
#line 360
    *str = md_malloc(42);
    }
#line 361
    if ((unsigned long )*str == (unsigned long )((void *)0)) {
      {
#line 362
      clean_up("out of memory");
      }
    }
    {
#line 363
    strcpy((char */* __restrict  */)*str, (char const   */* __restrict  */)dflt);
    }
  }
#line 365
  return;
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 1384 "/usr/include/curses.h"
extern WINDOW *curscr ;
#line 600 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void md_slurp(void) ;
#line 628
void pad(char const   *s___0 , short n___0 ) ;
#line 651
int r_index(char const   *str , int ch , char last ) ;
#line 683
void save_screen(void) ;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char msgs[5][80]  = { {        (char )'\000'}, 
   {        (char )'\000'}, 
   {        (char )'\000'}, 
   {        (char )'\000'}, 
   {        (char )'\000'}};
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
short msg_col  =    (short)0;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
short imsg  =    (short)-1;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char msg_cleared  =    (char)1;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char rmsg  =    (char)0;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char hunger_str[8]  = {      (char )'\000'};
#line 64 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char const   *more  =    "-more-";
#line 66 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void message(char const   *msg , char intrpt ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 71
  cant_int = (char)1;
#line 73
  if (! save_is_interactive) {
#line 74
    return;
  }
#line 76
  if (intrpt) {
    {
#line 77
    interrupted = (char)1;
#line 78
    md_slurp();
    }
  }
#line 81
  if (! msg_cleared) {
    {
#line 82
    tmp = wmove(stdscr, 0, (int )msg_col);
    }
#line 82
    if (! (tmp == -1)) {
      {
#line 82
      waddnstr(stdscr, more, -1);
      }
    }
    {
#line 83
    wrefresh(stdscr);
#line 84
    wait_for_ack();
#line 85
    check_message();
    }
  }
#line 87
  if (! rmsg) {
    {
#line 88
    imsg = (short )(((int )imsg + 1) % 5);
#line 89
    strcpy((char */* __restrict  */)(msgs[imsg]), (char const   */* __restrict  */)msg);
    }
  }
  {
#line 91
  tmp___0 = wmove(stdscr, 0, 0);
  }
#line 91
  if (! (tmp___0 == -1)) {
    {
#line 91
    waddnstr(stdscr, msg, -1);
    }
  }
  {
#line 92
  waddch(stdscr, (chtype const   )' ');
#line 93
  wrefresh(stdscr);
#line 94
  msg_cleared = (char)0;
#line 95
  tmp___1 = strlen(msg);
#line 95
  msg_col = (short )tmp___1;
#line 97
  cant_int = (char)0;
  }
#line 99
  if (did_int) {
    {
#line 100
    did_int = (char)0;
#line 101
    onintr(0);
    }
  }
#line 103
  return;
}
}
#line 105 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void remessage(short c___0 ) 
{ 


  {
#line 109
  if ((int )imsg != -1) {
    {
#line 110
    check_message();
#line 111
    rmsg = (char)1;
    }
    {
#line 112
    while (1) {
      while_continue: /* CIL Label */ ;
#line 112
      if (! ((int )c___0 > (int )imsg)) {
#line 112
        goto while_break;
      }
#line 113
      c___0 = (short )((int )c___0 - 5);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 115
    message((char const   *)(msgs[((int )imsg - (int )c___0) % 5]), (char)0);
#line 116
    rmsg = (char)0;
#line 117
    wmove(stdscr, (int )rogue.row, (int )rogue.col);
#line 118
    wrefresh(stdscr);
    }
  }
#line 120
  return;
}
}
#line 122 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void check_message(void) 
{ 


  {
#line 125
  if (msg_cleared) {
#line 126
    return;
  }
  {
#line 128
  wmove(stdscr, 0, 0);
#line 129
  wclrtoeol(stdscr);
#line 130
  wrefresh(stdscr);
#line 131
  msg_cleared = (char)1;
  }
#line 132
  return;
}
}
#line 134 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
int get_input_line(char const   *prompt , char const   *insert , char *buf , char const   *if_cancelled ,
                   char add_blank , char do_echo ) 
{ 
  short ch ;
  short i ;
  short n___0 ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  short tmp___5 ;

  {
  {
#line 143
  i = (short)0;
#line 145
  message(prompt, (char)0);
#line 146
  tmp = strlen(prompt);
#line 146
  n___0 = (short )tmp;
  }
#line 148
  if (*(insert + 0)) {
    {
#line 149
    tmp___0 = wmove(stdscr, 0, (int )n___0 + 1);
    }
#line 149
    if (! (tmp___0 == -1)) {
      {
#line 149
      waddnstr(stdscr, insert, -1);
      }
    }
    {
#line 150
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)insert);
#line 151
    tmp___1 = strlen(insert);
#line 151
    i = (short )tmp___1;
#line 152
    wmove(stdscr, 0, ((int )n___0 + (int )i) + 1);
#line 153
    wrefresh(stdscr);
    }
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___4 = rgetchar();
#line 156
    ch = (short )tmp___4;
    }
#line 156
    if ((int )ch != 13) {
#line 156
      if ((int )ch != 10) {
#line 156
        if (! ((int )ch != 27)) {
#line 156
          goto while_break;
        }
      } else {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
#line 157
    if ((int )ch >= 32) {
#line 157
      if ((int )ch <= 126) {
#line 157
        if ((int )i < 28) {
#line 158
          if ((int )ch != 32) {
#line 158
            goto _L;
          } else
#line 158
          if ((int )i > 0) {
            _L: /* CIL Label */ 
#line 159
            tmp___2 = i;
#line 159
            i = (short )((int )i + 1);
#line 159
            *(buf + tmp___2) = (char )ch;
#line 160
            if (do_echo) {
              {
#line 161
              waddch(stdscr, (chtype const   )ch);
              }
            }
          }
        }
      }
    }
#line 165
    if ((int )ch == 8) {
#line 165
      if ((int )i > 0) {
#line 166
        if (do_echo) {
          {
#line 167
          tmp___3 = wmove(stdscr, 0, (int )i + (int )n___0);
          }
#line 167
          if (! (tmp___3 == -1)) {
            {
#line 167
            waddch(stdscr, (chtype const   )' ');
            }
          }
          {
#line 168
          wmove(stdscr, 0, (int )i + (int )n___0);
          }
        }
#line 170
        i = (short )((int )i - 1);
      }
    }
    {
#line 172
    wrefresh(stdscr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  check_message();
  }
#line 175
  if (add_blank) {
#line 176
    tmp___5 = i;
#line 176
    i = (short )((int )i + 1);
#line 176
    *(buf + tmp___5) = (char )' ';
  } else {
    {
#line 178
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 178
      if ((int )i > 0) {
#line 178
        if (! ((int )*(buf + ((int )i - 1)) == 32)) {
#line 178
          goto while_break___0;
        }
      } else {
#line 178
        goto while_break___0;
      }
#line 179
      i = (short )((int )i - 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 183
  *(buf + i) = (char)0;
#line 185
  if ((int )ch == 27) {
#line 185
    goto _L___0;
  } else
#line 185
  if ((int )i == 0) {
#line 185
    goto _L___0;
  } else
#line 185
  if ((int )i == 1) {
#line 185
    if (add_blank) {
      _L___0: /* CIL Label */ 
#line 186
      if (if_cancelled) {
        {
#line 187
        message(if_cancelled, (char)0);
        }
      }
#line 189
      return (0);
    }
  }
#line 191
  return ((int )i);
}
}
#line 194 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
int rgetchar(void) 
{ 
  int ch ;

  {
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 200
    ch = getchar();
    }
    {
#line 203
    if (ch == 18) {
#line 203
      goto case_18;
    }
#line 213
    if (ch == 38) {
#line 213
      goto case_38;
    }
#line 216
    goto switch_default;
    case_18: /* CIL Label */ 
    {
#line 204
    wrefresh(curscr);
    }
#line 205
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 214
    save_screen();
    }
#line 215
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 217
    return (ch);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 227 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void print_stats(int stat_mask ) 
{ 
  char buf[16] ;
  char label ;
  int row___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 233
  row___0 = 23;
#line 235
  if (stat_mask & 128) {
#line 235
    label = (char)1;
  } else {
#line 235
    label = (char)0;
  }
#line 237
  if (stat_mask & 1) {
#line 238
    if (label) {
      {
#line 239
      tmp = wmove(stdscr, row___0, 0);
      }
#line 239
      if (! (tmp == -1)) {
        {
#line 239
        waddnstr(stdscr, "Level: ", -1);
        }
      }
    }
    {
#line 242
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
            (int )cur_level);
#line 243
    tmp___0 = wmove(stdscr, row___0, 7);
    }
#line 243
    if (! (tmp___0 == -1)) {
      {
#line 243
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 244
    pad((char const   *)(buf), (short)2);
    }
  }
#line 246
  if (stat_mask & 2) {
#line 247
    if (label) {
      {
#line 248
      tmp___1 = wmove(stdscr, row___0, 10);
      }
#line 248
      if (! (tmp___1 == -1)) {
        {
#line 248
        waddnstr(stdscr, "Gold: ", -1);
        }
      }
    }
#line 250
    if (rogue.gold > 999999L) {
#line 251
      rogue.gold = 999999L;
    }
    {
#line 253
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%ld",
            rogue.gold);
#line 254
    tmp___2 = wmove(stdscr, row___0, 16);
    }
#line 254
    if (! (tmp___2 == -1)) {
      {
#line 254
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 255
    pad((char const   *)(buf), (short)6);
    }
  }
#line 257
  if (stat_mask & 4) {
#line 258
    if (label) {
      {
#line 259
      tmp___3 = wmove(stdscr, row___0, 23);
      }
#line 259
      if (! (tmp___3 == -1)) {
        {
#line 259
        waddnstr(stdscr, "Hp: ", -1);
        }
      }
    }
#line 261
    if ((int )rogue.hp_max > 999) {
#line 262
      rogue.hp_current = (short )((int )rogue.hp_current - ((int )rogue.hp_max - 999));
#line 263
      rogue.hp_max = (short)999;
    }
    {
#line 265
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d(%d)",
            (int )rogue.hp_current, (int )rogue.hp_max);
#line 266
    tmp___4 = wmove(stdscr, row___0, 27);
    }
#line 266
    if (! (tmp___4 == -1)) {
      {
#line 266
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 267
    pad((char const   *)(buf), (short)8);
    }
  }
#line 269
  if (stat_mask & 8) {
#line 270
    if (label) {
      {
#line 271
      tmp___5 = wmove(stdscr, row___0, 36);
      }
#line 271
      if (! (tmp___5 == -1)) {
        {
#line 271
        waddnstr(stdscr, "Str: ", -1);
        }
      }
    }
#line 273
    if ((int )rogue.str_max > 99) {
#line 274
      rogue.str_current = (short )((int )rogue.str_current - ((int )rogue.str_max - 99));
#line 275
      rogue.str_max = (short)99;
    }
    {
#line 277
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d(%d)",
            (int )rogue.str_current + (int )add_strength, (int )rogue.str_max);
#line 279
    tmp___6 = wmove(stdscr, row___0, 41);
    }
#line 279
    if (! (tmp___6 == -1)) {
      {
#line 279
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 280
    pad((char const   *)(buf), (short)6);
    }
  }
#line 282
  if (stat_mask & 16) {
#line 283
    if (label) {
      {
#line 284
      tmp___7 = wmove(stdscr, row___0, 48);
      }
#line 284
      if (! (tmp___7 == -1)) {
        {
#line 284
        waddnstr(stdscr, "Arm: ", -1);
        }
      }
    }
#line 286
    if (rogue.armor) {
#line 286
      if ((int )(rogue.armor)->d_enchant > 99) {
#line 287
        (rogue.armor)->d_enchant = (short)99;
      }
    }
    {
#line 289
    tmp___8 = get_armor_class((object const   *)rogue.armor);
#line 289
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
            tmp___8);
#line 290
    tmp___9 = wmove(stdscr, row___0, 53);
    }
#line 290
    if (! (tmp___9 == -1)) {
      {
#line 290
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 291
    pad((char const   *)(buf), (short)2);
    }
  }
#line 293
  if (stat_mask & 32) {
#line 294
    if (label) {
      {
#line 295
      tmp___10 = wmove(stdscr, row___0, 56);
      }
#line 295
      if (! (tmp___10 == -1)) {
        {
#line 295
        waddnstr(stdscr, "Exp: ", -1);
        }
      }
    }
#line 297
    if (rogue.exp_points > 10000001L) {
#line 298
      rogue.exp_points = 10000001L;
    }
#line 300
    if ((int )rogue.exp > 21) {
#line 301
      rogue.exp = (short)21;
    }
    {
#line 303
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d/%ld",
            (int )rogue.exp, rogue.exp_points);
#line 304
    tmp___11 = wmove(stdscr, row___0, 61);
    }
#line 304
    if (! (tmp___11 == -1)) {
      {
#line 304
      waddnstr(stdscr, (char const   *)(buf), -1);
      }
    }
    {
#line 305
    pad((char const   *)(buf), (short)11);
    }
  }
#line 307
  if (stat_mask & 64) {
    {
#line 308
    tmp___12 = wmove(stdscr, row___0, 73);
    }
#line 308
    if (! (tmp___12 == -1)) {
      {
#line 308
      waddnstr(stdscr, (char const   *)(hunger_str), -1);
      }
    }
    {
#line 309
    wclrtoeol(stdscr);
    }
  }
  {
#line 311
  wrefresh(stdscr);
  }
#line 312
  return;
}
}
#line 314 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void pad(char const   *s___0 , short n___0 ) 
{ 
  short i ;
  size_t tmp ;

  {
  {
#line 321
  tmp = strlen(s___0);
#line 321
  i = (short )tmp;
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((int )i < (int )n___0)) {
#line 321
      goto while_break;
    }
    {
#line 322
    waddch(stdscr, (chtype const   )' ');
#line 321
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return;
}
}
#line 326 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void save_screen(void) 
{ 
  FILE *fp ;
  short i ;
  short j ;
  char buf[82] ;
  char found_non_blank ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 334
  fp = fopen((char const   */* __restrict  */)"rogue.screen", (char const   */* __restrict  */)"w");
  }
#line 334
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 335
    i = (short)0;
    {
#line 335
    while (1) {
      while_continue: /* CIL Label */ ;
#line 335
      if (! ((int )i < 24)) {
#line 335
        goto while_break;
      }
#line 336
      found_non_blank = (char)0;
#line 337
      j = (short)79;
      {
#line 337
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 337
        if (! ((int )j >= 0)) {
#line 337
          goto while_break___0;
        }
        {
#line 338
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 338
        if (tmp___1 == -1) {
#line 338
          buf[j] = (char )((chtype )-1);
        } else {
          {
#line 338
          tmp___0 = winch(stdscr);
#line 338
          buf[j] = (char )tmp___0;
          }
        }
#line 339
        if (! found_non_blank) {
#line 340
          if ((int )buf[j] != 32) {
#line 340
            goto _L;
          } else
#line 340
          if ((int )j == 0) {
            _L: /* CIL Label */ 
#line 341
            if ((int )j == 0) {
#line 341
              tmp___2 = 0;
            } else {
#line 341
              tmp___2 = 1;
            }
#line 341
            buf[(int )j + tmp___2] = (char)0;
#line 342
            found_non_blank = (char)1;
          }
        }
#line 337
        j = (short )((int )j - 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 346
      fputs((char const   */* __restrict  */)(buf), (FILE */* __restrict  */)fp);
#line 347
      _IO_putc('\n', fp);
#line 335
      i = (short )((int )i + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 349
    fclose(fp);
    }
  } else {
    {
#line 351
    sound_bell();
    }
  }
#line 353
  return;
}
}
#line 355 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
void sound_bell(void) 
{ 


  {
  {
#line 358
  putchar(7);
#line 359
  fflush(stdout);
  }
#line 360
  return;
}
}
#line 362 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
char is_digit(short ch ) 
{ 
  int tmp ;

  {
#line 366
  if ((int )ch >= 48) {
#line 366
    if ((int )ch <= 57) {
#line 366
      tmp = 1;
    } else {
#line 366
      tmp = 0;
    }
  } else {
#line 366
    tmp = 0;
  }
#line 366
  return ((char )tmp);
}
}
#line 369 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/message.c"
int r_index(char const   *str , int ch , char last ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 375
  i = 0;
#line 377
  if (last) {
    {
#line 378
    tmp = strlen(str);
#line 378
    i = (int )(tmp - 1UL);
    }
    {
#line 378
    while (1) {
      while_continue: /* CIL Label */ ;
#line 378
      if (! (i >= 0)) {
#line 378
        goto while_break;
      }
#line 379
      if ((int const   )*(str + i) == (int const   )ch) {
#line 380
        return (i);
      }
#line 378
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 384
    i = 0;
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 384
      if (! *(str + i)) {
#line 384
        goto while_break___0;
      }
#line 385
      if ((int const   )*(str + i) == (int const   )ch) {
#line 386
        return (i);
      }
#line 384
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 390
  return (-1);
}
}
#line 463 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void add_mazes(void) ;
#line 484
int connect_rooms(short room1 , short room2 ) ;
#line 499
void draw_simple_passage(short row1 , short col1 , short row2 , short col2 , short dir ) ;
#line 508
void fill_it(int rn , char do_rec_de ) ;
#line 509
void fill_out_level(void) ;
#line 523
int get_exp_level(long e ) ;
#line 554
void hide_boxed_passage(short row1 , short col1 , short row2 , short col2 , short n___0 ) ;
#line 556
int hp_raise(void) ;
#line 569
char is_all_connected(void) ;
#line 582
void make_maze(short r , short c___0 , short tr , short br , short lc , short rc ) ;
#line 584
void make_room(short rn , short r1 , short r2 , short r3 ) ;
#line 587
char mask_room(short rn , short *row___0 , short *col___0 , unsigned short mask ) ;
#line 603
void mix_random_rooms(void) ;
#line 639
void put_amulet(void) ;
#line 640
void put_door(room *rm , short dir , short *row___0 , short *col___0 ) ;
#line 660
void recursive_deadend(short rn , short const   *offsets___0 , short srow , short scol ) ;
#line 679
int same_col(int room1 , int room2 ) ;
#line 680
int same_row(int room1 , int room2 ) ;
#line 785 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
short cur_room  ;
#line 791
short less_hp ;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
short cur_level  =    (short)0;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
short max_level  =    (short)1;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
char const   *new_level_message  =    (char const   *)0;
#line 64 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
short party_room  =    (short)-1;
#line 65 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
short r_de  ;
#line 67 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
long const   level_points[21]  = 
#line 67
  {      (long const   )10L,      (long const   )20L,      (long const   )40L,      (long const   )80L, 
        (long const   )160L,      (long const   )320L,      (long const   )640L,      (long const   )1300L, 
        (long const   )2600L,      (long const   )5200L,      (long const   )10000L,      (long const   )20000L, 
        (long const   )40000L,      (long const   )80000L,      (long const   )160000L,      (long const   )320000L, 
        (long const   )1000000L,      (long const   )3333333L,      (long const   )6666666L,      (long const   )10000001L, 
        (long const   )99900000L};
#line 91 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
short random_rooms[9]  = 
#line 91
  {      (short)3,      (short)7,      (short)5,      (short)2, 
        (short)0,      (short)6,      (short)1,      (short)4, 
        (short)8};
#line 93 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void make_level(void) 
{ 
  short i ;
  short j ;
  short must_1 ;
  short must_2 ;
  short must_3 ;
  char big_room ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char tmp___5 ;
  char tmp___6 ;

  {
#line 100
  must_3 = (short)0;
#line 100
  must_2 = must_3;
#line 101
  if ((int )cur_level < 99) {
#line 102
    cur_level = (short )((int )cur_level + 1);
  }
#line 104
  if ((int )cur_level > (int )max_level) {
#line 105
    max_level = cur_level;
  }
  {
#line 107
  tmp = get_rand(0, 5);
#line 107
  must_1 = (short )tmp;
  }
  {
#line 110
  if ((int )must_1 == 0) {
#line 110
    goto case_0;
  }
#line 115
  if ((int )must_1 == 1) {
#line 115
    goto case_1;
  }
#line 120
  if ((int )must_1 == 2) {
#line 120
    goto case_2;
  }
#line 125
  if ((int )must_1 == 3) {
#line 125
    goto case_3;
  }
#line 130
  if ((int )must_1 == 4) {
#line 130
    goto case_4;
  }
#line 135
  if ((int )must_1 == 5) {
#line 135
    goto case_5;
  }
#line 109
  goto switch_break;
  case_0: /* CIL Label */ 
#line 111
  must_1 = (short)0;
#line 112
  must_2 = (short)1;
#line 113
  must_3 = (short)2;
#line 114
  goto switch_break;
  case_1: /* CIL Label */ 
#line 116
  must_1 = (short)3;
#line 117
  must_2 = (short)4;
#line 118
  must_3 = (short)5;
#line 119
  goto switch_break;
  case_2: /* CIL Label */ 
#line 121
  must_1 = (short)6;
#line 122
  must_2 = (short)7;
#line 123
  must_3 = (short)8;
#line 124
  goto switch_break;
  case_3: /* CIL Label */ 
#line 126
  must_1 = (short)0;
#line 127
  must_2 = (short)3;
#line 128
  must_3 = (short)6;
#line 129
  goto switch_break;
  case_4: /* CIL Label */ 
#line 131
  must_1 = (short)1;
#line 132
  must_2 = (short)4;
#line 133
  must_3 = (short)7;
#line 134
  goto switch_break;
  case_5: /* CIL Label */ 
#line 136
  must_1 = (short)2;
#line 137
  must_2 = (short)5;
#line 138
  must_3 = (short)8;
#line 139
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 141
  tmp___0 = rand_percent(8);
  }
#line 141
  if (tmp___0) {
#line 142
    party_room = (short)0;
  }
#line 144
  if ((int )party_room != -1) {
    {
#line 144
    tmp___1 = rand_percent(1);
    }
#line 144
    if (tmp___1) {
#line 144
      tmp___2 = 1;
    } else {
#line 144
      tmp___2 = 0;
    }
  } else {
#line 144
    tmp___2 = 0;
  }
#line 144
  big_room = (char )tmp___2;
#line 145
  if (big_room) {
    {
#line 146
    make_room((short)10, (short)0, (short)0, (short)0);
    }
  } else {
#line 148
    i = (short)0;
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
#line 148
      if (! ((int )i < 9)) {
#line 148
        goto while_break;
      }
      {
#line 149
      make_room(i, must_1, must_2, must_3);
#line 148
      i = (short )((int )i + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 152
  if (! big_room) {
    {
#line 153
    add_mazes();
#line 155
    mix_random_rooms();
#line 157
    j = (short)0;
    }
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! ((int )j < 9)) {
#line 157
        goto while_break___0;
      }
#line 159
      i = random_rooms[j];
#line 161
      if ((int )i < 8) {
        {
#line 162
        connect_rooms(i, (short )((int )i + 1));
        }
      }
#line 164
      if ((int )i < 6) {
        {
#line 165
        connect_rooms(i, (short )((int )i + 3));
        }
      }
#line 167
      if ((int )i < 7) {
#line 168
        if ((int )rooms[(int )i + 1].is_room & 1) {
          {
#line 169
          tmp___3 = connect_rooms(i, (short )((int )i + 2));
          }
#line 169
          if (tmp___3) {
#line 170
            rooms[(int )i + 1].is_room = (unsigned short)16;
          }
        }
      }
#line 174
      if ((int )i < 3) {
#line 175
        if ((int )rooms[(int )i + 3].is_room & 1) {
          {
#line 176
          tmp___4 = connect_rooms(i, (short )((int )i + 6));
          }
#line 176
          if (tmp___4) {
#line 177
            rooms[(int )i + 3].is_room = (unsigned short)16;
          }
        }
      }
      {
#line 181
      tmp___5 = is_all_connected();
      }
#line 181
      if (tmp___5) {
#line 182
        goto while_break___0;
      }
#line 157
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 185
    fill_out_level();
    }
  }
  {
#line 187
  tmp___6 = has_amulet();
  }
#line 187
  if (! tmp___6) {
#line 187
    if ((int )cur_level >= 26) {
      {
#line 188
      put_amulet();
      }
    }
  }
#line 190
  return;
}
}
#line 192 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void make_room(short rn , short r1 , short r2 , short r3 ) 
{ 
  short left_col ;
  short right_col ;
  short top_row ;
  short bottom_row ;
  short width ;
  short height ;
  short row_offset ;
  short col_offset ;
  short i ;
  short j ;
  short ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 201
  bottom_row = (short)0;
#line 201
  top_row = bottom_row;
#line 201
  right_col = top_row;
#line 201
  left_col = right_col;
  {
#line 203
  if ((int )rn == 0) {
#line 203
    goto case_0;
  }
#line 209
  if ((int )rn == 1) {
#line 209
    goto case_1;
  }
#line 215
  if ((int )rn == 2) {
#line 215
    goto case_2;
  }
#line 221
  if ((int )rn == 3) {
#line 221
    goto case_3;
  }
#line 227
  if ((int )rn == 4) {
#line 227
    goto case_4;
  }
#line 233
  if ((int )rn == 5) {
#line 233
    goto case_5;
  }
#line 239
  if ((int )rn == 6) {
#line 239
    goto case_6;
  }
#line 245
  if ((int )rn == 7) {
#line 245
    goto case_7;
  }
#line 251
  if ((int )rn == 8) {
#line 251
    goto case_8;
  }
#line 257
  if ((int )rn == 10) {
#line 257
    goto case_10;
  }
#line 202
  goto switch_break;
  case_0: /* CIL Label */ 
#line 204
  left_col = (short)0;
#line 205
  right_col = (short)25;
#line 206
  top_row = (short)1;
#line 207
  bottom_row = (short)6;
#line 208
  goto switch_break;
  case_1: /* CIL Label */ 
#line 210
  left_col = (short)27;
#line 211
  right_col = (short)51;
#line 212
  top_row = (short)1;
#line 213
  bottom_row = (short)6;
#line 214
  goto switch_break;
  case_2: /* CIL Label */ 
#line 216
  left_col = (short)53;
#line 217
  right_col = (short)79;
#line 218
  top_row = (short)1;
#line 219
  bottom_row = (short)6;
#line 220
  goto switch_break;
  case_3: /* CIL Label */ 
#line 222
  left_col = (short)0;
#line 223
  right_col = (short)25;
#line 224
  top_row = (short)8;
#line 225
  bottom_row = (short)14;
#line 226
  goto switch_break;
  case_4: /* CIL Label */ 
#line 228
  left_col = (short)27;
#line 229
  right_col = (short)51;
#line 230
  top_row = (short)8;
#line 231
  bottom_row = (short)14;
#line 232
  goto switch_break;
  case_5: /* CIL Label */ 
#line 234
  left_col = (short)53;
#line 235
  right_col = (short)79;
#line 236
  top_row = (short)8;
#line 237
  bottom_row = (short)14;
#line 238
  goto switch_break;
  case_6: /* CIL Label */ 
#line 240
  left_col = (short)0;
#line 241
  right_col = (short)25;
#line 242
  top_row = (short)16;
#line 243
  bottom_row = (short)22;
#line 244
  goto switch_break;
  case_7: /* CIL Label */ 
#line 246
  left_col = (short)27;
#line 247
  right_col = (short)51;
#line 248
  top_row = (short)16;
#line 249
  bottom_row = (short)22;
#line 250
  goto switch_break;
  case_8: /* CIL Label */ 
#line 252
  left_col = (short)53;
#line 253
  right_col = (short)79;
#line 254
  top_row = (short)16;
#line 255
  bottom_row = (short)22;
#line 256
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 258
  tmp = get_rand(1, 6);
#line 258
  top_row = (short )tmp;
#line 259
  tmp___0 = get_rand(17, 22);
#line 259
  bottom_row = (short )tmp___0;
#line 260
  tmp___1 = get_rand(0, 10);
#line 260
  left_col = (short )tmp___1;
#line 261
  tmp___2 = get_rand(69, 79);
#line 261
  right_col = (short )tmp___2;
#line 262
  rn = (short)0;
  }
#line 263
  goto B;
  switch_break: /* CIL Label */ ;
  }
  {
#line 265
  tmp___3 = get_rand(4, ((int )bottom_row - (int )top_row) + 1);
#line 265
  height = (short )tmp___3;
#line 266
  tmp___4 = get_rand(7, ((int )right_col - (int )left_col) - 2);
#line 266
  width = (short )tmp___4;
#line 268
  tmp___5 = get_rand(0, (((int )bottom_row - (int )top_row) - (int )height) + 1);
#line 268
  row_offset = (short )tmp___5;
#line 269
  tmp___6 = get_rand(0, (((int )right_col - (int )left_col) - (int )width) + 1);
#line 269
  col_offset = (short )tmp___6;
#line 271
  top_row = (short )((int )top_row + (int )row_offset);
#line 272
  bottom_row = (short )(((int )top_row + (int )height) - 1);
#line 274
  left_col = (short )((int )left_col + (int )col_offset);
#line 275
  right_col = (short )(((int )left_col + (int )width) - 1);
  }
#line 277
  if ((int )rn != (int )r1) {
#line 277
    if ((int )rn != (int )r2) {
#line 277
      if ((int )rn != (int )r3) {
        {
#line 277
        tmp___7 = rand_percent(40);
        }
#line 277
        if (tmp___7) {
#line 278
          goto END;
        }
      }
    }
  }
  B: 
#line 281
  rooms[rn].is_room = (unsigned short)2;
#line 283
  i = top_row;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! ((int )i <= (int )bottom_row)) {
#line 283
      goto while_break;
    }
#line 284
    j = left_col;
    {
#line 284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 284
      if (! ((int )j <= (int )right_col)) {
#line 284
        goto while_break___0;
      }
#line 285
      if ((int )i == (int )top_row) {
#line 286
        ch = (short)8;
      } else
#line 285
      if ((int )i == (int )bottom_row) {
#line 286
        ch = (short)8;
      } else
#line 287
      if ((int )i != (int )top_row) {
#line 287
        if ((int )i != (int )bottom_row) {
#line 287
          if ((int )j == (int )left_col) {
#line 289
            ch = (short)16;
          } else
#line 287
          if ((int )j == (int )right_col) {
#line 289
            ch = (short)16;
          } else {
#line 291
            ch = (short)64;
          }
        } else {
#line 291
          ch = (short)64;
        }
      } else {
#line 291
        ch = (short)64;
      }
#line 293
      dungeon[i][j] = (unsigned short )ch;
#line 284
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 283
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  END: 
#line 297
  rooms[rn].top_row = top_row;
#line 298
  rooms[rn].bottom_row = bottom_row;
#line 299
  rooms[rn].left_col = left_col;
#line 300
  rooms[rn].right_col = right_col;
#line 301
  return;
}
}
#line 303 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int connect_rooms(short room1 , short room2 ) 
{ 
  short row1 ;
  short col1 ;
  short row2 ;
  short col2 ;
  short dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 309
  if (! ((int )rooms[room1].is_room & 6)) {
#line 311
    return (0);
  } else
#line 309
  if (! ((int )rooms[room2].is_room & 6)) {
#line 311
    return (0);
  }
  {
#line 313
  tmp___2 = same_row((int )room1, (int )room2);
  }
#line 313
  if (tmp___2) {
#line 313
    if ((int )rooms[room1].left_col > (int )rooms[room2].right_col) {
      {
#line 315
      put_door(& rooms[room1], (short)6, & row1, & col1);
#line 316
      put_door(& rooms[room2], (short)2, & row2, & col2);
#line 317
      dir = (short)6;
      }
    } else {
#line 313
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 318
    tmp___1 = same_row((int )room1, (int )room2);
    }
#line 318
    if (tmp___1) {
#line 318
      if ((int )rooms[room2].left_col > (int )rooms[room1].right_col) {
        {
#line 320
        put_door(& rooms[room1], (short)2, & row1, & col1);
#line 321
        put_door(& rooms[room2], (short)6, & row2, & col2);
#line 322
        dir = (short)2;
        }
      } else {
#line 318
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 323
      tmp___0 = same_col((int )room1, (int )room2);
      }
#line 323
      if (tmp___0) {
#line 323
        if ((int )rooms[room1].top_row > (int )rooms[room2].bottom_row) {
          {
#line 325
          put_door(& rooms[room1], (short)0, & row1, & col1);
#line 326
          put_door(& rooms[room2], (short)4, & row2, & col2);
#line 327
          dir = (short)0;
          }
        } else {
#line 323
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 328
        tmp = same_col((int )room1, (int )room2);
        }
#line 328
        if (tmp) {
#line 328
          if ((int )rooms[room2].top_row > (int )rooms[room1].bottom_row) {
            {
#line 330
            put_door(& rooms[room1], (short)4, & row1, & col1);
#line 331
            put_door(& rooms[room2], (short)0, & row2, & col2);
#line 332
            dir = (short)4;
            }
          } else {
#line 334
            return (0);
          }
        } else {
#line 334
          return (0);
        }
      }
    }
  }
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 338
    draw_simple_passage(row1, col1, row2, col2, dir);
#line 337
    tmp___3 = rand_percent(4);
    }
#line 337
    if (! tmp___3) {
#line 337
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  rooms[room1].doors[(int )dir / 2].oth_room = room2;
#line 342
  rooms[room1].doors[(int )dir / 2].oth_row = row2;
#line 343
  rooms[room1].doors[(int )dir / 2].oth_col = col2;
#line 345
  rooms[room2].doors[(((int )dir + 4) % 8) / 2].oth_room = room1;
#line 346
  rooms[room2].doors[(((int )dir + 4) % 8) / 2].oth_row = row1;
#line 347
  rooms[room2].doors[(((int )dir + 4) % 8) / 2].oth_col = col1;
#line 348
  return (1);
}
}
#line 351 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void clear_level(void) 
{ 
  short i ;
  short j ;

  {
#line 356
  i = (short)0;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! ((int )i < 9)) {
#line 356
      goto while_break;
    }
#line 357
    rooms[i].is_room = (unsigned short)1;
#line 358
    j = (short)0;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! ((int )j < 4)) {
#line 358
        goto while_break___0;
      }
#line 359
      rooms[i].doors[j].oth_room = (short)-1;
#line 358
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 356
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  i = (short)0;
  {
#line 363
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 363
    if (! ((int )i < 10)) {
#line 363
      goto while_break___1;
    }
#line 364
    traps[i].trap_type = (short)-1;
#line 363
    i = (short )((int )i + 1);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 366
  i = (short)0;
  {
#line 366
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 366
    if (! ((int )i < 24)) {
#line 366
      goto while_break___2;
    }
#line 367
    j = (short)0;
    {
#line 367
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 367
      if (! ((int )j < 80)) {
#line 367
        goto while_break___3;
      }
#line 368
      dungeon[i][j] = (unsigned short)0;
#line 367
      j = (short )((int )j + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 366
    i = (short )((int )i + 1);
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 371
  see_invisible = (char)0;
#line 371
  detect_monster = see_invisible;
#line 372
  bear_trap = (short)0;
#line 372
  being_held = (char )bear_trap;
#line 373
  party_room = (short)-1;
#line 374
  rogue.col = (short)-1;
#line 374
  rogue.row = rogue.col;
#line 375
  wclear(stdscr);
  }
#line 376
  return;
}
}
#line 378 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void put_door(room *rm , short dir , short *row___0 , short *col___0 ) 
{ 
  short wall_width ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 386
  if ((int )rm->is_room & 4) {
#line 386
    wall_width = (short)0;
  } else {
#line 386
    wall_width = (short)1;
  }
  {
#line 390
  if ((int )dir == 4) {
#line 390
    goto case_4;
  }
#line 390
  if ((int )dir == 0) {
#line 390
    goto case_4;
  }
#line 398
  if ((int )dir == 6) {
#line 398
    goto case_6;
  }
#line 398
  if ((int )dir == 2) {
#line 398
    goto case_6;
  }
#line 388
  goto switch_break;
  case_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 391
  if ((int )dir == 0) {
#line 391
    *row___0 = rm->top_row;
  } else {
#line 391
    *row___0 = rm->bottom_row;
  }
  {
#line 392
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 393
    tmp = get_rand((int )rm->left_col + (int )wall_width, (int )rm->right_col - (int )wall_width);
#line 393
    *col___0 = (short )tmp;
    }
#line 392
    if (! (! ((int )dungeon[*row___0][*col___0] & 136))) {
#line 392
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  goto switch_break;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 399
  if ((int )dir == 6) {
#line 399
    *col___0 = rm->left_col;
  } else {
#line 399
    *col___0 = rm->right_col;
  }
  {
#line 400
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 401
    tmp___0 = get_rand((int )rm->top_row + (int )wall_width, (int )rm->bottom_row - (int )wall_width);
#line 401
    *row___0 = (short )tmp___0;
    }
#line 400
    if (! (! ((int )dungeon[*row___0][*col___0] & 144))) {
#line 400
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 404
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 406
  if ((int )rm->is_room & 2) {
#line 407
    dungeon[*row___0][*col___0] = (unsigned short)32;
  }
#line 409
  if ((int )cur_level > 2) {
    {
#line 409
    tmp___1 = rand_percent(12);
    }
#line 409
    if (tmp___1) {
#line 410
      dungeon[*row___0][*col___0] = (unsigned short )((int )dungeon[*row___0][*col___0] | 512);
    }
  }
#line 412
  rm->doors[(int )dir / 2].door_row = *row___0;
#line 413
  rm->doors[(int )dir / 2].door_col = *col___0;
#line 414
  return;
}
}
#line 416 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void draw_simple_passage(short row1 , short col1 , short row2 , short col2 , short dir ) 
{ 
  short i ;
  short middle ;
  short t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 422
  if ((int )dir == 6) {
#line 422
    goto _L;
  } else
#line 422
  if ((int )dir == 2) {
    _L: /* CIL Label */ 
#line 423
    if ((int )col1 > (int )col2) {
#line 424
      t = row1;
#line 424
      row1 = row2;
#line 424
      row2 = t;
#line 425
      t = col1;
#line 425
      col1 = col2;
#line 425
      col2 = t;
    }
    {
#line 427
    tmp = get_rand((int )col1 + 1, (int )col2 - 1);
#line 427
    middle = (short )tmp;
#line 428
    i = (short )((int )col1 + 1);
    }
    {
#line 428
    while (1) {
      while_continue: /* CIL Label */ ;
#line 428
      if (! ((int )i != (int )middle)) {
#line 428
        goto while_break;
      }
#line 429
      dungeon[row1][i] = (unsigned short)128;
#line 428
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 431
    i = row1;
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 431
      if (! ((int )i != (int )row2)) {
#line 431
        goto while_break___0;
      }
#line 432
      dungeon[i][middle] = (unsigned short)128;
#line 431
      if ((int )row1 > (int )row2) {
#line 431
        tmp___0 = -1;
      } else {
#line 431
        tmp___0 = 1;
      }
#line 431
      i = (short )((int )i + tmp___0);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 434
    i = middle;
    {
#line 434
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 434
      if (! ((int )i != (int )col2)) {
#line 434
        goto while_break___1;
      }
#line 435
      dungeon[row2][i] = (unsigned short)128;
#line 434
      i = (short )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 438
    if ((int )row1 > (int )row2) {
#line 439
      t = row1;
#line 439
      row1 = row2;
#line 439
      row2 = t;
#line 440
      t = col1;
#line 440
      col1 = col2;
#line 440
      col2 = t;
    }
    {
#line 442
    tmp___1 = get_rand((int )row1 + 1, (int )row2 - 1);
#line 442
    middle = (short )tmp___1;
#line 443
    i = (short )((int )row1 + 1);
    }
    {
#line 443
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 443
      if (! ((int )i != (int )middle)) {
#line 443
        goto while_break___2;
      }
#line 444
      dungeon[i][col1] = (unsigned short)128;
#line 443
      i = (short )((int )i + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 446
    i = col1;
    {
#line 446
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 446
      if (! ((int )i != (int )col2)) {
#line 446
        goto while_break___3;
      }
#line 447
      dungeon[middle][i] = (unsigned short)128;
#line 446
      if ((int )col1 > (int )col2) {
#line 446
        tmp___2 = -1;
      } else {
#line 446
        tmp___2 = 1;
      }
#line 446
      i = (short )((int )i + tmp___2);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 449
    i = middle;
    {
#line 449
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 449
      if (! ((int )i != (int )row2)) {
#line 449
        goto while_break___4;
      }
#line 450
      dungeon[i][col2] = (unsigned short)128;
#line 449
      i = (short )((int )i + 1);
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 453
  tmp___3 = rand_percent(12);
  }
#line 453
  if (tmp___3) {
    {
#line 454
    hide_boxed_passage((int )row1, (int )col1, (int )row2, (int )col2, 1);
    }
  }
#line 456
  return;
}
}
#line 458 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int same_row(int room1 , int room2 ) 
{ 


  {
#line 462
  return (room1 / 3 == room2 / 3);
}
}
#line 465 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int same_col(int room1 , int room2 ) 
{ 


  {
#line 469
  return (room1 % 3 == room2 % 3);
}
}
#line 472 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void add_mazes(void) 
{ 
  short i ;
  short j ;
  short start ;
  short maze_percent ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 479
  if ((int )cur_level > 1) {
    {
#line 480
    tmp = get_rand(0, 8);
#line 480
    start = (short )tmp;
#line 481
    maze_percent = (short )(((int )cur_level * 5) / 4);
    }
#line 483
    if ((int )cur_level > 15) {
#line 484
      maze_percent = (short )((int )maze_percent + (int )cur_level);
    }
#line 486
    i = (short)0;
    {
#line 486
    while (1) {
      while_continue: /* CIL Label */ ;
#line 486
      if (! ((int )i < 9)) {
#line 486
        goto while_break;
      }
#line 487
      j = (short )(((int )start + (int )i) % 9);
#line 488
      if ((int )rooms[j].is_room & 1) {
        {
#line 489
        tmp___3 = rand_percent((int )maze_percent);
        }
#line 489
        if (tmp___3) {
          {
#line 490
          rooms[j].is_room = (unsigned short)4;
#line 491
          tmp___0 = get_rand((int )rooms[j].left_col + 1, (int )rooms[j].right_col - 1);
#line 491
          tmp___1 = get_rand((int )rooms[j].top_row + 1, (int )rooms[j].bottom_row - 1);
#line 491
          make_maze((short )tmp___1, (short )tmp___0, rooms[j].top_row, rooms[j].bottom_row,
                    rooms[j].left_col, rooms[j].right_col);
#line 495
          tmp___2 = get_rand(0, 2);
#line 495
          hide_boxed_passage((int )rooms[j].top_row, (int )rooms[j].left_col, (int )rooms[j].bottom_row,
                             (int )rooms[j].right_col, tmp___2);
          }
        }
      }
#line 486
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 502
  return;
}
}
#line 504 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void fill_out_level(void) 
{ 
  short i ;
  short rn ;
  int tmp ;

  {
  {
#line 509
  mix_random_rooms();
#line 511
  r_de = (short)-1;
#line 513
  i = (short)0;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! ((int )i < 9)) {
#line 513
      goto while_break;
    }
#line 514
    rn = random_rooms[i];
#line 515
    if ((int )rooms[rn].is_room & 1) {
      {
#line 517
      fill_it((int )rn, (char)1);
      }
    } else
#line 515
    if ((int )rooms[rn].is_room & 16) {
      {
#line 515
      tmp = coin_toss();
      }
#line 515
      if (tmp) {
        {
#line 517
        fill_it((int )rn, (char)1);
        }
      }
    }
#line 513
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 520
  if ((int )r_de != -1) {
    {
#line 521
    fill_it((int )r_de, (char)0);
    }
  }
#line 523
  return;
}
}
#line 533 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
static short offsets[4]  = {      (short)-1,      (short)1,      (short)3,      (short)-3};
#line 525 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void fill_it(int rn , char do_rec_de ) 
{ 
  short i ;
  short tunnel_dir ;
  short door_dir ;
  short drow ;
  short dcol ;
  short target_room ;
  short rooms_found ;
  short srow ;
  short scol ;
  short t ;
  char did_this ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  int tmp___5 ;

  {
#line 531
  rooms_found = (short)0;
#line 534
  did_this = (char)0;
#line 536
  i = (short)0;
  {
#line 536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 536
    if (! ((int )i < 10)) {
#line 536
      goto while_break;
    }
    {
#line 537
    tmp = get_rand(0, 3);
#line 537
    srow = (short )tmp;
#line 538
    tmp___0 = get_rand(0, 3);
#line 538
    scol = (short )tmp___0;
#line 539
    t = offsets[srow];
#line 540
    offsets[srow] = offsets[scol];
#line 541
    offsets[scol] = t;
#line 536
    i = (short )((int )i + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  i = (short)0;
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! ((int )i < 4)) {
#line 543
      goto while_break___0;
    }
#line 545
    target_room = (short )(rn + (int )offsets[i]);
#line 547
    if ((int )target_room < 0) {
#line 550
      goto __Cont;
    } else
#line 547
    if ((int )target_room >= 9) {
#line 550
      goto __Cont;
    } else {
      {
#line 547
      tmp___1 = same_row(rn, (int )target_room);
      }
#line 547
      if (tmp___1) {
#line 547
        goto _L;
      } else {
        {
#line 547
        tmp___2 = same_col(rn, (int )target_room);
        }
#line 547
        if (tmp___2) {
          _L: /* CIL Label */ 
#line 547
          if (! ((int )rooms[target_room].is_room & 6)) {
#line 550
            goto __Cont;
          }
        } else {
#line 550
          goto __Cont;
        }
      }
    }
    {
#line 552
    tmp___3 = same_row(rn, (int )target_room);
    }
#line 552
    if (tmp___3) {
#line 553
      if ((int )rooms[rn].left_col < (int )rooms[target_room].left_col) {
#line 553
        tunnel_dir = (short)2;
      } else {
#line 553
        tunnel_dir = (short)6;
      }
    } else
#line 556
    if ((int )rooms[rn].top_row < (int )rooms[target_room].top_row) {
#line 556
      tunnel_dir = (short)4;
    } else {
#line 556
      tunnel_dir = (short)0;
    }
#line 559
    door_dir = (short )(((int )tunnel_dir + 4) % 8);
#line 560
    if ((int )rooms[target_room].doors[(int )door_dir / 2].oth_room != -1) {
#line 561
      goto __Cont;
    }
#line 563
    if (! do_rec_de) {
#line 565
      srow = (short )(((int )rooms[rn].top_row + (int )rooms[rn].bottom_row) / 2);
#line 566
      scol = (short )(((int )rooms[rn].left_col + (int )rooms[rn].right_col) / 2);
    } else
#line 563
    if (did_this) {
#line 565
      srow = (short )(((int )rooms[rn].top_row + (int )rooms[rn].bottom_row) / 2);
#line 566
      scol = (short )(((int )rooms[rn].left_col + (int )rooms[rn].right_col) / 2);
    } else {
      {
#line 563
      tmp___4 = mask_room((short )rn, & srow, & scol, (unsigned short)128);
      }
#line 563
      if (! tmp___4) {
#line 565
        srow = (short )(((int )rooms[rn].top_row + (int )rooms[rn].bottom_row) / 2);
#line 566
        scol = (short )(((int )rooms[rn].left_col + (int )rooms[rn].right_col) / 2);
      }
    }
    {
#line 568
    put_door(& rooms[target_room], door_dir, & drow, & dcol);
#line 569
    rooms_found = (short )((int )rooms_found + 1);
#line 570
    draw_simple_passage(srow, scol, drow, dcol, tunnel_dir);
#line 571
    rooms[rn].is_room = (unsigned short)8;
#line 572
    dungeon[srow][scol] = (unsigned short)128;
    }
#line 574
    if ((int )i < 3) {
#line 574
      if (! did_this) {
        {
#line 575
        did_this = (char)1;
#line 576
        tmp___5 = coin_toss();
        }
#line 576
        if (tmp___5) {
#line 577
          goto __Cont;
        }
      }
    }
#line 580
    if ((int )rooms_found < 2) {
#line 580
      if (do_rec_de) {
        {
#line 581
        recursive_deadend((short )rn, (short const   *)(offsets), srow, scol);
        }
      }
    }
#line 583
    goto while_break___0;
    __Cont: /* CIL Label */ 
#line 543
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 585
  return;
}
}
#line 587 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void recursive_deadend(short rn , short const   *offsets___0 , short srow , short scol ) 
{ 
  short i ;
  short de ;
  short drow ;
  short dcol ;
  short tunnel_dir ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 596
  rooms[rn].is_room = (unsigned short)8;
#line 597
  dungeon[srow][scol] = (unsigned short)128;
#line 599
  i = (short)0;
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
#line 599
    if (! ((int )i < 4)) {
#line 599
      goto while_break;
    }
#line 600
    de = (short )((int )rn + (int )*(offsets___0 + i));
#line 601
    if ((int )de < 0) {
#line 603
      goto __Cont;
    } else
#line 601
    if ((int )de >= 9) {
#line 603
      goto __Cont;
    } else {
      {
#line 601
      tmp = same_row((int )rn, (int )de);
      }
#line 601
      if (! tmp) {
        {
#line 601
        tmp___0 = same_col((int )rn, (int )de);
        }
#line 601
        if (! tmp___0) {
#line 603
          goto __Cont;
        }
      }
    }
#line 605
    if (! ((int )rooms[de].is_room & 1)) {
#line 606
      goto __Cont;
    }
    {
#line 608
    drow = (short )(((int )rooms[de].top_row + (int )rooms[de].bottom_row) / 2);
#line 609
    dcol = (short )(((int )rooms[de].left_col + (int )rooms[de].right_col) / 2);
#line 610
    tmp___1 = same_row((int )rn, (int )de);
    }
#line 610
    if (tmp___1) {
#line 611
      if ((int )rooms[rn].left_col < (int )rooms[de].left_col) {
#line 611
        tunnel_dir = (short)2;
      } else {
#line 611
        tunnel_dir = (short)6;
      }
    } else
#line 614
    if ((int )rooms[rn].top_row < (int )rooms[de].top_row) {
#line 614
      tunnel_dir = (short)4;
    } else {
#line 614
      tunnel_dir = (short)0;
    }
    {
#line 617
    draw_simple_passage(srow, scol, drow, dcol, tunnel_dir);
#line 618
    r_de = de;
#line 619
    recursive_deadend(de, offsets___0, drow, dcol);
    }
    __Cont: /* CIL Label */ 
#line 599
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return;
}
}
#line 623 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
char mask_room(short rn , short *row___0 , short *col___0 , unsigned short mask ) 
{ 
  short i ;
  short j ;

  {
#line 631
  i = rooms[rn].top_row;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! ((int )i <= (int )rooms[rn].bottom_row)) {
#line 631
      goto while_break;
    }
#line 632
    j = rooms[rn].left_col;
    {
#line 632
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 632
      if (! ((int )j <= (int )rooms[rn].right_col)) {
#line 632
        goto while_break___0;
      }
#line 633
      if ((int )dungeon[i][j] & (int )mask) {
#line 634
        *row___0 = i;
#line 635
        *col___0 = j;
#line 636
        return ((char)1);
      }
#line 632
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 631
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  return ((char)0);
}
}
#line 643 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void make_maze(short r , short c___0 , short tr , short br , short lc , short rc ) 
{ 
  char dirs[4] ;
  short i ;
  short t ;
  short t1 ;
  short t2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 650
  dirs[0] = (char)0;
#line 651
  dirs[1] = (char)4;
#line 652
  dirs[2] = (char)6;
#line 653
  dirs[3] = (char)2;
#line 655
  dungeon[r][c___0] = (unsigned short)128;
#line 657
  tmp___1 = rand_percent(20);
  }
#line 657
  if (tmp___1) {
#line 658
    i = (short)0;
    {
#line 658
    while (1) {
      while_continue: /* CIL Label */ ;
#line 658
      if (! ((int )i < 10)) {
#line 658
        goto while_break;
      }
      {
#line 661
      tmp = get_rand(0, 3);
#line 661
      t1 = (short )tmp;
#line 662
      tmp___0 = get_rand(0, 3);
#line 662
      t2 = (short )tmp___0;
#line 664
      t = (short )dirs[t1];
#line 664
      dirs[t1] = dirs[t2];
#line 664
      dirs[t2] = (char )t;
#line 658
      i = (short )((int )i + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 667
  i = (short)0;
  {
#line 667
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 667
    if (! ((int )i < 4)) {
#line 667
      goto while_break___0;
    }
    {
#line 669
    if ((int )dirs[i] == 0) {
#line 669
      goto case_0;
    }
#line 678
    if ((int )dirs[i] == 4) {
#line 678
      goto case_4;
    }
#line 687
    if ((int )dirs[i] == 6) {
#line 687
      goto case_6;
    }
#line 696
    if ((int )dirs[i] == 2) {
#line 696
      goto case_2;
    }
#line 668
    goto switch_break;
    case_0: /* CIL Label */ 
#line 670
    if ((int )r - 1 >= (int )tr) {
#line 670
      if ((int )dungeon[(int )r - 1][c___0] != 128) {
#line 670
        if ((int )dungeon[(int )r - 1][(int )c___0 - 1] != 128) {
#line 670
          if ((int )dungeon[(int )r - 1][(int )c___0 + 1] != 128) {
#line 670
            if ((int )dungeon[(int )r - 2][c___0] != 128) {
              {
#line 675
              make_maze((short )((int )r - 1), c___0, tr, br, lc, rc);
              }
            }
          }
        }
      }
    }
#line 677
    goto switch_break;
    case_4: /* CIL Label */ 
#line 679
    if ((int )r + 1 <= (int )br) {
#line 679
      if ((int )dungeon[(int )r + 1][c___0] != 128) {
#line 679
        if ((int )dungeon[(int )r + 1][(int )c___0 - 1] != 128) {
#line 679
          if ((int )dungeon[(int )r + 1][(int )c___0 + 1] != 128) {
#line 679
            if ((int )dungeon[(int )r + 2][c___0] != 128) {
              {
#line 684
              make_maze((short )((int )r + 1), c___0, tr, br, lc, rc);
              }
            }
          }
        }
      }
    }
#line 686
    goto switch_break;
    case_6: /* CIL Label */ 
#line 688
    if ((int )c___0 - 1 >= (int )lc) {
#line 688
      if ((int )dungeon[r][(int )c___0 - 1] != 128) {
#line 688
        if ((int )dungeon[(int )r - 1][(int )c___0 - 1] != 128) {
#line 688
          if ((int )dungeon[(int )r + 1][(int )c___0 - 1] != 128) {
#line 688
            if ((int )dungeon[r][(int )c___0 - 2] != 128) {
              {
#line 693
              make_maze(r, (short )((int )c___0 - 1), tr, br, lc, rc);
              }
            }
          }
        }
      }
    }
#line 695
    goto switch_break;
    case_2: /* CIL Label */ 
#line 697
    if ((int )c___0 + 1 <= (int )rc) {
#line 697
      if ((int )dungeon[r][(int )c___0 + 1] != 128) {
#line 697
        if ((int )dungeon[(int )r - 1][(int )c___0 + 1] != 128) {
#line 697
          if ((int )dungeon[(int )r + 1][(int )c___0 + 1] != 128) {
#line 697
            if ((int )dungeon[r][(int )c___0 + 2] != 128) {
              {
#line 702
              make_maze(r, (short )((int )c___0 + 1), tr, br, lc, rc);
              }
            }
          }
        }
      }
    }
#line 704
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 667
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 707
  return;
}
}
#line 709 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void hide_boxed_passage(short row1 , short col1 , short row2 , short col2 , short n___0 ) 
{ 
  short i ;
  short j ;
  short t ;
  short row___0 ;
  short col___0 ;
  short row_cut ;
  short col_cut ;
  short h ;
  short w ;
  int tmp ;
  int tmp___0 ;

  {
#line 717
  if ((int )cur_level > 2) {
#line 718
    if ((int )row1 > (int )row2) {
#line 719
      t = row1;
#line 719
      row1 = row2;
#line 719
      row2 = t;
    }
#line 721
    if ((int )col1 > (int )col2) {
#line 722
      t = col1;
#line 722
      col1 = col2;
#line 722
      col2 = t;
    }
#line 724
    h = (short )((int )row2 - (int )row1);
#line 725
    w = (short )((int )col2 - (int )col1);
#line 727
    if ((int )w >= 5) {
#line 727
      goto _L;
    } else
#line 727
    if ((int )h >= 5) {
      _L: /* CIL Label */ 
#line 728
      if ((int )h >= 2) {
#line 728
        row_cut = (short)1;
      } else {
#line 728
        row_cut = (short)0;
      }
#line 729
      if ((int )w >= 2) {
#line 729
        col_cut = (short)1;
      } else {
#line 729
        col_cut = (short)0;
      }
#line 731
      i = (short)0;
      {
#line 731
      while (1) {
        while_continue: /* CIL Label */ ;
#line 731
        if (! ((int )i < (int )n___0)) {
#line 731
          goto while_break;
        }
#line 732
        j = (short)0;
        {
#line 732
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 732
          if (! ((int )j < 10)) {
#line 732
            goto while_break___0;
          }
          {
#line 733
          tmp = get_rand((int )row1 + (int )row_cut, (int )row2 - (int )row_cut);
#line 733
          row___0 = (short )tmp;
#line 734
          tmp___0 = get_rand((int )col1 + (int )col_cut, (int )col2 - (int )col_cut);
#line 734
          col___0 = (short )tmp___0;
          }
#line 735
          if ((int )dungeon[row___0][col___0] == 128) {
#line 736
            dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 512);
#line 737
            goto while_break___0;
          }
#line 732
          j = (short )((int )j + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
#line 731
        i = (short )((int )i + 1);
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 743
  return;
}
}
#line 745 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void put_player(short nr ) 
{ 
  short rn ;
  short misses ;
  short row___0 ;
  short col___0 ;
  int tmp ;

  {
#line 749
  rn = nr;
#line 752
  misses = (short)0;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if ((int )misses < 2) {
#line 752
      if (! ((int )rn == (int )nr)) {
#line 752
        goto while_break;
      }
    } else {
#line 752
      goto while_break;
    }
    {
#line 753
    gr_row_col(& row___0, & col___0, (unsigned short)197);
#line 754
    rn = get_room_number((int )row___0, (int )col___0);
#line 752
    misses = (short )((int )misses + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  rogue.row = row___0;
#line 757
  rogue.col = col___0;
#line 759
  if ((int )dungeon[rogue.row][rogue.col] & 128) {
#line 760
    cur_room = (short)-3;
  } else {
#line 762
    cur_room = rn;
  }
#line 764
  if ((int )cur_room != -3) {
    {
#line 765
    light_up_room((int )cur_room);
    }
  } else {
    {
#line 767
    light_passage((int )rogue.row, (int )rogue.col);
    }
  }
  {
#line 769
  rn = get_room_number((int )rogue.row, (int )rogue.col);
#line 770
  wake_room(rn, (char)1, rogue.row, rogue.col);
  }
#line 771
  if (new_level_message) {
    {
#line 772
    message(new_level_message, (char)0);
#line 773
    new_level_message = (char const   *)0;
    }
  }
  {
#line 775
  tmp = wmove(stdscr, (int )rogue.row, (int )rogue.col);
  }
#line 775
  if (! (tmp == -1)) {
    {
#line 775
    waddch(stdscr, (chtype const   )rogue.fchar);
    }
  }
#line 776
  return;
}
}
#line 778 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int drop_check(void) 
{ 


  {
#line 781
  if (wizard) {
#line 782
    return (1);
  }
#line 784
  if ((int )dungeon[rogue.row][rogue.col] & 4) {
#line 785
    if (levitate) {
      {
#line 786
      message("you\'re floating in the air!", (char)0);
      }
#line 787
      return (0);
    }
#line 789
    return (1);
  }
  {
#line 791
  message("I see no way down", (char)0);
  }
#line 792
  return (0);
}
}
#line 795 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int check_up(void) 
{ 
  char tmp ;

  {
#line 798
  if (! wizard) {
#line 799
    if (! ((int )dungeon[rogue.row][rogue.col] & 4)) {
      {
#line 800
      message("I see no way up", (char)0);
      }
#line 801
      return (0);
    }
    {
#line 803
    tmp = has_amulet();
    }
#line 803
    if (! tmp) {
      {
#line 804
      message("your way is magically blocked", (char)0);
      }
#line 805
      return (0);
    }
  }
#line 808
  new_level_message = "you feel a wrenching sensation in your gut";
#line 809
  if ((int )cur_level == 1) {
    {
#line 810
    win();
    }
  } else {
#line 812
    cur_level = (short )((int )cur_level - 2);
#line 813
    return (1);
  }
#line 815
  return (0);
}
}
#line 818 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void add_exp(int e , char promotion ) 
{ 
  char mbuf[40] ;
  short new_exp ;
  short i ;
  short hp ;
  int tmp ;
  int tmp___0 ;

  {
#line 827
  rogue.exp_points += (long )e;
#line 829
  if (rogue.exp_points >= (long )level_points[(int )rogue.exp - 1]) {
    {
#line 830
    tmp = get_exp_level(rogue.exp_points);
#line 830
    new_exp = (short )tmp;
    }
#line 831
    if (rogue.exp_points > 10000001L) {
#line 832
      rogue.exp_points = 10000002L;
    }
#line 834
    i = (short )((int )rogue.exp + 1);
    {
#line 834
    while (1) {
      while_continue: /* CIL Label */ ;
#line 834
      if (! ((int )i <= (int )new_exp)) {
#line 834
        goto while_break;
      }
      {
#line 835
      sprintf((char */* __restrict  */)(mbuf), (char const   */* __restrict  */)"welcome to level %d",
              (int )i);
#line 836
      message((char const   *)(mbuf), (char)0);
      }
#line 837
      if (promotion) {
        {
#line 838
        tmp___0 = hp_raise();
#line 838
        hp = (short )tmp___0;
#line 839
        rogue.hp_current = (short )((int )rogue.hp_current + (int )hp);
#line 840
        rogue.hp_max = (short )((int )rogue.hp_max + (int )hp);
        }
      }
      {
#line 842
      rogue.exp = i;
#line 843
      print_stats(36);
#line 834
      i = (short )((int )i + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 846
    print_stats(32);
    }
  }
#line 848
  return;
}
}
#line 850 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int get_exp_level(long e ) 
{ 
  short i ;

  {
#line 856
  i = (short)0;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! ((int )i < 20)) {
#line 856
      goto while_break;
    }
#line 857
    if (level_points[i] > (long const   )e) {
#line 858
      goto while_break;
    }
#line 856
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 861
  return ((int )i + 1);
}
}
#line 864 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
int hp_raise(void) 
{ 
  int hp ;
  int tmp ;

  {
#line 869
  if (wizard) {
#line 869
    hp = 10;
  } else {
    {
#line 869
    tmp = get_rand(3, 10);
#line 869
    hp = tmp;
    }
  }
#line 870
  return (hp);
}
}
#line 873 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void show_average_hp(void) 
{ 
  char mbuf[80] ;
  float real_average ;
  float effective_average ;

  {
#line 880
  if ((int )rogue.exp == 1) {
#line 881
    effective_average = (float )0.00;
#line 881
    real_average = effective_average;
  } else {
#line 883
    real_average = (float )((((int )rogue.hp_max - (int )extra_hp) - 12) + (int )less_hp) / (float )((int )rogue.exp - 1);
#line 885
    effective_average = (float )((int )rogue.hp_max - 12) / (float )((int )rogue.exp - 1);
  }
  {
#line 888
  sprintf((char */* __restrict  */)(mbuf), (char const   */* __restrict  */)"R-Hp: %.2f, E-Hp: %.2f (!: %d, V: %d)",
          (double )real_average, (double )effective_average, (int )extra_hp, (int )less_hp);
#line 890
  message((char const   *)(mbuf), (char)0);
  }
#line 891
  return;
}
}
#line 893 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/level.c"
void mix_random_rooms(void) 
{ 
  short i ;
  short t ;
  short x ;
  short y ;
  int tmp ;
  int tmp___0 ;

  {
#line 899
  i = (short)0;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! ((int )i < 27)) {
#line 899
      goto while_break;
    }
    {
#line 900
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 901
      tmp = get_rand(0, 8);
#line 901
      x = (short )tmp;
#line 902
      tmp___0 = get_rand(0, 8);
#line 902
      y = (short )tmp___0;
      }
#line 900
      if (! ((int )x == (int )y)) {
#line 900
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 904
    t = random_rooms[x];
#line 904
    random_rooms[x] = random_rooms[y];
#line 904
    random_rooms[y] = t;
#line 899
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 906
  return;
}
}
#line 38 "include/string.h"
size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
#line 43 "/home/june/collector/temp/bsdgames-nonfree-2.17/lib/strlcpy.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  register char *d ;
  register char const   *s___0 ;
  register size_t n___0 ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 48
  d = dst;
#line 49
  s___0 = src;
#line 50
  n___0 = siz;
#line 53
  if (n___0 != 0UL) {
#line 53
    n___0 --;
#line 53
    if (n___0 != 0UL) {
      {
#line 54
      while (1) {
        while_continue: /* CIL Label */ ;
#line 55
        tmp = d;
#line 55
        d ++;
#line 55
        tmp___1 = s___0;
#line 55
        s___0 ++;
#line 55
        tmp___0 = (char )*tmp___1;
#line 55
        *tmp = tmp___0;
#line 55
        if ((int )tmp___0 == 0) {
#line 56
          goto while_break;
        }
#line 54
        n___0 --;
#line 54
        if (! (n___0 != 0UL)) {
#line 54
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 61
  if (n___0 == 0UL) {
#line 62
    if (siz != 0UL) {
#line 63
      *d = (char )'\000';
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      tmp___2 = s___0;
#line 64
      s___0 ++;
#line 64
      if (! *tmp___2) {
#line 64
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 68
  return ((size_t )((s___0 - src) - 1L));
}
}
#line 340 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
room rooms[9]  ;
#line 453
object *gr_object(void) ;
#line 529
char get_oth_room(short rn , short *row___0 , short *col___0 ) ;
#line 545
short gr_room(void) ;
#line 598
void md_shell(char const   *shell ) ;
#line 623
void opt_erase(int i ) ;
#line 624
void opt_go(int i ) ;
#line 625
void opt_show(int i ) ;
#line 630
short party_objects(int rn ) ;
#line 721
void visit_rooms(int rn ) ;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
char rooms_visited[9]  ;
#line 63 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
struct option options[7]  = {      {"Show position only at end of run (\"jump\"): ", (char)1, (char **)0, & jump}, 
        {"Follow turnings in passageways (\"passgo\"): ",
      (char)1, (char **)0, & passgo}, 
        {"Don\'t print skull when killed (\"noskull\" or \"notombstone\"): ", (char)1,
      (char **)0, & no_skull}, 
        {"Ask player before saying \'Okay, bye-bye!\' (\"askquit\"): ", (char)1, (char **)0,
      & ask_quit}, 
        {"Name (\"name\"): ", (char)0, & nick_name, (char *)0}, 
        {"Fruit (\"fruit\"): ", (char)0, & fruit, (char *)0}, 
        {"Save file (\"file\"): ", (char)0, & save_file, (char *)0}};
#line 99 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void light_up_room(int rn ) 
{ 
  short i ;
  short j ;
  object *monster ;
  char tmp ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 105
  if (! blind) {
#line 106
    i = rooms[rn].top_row;
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! ((int )i <= (int )rooms[rn].bottom_row)) {
#line 106
        goto while_break;
      }
#line 108
      j = rooms[rn].left_col;
      {
#line 108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 108
        if (! ((int )j <= (int )rooms[rn].right_col)) {
#line 108
          goto while_break___0;
        }
#line 110
        if ((int )dungeon[i][j] & 2) {
          {
#line 113
          monster = object_at(& level_monsters, i, j);
          }
#line 113
          if ((unsigned long )monster != (unsigned long )((void *)0)) {
            {
#line 115
            dungeon[monster->row][monster->col] = (unsigned short )((int )dungeon[monster->row][monster->col] & -3);
#line 116
            tmp = get_dungeon_char(monster->row, monster->col);
#line 116
            monster->d_enchant = (short )tmp;
#line 118
            dungeon[monster->row][monster->col] = (unsigned short )((int )dungeon[monster->row][monster->col] | 2);
            }
          }
        }
        {
#line 121
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 121
        if (! (tmp___1 == -1)) {
          {
#line 121
          tmp___0 = get_dungeon_char(i, j);
#line 121
          waddch(stdscr, (chtype const   )tmp___0);
          }
        }
#line 108
        j = (short )((int )j + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
#line 106
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 124
    tmp___2 = wmove(stdscr, (int )rogue.row, (int )rogue.col);
    }
#line 124
    if (! (tmp___2 == -1)) {
      {
#line 124
      waddch(stdscr, (chtype const   )rogue.fchar);
      }
    }
  }
#line 126
  return;
}
}
#line 128 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void light_passage(int row___0 , int col___0 ) 
{ 
  short i ;
  short j ;
  short i_end ;
  short j_end ;
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;

  {
#line 134
  if (blind) {
#line 135
    return;
  }
#line 137
  if (row___0 < 22) {
#line 137
    i_end = (short)1;
  } else {
#line 137
    i_end = (short)0;
  }
#line 138
  if (col___0 < 79) {
#line 138
    j_end = (short)1;
  } else {
#line 138
    j_end = (short)0;
  }
#line 140
  if (row___0 > 1) {
#line 140
    i = (short)-1;
  } else {
#line 140
    i = (short)0;
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((int )i <= (int )i_end)) {
#line 140
      goto while_break;
    }
#line 141
    if (col___0 > 0) {
#line 141
      j = (short)-1;
    } else {
#line 141
      j = (short)0;
    }
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      if (! ((int )j <= (int )j_end)) {
#line 141
        goto while_break___0;
      }
      {
#line 142
      tmp___1 = can_move(row___0, col___0, row___0 + (int )i, col___0 + (int )j);
      }
#line 142
      if (tmp___1) {
        {
#line 143
        tmp___0 = wmove(stdscr, row___0 + (int )i, col___0 + (int )j);
        }
#line 143
        if (! (tmp___0 == -1)) {
          {
#line 143
          tmp = get_dungeon_char((short )(row___0 + (int )i), (short )(col___0 + (int )j));
#line 143
          waddch(stdscr, (chtype const   )tmp);
          }
        }
      }
#line 141
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 149 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void darken_room(short rn ) 
{ 
  short i ;
  short j ;
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;

  {
#line 155
  i = (short )((int )rooms[rn].top_row + 1);
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((int )i < (int )rooms[rn].bottom_row)) {
#line 155
      goto while_break;
    }
#line 156
    j = (short )((int )rooms[rn].left_col + 1);
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 156
      if (! ((int )j < (int )rooms[rn].right_col)) {
#line 156
        goto while_break___0;
      }
#line 157
      if (blind) {
        {
#line 158
        tmp = wmove(stdscr, (int )i, (int )j);
        }
#line 158
        if (! (tmp == -1)) {
          {
#line 158
          waddch(stdscr, (chtype const   )' ');
          }
        }
      } else
#line 160
      if (! ((int )dungeon[i][j] & 5)) {
#line 160
        if (detect_monster) {
#line 160
          if (! ((int )dungeon[i][j] & 2)) {
#line 160
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 162
          tmp___1 = imitating((int )i, (int )j);
          }
#line 162
          if (! tmp___1) {
            {
#line 163
            tmp___0 = wmove(stdscr, (int )i, (int )j);
            }
#line 163
            if (! (tmp___0 == -1)) {
              {
#line 163
              waddch(stdscr, (chtype const   )' ');
              }
            }
          }
#line 165
          if ((int )dungeon[i][j] & 256) {
#line 165
            if (! ((int )dungeon[i][j] & 512)) {
              {
#line 166
              tmp___2 = wmove(stdscr, (int )i, (int )j);
              }
#line 166
              if (! (tmp___2 == -1)) {
                {
#line 166
                waddch(stdscr, (chtype const   )'^');
                }
              }
            }
          }
        }
      }
#line 156
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 155
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 174 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
char get_dungeon_char(short row___0 , short col___0 ) 
{ 
  unsigned short mask ;
  char tmp ;
  object *obj ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 178
  mask = dungeon[row___0][col___0];
#line 180
  if ((int )mask & 2) {
    {
#line 181
    tmp = gmc_row_col((int )row___0, (int )col___0);
    }
#line 181
    return (tmp);
  }
#line 183
  if ((int )mask & 1) {
    {
#line 186
    obj = object_at(& level_objects, row___0, col___0);
#line 187
    tmp___0 = get_mask_char(obj->what_is);
    }
#line 187
    return (tmp___0);
  }
#line 189
  if ((int )mask & 252) {
#line 190
    if ((int )mask & 132) {
#line 190
      if (! ((int )mask & 512)) {
#line 191
        if ((int )mask & 4) {
#line 191
          tmp___1 = '%';
        } else {
#line 191
          tmp___1 = '#';
        }
#line 191
        return ((char )tmp___1);
      }
    }
#line 193
    if ((int )mask & 8) {
#line 194
      return ((char )'-');
    }
#line 196
    if ((int )mask & 16) {
#line 197
      return ((char )'|');
    }
#line 199
    if ((int )mask & 64) {
#line 200
      if ((int )mask & 256) {
#line 201
        if (! ((int )dungeon[row___0][col___0] & 512)) {
#line 202
          return ((char )'^');
        }
      }
#line 205
      return ((char )'.');
    }
#line 207
    if ((int )mask & 32) {
#line 208
      if ((int )mask & 512) {
#line 209
        if ((int )col___0 > 0) {
#line 209
          if ((int )dungeon[row___0][(int )col___0 - 1] & 8) {
#line 211
            return ((char )'-');
          } else {
#line 209
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 209
        if ((int )col___0 < 79) {
#line 209
          if ((int )dungeon[row___0][(int )col___0 + 1] & 8) {
#line 211
            return ((char )'-');
          } else {
#line 213
            return ((char )'|');
          }
        } else {
#line 213
          return ((char )'|');
        }
      } else {
#line 216
        return ((char )'+');
      }
    }
  }
#line 220
  return ((char )' ');
}
}
#line 223 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
char get_mask_char(unsigned short mask ) 
{ 


  {
  {
#line 228
  if ((int )mask == 4) {
#line 228
    goto case_4;
  }
#line 230
  if ((int )mask == 8) {
#line 230
    goto case_8;
  }
#line 232
  if ((int )mask == 16) {
#line 232
    goto case_16;
  }
#line 234
  if ((int )mask == 32) {
#line 234
    goto case_32;
  }
#line 236
  if ((int )mask == 64) {
#line 236
    goto case_64;
  }
#line 238
  if ((int )mask == 1) {
#line 238
    goto case_1;
  }
#line 240
  if ((int )mask == 2) {
#line 240
    goto case_2;
  }
#line 242
  if ((int )mask == 128) {
#line 242
    goto case_128;
  }
#line 244
  if ((int )mask == 256) {
#line 244
    goto case_256;
  }
#line 246
  goto switch_default;
  case_4: /* CIL Label */ 
#line 229
  return ((char )'?');
  case_8: /* CIL Label */ 
#line 231
  return ((char )'!');
  case_16: /* CIL Label */ 
#line 233
  return ((char )'*');
  case_32: /* CIL Label */ 
#line 235
  return ((char )':');
  case_64: /* CIL Label */ 
#line 237
  return ((char )'/');
  case_1: /* CIL Label */ 
#line 239
  return ((char )']');
  case_2: /* CIL Label */ 
#line 241
  return ((char )')');
  case_128: /* CIL Label */ 
#line 243
  return ((char )'=');
  case_256: /* CIL Label */ 
#line 245
  return ((char )',');
  switch_default: /* CIL Label */ 
#line 247
  return ((char )'~');
  switch_break: /* CIL Label */ ;
  }
}
}
#line 251 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void gr_row_col(short *row___0 , short *col___0 , unsigned short mask ) 
{ 
  short rn ;
  short r ;
  short c___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 260
    tmp = get_rand(1, 22);
#line 260
    r = (short )tmp;
#line 261
    tmp___0 = get_rand(0, 79);
#line 261
    c___0 = (short )tmp___0;
#line 262
    rn = get_room_number((int )r, (int )c___0);
    }
#line 259
    if (! ((int )rn == -1)) {
#line 259
      if (! (! ((int )dungeon[r][c___0] & (int )mask))) {
#line 259
        if (! ((int )dungeon[r][c___0] & ~ ((int )mask))) {
#line 259
          if (! (! ((int )rooms[rn].is_room & 6))) {
#line 259
            if ((int )r == (int )rogue.row) {
#line 259
              if (! ((int )c___0 == (int )rogue.col)) {
#line 259
                goto while_break;
              }
            } else {
#line 259
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  *row___0 = r;
#line 270
  *col___0 = c___0;
#line 271
  return;
}
}
#line 273 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
short gr_room(void) 
{ 
  short i ;
  int tmp ;

  {
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 279
    tmp = get_rand(0, 8);
#line 279
    i = (short )tmp;
    }
#line 278
    if (! (! ((int )rooms[i].is_room & 6))) {
#line 278
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (i);
}
}
#line 285 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
short party_objects(int rn ) 
{ 
  short i ;
  short j ;
  short nf ;
  object *obj ;
  short n___0 ;
  short N ;
  short row___0 ;
  short col___0 ;
  char found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 289
  nf = (short)0;
#line 294
  col___0 = (short)0;
#line 294
  row___0 = col___0;
#line 295
  N = (short )((((int )rooms[rn].bottom_row - (int )rooms[rn].top_row) - 1) * (((int )rooms[rn].right_col - (int )rooms[rn].left_col) - 1));
#line 297
  tmp = get_rand(5, 10);
#line 297
  n___0 = (short )tmp;
  }
#line 298
  if ((int )n___0 > (int )N) {
#line 299
    n___0 = (short )((int )N - 2);
  }
#line 301
  i = (short)0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((int )i < (int )n___0)) {
#line 301
      goto while_break;
    }
#line 302
    found = (char)0;
#line 302
    j = (short )found;
    {
#line 302
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 302
      if (! found) {
#line 302
        if (! ((int )j < 250)) {
#line 302
          goto while_break___0;
        }
      } else {
#line 302
        goto while_break___0;
      }
      {
#line 303
      tmp___0 = get_rand((int )rooms[rn].top_row + 1, (int )rooms[rn].bottom_row - 1);
#line 303
      row___0 = (short )tmp___0;
#line 305
      tmp___1 = get_rand((int )rooms[rn].left_col + 1, (int )rooms[rn].right_col - 1);
#line 305
      col___0 = (short )tmp___1;
      }
#line 307
      if ((int )dungeon[row___0][col___0] == 64) {
#line 308
        found = (char)1;
      } else
#line 307
      if ((int )dungeon[row___0][col___0] == 128) {
#line 308
        found = (char)1;
      }
#line 302
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 311
    if (found) {
      {
#line 312
      obj = gr_object();
#line 313
      place_at(obj, (int )row___0, (int )col___0);
#line 314
      nf = (short )((int )nf + 1);
      }
    }
#line 301
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return (nf);
}
}
#line 320 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
short get_room_number(int row___0 , int col___0 ) 
{ 
  short i ;

  {
#line 326
  i = (short)0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! ((int )i < 9)) {
#line 326
      goto while_break;
    }
#line 327
    if (row___0 >= (int )rooms[i].top_row) {
#line 327
      if (row___0 <= (int )rooms[i].bottom_row) {
#line 327
        if (col___0 >= (int )rooms[i].left_col) {
#line 327
          if (col___0 <= (int )rooms[i].right_col) {
#line 329
            return (i);
          }
        }
      }
    }
#line 326
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return ((short)-1);
}
}
#line 335 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
char is_all_connected(void) 
{ 
  short i ;
  short starting_room ;

  {
#line 340
  starting_room = (short)0;
#line 341
  i = (short)0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! ((int )i < 9)) {
#line 341
      goto while_break;
    }
#line 342
    rooms_visited[i] = (char)0;
#line 343
    if ((int )rooms[i].is_room & 6) {
#line 344
      starting_room = i;
    }
#line 341
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  visit_rooms((int )starting_room);
#line 350
  i = (short)0;
  }
  {
#line 350
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 350
    if (! ((int )i < 9)) {
#line 350
      goto while_break___0;
    }
#line 351
    if ((int )rooms[i].is_room & 6) {
#line 351
      if (! rooms_visited[i]) {
#line 352
        return ((char)0);
      }
    }
#line 350
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 355
  return ((char)1);
}
}
#line 358 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void visit_rooms(int rn ) 
{ 
  short i ;
  short oth_rn ;

  {
#line 365
  rooms_visited[rn] = (char)1;
#line 367
  i = (short)0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((int )i < 4)) {
#line 367
      goto while_break;
    }
#line 368
    oth_rn = rooms[rn].doors[i].oth_room;
#line 369
    if ((int )oth_rn >= 0) {
#line 369
      if (! rooms_visited[oth_rn]) {
        {
#line 370
        visit_rooms((int )oth_rn);
        }
      }
    }
#line 367
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return;
}
}
#line 375 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void draw_magic_map(void) 
{ 
  short i ;
  short j ;
  short ch ;
  short och ;
  unsigned short mask ;
  unsigned short s___0 ;
  object *monster ;
  chtype tmp___0 ;
  int tmp___1 ;

  {
#line 379
  mask = (unsigned short)446;
#line 383
  i = (short)0;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! ((int )i < 24)) {
#line 383
      goto while_break;
    }
#line 384
    j = (short)0;
    {
#line 384
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 384
      if (! ((int )j < 80)) {
#line 384
        goto while_break___0;
      }
#line 385
      s___0 = dungeon[i][j];
#line 386
      if ((int )s___0 & (int )mask) {
        {
#line 387
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 387
        if (tmp___1 == -1) {
#line 387
          ch = (short )((chtype )-1);
        } else {
          {
#line 387
          tmp___0 = winch(stdscr);
#line 387
          ch = (short )tmp___0;
          }
        }
#line 387
        if ((int )ch == 32) {
#line 387
          goto _L;
        } else
#line 387
        if ((int )ch >= 65) {
#line 387
          if ((int )ch <= 90) {
#line 387
            goto _L;
          } else {
#line 387
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 387
        if ((int )s___0 & 768) {
          _L: /* CIL Label */ 
#line 389
          och = ch;
#line 390
          dungeon[i][j] = (unsigned short )((int )dungeon[i][j] & -513);
#line 391
          if ((int )s___0 & 8) {
#line 392
            ch = (short )'-';
          } else
#line 393
          if ((int )s___0 & 16) {
#line 394
            ch = (short )'|';
          } else
#line 395
          if ((int )s___0 & 32) {
#line 396
            ch = (short )'+';
          } else
#line 397
          if ((int )s___0 & 256) {
#line 398
            ch = (short )'^';
          } else
#line 399
          if ((int )s___0 & 4) {
#line 400
            ch = (short )'%';
          } else
#line 401
          if ((int )s___0 & 128) {
#line 402
            ch = (short )'#';
          } else {
#line 404
            goto __Cont;
          }
#line 406
          if (! ((int )s___0 & 2)) {
            {
#line 407
            waddch(stdscr, (chtype const   )ch);
            }
          } else
#line 406
          if ((int )och == 32) {
            {
#line 407
            waddch(stdscr, (chtype const   )ch);
            }
          }
#line 409
          if ((int )s___0 & 2) {
            {
#line 412
            monster = object_at(& level_monsters, i, j);
            }
#line 412
            if ((unsigned long )monster != (unsigned long )((void *)0)) {
#line 415
              monster->d_enchant = ch;
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 384
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return;
}
}
#line 425 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void dr_course(object *monster , char entering , short row___0 , short col___0 ) 
{ 
  short i ;
  short j ;
  short k ;
  short rn ;
  short r ;
  short rr ;
  char tmp ;
  int tmp___0 ;
  char tmp___1 ;

  {
  {
#line 434
  monster->row = row___0;
#line 435
  monster->col = col___0;
#line 437
  tmp = mon_sees((object const   *)monster, (int )rogue.row, (int )rogue.col);
  }
#line 437
  if (tmp) {
#line 438
    monster->trow = (short)-1;
#line 439
    return;
  }
  {
#line 441
  rn = get_room_number((int )row___0, (int )col___0);
  }
#line 443
  if (entering) {
    {
#line 445
    tmp___0 = get_rand(0, 8);
#line 445
    r = (short )tmp___0;
#line 446
    i = (short)0;
    }
    {
#line 446
    while (1) {
      while_continue: /* CIL Label */ ;
#line 446
      if (! ((int )i < 9)) {
#line 446
        goto while_break;
      }
#line 447
      rr = (short )(((int )r + (int )i) % 9);
#line 448
      if (! ((int )rooms[rr].is_room & 6)) {
#line 449
        goto __Cont;
      } else
#line 448
      if ((int )rr == (int )rn) {
#line 449
        goto __Cont;
      }
#line 451
      k = (short)0;
      {
#line 451
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 451
        if (! ((int )k < 4)) {
#line 451
          goto while_break___0;
        }
#line 452
        if ((int )rooms[rr].doors[k].oth_room == (int )rn) {
#line 453
          monster->trow = rooms[rr].doors[k].oth_row;
#line 454
          monster->tcol = rooms[rr].doors[k].oth_col;
#line 455
          if ((int )monster->trow == (int )row___0) {
#line 455
            if ((int )monster->tcol == (int )col___0) {
#line 457
              goto __Cont___0;
            }
          }
#line 459
          return;
        }
        __Cont___0: /* CIL Label */ 
#line 451
        k = (short )((int )k + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 446
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
#line 464
    i = rooms[rn].top_row;
    {
#line 464
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 464
      if (! ((int )i <= (int )rooms[rn].bottom_row)) {
#line 464
        goto while_break___1;
      }
#line 465
      j = rooms[rn].left_col;
      {
#line 465
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 465
        if (! ((int )j <= (int )rooms[rn].right_col)) {
#line 465
          goto while_break___2;
        }
#line 466
        if ((int )i != (int )monster->row) {
#line 466
          if ((int )j != (int )monster->col) {
#line 466
            if ((int )dungeon[i][j] & 32) {
#line 468
              monster->trow = i;
#line 469
              monster->tcol = j;
#line 470
              return;
            }
          }
        }
#line 465
        j = (short )((int )j + 1);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 464
      i = (short )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 475
    i = (short)0;
    {
#line 475
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 475
      if (! ((int )i < 9)) {
#line 475
        goto while_break___3;
      }
#line 476
      j = (short)0;
      {
#line 476
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 476
        if (! ((int )j < 4)) {
#line 476
          goto while_break___4;
        }
#line 477
        if ((int )rooms[i].doors[j].oth_room == (int )rn) {
#line 478
          k = (short)0;
          {
#line 478
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 478
            if (! ((int )k < 4)) {
#line 478
              goto while_break___5;
            }
#line 479
            if ((int )rooms[rn].doors[k].oth_room == (int )i) {
#line 480
              monster->trow = rooms[rn].doors[k].oth_row;
#line 481
              monster->tcol = rooms[rn].doors[k].oth_col;
#line 482
              return;
            }
#line 478
            k = (short )((int )k + 1);
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 476
        j = (short )((int )j + 1);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 475
      i = (short )((int )i + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 489
    monster->trow = (short)-1;
  } else {
    {
#line 491
    tmp___1 = get_oth_room(rn, & row___0, & col___0);
    }
#line 491
    if (tmp___1) {
#line 494
      monster->trow = row___0;
#line 495
      monster->tcol = col___0;
    } else {
#line 492
      monster->trow = (short)-1;
    }
  }
#line 498
  return;
}
}
#line 500 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
char get_oth_room(short rn , short *row___0 , short *col___0 ) 
{ 
  short d ;

  {
#line 504
  d = (short)-1;
#line 506
  if ((int )*row___0 == (int )rooms[rn].top_row) {
#line 507
    d = (short)0;
  } else
#line 508
  if ((int )*row___0 == (int )rooms[rn].bottom_row) {
#line 509
    d = (short)2;
  } else
#line 510
  if ((int )*col___0 == (int )rooms[rn].left_col) {
#line 511
    d = (short)3;
  } else
#line 512
  if ((int )*col___0 == (int )rooms[rn].right_col) {
#line 513
    d = (short)1;
  }
#line 515
  if ((int )d != -1) {
#line 515
    if ((int )rooms[rn].doors[d].oth_room >= 0) {
#line 516
      *row___0 = rooms[rn].doors[d].oth_row;
#line 517
      *col___0 = rooms[rn].doors[d].oth_col;
#line 518
      return ((char)1);
    }
  }
#line 520
  return ((char)0);
}
}
#line 523 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void edit_opts(void) 
{ 
  char save[8][80] ;
  short i ;
  short j ;
  short ch ;
  char done ;
  char buf[42] ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  short tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 529
  done = (char)0;
#line 532
  i = (short)0;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! ((int )i < 8)) {
#line 532
      goto while_break;
    }
#line 533
    j = (short)0;
    {
#line 533
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 533
      if (! ((int )j < 80)) {
#line 533
        goto while_break___0;
      }
      {
#line 534
      tmp___1 = wmove(stdscr, (int )i, (int )j);
      }
#line 534
      if (tmp___1 == -1) {
#line 534
        save[i][j] = (char )((chtype )-1);
      } else {
        {
#line 534
        tmp___0 = winch(stdscr);
#line 534
        save[i][j] = (char )tmp___0;
        }
      }
#line 533
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 536
    if ((int )i < 7) {
      {
#line 537
      opt_show((int )i);
      }
    }
#line 532
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  opt_go(0);
#line 541
  i = (short)0;
  }
  {
#line 543
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 543
    if (! (! done)) {
#line 543
      goto while_break___1;
    }
    {
#line 544
    wrefresh(stdscr);
#line 545
    tmp___2 = rgetchar();
#line 545
    ch = (short )tmp___2;
    }
    CH: 
    {
#line 548
    if ((int )ch == 27) {
#line 548
      goto case_27;
    }
#line 552
    if ((int )ch == 13) {
#line 552
      goto case_13;
    }
#line 552
    if ((int )ch == 10) {
#line 552
      goto case_13;
    }
#line 563
    if ((int )ch == 45) {
#line 563
      goto case_45;
    }
#line 573
    if ((int )ch == 70) {
#line 573
      goto case_70;
    }
#line 573
    if ((int )ch == 102) {
#line 573
      goto case_70;
    }
#line 573
    if ((int )ch == 84) {
#line 573
      goto case_70;
    }
#line 573
    if ((int )ch == 116) {
#line 573
      goto case_70;
    }
#line 580
    goto switch_default;
    case_27: /* CIL Label */ 
#line 549
    done = (char)1;
#line 550
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 553
    if ((int )i == 6) {
      {
#line 554
      tmp___3 = wmove(stdscr, 7, 0);
      }
#line 554
      if (! (tmp___3 == -1)) {
        {
#line 554
        waddnstr(stdscr, press_space, -1);
        }
      }
      {
#line 555
      wrefresh(stdscr);
#line 556
      wait_for_ack();
#line 557
      done = (char)1;
      }
    } else {
      {
#line 559
      i = (short )((int )i + 1);
#line 560
      opt_go((int )i);
      }
    }
#line 562
    goto switch_break;
    case_45: /* CIL Label */ 
#line 564
    if ((int )i > 0) {
      {
#line 565
      i = (short )((int )i - 1);
#line 565
      opt_go((int )i);
      }
    } else {
      {
#line 567
      sound_bell();
      }
    }
#line 569
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 574
    if (options[i].is_bool) {
#line 575
      if ((int )ch == 116) {
#line 575
        *(options[i].bval) = (char)1;
      } else
#line 575
      if ((int )ch == 84) {
#line 575
        *(options[i].bval) = (char)1;
      } else {
#line 575
        *(options[i].bval) = (char)0;
      }
      {
#line 576
      opt_show((int )i);
#line 577
      i = (short )((int )i + 1);
#line 577
      opt_go((int )i);
      }
#line 578
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 581
    if (options[i].is_bool) {
      {
#line 582
      sound_bell();
      }
#line 583
      goto switch_break;
    }
#line 585
    j = (short)0;
#line 586
    if ((int )ch == 8) {
#line 586
      goto _L___1;
    } else
#line 586
    if ((int )ch >= 32) {
#line 586
      if ((int )ch <= 126) {
        _L___1: /* CIL Label */ 
        {
#line 587
        opt_erase((int )i);
        }
        {
#line 588
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 589
          if ((int )ch >= 32) {
#line 589
            if ((int )ch <= 126) {
#line 589
              if ((int )j < 40) {
                {
#line 590
                tmp___4 = j;
#line 590
                j = (short )((int )j + 1);
#line 590
                buf[tmp___4] = (char )ch;
#line 591
                buf[j] = (char )'\000';
#line 592
                waddch(stdscr, (chtype const   )ch);
                }
              } else {
#line 589
                goto _L___0;
              }
            } else {
#line 589
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 593
          if ((int )ch == 8) {
#line 593
            if ((int )j > 0) {
              {
#line 594
              j = (short )((int )j - 1);
#line 594
              buf[j] = (char )'\000';
#line 595
              tmp___5 = strlen(options[i].prompt);
#line 595
              wmove(stdscr, (int )i, (int )((size_t )j + tmp___5));
#line 596
              waddch(stdscr, (chtype const   )' ');
#line 597
              tmp___6 = strlen(options[i].prompt);
#line 597
              wmove(stdscr, (int )i, (int )((size_t )j + tmp___6));
              }
            }
          }
          {
#line 599
          wrefresh(stdscr);
#line 600
          tmp___7 = rgetchar();
#line 600
          ch = (short )tmp___7;
          }
#line 588
          if ((int )ch != 10) {
#line 588
            if ((int )ch != 13) {
#line 588
              if (! ((int )ch != 27)) {
#line 588
                goto while_break___2;
              }
            } else {
#line 588
              goto while_break___2;
            }
          } else {
#line 588
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 602
        if ((int )j != 0) {
          {
#line 603
          strcpy((char */* __restrict  */)*(options[i].strval), (char const   */* __restrict  */)(buf));
          }
        }
        {
#line 605
        opt_show((int )i);
        }
#line 606
        goto CH;
      } else {
        {
#line 608
        sound_bell();
        }
      }
    } else {
      {
#line 608
      sound_bell();
      }
    }
#line 610
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 614
  i = (short)0;
  {
#line 614
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 614
    if (! ((int )i < 8)) {
#line 614
      goto while_break___3;
    }
    {
#line 615
    wmove(stdscr, (int )i, 0);
#line 616
    j = (short)0;
    }
    {
#line 616
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 616
      if (! ((int )j < 80)) {
#line 616
        goto while_break___4;
      }
      {
#line 617
      waddch(stdscr, (chtype const   )save[i][j]);
#line 616
      j = (short )((int )j + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 614
    i = (short )((int )i + 1);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 620
  return;
}
}
#line 622 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void opt_show(int i ) 
{ 
  char const   *s___0 ;
  struct option *opt ;

  {
  {
#line 627
  opt = & options[i];
#line 629
  opt_erase(i);
  }
#line 631
  if (opt->is_bool) {
#line 632
    if (*(opt->bval)) {
#line 632
      s___0 = "True";
    } else {
#line 632
      s___0 = "False";
    }
  } else {
#line 634
    s___0 = (char const   *)*(opt->strval);
  }
  {
#line 636
  waddnstr(stdscr, s___0, -1);
  }
#line 637
  return;
}
}
#line 639 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void opt_erase(int i ) 
{ 
  struct option *opt ;
  int tmp ;

  {
  {
#line 643
  opt = & options[i];
#line 645
  tmp = wmove(stdscr, i, 0);
  }
#line 645
  if (! (tmp == -1)) {
    {
#line 645
    waddnstr(stdscr, opt->prompt, -1);
    }
  }
  {
#line 646
  wclrtoeol(stdscr);
  }
#line 647
  return;
}
}
#line 649 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void opt_go(int i ) 
{ 
  size_t tmp ;

  {
  {
#line 653
  tmp = strlen(options[i].prompt);
#line 653
  wmove(stdscr, i, (int )tmp);
  }
#line 654
  return;
}
}
#line 656 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/room.c"
void do_shell(void) 
{ 
  char const   *sh ;
  char *tmp ;

  {
  {
#line 662
  md_ignore_signals();
#line 663
  tmp = md_getenv("SHELL");
#line 663
  sh = (char const   *)tmp;
  }
#line 663
  if (! sh) {
#line 664
    sh = "/bin/sh";
  }
  {
#line 666
  wmove(stdscr, LINES - 1, 0);
#line 667
  wrefresh(stdscr);
#line 668
  stop_window();
#line 669
  printf((char const   */* __restrict  */)"\nCreating new shell...\n");
#line 670
  md_shell(sh);
#line 671
  start_window();
#line 672
  wrefresh(curscr);
#line 673
  md_heed_signals();
  }
#line 675
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 90 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 588 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char md_df(char const   *fname ) ;
#line 590
void md_gct(struct rogue_time *rt_buf ) ;
#line 591
int md_get_file_id(char const   *fname ) ;
#line 592
void md_gfmt(char const   *fname , struct rogue_time *rt_buf ) ;
#line 596
int md_link_count(char const   *fname ) ;
#line 130 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_slurp(void) 
{ 


  {
  {
#line 133
  tcflush(0, 0);
  }
#line 134
  return;
}
}
#line 152 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_heed_signals(void) 
{ 


  {
  {
#line 155
  signal(2, & onintr);
#line 156
  signal(3, & byebye);
#line 157
  signal(1, & error_save);
  }
#line 158
  return;
}
}
#line 172 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_ignore_signals(void) 
{ 


  {
  {
#line 175
  signal(3, (void (*)(int  ))1);
#line 176
  signal(2, (void (*)(int  ))1);
#line 177
  signal(1, (void (*)(int  ))1);
  }
#line 178
  return;
}
}
#line 189 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
int md_get_file_id(char const   *fname ) 
{ 
  struct stat sbuf ;
  int tmp ;

  {
  {
#line 195
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& sbuf));
  }
#line 195
  if (tmp) {
#line 196
    return (-1);
  }
#line 198
  return ((int )sbuf.st_ino);
}
}
#line 209 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
int md_link_count(char const   *fname ) 
{ 
  struct stat sbuf ;

  {
  {
#line 215
  stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& sbuf));
  }
#line 216
  return ((int )sbuf.st_nlink);
}
}
#line 233 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_gct(struct rogue_time *rt_buf ) 
{ 
  struct tm *t ;
  time_t seconds ;

  {
  {
#line 240
  time(& seconds);
#line 241
  t = localtime((time_t const   *)(& seconds));
#line 243
  rt_buf->year = (short )t->tm_year;
#line 244
  rt_buf->month = (short )(t->tm_mon + 1);
#line 245
  rt_buf->day = (short )t->tm_mday;
#line 246
  rt_buf->hour = (short )t->tm_hour;
#line 247
  rt_buf->minute = (short )t->tm_min;
#line 248
  rt_buf->second = (short )t->tm_sec;
  }
#line 249
  return;
}
}
#line 267 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_gfmt(char const   *fname , struct rogue_time *rt_buf ) 
{ 
  struct stat sbuf ;
  time_t seconds ;
  struct tm *t ;

  {
  {
#line 276
  stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& sbuf));
#line 277
  seconds = sbuf.st_mtim.tv_sec;
#line 278
  t = localtime((time_t const   *)(& seconds));
#line 280
  rt_buf->year = (short )t->tm_year;
#line 281
  rt_buf->month = (short )(t->tm_mon + 1);
#line 282
  rt_buf->day = (short )t->tm_mday;
#line 283
  rt_buf->hour = (short )t->tm_hour;
#line 284
  rt_buf->minute = (short )t->tm_min;
#line 285
  rt_buf->second = (short )t->tm_sec;
  }
#line 286
  return;
}
}
#line 299 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
char md_df(char const   *fname ) 
{ 
  int tmp ;

  {
  {
#line 303
  tmp = unlink(fname);
  }
#line 303
  if (tmp) {
#line 304
    return ((char)0);
  }
#line 306
  return ((char)1);
}
}
#line 318 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
char const   *md_gln(void) 
{ 
  struct passwd *p ;
  __uid_t tmp ;

  {
  {
#line 323
  tmp = getuid();
#line 323
  p = getpwuid(tmp);
  }
#line 323
  if (! p) {
#line 324
    return ((char const   *)((char *)((void *)0)));
  }
#line 325
  return ((char const   *)p->pw_name);
}
}
#line 337 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_sleep(int nsecs ) 
{ 


  {
  {
#line 341
  sleep((unsigned int )nsecs);
  }
#line 342
  return;
}
}
#line 367 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
char *md_getenv(char const   *name ) 
{ 
  char *value ;

  {
  {
#line 373
  value = getenv(name);
  }
#line 375
  return (value);
}
}
#line 386 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
char *md_malloc(int n___0 ) 
{ 
  char *t ;
  void *tmp ;

  {
  {
#line 392
  tmp = malloc((size_t )n___0);
#line 392
  t = (char *)tmp;
  }
#line 393
  return (t);
}
}
#line 414 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
int md_gseed(void) 
{ 
  time_t seconds ;

  {
  {
#line 419
  time(& seconds);
  }
#line 420
  return ((int )seconds);
}
}
#line 430
 __attribute__((__noreturn__)) void md_exit(int status ) ;
#line 430 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_exit(int status ) 
{ 


  {
  {
#line 434
  exit(status);
  }
}
}
#line 452 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
static int fd  ;
#line 448 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_lock(char l ) 
{ 
  short tries ;
  int tmp ;

  {
#line 455
  if (l) {
    {
#line 456
    setegid(egid);
#line 457
    fd = open("/var/games/bsdgames-nonfree/rogue.scores", 0);
    }
#line 457
    if (fd < 1) {
      {
#line 458
      setegid(gid);
#line 459
      message("cannot lock score file", (char)0);
      }
#line 460
      return;
    }
    {
#line 462
    setegid(gid);
#line 463
    tries = (short)0;
    }
    {
#line 463
    while (1) {
      while_continue: /* CIL Label */ ;
#line 463
      if (! ((int )tries < 5)) {
#line 463
        goto while_break;
      }
      {
#line 464
      tmp = flock(fd, 6);
      }
#line 464
      if (! tmp) {
#line 465
        return;
      }
#line 463
      tries = (short )((int )tries + 1);
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 467
    flock(fd, 4);
#line 468
    close(fd);
    }
  }
#line 470
  return;
}
}
#line 481 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/machdep.c"
void md_shell(char const   *shell ) 
{ 
  int w ;
  __pid_t tmp ;

  {
  {
#line 487
  tmp = fork();
  }
#line 487
  if (! tmp) {
    {
#line 488
    execl(shell, shell, (char *)0);
    }
  }
  {
#line 490
  wait((union wait *)(& w));
  }
#line 491
  return;
}
}
#line 468 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
void bounce(short ball , short dir , short row___0 , short col___0 , short r ) ;
#line 477
char check_imitator(object *monster ) ;
#line 485
void cough_up(object *monster ) ;
#line 489
void disappear(object *monster ) ;
#line 497
void drain_life(void) ;
#line 502
void drop_level(void) ;
#line 515
void freeze(object *monster ) ;
#line 520
int get_dir(short srow , short scol , short drow , short dcol ) ;
#line 539
char gold_at(short row___0 , short col___0 ) ;
#line 694
void special_hit(object *monster ) ;
#line 697
void steal_gold(object *monster ) ;
#line 698
void steal_item(object *monster ) ;
#line 699
void sting(object *monster ) ;
#line 711
char try_to_cough(short row___0 , short col___0 , object *obj ) ;
#line 742 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char being_held  ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
short less_hp  =    (short)0;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void special_hit(object *monster ) 
{ 
  int tmp ;

  {
#line 65
  if (monster->m_flags & 512UL) {
    {
#line 65
    tmp = rand_percent(66);
    }
#line 65
    if (tmp) {
#line 66
      return;
    }
  }
#line 68
  if (monster->m_flags & 1024UL) {
    {
#line 69
    rust(monster);
    }
  }
#line 71
  if (monster->m_flags & 2048UL) {
#line 71
    if (! levitate) {
#line 72
      being_held = (char)1;
    }
  }
#line 74
  if (monster->m_flags & 4096UL) {
    {
#line 75
    freeze(monster);
    }
  }
#line 77
  if (monster->m_flags & 32768UL) {
    {
#line 78
    sting(monster);
    }
  }
#line 80
  if (monster->m_flags & 65536UL) {
    {
#line 81
    drain_life();
    }
  }
#line 83
  if (monster->m_flags & 131072UL) {
    {
#line 84
    drop_level();
    }
  }
#line 86
  if (monster->m_flags & 8192UL) {
    {
#line 87
    steal_gold(monster);
    }
  } else
#line 88
  if (monster->m_flags & 16384UL) {
    {
#line 89
    steal_item(monster);
    }
  }
#line 91
  return;
}
}
#line 93 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void rust(object *monster ) 
{ 
  int tmp ;

  {
#line 97
  if (! rogue.armor) {
#line 99
    return;
  } else {
    {
#line 97
    tmp = get_armor_class((object const   *)rogue.armor);
    }
#line 97
    if (tmp <= 1) {
#line 99
      return;
    } else
#line 97
    if ((int )(rogue.armor)->which_kind == 0) {
#line 99
      return;
    }
  }
#line 101
  if ((rogue.armor)->is_protected) {
#line 101
    goto _L;
  } else
#line 101
  if (maintain_armor) {
    _L: /* CIL Label */ 
#line 102
    if (monster) {
#line 102
      if (! (monster->m_flags & 1048576UL)) {
        {
#line 103
        message("the rust vanishes instantly", (char)0);
#line 104
        monster->m_flags |= 1048576UL;
        }
      }
    }
  } else {
    {
#line 107
    (rogue.armor)->d_enchant = (short )((int )(rogue.armor)->d_enchant - 1);
#line 108
    message("your armor weakens", (char)0);
#line 109
    print_stats(16);
    }
  }
#line 111
  return;
}
}
#line 113 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void freeze(object *monster ) 
{ 
  short freeze_percent ;
  short i ;
  short n___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 117
  freeze_percent = (short)99;
#line 120
  tmp = rand_percent(12);
  }
#line 120
  if (tmp) {
#line 121
    return;
  }
  {
#line 123
  freeze_percent = (short )((int )freeze_percent - ((int )rogue.str_current + (int )rogue.str_current / 2));
#line 124
  freeze_percent = (short )((int )freeze_percent - ((int )rogue.exp + (int )ring_exp) * 4);
#line 125
  tmp___0 = get_armor_class((object const   *)rogue.armor);
#line 125
  freeze_percent = (short )((int )freeze_percent - tmp___0 * 5);
#line 126
  freeze_percent = (short )((int )freeze_percent - (int )rogue.hp_max / 3);
  }
#line 128
  if ((int )freeze_percent > 10) {
    {
#line 129
    monster->m_flags |= 524288UL;
#line 130
    message("you are frozen", (char)1);
#line 132
    tmp___1 = get_rand(4, 8);
#line 132
    n___0 = (short )tmp___1;
#line 133
    i = (short)0;
    }
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
#line 133
      if (! ((int )i < (int )n___0)) {
#line 133
        goto while_break;
      }
      {
#line 134
      mv_mons();
#line 133
      i = (short )((int )i + 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 136
    tmp___2 = rand_percent((int )freeze_percent);
    }
#line 136
    if (tmp___2) {
#line 137
      i = (short)0;
      {
#line 137
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 137
        if (! ((int )i < 50)) {
#line 137
          goto while_break___0;
        }
        {
#line 138
        mv_mons();
#line 137
        i = (short )((int )i + 1);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 140
      killed_by((object const   *)((object *)0), (short)1);
      }
    }
    {
#line 142
    message(you_can_move_again, (char)1);
#line 143
    monster->m_flags &= 0xfffffffffff7ffffUL;
    }
  }
#line 145
  return;
}
}
#line 147 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void steal_gold(object *monster ) 
{ 
  int amount ;
  int tmp ;

  {
#line 153
  if (rogue.gold <= 0L) {
#line 154
    return;
  } else {
    {
#line 153
    tmp = rand_percent(10);
    }
#line 153
    if (tmp) {
#line 154
      return;
    }
  }
  {
#line 157
  amount = get_rand((int )cur_level * 10, (int )cur_level * 30);
  }
#line 159
  if ((long )amount > rogue.gold) {
#line 160
    amount = (int )rogue.gold;
  }
  {
#line 162
  rogue.gold -= (long )amount;
#line 163
  message("your purse feels lighter", (char)0);
#line 164
  print_stats(2);
#line 165
  disappear(monster);
  }
#line 166
  return;
}
}
#line 168 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void steal_item(object *monster ) 
{ 
  object *obj ;
  short i ;
  short n___0 ;
  short t ;
  char desc[80] ;
  char has_something ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 173
  t = (short)0;
#line 175
  has_something = (char)0;
#line 177
  tmp = rand_percent(15);
  }
#line 177
  if (tmp) {
#line 178
    return;
  }
#line 180
  obj = rogue.pack.next_object;
#line 182
  if (! obj) {
#line 183
    goto DSPR;
  }
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! obj) {
#line 185
      goto while_break;
    }
#line 186
    if (! ((int )obj->in_use_flags & 15)) {
#line 187
      has_something = (char)1;
#line 188
      goto while_break;
    }
#line 190
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (! has_something) {
#line 193
    goto DSPR;
  }
  {
#line 195
  tmp___0 = get_rand(0, 24);
#line 195
  n___0 = (short )tmp___0;
#line 196
  obj = rogue.pack.next_object;
#line 198
  i = (short)0;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! ((int )i <= (int )n___0)) {
#line 198
      goto while_break___0;
    }
#line 199
    obj = obj->next_object;
    {
#line 200
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 200
      if (! (! obj)) {
#line 200
        if (! ((int )obj->in_use_flags & 15)) {
#line 200
          goto while_break___1;
        }
      }
#line 201
      if (! obj) {
#line 202
        obj = rogue.pack.next_object;
      } else {
#line 204
        obj = obj->next_object;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 198
    i = (short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  strcpy((char */* __restrict  */)(desc), (char const   */* __restrict  */)"she stole ");
  }
#line 209
  if ((int )obj->what_is != 2) {
#line 210
    t = obj->quantity;
#line 211
    obj->quantity = (short)1;
  }
  {
#line 213
  get_desc((object const   *)obj, desc + 10);
#line 214
  message((char const   *)(desc), (char)0);
  }
#line 216
  if ((int )obj->what_is != 2) {
#line 216
    obj->quantity = t;
  } else {
#line 216
    obj->quantity = (short)1;
  }
  {
#line 218
  vanish(obj, (short)0, & rogue.pack);
  }
  DSPR: 
  {
#line 220
  disappear(monster);
  }
#line 221
  return;
}
}
#line 223 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void disappear(object *monster ) 
{ 
  short row___0 ;
  short col___0 ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 229
  row___0 = monster->row;
#line 230
  col___0 = monster->col;
#line 232
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -3);
#line 233
  tmp___1 = rogue_can_see((int )row___0, (int )col___0);
  }
#line 233
  if (tmp___1) {
    {
#line 234
    tmp___0 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 234
    if (! (tmp___0 == -1)) {
      {
#line 234
      tmp = get_dungeon_char(row___0, col___0);
#line 234
      waddch(stdscr, (chtype const   )tmp);
      }
    }
  }
  {
#line 236
  take_from_pack(monster, & level_monsters);
#line 237
  free_object(monster);
#line 238
  mon_disappeared = (char)1;
  }
#line 239
  return;
}
}
#line 241 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void cough_up(object *monster ) 
{ 
  object *obj ;
  short row___0 ;
  short col___0 ;
  short i ;
  short n___0 ;
  int tmp ;
  int tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;

  {
#line 248
  if ((int )cur_level < (int )max_level) {
#line 249
    return;
  }
#line 252
  if (monster->m_flags & 8192UL) {
    {
#line 253
    obj = alloc_object();
#line 254
    obj->what_is = (unsigned short)16;
#line 255
    tmp = get_rand((int )cur_level * 15, (int )cur_level * 30);
#line 255
    obj->quantity = (short )tmp;
    }
  } else {
    {
#line 257
    tmp___0 = rand_percent((int )monster->which_kind);
    }
#line 257
    if (! tmp___0) {
#line 258
      return;
    }
    {
#line 260
    obj = gr_object();
    }
  }
#line 262
  row___0 = monster->row;
#line 263
  col___0 = monster->col;
#line 265
  n___0 = (short)0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! ((int )n___0 <= 5)) {
#line 265
      goto while_break;
    }
#line 266
    i = (short )(- ((int )n___0));
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! ((int )i <= (int )n___0)) {
#line 266
        goto while_break___0;
      }
      {
#line 267
      tmp___1 = try_to_cough((short )((int )row___0 + (int )n___0), (short )((int )col___0 + (int )i),
                             obj);
      }
#line 267
      if (tmp___1) {
#line 268
        return;
      }
      {
#line 270
      tmp___2 = try_to_cough((short )((int )row___0 - (int )n___0), (short )((int )col___0 + (int )i),
                             obj);
      }
#line 270
      if (tmp___2) {
#line 271
        return;
      }
#line 266
      i = (short )((int )i + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 274
    i = (short )(- ((int )n___0));
    {
#line 274
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 274
      if (! ((int )i <= (int )n___0)) {
#line 274
        goto while_break___1;
      }
      {
#line 275
      tmp___3 = try_to_cough((short )((int )row___0 + (int )i), (short )((int )col___0 - (int )n___0),
                             obj);
      }
#line 275
      if (tmp___3) {
#line 276
        return;
      }
      {
#line 278
      tmp___4 = try_to_cough((short )((int )row___0 + (int )i), (short )((int )col___0 + (int )n___0),
                             obj);
      }
#line 278
      if (tmp___4) {
#line 279
        return;
      }
#line 274
      i = (short )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 265
    n___0 = (short )((int )n___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  free_object(obj);
  }
#line 284
  return;
}
}
#line 286 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char try_to_cough(short row___0 , short col___0 , object *obj ) 
{ 
  char tmp ;
  int tmp___0 ;

  {
#line 291
  if ((int )row___0 < 1) {
#line 293
    return ((char)0);
  } else
#line 291
  if ((int )row___0 > 22) {
#line 293
    return ((char)0);
  } else
#line 291
  if ((int )col___0 < 0) {
#line 293
    return ((char)0);
  } else
#line 291
  if ((int )col___0 > 79) {
#line 293
    return ((char)0);
  }
#line 295
  if (! ((int )dungeon[row___0][col___0] & 261)) {
#line 295
    if ((int )dungeon[row___0][col___0] & 224) {
      {
#line 297
      place_at(obj, (int )row___0, (int )col___0);
      }
#line 298
      if ((int )row___0 != (int )rogue.row) {
#line 298
        goto _L;
      } else
#line 298
      if ((int )col___0 != (int )rogue.col) {
        _L: /* CIL Label */ 
#line 298
        if (! ((int )dungeon[row___0][col___0] & 2)) {
          {
#line 300
          tmp___0 = wmove(stdscr, (int )row___0, (int )col___0);
          }
#line 300
          if (! (tmp___0 == -1)) {
            {
#line 300
            tmp = get_dungeon_char(row___0, col___0);
#line 300
            waddch(stdscr, (chtype const   )tmp);
            }
          }
        }
      }
#line 302
      return ((char)1);
    }
  }
#line 304
  return ((char)0);
}
}
#line 307 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char seek_gold(object *monster ) 
{ 
  short i ;
  short j ;
  short rn ;
  short s___0 ;
  int tmp ;
  char tmp___0 ;

  {
  {
#line 313
  rn = get_room_number((int )monster->row, (int )monster->col);
  }
#line 313
  if ((int )rn < 0) {
#line 314
    return ((char)0);
  }
#line 316
  i = (short )((int )rooms[rn].top_row + 1);
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! ((int )i < (int )rooms[rn].bottom_row)) {
#line 316
      goto while_break;
    }
#line 317
    j = (short )((int )rooms[rn].left_col + 1);
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 317
      if (! ((int )j < (int )rooms[rn].right_col)) {
#line 317
        goto while_break___0;
      }
      {
#line 318
      tmp___0 = gold_at((int )i, (int )j);
      }
#line 318
      if (tmp___0) {
#line 318
        if (! ((int )dungeon[i][j] & 2)) {
          {
#line 319
          monster->m_flags |= 256UL;
#line 320
          tmp = mon_can_go((object const   *)monster, (int )i, (int )j);
#line 320
          s___0 = (short )tmp;
#line 321
          monster->m_flags &= 0xfffffffffffffeffUL;
          }
#line 322
          if (s___0) {
            {
#line 323
            move_mon_to(monster, (int )i, (int )j);
#line 324
            monster->m_flags |= 8UL;
#line 325
            monster->m_flags &= 0xfffffffffffbffefUL;
            }
#line 326
            return ((char)1);
          }
          {
#line 328
          monster->m_flags &= 0xfffffffffffbffffUL;
#line 329
          monster->m_flags |= 256UL;
#line 330
          mv_1_monster(monster, (int )i, (int )j);
#line 331
          monster->m_flags &= 0xfffffffffffffeffUL;
#line 332
          monster->m_flags |= 262144UL;
          }
#line 333
          return ((char)1);
        }
      }
#line 317
      j = (short )((int )j + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return ((char)0);
}
}
#line 340 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char gold_at(short row___0 , short col___0 ) 
{ 
  object *obj ;

  {
#line 344
  if ((int )dungeon[row___0][col___0] & 1) {
    {
#line 347
    obj = object_at(& level_objects, row___0, col___0);
    }
#line 347
    if (obj) {
#line 347
      if ((int )obj->what_is == 16) {
#line 349
        return ((char)1);
      }
    }
  }
#line 352
  return ((char)0);
}
}
#line 355 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void check_gold_seeker(object *monster ) 
{ 


  {
#line 359
  monster->m_flags &= 0xfffffffffffbffffUL;
#line 360
  return;
}
}
#line 362 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char check_imitator(object *monster ) 
{ 
  char msg[80] ;
  char tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 368
  if (monster->m_flags & 4194304UL) {
    {
#line 369
    wake_up(monster);
    }
#line 370
    if (! blind) {
      {
#line 371
      tmp___0 = wmove(stdscr, (int )monster->row, (int )monster->col);
      }
#line 371
      if (! (tmp___0 == -1)) {
        {
#line 371
        tmp = get_dungeon_char(monster->row, monster->col);
#line 371
        waddch(stdscr, (chtype const   )tmp);
        }
      }
      {
#line 373
      check_message();
#line 374
      tmp___1 = mon_name((object const   *)monster);
#line 374
      sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"wait, that\'s a %s!",
              tmp___1);
#line 375
      message((char const   *)(msg), (char)1);
      }
    }
#line 377
    return ((char)1);
  }
#line 379
  return ((char)0);
}
}
#line 382 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char imitating(short row___0 , short col___0 ) 
{ 
  object *monster ;

  {
#line 386
  if ((int )dungeon[row___0][col___0] & 2) {
    {
#line 389
    monster = object_at(& level_monsters, row___0, col___0);
    }
#line 389
    if ((unsigned long )monster != (unsigned long )((void *)0)) {
#line 390
      if (monster->m_flags & 4194304UL) {
#line 391
        return ((char)1);
      }
    }
  }
#line 395
  return ((char)0);
}
}
#line 398 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void sting(object *monster ) 
{ 
  short sting_chance ;
  char msg[80] ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 402
  sting_chance = (short)35;
#line 405
  if ((int )rogue.str_current <= 3) {
#line 406
    return;
  } else
#line 405
  if (sustain_strength) {
#line 406
    return;
  }
  {
#line 408
  tmp = get_armor_class((object const   *)rogue.armor);
#line 408
  sting_chance = (short )((int )sting_chance + 6 * (6 - tmp));
  }
#line 410
  if ((int )rogue.exp + (int )ring_exp > 8) {
#line 411
    sting_chance = (short )((int )sting_chance - 6 * (((int )rogue.exp + (int )ring_exp) - 8));
  }
  {
#line 413
  tmp___1 = rand_percent((int )sting_chance);
  }
#line 413
  if (tmp___1) {
    {
#line 414
    tmp___0 = mon_name((object const   *)monster);
#line 414
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"the %s\'s bite has weakened you",
            tmp___0);
#line 416
    message((char const   *)(msg), (char)0);
#line 417
    rogue.str_current = (short )((int )rogue.str_current - 1);
#line 418
    print_stats(8);
    }
  }
#line 420
  return;
}
}
#line 422 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void drop_level(void) 
{ 
  int hp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 427
  tmp = rand_percent(80);
  }
#line 427
  if (tmp) {
#line 428
    return;
  } else
#line 427
  if ((int )rogue.exp <= 5) {
#line 428
    return;
  }
  {
#line 430
  tmp___0 = get_rand(9, 29);
#line 430
  rogue.exp_points = (long )(level_points[(int )rogue.exp - 2] - (long const   )tmp___0);
#line 431
  rogue.exp = (short )((int )rogue.exp - 2);
#line 432
  hp = hp_raise();
#line 433
  rogue.hp_current = (short )((int )rogue.hp_current - hp);
  }
#line 433
  if ((int )rogue.hp_current <= 0) {
#line 434
    rogue.hp_current = (short)1;
  }
#line 436
  rogue.hp_max = (short )((int )rogue.hp_max - hp);
#line 436
  if ((int )rogue.hp_max <= 0) {
#line 437
    rogue.hp_max = (short)1;
  }
  {
#line 439
  add_exp(1, (char)0);
  }
#line 440
  return;
}
}
#line 442 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
void drain_life(void) 
{ 
  short n___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 447
  tmp = rand_percent(60);
  }
#line 447
  if (tmp) {
#line 448
    return;
  } else
#line 447
  if ((int )rogue.hp_max <= 30) {
#line 448
    return;
  } else
#line 447
  if ((int )rogue.hp_current < 10) {
#line 448
    return;
  }
  {
#line 450
  tmp___0 = get_rand(1, 3);
#line 450
  n___0 = (short )tmp___0;
  }
#line 452
  if ((int )n___0 != 2) {
    {
#line 453
    message("you feel weaker", (char)0);
    }
  } else
#line 452
  if (! sustain_strength) {
    {
#line 453
    message("you feel weaker", (char)0);
    }
  }
#line 455
  if ((int )n___0 != 2) {
#line 456
    rogue.hp_max = (short )((int )rogue.hp_max - 1);
#line 457
    rogue.hp_current = (short )((int )rogue.hp_current - 1);
#line 458
    less_hp = (short )((int )less_hp + 1);
  }
#line 460
  if ((int )n___0 != 1) {
#line 461
    if ((int )rogue.str_current > 3) {
#line 461
      if (! sustain_strength) {
        {
#line 462
        rogue.str_current = (short )((int )rogue.str_current - 1);
#line 463
        tmp___1 = coin_toss();
        }
#line 463
        if (tmp___1) {
#line 464
          rogue.str_max = (short )((int )rogue.str_max - 1);
        }
      }
    }
  }
  {
#line 468
  print_stats(12);
  }
#line 469
  return;
}
}
#line 471 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char m_confuse(object *monster ) 
{ 
  char msg[80] ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 477
  tmp = rogue_can_see((int )monster->row, (int )monster->col);
  }
#line 477
  if (! tmp) {
#line 478
    return ((char)0);
  }
  {
#line 480
  tmp___0 = rand_percent(45);
  }
#line 480
  if (tmp___0) {
#line 481
    monster->m_flags &= 0xffffffffffdfffffUL;
#line 482
    return ((char)0);
  }
  {
#line 484
  tmp___2 = rand_percent(55);
  }
#line 484
  if (tmp___2) {
    {
#line 485
    monster->m_flags &= 0xffffffffffdfffffUL;
#line 486
    tmp___1 = mon_name((object const   *)monster);
#line 486
    sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"the gaze of the %s has confused you",
            tmp___1);
#line 487
    message((char const   *)(msg), (char)1);
#line 488
    cnfs();
    }
#line 489
    return ((char)1);
  }
#line 491
  return ((char)0);
}
}
#line 494 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
char flame_broil(object *monster ) 
{ 
  short row___0 ;
  short col___0 ;
  short dir ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 500
  tmp = mon_sees((object const   *)monster, (int )rogue.row, (int )rogue.col);
  }
#line 500
  if (tmp) {
    {
#line 500
    tmp___0 = coin_toss();
    }
#line 500
    if (tmp___0) {
#line 501
      return ((char)0);
    }
  } else {
#line 501
    return ((char)0);
  }
#line 503
  row___0 = (short )((int )rogue.row - (int )monster->row);
#line 504
  col___0 = (short )((int )rogue.col - (int )monster->col);
#line 505
  if ((int )row___0 < 0) {
#line 506
    row___0 = (short )(- ((int )row___0));
  }
#line 508
  if ((int )col___0 < 0) {
#line 509
    col___0 = (short )(- ((int )col___0));
  }
#line 511
  if ((int )row___0 != 0) {
#line 511
    if ((int )col___0 != 0) {
#line 511
      if ((int )row___0 != (int )col___0) {
#line 513
        return ((char)0);
      } else {
#line 511
        goto _L___0;
      }
    } else {
#line 511
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 511
  if ((int )row___0 > 7) {
#line 513
    return ((char)0);
  } else
#line 511
  if ((int )col___0 > 7) {
#line 513
    return ((char)0);
  }
  {
#line 515
  tmp___1 = get_dir(monster->row, monster->col, row___0, col___0);
#line 515
  dir = (short )tmp___1;
#line 516
  bounce((short)10, dir, monster->row, monster->col, (short)0);
  }
#line 518
  return ((char)1);
}
}
#line 521 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/spec_hit.c"
int get_dir(short srow , short scol , short drow , short dcol ) 
{ 


  {
#line 525
  if ((int )srow == (int )drow) {
#line 526
    if ((int )scol < (int )dcol) {
#line 527
      return (2);
    } else {
#line 529
      return (6);
    }
  }
#line 532
  if ((int )scol == (int )dcol) {
#line 533
    if ((int )srow < (int )drow) {
#line 534
      return (4);
    } else {
#line 536
      return (0);
    }
  }
#line 539
  if ((int )srow > (int )drow) {
#line 539
    if ((int )scol > (int )dcol) {
#line 540
      return (7);
    }
  }
#line 542
  if ((int )srow < (int )drow) {
#line 542
    if ((int )scol < (int )dcol) {
#line 543
      return (3);
    }
  }
#line 545
  if ((int )srow < (int )drow) {
#line 545
    if ((int )scol > (int )dcol) {
#line 546
      return (5);
    }
  }
#line 549
  return (1);
}
}
#line 487 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
int damage_for_strength(void) ;
#line 528
int get_number(char const   *s___0 ) ;
#line 533
int get_w_damage(object const   *obj ) ;
#line 670
void rogue_damage(short d , object *monster , short other ) ;
#line 708
int to_hit(object const   *obj ) ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
object *fight_monster  =    (object *)0;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
char hit_message[80]  = {      (char )'\000'};
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void mon_hit(object *monster ) 
{ 
  short damage ;
  short hit_chance ;
  char const   *mn ;
  float minus ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  short tmp___4 ;

  {
#line 69
  if (fight_monster) {
#line 69
    if ((unsigned long )monster != (unsigned long )fight_monster) {
#line 70
      fight_monster = (object *)0;
    }
  }
#line 72
  monster->trow = (short)-1;
#line 73
  if ((int )cur_level >= 52) {
#line 74
    hit_chance = (short)100;
  } else {
#line 76
    hit_chance = monster->class;
#line 77
    hit_chance = (short )((int )hit_chance - ((2 * (int )rogue.exp + 2 * (int )ring_exp) - (int )r_rings));
  }
#line 79
  if (wizard) {
#line 80
    hit_chance = (short )((int )hit_chance / 2);
  }
#line 82
  if (! fight_monster) {
#line 83
    interrupted = (char)1;
  }
  {
#line 85
  mn = mon_name((object const   *)monster);
#line 87
  tmp___0 = rand_percent((int )hit_chance);
  }
#line 87
  if (! tmp___0) {
#line 88
    if (! fight_monster) {
      {
#line 89
      tmp = strlen((char const   *)(hit_message));
#line 89
      sprintf((char */* __restrict  */)(hit_message + tmp), (char const   */* __restrict  */)"the %s misses",
              mn);
#line 91
      message((char const   *)(hit_message), (char)1);
#line 92
      hit_message[0] = (char)0;
      }
    }
#line 94
    return;
  }
#line 96
  if (! fight_monster) {
    {
#line 97
    tmp___1 = strlen((char const   *)(hit_message));
#line 97
    sprintf((char */* __restrict  */)(hit_message + tmp___1), (char const   */* __restrict  */)"the %s hit",
            mn);
#line 98
    message((char const   *)(hit_message), (char)1);
#line 99
    hit_message[0] = (char)0;
    }
  }
#line 101
  if (! (monster->m_flags & 16777216UL)) {
    {
#line 102
    tmp___2 = get_damage(monster->damage, (char)1);
#line 102
    damage = (short )tmp___2;
    }
#line 103
    if ((int )cur_level >= 52) {
#line 104
      minus = (float )(52 - (int )cur_level);
    } else {
      {
#line 106
      tmp___3 = get_armor_class((object const   *)rogue.armor);
#line 106
      minus = (float )((double )((float )tmp___3) * 3.00);
#line 107
      minus = (float )(((double )minus / 100.00) * (double )((float )damage));
      }
    }
#line 109
    damage = (short )((int )damage - (int )((short )minus));
  } else {
#line 111
    tmp___4 = monster->identified;
#line 111
    monster->identified = (short )((int )monster->identified + 1);
#line 111
    damage = tmp___4;
  }
#line 113
  if (wizard) {
#line 114
    damage = (short )((int )damage / 3);
  }
#line 116
  if ((int )damage > 0) {
    {
#line 117
    rogue_damage(damage, monster, (short)0);
    }
  }
#line 119
  if (monster->m_flags & 261120UL) {
    {
#line 120
    special_hit(monster);
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void rogue_hit(object *monster , char force_hit ) 
{ 
  short damage ;
  short hit_chance ;
  char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 131
  if (monster) {
    {
#line 132
    tmp = check_imitator(monster);
    }
#line 132
    if (tmp) {
#line 133
      return;
    }
#line 135
    if (force_hit) {
#line 135
      hit_chance = (short)100;
    } else {
      {
#line 135
      tmp___0 = get_hit_chance((object const   *)rogue.weapon);
#line 135
      hit_chance = (short )tmp___0;
      }
    }
#line 137
    if (wizard) {
#line 138
      hit_chance = (short )((int )hit_chance * 2);
    }
    {
#line 140
    tmp___1 = rand_percent((int )hit_chance);
    }
#line 140
    if (! tmp___1) {
#line 141
      if (! fight_monster) {
        {
#line 142
        strcpy((char */* __restrict  */)(hit_message), (char const   */* __restrict  */)"you miss  ");
        }
      }
#line 144
      goto RET;
    }
    {
#line 146
    tmp___2 = get_weapon_damage((object const   *)rogue.weapon);
#line 146
    damage = (short )tmp___2;
    }
#line 147
    if (wizard) {
#line 148
      damage = (short )((int )damage * 3);
    }
#line 150
    if (con_mon) {
      {
#line 151
      s_con_mon(monster);
      }
    }
    {
#line 153
    tmp___3 = mon_damage(monster, damage);
    }
#line 153
    if (tmp___3) {
#line 154
      if (! fight_monster) {
        {
#line 155
        strcpy((char */* __restrict  */)(hit_message), (char const   */* __restrict  */)"you hit  ");
        }
      }
    }
    RET: 
    {
#line 158
    check_gold_seeker(monster);
#line 159
    wake_up(monster);
    }
  }
#line 161
  return;
}
}
#line 163 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void rogue_damage(short d , object *monster , short other ) 
{ 


  {
#line 169
  if ((int )d >= (int )rogue.hp_current) {
    {
#line 170
    rogue.hp_current = (short)0;
#line 171
    print_stats(4);
#line 172
    killed_by((object const   *)monster, other);
    }
  }
#line 174
  if ((int )d > 0) {
    {
#line 175
    rogue.hp_current = (short )((int )rogue.hp_current - (int )d);
#line 176
    print_stats(4);
    }
  }
#line 178
  return;
}
}
#line 180 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int get_damage(char const   *ds , char r ) 
{ 
  int i ;
  int j ;
  int n___0 ;
  int d ;
  int total ;
  int tmp ;
  int tmp___0 ;

  {
#line 185
  i = 0;
#line 185
  total = 0;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! *(ds + i)) {
#line 187
      goto while_break;
    }
    {
#line 188
    n___0 = get_number(ds + i);
    }
    {
#line 189
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 189
      tmp = i;
#line 189
      i ++;
#line 189
      if (! ((int const   )*(ds + tmp) != 100)) {
#line 189
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 190
    d = get_number(ds + i);
    }
    {
#line 191
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 191
      if ((int const   )*(ds + i) != 47) {
#line 191
        if (! *(ds + i)) {
#line 191
          goto while_break___1;
        }
      } else {
#line 191
        goto while_break___1;
      }
#line 191
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 193
    j = 0;
    {
#line 193
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 193
      if (! (j < n___0)) {
#line 193
        goto while_break___2;
      }
#line 194
      if (r) {
        {
#line 195
        tmp___0 = get_rand(1, d);
#line 195
        total += tmp___0;
        }
      } else {
#line 197
        total += d;
      }
#line 193
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 200
    if ((int const   )*(ds + i) == 47) {
#line 201
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (total);
}
}
#line 207 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int get_w_damage(object const   *obj ) 
{ 
  char new_damage[12] ;
  int tmp_to_hit ;
  int tmp_damage ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 213
  i = 0;
#line 215
  if (! obj) {
#line 216
    return (-1);
  } else
#line 215
  if ((int const   )obj->what_is != 2) {
#line 216
    return (-1);
  }
  {
#line 218
  tmp = get_number((char const   *)obj->damage);
#line 218
  tmp_to_hit = tmp + (int )obj->hit_enchant;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    tmp___0 = i;
#line 219
    i ++;
#line 219
    if (! ((int const   )*(obj->damage + tmp___0) != 100)) {
#line 219
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  tmp___1 = get_number((char const   *)(obj->damage + i));
#line 220
  tmp_damage = tmp___1 + (int )obj->d_enchant;
#line 222
  sprintf((char */* __restrict  */)(new_damage), (char const   */* __restrict  */)"%dd%d",
          tmp_to_hit, tmp_damage);
#line 224
  tmp___2 = get_damage((char const   *)(new_damage), (char)1);
  }
#line 224
  return (tmp___2);
}
}
#line 227 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int get_number(char const   *s___0 ) 
{ 
  int i ;
  int total ;

  {
#line 231
  i = 0;
#line 232
  total = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if ((int const   )*(s___0 + i) >= 48) {
#line 234
      if (! ((int const   )*(s___0 + i) <= 57)) {
#line 234
        goto while_break;
      }
    } else {
#line 234
      goto while_break;
    }
#line 235
    total = 10 * total + (int )((int const   )*(s___0 + i) - 48);
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (total);
}
}
#line 241 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
long lget_number(char const   *s___0 ) 
{ 
  short i ;
  long total ;

  {
#line 245
  i = (short)0;
#line 246
  total = 0L;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if ((int const   )*(s___0 + i) >= 48) {
#line 248
      if (! ((int const   )*(s___0 + i) <= 57)) {
#line 248
        goto while_break;
      }
    } else {
#line 248
      goto while_break;
    }
#line 249
    total = 10L * total + (long )((int const   )*(s___0 + i) - 48);
#line 250
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (total);
}
}
#line 255 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int to_hit(object const   *obj ) 
{ 
  int tmp ;

  {
#line 259
  if (! obj) {
#line 260
    return (1);
  }
  {
#line 262
  tmp = get_number((char const   *)obj->damage);
  }
#line 262
  return (tmp + (int )obj->hit_enchant);
}
}
#line 265 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int damage_for_strength(void) 
{ 
  short strength ;

  {
#line 270
  strength = (short )((int )rogue.str_current + (int )add_strength);
#line 272
  if ((int )strength <= 6) {
#line 273
    return ((int )strength - 5);
  }
#line 275
  if ((int )strength <= 14) {
#line 276
    return (1);
  }
#line 278
  if ((int )strength <= 17) {
#line 279
    return (3);
  }
#line 281
  if ((int )strength <= 18) {
#line 282
    return (4);
  }
#line 284
  if ((int )strength <= 20) {
#line 285
    return (5);
  }
#line 287
  if ((int )strength <= 21) {
#line 288
    return (6);
  }
#line 290
  if ((int )strength <= 30) {
#line 291
    return (7);
  }
#line 293
  return (8);
}
}
#line 296 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int mon_damage(object *monster , short damage ) 
{ 
  char const   *mn ;
  short row___0 ;
  short col___0 ;
  char tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 304
  monster->quantity = (short )((int )monster->quantity - (int )damage);
#line 306
  if ((int )monster->quantity <= 0) {
    {
#line 307
    row___0 = monster->row;
#line 308
    col___0 = monster->col;
#line 309
    dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] & -3);
#line 310
    tmp___0 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 310
    if (! (tmp___0 == -1)) {
      {
#line 310
      tmp = get_dungeon_char(row___0, col___0);
#line 310
      waddch(stdscr, (chtype const   )((int )tmp));
      }
    }
    {
#line 312
    fight_monster = (object *)0;
#line 313
    cough_up(monster);
#line 314
    mn = mon_name((object const   *)monster);
#line 315
    tmp___1 = strlen((char const   *)(hit_message));
#line 315
    sprintf((char */* __restrict  */)(hit_message + tmp___1), (char const   */* __restrict  */)"defeated the %s",
            mn);
#line 316
    message((char const   *)(hit_message), (char)1);
#line 317
    hit_message[0] = (char)0;
#line 318
    add_exp((int )monster->kill_exp, (char)1);
#line 319
    take_from_pack(monster, & level_monsters);
    }
#line 321
    if (monster->m_flags & 2048UL) {
#line 322
      being_held = (char)0;
    }
    {
#line 324
    free_object(monster);
    }
#line 325
    return (0);
  }
#line 327
  return (1);
}
}
#line 330 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void fight(char to_the_death ) 
{ 
  short ch ;
  short c___0 ;
  short d ;
  short row___0 ;
  short col___0 ;
  char first_miss ;
  short possible_damage ;
  object *monster ;
  int tmp ;
  char tmp___0 ;
  chtype tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  int tmp___5 ;

  {
#line 336
  first_miss = (char)1;
#line 340
  ch = (short)0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 341
    tmp = rgetchar();
#line 341
    ch = (short )tmp;
#line 341
    tmp___0 = is_direction(ch, & d);
    }
#line 341
    if (tmp___0) {
#line 341
      goto while_break;
    }
    {
#line 342
    sound_bell();
    }
#line 343
    if (first_miss) {
      {
#line 344
      message("direction?", (char)0);
#line 345
      first_miss = (char)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  check_message();
  }
#line 349
  if ((int )ch == 27) {
#line 350
    return;
  }
  {
#line 352
  row___0 = rogue.row;
#line 352
  col___0 = rogue.col;
#line 353
  get_dir_rc(d, & row___0, & col___0, (short)0);
#line 355
  tmp___3 = wmove(stdscr, (int )row___0, (int )col___0);
  }
#line 355
  if (tmp___3 == -1) {
#line 355
    c___0 = (short )((chtype )-1);
  } else {
    {
#line 355
    tmp___2 = winch(stdscr);
#line 355
    c___0 = (short )tmp___2;
    }
  }
#line 356
  if ((int )c___0 < 65) {
    {
#line 358
    message("I see no monster there", (char)0);
    }
#line 359
    return;
  } else
#line 356
  if ((int )c___0 > 90) {
    {
#line 358
    message("I see no monster there", (char)0);
    }
#line 359
    return;
  } else {
    {
#line 356
    tmp___4 = can_move((int )rogue.row, (int )rogue.col, (int )row___0, (int )col___0);
    }
#line 356
    if (! tmp___4) {
      {
#line 358
      message("I see no monster there", (char)0);
      }
#line 359
      return;
    }
  }
  {
#line 361
  fight_monster = object_at(& level_monsters, row___0, col___0);
  }
#line 361
  if (! fight_monster) {
#line 362
    return;
  }
#line 364
  if (! (fight_monster->m_flags & 16777216UL)) {
    {
#line 365
    tmp___5 = get_damage(fight_monster->damage, (char)0);
#line 365
    possible_damage = (short )((tmp___5 * 2) / 3);
    }
  } else {
#line 367
    possible_damage = (short )((int )fight_monster->identified - 1);
  }
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 369
    if (! fight_monster) {
#line 369
      goto while_break___0;
    }
    {
#line 370
    one_move_rogue(ch, (short)0);
    }
#line 371
    if (! to_the_death) {
#line 371
      if ((int )rogue.hp_current <= (int )possible_damage) {
#line 373
        fight_monster = (object *)0;
      } else {
#line 371
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 371
    if (interrupted) {
#line 373
      fight_monster = (object *)0;
    } else
#line 371
    if (! ((int )dungeon[row___0][col___0] & 2)) {
#line 373
      fight_monster = (object *)0;
    } else {
      {
#line 375
      monster = object_at(& level_monsters, row___0, col___0);
      }
#line 376
      if ((unsigned long )monster != (unsigned long )fight_monster) {
#line 377
        fight_monster = (object *)0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 383 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void get_dir_rc(short dir , short *row___0 , short *col___0 , short allow_off_screen ) 
{ 


  {
  {
#line 390
  if ((int )dir == 6) {
#line 390
    goto case_6;
  }
#line 395
  if ((int )dir == 4) {
#line 395
    goto case_4;
  }
#line 400
  if ((int )dir == 0) {
#line 400
    goto case_0;
  }
#line 405
  if ((int )dir == 2) {
#line 405
    goto case_2;
  }
#line 410
  if ((int )dir == 7) {
#line 410
    goto case_7;
  }
#line 416
  if ((int )dir == 1) {
#line 416
    goto case_1;
  }
#line 422
  if ((int )dir == 3) {
#line 422
    goto case_3;
  }
#line 428
  if ((int )dir == 5) {
#line 428
    goto case_5;
  }
#line 389
  goto switch_break;
  case_6: /* CIL Label */ 
#line 391
  if (allow_off_screen) {
#line 392
    *col___0 = (short )((int )*col___0 - 1);
  } else
#line 391
  if ((int )*col___0 > 0) {
#line 392
    *col___0 = (short )((int )*col___0 - 1);
  }
#line 394
  goto switch_break;
  case_4: /* CIL Label */ 
#line 396
  if (allow_off_screen) {
#line 397
    *row___0 = (short )((int )*row___0 + 1);
  } else
#line 396
  if ((int )*row___0 < 22) {
#line 397
    *row___0 = (short )((int )*row___0 + 1);
  }
#line 399
  goto switch_break;
  case_0: /* CIL Label */ 
#line 401
  if (allow_off_screen) {
#line 402
    *row___0 = (short )((int )*row___0 - 1);
  } else
#line 401
  if ((int )*row___0 > 1) {
#line 402
    *row___0 = (short )((int )*row___0 - 1);
  }
#line 404
  goto switch_break;
  case_2: /* CIL Label */ 
#line 406
  if (allow_off_screen) {
#line 407
    *col___0 = (short )((int )*col___0 + 1);
  } else
#line 406
  if ((int )*col___0 < 79) {
#line 407
    *col___0 = (short )((int )*col___0 + 1);
  }
#line 409
  goto switch_break;
  case_7: /* CIL Label */ 
#line 411
  if (allow_off_screen) {
#line 412
    *row___0 = (short )((int )*row___0 - 1);
#line 413
    *col___0 = (short )((int )*col___0 - 1);
  } else
#line 411
  if ((int )*row___0 > 1) {
#line 411
    if ((int )*col___0 > 0) {
#line 412
      *row___0 = (short )((int )*row___0 - 1);
#line 413
      *col___0 = (short )((int )*col___0 - 1);
    }
  }
#line 415
  goto switch_break;
  case_1: /* CIL Label */ 
#line 417
  if (allow_off_screen) {
#line 418
    *row___0 = (short )((int )*row___0 - 1);
#line 419
    *col___0 = (short )((int )*col___0 + 1);
  } else
#line 417
  if ((int )*row___0 > 1) {
#line 417
    if ((int )*col___0 < 79) {
#line 418
      *row___0 = (short )((int )*row___0 - 1);
#line 419
      *col___0 = (short )((int )*col___0 + 1);
    }
  }
#line 421
  goto switch_break;
  case_3: /* CIL Label */ 
#line 423
  if (allow_off_screen) {
#line 424
    *row___0 = (short )((int )*row___0 + 1);
#line 425
    *col___0 = (short )((int )*col___0 + 1);
  } else
#line 423
  if ((int )*row___0 < 22) {
#line 423
    if ((int )*col___0 < 79) {
#line 424
      *row___0 = (short )((int )*row___0 + 1);
#line 425
      *col___0 = (short )((int )*col___0 + 1);
    }
  }
#line 427
  goto switch_break;
  case_5: /* CIL Label */ 
#line 429
  if (allow_off_screen) {
#line 430
    *row___0 = (short )((int )*row___0 + 1);
#line 431
    *col___0 = (short )((int )*col___0 - 1);
  } else
#line 429
  if ((int )*row___0 < 22) {
#line 429
    if ((int )*col___0 > 0) {
#line 430
      *row___0 = (short )((int )*row___0 + 1);
#line 431
      *col___0 = (short )((int )*col___0 - 1);
    }
  }
#line 433
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 437 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int get_hit_chance(object const   *weapon ) 
{ 
  short hit_chance ;
  int tmp ;

  {
  {
#line 443
  hit_chance = (short)40;
#line 444
  tmp = to_hit(weapon);
#line 444
  hit_chance = (short )((int )hit_chance + 3 * tmp);
#line 445
  hit_chance = (short )((int )hit_chance + ((2 * (int )rogue.exp + 2 * (int )ring_exp) - (int )r_rings));
  }
#line 446
  return ((int )hit_chance);
}
}
#line 449 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
int get_weapon_damage(object const   *weapon ) 
{ 
  short damage ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 455
  tmp = get_w_damage(weapon);
#line 455
  damage = (short )tmp;
#line 456
  tmp___0 = damage_for_strength();
#line 456
  damage = (short )((int )damage + tmp___0);
#line 457
  damage = (short )((int )damage + ((((int )rogue.exp + (int )ring_exp) - (int )r_rings) + 1) / 2);
  }
#line 458
  return ((int )damage);
}
}
#line 461 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/hit.c"
void s_con_mon(object *monster ) 
{ 
  int tmp ;

  {
#line 465
  if (con_mon) {
    {
#line 466
    monster->m_flags |= 512UL;
#line 467
    tmp = get_rand(12, 22);
#line 467
    monster->hit_enchant = (short )((int )monster->hit_enchant + tmp);
#line 468
    message("the monster appears confused", (char)0);
#line 469
    con_mon = (char)0;
    }
  }
#line 471
  return;
}
}
#line 342 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
unsigned short dungeon[24][80]  ;
#line 343 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object level_objects  ;
#line 467
void assign_damage(object *obj ) ;
#line 540
void gr_armor(object *obj ) ;
#line 543
void gr_potion(object *obj ) ;
#line 547
void gr_scroll(object *obj ) ;
#line 548
void gr_wand(object *obj ) ;
#line 549
void gr_weapon(object *obj , int assign_wk ) ;
#line 583
void make_party(void) ;
#line 632
void plant_gold(short row___0 , short col___0 , char is_maze ) ;
#line 641
void put_gold(void) ;
#line 656
void rand_place(object *obj ) ;
#line 739
unsigned short gr_what_is(void) ;
#line 788
short foods ;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
short foods  =    (short)0;
#line 61 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
object *free_list  =    (object *)0;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
char *fruit  =    (char *)0;
#line 64 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
fighter rogue  = 
#line 64
     {(object *)0, (object *)0, (object *)0, (object *)0, (short)12, (short)12, (short)16,
    (short)16, {0UL, (char const   *)0, (short)0, (short)0, (short)0, (short)0, (short)0,
                (short)0, (short)0, (unsigned short)0, (short)0, (short)0, (short)0,
                (short)0, (short)0, (short)0, (short)0, (short)0, (short)0, (short)0,
                (unsigned short)0, (short)0, (unsigned short)0, (struct obj *)0},
    0L, (short)1, 0L, (short)0, (short)0, (short )'@', (short)1250};
#line 82 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_potions[14]  = 
#line 82
  {      {(short)100, {(char )'b', (char )'l', (char )'u', (char )'e', (char )' ', (char )'\000',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of increase strength ",
      (unsigned short)0}, 
        {(short)250, {(char )'r', (char )'e', (char )'d', (char )' ', (char )'\000',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of restore strength ", (unsigned short)0}, 
        {(short)100, {(char )'g', (char )'r', (char )'e', (char )'e', (char )'n', (char )' ',
                   (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of healing ", (unsigned short)0}, 
        {(short)200, {(char )'g', (char )'r', (char )'e', (char )'y', (char )' ', (char )'\000',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of extra healing ",
      (unsigned short)0}, 
        {(short)10, {(char )'b', (char )'r', (char )'o', (char )'w', (char )'n', (char )' ',
                  (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of poison ",
      (unsigned short)0}, 
        {(short)300, {(char )'c', (char )'l', (char )'e', (char )'a', (char )'r', (char )' ',
                   (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of raise level ", (unsigned short)0}, 
        {(short)10, {(char )'p', (char )'i', (char )'n', (char )'k', (char )' ', (char )'\000',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of blindness ",
      (unsigned short)0}, 
        {(short)25, {(char )'w', (char )'h', (char )'i', (char )'t', (char )'e', (char )' ',
                  (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of hallucination ",
      (unsigned short)0}, 
        {(short)100, {(char )'p', (char )'u', (char )'r', (char )'p', (char )'l', (char )'e',
                   (char )' ', (char )'\000', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of detect monster ", (unsigned short)0}, 
        {(short)100, {(char )'b', (char )'l', (char )'a', (char )'c', (char )'k', (char )' ',
                   (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of detect things ", (unsigned short)0}, 
        {(short)10, {(char )'y', (char )'e', (char )'l', (char )'l', (char )'o', (char )'w',
                  (char )' ', (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of confusion ",
      (unsigned short)0}, 
        {(short)80, {(char )'p', (char )'l', (char )'a', (char )'i', (char )'d', (char )' ',
                  (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of levitation ",
      (unsigned short)0}, 
        {(short)150, {(char )'b', (char )'u', (char )'r', (char )'g', (char )'u', (char )'n',
                   (char )'d', (char )'y', (char )' ', (char )'\000', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of haste self ", (unsigned short)0}, 
        {(short)145, {(char )'b', (char )'e', (char )'i', (char )'g', (char )'e', (char )' ',
                   (char )'\000', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of see invisible ", (unsigned short)0}};
#line 99 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_scrolls[13]  = 
#line 99
  {      {(short)505, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of protect armor ", (unsigned short)0}, 
        {(short)200, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of hold monster ", (unsigned short)0}, 
        {(short)235, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of enchant weapon ", (unsigned short)0}, 
        {(short)235, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of enchant armor ", (unsigned short)0}, 
        {(short)175, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of identify ", (unsigned short)0}, 
        {(short)190, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of teleportation ", (unsigned short)0}, 
        {(short)25, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of sleep ", (unsigned short)0}, 
        {(short)610, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of scare monster ", (unsigned short)0}, 
        {(short)210, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of remove curse ", (unsigned short)0}, 
        {(short)80, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of create monster ", (unsigned short)0}, 
        {(short)25, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of aggravate monster ", (unsigned short)0}, 
        {(short)180, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of magic mapping ", (unsigned short)0}, 
        {(short)90, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )'\000'},
      "of confuse monster ", (unsigned short)0}};
#line 115 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_weapons[8]  = 
#line 115
  {      {(short)150, {(char )'s', (char )'h', (char )'o', (char )'r', (char )'t', (char )' ',
                   (char )'b', (char )'o', (char )'w', (char )' ', (char )'\000'},
      "", (unsigned short)0}, 
        {(short)8, {(char )'d', (char )'a', (char )'r', (char )'t', (char )'s', (char )' ',
                 (char )'\000'}, "", (unsigned short)0}, 
        {(short)15, {(char )'a', (char )'r', (char )'r', (char )'o', (char )'w', (char )'s',
                  (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)27, {(char )'d', (char )'a', (char )'g', (char )'g', (char )'e', (char )'r',
                  (char )'s', (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)35, {(char )'s', (char )'h', (char )'u', (char )'r', (char )'i', (char )'k',
                  (char )'e', (char )'n', (char )'s', (char )' ', (char )'\000'},
      "", (unsigned short)0}, 
        {(short)360, {(char )'m', (char )'a', (char )'c', (char )'e', (char )' ', (char )'\000'},
      "", (unsigned short)0}, 
        {(short)470, {(char )'l', (char )'o', (char )'n', (char )'g', (char )' ', (char )'s',
                   (char )'w', (char )'o', (char )'r', (char )'d', (char )' ', (char )'\000'},
      "", (unsigned short)0}, 
        {(short)580, {(char )'t', (char )'w', (char )'o', (char )'-', (char )'h', (char )'a',
                   (char )'n', (char )'d', (char )'e', (char )'d', (char )' ', (char )'s',
                   (char )'w', (char )'o', (char )'r', (char )'d', (char )' ', (char )'\000'},
      "", (unsigned short)0}};
#line 126 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_armors[7]  = {      {(short)300, {(char )'l', (char )'e', (char )'a', (char )'t', (char )'h', (char )'e',
                   (char )'r', (char )' ', (char )'a', (char )'r', (char )'m', (char )'o',
                   (char )'r', (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)300,
      {(char )'r', (char )'i', (char )'n', (char )'g', (char )' ', (char )'m', (char )'a',
       (char )'i', (char )'l', (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)400,
      {(char )'s', (char )'c', (char )'a', (char )'l', (char )'e', (char )' ', (char )'m',
       (char )'a', (char )'i', (char )'l', (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)500,
      {(char )'c', (char )'h', (char )'a', (char )'i', (char )'n', (char )' ', (char )'m',
       (char )'a', (char )'i', (char )'l', (char )' ', (char )'\000'}, "", (unsigned short)0}, 
        {(short)600,
      {(char )'b', (char )'a', (char )'n', (char )'d', (char )'e', (char )'d', (char )' ',
       (char )'m', (char )'a', (char )'i', (char )'l', (char )' ', (char )'\000'},
      "", (unsigned short)0}, 
        {(short)600, {(char )'s', (char )'p', (char )'l', (char )'i', (char )'n', (char )'t',
                   (char )' ', (char )'m', (char )'a', (char )'i', (char )'l', (char )' ',
                   (char )'\000'}, "", (unsigned short)0}, 
        {(short)700, {(char )'p', (char )'l', (char )'a', (char )'t', (char )'e', (char )' ',
                   (char )'m', (char )'a', (char )'i', (char )'l', (char )' ', (char )'\000'},
      "", (unsigned short)0}};
#line 136 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_wands[11]  = 
#line 136
  {      {(short)25, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of teleport away ",
      (unsigned short)0}, 
        {(short)50, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of slow monster ",
      (unsigned short)0}, 
        {(short)8, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )'\000'}, "of invisibility ",
      (unsigned short)0}, 
        {(short)55, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of polymorph ",
      (unsigned short)0}, 
        {(short)2, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )'\000'}, "of haste monster ",
      (unsigned short)0}, 
        {(short)20, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of magic missile ",
      (unsigned short)0}, 
        {(short)20, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of cancellation ",
      (unsigned short)0}, 
        {(short)0, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                 (char )' ', (char )' ', (char )' ', (char )'\000'}, "of do nothing ",
      (unsigned short)0}, 
        {(short)35, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of drain life ",
      (unsigned short)0}, 
        {(short)20, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of cold ",
      (unsigned short)0}, 
        {(short)20, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of fire ",
      (unsigned short)0}};
#line 150 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
struct id id_rings[11]  = 
#line 150
  {      {(short)250, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of stealth ",
      (unsigned short)0}, 
        {(short)100, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of teleportation ",
      (unsigned short)0}, 
        {(short)255, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of regeneration ",
      (unsigned short)0}, 
        {(short)295, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of slow digestion ",
      (unsigned short)0}, 
        {(short)200, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of add strength ",
      (unsigned short)0}, 
        {(short)250, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of sustain strength ",
      (unsigned short)0}, 
        {(short)250, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of dexterity ",
      (unsigned short)0}, 
        {(short)25, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                  (char )' ', (char )' ', (char )' ', (char )'\000'}, "of adornment ",
      (unsigned short)0}, 
        {(short)300, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of see invisible ",
      (unsigned short)0}, 
        {(short)290, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of maintain armor ",
      (unsigned short)0}, 
        {(short)270, {(char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )' ', (char )' ', (char )' ',
                   (char )' ', (char )' ', (char )' ', (char )'\000'}, "of searching ",
      (unsigned short)0}};
#line 164 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void put_objects(void) 
{ 
  short i ;
  short n___0 ;
  object *obj ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 170
  if ((int )cur_level < (int )max_level) {
#line 171
    return;
  }
  {
#line 173
  tmp___2 = coin_toss();
  }
#line 173
  if (tmp___2) {
    {
#line 173
    tmp___0 = get_rand(2, 4);
#line 173
    n___0 = (short )tmp___0;
    }
  } else {
    {
#line 173
    tmp___1 = get_rand(3, 5);
#line 173
    n___0 = (short )tmp___1;
    }
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    tmp___3 = rand_percent(33);
    }
#line 174
    if (! tmp___3) {
#line 174
      goto while_break;
    }
#line 175
    n___0 = (short )((int )n___0 + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if ((int )party_room != -1) {
    {
#line 178
    make_party();
    }
  }
#line 180
  i = (short)0;
  {
#line 180
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 180
    if (! ((int )i < (int )n___0)) {
#line 180
      goto while_break___0;
    }
    {
#line 181
    obj = gr_object();
#line 182
    rand_place(obj);
#line 180
    i = (short )((int )i + 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 184
  put_gold();
  }
#line 185
  return;
}
}
#line 187 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void put_gold(void) 
{ 
  short i ;
  short j ;
  short row___0 ;
  short col___0 ;
  char is_maze ;
  char is_room ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 194
  i = (short)0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! ((int )i < 9)) {
#line 194
      goto while_break;
    }
#line 195
    if ((int )rooms[i].is_room & 4) {
#line 195
      is_maze = (char)1;
    } else {
#line 195
      is_maze = (char)0;
    }
#line 196
    if ((int )rooms[i].is_room & 2) {
#line 196
      is_room = (char)1;
    } else {
#line 196
      is_room = (char)0;
    }
#line 198
    if (! is_room) {
#line 198
      if (! is_maze) {
#line 199
        goto __Cont;
      }
    }
#line 201
    if (is_maze) {
#line 201
      goto _L;
    } else {
      {
#line 201
      tmp___1 = rand_percent(46);
      }
#line 201
      if (tmp___1) {
        _L: /* CIL Label */ 
#line 202
        j = (short)0;
        {
#line 202
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 202
          if (! ((int )j < 50)) {
#line 202
            goto while_break___0;
          }
          {
#line 203
          tmp = get_rand((int )rooms[i].top_row + 1, (int )rooms[i].bottom_row - 1);
#line 203
          row___0 = (short )tmp;
#line 205
          tmp___0 = get_rand((int )rooms[i].left_col + 1, (int )rooms[i].right_col - 1);
#line 205
          col___0 = (short )tmp___0;
          }
#line 207
          if ((int )dungeon[row___0][col___0] == 64) {
            {
#line 209
            plant_gold((int )row___0, (int )col___0, is_maze);
            }
#line 210
            goto while_break___0;
          } else
#line 207
          if ((int )dungeon[row___0][col___0] == 128) {
            {
#line 209
            plant_gold((int )row___0, (int )col___0, is_maze);
            }
#line 210
            goto while_break___0;
          }
#line 202
          j = (short )((int )j + 1);
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 194
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 217 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void plant_gold(short row___0 , short col___0 , char is_maze ) 
{ 
  object *obj ;
  int tmp ;

  {
  {
#line 224
  obj = alloc_object();
#line 225
  obj->row = row___0;
#line 225
  obj->col = col___0;
#line 226
  obj->what_is = (unsigned short)16;
#line 227
  tmp = get_rand(2 * (int )cur_level, 16 * (int )cur_level);
#line 227
  obj->quantity = (short )tmp;
  }
#line 228
  if (is_maze) {
#line 229
    obj->quantity = (short )((int )obj->quantity + (int )obj->quantity / 2);
  }
  {
#line 231
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 1);
#line 232
  add_to_pack(obj, & level_objects, 0);
  }
#line 233
  return;
}
}
#line 235 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void place_at(object *obj , int row___0 , int col___0 ) 
{ 


  {
  {
#line 240
  obj->row = (short )row___0;
#line 241
  obj->col = (short )col___0;
#line 242
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 1);
#line 243
  add_to_pack(obj, & level_objects, 0);
  }
#line 244
  return;
}
}
#line 246 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
object *object_at(object *pack , short row___0 , short col___0 ) 
{ 
  object *obj ;

  {
#line 251
  obj = (object *)0;
#line 253
  if ((int )dungeon[row___0][col___0] & 3) {
#line 254
    obj = pack->next_object;
    {
#line 256
    while (1) {
      while_continue: /* CIL Label */ ;
#line 256
      if (obj) {
#line 256
        if (! ((int )obj->row != (int )row___0)) {
#line 256
          if (! ((int )obj->col != (int )col___0)) {
#line 256
            goto while_break;
          }
        }
      } else {
#line 256
        goto while_break;
      }
#line 257
      obj = obj->next_object;
    }
    while_break: /* CIL Label */ ;
    }
#line 259
    if (! obj) {
      {
#line 260
      message("object_at(): inconsistent", (char)1);
      }
    }
  }
#line 263
  return (obj);
}
}
#line 266 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
object *get_letter_object(int ch ) 
{ 
  object *obj ;

  {
#line 272
  obj = rogue.pack.next_object;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (obj) {
#line 274
      if (! ((int )obj->ichar != ch)) {
#line 274
        goto while_break;
      }
    } else {
#line 274
      goto while_break;
    }
#line 275
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (obj);
}
}
#line 280 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void free_stuff(object *objlist ) 
{ 
  object *obj ;

  {
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! objlist->next_object) {
#line 286
      goto while_break;
    }
    {
#line 287
    obj = objlist->next_object;
#line 288
    objlist->next_object = (objlist->next_object)->next_object;
#line 290
    free_object(obj);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return;
}
}
#line 294 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
char const   *name_of(object const   *obj ) 
{ 
  char const   *retstring ;

  {
  {
#line 301
  if ((int const   )obj->what_is == 4) {
#line 301
    goto case_4;
  }
#line 304
  if ((int const   )obj->what_is == 8) {
#line 304
    goto case_8;
  }
#line 307
  if ((int const   )obj->what_is == 32) {
#line 307
    goto case_32;
  }
#line 314
  if ((int const   )obj->what_is == 64) {
#line 314
    goto case_64;
  }
#line 317
  if ((int const   )obj->what_is == 2) {
#line 317
    goto case_2;
  }
#line 335
  if ((int const   )obj->what_is == 1) {
#line 335
    goto case_1___0;
  }
#line 338
  if ((int const   )obj->what_is == 128) {
#line 338
    goto case_128;
  }
#line 341
  if ((int const   )obj->what_is == 256) {
#line 341
    goto case_256;
  }
#line 344
  goto switch_default___0;
  case_4: /* CIL Label */ 
#line 302
  if ((int const   )obj->quantity > 1) {
#line 302
    retstring = "scrolls ";
  } else {
#line 302
    retstring = "scroll ";
  }
#line 303
  goto switch_break;
  case_8: /* CIL Label */ 
#line 305
  if ((int const   )obj->quantity > 1) {
#line 305
    retstring = "potions ";
  } else {
#line 305
    retstring = "potion ";
  }
#line 306
  goto switch_break;
  case_32: /* CIL Label */ 
#line 308
  if ((int const   )obj->which_kind == 0) {
#line 309
    retstring = "food ";
  } else {
#line 311
    retstring = (char const   *)fruit;
  }
#line 313
  goto switch_break;
  case_64: /* CIL Label */ 
#line 315
  if (is_wood[obj->which_kind]) {
#line 315
    retstring = "staff ";
  } else {
#line 315
    retstring = "wand ";
  }
#line 316
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 319
  if ((int const   )obj->which_kind == 1) {
#line 319
    goto case_1;
  }
#line 322
  if ((int const   )obj->which_kind == 2) {
#line 322
    goto case_2___0;
  }
#line 325
  if ((int const   )obj->which_kind == 3) {
#line 325
    goto case_3;
  }
#line 328
  if ((int const   )obj->which_kind == 4) {
#line 328
    goto case_4___0;
  }
#line 331
  goto switch_default;
  case_1: /* CIL Label */ 
#line 320
  if ((int const   )obj->quantity > 1) {
#line 320
    retstring = "darts ";
  } else {
#line 320
    retstring = "dart ";
  }
#line 321
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 323
  if ((int const   )obj->quantity > 1) {
#line 323
    retstring = "arrows ";
  } else {
#line 323
    retstring = "arrow ";
  }
#line 324
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 326
  if ((int const   )obj->quantity > 1) {
#line 326
    retstring = "daggers ";
  } else {
#line 326
    retstring = "dagger ";
  }
#line 327
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 329
  if ((int const   )obj->quantity > 1) {
#line 329
    retstring = "shurikens ";
  } else {
#line 329
    retstring = "shuriken ";
  }
#line 330
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 332
  retstring = (char const   *)(id_weapons[obj->which_kind].title);
  switch_break___0: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  case_1___0: /* CIL Label */ 
#line 336
  retstring = "armor ";
#line 337
  goto switch_break;
  case_128: /* CIL Label */ 
#line 339
  retstring = "ring ";
#line 340
  goto switch_break;
  case_256: /* CIL Label */ 
#line 342
  retstring = "amulet ";
#line 343
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 345
  retstring = "unknown ";
#line 346
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 348
  return (retstring);
}
}
#line 351 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
object *gr_object(void) 
{ 
  object *obj ;

  {
  {
#line 356
  obj = alloc_object();
  }
#line 358
  if ((int )foods < (int )cur_level / 3) {
#line 359
    obj->what_is = (unsigned short)32;
#line 360
    foods = (short )((int )foods + 1);
  } else {
    {
#line 362
    obj->what_is = gr_what_is();
    }
  }
  {
#line 365
  if ((int )obj->what_is == 4) {
#line 365
    goto case_4;
  }
#line 368
  if ((int )obj->what_is == 8) {
#line 368
    goto case_8;
  }
#line 371
  if ((int )obj->what_is == 2) {
#line 371
    goto case_2;
  }
#line 374
  if ((int )obj->what_is == 1) {
#line 374
    goto case_1;
  }
#line 377
  if ((int )obj->what_is == 64) {
#line 377
    goto case_64;
  }
#line 380
  if ((int )obj->what_is == 32) {
#line 380
    goto case_32;
  }
#line 383
  if ((int )obj->what_is == 128) {
#line 383
    goto case_128;
  }
#line 364
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 366
  gr_scroll(obj);
  }
#line 367
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 369
  gr_potion(obj);
  }
#line 370
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 372
  gr_weapon(obj, 1);
  }
#line 373
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 375
  gr_armor(obj);
  }
#line 376
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 378
  gr_wand(obj);
  }
#line 379
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 381
  get_food(obj, (char)0);
  }
#line 382
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 384
  gr_ring(obj, (char)1);
  }
#line 385
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 387
  return (obj);
}
}
#line 390 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
unsigned short gr_what_is(void) 
{ 
  short percent ;
  unsigned short what_is ;
  int tmp ;

  {
  {
#line 396
  tmp = get_rand(1, 91);
#line 396
  percent = (short )tmp;
  }
#line 398
  if ((int )percent <= 30) {
#line 399
    what_is = (unsigned short)4;
  } else
#line 400
  if ((int )percent <= 60) {
#line 401
    what_is = (unsigned short)8;
  } else
#line 402
  if ((int )percent <= 64) {
#line 403
    what_is = (unsigned short)64;
  } else
#line 404
  if ((int )percent <= 74) {
#line 405
    what_is = (unsigned short)2;
  } else
#line 406
  if ((int )percent <= 83) {
#line 407
    what_is = (unsigned short)1;
  } else
#line 408
  if ((int )percent <= 88) {
#line 409
    what_is = (unsigned short)32;
  } else {
#line 411
    what_is = (unsigned short)128;
  }
#line 413
  return (what_is);
}
}
#line 416 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void gr_scroll(object *obj ) 
{ 
  short percent ;
  int tmp ;

  {
  {
#line 422
  tmp = get_rand(0, 91);
#line 422
  percent = (short )tmp;
#line 424
  obj->what_is = (unsigned short)4;
  }
#line 426
  if ((int )percent <= 5) {
#line 427
    obj->which_kind = (unsigned short)0;
  } else
#line 428
  if ((int )percent <= 10) {
#line 429
    obj->which_kind = (unsigned short)1;
  } else
#line 430
  if ((int )percent <= 20) {
#line 431
    obj->which_kind = (unsigned short)9;
  } else
#line 432
  if ((int )percent <= 35) {
#line 433
    obj->which_kind = (unsigned short)4;
  } else
#line 434
  if ((int )percent <= 43) {
#line 435
    obj->which_kind = (unsigned short)5;
  } else
#line 436
  if ((int )percent <= 50) {
#line 437
    obj->which_kind = (unsigned short)6;
  } else
#line 438
  if ((int )percent <= 55) {
#line 439
    obj->which_kind = (unsigned short)7;
  } else
#line 440
  if ((int )percent <= 64) {
#line 441
    obj->which_kind = (unsigned short)8;
  } else
#line 442
  if ((int )percent <= 69) {
#line 443
    obj->which_kind = (unsigned short)3;
  } else
#line 444
  if ((int )percent <= 74) {
#line 445
    obj->which_kind = (unsigned short)2;
  } else
#line 446
  if ((int )percent <= 80) {
#line 447
    obj->which_kind = (unsigned short)10;
  } else
#line 448
  if ((int )percent <= 86) {
#line 449
    obj->which_kind = (unsigned short)12;
  } else {
#line 451
    obj->which_kind = (unsigned short)11;
  }
#line 453
  return;
}
}
#line 455 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void gr_potion(object *obj ) 
{ 
  short percent ;
  int tmp ;

  {
  {
#line 461
  tmp = get_rand(1, 118);
#line 461
  percent = (short )tmp;
#line 463
  obj->what_is = (unsigned short)8;
  }
#line 465
  if ((int )percent <= 5) {
#line 466
    obj->which_kind = (unsigned short)5;
  } else
#line 467
  if ((int )percent <= 15) {
#line 468
    obj->which_kind = (unsigned short)9;
  } else
#line 469
  if ((int )percent <= 25) {
#line 470
    obj->which_kind = (unsigned short)8;
  } else
#line 471
  if ((int )percent <= 35) {
#line 472
    obj->which_kind = (unsigned short)0;
  } else
#line 473
  if ((int )percent <= 45) {
#line 474
    obj->which_kind = (unsigned short)1;
  } else
#line 475
  if ((int )percent <= 55) {
#line 476
    obj->which_kind = (unsigned short)2;
  } else
#line 477
  if ((int )percent <= 65) {
#line 478
    obj->which_kind = (unsigned short)3;
  } else
#line 479
  if ((int )percent <= 75) {
#line 480
    obj->which_kind = (unsigned short)6;
  } else
#line 481
  if ((int )percent <= 85) {
#line 482
    obj->which_kind = (unsigned short)7;
  } else
#line 483
  if ((int )percent <= 95) {
#line 484
    obj->which_kind = (unsigned short)10;
  } else
#line 485
  if ((int )percent <= 105) {
#line 486
    obj->which_kind = (unsigned short)4;
  } else
#line 487
  if ((int )percent <= 110) {
#line 488
    obj->which_kind = (unsigned short)11;
  } else
#line 489
  if ((int )percent <= 114) {
#line 490
    obj->which_kind = (unsigned short)12;
  } else {
#line 492
    obj->which_kind = (unsigned short)13;
  }
#line 494
  return;
}
}
#line 496 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void gr_weapon(object *obj , int assign_wk ) 
{ 
  short percent ;
  short i ;
  short blessing ;
  short increment ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 505
  obj->what_is = (unsigned short)2;
#line 506
  if (assign_wk) {
    {
#line 507
    tmp = get_rand(0, 7);
#line 507
    obj->which_kind = (unsigned short )tmp;
    }
  }
#line 509
  if ((int )obj->which_kind == 2) {
    {
#line 511
    tmp___0 = get_rand(3, 15);
#line 511
    obj->quantity = (short )tmp___0;
#line 512
    tmp___1 = get_rand(0, 126);
#line 512
    obj->quiver = (short )tmp___1;
    }
  } else
#line 509
  if ((int )obj->which_kind == 3) {
    {
#line 511
    tmp___0 = get_rand(3, 15);
#line 511
    obj->quantity = (short )tmp___0;
#line 512
    tmp___1 = get_rand(0, 126);
#line 512
    obj->quiver = (short )tmp___1;
    }
  } else
#line 509
  if (((int )obj->which_kind == 4) | ((int )obj->which_kind == 1)) {
    {
#line 511
    tmp___0 = get_rand(3, 15);
#line 511
    obj->quantity = (short )tmp___0;
#line 512
    tmp___1 = get_rand(0, 126);
#line 512
    obj->quiver = (short )tmp___1;
    }
  } else {
#line 514
    obj->quantity = (short)1;
  }
  {
#line 516
  tmp___2 = (short)0;
#line 516
  obj->d_enchant = tmp___2;
#line 516
  obj->hit_enchant = tmp___2;
#line 518
  tmp___3 = get_rand(1, 96);
#line 518
  percent = (short )tmp___3;
#line 519
  tmp___4 = get_rand(1, 3);
#line 519
  blessing = (short )tmp___4;
  }
#line 521
  if ((int )percent <= 32) {
#line 522
    if ((int )percent <= 16) {
#line 523
      increment = (short)1;
    } else {
#line 525
      increment = (short)-1;
#line 526
      obj->is_cursed = (short)1;
    }
#line 528
    i = (short)0;
    {
#line 528
    while (1) {
      while_continue: /* CIL Label */ ;
#line 528
      if (! ((int )i < (int )blessing)) {
#line 528
        goto while_break;
      }
      {
#line 529
      tmp___5 = coin_toss();
      }
#line 529
      if (tmp___5) {
#line 530
        obj->hit_enchant = (short )((int )obj->hit_enchant + (int )increment);
      } else {
#line 532
        obj->d_enchant = (short )((int )obj->d_enchant + (int )increment);
      }
#line 528
      i = (short )((int )i + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 536
  assign_damage(obj);
  }
#line 537
  return;
}
}
#line 539 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void assign_damage(object *obj ) 
{ 


  {
  {
#line 545
  if ((int )obj->which_kind == 1) {
#line 545
    goto case_1;
  }
#line 545
  if ((int )obj->which_kind == 0) {
#line 545
    goto case_1;
  }
#line 548
  if ((int )obj->which_kind == 2) {
#line 548
    goto case_2;
  }
#line 551
  if ((int )obj->which_kind == 3) {
#line 551
    goto case_3;
  }
#line 554
  if ((int )obj->which_kind == 4) {
#line 554
    goto case_4;
  }
#line 557
  if ((int )obj->which_kind == 5) {
#line 557
    goto case_5;
  }
#line 560
  if ((int )obj->which_kind == 6) {
#line 560
    goto case_6;
  }
#line 563
  if ((int )obj->which_kind == 7) {
#line 563
    goto case_7;
  }
#line 566
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 546
  obj->damage = "1d1";
#line 547
  goto switch_break;
  case_2: /* CIL Label */ 
#line 549
  obj->damage = "1d2";
#line 550
  goto switch_break;
  case_3: /* CIL Label */ 
#line 552
  obj->damage = "1d3";
#line 553
  goto switch_break;
  case_4: /* CIL Label */ 
#line 555
  obj->damage = "1d4";
#line 556
  goto switch_break;
  case_5: /* CIL Label */ 
#line 558
  obj->damage = "2d3";
#line 559
  goto switch_break;
  case_6: /* CIL Label */ 
#line 561
  obj->damage = "3d4";
#line 562
  goto switch_break;
  case_7: /* CIL Label */ 
#line 564
  obj->damage = "4d5";
#line 565
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 567
  obj->damage = "1d1";
#line 568
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 572 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void gr_armor(object *obj ) 
{ 
  short percent ;
  short blessing ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 579
  obj->what_is = (unsigned short)1;
#line 580
  tmp = get_rand(0, 6);
#line 580
  obj->which_kind = (unsigned short )tmp;
#line 581
  obj->class = (short )((int )obj->which_kind + 2);
  }
#line 582
  if ((int )obj->which_kind == 6) {
#line 583
    obj->class = (short )((int )obj->class - 1);
  } else
#line 582
  if ((int )obj->which_kind == 5) {
#line 583
    obj->class = (short )((int )obj->class - 1);
  }
  {
#line 585
  obj->is_protected = (short)0;
#line 586
  obj->d_enchant = (short)0;
#line 588
  tmp___0 = get_rand(1, 100);
#line 588
  percent = (short )tmp___0;
#line 589
  tmp___1 = get_rand(1, 3);
#line 589
  blessing = (short )tmp___1;
  }
#line 591
  if ((int )percent <= 16) {
#line 592
    obj->is_cursed = (short)1;
#line 593
    obj->d_enchant = (short )((int )obj->d_enchant - (int )blessing);
  } else
#line 594
  if ((int )percent <= 33) {
#line 595
    obj->d_enchant = (short )((int )obj->d_enchant + (int )blessing);
  }
#line 597
  return;
}
}
#line 599 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void gr_wand(object *obj ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 603
  obj->what_is = (unsigned short)64;
#line 604
  tmp = get_rand(0, 10);
#line 604
  obj->which_kind = (unsigned short )tmp;
#line 605
  tmp___0 = get_rand(3, 7);
#line 605
  obj->class = (short )tmp___0;
  }
#line 606
  return;
}
}
#line 608 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void get_food(object *obj , char force_ration ) 
{ 
  int tmp ;

  {
#line 613
  obj->what_is = (unsigned short)32;
#line 615
  if (force_ration) {
#line 616
    obj->which_kind = (unsigned short)0;
  } else {
    {
#line 615
    tmp = rand_percent(80);
    }
#line 615
    if (tmp) {
#line 616
      obj->which_kind = (unsigned short)0;
    } else {
#line 618
      obj->which_kind = (unsigned short)1;
    }
  }
#line 620
  return;
}
}
#line 622 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void put_stairs(void) 
{ 
  short row___0 ;
  short col___0 ;

  {
  {
#line 627
  gr_row_col(& row___0, & col___0, (unsigned short)192);
#line 628
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 4);
  }
#line 629
  return;
}
}
#line 631 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
int get_armor_class(object const   *obj ) 
{ 


  {
#line 635
  if (obj) {
#line 636
    return ((int )((int const   )obj->class + (int const   )obj->d_enchant));
  }
#line 638
  return (0);
}
}
#line 641 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
object *alloc_object(void) 
{ 
  object *obj ;
  char *tmp ;
  short tmp___0 ;

  {
#line 646
  if (free_list) {
#line 647
    obj = free_list;
#line 648
    free_list = free_list->next_object;
  } else {
    {
#line 649
    tmp = md_malloc((int )sizeof(object ));
#line 649
    obj = (object *)tmp;
    }
#line 649
    if (! obj) {
      {
#line 650
      message("cannot allocate object, saving game", (char)0);
#line 651
      save_into_file(error_file);
      }
    }
  }
#line 653
  obj->quantity = (short)1;
#line 654
  obj->ichar = (short )'L';
#line 655
  tmp___0 = (short)0;
#line 655
  obj->is_cursed = tmp___0;
#line 655
  obj->picked_up = tmp___0;
#line 656
  obj->in_use_flags = (unsigned short)0;
#line 657
  obj->identified = (short)0;
#line 658
  obj->damage = "1d1";
#line 659
  return (obj);
}
}
#line 662 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void free_object(object *obj ) 
{ 


  {
#line 666
  obj->next_object = free_list;
#line 667
  free_list = obj;
#line 668
  return;
}
}
#line 670 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void make_party(void) 
{ 
  short n___0 ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 675
  party_room = gr_room();
#line 677
  tmp___1 = rand_percent(99);
  }
#line 677
  if (tmp___1) {
    {
#line 677
    tmp___0 = party_objects((int )party_room);
#line 677
    n___0 = tmp___0;
    }
  } else {
#line 677
    n___0 = (short)11;
  }
  {
#line 678
  tmp___2 = rand_percent(99);
  }
#line 678
  if (tmp___2) {
    {
#line 679
    party_monsters((int )party_room, (int )n___0);
    }
  }
#line 681
  return;
}
}
#line 683 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void show_objects(void) 
{ 
  object *obj ;
  short mc ;
  short rc ;
  short row___0 ;
  short col___0 ;
  object *monster ;
  char tmp ;
  chtype tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 690
  obj = level_objects.next_object;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! obj) {
#line 692
      goto while_break;
    }
    {
#line 693
    row___0 = obj->row;
#line 694
    col___0 = obj->col;
#line 696
    tmp = get_mask_char(obj->what_is);
#line 696
    rc = (short )tmp;
    }
#line 698
    if ((int )dungeon[row___0][col___0] & 2) {
      {
#line 699
      monster = object_at(& level_monsters, row___0, col___0);
      }
#line 699
      if ((unsigned long )monster != (unsigned long )((void *)0)) {
#line 701
        monster->d_enchant = rc;
      }
    }
    {
#line 704
    tmp___2 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 704
    if (tmp___2 == -1) {
#line 704
      mc = (short )((chtype )-1);
    } else {
      {
#line 704
      tmp___1 = winch(stdscr);
#line 704
      mc = (short )tmp___1;
      }
    }
#line 705
    if ((int )mc < 65) {
#line 705
      goto _L___0;
    } else
#line 705
    if ((int )mc > 90) {
      _L___0: /* CIL Label */ 
#line 705
      if ((int )row___0 != (int )rogue.row) {
#line 705
        goto _L;
      } else
#line 705
      if ((int )col___0 != (int )rogue.col) {
        _L: /* CIL Label */ 
        {
#line 707
        tmp___3 = wmove(stdscr, (int )row___0, (int )col___0);
        }
#line 707
        if (! (tmp___3 == -1)) {
          {
#line 707
          waddch(stdscr, (chtype const   )rc);
          }
        }
      }
    }
#line 709
    obj = obj->next_object;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  monster = level_monsters.next_object;
  {
#line 714
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 714
    if (! monster) {
#line 714
      goto while_break___0;
    }
#line 715
    if (monster->m_flags & 4194304UL) {
      {
#line 716
      tmp___4 = wmove(stdscr, (int )monster->row, (int )monster->col);
      }
#line 716
      if (! (tmp___4 == -1)) {
        {
#line 716
        waddch(stdscr, (chtype const   )((int )monster->what_is));
        }
      }
    }
#line 718
    monster = monster->next_object;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 722 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void put_amulet(void) 
{ 
  object *obj ;

  {
  {
#line 727
  obj = alloc_object();
#line 728
  obj->what_is = (unsigned short)256;
#line 729
  rand_place(obj);
  }
#line 730
  return;
}
}
#line 732 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void rand_place(object *obj ) 
{ 
  short row___0 ;
  short col___0 ;

  {
  {
#line 738
  gr_row_col(& row___0, & col___0, (unsigned short)192);
#line 739
  place_at(obj, (int )row___0, (int )col___0);
  }
#line 740
  return;
}
}
#line 742 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/object.c"
void c_object_for_wizard(void) 
{ 
  short ch ;
  short max ;
  short wk ;
  object *obj ;
  char buf[80] ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 749
  max = (short)0;
#line 750
  tmp = pack_count((object const   *)((object *)0));
  }
#line 750
  if ((int )tmp >= 24) {
    {
#line 751
    message("pack full", (char)0);
    }
#line 752
    return;
  }
  {
#line 754
  message("type of object?", (char)0);
  }
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 756
    tmp___0 = rgetchar();
#line 756
    ch = (short )tmp___0;
#line 756
    tmp___1 = r_index("!?:)]=/,\033", (int )ch, (char)0);
    }
#line 756
    if (! (tmp___1 == -1)) {
#line 756
      goto while_break;
    }
    {
#line 757
    sound_bell();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 759
  check_message();
  }
#line 761
  if ((int )ch == 27) {
#line 762
    return;
  }
  {
#line 764
  obj = alloc_object();
  }
  {
#line 767
  if ((int )ch == 33) {
#line 767
    goto case_33;
  }
#line 771
  if ((int )ch == 63) {
#line 771
    goto case_63;
  }
#line 775
  if ((int )ch == 44) {
#line 775
    goto case_44;
  }
#line 778
  if ((int )ch == 58) {
#line 778
    goto case_58;
  }
#line 781
  if ((int )ch == 41) {
#line 781
    goto case_41;
  }
#line 785
  if ((int )ch == 93) {
#line 785
    goto case_93;
  }
#line 789
  if ((int )ch == 47) {
#line 789
    goto case_47;
  }
#line 793
  if ((int )ch == 61) {
#line 793
    goto case_61;
  }
#line 766
  goto switch_break;
  case_33: /* CIL Label */ 
#line 768
  obj->what_is = (unsigned short)8;
#line 769
  max = (short)13;
#line 770
  goto switch_break;
  case_63: /* CIL Label */ 
#line 772
  obj->what_is = (unsigned short)4;
#line 773
  max = (short)12;
#line 774
  goto switch_break;
  case_44: /* CIL Label */ 
#line 776
  obj->what_is = (unsigned short)256;
#line 777
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 779
  get_food(obj, (char)0);
  }
#line 780
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 782
  gr_weapon(obj, 0);
#line 783
  max = (short)7;
  }
#line 784
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 786
  gr_armor(obj);
#line 787
  max = (short)6;
  }
#line 788
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 790
  gr_wand(obj);
#line 791
  max = (short)10;
  }
#line 792
  goto switch_break;
  case_61: /* CIL Label */ 
#line 794
  max = (short)10;
#line 795
  obj->what_is = (unsigned short)128;
#line 796
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 798
  if ((int )ch != 44) {
#line 798
    if ((int )ch != 58) {
      GIL: 
      {
#line 800
      tmp___3 = get_input_line("which kind?", "", buf, "", (char)0, (char)1);
      }
#line 800
      if (tmp___3) {
        {
#line 801
        tmp___2 = get_number((char const   *)(buf));
#line 801
        wk = (short )tmp___2;
        }
#line 802
        if ((int )wk >= 0) {
#line 802
          if ((int )wk <= (int )max) {
#line 803
            obj->which_kind = (unsigned short )wk;
#line 804
            if ((int )obj->what_is == 128) {
              {
#line 805
              gr_ring(obj, (char)0);
              }
            }
          } else {
            {
#line 808
            sound_bell();
            }
#line 809
            goto GIL;
          }
        } else {
          {
#line 808
          sound_bell();
          }
#line 809
          goto GIL;
        }
      } else {
        {
#line 812
        free_object(obj);
        }
#line 813
        return;
      }
    }
  }
  {
#line 816
  get_desc((object const   *)obj, buf);
#line 817
  message((char const   *)(buf), (char)0);
#line 818
  add_to_pack(obj, & rogue.pack, 1);
  }
#line 819
  return;
}
}
#line 552 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
char has_been_touched(struct rogue_time  const  *saved_time , struct rogue_time  const  *mod_time ) ;
#line 652
void r_read(FILE *fp , char *buf , int n___0 ) ;
#line 653
void r_write(FILE *fp , char const   *buf , int n___0 ) ;
#line 657
void read_pack(object *pack , FILE *fp , char is_rogue ) ;
#line 659
void read_string(char *s___0 , FILE *fp , size_t len ) ;
#line 675
void rw_dungeon(FILE *fp , char rw ) ;
#line 676
void rw_id(struct id *id_table , FILE *fp , int n___0 , char wr ) ;
#line 677
void rw_rooms(FILE *fp , char rw ) ;
#line 731
void write_pack(object const   *pack , FILE *fp ) ;
#line 732
void write_string(char *s___0 , FILE *fp ) ;
#line 59 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
short write_failed  =    (short)0;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
char *save_file  =    (char *)0;
#line 62 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void save_game(void) 
{ 
  char fname[64] ;
  int tmp ;

  {
  {
#line 67
  tmp = get_input_line("file name?", (char const   *)save_file, fname, "game not saved",
                       (char)0, (char)1);
  }
#line 67
  if (! tmp) {
#line 69
    return;
  }
  {
#line 71
  check_message();
#line 72
  message((char const   *)(fname), (char)0);
#line 73
  save_into_file((char const   *)(fname));
  }
#line 74
  return;
}
}
#line 76 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void save_into_file(char const   *sfile ) 
{ 
  FILE *fp ;
  int file_id ;
  char *name_buffer ;
  size_t len ;
  char *hptr ;
  struct rogue_time rt_buf ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 87
  if ((int const   )*(sfile + 0) == 126) {
    {
#line 88
    hptr = md_getenv("HOME");
    }
#line 88
    if ((unsigned long )hptr != (unsigned long )((void *)0)) {
      {
#line 89
      tmp = strlen((char const   *)hptr);
#line 89
      tmp___0 = strlen(sfile);
#line 89
      len = tmp + tmp___0;
#line 90
      name_buffer = md_malloc((int )len);
      }
#line 91
      if ((unsigned long )name_buffer == (unsigned long )((void *)0)) {
        {
#line 92
        message("out of memory for save file name", (char)0);
#line 93
        sfile = error_file;
        }
      } else {
        {
#line 95
        strcpy((char */* __restrict  */)name_buffer, (char const   */* __restrict  */)hptr);
#line 96
        strcat((char */* __restrict  */)name_buffer, (char const   */* __restrict  */)(sfile + 1));
#line 97
        sfile = (char const   *)name_buffer;
        }
      }
    }
  }
  {
#line 101
  fp = fopen((char const   */* __restrict  */)sfile, (char const   */* __restrict  */)"w");
  }
#line 101
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 103
    message("problem accessing the save file", (char)0);
    }
#line 104
    return;
  } else {
    {
#line 101
    file_id = md_get_file_id(sfile);
    }
#line 101
    if (file_id == -1) {
      {
#line 103
      message("problem accessing the save file", (char)0);
      }
#line 104
      return;
    }
  }
  {
#line 106
  md_ignore_signals();
#line 107
  write_failed = (short)0;
#line 108
  xxx((char)1);
#line 109
  r_write(fp, (char const   *)(& detect_monster), (int )sizeof(detect_monster));
#line 110
  r_write(fp, (char const   *)((char *)(& cur_level)), (int )sizeof(cur_level));
#line 111
  r_write(fp, (char const   *)((char *)(& max_level)), (int )sizeof(max_level));
#line 112
  write_string(hunger_str, fp);
#line 113
  write_string(login_name, fp);
#line 114
  r_write(fp, (char const   *)((char *)(& party_room)), (int )sizeof(party_room));
#line 115
  write_pack((object const   *)(& level_monsters), fp);
#line 116
  write_pack((object const   *)(& level_objects), fp);
#line 117
  r_write(fp, (char const   *)((char *)(& file_id)), (int )sizeof(file_id));
#line 118
  rw_dungeon(fp, (char)1);
#line 119
  r_write(fp, (char const   *)((char *)(& foods)), (int )sizeof(foods));
#line 120
  r_write(fp, (char const   *)((char *)(& rogue)), (int )sizeof(fighter ));
#line 121
  write_pack((object const   *)(& rogue.pack), fp);
#line 122
  rw_id(id_potions, fp, 14, (char)1);
#line 123
  rw_id(id_scrolls, fp, 13, (char)1);
#line 124
  rw_id(id_wands, fp, 11, (char)1);
#line 125
  rw_id(id_rings, fp, 11, (char)1);
#line 126
  r_write(fp, (char const   *)((char *)(traps)), (int )(10UL * sizeof(trap )));
#line 127
  r_write(fp, (char const   *)(is_wood), (int )(11UL * sizeof(char )));
#line 128
  r_write(fp, (char const   *)((char *)(& cur_room)), (int )sizeof(cur_room));
#line 129
  rw_rooms(fp, (char)1);
#line 130
  r_write(fp, (char const   *)(& being_held), (int )sizeof(being_held));
#line 131
  r_write(fp, (char const   *)((char *)(& bear_trap)), (int )sizeof(bear_trap));
#line 132
  r_write(fp, (char const   *)((char *)(& halluc)), (int )sizeof(halluc));
#line 133
  r_write(fp, (char const   *)((char *)(& blind)), (int )sizeof(blind));
#line 134
  r_write(fp, (char const   *)((char *)(& confused)), (int )sizeof(confused));
#line 135
  r_write(fp, (char const   *)((char *)(& levitate)), (int )sizeof(levitate));
#line 136
  r_write(fp, (char const   *)((char *)(& haste_self)), (int )sizeof(haste_self));
#line 137
  r_write(fp, (char const   *)(& see_invisible), (int )sizeof(see_invisible));
#line 138
  r_write(fp, (char const   *)(& detect_monster), (int )sizeof(detect_monster));
#line 139
  r_write(fp, (char const   *)(& wizard), (int )sizeof(wizard));
#line 140
  r_write(fp, (char const   *)(& score_only), (int )sizeof(score_only));
#line 141
  r_write(fp, (char const   *)((char *)(& m_moves)), (int )sizeof(m_moves));
#line 142
  md_gct(& rt_buf);
#line 143
  rt_buf.second = (short )((int )rt_buf.second + 10);
#line 144
  r_write(fp, (char const   *)((char *)(& rt_buf)), (int )sizeof(rt_buf));
#line 145
  fclose(fp);
  }
#line 147
  if (write_failed) {
    {
#line 148
    md_df(sfile);
    }
  } else {
    {
#line 150
    clean_up("");
    }
  }
#line 152
  return;
}
}
#line 154 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void restore(char const   *fname ) 
{ 
  FILE *fp ;
  struct rogue_time saved_time ;
  struct rogue_time mod_time ;
  char buf[4] ;
  char tbuf[40] ;
  int new_file_id ;
  int saved_file_id ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char tmp___2 ;
  char tmp___3 ;

  {
  {
#line 164
  fp = (FILE *)((void *)0);
#line 165
  new_file_id = md_get_file_id(fname);
  }
#line 165
  if (new_file_id == -1) {
    {
#line 167
    clean_up("cannot open file");
    }
  } else {
    {
#line 165
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 165
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 167
      clean_up("cannot open file");
      }
    }
  }
  {
#line 169
  tmp = md_link_count(fname);
  }
#line 169
  if (tmp > 1) {
    {
#line 170
    clean_up("file has link");
    }
  }
  {
#line 172
  xxx((char)1);
#line 173
  r_read(fp, & detect_monster, (int )sizeof(detect_monster));
#line 174
  r_read(fp, (char *)(& cur_level), (int )sizeof(cur_level));
#line 175
  r_read(fp, (char *)(& max_level), (int )sizeof(max_level));
#line 176
  read_string(hunger_str, fp, sizeof(hunger_str));
#line 178
  strlcpy(tbuf, (char const   *)(login_name), sizeof(tbuf));
#line 179
  read_string(login_name, fp, sizeof(login_name));
#line 180
  tmp___0 = strcmp((char const   *)(tbuf), (char const   *)(login_name));
  }
#line 180
  if (tmp___0) {
    {
#line 181
    clean_up("you\'re not the original player");
    }
  }
  {
#line 184
  r_read(fp, (char *)(& party_room), (int )sizeof(party_room));
#line 185
  read_pack(& level_monsters, fp, (char)0);
#line 186
  read_pack(& level_objects, fp, (char)0);
#line 187
  r_read(fp, (char *)(& saved_file_id), (int )sizeof(saved_file_id));
  }
#line 188
  if (new_file_id != saved_file_id) {
    {
#line 189
    clean_up("sorry, saved game is not in the same file");
    }
  }
  {
#line 191
  rw_dungeon(fp, (char)0);
#line 192
  r_read(fp, (char *)(& foods), (int )sizeof(foods));
#line 193
  r_read(fp, (char *)(& rogue), (int )sizeof(fighter ));
#line 194
  read_pack(& rogue.pack, fp, (char)1);
#line 195
  rw_id(id_potions, fp, 14, (char)0);
#line 196
  rw_id(id_scrolls, fp, 13, (char)0);
#line 197
  rw_id(id_wands, fp, 11, (char)0);
#line 198
  rw_id(id_rings, fp, 11, (char)0);
#line 199
  r_read(fp, (char *)(traps), (int )(10UL * sizeof(trap )));
#line 200
  r_read(fp, is_wood, (int )(11UL * sizeof(char )));
#line 201
  r_read(fp, (char *)(& cur_room), (int )sizeof(cur_room));
#line 202
  rw_rooms(fp, (char)0);
#line 203
  r_read(fp, & being_held, (int )sizeof(being_held));
#line 204
  r_read(fp, (char *)(& bear_trap), (int )sizeof(bear_trap));
#line 205
  r_read(fp, (char *)(& halluc), (int )sizeof(halluc));
#line 206
  r_read(fp, (char *)(& blind), (int )sizeof(blind));
#line 207
  r_read(fp, (char *)(& confused), (int )sizeof(confused));
#line 208
  r_read(fp, (char *)(& levitate), (int )sizeof(levitate));
#line 209
  r_read(fp, (char *)(& haste_self), (int )sizeof(haste_self));
#line 210
  r_read(fp, & see_invisible, (int )sizeof(see_invisible));
#line 211
  r_read(fp, & detect_monster, (int )sizeof(detect_monster));
#line 212
  r_read(fp, & wizard, (int )sizeof(wizard));
#line 213
  r_read(fp, & score_only, (int )sizeof(score_only));
#line 214
  r_read(fp, (char *)(& m_moves), (int )sizeof(m_moves));
#line 215
  r_read(fp, (char *)(& saved_time), (int )sizeof(saved_time));
#line 217
  tmp___1 = fread((void */* __restrict  */)(buf), sizeof(char ), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 217
  if (tmp___1 > 0UL) {
    {
#line 218
    wclear(stdscr);
#line 219
    clean_up("extra characters in file");
    }
  }
  {
#line 222
  md_gfmt(fname, & mod_time);
#line 224
  tmp___2 = has_been_touched((struct rogue_time  const  *)(& saved_time), (struct rogue_time  const  *)(& mod_time));
  }
#line 224
  if (tmp___2) {
    {
#line 225
    wclear(stdscr);
#line 226
    clean_up("sorry, file has been touched");
    }
  }
#line 228
  if (! wizard) {
    {
#line 228
    tmp___3 = md_df(fname);
    }
#line 228
    if (! tmp___3) {
      {
#line 229
      clean_up("cannot delete file");
      }
    }
  }
  {
#line 231
  msg_cleared = (char)0;
#line 232
  ring_stats((char)0);
#line 233
  fclose(fp);
  }
#line 234
  return;
}
}
#line 236 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void write_pack(object const   *pack , FILE *fp ) 
{ 
  object t ;

  {
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    pack = (object const   *)pack->next_object;
#line 243
    if (! ((unsigned long )pack != (unsigned long )((void *)0))) {
#line 243
      goto while_break;
    }
    {
#line 244
    r_write(fp, (char const   *)pack, (int )sizeof(object ));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  t.what_is = (unsigned short)0;
#line 246
  t.ichar = (short )t.what_is;
#line 247
  r_write(fp, (char const   *)(& t), (int )sizeof(object ));
  }
#line 248
  return;
}
}
#line 250 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void read_pack(object *pack , FILE *fp , char is_rogue ) 
{ 
  object read_obj ;
  object *new_obj ;
  int tmp ;

  {
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 259
    r_read(fp, (char *)(& read_obj), (int )sizeof(object ));
    }
#line 260
    if ((int )read_obj.ichar == 0) {
#line 261
      pack->next_object = (object *)0;
#line 262
      goto while_break;
    }
    {
#line 264
    new_obj = alloc_object();
#line 265
    *new_obj = read_obj;
#line 269
    assign_damage(new_obj);
    }
#line 270
    if (is_rogue) {
#line 271
      if ((int )new_obj->in_use_flags & 2) {
        {
#line 272
        do_wear(new_obj);
        }
      } else
#line 273
      if ((int )new_obj->in_use_flags & 1) {
        {
#line 274
        do_wield(new_obj);
        }
      } else
#line 275
      if ((int )new_obj->in_use_flags & 12) {
#line 276
        if ((int )new_obj->in_use_flags & 4) {
#line 276
          tmp = 1;
        } else {
#line 276
          tmp = 0;
        }
        {
#line 276
        do_put_on(new_obj, (char )tmp);
        }
      }
    }
#line 280
    pack->next_object = new_obj;
#line 281
    pack = new_obj;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 285 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void rw_dungeon(FILE *fp , char rw ) 
{ 
  short i ;
  short j ;
  char buf[80] ;
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 293
  i = (short)0;
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
#line 293
    if (! ((int )i < 24)) {
#line 293
      goto while_break;
    }
#line 294
    if (rw) {
      {
#line 295
      r_write(fp, (char const   *)((char *)(dungeon[i])), (int )(80UL * sizeof(dungeon[0][0])));
#line 296
      j = (short)0;
      }
      {
#line 296
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 296
        if (! ((int )j < 80)) {
#line 296
          goto while_break___0;
        }
        {
#line 297
        tmp___1 = wmove(stdscr, (int )i, (int )j);
        }
#line 297
        if (tmp___1 == -1) {
#line 297
          buf[j] = (char )((chtype )-1);
        } else {
          {
#line 297
          tmp___0 = winch(stdscr);
#line 297
          buf[j] = (char )tmp___0;
          }
        }
#line 296
        j = (short )((int )j + 1);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 299
      r_write(fp, (char const   *)(buf), 80);
      }
    } else {
      {
#line 301
      r_read(fp, (char *)(dungeon[i]), (int )(80UL * sizeof(dungeon[0][0])));
#line 302
      r_read(fp, buf, 80);
#line 303
      j = (short)0;
      }
      {
#line 303
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 303
        if (! ((int )j < 80)) {
#line 303
          goto while_break___1;
        }
        {
#line 304
        tmp___2 = wmove(stdscr, (int )i, (int )j);
        }
#line 304
        if (! (tmp___2 == -1)) {
          {
#line 304
          waddch(stdscr, (chtype const   )buf[j]);
          }
        }
#line 303
        j = (short )((int )j + 1);
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 293
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return;
}
}
#line 310 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void rw_id(struct id *id_table , FILE *fp , int n___0 , char wr ) 
{ 
  short i ;

  {
#line 319
  i = (short)0;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((int )i < n___0)) {
#line 319
      goto while_break;
    }
#line 320
    if (wr) {
      {
#line 321
      r_write(fp, (char const   *)(& (id_table + i)->value), (int )sizeof(short ));
#line 322
      r_write(fp, (char const   *)(& (id_table + i)->id_status), (int )sizeof(unsigned short ));
#line 324
      write_string((id_table + i)->title, fp);
      }
    } else {
      {
#line 326
      r_read(fp, (char *)(& (id_table + i)->value), (int )sizeof(short ));
#line 327
      r_read(fp, (char *)(& (id_table + i)->id_status), (int )sizeof(unsigned short ));
#line 329
      read_string((id_table + i)->title, fp, (size_t )64);
      }
    }
#line 319
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return;
}
}
#line 334 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void write_string(char *s___0 , FILE *fp ) 
{ 
  short n___0 ;
  size_t tmp ;

  {
  {
#line 341
  tmp = strlen((char const   *)s___0);
#line 341
  n___0 = (short )(tmp + 1UL);
#line 342
  xxxx(s___0, n___0);
#line 343
  r_write(fp, (char const   *)((char *)(& n___0)), (int )sizeof(short ));
#line 344
  r_write(fp, (char const   *)s___0, (int )n___0);
  }
#line 345
  return;
}
}
#line 347 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void read_string(char *s___0 , FILE *fp , size_t len ) 
{ 
  short n___0 ;

  {
  {
#line 355
  r_read(fp, (char *)(& n___0), (int )sizeof(short ));
  }
#line 356
  if ((size_t )n___0 > len) {
    {
#line 357
    clean_up("read_string: corrupt game file");
    }
  }
  {
#line 358
  r_read(fp, s___0, (int )n___0);
#line 359
  xxxx(s___0, n___0);
  }
#line 360
  return;
}
}
#line 362 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void rw_rooms(FILE *fp , char rw ) 
{ 
  short i ;

  {
#line 369
  i = (short)0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! ((int )i < 9)) {
#line 369
      goto while_break;
    }
#line 370
    if (rw) {
      {
#line 370
      r_write(fp, (char const   *)((char *)(rooms + (int )i)), (int )sizeof(room ));
      }
    } else {
      {
#line 370
      r_read(fp, (char *)(rooms + (int )i), (int )sizeof(room ));
      }
    }
#line 369
    i = (short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  return;
}
}
#line 375 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void r_read(FILE *fp , char *buf , int n___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 381
  tmp = fread((void */* __restrict  */)buf, sizeof(char ), (size_t )n___0, (FILE */* __restrict  */)fp);
  }
#line 381
  if (tmp != (size_t )n___0) {
    {
#line 382
    clean_up("read() failed, don\'t know why");
    }
  }
#line 384
  return;
}
}
#line 386 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
void r_write(FILE *fp , char const   *buf , int n___0 ) 
{ 
  size_t tmp ;

  {
#line 392
  if (! write_failed) {
    {
#line 393
    tmp = fwrite((void const   */* __restrict  */)buf, sizeof(char ), (size_t )n___0,
                 (FILE */* __restrict  */)fp);
    }
#line 393
    if (tmp != (size_t )n___0) {
      {
#line 394
      message("write() failed, don\'t know why", (char)0);
#line 395
      sound_bell();
#line 396
      write_failed = (short)1;
      }
    }
  }
#line 399
  return;
}
}
#line 401 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/save.c"
char has_been_touched(struct rogue_time  const  *saved_time , struct rogue_time  const  *mod_time ) 
{ 


  {
#line 405
  if ((int const   )saved_time->year < (int const   )mod_time->year) {
#line 406
    return ((char)1);
  } else
#line 407
  if ((int const   )saved_time->year > (int const   )mod_time->year) {
#line 408
    return ((char)0);
  }
#line 410
  if ((int const   )saved_time->month < (int const   )mod_time->month) {
#line 411
    return ((char)1);
  } else
#line 412
  if ((int const   )saved_time->month > (int const   )mod_time->month) {
#line 413
    return ((char)0);
  }
#line 415
  if ((int const   )saved_time->day < (int const   )mod_time->day) {
#line 416
    return ((char)1);
  } else
#line 417
  if ((int const   )saved_time->day > (int const   )mod_time->day) {
#line 418
    return ((char)0);
  }
#line 420
  if ((int const   )saved_time->hour < (int const   )mod_time->hour) {
#line 421
    return ((char)1);
  } else
#line 422
  if ((int const   )saved_time->hour > (int const   )mod_time->hour) {
#line 423
    return ((char)0);
  }
#line 425
  if ((int const   )saved_time->minute < (int const   )mod_time->minute) {
#line 426
    return ((char)1);
  } else
#line 427
  if ((int const   )saved_time->minute > (int const   )mod_time->minute) {
#line 428
    return ((char)0);
  }
#line 430
  if ((int const   )saved_time->second < (int const   )mod_time->second) {
#line 431
    return ((char)1);
  }
#line 433
  return ((char)0);
}
}
#line 451 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/rogue.h"
object *get_zapped_monster(short dir , short *row___0 , short *col___0 ) ;
#line 705
void tele_away(object *monster ) ;
#line 726
void wdrain_life(object *monster ) ;
#line 735
void zap_monster(object *monster , unsigned short kind ) ;
#line 58 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
char wizard  =    (char)0;
#line 60 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void zapp(void) 
{ 
  short wch ;
  char first_miss ;
  object *wand ;
  short dir ;
  short d ;
  short row___0 ;
  short col___0 ;
  object *monster ;
  int tmp ;
  char tmp___0 ;

  {
#line 64
  first_miss = (char)1;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp = rgetchar();
#line 69
    dir = (short )tmp;
#line 69
    tmp___0 = is_direction(dir, & d);
    }
#line 69
    if (tmp___0) {
#line 69
      goto while_break;
    }
    {
#line 70
    sound_bell();
    }
#line 71
    if (first_miss) {
      {
#line 72
      message("direction? ", (char)0);
#line 73
      first_miss = (char)0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  check_message();
  }
#line 77
  if ((int )dir == 27) {
#line 78
    return;
  }
  {
#line 80
  wch = pack_letter("zap with what?", (unsigned short)64);
  }
#line 80
  if ((int )wch == 27) {
#line 81
    return;
  }
  {
#line 83
  check_message();
#line 85
  wand = get_letter_object((int )wch);
  }
#line 85
  if (! wand) {
    {
#line 86
    message("no such item.", (char)0);
    }
#line 87
    return;
  }
#line 89
  if ((int )wand->what_is != 64) {
    {
#line 90
    message("you can\'t zap with that", (char)0);
    }
#line 91
    return;
  }
#line 93
  if ((int )wand->class <= 0) {
    {
#line 94
    message("nothing happens", (char)0);
    }
  } else {
#line 96
    wand->class = (short )((int )wand->class - 1);
#line 97
    row___0 = rogue.row;
#line 97
    col___0 = rogue.col;
#line 98
    if ((int )wand->which_kind == 9) {
      {
#line 99
      bounce((short )wand->which_kind, d, row___0, col___0, (short)0);
      }
    } else
#line 98
    if ((int )wand->which_kind == 10) {
      {
#line 99
      bounce((short )wand->which_kind, d, row___0, col___0, (short)0);
      }
    } else {
      {
#line 101
      monster = get_zapped_monster(d, & row___0, & col___0);
      }
#line 102
      if ((int )wand->which_kind == 8) {
        {
#line 103
        wdrain_life(monster);
        }
      } else
#line 104
      if (monster) {
        {
#line 105
        wake_up(monster);
#line 106
        s_con_mon(monster);
#line 107
        zap_monster(monster, wand->which_kind);
#line 108
        relight();
        }
      }
    }
  }
  {
#line 112
  reg_move();
  }
#line 113
  return;
}
}
#line 115 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
object *get_zapped_monster(short dir , short *row___0 , short *col___0 ) 
{ 
  short orow ;
  short ocol ;
  object *tmp ;
  char tmp___0 ;

  {
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 123
    orow = *row___0;
#line 123
    ocol = *col___0;
#line 124
    get_dir_rc(dir, row___0, col___0, (short)0);
    }
#line 125
    if ((int )*row___0 == (int )orow) {
#line 125
      if ((int )*col___0 == (int )ocol) {
#line 128
        return ((object *)0);
      } else {
#line 125
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 125
    if ((int )dungeon[*row___0][*col___0] & 24) {
#line 128
      return ((object *)0);
    } else
#line 125
    if ((int )dungeon[*row___0][*col___0] == 0) {
#line 128
      return ((object *)0);
    }
#line 130
    if ((int )dungeon[*row___0][*col___0] & 2) {
      {
#line 131
      tmp___0 = imitating((int )*row___0, (int )*col___0);
      }
#line 131
      if (! tmp___0) {
        {
#line 132
        tmp = object_at(& level_monsters, *row___0, *col___0);
        }
#line 132
        return (tmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 138 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void zap_monster(object *monster , unsigned short kind ) 
{ 
  short row___0 ;
  short col___0 ;
  object *nm ;
  short tc ;
  int tmp ;

  {
#line 147
  row___0 = monster->row;
#line 148
  col___0 = monster->col;
  {
#line 151
  if ((int )kind == 1) {
#line 151
    goto case_1;
  }
#line 159
  if ((int )kind == 4) {
#line 159
    goto case_4;
  }
#line 166
  if ((int )kind == 0) {
#line 166
    goto case_0;
  }
#line 169
  if ((int )kind == 2) {
#line 169
    goto case_2;
  }
#line 172
  if ((int )kind == 3) {
#line 172
    goto case_3;
  }
#line 187
  if ((int )kind == 5) {
#line 187
    goto case_5;
  }
#line 190
  if ((int )kind == 6) {
#line 190
    goto case_6;
  }
#line 200
  if ((int )kind == 7) {
#line 200
    goto case_7;
  }
#line 150
  goto switch_break;
  case_1: /* CIL Label */ 
#line 152
  if (monster->m_flags & 1UL) {
#line 153
    monster->m_flags &= 0xfffffffffffffffeUL;
  } else {
#line 155
    monster->quiver = (short)0;
#line 156
    monster->m_flags |= 2UL;
  }
#line 158
  goto switch_break;
  case_4: /* CIL Label */ 
#line 160
  if (monster->m_flags & 2UL) {
#line 161
    monster->m_flags &= 0xfffffffffffffffdUL;
  } else {
#line 163
    monster->m_flags |= 1UL;
  }
#line 165
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 167
  tele_away(monster);
  }
#line 168
  goto switch_break;
  case_2: /* CIL Label */ 
#line 170
  monster->m_flags |= 4UL;
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
#line 173
  if (monster->m_flags & 2048UL) {
#line 174
    being_held = (char)0;
  }
  {
#line 176
  nm = monster->next_object;
#line 177
  tc = monster->d_enchant;
#line 178
  tmp = get_rand(0, 25);
#line 178
  gr_monster(monster, tmp);
#line 179
  monster->row = row___0;
#line 180
  monster->col = col___0;
#line 181
  monster->next_object = nm;
#line 182
  monster->d_enchant = tc;
  }
#line 183
  if (! (monster->m_flags & 4194304UL)) {
    {
#line 184
    wake_up(monster);
    }
  }
#line 186
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 188
  rogue_hit(monster, (char)1);
  }
#line 189
  goto switch_break;
  case_6: /* CIL Label */ 
#line 191
  if (monster->m_flags & 2048UL) {
#line 192
    being_held = (char)0;
  }
#line 194
  if (monster->m_flags & 16384UL) {
#line 195
    monster->which_kind = (unsigned short)0;
  }
#line 197
  monster->m_flags &= 0xffffffffff18033bUL;
#line 199
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 201
  message("nothing happens", (char)0);
  }
#line 202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 206 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void tele_away(object *monster ) 
{ 
  short row___0 ;
  short col___0 ;
  int tmp ;
  chtype tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 212
  if (monster->m_flags & 2048UL) {
#line 213
    being_held = (char)0;
  }
  {
#line 215
  gr_row_col(& row___0, & col___0, (unsigned short)197);
#line 216
  tmp = wmove(stdscr, (int )monster->row, (int )monster->col);
  }
#line 216
  if (! (tmp == -1)) {
    {
#line 216
    waddch(stdscr, (chtype const   )monster->d_enchant);
    }
  }
  {
#line 217
  dungeon[monster->row][monster->col] = (unsigned short )((int )dungeon[monster->row][monster->col] & -3);
#line 218
  monster->row = row___0;
#line 218
  monster->col = col___0;
#line 219
  dungeon[row___0][col___0] = (unsigned short )((int )dungeon[row___0][col___0] | 2);
#line 220
  tmp___2 = wmove(stdscr, (int )row___0, (int )col___0);
  }
#line 220
  if (tmp___2 == -1) {
#line 220
    monster->d_enchant = (short )((chtype )-1);
  } else {
    {
#line 220
    tmp___1 = winch(stdscr);
#line 220
    monster->d_enchant = (short )tmp___1;
    }
  }
#line 221
  if (detect_monster) {
#line 221
    goto _L;
  } else {
    {
#line 221
    tmp___5 = rogue_can_see((int )row___0, (int )col___0);
    }
#line 221
    if (tmp___5) {
      _L: /* CIL Label */ 
      {
#line 222
      tmp___4 = wmove(stdscr, (int )row___0, (int )col___0);
      }
#line 222
      if (! (tmp___4 == -1)) {
        {
#line 222
        tmp___3 = gmc(monster);
#line 222
        waddch(stdscr, (chtype const   )tmp___3);
        }
      }
    }
  }
#line 224
  return;
}
}
#line 226 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void wizardize(void) 
{ 
  char buf[100] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 231
  if (wizard) {
    {
#line 232
    wizard = (char)0;
#line 233
    message("not wizard anymore", (char)0);
    }
  } else {
    {
#line 235
    tmp___1 = get_input_line("wizard\'s password:", "", buf, "", (char)0, (char)0);
    }
#line 235
    if (tmp___1) {
      {
#line 236
      xxx((char)1);
#line 237
      tmp = strlen((char const   *)(buf));
#line 237
      xxxx(buf, (short )tmp);
#line 238
      tmp___0 = strncmp((char const   *)(buf), "\247DV\272M\243\027", (size_t )7);
      }
#line 238
      if (tmp___0) {
        {
#line 243
        message("sorry", (char)0);
        }
      } else {
        {
#line 239
        wizard = (char)1;
#line 240
        score_only = (char)1;
#line 241
        message("Welcome, mighty wizard!", (char)0);
        }
      }
    }
  }
#line 247
  return;
}
}
#line 249 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void wdrain_life(object *monster ) 
{ 
  short hp ;
  object *lmon ;
  object *nm ;
  short tmp ;

  {
#line 256
  hp = (short )((int )rogue.hp_current / 3);
#line 257
  rogue.hp_current = (short )(((int )rogue.hp_current + 1) / 2);
#line 259
  if ((int )cur_room >= 0) {
#line 260
    lmon = level_monsters.next_object;
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
#line 261
      if (! lmon) {
#line 261
        goto while_break;
      }
      {
#line 262
      nm = lmon->next_object;
#line 263
      tmp = get_room_number((int )lmon->row, (int )lmon->col);
      }
#line 263
      if ((int )tmp == (int )cur_room) {
        {
#line 264
        wake_up(lmon);
#line 265
        mon_damage(lmon, hp);
        }
      }
#line 267
      lmon = nm;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 270
  if (monster) {
    {
#line 271
    wake_up(monster);
#line 272
    mon_damage(monster, hp);
    }
  }
  {
#line 275
  print_stats(4);
#line 276
  relight();
  }
#line 277
  return;
}
}
#line 287 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
static short btime  ;
#line 279 "/home/june/collector/temp/bsdgames-nonfree-2.17/rogue/zap.c"
void bounce(short ball , short dir , short row___0 , short col___0 , short r ) 
{ 
  short orow ;
  short ocol ;
  char buf[80] ;
  char const   *s___0 ;
  short i ;
  short ch ;
  short new_dir ;
  short damage ;
  int tmp ;
  chtype tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  chtype tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  object *monster ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  short nrow ;
  short ncol ;
  int tmp___20 ;

  {
#line 286
  new_dir = (short)-1;
#line 289
  r = (short )((int )r + 1);
#line 289
  if ((int )r == 1) {
    {
#line 290
    tmp = get_rand(3, 6);
#line 290
    btime = (short )tmp;
    }
  } else
#line 291
  if ((int )r > (int )btime) {
#line 292
    return;
  }
#line 295
  if ((int )ball == 10) {
#line 296
    s___0 = "fire";
  } else {
#line 298
    s___0 = "ice";
  }
#line 300
  if ((int )r > 1) {
    {
#line 301
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s bounces",
            s___0);
#line 302
    message((char const   *)(buf), (char)0);
    }
  }
#line 304
  orow = row___0;
#line 305
  ocol = col___0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 307
    tmp___2 = wmove(stdscr, (int )orow, (int )ocol);
    }
#line 307
    if (tmp___2 == -1) {
#line 307
      ch = (short )((chtype )-1);
    } else {
      {
#line 307
      tmp___1 = winch(stdscr);
#line 307
      ch = (short )tmp___1;
      }
    }
#line 308
    if (stdscr) {
#line 308
      stdscr->_attrs = 1UL << 16;
    }
    {
#line 309
    tmp___3 = wmove(stdscr, (int )orow, (int )ocol);
    }
#line 309
    if (! (tmp___3 == -1)) {
      {
#line 309
      waddch(stdscr, (chtype const   )ch);
      }
    }
    {
#line 310
    get_dir_rc(dir, & orow, & ocol, (short)1);
    }
#line 306
    if ((int )ocol <= 0) {
#line 306
      goto while_break;
    } else
#line 306
    if ((int )ocol >= 79) {
#line 306
      goto while_break;
    } else
#line 306
    if ((int )dungeon[orow][ocol] == 0) {
#line 306
      goto while_break;
    } else
#line 306
    if ((int )dungeon[orow][ocol] & 2) {
#line 306
      goto while_break;
    } else
#line 306
    if ((int )dungeon[orow][ocol] & 24) {
#line 306
      goto while_break;
    } else
#line 306
    if ((int )orow == (int )rogue.row) {
#line 306
      if ((int )ocol == (int )rogue.col) {
#line 306
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  if (stdscr) {
#line 317
    stdscr->_attrs = 0UL;
  }
  {
#line 318
  wrefresh(stdscr);
  }
  {
#line 319
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 320
    orow = row___0;
#line 321
    ocol = col___0;
#line 322
    tmp___6 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 322
    if (tmp___6 == -1) {
#line 322
      ch = (short )((chtype )-1);
    } else {
      {
#line 322
      tmp___5 = winch(stdscr);
#line 322
      ch = (short )tmp___5;
      }
    }
    {
#line 323
    tmp___7 = wmove(stdscr, (int )row___0, (int )col___0);
    }
#line 323
    if (! (tmp___7 == -1)) {
      {
#line 323
      waddch(stdscr, (chtype const   )ch);
      }
    }
    {
#line 324
    get_dir_rc(dir, & row___0, & col___0, (short)1);
    }
#line 319
    if ((int )col___0 <= 0) {
#line 319
      goto while_break___0;
    } else
#line 319
    if ((int )col___0 >= 79) {
#line 319
      goto while_break___0;
    } else
#line 319
    if ((int )dungeon[row___0][col___0] == 0) {
#line 319
      goto while_break___0;
    } else
#line 319
    if ((int )dungeon[row___0][col___0] & 2) {
#line 319
      goto while_break___0;
    } else
#line 319
    if ((int )dungeon[row___0][col___0] & 24) {
#line 319
      goto while_break___0;
    } else
#line 319
    if ((int )row___0 == (int )rogue.row) {
#line 319
      if ((int )col___0 == (int )rogue.col) {
#line 319
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 332
  if ((int )dungeon[row___0][col___0] & 2) {
    {
#line 335
    monster = object_at(& level_monsters, row___0, col___0);
#line 337
    wake_up(monster);
#line 338
    tmp___9 = rand_percent(33);
    }
#line 338
    if (tmp___9) {
      {
#line 339
      tmp___8 = mon_name((object const   *)monster);
#line 339
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s misses the %s",
              s___0, tmp___8);
#line 340
      message((char const   *)(buf), (char)0);
      }
#line 341
      goto ND;
    }
#line 343
    if ((int )ball == 10) {
#line 344
      if (! (monster->m_flags & 1024UL)) {
#line 345
        if (monster->m_flags & 4096UL) {
#line 346
          damage = monster->quantity;
        } else
#line 347
        if (monster->m_flags & 8388608UL) {
#line 348
          damage = (short )((int )monster->quantity / 10 + 1);
        } else {
          {
#line 350
          tmp___10 = get_rand((int )rogue.hp_current / 3, (int )rogue.hp_max);
#line 350
          damage = (short )tmp___10;
          }
        }
      } else {
#line 353
        damage = (short )((int )monster->quantity / 2 + 1);
      }
      {
#line 355
      tmp___11 = mon_name((object const   *)monster);
#line 355
      sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s hits the %s",
              s___0, tmp___11);
#line 356
      message((char const   *)(buf), (char)0);
#line 357
      mon_damage(monster, damage);
      }
    } else {
#line 359
      damage = (short)-1;
#line 360
      if (! (monster->m_flags & 4096UL)) {
        {
#line 361
        tmp___13 = rand_percent(33);
        }
#line 361
        if (tmp___13) {
          {
#line 362
          message("the monster is frozen", (char)0);
#line 363
          monster->m_flags |= 33554440UL;
#line 364
          tmp___12 = get_rand(3, 6);
#line 364
          monster->picked_up = (short )tmp___12;
          }
        } else {
#line 366
          damage = (short )((int )rogue.hp_current / 4);
        }
      } else {
#line 369
        damage = (short)-2;
      }
#line 371
      if ((int )damage != -1) {
        {
#line 372
        tmp___14 = mon_name((object const   *)monster);
#line 372
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s hits the %s",
                s___0, tmp___14);
#line 373
        message((char const   *)(buf), (char)0);
#line 374
        mon_damage(monster, damage);
        }
      }
    }
  } else
#line 377
  if ((int )row___0 == (int )rogue.row) {
#line 377
    if ((int )col___0 == (int )rogue.col) {
      {
#line 378
      tmp___18 = get_armor_class((object const   *)rogue.armor);
#line 378
      tmp___19 = rand_percent(10 + 3 * tmp___18);
      }
#line 378
      if (tmp___19) {
        {
#line 379
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s misses",
                s___0);
#line 380
        message((char const   *)(buf), (char)0);
        }
#line 381
        goto ND;
      } else {
        {
#line 383
        tmp___15 = get_rand(3, 3 * (int )rogue.exp);
#line 383
        damage = (short )tmp___15;
        }
#line 384
        if ((int )ball == 10) {
          {
#line 385
          damage = (short )(((int )damage * 3) / 2);
#line 386
          tmp___16 = get_armor_class((object const   *)rogue.armor);
#line 386
          damage = (short )((int )damage - tmp___16);
          }
        }
        {
#line 388
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"the %s hits",
                s___0);
        }
#line 389
        if ((int )ball == 10) {
#line 389
          tmp___17 = 6;
        } else {
#line 389
          tmp___17 = 1;
        }
        {
#line 389
        rogue_damage(damage, (object *)0, (short )tmp___17);
#line 391
        message((char const   *)(buf), (char)0);
        }
      }
    } else {
#line 377
      goto ND;
    }
  } else {
    ND: 
#line 396
    i = (short)0;
    {
#line 396
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 396
      if (! ((int )i < 10)) {
#line 396
        goto while_break___1;
      }
      {
#line 397
      tmp___20 = get_rand(0, 7);
#line 397
      dir = (short )tmp___20;
#line 398
      nrow = orow;
#line 399
      ncol = ocol;
#line 400
      get_dir_rc(dir, & nrow, & ncol, (short)1);
      }
#line 401
      if ((int )ncol >= 0) {
#line 401
        if ((int )ncol <= 79) {
#line 401
          if ((int )dungeon[nrow][ncol] != 0) {
#line 401
            if (! ((int )dungeon[nrow][ncol] & 24)) {
#line 404
              new_dir = dir;
#line 405
              goto while_break___1;
            }
          }
        }
      }
#line 396
      i = (short )((int )i + 1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 408
    if ((int )new_dir != -1) {
      {
#line 409
      bounce(ball, new_dir, orow, ocol, r);
      }
    }
  }
#line 412
  return;
}
}
