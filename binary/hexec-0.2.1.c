/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 25 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.h"
struct hexec_buf;
#line 27 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.h"
struct hexec_shm {
   _Bool owner ;
   char *name ;
   char *mmap ;
   char *buf ;
   int mmap_size ;
   int buf_size ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.h"
struct hexec_buf {
   _Bool owner ;
   char *buf ;
   int buf_size ;
   int max_size ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 35 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.c"
struct shm_header {
   int buf_size ;
};
#line 30 "../common/expr.h"
struct args_t;
#line 46 "../common/expr.h"
struct hexec_expr {
   int type ;
   int expr1 ;
   int expr2 ;
   int str ;
   _Bool case_insensitive ;
   int argc ;
   int argv ;
};
#line 26 "../common/args.h"
struct args_t {
   char **argv ;
   int argc ;
   int max_argc ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 296 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 290 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 290 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_16 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_16 pthread_mutex_t;
#line 58 "../common/expr.h"
struct hexec_expr_shm_header {
   int root_expr ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.h"
struct hexec_parser {
   struct hexec_buf *buf ;
   struct args_t *args ;
   int cur_arg ;
   struct hexec_expr_shm_header *shm_header ;
   int result ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_14 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_14 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 253 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 247 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
union __anonunion_68 {
   int __in ;
   int __i ;
};
#line 247 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
union __anonunion_69 {
   int __in ;
   int __i ;
};
#line 66 "expr-grammar.y"
union YYSTYPE {
   int expr ;
};
#line 66 "expr-grammar.y"
typedef union YYSTYPE YYSTYPE;
#line 174 "hexec-expr-grammar.c"
typedef unsigned char yytype_uint8;
#line 181 "hexec-expr-grammar.c"
typedef signed char yytype_int8;
#line 195 "hexec-expr-grammar.c"
typedef short yytype_int16;
#line 326 "hexec-expr-grammar.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/locate.h"
int hexec_locate(char const   *file , char **out ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 277
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                                                  int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/locate.c"
static int check_access(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = access(path, 1);
  }
#line 44
  return (tmp);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/locate.c"
int hexec_locate(char const   *file , char **out ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t pathlen ;
  size_t alloclen ;
  char *path ;
  char *tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  char *name ;
  char *path_malloc ;
  void *tmp___3 ;
  void *tmp___4 ;
  _Bool got_eacces ;
  char *p ;
  char *startp ;
  void *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;

  {
#line 49
  if ((int const   )*file == 0) {
    {
#line 52
    tmp = __errno_location();
#line 52
    *tmp = 2;
    }
#line 53
    return (-1);
  }
  {
#line 56
  tmp___0 = strchr(file, '/');
  }
#line 56
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
#line 59
    *out = strdup(file);
    }
#line 60
    return (0);
  }
  {
#line 63
  alloclen = (size_t )0;
#line 64
  tmp___1 = getenv("PATH");
#line 64
  path = tmp___1;
  }
#line 65
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 67
    pathlen = strlen("/bin:/usr/bin");
#line 68
    alloclen = pathlen + 1UL;
    }
  } else {
    {
#line 72
    pathlen = strlen((char const   *)path);
    }
  }
  {
#line 75
  tmp___2 = strlen(file);
#line 75
  len = tmp___2 + 1UL;
#line 76
  alloclen += (pathlen + len) + 1UL;
#line 79
  path_malloc = (char *)((void *)0);
#line 80
  tmp___3 = malloc(alloclen);
#line 80
  name = (char *)tmp___3;
#line 80
  path_malloc = name;
  }
#line 81
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 82
    return (-1);
  }
#line 84
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 89
    path = ((name + pathlen) + len) + 1;
#line 90
    *(path + 0) = (char )':';
#line 91
    memcpy((void */* __restrict  */)path, (void const   */* __restrict  */)"/bin:/usr/bin",
           pathlen + 1UL);
    }
  }
  {
#line 95
  tmp___4 = memcpy((void */* __restrict  */)((name + pathlen) + 1), (void const   */* __restrict  */)file,
                   len);
#line 95
  name = (char *)tmp___4;
#line 97
  name --;
#line 97
  *name = (char )'/';
#line 99
  got_eacces = (_Bool)0;
#line 100
  p = path;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 105
    path = p;
#line 106
    p = strchrnul((char const   *)path, ':');
    }
#line 108
    if ((unsigned long )p == (unsigned long )path) {
#line 112
      startp = name + 1;
    } else {
      {
#line 116
      tmp___5 = memcpy((void */* __restrict  */)(name - (p - path)), (void const   */* __restrict  */)path,
                       (size_t )(p - path));
#line 116
      startp = (char *)tmp___5;
      }
    }
    {
#line 120
    tmp___7 = check_access((char const   *)startp);
    }
#line 120
    if (tmp___7) {
      {
#line 122
      tmp___6 = __errno_location();
      }
#line 122
      if (*tmp___6 == 13) {
#line 123
        got_eacces = (_Bool)1;
      }
    } else {
      {
#line 127
      *out = strdup((char const   *)startp);
#line 128
      free((void *)path_malloc);
      }
#line 130
      return (0);
    }
#line 101
    tmp___8 = p;
#line 101
    p ++;
#line 101
    if (! ((int )*tmp___8 != 0)) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (got_eacces) {
    {
#line 140
    tmp___9 = __errno_location();
#line 140
    *tmp___9 = 13;
    }
  }
  {
#line 143
  free((void *)path_malloc);
  }
#line 146
  return (-1);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.h"
int hexec_shm_create(struct hexec_shm *shm___0 , char const   *shm_name , struct hexec_buf *buf ) ;
#line 39
int hexec_shm_open(struct hexec_shm *shm___0 , char const   *shm_name ) ;
#line 40
int hexec_shm_close(struct hexec_shm *shm___0 ) ;
#line 42
int hexec_shm_to_buf(struct hexec_shm *shm___0 , struct hexec_buf *buf ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.h"
int hexec_buf_create_from(struct hexec_buf *buf , void *from , int size , _Bool own ) ;
#line 38
int hexec_buf_copy_to(struct hexec_buf *buf , void *to , int size ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.h"
void hexec_error(char const   *str  , ...) ;
#line 34
void hexec_fatal(char const   *str  , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 144
extern int shm_open(char const   *__name , int __oflag , mode_t __mode ) ;
#line 147
extern int shm_unlink(char const   *__name ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.c"
int hexec_shm_create(struct hexec_shm *shm___0 , char const   *shm_name , struct hexec_buf *buf ) 
{ 
  int fd ;
  int tmp ;
  int mmap_size ;
  int tmp___0 ;
  char *mmap_buf ;
  void *tmp___1 ;
  struct shm_header header ;

  {
  {
#line 44
  tmp = shm_open(shm_name, 194, (mode_t )(448 | (448 >> 3)));
#line 44
  fd = tmp;
  }
#line 45
  if (fd == -1) {
    {
#line 47
    hexec_error("failed to create shared memory object %s\n", shm_name);
    }
#line 48
    return (-1);
  }
  {
#line 51
  mmap_size = (int )(sizeof(struct shm_header ) + (unsigned long )buf->buf_size);
#line 53
  tmp___0 = ftruncate(fd, (__off_t )mmap_size);
  }
#line 53
  if (tmp___0) {
    {
#line 55
    close(fd);
#line 56
    shm_unlink(shm_name);
#line 57
    hexec_error("failed to resize shared memory object %s\n", shm_name);
    }
#line 58
    return (-1);
  }
  {
#line 61
  tmp___1 = mmap((void *)0, (size_t )mmap_size, 2, 1, fd, (__off_t )0);
#line 61
  mmap_buf = (char *)tmp___1;
  }
#line 62
  if ((unsigned long )mmap_buf == (unsigned long )((void *)-1)) {
    {
#line 64
    close(fd);
#line 65
    shm_unlink(shm_name);
#line 66
    hexec_error("failed to map shared memory object %s\n", shm_name);
    }
#line 67
    return (-1);
  }
  {
#line 71
  header.buf_size = buf->buf_size;
#line 73
  memcpy((void */* __restrict  */)mmap_buf, (void const   */* __restrict  */)(& header),
         sizeof(struct shm_header ));
#line 74
  hexec_buf_copy_to(buf, (void *)(mmap_buf + sizeof(struct shm_header )), buf->buf_size);
#line 75
  close(fd);
#line 77
  shm___0->owner = (_Bool)1;
#line 78
  shm___0->name = strdup(shm_name);
#line 79
  shm___0->mmap = mmap_buf;
#line 80
  shm___0->mmap_size = mmap_size;
#line 81
  shm___0->buf = mmap_buf + sizeof(struct shm_header );
#line 82
  shm___0->buf_size = buf->buf_size;
  }
#line 84
  return (0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.c"
int hexec_shm_open(struct hexec_shm *shm___0 , char const   *shm_name ) 
{ 
  int fd ;
  int tmp ;
  char *mmap_buf ;
  void *tmp___0 ;
  struct shm_header header ;
  int mmap_size ;
  void *tmp___1 ;

  {
  {
#line 89
  tmp = shm_open(shm_name, 0, (mode_t )0);
#line 89
  fd = tmp;
  }
#line 90
  if (fd == -1) {
    {
#line 92
    hexec_error("failed to open shared memory object %s\n", shm_name);
    }
#line 93
    return (-1);
  }
  {
#line 96
  tmp___0 = mmap((void *)0, sizeof(struct shm_header ), 1, 1, fd, (__off_t )0);
#line 96
  mmap_buf = (char *)tmp___0;
  }
#line 97
  if ((unsigned long )mmap_buf == (unsigned long )((void *)-1)) {
    {
#line 99
    close(fd);
#line 100
    hexec_error("failed to map shared memory object %s\n", shm_name);
    }
#line 101
    return (-1);
  }
  {
#line 104
  memcpy((void */* __restrict  */)(& header), (void const   */* __restrict  */)mmap_buf,
         sizeof(struct shm_header ));
#line 105
  munmap((void *)mmap_buf, sizeof(struct shm_header ));
#line 107
  mmap_size = (int )(sizeof(struct shm_header ) + (unsigned long )header.buf_size);
#line 109
  tmp___1 = mmap((void *)0, (size_t )mmap_size, 1, 1, fd, (__off_t )0);
#line 109
  mmap_buf = (char *)tmp___1;
  }
#line 110
  if ((unsigned long )mmap_buf == (unsigned long )((void *)-1)) {
    {
#line 112
    close(fd);
#line 113
    hexec_error("failed to map shared memory object %s\n", shm_name);
    }
#line 114
    return (-1);
  }
  {
#line 117
  close(fd);
#line 119
  shm___0->owner = (_Bool)0;
#line 120
  shm___0->name = strdup(shm_name);
#line 121
  shm___0->mmap = mmap_buf;
#line 122
  shm___0->mmap_size = mmap_size;
#line 123
  shm___0->buf = mmap_buf + sizeof(struct shm_header );
#line 124
  shm___0->buf_size = header.buf_size;
  }
#line 126
  return (0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.c"
int hexec_shm_close(struct hexec_shm *shm___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 131
  tmp = munmap((void *)shm___0->mmap, (size_t )shm___0->mmap_size);
  }
#line 131
  if (tmp) {
    {
#line 132
    hexec_fatal("failed to unmap shared memory object %s\n", shm___0->name);
    }
  }
#line 133
  if (shm___0->owner) {
    {
#line 133
    tmp___0 = shm_unlink((char const   *)shm___0->name);
    }
#line 133
    if (tmp___0) {
      {
#line 134
      hexec_fatal("failed to unlink shared memory object %s\n", shm___0->name);
      }
    }
  }
  {
#line 135
  free((void *)shm___0->name);
  }
#line 136
  return (0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/shm.c"
int hexec_shm_to_buf(struct hexec_shm *shm___0 , struct hexec_buf *buf ) 
{ 
  int tmp ;

  {
  {
#line 141
  tmp = hexec_buf_create_from(buf, (void *)shm___0->buf, shm___0->buf_size, (_Bool)0);
  }
#line 141
  return (tmp);
}
}
#line 65 "../common/expr.h"
int hexec_expr_eval(char const   *path , struct args_t *args , struct args_t *env ,
                    struct hexec_buf *buf , int e , int *last_exec_status ) ;
#line 44 "../common/args.h"
int hexec_args_print(struct args_t *args ) ;
#line 31 "../common/error.h"
void hexec_log(char const   *str  , ...) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
int eval_exec(char const   *path , struct args_t *args , struct args_t *env , struct hexec_buf *buf ,
              struct hexec_expr *e , int *last_exec_status ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
static struct hexec_expr *to_expr(struct hexec_buf *buf , int p ) 
{ 


  {
#line 45
  return ((struct hexec_expr *)(buf->buf + p));
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
static int eval_path(char const   *path , struct args_t *args , struct args_t *env ,
                     struct hexec_buf *buf , struct hexec_expr *e ) 
{ 
  int flags ;
  int ret ;
  int tmp ;

  {
#line 50
  flags = 0;
#line 51
  if (e->case_insensitive) {
#line 52
    flags |= 1 << 4;
  }
  {
#line 53
  tmp = fnmatch((char const   *)(buf->buf + e->str), path, flags);
#line 53
  ret = tmp;
  }
#line 54
  if (ret == 0) {
#line 55
    return (0);
  }
#line 56
  if (ret == 1) {
#line 57
    return (1);
  }
#line 58
  return (2);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
static int eval_name(char const   *name , struct args_t *args , struct args_t *env ,
                     struct hexec_buf *buf , struct hexec_expr *e ) 
{ 
  char *name_copy ;
  char *tmp ;
  char *base_name ;
  char *tmp___0 ;
  int flags ;
  int ret ;
  int tmp___1 ;

  {
  {
#line 63
  tmp = strdup(name);
#line 63
  name_copy = tmp;
#line 64
  tmp___0 = __xpg_basename(name_copy);
#line 64
  base_name = tmp___0;
#line 66
  flags = 0;
  }
#line 67
  if (e->case_insensitive) {
#line 68
    flags |= 1 << 4;
  }
  {
#line 69
  tmp___1 = fnmatch((char const   *)(buf->buf + e->str), (char const   *)base_name,
                    flags);
#line 69
  ret = tmp___1;
#line 70
  free((void *)name_copy);
  }
#line 71
  if (ret == 0) {
#line 72
    return (0);
  }
#line 73
  if (ret == 1) {
#line 74
    return (1);
  }
#line 75
  return (2);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
static int eval_contains(char const   *name , struct args_t *args , struct args_t *env ,
                         struct hexec_buf *buf , struct hexec_expr *e ) 
{ 
  char *name_copy ;
  char *tmp ;
  int i ;
  int tmp___0 ;
  _Bool match ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 80
  if (e->case_insensitive) {
    {
#line 82
    tmp = strdup(name);
#line 82
    name_copy = tmp;
#line 83
    i = 0;
    }
    {
#line 83
    while (1) {
      while_continue: /* CIL Label */ ;
#line 83
      if (! *(name_copy + i)) {
#line 83
        goto while_break;
      }
      {
#line 84
      tmp___0 = tolower((int )*(name_copy + i));
#line 84
      *(name_copy + i) = (char )tmp___0;
#line 83
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 86
    tmp___1 = strstr((char const   *)name_copy, (char const   *)(buf->buf + e->str));
#line 86
    match = (_Bool )((unsigned long )tmp___1 != (unsigned long )((void *)0));
#line 87
    free((void *)name_copy);
    }
#line 88
    if (match) {
#line 89
      return (0);
    }
#line 90
    return (1);
  } else {
    {
#line 94
    tmp___2 = strstr(name, (char const   *)(buf->buf + e->str));
    }
#line 94
    if (tmp___2) {
#line 95
      return (0);
    }
#line 96
    return (1);
  }
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
static int eval_print(char const   *path , struct args_t *args , struct args_t *env ,
                      struct hexec_buf *buf , struct hexec_expr *e ) 
{ 


  {
  {
#line 105
  hexec_args_print(args);
#line 106
  hexec_log("\n");
  }
#line 108
  return (1);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval.c"
int hexec_expr_eval(char const   *path , struct args_t *args , struct args_t *env ,
                    struct hexec_buf *buf , int e , int *last_exec_status ) 
{ 
  struct hexec_expr *ex ;
  struct hexec_expr *tmp ;
  int res ;
  int tmp___0 ;
  int leftRes ;
  int tmp___1 ;
  int tmp___2 ;
  int leftRes___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 113
  tmp = to_expr(buf, e);
#line 113
  ex = tmp;
  }
  {
#line 117
  if (ex->type == 0) {
#line 117
    goto case_0;
  }
#line 125
  if (ex->type == 1) {
#line 125
    goto case_1;
  }
#line 131
  if (ex->type == 2) {
#line 131
    goto case_2;
  }
#line 138
  if (ex->type == 6) {
#line 138
    goto case_6;
  }
#line 140
  if (ex->type == 3) {
#line 140
    goto case_3;
  }
#line 142
  if (ex->type == 4) {
#line 142
    goto case_4;
  }
#line 144
  if (ex->type == 5) {
#line 144
    goto case_5;
  }
#line 146
  if (ex->type == 7) {
#line 146
    goto case_7;
  }
#line 115
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 118
  tmp___0 = hexec_expr_eval(path, args, env, buf, ex->expr1, last_exec_status);
#line 118
  res = tmp___0;
  }
#line 119
  if (res == 0) {
#line 120
    return (1);
  }
#line 121
  if (res == 1) {
#line 122
    return (0);
  }
#line 123
  return (2);
  case_1: /* CIL Label */ 
  {
#line 126
  tmp___1 = hexec_expr_eval(path, args, env, buf, ex->expr1, last_exec_status);
#line 126
  leftRes = tmp___1;
  }
#line 127
  if (leftRes == 0) {
    {
#line 128
    tmp___2 = hexec_expr_eval(path, args, env, buf, ex->expr2, last_exec_status);
    }
#line 128
    return (tmp___2);
  }
#line 129
  return (leftRes);
  case_2: /* CIL Label */ 
  {
#line 132
  tmp___3 = hexec_expr_eval(path, args, env, buf, ex->expr1, last_exec_status);
#line 132
  leftRes___0 = tmp___3;
  }
#line 133
  if (leftRes___0 == 0) {
#line 134
    return (0);
  }
  {
#line 135
  tmp___4 = hexec_expr_eval(path, args, env, buf, ex->expr2, last_exec_status);
  }
#line 135
  return (tmp___4);
  case_6: /* CIL Label */ 
  {
#line 139
  tmp___5 = eval_print(path, args, env, buf, ex);
  }
#line 139
  return (tmp___5);
  case_3: /* CIL Label */ 
  {
#line 141
  tmp___6 = eval_path(path, args, env, buf, ex);
  }
#line 141
  return (tmp___6);
  case_4: /* CIL Label */ 
  {
#line 143
  tmp___7 = eval_name(path, args, env, buf, ex);
  }
#line 143
  return (tmp___7);
  case_5: /* CIL Label */ 
  {
#line 145
  tmp___8 = eval_contains(path, args, env, buf, ex);
  }
#line 145
  return (tmp___8);
  case_7: /* CIL Label */ 
  {
#line 147
  tmp___9 = eval_exec(path, args, env, buf, ex, last_exec_status);
  }
#line 147
  return (tmp___9);
  switch_break: /* CIL Label */ ;
  }
  {
#line 149
  hexec_log("unknown expr: %d\n", ex->type);
  }
#line 150
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 34 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.h"
int hexec_args_init(struct args_t *args ) ;
#line 35
int hexec_args_free(struct args_t *args ) ;
#line 37
int hexec_args_add(struct args_t *args , char const   *arg ) ;
#line 38
int hexec_args_remove(struct args_t *args , int idx ) ;
#line 39
int hexec_args_replace(struct args_t *args , int idx , char const   *arg ) ;
#line 41
int hexec_args_from_array(struct args_t *args , char * const  *argv ) ;
#line 42
int hexec_args_from_va_list(struct args_t *args , char const   *first , va_list *va ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
static int hexec_args_grow(struct args_t *args , int argc ) 
{ 
  void *tmp ;

  {
#line 30
  if (args->max_argc >= argc) {
#line 31
    return (0);
  }
  {
#line 32
  tmp = realloc((void *)args->argv, (unsigned long )(argc + 1) * sizeof(char *));
#line 32
  args->argv = (char **)tmp;
#line 33
  args->max_argc = argc;
  }
#line 34
  return (0);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_init(struct args_t *args ) 
{ 


  {
#line 39
  args->argv = (char **)((void *)0);
#line 40
  args->argc = 0;
#line 41
  args->max_argc = 0;
#line 42
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_free(struct args_t *args ) 
{ 
  int i ;

  {
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < args->argc)) {
#line 48
      goto while_break;
    }
    {
#line 49
    free((void *)*(args->argv + i));
#line 48
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 50
  free((void *)args->argv);
#line 51
  args->argv = (char **)((void *)0);
#line 52
  args->argc = 0;
#line 53
  args->max_argc = 0;
  }
#line 54
  return (0);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_add(struct args_t *args , char const   *arg ) 
{ 
  int tmp ;

  {
  {
#line 59
  hexec_args_grow(args, args->argc + 1);
#line 60
  tmp = args->argc;
#line 60
  (args->argc) ++;
#line 60
  *(args->argv + tmp) = strdup(arg);
#line 61
  *(args->argv + args->argc) = (char *)((void *)0);
  }
#line 62
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_remove(struct args_t *args , int idx ) 
{ 


  {
  {
#line 67
  free((void *)*(args->argv + idx));
#line 68
  memmove((void *)(args->argv + idx), (void const   *)((args->argv + idx) + 1), (unsigned long )((args->argc - idx) - 1) * sizeof(char *));
#line 69
  (args->argc) --;
#line 70
  *(args->argv + args->argc) = (char *)((void *)0);
  }
#line 71
  return (0);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_replace(struct args_t *args , int idx , char const   *arg ) 
{ 


  {
  {
#line 76
  free((void *)*(args->argv + idx));
#line 77
  *(args->argv + idx) = strdup(arg);
  }
#line 78
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_from_array(struct args_t *args , char * const  *argv ) 
{ 
  int i ;

  {
  {
#line 84
  hexec_args_init(args);
#line 85
  i = 0;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! *(argv + i)) {
#line 85
      goto while_break;
    }
    {
#line 86
    hexec_args_add(args, (char const   *)*(argv + i));
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return (0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_from_va_list(struct args_t *args , char const   *first , va_list *va ) 
{ 
  char const   *arg ;
  char const   *tmp___0 ;

  {
  {
#line 92
  hexec_args_init(args);
  }
#line 93
  if (first) {
    {
#line 94
    hexec_args_add(args, first);
    }
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    tmp___0 = __builtin_va_arg(*va, char const   *);
#line 97
    arg = tmp___0;
    }
#line 98
    if (! arg) {
#line 99
      goto while_break;
    }
    {
#line 100
    hexec_args_add(args, arg);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
int hexec_args_print(struct args_t *args ) 
{ 
  int i ;

  {
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < args->argc)) {
#line 108
      goto while_break;
    }
#line 110
    if (i) {
      {
#line 111
      hexec_log(" ");
      }
    }
    {
#line 112
    hexec_log("\"%s\"", *(args->argv + i));
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return (0);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.h"
int hexec_buf_create(struct hexec_buf *buf ) ;
#line 35
int hexec_buf_destroy(struct hexec_buf *buf ) ;
#line 37
int hexec_buf_alloc(struct hexec_buf *buf , int size ) ;
#line 40
int hexec_buf_strdup(struct hexec_buf *buf , char const   *str ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_create(struct hexec_buf *buf ) 
{ 
  void *tmp ;

  {
  {
#line 32
  buf->owner = (_Bool)1;
#line 33
  tmp = malloc((size_t )1024);
#line 33
  buf->buf = (char *)tmp;
#line 34
  buf->max_size = 1024;
#line 35
  buf->buf_size = 0;
  }
#line 36
  return (0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_create_from(struct hexec_buf *buf , void *from , int size , _Bool own ) 
{ 


  {
#line 41
  buf->owner = own;
#line 42
  buf->buf = (char *)from;
#line 43
  buf->buf_size = size;
#line 44
  buf->max_size = size;
#line 45
  return (0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_destroy(struct hexec_buf *buf ) 
{ 


  {
#line 50
  if (buf->owner) {
    {
#line 51
    free((void *)buf->buf);
    }
  }
#line 52
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_alloc(struct hexec_buf *buf , int size ) 
{ 
  _Bool do_realloc ;
  void *tmp ;
  int ptr ;

  {
#line 57
  if (! buf->owner) {
    {
#line 57
    __assert_fail("buf->owner", "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c",
                  57U, "hexec_buf_alloc");
    }
  }
#line 59
  do_realloc = (_Bool)0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (buf->buf_size + size > buf->max_size)) {
#line 60
      goto while_break;
    }
#line 62
    buf->max_size += 1024;
#line 63
    do_realloc = (_Bool)1;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  if (do_realloc) {
    {
#line 66
    tmp = realloc((void *)buf->buf, (size_t )buf->max_size);
#line 66
    buf->buf = (char *)tmp;
    }
  }
#line 68
  ptr = buf->buf_size;
#line 69
  buf->buf_size += size;
#line 70
  return (ptr);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_copy_to(struct hexec_buf *buf , void *to , int size ) 
{ 


  {
#line 75
  if (buf->buf_size < size) {
#line 76
    size = buf->buf_size;
  }
  {
#line 77
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)buf->buf, (size_t )size);
  }
#line 78
  return (size);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/buf.c"
int hexec_buf_strdup(struct hexec_buf *buf , char const   *str ) 
{ 
  int ptr ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 83
  tmp = strlen(str);
#line 83
  tmp___0 = hexec_buf_alloc(buf, (int )(tmp + 1UL));
#line 83
  ptr = tmp___0;
#line 84
  strcpy((char */* __restrict  */)(buf->buf + ptr), (char const   */* __restrict  */)str);
  }
#line 85
  return (ptr);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 412 "/usr/include/stdio.h"
extern int ( /* format attribute */  vdprintf)(int __fd , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __arg ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.h"
int log_out_fd ;
#line 27
int hexec_open_log_fd(char const   *path ) ;
#line 28
void hexec_lock_log(void) ;
#line 29
void hexec_unlock_log(void) ;
#line 32
void hexec_warning(char const   *str  , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 221
extern int lockf(int __fd , int __cmd , off_t __len ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
int log_out_fd  =    -1;
#line 37 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_lock_log(void) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 39
  tmp = lockf(log_out_fd, 1, (off_t )0);
#line 39
  err = tmp;
  }
#line 40
  if (! (! err)) {
    {
#line 40
    __assert_fail("!err", "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c",
                  40U, "hexec_lock_log");
    }
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_unlock_log(void) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 45
  tmp = lockf(log_out_fd, 0, (off_t )0);
#line 45
  err = tmp;
  }
#line 46
  if (! (! err)) {
    {
#line 46
    __assert_fail("!err", "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c",
                  46U, "hexec_unlock_log");
    }
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
int hexec_open_log_fd(char const   *path ) 
{ 


  {
  {
#line 51
  log_out_fd = open(path, 1089, ((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3));
  }
#line 52
  if (log_out_fd == -1) {
#line 53
    return (-1);
  }
#line 55
  return (0);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_log(char const   *str  , ...) 
{ 
  int err ;
  int *tmp ;
  va_list va ;
  int *tmp___0 ;

  {
#line 60
  if (log_out_fd == -1) {
#line 61
    return;
  }
  {
#line 62
  tmp = __errno_location();
#line 62
  err = *tmp;
#line 64
  __builtin_va_start(va, str);
#line 66
  vdprintf(log_out_fd, (char const   */* __restrict  */)str, va);
#line 67
  __builtin_va_end(va);
#line 68
  tmp___0 = __errno_location();
#line 68
  *tmp___0 = err;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_warning(char const   *str  , ...) 
{ 
  int err ;
  int *tmp ;
  va_list va ;
  int *tmp___0 ;

  {
#line 73
  if (log_out_fd == -1) {
#line 74
    return;
  }
  {
#line 75
  tmp = __errno_location();
#line 75
  err = *tmp;
#line 77
  __builtin_va_start(va, str);
#line 79
  vdprintf(log_out_fd, (char const   */* __restrict  */)str, va);
#line 80
  __builtin_va_end(va);
#line 81
  tmp___0 = __errno_location();
#line 81
  *tmp___0 = err;
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_error(char const   *str  , ...) 
{ 
  int err ;
  int *tmp ;
  va_list va ;
  int *tmp___0 ;

  {
#line 86
  if (log_out_fd == -1) {
#line 87
    return;
  }
  {
#line 88
  tmp = __errno_location();
#line 88
  err = *tmp;
#line 90
  __builtin_va_start(va, str);
#line 92
  vdprintf(log_out_fd, (char const   */* __restrict  */)str, va);
#line 93
  __builtin_va_end(va);
#line 94
  tmp___0 = __errno_location();
#line 94
  *tmp___0 = err;
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/error.c"
void hexec_fatal(char const   *str  , ...) 
{ 
  va_list va ;

  {
#line 99
  if (log_out_fd == -1) {
#line 100
    return;
  }
  {
#line 102
  __builtin_va_start(va, str);
#line 104
  vdprintf(log_out_fd, (char const   */* __restrict  */)str, va);
#line 105
  __builtin_va_end(va);
#line 106
  exit(1);
  }
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 23 "../common/utils.h"
char *hexec_xstrcat(char *s1 , char const   *s2 , int *cur_len , int *cur_max_len ) ;
#line 24
char *hexec_xstrcatch(char *s1 , char ch , int *cur_len , int *cur_max_len ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.h"
int (*orig_execve)(char const   *filename , char * const  *argv , char * const  *envp ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 756 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
static void remove_ld_preload(struct args_t *env ) 
{ 
  int i ;
  char *a ;
  char *tmp ;
  char *b ;
  char *tmp___0 ;
  int pos ;
  int len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < env->argc)) {
#line 42
      goto while_break;
    }
    {
#line 44
    tmp = strstr((char const   *)*(env->argv + i), "LD_PRELOAD=");
#line 44
    a = tmp;
    }
#line 45
    if ((unsigned long )a == (unsigned long )*(env->argv + i)) {
      {
#line 47
      tmp___0 = strstr((char const   *)*(env->argv + i), "/usr/local/lib/hexec/libhexec-hook.so");
#line 47
      b = tmp___0;
      }
#line 48
      if (b) {
        {
#line 50
        pos = (int )(b - *(env->argv + i));
#line 51
        tmp___1 = strlen("/usr/local/lib/hexec/libhexec-hook.so");
#line 51
        len = (int )tmp___1;
        }
#line 53
        if ((int )*(b + -1) == 61) {
          {
#line 55
          tmp___2 = strlen((char const   *)*(env->argv + i));
#line 55
          memmove((void *)(*(env->argv + i) + pos), (void const   *)((*(env->argv + i) + pos) + len),
                  ((tmp___2 - (size_t )pos) - (size_t )len) + 1UL);
          }
        } else {
          {
#line 53
          tmp___3 = __ctype_b_loc();
          }
#line 53
          if ((int const   )*(*tmp___3 + (int )*(b + -1)) & 8192) {
#line 53
            if ((int )*(b + len) == 0) {
              {
#line 55
              tmp___2 = strlen((char const   *)*(env->argv + i));
#line 55
              memmove((void *)(*(env->argv + i) + pos), (void const   *)((*(env->argv + i) + pos) + len),
                      ((tmp___2 - (size_t )pos) - (size_t )len) + 1UL);
              }
            } else {
              {
#line 53
              tmp___4 = __ctype_b_loc();
              }
#line 53
              if ((int const   )*(*tmp___4 + (int )*(b + len)) & 8192) {
                {
#line 55
                tmp___2 = strlen((char const   *)*(env->argv + i));
#line 55
                memmove((void *)(*(env->argv + i) + pos), (void const   *)((*(env->argv + i) + pos) + len),
                        ((tmp___2 - (size_t )pos) - (size_t )len) + 1UL);
                }
              }
            }
          }
        }
      }
      {
#line 59
      tmp___5 = i;
#line 59
      i --;
#line 59
      hexec_args_remove(env, tmp___5);
      }
    }
#line 42
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
static _Bool needs_escaping(char ch ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp = __ctype_b_loc();
  }
#line 70
  if ((int const   )*(*tmp + (int )ch) & 8) {
#line 70
    tmp___0 = 0;
  } else {
#line 70
    tmp___0 = 1;
  }
#line 70
  return ((_Bool )tmp___0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
static int insert_exec_args(struct args_t *exec_args , struct args_t *orig_args ,
                            char const   *arg ) 
{ 
  int ins_arg_len ;
  int ins_arg_max ;
  char *ins_arg ;
  void *tmp ;
  int arg_len ;
  size_t tmp___0 ;
  int pos ;
  int flags ;
  int start ;
  int end ;
  _Bool is_insert_cnt ;
  int first_arg ;
  int arg_cnt ;
  int i ;
  int j ;
  unsigned short const   **tmp___1 ;
  char tmp___2[32] ;
  int i___0 ;
  char const   *a ;
  int j___0 ;
  _Bool tmp___3 ;

  {
  {
#line 78
  ins_arg_len = 0;
#line 79
  ins_arg_max = 32;
#line 80
  tmp = malloc((size_t )ins_arg_max);
#line 80
  ins_arg = (char *)tmp;
#line 82
  tmp___0 = strlen(arg);
#line 82
  arg_len = (int )tmp___0;
  }
#line 83
  if (! arg_len) {
    {
#line 83
    __assert_fail("arg_len", "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c",
                  83U, "insert_exec_args");
    }
  }
#line 84
  pos = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (pos < arg_len)) {
#line 85
      goto while_break;
    }
#line 87
    if ((int const   )*(arg + pos) == 123) {
#line 87
      if (pos == 0) {
#line 87
        goto _L;
      } else
#line 87
      if ((int const   )*(arg + (pos - 1)) != 92) {
        _L: /* CIL Label */ 
#line 89
        flags = 0;
#line 91
        start = pos;
#line 92
        end = start;
        {
#line 93
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 93
          if (end < arg_len) {
#line 93
            if (! ((int const   )*(arg + end) != 125)) {
#line 93
              goto while_break___0;
            }
          } else {
#line 93
            goto while_break___0;
          }
#line 94
          end ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 95
        if (end == arg_len) {
#line 96
          goto format_error;
        }
#line 98
        is_insert_cnt = (_Bool)0;
#line 99
        first_arg = -1;
#line 100
        arg_cnt = 0;
#line 102
        i = start + 1;
        {
#line 102
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 102
          if (i <= end) {
#line 102
            if (! (first_arg == -1)) {
#line 102
              goto while_break___1;
            }
          } else {
#line 102
            goto while_break___1;
          }
          {
#line 106
          if ((int const   )*(arg + i) == 113) {
#line 106
            goto case_113;
          }
#line 109
          if ((int const   )*(arg + i) == 115) {
#line 109
            goto case_115;
          }
#line 112
          if ((int const   )*(arg + i) == 101) {
#line 112
            goto case_101;
          }
#line 115
          if ((int const   )*(arg + i) == 125) {
#line 115
            goto case_125;
          }
#line 119
          goto switch_default;
          case_113: /* CIL Label */ 
#line 107
          flags |= 1;
#line 108
          goto switch_break;
          case_115: /* CIL Label */ 
#line 110
          flags |= 4;
#line 111
          goto switch_break;
          case_101: /* CIL Label */ 
#line 113
          flags |= 2;
#line 114
          goto switch_break;
          case_125: /* CIL Label */ 
#line 116
          first_arg = 0;
#line 117
          arg_cnt = orig_args->argc;
#line 118
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 120
          if ((int const   )*(arg + i) == 110) {
#line 122
            is_insert_cnt = (_Bool)1;
#line 123
            if (i + 1 != end) {
#line 124
              goto format_error;
            }
          } else {
#line 128
            j = i;
            {
#line 128
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 128
              if (! (j < end)) {
#line 128
                goto while_break___2;
              }
              {
#line 130
              tmp___1 = __ctype_b_loc();
              }
#line 130
              if (! ((int const   )*(*tmp___1 + (int )*(arg + j)) & 2048)) {
#line 131
                goto format_error;
              }
#line 128
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 133
            first_arg = atoi(arg + i);
#line 134
            arg_cnt = 1;
            }
          }
#line 136
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 102
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 139
        if (! is_insert_cnt) {
#line 139
          if (first_arg < 0) {
#line 140
            goto out_of_range_error;
          } else
#line 139
          if (first_arg >= orig_args->argc) {
#line 140
            goto out_of_range_error;
          } else
#line 139
          if (first_arg + arg_cnt > orig_args->argc) {
#line 140
            goto out_of_range_error;
          }
        }
#line 142
        if (flags & 4) {
#line 145
          if (ins_arg_len > 0) {
            {
#line 147
            hexec_args_add(exec_args, (char const   *)ins_arg);
#line 148
            *ins_arg = (char)0;
#line 149
            ins_arg_len = 0;
            }
          }
        }
#line 153
        if (is_insert_cnt) {
          {
#line 156
          sprintf((char */* __restrict  */)(tmp___2), (char const   */* __restrict  */)"%d",
                  orig_args->argc);
          }
#line 157
          if (flags & 1) {
            {
#line 158
            ins_arg = hexec_xstrcatch(ins_arg, (char )'\"', & ins_arg_len, & ins_arg_max);
            }
          }
          {
#line 159
          ins_arg = hexec_xstrcat(ins_arg, (char const   *)(tmp___2), & ins_arg_len,
                                  & ins_arg_max);
          }
#line 160
          if (flags & 1) {
            {
#line 161
            ins_arg = hexec_xstrcatch(ins_arg, (char )'\"', & ins_arg_len, & ins_arg_max);
            }
          }
#line 162
          if (flags & 4) {
#line 165
            if (ins_arg_len > 0) {
              {
#line 167
              hexec_args_add(exec_args, (char const   *)ins_arg);
#line 168
              *ins_arg = (char)0;
#line 169
              ins_arg_len = 0;
              }
            }
          }
        } else {
#line 175
          i___0 = 0;
          {
#line 175
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 175
            if (! (i___0 < arg_cnt)) {
#line 175
              goto while_break___3;
            }
#line 177
            if (i___0 != 0) {
#line 177
              if (! (flags & 4)) {
                {
#line 178
                ins_arg = hexec_xstrcatch(ins_arg, (char )' ', & ins_arg_len, & ins_arg_max);
                }
              }
            }
#line 179
            if (flags & 1) {
              {
#line 180
              ins_arg = hexec_xstrcatch(ins_arg, (char )'\"', & ins_arg_len, & ins_arg_max);
              }
            }
#line 181
            if (flags & 2) {
#line 183
              a = (char const   *)*(orig_args->argv + (i___0 + first_arg));
#line 184
              j___0 = 0;
              {
#line 184
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 184
                if (! *(a + j___0)) {
#line 184
                  goto while_break___4;
                }
                {
#line 186
                tmp___3 = needs_escaping((char )*(a + j___0));
                }
#line 186
                if (tmp___3) {
                  {
#line 187
                  ins_arg = hexec_xstrcatch(ins_arg, (char )'\\', & ins_arg_len, & ins_arg_max);
                  }
                }
                {
#line 188
                ins_arg = hexec_xstrcatch(ins_arg, (char )*(a + j___0), & ins_arg_len,
                                          & ins_arg_max);
#line 184
                j___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
            } else {
              {
#line 193
              ins_arg = hexec_xstrcat(ins_arg, (char const   *)*(orig_args->argv + (i___0 + first_arg)),
                                      & ins_arg_len, & ins_arg_max);
              }
            }
#line 195
            if (flags & 1) {
              {
#line 196
              ins_arg = hexec_xstrcatch(ins_arg, (char )'\"', & ins_arg_len, & ins_arg_max);
              }
            }
#line 198
            if (flags & 4) {
              {
#line 200
              hexec_args_add(exec_args, (char const   *)ins_arg);
#line 201
              *ins_arg = (char)0;
#line 202
              ins_arg_len = 0;
              }
            }
#line 175
            i___0 ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 207
        pos = end + 1;
      } else {
        {
#line 211
        ins_arg = hexec_xstrcatch(ins_arg, (char )*(arg + pos), & ins_arg_len, & ins_arg_max);
#line 212
        pos ++;
        }
      }
    } else {
      {
#line 211
      ins_arg = hexec_xstrcatch(ins_arg, (char )*(arg + pos), & ins_arg_len, & ins_arg_max);
#line 212
      pos ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if (ins_arg_len > 0) {
    {
#line 219
    hexec_args_add(exec_args, (char const   *)ins_arg);
    }
  }
  {
#line 223
  free((void *)ins_arg);
  }
#line 224
  return (0);
  {
#line 227
  hexec_fatal("error while processing replacement argument\n");
#line 228
  free((void *)ins_arg);
  }
  format_error: 
  {
#line 231
  hexec_error("invalid format of replacement argument \'%s\'\n", arg);
#line 232
  free((void *)ins_arg);
  }
#line 233
  return (-1);
  out_of_range_error: 
  {
#line 236
  hexec_error("replacement argument \'%s\' out of range\n", arg);
#line 237
  free((void *)ins_arg);
  }
#line 238
  return (-1);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/expr-eval-exec.c"
int eval_exec(char const   *path , struct args_t *args , struct args_t *env , struct hexec_buf *buf ,
              struct hexec_expr *e , int *last_exec_status ) 
{ 
  char *exec_path ;
  struct args_t exec_args ;
  struct args_t exec_env ;
  int i ;
  int i___0 ;
  int *argv ;
  char *arg ;
  int tmp ;
  int tmp___0 ;
  int pid ;
  __pid_t tmp___1 ;
  int err ;
  int tmp___2 ;
  int status ;
  __pid_t tmp___3 ;
  union __anonunion_55 __constr_expr_0 ;
  union __anonunion_56 __constr_expr_1 ;
  union __anonunion_57 __constr_expr_2 ;

  {
  {
#line 249
  hexec_args_init(& exec_args);
#line 250
  hexec_args_init(& exec_env);
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < env->argc)) {
#line 251
      goto while_break;
    }
    {
#line 252
    hexec_args_add(& exec_env, (char const   *)*(env->argv + i));
#line 251
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  i___0 = 0;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! (i___0 < e->argc)) {
#line 253
      goto while_break___0;
    }
    {
#line 255
    argv = (int *)(buf->buf + e->argv);
#line 256
    arg = buf->buf + *(argv + i___0);
#line 257
    tmp = insert_exec_args(& exec_args, args, (char const   *)arg);
    }
#line 257
    if (tmp) {
#line 258
      return (2);
    }
#line 253
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 260
  remove_ld_preload(& exec_env);
#line 262
  tmp___0 = hexec_locate((char const   *)*(exec_args.argv + 0), & exec_path);
  }
#line 262
  if (tmp___0) {
    {
#line 264
    hexec_error("could not locate %s\n", *(exec_args.argv + 0));
#line 265
    hexec_args_free(& exec_args);
#line 266
    hexec_args_free(& exec_env);
    }
#line 267
    return (2);
  }
  {
#line 274
  tmp___1 = fork();
#line 274
  pid = tmp___1;
  }
#line 275
  if (pid == -1) {
    {
#line 276
    hexec_fatal("failed to fork\n");
    }
  }
#line 277
  if (pid == 0) {
    {
#line 279
    tmp___2 = (*orig_execve)((char const   *)exec_path, (char * const  *)exec_args.argv,
                             (char * const  *)exec_env.argv);
#line 279
    err = tmp___2;
#line 280
    hexec_log("execve err = %d\n", err);
#line 281
    exit(err);
    }
  }
  {
#line 285
  tmp___3 = waitpid(pid, & status, 0);
  }
#line 285
  if (tmp___3 != pid) {
    {
#line 287
    hexec_fatal("waitpid failed\n");
    }
  }
#line 290
  __constr_expr_1.__in = status;
#line 290
  if ((__constr_expr_1.__i & 65280) >> 8 == 0) {
#line 290
    __constr_expr_2.__in = status;
#line 290
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
#line 292
      *last_exec_status = -1;
    } else {
#line 296
      __constr_expr_0.__in = status;
#line 296
      *last_exec_status = (__constr_expr_0.__i & 65280) >> 8;
    }
  } else {
#line 296
    __constr_expr_0.__in = status;
#line 296
    *last_exec_status = (__constr_expr_0.__i & 65280) >> 8;
  }
  {
#line 299
  free((void *)exec_path);
#line 300
  hexec_args_free(& exec_args);
#line 301
  hexec_args_free(& exec_env);
  }
#line 303
  return (0);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/utils.c"
char *hexec_xstrcat(char *s1 , char const   *s2 , int *cur_len , int *cur_max_len ) 
{ 
  int s2_len ;
  size_t tmp ;
  int new_len ;
  _Bool do_realloc ;
  void *tmp___0 ;

  {
  {
#line 31
  tmp = strlen(s2);
#line 31
  s2_len = (int )tmp;
#line 32
  new_len = *cur_len + s2_len;
#line 33
  do_realloc = (_Bool)0;
  }
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! (new_len + 1 >= *cur_max_len)) {
#line 34
      goto while_break;
    }
#line 36
    *cur_max_len += 32;
#line 37
    do_realloc = (_Bool)1;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if (do_realloc) {
    {
#line 41
    tmp___0 = realloc((void *)s1, (size_t )*cur_max_len);
#line 41
    s1 = (char *)tmp___0;
    }
  }
  {
#line 43
  memcpy((void */* __restrict  */)(s1 + *cur_len), (void const   */* __restrict  */)s2,
         (size_t )(s2_len + 1));
#line 44
  *cur_len += s2_len;
  }
#line 45
  return (s1);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/utils.c"
char *hexec_xstrcatch(char *s1 , char ch , int *cur_len , int *cur_max_len ) 
{ 
  char tmp[2] ;
  char *tmp___0 ;

  {
  {
#line 50
  tmp[0] = ch;
#line 50
  tmp[1] = (char)0;
#line 51
  tmp___0 = hexec_xstrcat(s1, (char const   *)(tmp), cur_len, cur_max_len);
  }
#line 51
  return (tmp___0);
}
}
#line 64 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 773 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 545 "/usr/include/unistd.h"
extern char **environ ;
#line 551
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *path ,
                                                                                        char * const  *argv ,
                                                                                        char * const  *envp ) ;
#line 557
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int fd ,
                                                                                       char * const  *argv ,
                                                                                       char * const  *envp ) ;
#line 563
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *path ,
                                                                                       char * const  *argv ) ;
#line 568
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 573
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path ,
                                                                                       char const   *arg 
                                                                                       , ...) ;
#line 578
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *file ,
                                                                                        char * const  *argv ) ;
#line 584
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *file ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.h"
int (*orig_execve)(char const   *filename , char * const  *argv , char * const  *envp )  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.h"
int (*orig_execvp)(char const   *file , char * const  *argv )  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int (*orig_fexecve)(int fd , char * const  *argv , char * const  *envp )  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int (*orig_execl)(char const   *path , char const   *arg  , ...)  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int (*orig_execlp)(char const   *file , char const   *arg  , ...)  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int (*orig_execle)(char const   *path , char const   *arg  , ...)  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int (*orig_execv)(char const   *path , char * const  *argv )  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static pthread_mutex_t init_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 57 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static int is_initialized  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static struct hexec_shm shm  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static struct hexec_buf expr_buf  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static struct hexec_expr_shm_header *expr_header  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static void init(void) 
{ 
  char *shm_name ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *log_out_fd_str ;
  char *tmp___2 ;

  {
#line 65
  if (is_initialized) {
#line 66
    return;
  }
  {
#line 67
  pthread_mutex_lock(& init_mutex);
  }
#line 68
  if (is_initialized) {
    {
#line 70
    pthread_mutex_unlock(& init_mutex);
    }
#line 71
    return;
  }
  {
#line 74
  *((void **)(& orig_execve)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execve");
#line 75
  *((void **)(& orig_fexecve)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"fexecve");
#line 76
  *((void **)(& orig_execl)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execl");
#line 77
  *((void **)(& orig_execlp)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execlp");
#line 78
  *((void **)(& orig_execle)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execle");
#line 79
  *((void **)(& orig_execv)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execv");
#line 80
  *((void **)(& orig_execvp)) = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"execvp");
#line 82
  tmp = getenv("HEXEC_EXPR_SHM");
#line 82
  shm_name = tmp;
  }
#line 84
  if (! shm_name) {
    {
#line 85
    hexec_fatal("HEXEC_EXPR_SHM is not set\n");
    }
  }
  {
#line 86
  tmp___0 = hexec_shm_open(& shm, (char const   *)shm_name);
  }
#line 86
  if (tmp___0) {
    {
#line 87
    hexec_fatal("failed to map expression\n");
    }
  }
  {
#line 88
  tmp___1 = hexec_shm_to_buf(& shm, & expr_buf);
  }
#line 88
  if (tmp___1) {
    {
#line 90
    hexec_shm_close(& shm);
#line 91
    hexec_fatal("failed to get buf from shm\n");
    }
  }
  {
#line 94
  expr_header = (struct hexec_expr_shm_header *)shm.buf;
#line 96
  tmp___2 = getenv("HEXEC_LOG_FD");
#line 96
  log_out_fd_str = tmp___2;
  }
#line 97
  if (log_out_fd_str) {
    {
#line 98
    log_out_fd = atoi((char const   *)log_out_fd_str);
    }
  }
  {
#line 100
  is_initialized = 1;
#line 101
  pthread_mutex_unlock(& init_mutex);
  }
#line 102
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
static int hook_execve(int fd , char const   *path , int is_absulute_path , struct args_t *args ,
                       struct args_t *env ) 
{ 
  int err ;
  char *path2 ;
  int last_exec_status ;
  int res ;
  int tmp ;
  int *tmp___0 ;

  {
#line 115
  err = 0;
#line 116
  path2 = (char *)((void *)0);
#line 120
  if (fd != -1) {
#line 120
    if (! path) {
      {
#line 122
      hexec_fatal("fd based exec not implemented");
      }
    } else {
#line 120
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 124
  if (fd == -1) {
#line 124
    if (path) {
#line 126
      if (! is_absulute_path) {
        {
#line 128
        err = hexec_locate(path, & path2);
        }
#line 128
        if (err) {
#line 130
          return (err);
        }
      }
    }
  }
#line 134
  if (! path2) {
    {
#line 135
    path2 = strdup(path);
    }
  }
  {
#line 136
  last_exec_status = 0;
#line 137
  tmp = hexec_expr_eval((char const   *)path2, args, env, & expr_buf, expr_header->root_expr,
                        & last_exec_status);
#line 137
  res = tmp;
  }
#line 138
  if (res == 1) {
    {
#line 143
    (*orig_execve)((char const   *)path2, (char * const  *)args->argv, (char * const  *)env->argv);
#line 144
    tmp___0 = __errno_location();
#line 144
    err = *tmp___0;
#line 145
    free((void *)path2);
    }
#line 146
    return (err);
  }
#line 148
  if (res == 2) {
    {
#line 150
    hexec_fatal("error in expression\n");
    }
  }
  {
#line 152
  free((void *)path2);
  }
#line 153
  if (! err) {
    {
#line 154
    exit(last_exec_status);
    }
  }
#line 156
  return (err);
}
}
#line 161
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *path ,
                                                                                        char * const  *argv ,
                                                                                        char * const  *envp ) ;
#line 161 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *path , char * const  *argv ,
                                                          char * const  *envp ) 
{ 
  int err ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 165
  init();
#line 166
  hexec_args_from_array(& args, argv);
#line 167
  hexec_args_from_array(& env, envp);
#line 168
  err = hook_execve(-1, path, 1, & args, & env);
#line 169
  hexec_args_free(& args);
#line 170
  hexec_args_free(& env);
#line 171
  tmp = __errno_location();
#line 171
  *tmp = err;
  }
#line 172
  return (err == 0);
}
}
#line 175
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int fd ,
                                                                                       char * const  *argv ,
                                                                                       char * const  *envp ) ;
#line 175 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(2), __leaf__)) fexecve)(int fd , char * const  *argv ,
                                                         char * const  *envp ) 
{ 
  int err ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 179
  init();
#line 180
  hexec_args_from_array(& args, argv);
#line 181
  hexec_args_from_array(& env, envp);
#line 182
  err = hook_execve(-1, (char const   *)((void *)0), 1, & args, & env);
#line 183
  hexec_args_free(& args);
#line 184
  hexec_args_free(& env);
#line 185
  tmp = __errno_location();
#line 185
  *tmp = err;
  }
#line 186
  return (err == 0);
}
}
#line 189
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path ,
                                                                                       char const   *arg 
                                                                                       , ...) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *path , char const   *arg 
                                                         , ...) 
{ 
  int err ;
  va_list va ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 195
  init();
#line 196
  __builtin_va_start(va, arg);
#line 197
  hexec_args_from_va_list(& args, arg, & va);
#line 198
  hexec_args_from_array(& env, (char * const  *)environ);
#line 199
  __builtin_va_end(va);
#line 200
  err = hook_execve(-1, path, 1, & args, & env);
#line 201
  hexec_args_free(& args);
#line 202
  hexec_args_free(& env);
#line 203
  tmp = __errno_location();
#line 203
  *tmp = err;
  }
#line 204
  return (err == 0);
}
}
#line 207
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *file ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 207 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *file , char const   *arg 
                                                          , ...) 
{ 
  int err ;
  va_list va ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 213
  init();
#line 214
  __builtin_va_start(va, arg);
#line 215
  hexec_args_from_va_list(& args, arg, & va);
#line 216
  hexec_args_from_array(& env, (char * const  *)environ);
#line 217
  __builtin_va_end(va);
#line 218
  err = hook_execve(-1, file, 0, & args, & env);
#line 219
  hexec_args_free(& args);
#line 220
  hexec_args_free(& env);
#line 221
  tmp = __errno_location();
#line 221
  *tmp = err;
  }
#line 222
  return (err == 0);
}
}
#line 225
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path ,
                                                                                        char const   *arg 
                                                                                        , ...) ;
#line 225 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execle)(char const   *path , char const   *arg 
                                                          , ...) 
{ 
  int err ;
  va_list va ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 231
  init();
#line 232
  __builtin_va_start(va, arg);
#line 233
  hexec_args_from_va_list(& args, arg, & va);
#line 234
  hexec_args_from_va_list(& env, (char const   *)((void *)0), & va);
#line 235
  __builtin_va_end(va);
#line 236
  err = hook_execve(-1, path, 1, & args, & env);
#line 237
  hexec_args_free(& args);
#line 238
  hexec_args_free(& env);
#line 239
  tmp = __errno_location();
#line 239
  *tmp = err;
  }
#line 240
  return (err == 0);
}
}
#line 243
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *path ,
                                                                                       char * const  *argv ) ;
#line 243 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *path , char * const  *argv ) 
{ 
  int err ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 248
  init();
#line 249
  hexec_args_from_array(& args, argv);
#line 250
  hexec_args_from_array(& env, (char * const  *)environ);
#line 251
  err = hook_execve(-1, path, 1, & args, & env);
#line 252
  hexec_args_free(& args);
#line 253
  hexec_args_free(& env);
#line 254
  tmp = __errno_location();
#line 254
  *tmp = err;
  }
#line 255
  return (err == 0);
}
}
#line 258
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *file ,
                                                                                        char * const  *argv ) ;
#line 258 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hook/libhexec-hook.c"
int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *file , char * const  *argv ) 
{ 
  int err ;
  struct args_t args ;
  struct args_t env ;
  int *tmp ;

  {
  {
#line 263
  init();
#line 264
  hexec_args_from_array(& args, argv);
#line 265
  hexec_args_from_array(& env, (char * const  *)environ);
#line 266
  err = hook_execve(-1, file, 0, & args, & env);
#line 267
  hexec_args_free(& args);
#line 268
  hexec_args_free(& env);
#line 269
  tmp = __errno_location();
#line 269
  *tmp = err;
  }
#line 270
  return (err == 0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/locate.c"
static int check_access___0(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = access(path, 1);
  }
#line 44
  return (tmp);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
static int hexec_args_grow___0(struct args_t *args , int argc ) 
{ 
  void *tmp ;

  {
#line 30
  if (args->max_argc >= argc) {
#line 31
    return (0);
  }
  {
#line 32
  tmp = realloc((void *)args->argv, (unsigned long )(argc + 1) * sizeof(char *));
#line 32
  args->argv = (char **)tmp;
#line 33
  args->max_argc = argc;
  }
#line 34
  return (0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/locate.c"
static int check_access___1(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = access(path, 1);
  }
#line 44
  return (tmp);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.h"
void hexec_parser_init(struct hexec_parser *p , struct hexec_buf *buf , struct args_t *args ,
                       int first_arg ) ;
#line 40
int hexec_parser_parse(void *yyparam_ ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
void print_version(void) 
{ 


  {
  {
#line 43
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s version %s\n",
          "hexec", "0.2.1");
  }
#line 44
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
void print_copyright(void) 
{ 


  {
  {
#line 48
  print_version();
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Copyright 2008 (c) by Alexander Block\n");
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
void print_usage(char const   *msg , _Bool do_exit ) 
{ 


  {
#line 54
  if (msg) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            msg);
    }
  }
  {
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: hexec <expr> cmd [args...]\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use \'man hexec\' to get a detailed documentation\n");
  }
#line 58
  if (do_exit) {
    {
#line 59
    exit(1);
    }
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
static void append_env(char const   *var , char const   *value ) 
{ 
  char *orig_value ;
  char *tmp ;
  char *new_value ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = getenv(var);
#line 64
  orig_value = tmp;
  }
#line 65
  if (! orig_value) {
    {
#line 67
    setenv(var, value, 1);
    }
  } else {
    {
#line 71
    tmp___0 = strlen((char const   *)orig_value);
#line 71
    tmp___1 = strlen(value);
#line 71
    tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 71
    new_value = (char *)tmp___2;
#line 72
    strcpy((char */* __restrict  */)new_value, (char const   */* __restrict  */)orig_value);
#line 73
    strcat((char */* __restrict  */)new_value, (char const   */* __restrict  */)" ");
#line 74
    strcat((char */* __restrict  */)new_value, (char const   */* __restrict  */)value);
#line 75
    setenv(var, (char const   *)new_value, 1);
#line 76
    free((void *)new_value);
    }
  }
#line 78
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
_Bool parse_opt(int argc , char **argv , int *cur_arg , char *name , _Bool needs_value ,
                char **value ) 
{ 
  size_t arg_len ;
  size_t tmp ;
  size_t name_len ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 82
  if (*cur_arg >= argc) {
#line 83
    return ((_Bool)0);
  }
  {
#line 84
  tmp = strlen((char const   *)*(argv + *cur_arg));
#line 84
  arg_len = tmp;
#line 85
  tmp___0 = strlen((char const   *)name);
#line 85
  name_len = tmp___0;
#line 87
  tmp___1 = strncmp((char const   *)*(argv + *cur_arg), (char const   *)name, name_len);
  }
#line 87
  if (! tmp___1) {
#line 89
    if (needs_value) {
#line 91
      if (arg_len > name_len) {
#line 93
        *value = *(argv + *cur_arg) + name_len;
#line 94
        (*cur_arg) ++;
#line 95
        return ((_Bool)1);
      } else {
#line 99
        if (*cur_arg + 1 >= argc) {
          {
#line 101
          print_usage("missing value for argument", (_Bool)1);
          }
        }
#line 104
        *value = *(argv + (*cur_arg + 1));
#line 105
        *cur_arg += 2;
#line 106
        return ((_Bool)1);
      }
    } else {
#line 111
      if (arg_len != name_len) {
#line 112
        return ((_Bool)0);
      }
#line 113
      (*cur_arg) ++;
#line 114
      return ((_Bool)1);
    }
  }
#line 117
  return ((_Bool)0);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
void make_shm_name(char *name ) 
{ 
  __pid_t tmp ;

  {
  {
#line 122
  tmp = getpid();
#line 122
  sprintf((char */* __restrict  */)name, (char const   */* __restrict  */)"/hexec-shm-%d",
          tmp);
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
void sig_handler(int signum ) 
{ 
  char shm_name[128] ;

  {
  {
#line 128
  make_shm_name(shm_name);
#line 129
  hexec_log("Received interrupt. Removing shm object \'%s\'\n", shm_name);
#line 130
  shm_unlink((char const   *)(shm_name));
#line 131
  exit(1);
  }
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/hexec.c"
int main(int argc , char **argv ) 
{ 
  int err ;
  char shm_name[128] ;
  char *log_out ;
  struct hexec_buf buf ;
  struct hexec_shm shm___0 ;
  struct hexec_parser parser ;
  struct args_t args ;
  int cur_arg ;
  struct sigaction act ;
  char *value ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int first_expr_arg ;
  int tmp___5 ;
  int pid ;
  __pid_t tmp___6 ;
  char tmp___7[16] ;
  int err___0 ;
  int tmp___8 ;
  int *tmp___9 ;
  int status ;
  __pid_t tmp___10 ;
  union __anonunion_67 __constr_expr_3 ;
  union __anonunion_68 __constr_expr_4 ;
  union __anonunion_69 __constr_expr_5 ;

  {
  {
#line 138
  log_out = (char *)((void *)0);
#line 143
  cur_arg = 1;
#line 149
  memset((void *)(& act), 0, sizeof(act));
#line 150
  act.__sigaction_handler.sa_handler = & sig_handler;
#line 151
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 153
  if (argc == 1) {
    {
#line 155
    print_copyright();
#line 156
    print_usage("\nno arguments given\n", (_Bool)1);
    }
  }
  {
#line 159
  hexec_open_log_fd("/dev/stderr");
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    tmp___3 = parse_opt(argc, argv, & cur_arg, (char *)"-h", (_Bool)0, & value);
    }
#line 164
    if (tmp___3) {
      {
#line 167
      print_copyright();
#line 168
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 169
      print_usage((char const   *)((void *)0), (_Bool)1);
      }
    } else {
      {
#line 164
      tmp___4 = parse_opt(argc, argv, & cur_arg, (char *)"--help", (_Bool)0, & value);
      }
#line 164
      if (tmp___4) {
        {
#line 167
        print_copyright();
#line 168
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 169
        print_usage((char const   *)((void *)0), (_Bool)1);
        }
      } else {
        {
#line 171
        tmp___1 = parse_opt(argc, argv, & cur_arg, (char *)"-v", (_Bool)0, & value);
        }
#line 171
        if (tmp___1) {
          {
#line 174
          print_version();
#line 175
          exit(0);
          }
        } else {
          {
#line 171
          tmp___2 = parse_opt(argc, argv, & cur_arg, (char *)"--version", (_Bool)0,
                              & value);
          }
#line 171
          if (tmp___2) {
            {
#line 174
            print_version();
#line 175
            exit(0);
            }
          } else {
            {
#line 177
            tmp = parse_opt(argc, argv, & cur_arg, (char *)"-lo", (_Bool)1, & value);
            }
#line 177
            if (tmp) {
#line 180
              log_out = value;
            } else {
              {
#line 177
              tmp___0 = parse_opt(argc, argv, & cur_arg, (char *)"--log-out", (_Bool)1,
                                  & value);
              }
#line 177
              if (tmp___0) {
#line 180
                log_out = value;
              } else {
#line 183
                goto while_break;
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  first_expr_arg = cur_arg;
#line 188
  hexec_args_from_array(& args, (char * const  *)argv);
#line 189
  hexec_buf_create(& buf);
#line 190
  hexec_parser_init(& parser, & buf, & args, first_expr_arg);
#line 192
  tmp___5 = hexec_parser_parse((void *)(& parser));
  }
#line 192
  if (tmp___5) {
    {
#line 193
    print_usage("parsing of expression failed\n", (_Bool)1);
    }
  }
#line 194
  if (parser.result == -1) {
    {
#line 195
    print_usage("missing expression\n", (_Bool)1);
    }
  }
#line 197
  if (parser.cur_arg >= argc) {
    {
#line 198
    print_usage("missing command\n", (_Bool)1);
    }
  }
  {
#line 200
  make_shm_name(shm_name);
#line 201
  hexec_log("shm_name: %s\n", shm_name);
#line 205
  err = hexec_shm_create(& shm___0, (char const   *)(shm_name), & buf);
  }
#line 206
  if (err) {
    {
#line 207
    hexec_fatal("failed to create shared memory object\n");
    }
  }
  {
#line 213
  tmp___6 = fork();
#line 213
  pid = tmp___6;
  }
#line 214
  if (pid == -1) {
    {
#line 215
    hexec_fatal("failed to fork process\n");
    }
  }
#line 216
  if (pid == 0) {
    {
#line 222
    append_env("LD_PRELOAD", "/usr/local/lib/hexec/libhexec-hook.so");
#line 223
    setenv("HEXEC_EXPR_SHM", (char const   *)(shm_name), 1);
    }
#line 224
    if (log_out) {
      {
#line 226
      hexec_open_log_fd((char const   *)log_out);
      }
    }
    {
#line 229
    sprintf((char */* __restrict  */)(tmp___7), (char const   */* __restrict  */)"%d",
            log_out_fd);
#line 230
    setenv("HEXEC_LOG_FD", (char const   *)(tmp___7), 1);
#line 233
    tmp___8 = execvp((char const   *)*(args.argv + parser.cur_arg), (char * const  *)(args.argv + parser.cur_arg));
#line 233
    err___0 = tmp___8;
#line 234
    hexec_error("failed to call command\n");
#line 235
    tmp___9 = __errno_location();
#line 235
    exit(*tmp___9);
    }
  }
  {
#line 239
  tmp___10 = waitpid(pid, & status, 0);
  }
#line 239
  if (tmp___10 != pid) {
    {
#line 241
    hexec_shm_close(& shm___0);
#line 242
    hexec_fatal("waitpid failed\n");
    }
  }
  {
#line 245
  hexec_shm_close(& shm___0);
#line 247
  __constr_expr_4.__in = status;
  }
#line 247
  if ((__constr_expr_4.__i & 65280) >> 8 == 0) {
#line 247
    __constr_expr_5.__in = status;
#line 247
    if ((int )((signed char )((__constr_expr_5.__i & 127) + 1)) >> 1 > 0) {
#line 249
      return (-1);
    } else {
#line 253
      __constr_expr_3.__in = status;
#line 253
      return ((__constr_expr_3.__i & 65280) >> 8);
    }
  } else {
#line 253
    __constr_expr_3.__in = status;
#line 253
    return ((__constr_expr_3.__i & 65280) >> 8);
  }
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/common/args.c"
static int hexec_args_grow___1(struct args_t *args , int argc ) 
{ 
  void *tmp ;

  {
#line 30
  if (args->max_argc >= argc) {
#line 31
    return (0);
  }
  {
#line 32
  tmp = realloc((void *)args->argv, (unsigned long )(argc + 1) * sizeof(char *));
#line 32
  args->argv = (char **)tmp;
#line 33
  args->max_argc = argc;
  }
#line 34
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 569
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.h"
int hexec_parser_build_not(struct hexec_parser *p , int expr ) ;
#line 43
int hexec_parser_build_and(struct hexec_parser *p , int left , int right ) ;
#line 44
int hexec_parser_build_or(struct hexec_parser *p , int left , int right ) ;
#line 46
_Bool hexec_action_parse_print(struct hexec_parser *p , int *action ) ;
#line 47
_Bool hexec_action_parse_fname_match(struct hexec_parser *p , int *action , int type ,
                                     _Bool case_insensitive ) ;
#line 48
_Bool hexec_action_parse_exec(struct hexec_parser *p , int *action ) ;
#line 49
_Bool hexec_action_parse_sh(struct hexec_parser *p , int *action ) ;
#line 36 "expr-grammar.y"
int hexec_parser_lex(struct hexec_parser *p ) ;
#line 39 "expr-grammar.y"
void hexec_parser_error(char const   *msg ) 
{ 


  {
#line 42
  return;
}
}
#line 399 "hexec-expr-grammar.c"
static yytype_uint8 const   yytranslate[265]  = 
#line 399 "hexec-expr-grammar.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9};
#line 433 "hexec-expr-grammar.c"
static yytype_uint8 const   yyprhs[15]  = 
#line 433
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )34};
#line 440 "hexec-expr-grammar.c"
static yytype_int8 const   yyrhs[36]  = 
#line 440
  {      (yytype_int8 const   )11,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )3,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )16, 
        (yytype_int8 const   )6,      (yytype_int8 const   )-1,      (yytype_int8 const   )12,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )7,      (yytype_int8 const   )13,      (yytype_int8 const   )-1,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )8,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )13,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )-1,      (yytype_int8 const   )15,      (yytype_int8 const   )9, 
        (yytype_int8 const   )14,      (yytype_int8 const   )-1,      (yytype_int8 const   )15,      (yytype_int8 const   )-1};
#line 449 "hexec-expr-grammar.c"
static yytype_uint8 const   yyrline[15]  = 
#line 449
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )96};
#line 459 "hexec-expr-grammar.c"
static char const   * const  yytname[18]  = 
#line 459
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"T_ACTION", 
        (char const   */* const  */)"T_CONSTANT",      (char const   */* const  */)"T_OB",      (char const   */* const  */)"T_CB",      (char const   */* const  */)"T_UNARY_NOT", 
        (char const   */* const  */)"T_BINARY_AND",      (char const   */* const  */)"T_BINARY_OR",      (char const   */* const  */)"$accept",      (char const   */* const  */)"input", 
        (char const   */* const  */)"primary_expression",      (char const   */* const  */)"unary_expression",      (char const   */* const  */)"logical_and_expression",      (char const   */* const  */)"logical_or_expression", 
        (char const   */* const  */)"expression",      (char const   */* const  */)0};
#line 478 "hexec-expr-grammar.c"
static yytype_uint8 const   yyr1[15]  = 
#line 478
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )12,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16};
#line 485 "hexec-expr-grammar.c"
static yytype_uint8 const   yyr2[15]  = 
#line 485
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1};
#line 494 "hexec-expr-grammar.c"
static yytype_uint8 const   yydefact[20]  = 
#line 494
  {      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )14,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )10,      (yytype_uint8 const   )13};
#line 501 "hexec-expr-grammar.c"
static yytype_int8 const   yydefgoto[7]  = {      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10};
#line 509 "hexec-expr-grammar.c"
static yytype_int8 const   yypact[20]  = 
#line 509
  {      (yytype_int8 const   )4,      (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )4, 
        (yytype_int8 const   )4,      (yytype_int8 const   )12,      (yytype_int8 const   )-5,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )5,      (yytype_int8 const   )-5,      (yytype_int8 const   )7, 
        (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )4,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )4,      (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )-2};
#line 516 "hexec-expr-grammar.c"
static yytype_int8 const   yypgoto[7]  = {      (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )-5,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )0,      (yytype_int8 const   )-5,      (yytype_int8 const   )14};
#line 526 "hexec-expr-grammar.c"
static yytype_uint8 const   yytable[18]  = 
#line 526
  {      (yytype_uint8 const   )12,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )4,      (yytype_uint8 const   )14,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )18,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )17,      (yytype_uint8 const   )16,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )11};
#line 532 "hexec-expr-grammar.c"
static yytype_uint8 const   yycheck[18]  = 
#line 532
  {      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )14,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )3};
#line 540 "hexec-expr-grammar.c"
static yytype_uint8 const   yystos[20]  = 
#line 540
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )6,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14};
#line 669 "hexec-expr-grammar.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 679
  if (! yyvaluep) {
#line 680
    return;
  }
  {
#line 689
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 690
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 692
  return;
}
}
#line 701 "hexec-expr-grammar.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 711
  if (yytype < 10) {
    {
#line 712
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 714
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 716
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 717
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 718
  return;
}
}
#line 727 "hexec-expr-grammar.c"
static void yy_stack_print(yytype_int16 *bottom , yytype_int16 *top ) 
{ 


  {
  {
#line 736
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 737
  while (1) {
    while_continue: /* CIL Label */ ;
#line 737
    if (! ((unsigned long )bottom <= (unsigned long )top)) {
#line 737
      goto while_break;
    }
    {
#line 738
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            (int )*bottom);
#line 737
    bottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 739
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 740
  return;
}
}
#line 755 "hexec-expr-grammar.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 764
  yynrhs = (int )yyr2[yyrule];
#line 766
  yylno = (unsigned long )yyrline[yyrule];
#line 767
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 770
  yyi = 0;
  }
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (yyi < yynrhs)) {
#line 770
      goto while_break;
    }
    {
#line 772
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 773
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 776
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 770
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return;
}
}
#line 788 "hexec-expr-grammar.c"
int hexec_parser_debug  ;
#line 876 "hexec-expr-grammar.c"
static unsigned long yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned long yyn ;
  char const   *yyp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 879
  if ((int const   )*yystr == 34) {
#line 881
    yyn = 0UL;
#line 882
    yyp = yystr;
    {
#line 884
    while (1) {
      while_continue: /* CIL Label */ ;
#line 885
      yyp ++;
      {
#line 888
      if ((int const   )*yyp == 44) {
#line 888
        goto case_44;
      }
#line 888
      if ((int const   )*yyp == 39) {
#line 888
        goto case_44;
      }
#line 891
      if ((int const   )*yyp == 92) {
#line 891
        goto case_92;
      }
#line 901
      if ((int const   )*yyp == 34) {
#line 901
        goto case_34;
      }
#line 895
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 889
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 892
      yyp ++;
#line 892
      if ((int const   )*yyp != 92) {
#line 893
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 896
      if (yyres) {
#line 897
        *(yyres + yyn) = (char )*yyp;
      }
#line 898
      yyn ++;
#line 899
      goto switch_break;
      case_34: /* CIL Label */ 
#line 902
      if (yyres) {
#line 903
        *(yyres + yyn) = (char )'\000';
      }
#line 904
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 909
  if (! yyres) {
    {
#line 910
    tmp = strlen(yystr);
    }
#line 910
    return (tmp);
  }
  {
#line 912
  tmp___0 = stpcpy((char */* __restrict  */)yyres, (char const   */* __restrict  */)yystr);
  }
#line 912
  return ((unsigned long )(tmp___0 - yyres));
}
}
#line 952
static unsigned long yysyntax_error(char *yyresult , int yystate , int hexec_parser_char___0 ) ;
#line 952 "hexec-expr-grammar.c"
static char const   yyunexpected[28]  = 
#line 952
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 953 "hexec-expr-grammar.c"
static char const   yyexpecting[15]  = 
#line 953
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 954 "hexec-expr-grammar.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 923 "hexec-expr-grammar.c"
static unsigned long yysyntax_error(char *yyresult , int yystate , int hexec_parser_char___0 ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned long yysize0 ;
  unsigned long tmp___0 ;
  unsigned long yysize ;
  unsigned long yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char tmp___8 ;

  {
#line 926
  yyn = (int )yypact[yystate];
#line 928
  if (-5 < yyn) {
#line 928
    if (yyn <= 17) {
#line 932
      if ((unsigned int )hexec_parser_char___0 <= 264U) {
#line 932
        tmp = (int const   )yytranslate[hexec_parser_char___0];
      } else {
#line 932
        tmp = (int const   )2;
      }
      {
#line 932
      yytype = (int )tmp;
#line 933
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 933
      yysize0 = tmp___0;
#line 934
      yysize = yysize0;
#line 936
      yysize_overflow = 0;
#line 959
      yyprefix = yyexpecting;
      }
#line 963
      if (yyn < 0) {
#line 963
        tmp___1 = - yyn;
      } else {
#line 963
        tmp___1 = 0;
      }
#line 963
      yyxbegin = tmp___1;
#line 966
      yychecklim = (17 - yyn) + 1;
#line 967
      if (yychecklim < 10) {
#line 967
        tmp___2 = yychecklim;
      } else {
#line 967
        tmp___2 = 10;
      }
      {
#line 967
      yyxend = tmp___2;
#line 968
      yycount = 1;
#line 970
      yyarg[0] = (char const   *)yytname[yytype];
#line 971
      yyfmt = stpcpy((char */* __restrict  */)(yyformat), (char const   */* __restrict  */)(yyunexpected));
#line 973
      yyx = yyxbegin;
      }
      {
#line 973
      while (1) {
        while_continue: /* CIL Label */ ;
#line 973
        if (! (yyx < yyxend)) {
#line 973
          goto while_break;
        }
#line 974
        if ((int const   )yycheck[yyx + yyn] == (int const   )yyx) {
#line 974
          if (yyx != 1) {
#line 976
            if (yycount == 5) {
#line 978
              yycount = 1;
#line 979
              yysize = yysize0;
#line 980
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 981
              goto while_break;
            }
            {
#line 983
            tmp___3 = yycount;
#line 983
            yycount ++;
#line 983
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 984
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 984
            yysize1 = yysize + tmp___4;
#line 985
            yysize_overflow |= yysize1 < yysize;
#line 986
            yysize = yysize1;
#line 987
            yyfmt = stpcpy((char */* __restrict  */)yyfmt, (char const   */* __restrict  */)yyprefix);
#line 988
            yyprefix = yyor;
            }
          }
        }
#line 973
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 991
      yyf = (char const   *)(yyformat);
#line 992
      tmp___5 = strlen(yyf);
#line 992
      yysize1 = yysize + tmp___5;
#line 993
      yysize_overflow |= yysize1 < yysize;
#line 994
      yysize = yysize1;
      }
#line 996
      if (yysize_overflow) {
#line 997
        return (0xffffffffffffffffUL);
      }
#line 999
      if (yyresult) {
#line 1004
        yyp = yyresult;
#line 1005
        yyi = 0;
        {
#line 1006
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1006
          tmp___8 = (char )*yyf;
#line 1006
          *yyp = tmp___8;
#line 1006
          if (! ((int )tmp___8 != 0)) {
#line 1006
            goto while_break___0;
          }
#line 1008
          if ((int )*yyp == 37) {
#line 1008
            if ((int const   )*(yyf + 1) == 115) {
#line 1008
              if (yyi < yycount) {
                {
#line 1010
                tmp___6 = yyi;
#line 1010
                yyi ++;
#line 1010
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1010
                yyp += tmp___7;
#line 1011
                yyf += 2;
                }
              } else {
#line 1015
                yyp ++;
#line 1016
                yyf ++;
              }
            } else {
#line 1015
              yyp ++;
#line 1016
              yyf ++;
            }
          } else {
#line 1015
            yyp ++;
#line 1016
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1020
      return (yysize);
    } else {
#line 929
      return (0UL);
    }
  } else {
#line 929
    return (0UL);
  }
}
}
#line 1033 "hexec-expr-grammar.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1045
  if (! yymsg) {
#line 1046
    yymsg = "Deleting";
  }
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if (hexec_parser_debug) {
      {
#line 1047
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1047
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1047
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1047
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1052
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1053
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1055
  return;
}
}
#line 1077 "hexec-expr-grammar.c"
int hexec_parser_char  ;
#line 1080 "hexec-expr-grammar.c"
YYSTYPE hexec_parser_lval  ;
#line 1083 "hexec-expr-grammar.c"
int hexec_parser_nerrs  ;
#line 1094 "hexec-expr-grammar.c"
int hexec_parser_parse(void *yyparam_ ) 
{ 
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned long yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  unsigned long yysize___0 ;
  unsigned long tmp___0 ;
  unsigned long yyalloc ;
  void *tmp___1 ;

  {
#line 1120
  yytoken = 0;
#line 1124
  yymsg = yymsgbuf;
#line 1125
  yymsg_alloc = sizeof(yymsgbuf);
#line 1138
  yyss = yyssa;
#line 1143
  yyvs = yyvsa;
#line 1150
  yystacksize = 200UL;
#line 1159
  yylen = 0;
  {
#line 1161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1161
    if (hexec_parser_debug) {
      {
#line 1161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1161
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1163
  yystate = 0;
#line 1164
  yyerrstatus = 0;
#line 1165
  hexec_parser_nerrs = 0;
#line 1166
  hexec_parser_char = -2;
#line 1173
  yyssp = yyss;
#line 1174
  yyvsp = yyvs;
#line 1176
  goto yysetstate;
  yynewstate: 
#line 1184
  yyssp ++;
  yysetstate: 
#line 1187
  *yyssp = (yytype_int16 )yystate;
#line 1189
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1192
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1221
    if (10000UL <= yystacksize) {
#line 1222
      goto yyexhaustedlab;
    }
#line 1223
    yystacksize *= 2UL;
#line 1224
    if (10000UL < yystacksize) {
#line 1225
      yystacksize = 10000UL;
    }
    {
#line 1228
    yyss1 = yyss;
#line 1229
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1229
    yyptr = (union yyalloc *)tmp;
    }
#line 1231
    if (! yyptr) {
#line 1232
      goto yyexhaustedlab;
    }
    {
#line 1233
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1233
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1233
      yyss = & yyptr->yyss;
#line 1233
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1233
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1233
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1234
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1234
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1234
      yyvs = & yyptr->yyvs;
#line 1234
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1234
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1234
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1237
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1238
      free((void *)yyss1);
      }
    }
#line 1243
    yyssp = (yyss + yysize) - 1;
#line 1244
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1247
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1247
      if (hexec_parser_debug) {
        {
#line 1247
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 1247
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1250
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1251
      goto yyabortlab;
    }
  }
  {
#line 1254
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1254
    if (hexec_parser_debug) {
      {
#line 1254
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1254
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1256
  goto yybackup;
  yybackup: 
#line 1267
  yyn = (int )yypact[yystate];
#line 1268
  if (yyn == -5) {
#line 1269
    goto yydefault;
  }
#line 1274
  if (hexec_parser_char == -2) {
    {
#line 1276
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1276
      if (hexec_parser_debug) {
        {
#line 1276
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1276
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1277
    hexec_parser_char = hexec_parser_lex((struct hexec_parser *)yyparam_);
    }
  }
#line 1280
  if (hexec_parser_char <= 0) {
#line 1282
    yytoken = 0;
#line 1282
    hexec_parser_char = yytoken;
    {
#line 1283
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1283
      if (hexec_parser_debug) {
        {
#line 1283
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1283
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1287
    if ((unsigned int )hexec_parser_char <= 264U) {
#line 1287
      yytoken = (int )yytranslate[hexec_parser_char];
    } else {
#line 1287
      yytoken = 2;
    }
    {
#line 1288
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1288
      if (hexec_parser_debug) {
        {
#line 1288
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1288
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& hexec_parser_lval));
#line 1288
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1288
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1293
  yyn += yytoken;
#line 1294
  if (yyn < 0) {
#line 1295
    goto yydefault;
  } else
#line 1294
  if (17 < yyn) {
#line 1295
    goto yydefault;
  } else
#line 1294
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1295
    goto yydefault;
  }
#line 1296
  yyn = (int )yytable[yyn];
#line 1297
  if (yyn <= 0) {
#line 1299
    if (yyn == 0) {
#line 1300
      goto yyerrlab;
    } else
#line 1299
    if (yyn == -1) {
#line 1300
      goto yyerrlab;
    }
#line 1301
    yyn = - yyn;
#line 1302
    goto yyreduce;
  }
#line 1305
  if (yyn == 13) {
#line 1306
    goto yyacceptlab;
  }
#line 1310
  if (yyerrstatus) {
#line 1311
    yyerrstatus --;
  }
  {
#line 1314
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1314
    if (hexec_parser_debug) {
      {
#line 1314
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1314
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& hexec_parser_lval));
#line 1314
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1314
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1317
  if (hexec_parser_char != 0) {
#line 1318
    hexec_parser_char = -2;
  }
#line 1320
  yystate = yyn;
#line 1321
  yyvsp ++;
#line 1321
  *yyvsp = hexec_parser_lval;
#line 1323
  goto yynewstate;
  yydefault: 
#line 1330
  yyn = (int )yydefact[yystate];
#line 1331
  if (yyn == 0) {
#line 1332
    goto yyerrlab;
  }
#line 1333
  goto yyreduce;
  yyreduce: 
#line 1341
  yylen = (int )yyr2[yyn];
#line 1351
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1354
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1354
    if (hexec_parser_debug) {
      {
#line 1354
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1354
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1357
  if (yyn == 3) {
#line 1357
    goto case_3;
  }
#line 68
  if (yyn == 6) {
#line 68 "expr-grammar.y"
    goto case_6;
  }
#line 75
  if (yyn == 8) {
#line 75
    goto case_8;
  }
#line 81
  if (yyn == 10) {
#line 81
    goto case_10;
  }
#line 87
  if (yyn == 11) {
#line 87
    goto case_11;
  }
#line 89
  if (yyn == 13) {
#line 89
    goto case_13;
  }
#line 1390 "hexec-expr-grammar.c"
  goto switch_default;
  case_3: /* CIL Label */ 
#line 65 "expr-grammar.y"
  ((struct hexec_parser *)yyparam_)->result = 0;
#line 65
  (((struct hexec_parser *)yyparam_)->shm_header)->root_expr = (yyvsp + 0)->expr;
#line 66
  goto switch_break;
  case_6: /* CIL Label */ 
#line 72
  yyval.expr = (yyvsp + -1)->expr;
#line 73
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 78
  yyval.expr = hexec_parser_build_not((struct hexec_parser *)yyparam_, (yyvsp + 0)->expr);
  }
#line 79
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 84
  yyval.expr = hexec_parser_build_and((struct hexec_parser *)yyparam_, (yyvsp + -2)->expr,
                                      (yyvsp + 0)->expr);
  }
#line 85
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 86
  yyval.expr = hexec_parser_build_and((struct hexec_parser *)yyparam_, (yyvsp + -1)->expr,
                                      (yyvsp + 0)->expr);
  }
#line 87
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 92
  yyval.expr = hexec_parser_build_or((struct hexec_parser *)yyparam_, (yyvsp + -2)->expr,
                                     (yyvsp + 0)->expr);
  }
#line 93
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1390 "hexec-expr-grammar.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1392
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1392
    if (hexec_parser_debug) {
      {
#line 1392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 1392
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval));
#line 1392
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1392
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1394
  yyvsp -= yylen;
#line 1394
  yyssp -= yylen;
#line 1395
  yylen = 0;
  {
#line 1396
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1396
    if (hexec_parser_debug) {
      {
#line 1396
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1396
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1398
  yyvsp ++;
#line 1398
  *yyvsp = yyval;
#line 1405
  yyn = (int )yyr1[yyn];
#line 1407
  yystate = (int )((int const   )yypgoto[yyn - 10] + (int const   )*yyssp);
#line 1408
  if (0 <= yystate) {
#line 1408
    if (yystate <= 17) {
#line 1408
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 1409
        yystate = (int )yytable[yystate];
      } else {
#line 1411
        yystate = (int )yydefgoto[yyn - 10];
      }
    } else {
#line 1411
      yystate = (int )yydefgoto[yyn - 10];
    }
  } else {
#line 1411
    yystate = (int )yydefgoto[yyn - 10];
  }
#line 1413
  goto yynewstate;
  yyerrlab: 
#line 1421
  if (! yyerrstatus) {
    {
#line 1423
    hexec_parser_nerrs ++;
#line 1428
    tmp___0 = yysyntax_error((char *)0, yystate, hexec_parser_char);
#line 1428
    yysize___0 = tmp___0;
    }
#line 1429
    if (yymsg_alloc < yysize___0) {
#line 1429
      if (yymsg_alloc < 0xffffffffffffffffUL) {
#line 1431
        yyalloc = 2UL * yysize___0;
#line 1432
        if (yysize___0 <= yyalloc) {
#line 1432
          if (! (yyalloc <= 0xffffffffffffffffUL)) {
#line 1433
            yyalloc = 0xffffffffffffffffUL;
          }
        } else {
#line 1433
          yyalloc = 0xffffffffffffffffUL;
        }
#line 1434
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 1435
          free((void *)yymsg);
          }
        }
        {
#line 1436
        tmp___1 = malloc(yyalloc);
#line 1436
        yymsg = (char *)tmp___1;
        }
#line 1437
        if (yymsg) {
#line 1438
          yymsg_alloc = yyalloc;
        } else {
#line 1441
          yymsg = yymsgbuf;
#line 1442
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 1446
    if (0UL < yysize___0) {
#line 1446
      if (yysize___0 <= yymsg_alloc) {
        {
#line 1448
        yysyntax_error(yymsg, yystate, hexec_parser_char);
#line 1449
        hexec_parser_error((char const   *)yymsg);
        }
      } else {
#line 1446
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1453
      hexec_parser_error("syntax error");
      }
#line 1454
      if (yysize___0 != 0UL) {
#line 1455
        goto yyexhaustedlab;
      }
    }
  }
#line 1463
  if (yyerrstatus == 3) {
#line 1468
    if (hexec_parser_char <= 0) {
#line 1471
      if (hexec_parser_char == 0) {
#line 1472
        goto yyabortlab;
      }
    } else {
      {
#line 1476
      yydestruct("Error: discarding", yytoken, & hexec_parser_lval);
#line 1478
      hexec_parser_char = -2;
      }
    }
  }
#line 1484
  goto yyerrlab1;
#line 1500
  yyvsp -= yylen;
#line 1500
  yyssp -= yylen;
#line 1501
  yylen = 0;
  {
#line 1502
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1502
    if (hexec_parser_debug) {
      {
#line 1502
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1502
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1503
  yystate = (int )*yyssp;
#line 1504
  goto yyerrlab1;
  yyerrlab1: 
#line 1511
  yyerrstatus = 3;
  {
#line 1513
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1515
    yyn = (int )yypact[yystate];
#line 1516
    if (yyn != -5) {
#line 1518
      yyn ++;
#line 1519
      if (0 <= yyn) {
#line 1519
        if (yyn <= 17) {
#line 1519
          if ((int const   )yycheck[yyn] == 1) {
#line 1521
            yyn = (int )yytable[yyn];
#line 1522
            if (0 < yyn) {
#line 1523
              goto while_break___12;
            }
          }
        }
      }
    }
#line 1528
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1529
      goto yyabortlab;
    }
    {
#line 1532
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 1534
    yyvsp --;
#line 1534
    yyssp --;
#line 1535
    yystate = (int )*yyssp;
    }
    {
#line 1536
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1536
      if (hexec_parser_debug) {
        {
#line 1536
        yy_stack_print(yyss, yyssp);
        }
      }
#line 1536
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1539
  if (yyn == 13) {
#line 1540
    goto yyacceptlab;
  }
#line 1542
  yyvsp ++;
#line 1542
  *yyvsp = hexec_parser_lval;
  {
#line 1546
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 1546
    if (hexec_parser_debug) {
      {
#line 1546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1546
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 1546
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1546
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1548
  yystate = yyn;
#line 1549
  goto yynewstate;
  yyacceptlab: 
#line 1556
  yyresult = 0;
#line 1557
  goto yyreturn;
  yyabortlab: 
#line 1563
  yyresult = 1;
#line 1564
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1571
  hexec_parser_error("memory exhausted");
#line 1572
  yyresult = 2;
  }
  yyreturn: 
#line 1577
  if (hexec_parser_char != 0) {
#line 1577
    if (hexec_parser_char != -2) {
      {
#line 1578
      yydestruct("Cleanup: discarding lookahead", yytoken, & hexec_parser_lval);
      }
    }
  }
#line 1582
  yyvsp -= yylen;
#line 1582
  yyssp -= yylen;
  {
#line 1583
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1583
    if (hexec_parser_debug) {
      {
#line 1583
      yy_stack_print(yyss, yyssp);
      }
    }
#line 1583
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 1584
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 1584
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1584
      goto while_break___16;
    }
    {
#line 1586
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 1588
    yyvsp --;
#line 1588
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1591
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1592
    free((void *)yyss);
    }
  }
#line 1595
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 1596
    free((void *)yymsg);
    }
  }
#line 1599
  return (yyresult);
}
}
#line 101 "expr-grammar.y"
int hexec_parser_lex2(struct hexec_parser *p ) 
{ 
  char const   *a ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int tmp___17 ;
  _Bool tmp___18 ;
  int tmp___19 ;
  int tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  int tmp___27 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  int tmp___31 ;
  int tmp___33 ;
  _Bool tmp___34 ;
  int tmp___35 ;
  int tmp___37 ;
  _Bool tmp___38 ;
  int tmp___39 ;
  int tmp___41 ;
  _Bool tmp___42 ;
  int tmp___43 ;

  {
#line 103
  if (p->cur_arg >= (p->args)->argc) {
#line 104
    return (-1);
  }
  {
#line 105
  tmp = p->cur_arg;
#line 105
  (p->cur_arg) ++;
#line 105
  a = (char const   *)*((p->args)->argv + tmp);
#line 106
  tmp___0 = strcmp(a, "(");
  }
#line 106
  if (! tmp___0) {
#line 107
    return (260);
  }
  {
#line 108
  tmp___1 = strcmp(a, ")");
  }
#line 108
  if (! tmp___1) {
#line 109
    return (261);
  }
  {
#line 110
  tmp___2 = strcmp(a, "!");
  }
#line 110
  if (tmp___2) {
    {
#line 110
    tmp___3 = strcmp(a, "-not");
    }
#line 110
    if (! tmp___3) {
#line 111
      return (262);
    }
  } else {
#line 111
    return (262);
  }
  {
#line 112
  tmp___4 = strcmp(a, "-a");
  }
#line 112
  if (tmp___4) {
    {
#line 112
    tmp___5 = strcmp(a, "-and");
    }
#line 112
    if (! tmp___5) {
#line 113
      return (263);
    }
  } else {
#line 113
    return (263);
  }
  {
#line 114
  tmp___6 = strcmp(a, "-o");
  }
#line 114
  if (tmp___6) {
    {
#line 114
    tmp___7 = strcmp(a, "-or");
    }
#line 114
    if (! tmp___7) {
#line 115
      return (264);
    }
  } else {
#line 115
    return (264);
  }
  {
#line 117
  tmp___11 = strcmp(a, "-print");
  }
#line 117
  if (! tmp___11) {
    {
#line 117
    tmp___10 = hexec_action_parse_print(p, & hexec_parser_lval.expr);
    }
#line 117
    if (tmp___10) {
#line 117
      tmp___9 = 258;
    } else {
#line 117
      tmp___9 = 1;
    }
#line 117
    return (tmp___9);
  }
  {
#line 118
  tmp___15 = strcmp(a, "-path");
  }
#line 118
  if (! tmp___15) {
    {
#line 118
    tmp___14 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 3, (_Bool)0);
    }
#line 118
    if (tmp___14) {
#line 118
      tmp___13 = 258;
    } else {
#line 118
      tmp___13 = 1;
    }
#line 118
    return (tmp___13);
  }
  {
#line 119
  tmp___19 = strcmp(a, "-ipath");
  }
#line 119
  if (! tmp___19) {
    {
#line 119
    tmp___18 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 3, (_Bool)1);
    }
#line 119
    if (tmp___18) {
#line 119
      tmp___17 = 258;
    } else {
#line 119
      tmp___17 = 1;
    }
#line 119
    return (tmp___17);
  }
  {
#line 120
  tmp___23 = strcmp(a, "-name");
  }
#line 120
  if (! tmp___23) {
    {
#line 120
    tmp___22 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 4, (_Bool)0);
    }
#line 120
    if (tmp___22) {
#line 120
      tmp___21 = 258;
    } else {
#line 120
      tmp___21 = 1;
    }
#line 120
    return (tmp___21);
  }
  {
#line 121
  tmp___27 = strcmp(a, "-iname");
  }
#line 121
  if (! tmp___27) {
    {
#line 121
    tmp___26 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 4, (_Bool)1);
    }
#line 121
    if (tmp___26) {
#line 121
      tmp___25 = 258;
    } else {
#line 121
      tmp___25 = 1;
    }
#line 121
    return (tmp___25);
  }
  {
#line 122
  tmp___31 = strcmp(a, "-contains");
  }
#line 122
  if (! tmp___31) {
    {
#line 122
    tmp___30 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 5, (_Bool)0);
    }
#line 122
    if (tmp___30) {
#line 122
      tmp___29 = 258;
    } else {
#line 122
      tmp___29 = 1;
    }
#line 122
    return (tmp___29);
  }
  {
#line 123
  tmp___35 = strcmp(a, "-icontains");
  }
#line 123
  if (! tmp___35) {
    {
#line 123
    tmp___34 = hexec_action_parse_fname_match(p, & hexec_parser_lval.expr, 5, (_Bool)1);
    }
#line 123
    if (tmp___34) {
#line 123
      tmp___33 = 258;
    } else {
#line 123
      tmp___33 = 1;
    }
#line 123
    return (tmp___33);
  }
  {
#line 124
  tmp___39 = strcmp(a, "-exec");
  }
#line 124
  if (! tmp___39) {
    {
#line 124
    tmp___38 = hexec_action_parse_exec(p, & hexec_parser_lval.expr);
    }
#line 124
    if (tmp___38) {
#line 124
      tmp___37 = 258;
    } else {
#line 124
      tmp___37 = 1;
    }
#line 124
    return (tmp___37);
  }
  {
#line 125
  tmp___43 = strcmp(a, "-sh");
  }
#line 125
  if (! tmp___43) {
    {
#line 125
    tmp___42 = hexec_action_parse_sh(p, & hexec_parser_lval.expr);
    }
#line 125
    if (tmp___42) {
#line 125
      tmp___41 = 258;
    } else {
#line 125
      tmp___41 = 1;
    }
#line 125
    return (tmp___41);
  }
#line 127
  return (-1);
}
}
#line 130 "expr-grammar.y"
int hexec_parser_lex(struct hexec_parser *p ) 
{ 
  int backup ;
  int tok ;
  int tmp ;

  {
  {
#line 132
  backup = p->cur_arg;
#line 133
  tmp = hexec_parser_lex2(p);
#line 133
  tok = tmp;
  }
#line 134
  if (tok == -1) {
#line 135
    p->cur_arg = backup;
  }
#line 136
  return (tok);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
void hexec_parser_init(struct hexec_parser *p , struct hexec_buf *buf , struct args_t *args ,
                       int first_arg ) 
{ 
  int shm_header ;
  int tmp ;

  {
  {
#line 33
  p->buf = buf;
#line 34
  p->args = args;
#line 35
  p->cur_arg = first_arg;
#line 36
  p->result = -1;
#line 38
  tmp = hexec_buf_alloc(p->buf, (int )sizeof(struct hexec_expr_shm_header ));
#line 38
  shm_header = tmp;
  }
#line 39
  if (! (shm_header == 0)) {
    {
#line 39
    __assert_fail("shm_header == 0", "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c",
                  39U, "hexec_parser_init");
    }
  }
#line 41
  p->shm_header = (struct hexec_expr_shm_header *)buf->buf;
#line 42
  (p->shm_header)->root_expr = -1;
#line 43
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
static void alloc_expr(struct hexec_parser *p , int *ptr , struct hexec_expr **e ) 
{ 


  {
  {
#line 47
  *ptr = hexec_buf_alloc(p->buf, (int )sizeof(struct hexec_expr ));
#line 48
  *e = (struct hexec_expr *)((p->buf)->buf + *ptr);
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
int hexec_parser_build_not(struct hexec_parser *p , int expr ) 
{ 
  int ei ;
  struct hexec_expr *e ;

  {
  {
#line 55
  alloc_expr(p, & ei, & e);
#line 56
  e->type = 0;
#line 57
  e->expr1 = expr;
  }
#line 58
  return (ei);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
int hexec_parser_build_and(struct hexec_parser *p , int left , int right ) 
{ 
  int ei ;
  struct hexec_expr *e ;

  {
  {
#line 65
  alloc_expr(p, & ei, & e);
#line 66
  e->type = 1;
#line 67
  e->expr1 = left;
#line 68
  e->expr2 = right;
  }
#line 69
  return (ei);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
int hexec_parser_build_or(struct hexec_parser *p , int left , int right ) 
{ 
  int ei ;
  struct hexec_expr *e ;

  {
  {
#line 76
  alloc_expr(p, & ei, & e);
#line 77
  e->type = 2;
#line 78
  e->expr1 = left;
#line 79
  e->expr2 = right;
  }
#line 80
  return (ei);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
_Bool hexec_action_parse_print(struct hexec_parser *p , int *action ) 
{ 
  struct hexec_expr *e ;

  {
  {
#line 86
  alloc_expr(p, action, & e);
#line 87
  e->type = 6;
  }
#line 88
  return ((_Bool)1);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
_Bool hexec_action_parse_fname_match(struct hexec_parser *p , int *action , int type ,
                                     _Bool case_insensitive ) 
{ 
  char *str ;
  int tmp ;
  struct hexec_expr *e ;
  size_t tmp___0 ;
  char *str2 ;
  int i ;
  int tmp___1 ;

  {
#line 93
  if (p->cur_arg >= (p->args)->argc) {
    {
#line 95
    hexec_error("expression misses argument\n");
    }
#line 96
    return ((_Bool)0);
  }
  {
#line 98
  tmp = p->cur_arg;
#line 98
  (p->cur_arg) ++;
#line 98
  str = *((p->args)->argv + tmp);
#line 100
  alloc_expr(p, action, & e);
#line 101
  e->type = type;
#line 102
  e->case_insensitive = case_insensitive;
#line 103
  tmp___0 = strlen((char const   *)str);
#line 103
  e->str = hexec_buf_alloc(p->buf, (int )(tmp___0 + 1UL));
#line 105
  str2 = (p->buf)->buf + e->str;
#line 106
  strcpy((char */* __restrict  */)str2, (char const   */* __restrict  */)str);
  }
#line 108
  if (type == 5) {
#line 108
    if (case_insensitive) {
#line 112
      i = 0;
      {
#line 112
      while (1) {
        while_continue: /* CIL Label */ ;
#line 112
        if (! *(str2 + i)) {
#line 112
          goto while_break;
        }
        {
#line 113
        tmp___1 = tolower((int )*(str2 + i));
#line 113
        *(str2 + i) = (char )tmp___1;
#line 112
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 116
  return ((_Bool)1);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
_Bool hexec_action_parse_exec(struct hexec_parser *p , int *action ) 
{ 
  int argc ;
  _Bool found_term ;
  int i ;
  int tmp ;
  int argv ;
  int tmp___0 ;
  int *argv1 ;
  int i___0 ;
  size_t tmp___1 ;
  struct hexec_expr *e ;

  {
#line 121
  if (p->cur_arg >= (p->args)->argc) {
    {
#line 123
    hexec_error("-exec misses command\n");
    }
#line 124
    return ((_Bool)0);
  }
#line 127
  argc = 0;
#line 128
  found_term = (_Bool)0;
#line 129
  i = p->cur_arg;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < (p->args)->argc)) {
#line 129
      goto while_break;
    }
    {
#line 131
    tmp = strcmp(";", (char const   *)*((p->args)->argv + i));
    }
#line 131
    if (! tmp) {
#line 133
      found_term = (_Bool)1;
#line 134
      goto while_break;
    }
#line 136
    argc ++;
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (argc == 0) {
    {
#line 140
    hexec_error("-exec misses command\n");
    }
#line 141
    return ((_Bool)0);
  }
#line 143
  if (! found_term) {
    {
#line 145
    hexec_error("-exec must be terminated with ;\n");
    }
#line 146
    return ((_Bool)0);
  }
  {
#line 149
  tmp___0 = hexec_buf_alloc(p->buf, (int )(sizeof(int ) * (unsigned long )argc));
#line 149
  argv = tmp___0;
#line 150
  argv1 = (int *)((p->buf)->buf + argv);
#line 151
  i___0 = 0;
  }
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i___0 < argc)) {
#line 151
      goto while_break___0;
    }
    {
#line 153
    tmp___1 = strlen((char const   *)*((p->args)->argv + (i___0 + p->cur_arg)));
#line 153
    *(argv1 + i___0) = hexec_buf_alloc(p->buf, (int )(tmp___1 + 1UL));
#line 154
    strcpy((char */* __restrict  */)((p->buf)->buf + *(argv1 + i___0)), (char const   */* __restrict  */)*((p->args)->argv + (i___0 + p->cur_arg)));
#line 151
    i___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 157
  alloc_expr(p, action, & e);
#line 158
  e->type = 7;
#line 159
  e->argc = argc;
#line 160
  e->argv = argv;
#line 162
  p->cur_arg += argc + 1;
  }
#line 164
  return ((_Bool)1);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/hexec-0.2.1/hexec/parser.c"
_Bool hexec_action_parse_sh(struct hexec_parser *p , int *action ) 
{ 
  char const   *script ;
  struct hexec_expr *e ;
  int *argv1 ;

  {
#line 169
  if (p->cur_arg >= (p->args)->argc) {
    {
#line 171
    hexec_error("-sh misses arguments\n");
    }
#line 172
    return ((_Bool)0);
  }
  {
#line 177
  script = (char const   *)*((p->args)->argv + p->cur_arg);
#line 180
  alloc_expr(p, action, & e);
#line 181
  e->type = 7;
#line 182
  e->argc = 3;
#line 183
  e->argv = hexec_buf_alloc(p->buf, (int )(sizeof(int ) * (unsigned long )e->argc));
#line 185
  argv1 = (int *)((p->buf)->buf + e->argv);
#line 186
  *(argv1 + 0) = hexec_buf_strdup(p->buf, "/bin/sh");
#line 187
  *(argv1 + 1) = hexec_buf_strdup(p->buf, "-c");
#line 188
  *(argv1 + 2) = hexec_buf_strdup(p->buf, script);
#line 190
  (p->cur_arg) ++;
  }
#line 192
  return ((_Bool)1);
}
}
