/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
struct protocolstruct;
#line 72 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
typedef struct protocolstruct ProtocolStruct;
#line 73 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
struct protocolstruct {
   struct sockaddr_in sin1 ;
   struct sockaddr_in sin2 ;
   int nodelay ;
   struct hostent *addr ;
   int sndbufsz ;
   int rcvbufsz ;
};
#line 325
struct argstruct;
#line 325 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
typedef struct argstruct ArgStruct;
#line 326 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
struct argstruct {
   int cache ;
   char *host ;
   int servicefd ;
   int commfd ;
   short port ;
   char *r_buff ;
   char *r_buff_orig ;
   char *r_ptr ;
   char *r_ptr_saved ;
   char *s_buff ;
   char *s_buff_orig ;
   char *s_ptr ;
   int bufflen ;
   int upper ;
   int tr ;
   int rcv ;
   int bidir ;
   int nbuff ;
   int source_node ;
   int preburst ;
   int reset_conn ;
   int soffset ;
   int roffset ;
   int syncflag ;
   int use_sdp ;
   ProtocolStruct prot ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 362 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
struct data;
#line 362 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
typedef struct data Data;
#line 363 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
struct data {
   double t ;
   double bps ;
   double variance ;
   int bits ;
   int repeat ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2), __leaf__)) bcopy)(void const   *__src ,
                                                                                               void *__dest ,
                                                                                               size_t __n ) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 374 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
void Init(ArgStruct *p , int *pargc , char ***pargv ) ;
#line 376
void Setup(ArgStruct *p ) ;
#line 378
void establish(ArgStruct *p ) ;
#line 380
void Sync(ArgStruct *p ) ;
#line 382
void PrepareToReceive(ArgStruct *p ) ;
#line 384
void SendData(ArgStruct *p ) ;
#line 386
void RecvData(ArgStruct *p ) ;
#line 388
void SendTime(ArgStruct *p , double *t ) ;
#line 390
void RecvTime(ArgStruct *p , double *t ) ;
#line 392
void SendRepeat(ArgStruct *p , int rpt ) ;
#line 394
void RecvRepeat(ArgStruct *p , int *rpt ) ;
#line 398
void CleanUp(ArgStruct *p ) ;
#line 404
void Reset(ArgStruct *p ) ;
#line 424
void AfterAlignmentInit(ArgStruct *p ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
int doing_reset  =    0;
#line 23 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void Init(ArgStruct *p , int *pargc , char ***pargv ) 
{ 
  int tmp ;

  {
#line 25
  p->reset_conn = 0;
#line 26
  tmp = 0;
#line 26
  p->prot.rcvbufsz = tmp;
#line 26
  p->prot.sndbufsz = tmp;
#line 27
  p->tr = 0;
#line 28
  p->rcv = 1;
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void Setup(ArgStruct *p ) 
{ 
  int one ;
  int sockfd ;
  struct sockaddr_in *lsin1 ;
  struct sockaddr_in *lsin2 ;
  char *host ;
  struct hostent *addr ;
  struct protoent *proto ;
  int send_size ;
  int recv_size ;
  int sizeofint ;
  int socket_family ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
#line 34
  one = 1;
#line 40
  sizeofint = (int )sizeof(int );
#line 41
  socket_family = 2;
#line 44
  host = p->host;
#line 46
  if (p->use_sdp) {
    {
#line 47
    printf((char const   */* __restrict  */)"Using AF_INET_SDP (27) socket family\n");
#line 48
    socket_family = 27;
    }
  }
  {
#line 51
  lsin1 = & p->prot.sin1;
#line 52
  lsin2 = & p->prot.sin2;
#line 54
  bzero((void *)((char *)lsin1), sizeof(*lsin1));
#line 55
  bzero((void *)((char *)lsin2), sizeof(*lsin2));
#line 57
  sockfd = socket(socket_family, 1, 0);
  }
#line 57
  if (sockfd < 0) {
    {
#line 58
    tmp = __errno_location();
#line 58
    printf((char const   */* __restrict  */)"NetPIPE: can\'t open stream socket! errno=%d\n",
           *tmp);
#line 59
    exit(-4);
    }
  }
  {
#line 62
  proto = getprotobyname("tcp");
  }
#line 62
  if (! proto) {
    {
#line 63
    printf((char const   */* __restrict  */)"NetPIPE: protocol \'tcp\' unknown!\n");
#line 64
    exit(555);
    }
  }
  {
#line 69
  tmp___1 = setsockopt(sockfd, proto->p_proto, 1, (void const   *)(& one), (socklen_t )sizeof(one));
  }
#line 69
  if (tmp___1 < 0) {
    {
#line 71
    tmp___0 = __errno_location();
#line 71
    printf((char const   */* __restrict  */)"NetPIPE: setsockopt: TCP_NODELAY failed! errno=%d\n",
           *tmp___0);
#line 72
    exit(556);
    }
  }
#line 77
  if (p->prot.sndbufsz > 0) {
    {
#line 79
    tmp___3 = setsockopt(sockfd, 1, 7, (void const   *)(& p->prot.sndbufsz), (socklen_t )sizeof(p->prot.sndbufsz));
    }
#line 79
    if (tmp___3 < 0) {
      {
#line 82
      tmp___2 = __errno_location();
#line 82
      printf((char const   */* __restrict  */)"NetPIPE: setsockopt: SO_SNDBUF failed! errno=%d\n",
             *tmp___2);
#line 83
      printf((char const   */* __restrict  */)"You may have asked for a buffer larger than the system can handle\n");
#line 84
      exit(556);
      }
    }
    {
#line 86
    tmp___5 = setsockopt(sockfd, 1, 8, (void const   *)(& p->prot.rcvbufsz), (socklen_t )sizeof(p->prot.rcvbufsz));
    }
#line 86
    if (tmp___5 < 0) {
      {
#line 89
      tmp___4 = __errno_location();
#line 89
      printf((char const   */* __restrict  */)"NetPIPE: setsockopt: SO_RCVBUF failed! errno=%d\n",
             *tmp___4);
#line 90
      printf((char const   */* __restrict  */)"You may have asked for a buffer larger than the system can handle\n");
#line 91
      exit(556);
      }
    }
  }
  {
#line 94
  getsockopt(sockfd, 1, 7, (void */* __restrict  */)((char *)(& send_size)), (socklen_t */* __restrict  */)((void *)(& sizeofint)));
#line 96
  getsockopt(sockfd, 1, 8, (void */* __restrict  */)((char *)(& recv_size)), (socklen_t */* __restrict  */)((void *)(& sizeofint)));
  }
#line 99
  if (! doing_reset) {
    {
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Send and receive buffers are %d and %d bytes\n",
            send_size, recv_size);
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(A bug in Linux doubles the requested buffer sizes)\n");
    }
  }
#line 105
  if (p->tr) {
    {
#line 107
    tmp___6 = atoi((char const   *)host);
    }
#line 107
    if (tmp___6 > 0) {
      {
#line 108
      lsin1->sin_family = (sa_family_t )2;
#line 109
      lsin1->sin_addr.s_addr = inet_addr((char const   *)host);
      }
    } else {
      {
#line 113
      addr = gethostbyname((char const   *)host);
      }
#line 113
      if ((unsigned long )addr == (unsigned long )((void *)0)) {
        {
#line 114
        printf((char const   */* __restrict  */)"NetPIPE: invalid hostname \'%s\'\n",
               host);
#line 115
        exit(-5);
        }
      }
      {
#line 118
      lsin1->sin_family = (sa_family_t )addr->h_addrtype;
#line 119
      bcopy((void const   *)*(addr->h_addr_list + 0), (void *)((char *)(& lsin1->sin_addr.s_addr)),
            (size_t )addr->h_length);
      }
    }
    {
#line 122
    lsin1->sin_port = htons((uint16_t )p->port);
#line 124
    p->commfd = sockfd;
    }
  } else
#line 126
  if (p->rcv) {
    {
#line 128
    tmp___8 = setsockopt(sockfd, 1, 2, (void const   *)(& one), (socklen_t )sizeof(int ));
    }
#line 128
    if (tmp___8) {
      {
#line 129
      tmp___7 = __errno_location();
#line 129
      printf((char const   */* __restrict  */)"NetPIPE: server: unable to setsockopt -- errno %d\n",
             *tmp___7);
#line 130
      exit(557);
      }
    }
    {
#line 133
    bzero((void *)((char *)lsin1), sizeof(*lsin1));
#line 134
    lsin1->sin_family = (sa_family_t )2;
#line 135
    lsin1->sin_addr.s_addr = htonl((in_addr_t )0);
#line 136
    lsin1->sin_port = htons((uint16_t )p->port);
#line 138
    tmp___10 = bind(sockfd, (struct sockaddr  const  *)((struct sockaddr *)lsin1),
                    (socklen_t )sizeof(*lsin1));
    }
#line 138
    if (tmp___10 < 0) {
      {
#line 139
      tmp___9 = __errno_location();
#line 139
      printf((char const   */* __restrict  */)"NetPIPE: server: bind on local address failed! errno=%d\n",
             *tmp___9);
#line 140
      exit(-6);
      }
    }
#line 143
    p->servicefd = sockfd;
  }
  {
#line 145
  p->upper = send_size + recv_size;
#line 147
  establish(p);
  }
#line 149
  return;
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
static int readFully(int fd , void *obuf , int len ) 
{ 
  int bytesLeft ;
  char *buf ;
  int bytesRead ;
  ssize_t tmp ;

  {
#line 154
  bytesLeft = len;
#line 155
  buf = (char *)obuf;
#line 156
  bytesRead = 0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (bytesLeft > 0) {
      {
#line 158
      tmp = read(fd, (void *)buf, (size_t )bytesLeft);
#line 158
      bytesRead = (int )tmp;
      }
#line 158
      if (! (bytesRead > 0)) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
#line 161
    bytesLeft -= bytesRead;
#line 162
    buf += bytesRead;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (bytesRead <= 0) {
#line 164
    return (bytesRead);
  }
#line 165
  return (len);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void Sync(ArgStruct *p ) 
{ 
  char s[7] ;
  char response[7] ;
  size_t tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 170
  s[0] = (char )'S';
#line 170
  s[1] = (char )'y';
#line 170
  s[2] = (char )'n';
#line 170
  s[3] = (char )'c';
#line 170
  s[4] = (char )'M';
#line 170
  s[5] = (char )'e';
#line 170
  s[6] = (char )'\000';
#line 170
  response[0] = (char )' ';
#line 170
  response[1] = (char )' ';
#line 170
  response[2] = (char )' ';
#line 170
  response[3] = (char )' ';
#line 170
  response[4] = (char )' ';
#line 170
  response[5] = (char )' ';
#line 170
  response[6] = (char )'\000';
#line 172
  tmp = strlen((char const   *)(s));
#line 172
  tmp___0 = write(p->commfd, (void const   *)(s), tmp);
  }
#line 172
  if (tmp___0 < 0L) {
    {
#line 175
    perror("NetPIPE: error writing or reading synchronization string");
#line 176
    exit(3);
    }
  } else {
    {
#line 172
    tmp___1 = strlen((char const   *)(s));
#line 172
    tmp___2 = readFully(p->commfd, (void *)(response), (int )tmp___1);
    }
#line 172
    if (tmp___2 < 0) {
      {
#line 175
      perror("NetPIPE: error writing or reading synchronization string");
#line 176
      exit(3);
      }
    }
  }
  {
#line 178
  tmp___3 = strlen((char const   *)(s));
#line 178
  tmp___4 = strncmp((char const   *)(s), (char const   *)(response), tmp___3);
  }
#line 178
  if (tmp___4) {
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NetPIPE: Synchronization string incorrect! |%s|\n",
            response);
#line 181
    exit(3);
    }
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void PrepareToReceive(ArgStruct *p ) 
{ 


  {
#line 191
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void SendData(ArgStruct *p ) 
{ 
  int bytesWritten ;
  int bytesLeft ;
  char *q ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 198
  bytesLeft = p->bufflen;
#line 199
  bytesWritten = 0;
#line 200
  q = p->s_ptr;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (bytesLeft > 0) {
      {
#line 201
      tmp = write(p->commfd, (void const   *)q, (size_t )bytesLeft);
#line 201
      bytesWritten = (int )tmp;
      }
#line 201
      if (! (bytesWritten > 0)) {
#line 201
        goto while_break;
      }
    } else {
#line 201
      goto while_break;
    }
#line 204
    bytesLeft -= bytesWritten;
#line 205
    q += bytesWritten;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  if (bytesWritten == -1) {
    {
#line 209
    tmp___0 = __errno_location();
#line 209
    printf((char const   */* __restrict  */)"NetPIPE: write: error encountered, errno=%d\n",
           *tmp___0);
#line 210
    exit(401);
    }
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void RecvData(ArgStruct *p ) 
{ 
  int bytesLeft ;
  int bytesRead ;
  char *q ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 220
  bytesLeft = p->bufflen;
#line 221
  bytesRead = 0;
#line 222
  q = p->r_ptr;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (bytesLeft > 0) {
      {
#line 223
      tmp = read(p->commfd, (void *)q, (size_t )bytesLeft);
#line 223
      bytesRead = (int )tmp;
      }
#line 223
      if (! (bytesRead > 0)) {
#line 223
        goto while_break;
      }
    } else {
#line 223
      goto while_break;
    }
#line 226
    bytesLeft -= bytesRead;
#line 227
    q += bytesRead;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  if (bytesLeft > 0) {
#line 229
    if (bytesRead == 0) {
      {
#line 231
      printf((char const   */* __restrict  */)"NetPIPE: \"end of file\" encountered on reading from socket\n");
      }
    } else {
#line 229
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 233
  if (bytesRead == -1) {
    {
#line 235
    tmp___0 = __errno_location();
#line 235
    printf((char const   */* __restrict  */)"NetPIPE: read: error encountered, errno=%d\n",
           *tmp___0);
#line 236
    exit(401);
    }
  }
#line 238
  return;
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void SendTime(ArgStruct *p , double *t ) 
{ 
  uint32_t ltime ;
  uint32_t ntime ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 251
  ltime = (uint32_t )(*t * 1.e8);
#line 254
  ntime = htonl(ltime);
#line 255
  tmp___0 = write(p->commfd, (void const   *)((char *)(& ntime)), sizeof(uint32_t ));
  }
#line 255
  if (tmp___0 < 0L) {
    {
#line 257
    tmp = __errno_location();
#line 257
    printf((char const   */* __restrict  */)"NetPIPE: write failed in SendTime: errno=%d\n",
           *tmp);
#line 258
    exit(301);
    }
  }
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void RecvTime(ArgStruct *p , double *t ) 
{ 
  uint32_t ltime ;
  uint32_t ntime ;
  int bytesRead ;
  int *tmp ;

  {
  {
#line 267
  bytesRead = readFully(p->commfd, (void *)(& ntime), (int )sizeof(uint32_t ));
  }
#line 268
  if (bytesRead < 0) {
    {
#line 270
    tmp = __errno_location();
#line 270
    printf((char const   */* __restrict  */)"NetPIPE: read failed in RecvTime: errno=%d\n",
           *tmp);
#line 271
    exit(302);
    }
  } else
#line 273
  if ((unsigned long )bytesRead != sizeof(uint32_t )) {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NetPIPE: partial read in RecvTime of %d bytes\n",
            bytesRead);
#line 277
    exit(303);
    }
  }
  {
#line 279
  ltime = ntohl(ntime);
#line 283
  *t = (double )ltime / 1.0e8;
  }
#line 284
  return;
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void SendRepeat(ArgStruct *p , int rpt ) 
{ 
  uint32_t lrpt ;
  uint32_t nrpt ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 290
  lrpt = (uint32_t )rpt;
#line 292
  nrpt = htonl(lrpt);
#line 293
  tmp___0 = write(p->commfd, (void const   *)((void *)(& nrpt)), sizeof(uint32_t ));
  }
#line 293
  if (tmp___0 < 0L) {
    {
#line 295
    tmp = __errno_location();
#line 295
    printf((char const   */* __restrict  */)"NetPIPE: write failed in SendRepeat: errno=%d\n",
           *tmp);
#line 296
    exit(304);
    }
  }
#line 298
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void RecvRepeat(ArgStruct *p , int *rpt ) 
{ 
  uint32_t lrpt ;
  uint32_t nrpt ;
  int bytesRead ;
  int *tmp ;

  {
  {
#line 305
  bytesRead = readFully(p->commfd, (void *)(& nrpt), (int )sizeof(uint32_t ));
  }
#line 306
  if (bytesRead < 0) {
    {
#line 308
    tmp = __errno_location();
#line 308
    printf((char const   */* __restrict  */)"NetPIPE: read failed in RecvRepeat: errno=%d\n",
           *tmp);
#line 309
    exit(305);
    }
  } else
#line 311
  if ((unsigned long )bytesRead != sizeof(uint32_t )) {
    {
#line 313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NetPIPE: partial read in RecvRepeat of %d bytes\n",
            bytesRead);
#line 315
    exit(306);
    }
  }
  {
#line 317
  lrpt = ntohl(nrpt);
#line 319
  *rpt = (int )lrpt;
  }
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void establish(ArgStruct *p ) 
{ 
  int one ;
  socklen_t clen ;
  struct protoent *proto ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 324
  one = 1;
#line 328
  clen = (socklen_t )sizeof(p->prot.sin2);
#line 330
  if (p->tr) {
    {
#line 332
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 332
      tmp___1 = connect(p->commfd, (struct sockaddr  const  *)((struct sockaddr *)(& p->prot.sin1)),
                        (socklen_t )sizeof(p->prot.sin1));
      }
#line 332
      if (! (tmp___1 < 0)) {
#line 332
        goto while_break;
      }
#line 340
      if (! doing_reset) {
        {
#line 341
        tmp = __errno_location();
#line 341
        printf((char const   */* __restrict  */)"Client: Cannot Connect! errno=%d\n",
               *tmp);
#line 342
        exit(-10);
        }
      } else {
        {
#line 340
        tmp___0 = __errno_location();
        }
#line 340
        if (*tmp___0 != 111) {
          {
#line 341
          tmp = __errno_location();
#line 341
          printf((char const   */* __restrict  */)"Client: Cannot Connect! errno=%d\n",
                 *tmp);
#line 342
          exit(-10);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 347
  if (p->rcv) {
    {
#line 350
    listen(p->servicefd, 5);
#line 351
    p->commfd = accept(p->servicefd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& p->prot.sin2)),
                       (socklen_t */* __restrict  */)(& clen));
    }
#line 353
    if (p->commfd < 0) {
      {
#line 354
      tmp___2 = __errno_location();
#line 354
      printf((char const   */* __restrict  */)"Server: Accept Failed! errno=%d\n",
             *tmp___2);
#line 355
      exit(-12);
      }
    }
    {
#line 362
    proto = getprotobyname("tcp");
    }
#line 362
    if (! proto) {
      {
#line 363
      printf((char const   */* __restrict  */)"unknown protocol!\n");
#line 364
      exit(555);
      }
    }
    {
#line 367
    tmp___4 = setsockopt(p->commfd, proto->p_proto, 1, (void const   *)(& one), (socklen_t )sizeof(one));
    }
#line 367
    if (tmp___4 < 0) {
      {
#line 370
      tmp___3 = __errno_location();
#line 370
      printf((char const   */* __restrict  */)"setsockopt: TCP_NODELAY failed! errno=%d\n",
             *tmp___3);
#line 371
      exit(556);
      }
    }
#line 375
    if (p->prot.sndbufsz > 0) {
      {
#line 379
      tmp___6 = setsockopt(p->commfd, 1, 7, (void const   *)(& p->prot.sndbufsz),
                           (socklen_t )sizeof(p->prot.sndbufsz));
      }
#line 379
      if (tmp___6 < 0) {
        {
#line 382
        tmp___5 = __errno_location();
#line 382
        printf((char const   */* __restrict  */)"setsockopt: SO_SNDBUF failed! errno=%d\n",
               *tmp___5);
#line 383
        exit(556);
        }
      }
      {
#line 385
      tmp___8 = setsockopt(p->commfd, 1, 8, (void const   *)(& p->prot.rcvbufsz),
                           (socklen_t )sizeof(p->prot.rcvbufsz));
      }
#line 385
      if (tmp___8 < 0) {
        {
#line 388
        tmp___7 = __errno_location();
#line 388
        printf((char const   */* __restrict  */)"setsockopt: SO_RCVBUF failed! errno=%d\n",
               *tmp___7);
#line 389
        exit(556);
        }
      }
    }
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void CleanUp(ArgStruct *p ) 
{ 
  char quit[5] ;

  {
#line 397
  quit[0] = (char )'Q';
#line 397
  quit[1] = (char )'U';
#line 397
  quit[2] = (char )'I';
#line 397
  quit[3] = (char )'T';
#line 397
  quit[4] = (char )'\000';
#line 399
  if (p->tr) {
    {
#line 401
    write(p->commfd, (void const   *)(quit), (size_t )5);
#line 402
    read(p->commfd, (void *)(quit), (size_t )5);
#line 403
    close(p->commfd);
    }
  } else
#line 405
  if (p->rcv) {
    {
#line 407
    read(p->commfd, (void *)(quit), (size_t )5);
#line 408
    write(p->commfd, (void const   *)(quit), (size_t )5);
#line 409
    close(p->commfd);
#line 410
    close(p->servicefd);
    }
  }
#line 413
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void Reset(ArgStruct *p ) 
{ 


  {
#line 421
  if (p->reset_conn) {
    {
#line 423
    doing_reset = 1;
#line 427
    CleanUp(p);
#line 431
    Setup(p);
    }
  }
#line 435
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/tcp.c"
void AfterAlignmentInit(ArgStruct *p ) 
{ 


  {
#line 440
  return;
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int argc ,
                                                                             char * const  *argv ,
                                                                             char const   *optstring ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 372 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.h"
double When(void) ;
#line 396
void FreeBuff(char *buff1 , char *buff2 ) ;
#line 400
void InitBufferData(ArgStruct *p , int nbytes , int soffset , int roffset ) ;
#line 402
void MyMalloc(ArgStruct *p , int bufflen , int soffset , int roffset ) ;
#line 406
void mymemset(int *ptr , int c , int n ) ;
#line 408
void flushcache(int *ptr , int n ) ;
#line 410
void SetIntegrityData(ArgStruct *p ) ;
#line 412
void VerifyIntegrity(ArgStruct *p ) ;
#line 414
void *AlignBuffer(void *buff , int boundary ) ;
#line 416
void AdvanceSendPtr(ArgStruct *p , int blocksize ) ;
#line 418
void AdvanceRecvPtr(ArgStruct *p , int blocksize ) ;
#line 420
void SaveRecvPtr(ArgStruct *p ) ;
#line 422
void ResetRecvPtr(ArgStruct *p ) ;
#line 428
void PrintUsage(void) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
int main(int argc , char **argv ) 
{ 
  FILE *out ;
  char s[255] ;
  char s2[255] ;
  char delim[255] ;
  char *pstr ;
  int *memcache ;
  int len_buf_align ;
  int c ;
  int i ;
  int j ;
  int n ;
  int nq ;
  int asyncReceive ;
  int bufalign ;
  int errFlag ;
  int nrepeat ;
  int nrepeat_const ;
  int len ;
  int inc ;
  int perturbation ;
  int pert ;
  int start ;
  int end ;
  int streamopt ;
  int debug_wait ;
  ArgStruct args ;
  double t ;
  double t0 ;
  double tlast ;
  Data bwdata[8000] ;
  int integCheck ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  double tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 46
  asyncReceive = 0;
#line 46
  bufalign = 16384;
#line 46
  nrepeat_const = 0;
#line 46
  inc = 0;
#line 46
  perturbation = 3;
#line 46
  start = 1;
#line 46
  end = 10000000;
#line 46
  streamopt = 0;
#line 46
  debug_wait = 0;
#line 71
  integCheck = 0;
#line 75
  strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)"np.out");
#line 81
  Init(& args, & argc, & argv);
#line 83
  args.preburst = 0;
#line 84
  args.bidir = 0;
#line 85
  args.cache = 1;
#line 86
  args.upper = end;
#line 87
  args.host = (char *)((void *)0);
#line 88
  args.soffset = 0;
#line 89
  args.roffset = 0;
#line 90
  args.syncflag = 0;
#line 91
  args.use_sdp = 0;
#line 92
  args.port = (short)5002;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    c = getopt(argc, (char * const  *)argv, "AXSO:rIiszgfaB2h:p:o:l:u:b:m:n:t:c:d:D:P:");
    }
#line 103
    if (! (c != -1)) {
#line 103
      goto while_break;
    }
    {
#line 107
    if (c == 65) {
#line 107
      goto case_65;
    }
#line 110
    if (c == 79) {
#line 110
      goto case_79;
    }
#line 124
    if (c == 112) {
#line 124
      goto case_112;
    }
#line 133
    if (c == 66) {
#line 133
      goto case_66;
    }
#line 144
    if (c == 73) {
#line 144
      goto case_73;
    }
#line 148
    if (c == 111) {
#line 148
      goto case_111;
    }
#line 152
    if (c == 115) {
#line 152
      goto case_115;
    }
#line 169
    if (c == 108) {
#line 169
      goto case_108;
    }
#line 177
    if (c == 117) {
#line 177
      goto case_117;
    }
#line 181
    if (c == 98) {
#line 181
      goto case_98;
    }
#line 186
    if (c == 50) {
#line 186
      goto case_50;
    }
#line 199
    if (c == 104) {
#line 199
      goto case_104;
    }
#line 222
    if (c == 105) {
#line 222
      goto case_105;
    }
#line 411
    if (c == 80) {
#line 411
      goto case_80;
    }
#line 415
    if (c == 110) {
#line 415
      goto case_110;
    }
#line 419
    if (c == 114) {
#line 419
      goto case_114;
    }
#line 423
    if (c == 88) {
#line 423
      goto case_88;
    }
#line 428
    goto switch_default;
    case_65: /* CIL Label */ 
#line 108
    args.use_sdp = 1;
#line 109
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 111
    strcpy((char */* __restrict  */)(s2), (char const   */* __restrict  */)optarg);
#line 112
    strcpy((char */* __restrict  */)(delim), (char const   */* __restrict  */)",");
#line 113
    pstr = strtok((char */* __restrict  */)(s2), (char const   */* __restrict  */)(delim));
    }
#line 113
    if ((unsigned long )pstr != (unsigned long )((void *)0)) {
      {
#line 114
      args.soffset = atoi((char const   *)pstr);
#line 115
      pstr = strtok((char */* __restrict  */)((char *)((void *)0)), (char const   */* __restrict  */)(delim));
      }
#line 115
      if ((unsigned long )pstr != (unsigned long )((void *)0)) {
        {
#line 116
        args.roffset = atoi((char const   *)pstr);
        }
      } else {
#line 118
        args.roffset = args.soffset;
      }
    } else {
#line 120
      args.soffset = 0;
#line 120
      args.roffset = 0;
    }
    {
#line 122
    printf((char const   */* __restrict  */)"Transmit buffer offset: %d\nReceive buffer offset: %d\n",
           args.soffset, args.roffset);
    }
#line 123
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 124
    perturbation = atoi((char const   *)optarg);
    }
#line 125
    if (perturbation > 0) {
      {
#line 126
      printf((char const   */* __restrict  */)"Using a perturbation value of %d\n\n",
             perturbation);
      }
    } else {
      {
#line 128
      perturbation = 0;
#line 129
      printf((char const   */* __restrict  */)"Using no perturbations\n\n");
      }
    }
#line 131
    goto switch_break;
    case_66: /* CIL Label */ 
#line 133
    if (integCheck == 1) {
      {
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Integrity check not supported with prepost burst\n");
#line 135
      exit(-1);
      }
    }
    {
#line 137
    args.preburst = 1;
#line 138
    asyncReceive = 1;
#line 139
    printf((char const   */* __restrict  */)"Preposting all receives before a timed run.\n");
#line 140
    printf((char const   */* __restrict  */)"Some would consider this cheating,\n");
#line 141
    printf((char const   */* __restrict  */)"but it is needed to match some vendor tests.\n");
#line 141
    fflush(stdout);
    }
#line 142
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 144
    args.cache = 0;
#line 145
    printf((char const   */* __restrict  */)"Performance measured without cache effects\n\n");
#line 145
    fflush(stdout);
    }
#line 146
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 148
    memset((void *)(s), 0, sizeof(s));
#line 148
    strncpy((char */* __restrict  */)(s), (char const   */* __restrict  */)optarg,
            sizeof(s) - 1UL);
#line 149
    printf((char const   */* __restrict  */)"Sending output to %s\n", s);
#line 149
    fflush(stdout);
    }
#line 150
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 152
    streamopt = 1;
#line 153
    printf((char const   */* __restrict  */)"Streaming in one direction only.\n\n");
#line 155
    printf((char const   */* __restrict  */)"Sockets are reset between trials to avoid\n");
#line 156
    printf((char const   */* __restrict  */)"degradation from a collapsing window size.\n\n");
#line 158
    args.reset_conn = 1;
#line 159
    printf((char const   */* __restrict  */)"Streaming does not provide an accurate\n");
#line 160
    printf((char const   */* __restrict  */)"measurement of the latency since small\n");
#line 161
    printf((char const   */* __restrict  */)"messages may get bundled together.\n\n");
    }
#line 162
    if (args.bidir == 1) {
      {
#line 163
      printf((char const   */* __restrict  */)"You can\'t use -s and -2 together\n");
#line 164
      exit(0);
      }
    }
    {
#line 166
    fflush(stdout);
    }
#line 167
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 169
    start = atoi((char const   *)optarg);
    }
#line 170
    if (start < 1) {
      {
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Need a starting value >= 1\n");
#line 173
      exit(0);
      }
    }
#line 175
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 177
    end = atoi((char const   *)optarg);
    }
#line 178
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 182
    args.prot.rcvbufsz = atoi((char const   *)optarg);
#line 182
    args.prot.sndbufsz = args.prot.rcvbufsz;
    }
#line 183
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 186
    args.bidir = 1;
#line 188
    printf((char const   */* __restrict  */)"Passing data in both directions simultaneously.\n");
#line 189
    printf((char const   */* __restrict  */)"Output is for the combined bandwidth.\n");
#line 191
    printf((char const   */* __restrict  */)"The socket buffer size limits the maximum test size.\n\n");
    }
#line 193
    if (streamopt) {
      {
#line 194
      printf((char const   */* __restrict  */)"You can\'t use -s and -2 together\n");
#line 195
      exit(0);
      }
    }
#line 197
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 199
    args.tr = 1;
#line 200
    args.rcv = 0;
#line 201
    tmp = strlen((char const   *)optarg);
#line 201
    tmp___0 = malloc(tmp + 1UL);
#line 201
    args.host = (char *)tmp___0;
#line 202
    strcpy((char */* __restrict  */)args.host, (char const   */* __restrict  */)optarg);
    }
#line 203
    goto switch_break;
    case_105: /* CIL Label */ 
#line 222
    if (args.preburst == 1) {
      {
#line 223
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Integrity check not supported with prepost burst\n");
#line 224
      exit(-1);
      }
    }
    {
#line 226
    integCheck = 1;
#line 227
    perturbation = 0;
#line 228
    start = (int )(sizeof(int ) + 1UL);
#line 229
    printf((char const   */* __restrict  */)"Doing an integrity check instead of measuring performance\n");
#line 229
    fflush(stdout);
    }
#line 230
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 412
    tmp___1 = atoi((char const   *)optarg);
#line 412
    args.port = (short )tmp___1;
    }
#line 413
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 415
    nrepeat_const = atoi((char const   *)optarg);
    }
#line 416
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 419
    args.reset_conn = 1;
#line 420
    printf((char const   */* __restrict  */)"Resetting connection after every trial\n");
    }
#line 421
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 423
    debug_wait = 1;
#line 424
    printf((char const   */* __restrict  */)"Enableing debug wait!\n");
#line 425
    tmp___2 = getpid();
#line 425
    printf((char const   */* __restrict  */)"Attach to pid %d and set debug_wait to 0 to conttinue\n",
           tmp___2);
    }
#line 426
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 429
    PrintUsage();
#line 430
    exit(-12);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (! debug_wait) {
#line 434
      goto while_break___0;
    }
#line 435
    i = 0;
    {
#line 435
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 435
      if (! (i < 10000)) {
#line 435
        goto while_break___1;
      }
#line 435
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 489
  if (start > end) {
    {
#line 491
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start MUST be LESS than end\n");
#line 492
    exit(420132);
    }
  }
  {
#line 494
  args.nbuff = 3;
#line 496
  Setup(& args);
  }
#line 498
  if (args.bidir) {
#line 498
    if (end > args.upper) {
#line 499
      end = args.upper;
#line 500
      if (args.tr) {
        {
#line 501
        printf((char const   */* __restrict  */)"The upper limit is being set to %d Bytes\n",
               end);
#line 503
        printf((char const   */* __restrict  */)"due to socket buffer size limitations\n\n");
        }
      }
    }
  }
#line 521
  if (args.tr) {
    {
#line 523
    out = fopen((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"w");
    }
#line 523
    if ((unsigned long )out == (unsigned long )((void *)0)) {
      {
#line 525
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for output\n",
              s);
#line 526
      exit(1);
      }
    }
  } else {
#line 529
    out = stdout;
  }
#line 533
  if (start > 1) {
#line 533
    inc = start / 2;
  } else {
#line 533
    inc = 1;
  }
#line 534
  if (start > 1) {
#line 534
    nq = 1;
  } else {
#line 534
    nq = 0;
  }
  {
#line 538
  args.bufflen = start;
#line 539
  MyMalloc(& args, args.bufflen, 0, 0);
#line 540
  InitBufferData(& args, args.bufflen, 0, 0);
  }
#line 542
  if (args.cache) {
#line 542
    args.s_buff = args.r_buff;
  }
  {
#line 544
  args.r_buff_orig = args.r_buff;
#line 544
  args.r_ptr = args.r_buff_orig;
#line 545
  args.s_buff_orig = args.s_buff;
#line 545
  args.s_ptr = args.s_buff_orig;
#line 547
  AfterAlignmentInit(& args);
  }
#line 552
  if (asyncReceive) {
    {
#line 553
    PrepareToReceive(& args);
    }
  }
  {
#line 555
  Sync(& args);
#line 563
  t0 = When();
#line 564
  n = 0;
  }
  {
#line 564
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 564
    if (! (n < 100)) {
#line 564
      goto while_break___2;
    }
#line 565
    if (args.tr) {
      {
#line 566
      SendData(& args);
#line 567
      RecvData(& args);
      }
#line 568
      if (asyncReceive) {
#line 568
        if (n < 99) {
          {
#line 569
          PrepareToReceive(& args);
          }
        }
      }
    } else
#line 570
    if (args.rcv) {
      {
#line 571
      RecvData(& args);
      }
#line 572
      if (asyncReceive) {
#line 572
        if (n < 99) {
          {
#line 573
          PrepareToReceive(& args);
          }
        }
      }
      {
#line 574
      SendData(& args);
      }
    }
#line 564
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 577
  tmp___3 = When();
#line 577
  tlast = (tmp___3 - t0) / (double )200;
#line 581
  Sync(& args);
#line 583
  Reset(& args);
  }
#line 586
  if (args.cache) {
    {
#line 587
    FreeBuff(args.r_buff_orig, (char *)((void *)0));
    }
  } else {
    {
#line 589
    FreeBuff(args.r_buff_orig, args.s_buff_orig);
    }
  }
#line 593
  if (! args.cache) {
    {
#line 598
    tmp___4 = malloc((size_t )10000000);
#line 598
    memcache = (int *)tmp___4;
    }
#line 598
    if ((unsigned long )memcache == (unsigned long )((void *)0)) {
      {
#line 600
      perror("malloc");
#line 601
      exit(1);
      }
    }
    {
#line 603
    mymemset(memcache, 0, (int )(10000000UL / sizeof(int )));
#line 607
    MyMalloc(& args, 10000000 + bufalign, args.soffset, args.roffset);
#line 611
    args.s_buff_orig = args.s_buff;
#line 612
    args.r_buff_orig = args.r_buff;
#line 616
    tmp___5 = AlignBuffer((void *)args.s_buff, bufalign);
#line 616
    args.s_buff = (char *)tmp___5;
#line 617
    tmp___6 = AlignBuffer((void *)args.r_buff, bufalign);
#line 617
    args.r_buff = (char *)tmp___6;
#line 621
    AfterAlignmentInit(& args);
#line 626
    args.s_ptr = args.s_buff + args.soffset;
#line 627
    args.r_ptr = args.r_buff + args.roffset;
    }
  }
#line 634
  if (args.tr) {
    {
#line 634
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now starting the main loop\n");
    }
  }
#line 636
  n = 0;
#line 636
  len = start;
#line 636
  errFlag = 0;
  {
#line 636
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 636
    if (n < 7997) {
#line 636
      if (tlast < 1.0) {
#line 636
        if (len <= end) {
#line 636
          if (! (! errFlag)) {
#line 636
            goto while_break___3;
          }
        } else {
#line 636
          goto while_break___3;
        }
      } else {
#line 636
        goto while_break___3;
      }
    } else {
#line 636
      goto while_break___3;
    }
#line 643
    if (nq > 2) {
#line 643
      if (nq % 2) {
#line 643
        inc += inc;
      } else {
#line 643
        inc = inc;
      }
    }
#line 647
    if (perturbation > 0) {
#line 647
      if (inc > perturbation + 1) {
#line 647
        pert = - perturbation;
      } else {
#line 647
        pert = 0;
      }
    } else {
#line 647
      pert = 0;
    }
    {
#line 647
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 647
      if (! (pert <= perturbation)) {
#line 647
        goto while_break___4;
      }
      {
#line 652
      Sync(& args);
      }
#line 656
      if (args.tr) {
#line 658
        if (nrepeat_const) {
#line 659
          nrepeat = nrepeat_const;
        } else
#line 663
        if (0.10 / (((double )args.bufflen / ((double )(args.bufflen - inc) + 1.0)) * tlast) > (double )3) {
#line 663
          nrepeat = (int )(0.10 / (((double )args.bufflen / ((double )(args.bufflen - inc) + 1.0)) * tlast));
        } else {
#line 663
          nrepeat = 3;
        }
        {
#line 666
        SendRepeat(& args, nrepeat);
        }
      } else
#line 668
      if (args.rcv) {
        {
#line 670
        RecvRepeat(& args, & nrepeat);
        }
      }
#line 673
      args.bufflen = len + pert;
#line 675
      if (args.tr) {
        {
#line 676
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%3d: %7d bytes %6d times --> ",
                n, args.bufflen, nrepeat);
        }
      }
#line 679
      if (args.cache) {
        {
#line 683
        MyMalloc(& args, args.bufflen + bufalign, args.soffset, args.roffset);
#line 687
        args.r_buff_orig = args.r_buff;
#line 688
        args.s_buff_orig = args.r_buff;
#line 692
        tmp___8 = AlignBuffer((void *)args.r_buff, bufalign);
#line 692
        args.r_buff = (char *)tmp___8;
#line 693
        args.s_buff = args.r_buff;
#line 706
        InitBufferData(& args, args.bufflen, args.soffset, args.roffset);
#line 711
        AfterAlignmentInit(& args);
#line 718
        args.r_ptr = args.r_buff + args.roffset;
#line 719
        args.s_ptr = args.r_buff + args.soffset;
        }
      } else {
#line 728
        len_buf_align = args.bufflen;
#line 729
        if (bufalign != 0) {
#line 730
          len_buf_align += bufalign - args.bufflen % bufalign;
        }
        {
#line 736
        InitBufferData(& args, 10000000, args.soffset, args.roffset);
#line 740
        args.r_ptr = args.r_buff + args.roffset;
#line 741
        args.s_ptr = args.s_buff + args.soffset;
        }
      }
#line 744
      bwdata[n].t = 1e99;
#line 755
      if (args.tr) {
#line 755
        goto _L;
      } else
#line 755
      if (args.bidir) {
        _L: /* CIL Label */ 
#line 763
        i = 0;
        {
#line 763
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 763
          if (integCheck) {
#line 763
            tmp___10 = 1;
          } else {
#line 763
            tmp___10 = 3;
          }
#line 763
          if (! (i < tmp___10)) {
#line 763
            goto while_break___5;
          }
#line 765
          if (args.preburst) {
#line 765
            if (asyncReceive) {
#line 765
              if (! streamopt) {
                {
#line 775
                SaveRecvPtr(& args);
#line 777
                j = 0;
                }
                {
#line 777
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 777
                  if (! (j < nrepeat)) {
#line 777
                    goto while_break___6;
                  }
                  {
#line 779
                  PrepareToReceive(& args);
                  }
#line 780
                  if (! args.cache) {
                    {
#line 781
                    AdvanceRecvPtr(& args, len_buf_align);
                    }
                  }
#line 777
                  j ++;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 784
                ResetRecvPtr(& args);
                }
              }
            }
          }
#line 788
          if (! args.cache) {
            {
#line 789
            flushcache(memcache, (int )(10000000UL / sizeof(int )));
            }
          }
          {
#line 791
          Sync(& args);
#line 793
          t0 = When();
#line 795
          j = 0;
          }
          {
#line 795
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 795
            if (! (j < nrepeat)) {
#line 795
              goto while_break___7;
            }
#line 797
            if (! args.preburst) {
#line 797
              if (asyncReceive) {
#line 797
                if (! streamopt) {
                  {
#line 799
                  PrepareToReceive(& args);
                  }
                }
              }
            }
#line 802
            if (integCheck) {
              {
#line 802
              SetIntegrityData(& args);
              }
            }
            {
#line 804
            SendData(& args);
            }
#line 806
            if (! streamopt) {
              {
#line 808
              RecvData(& args);
              }
#line 810
              if (integCheck) {
                {
#line 810
                VerifyIntegrity(& args);
                }
              }
#line 812
              if (! args.cache) {
                {
#line 813
                AdvanceRecvPtr(& args, len_buf_align);
                }
              }
            }
#line 820
            if (! args.cache) {
              {
#line 821
              AdvanceSendPtr(& args, len_buf_align);
              }
            }
#line 795
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 827
          tmp___9 = When();
#line 827
          t = (tmp___9 - t0) / (double )nrepeat;
          }
#line 829
          if (! streamopt) {
#line 829
            if (! args.bidir) {
#line 829
              t /= (double )2;
            }
          }
          {
#line 831
          Reset(& args);
          }
#line 837
          if (bwdata[n].t < t) {
#line 837
            bwdata[n].t = bwdata[n].t;
          } else {
#line 837
            bwdata[n].t = t;
          }
#line 763
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 842
        if (streamopt) {
          {
#line 843
          RecvTime(& args, & bwdata[n].t);
          }
        }
      } else
#line 853
      if (args.rcv) {
#line 860
        i = 0;
        {
#line 860
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 860
          if (integCheck) {
#line 860
            tmp___12 = 1;
          } else {
#line 860
            tmp___12 = 3;
          }
#line 860
          if (! (i < tmp___12)) {
#line 860
            goto while_break___8;
          }
#line 862
          if (asyncReceive) {
#line 864
            if (args.preburst) {
              {
#line 874
              SaveRecvPtr(& args);
#line 876
              j = 0;
              }
              {
#line 876
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 876
                if (! (j < nrepeat)) {
#line 876
                  goto while_break___9;
                }
                {
#line 878
                PrepareToReceive(& args);
                }
#line 879
                if (! args.cache) {
                  {
#line 880
                  AdvanceRecvPtr(& args, len_buf_align);
                  }
                }
#line 876
                j ++;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 883
              ResetRecvPtr(& args);
              }
            } else {
              {
#line 888
              PrepareToReceive(& args);
              }
            }
          }
#line 894
          if (! args.cache) {
            {
#line 895
            flushcache(memcache, (int )(10000000UL / sizeof(int )));
            }
          }
          {
#line 897
          Sync(& args);
#line 899
          t0 = When();
#line 900
          j = 0;
          }
          {
#line 900
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 900
            if (! (j < nrepeat)) {
#line 900
              goto while_break___10;
            }
            {
#line 902
            RecvData(& args);
            }
#line 904
            if (integCheck) {
              {
#line 904
              VerifyIntegrity(& args);
              }
            }
#line 906
            if (! args.cache) {
              {
#line 908
              AdvanceRecvPtr(& args, len_buf_align);
              }
            }
#line 911
            if (! args.preburst) {
#line 911
              if (asyncReceive) {
#line 911
                if (j < nrepeat - 1) {
                  {
#line 913
                  PrepareToReceive(& args);
                  }
                }
              }
            }
#line 916
            if (! streamopt) {
#line 918
              if (integCheck) {
                {
#line 918
                SetIntegrityData(& args);
                }
              }
              {
#line 920
              SendData(& args);
              }
#line 922
              if (! args.cache) {
                {
#line 923
                AdvanceSendPtr(& args, len_buf_align);
                }
              }
            }
#line 900
            j ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 927
          tmp___11 = When();
#line 927
          t = (tmp___11 - t0) / (double )nrepeat;
          }
#line 929
          if (! streamopt) {
#line 929
            if (! args.bidir) {
#line 929
              t /= (double )2;
            }
          }
          {
#line 931
          Reset(& args);
          }
#line 933
          if (bwdata[n].t < t) {
#line 933
            bwdata[n].t = bwdata[n].t;
          } else {
#line 933
            bwdata[n].t = t;
          }
#line 860
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 937
        if (streamopt) {
          {
#line 938
          SendTime(& args, & bwdata[n].t);
          }
        }
      } else {
#line 945
        i = 0;
        {
#line 945
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 945
          if (integCheck) {
#line 945
            tmp___13 = 1;
          } else {
#line 945
            tmp___13 = 3;
          }
#line 945
          if (! (i < tmp___13)) {
#line 945
            goto while_break___11;
          }
          {
#line 947
          Sync(& args);
#line 945
          i ++;
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 956
      if (bwdata[n].t == 0.0) {
#line 957
        bwdata[n].t = 0.000001;
      }
#line 960
      tlast = bwdata[n].t;
#line 961
      bwdata[n].bits = (args.bufflen * 8) * (1 + args.bidir);
#line 962
      bwdata[n].bps = (double )bwdata[n].bits / ((bwdata[n].t * (double )1024) * (double )1024);
#line 963
      bwdata[n].repeat = nrepeat;
#line 965
      if (args.tr) {
#line 967
        if (integCheck) {
          {
#line 968
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%8d %d",
                  bwdata[n].bits / 8, nrepeat);
          }
        } else {
          {
#line 971
          fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%8d %lf %12.8lf",
                  bwdata[n].bits / 8, bwdata[n].bps, bwdata[n].t);
          }
        }
        {
#line 975
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 976
        fflush(out);
        }
      }
#line 982
      if (args.cache) {
        {
#line 983
        FreeBuff(args.r_buff_orig, (char *)((void *)0));
        }
      }
#line 985
      if (args.tr) {
#line 986
        if (integCheck) {
          {
#line 987
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Integrity check passed\n");
          }
        } else {
          {
#line 990
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %8.2lf Mbps in %10.2lf usec\n",
                  bwdata[n].bps, tlast * 1.0e6);
          }
        }
      }
#line 647
      n ++;
#line 647
      if (perturbation > 0) {
#line 647
        if (inc > perturbation + 1) {
#line 647
          tmp___7 = perturbation;
        } else {
#line 647
          tmp___7 = perturbation + 1;
        }
      } else {
#line 647
        tmp___7 = perturbation + 1;
      }
#line 647
      pert += tmp___7;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 636
    len += inc;
#line 636
    nq ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1003
  if (! args.cache) {
    {
#line 1004
    FreeBuff(args.s_buff_orig, args.r_buff_orig);
    }
  }
#line 1006
  if (args.tr) {
    {
#line 1006
    fclose(out);
    }
  }
  {
#line 1008
  CleanUp(& args);
  }
#line 1009
  return (0);
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
double When(void) 
{ 
  struct timeval tp ;

  {
  {
#line 1017
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
  }
#line 1018
  return ((double )tp.tv_sec + (double )tp.tv_usec * 1e-6);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void mymemset(int *ptr , int c , int n ) 
{ 
  int i ;

  {
#line 1029
  i = 0;
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1029
    if (! (i < n)) {
#line 1029
      goto while_break;
    }
#line 1030
    *(ptr + i) = c;
#line 1029
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1038 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
static int flag  =    0;
#line 1036 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void flushcache(int *ptr , int n ) 
{ 
  int i ;

  {
#line 1041
  flag = (flag + 1) % 2;
#line 1042
  if (flag == 0) {
#line 1043
    i = 0;
    {
#line 1043
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1043
      if (! (i < n)) {
#line 1043
        goto while_break;
      }
#line 1044
      (*(ptr + i)) ++;
#line 1043
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1046
    i = 0;
    {
#line 1046
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1046
      if (! (i < n)) {
#line 1046
        goto while_break___0;
      }
#line 1047
      (*(ptr + i)) --;
#line 1046
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1049
  return;
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void SetIntegrityData(ArgStruct *p ) 
{ 
  int i ;
  int num_segments ;

  {
#line 1062
  num_segments = (int )((unsigned long )p->bufflen / sizeof(int ));
#line 1064
  i = 0;
  {
#line 1064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    if (! (i < num_segments)) {
#line 1064
      goto while_break;
    }
#line 1066
    *((int *)p->s_ptr + i) = i;
#line 1064
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1069
  return;
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void VerifyIntegrity(ArgStruct *p ) 
{ 
  int i ;
  int num_segments ;
  int integrityVerified ;

  {
#line 1075
  integrityVerified = 1;
#line 1077
  num_segments = (int )((unsigned long )p->bufflen / sizeof(int ));
#line 1079
  i = 0;
  {
#line 1079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1079
    if (! (i < num_segments)) {
#line 1079
      goto while_break;
    }
#line 1081
    if (*((int *)p->r_ptr + i) != i) {
#line 1083
      integrityVerified = 0;
#line 1084
      goto while_break;
    }
#line 1079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1091
  if (! integrityVerified) {
    {
#line 1093
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Integrity check failed: Expecting %d but received %d\n",
            i, *((int *)p->r_ptr + i));
#line 1106
    exit(-1);
    }
  }
#line 1110
  return;
}
}
#line 1112 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void PrintUsage(void) 
{ 


  {
  {
#line 1114
  printf((char const   */* __restrict  */)"\n NETPIPE USAGE \n\n");
#line 1116
  printf((char const   */* __restrict  */)"a: asynchronous receive (a.k.a. preposted receive)\n");
#line 1118
  printf((char const   */* __restrict  */)"B: burst all preposts before measuring performance\n");
#line 1120
  printf((char const   */* __restrict  */)"b: specify TCP send/receive socket buffer sizes\n");
#line 1142
  printf((char const   */* __restrict  */)"h: specify hostname of the receiver <-h host>\n");
#line 1145
  printf((char const   */* __restrict  */)"I: Invalidate cache (measure performance without cache effects).\n   This simulates data coming from main memory instead of cache.\n");
#line 1147
  printf((char const   */* __restrict  */)"i: Do an integrity check instead of measuring performance\n");
#line 1148
  printf((char const   */* __restrict  */)"l: lower bound start value e.g. <-l 1>\n");
#line 1155
  printf((char const   */* __restrict  */)"n: Set a constant value for number of repeats <-n 50>\n");
#line 1156
  printf((char const   */* __restrict  */)"o: specify output filename <-o filename>\n");
#line 1157
  printf((char const   */* __restrict  */)"O: specify transmit and optionally receive buffer offsets <-O 1,3>\n");
#line 1158
  printf((char const   */* __restrict  */)"p: set the perturbation number <-p 1>\n   (default = 3 Bytes, set to 0 for no perturbations)\n");
#line 1162
  printf((char const   */* __restrict  */)"r: reset sockets for every trial\n");
#line 1165
  printf((char const   */* __restrict  */)"s: stream data in one direction only.\n");
#line 1207
  printf((char const   */* __restrict  */)"u: upper bound stop value e.g. <-u 1048576>\n");
#line 1213
  printf((char const   */* __restrict  */)"2: Send data in both directions at the same time.\n");
#line 1214
  printf((char const   */* __restrict  */)"P: Set the port number to one other than the default.\n");
#line 1219
  printf((char const   */* __restrict  */)"   The maximum test size is limited by the TCP buffer size\n");
#line 1222
  printf((char const   */* __restrict  */)"A: Use SDP Address familty (AF_INET_SDP)\n");
#line 1224
  printf((char const   */* __restrict  */)"\n");
  }
#line 1225
  return;
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void *AlignBuffer(void *buff , int boundary ) 
{ 


  {
#line 1229
  if (boundary == 0) {
#line 1230
    return (buff);
  } else {
#line 1233
    return ((void *)((char *)buff + ((unsigned long )boundary - (unsigned long )buff % (unsigned long )boundary)));
  }
}
}
#line 1236 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void AdvanceSendPtr(ArgStruct *p , int blocksize ) 
{ 


  {
#line 1240
  if ((unsigned long )(p->s_ptr + blocksize) < (unsigned long )((p->s_buff + 10000000) - blocksize)) {
#line 1242
    p->s_ptr += blocksize;
  } else {
#line 1246
    p->s_ptr = p->s_buff;
  }
#line 1247
  return;
}
}
#line 1249 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void AdvanceRecvPtr(ArgStruct *p , int blocksize ) 
{ 


  {
#line 1253
  if ((unsigned long )(p->r_ptr + blocksize) < (unsigned long )((p->r_buff + 10000000) - blocksize)) {
#line 1255
    p->r_ptr += blocksize;
  } else {
#line 1259
    p->r_ptr = p->r_buff;
  }
#line 1260
  return;
}
}
#line 1262 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void SaveRecvPtr(ArgStruct *p ) 
{ 


  {
#line 1266
  p->r_ptr_saved = (char *)((void *)p->r_ptr);
#line 1267
  return;
}
}
#line 1269 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void ResetRecvPtr(ArgStruct *p ) 
{ 


  {
#line 1271
  p->r_ptr = p->r_ptr_saved;
#line 1272
  return;
}
}
#line 1275 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void InitBufferData(ArgStruct *p , int nbytes , int soffset , int roffset ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1277
  if (soffset > roffset) {
#line 1277
    tmp = soffset;
  } else {
#line 1277
    tmp = roffset;
  }
  {
#line 1277
  memset((void *)p->r_buff, 'a', (size_t )(nbytes + tmp));
  }
#line 1284
  if (p->cache) {
#line 1286
    if (soffset > roffset) {
#line 1286
      tmp___0 = soffset;
    } else {
#line 1286
      tmp___0 = roffset;
    }
#line 1286
    *(p->r_buff + ((nbytes + tmp___0) - 1)) = (char )(97 + p->tr);
  } else {
    {
#line 1294
    memset((void *)p->s_buff, 'b', (size_t )(nbytes + soffset));
    }
  }
#line 1295
  return;
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void MyMalloc(ArgStruct *p , int bufflen , int soffset , int roffset ) 
{ 
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
#line 1300
  if (soffset > roffset) {
#line 1300
    tmp___0 = soffset;
  } else {
#line 1300
    tmp___0 = roffset;
  }
  {
#line 1300
  tmp___1 = malloc((size_t )(bufflen + tmp___0));
#line 1300
  tmp = (char *)tmp___1;
#line 1300
  p->r_buff = tmp;
  }
#line 1300
  if ((unsigned long )tmp == (unsigned long )((char *)((void *)0))) {
    {
#line 1302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t allocate memory for receive buffer\n");
#line 1303
    exit(-1);
    }
  }
#line 1307
  if (! p->cache) {
    {
#line 1308
    tmp___3 = malloc((size_t )(bufflen + soffset));
#line 1308
    tmp___2 = (char *)tmp___3;
#line 1308
    p->s_buff = tmp___2;
    }
#line 1308
    if ((unsigned long )tmp___2 == (unsigned long )((char *)((void *)0))) {
      {
#line 1310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"couldn\'t allocate memory for send buffer\n");
#line 1311
      exit(-1);
      }
    }
  }
#line 1313
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/netpipe-3.7.2/./src/netpipe.c"
void FreeBuff(char *buff1 , char *buff2 ) 
{ 


  {
#line 1317
  if ((unsigned long )buff1 != (unsigned long )((void *)0)) {
    {
#line 1319
    free((void *)buff1);
    }
  }
#line 1322
  if ((unsigned long )buff2 != (unsigned long )((void *)0)) {
    {
#line 1324
    free((void *)buff2);
    }
  }
#line 1325
  return;
}
}
