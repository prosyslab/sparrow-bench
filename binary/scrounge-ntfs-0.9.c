/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 79 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef unsigned char byte;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 92 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef uint64_t uint64;
#line 104 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef int64_t int64;
#line 116 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef uint32_t uint32;
#line 140 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef uint16_t uint16;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 59 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
struct _drive_partentry {
   byte active ;
   byte starthead ;
   byte startsector ;
   byte startcylinder ;
   byte system ;
   byte endhead ;
   byte endsector ;
   byte endcylinder ;
   uint32 startsec ;
   uint32 endsec ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
typedef struct _drive_partentry drive_partentry;
#line 77 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
struct _drive_mbr {
   byte fill[446] ;
   drive_partentry partitions[4] ;
   uint16 sig ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
typedef struct _drive_mbr drive_mbr;
#line 85
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
#pragma pack(1)
#line 37 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct ntfs_bootsector {
   byte jmp[3] ;
   char sysId[8] ;
   uint16 bytePerSec ;
   byte secPerClus ;
   byte padding[7] ;
   byte mediaDescriptor ;
   byte padding2[2] ;
   uint16 secPerTrack ;
   uint16 numHeads ;
   byte padding3[8] ;
   uint32 signature ;
   uint64 cSectors ;
   uint64 offMFT ;
   uint64 offMFTMirr ;
   uint32 clusPerMFT ;
   uint32 clusPerIndex ;
   uint64 serialNum ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct ntfs_bootsector ntfs_bootsector;
#line 197
#pragma pack()
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
struct _ntfsx_mftmap;
#line 35
struct _drivelocks;
#line 37 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
struct _partitioninfo {
   uint32 first ;
   uint32 end ;
   uint32 mft ;
   byte cluster ;
   int device ;
   struct _drivelocks *locks ;
   struct _ntfsx_mftmap *mftmap ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
typedef struct _partitioninfo partitioninfo;
#line 51
#pragma pack(1)
#line 85
#pragma pack()
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 152 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int uint;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 240 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef char fchar_t;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
#pragma pack(1)
#line 197
#pragma pack()
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 152 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef int16_t int16;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 28 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef int16 ntfs_char;
#line 30
#pragma pack(1)
#line 197
#pragma pack()
#line 73 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef unsigned char bool;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
#pragma pack(1)
#line 72 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_recordheader {
   uint32 magic ;
   uint16 offUpdSeq ;
   uint16 cwUpdSeq ;
   uint64 logSeqNum ;
   uint16 seqNum ;
   uint16 cHardlinks ;
   uint16 offAttrs ;
   uint16 flags ;
   uint32 cbRecord ;
   uint32 cbAllocated ;
   uint64 refBaseRecord ;
   uint16 nextAttrId ;
   uint16 padding ;
   uint32 recordNum ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_recordheader ntfs_recordheader;
#line 96 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_attribheader {
   uint32 type ;
   uint32 cbAttribute ;
   byte bNonResident ;
   byte cName ;
   uint16 offName ;
   uint16 flags ;
   uint16 idAttribute ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_attribheader ntfs_attribheader;
#line 108 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_attribresident {
   ntfs_attribheader header ;
   uint32 cbAttribData ;
   uint16 offAttribData ;
   byte bIndexed ;
   byte padding ;
};
#line 108 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_attribresident ntfs_attribresident;
#line 119 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_attribnonresident {
   ntfs_attribheader header ;
   uint64 startVCN ;
   uint64 lastVCN ;
   uint16 offDataRuns ;
   uint16 compUnitSize ;
   uint32 padding ;
   uint64 cbAllocated ;
   uint64 cbAttribData ;
   uint64 cbInitData ;
};
#line 119 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_attribnonresident ntfs_attribnonresident;
#line 184 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_attriblistrecord {
   uint32 type ;
   uint16 cbRecord ;
   byte cName ;
   byte offName ;
   uint64 startVCN ;
   uint64 refAttrib ;
   uint16 idAttribute ;
};
#line 184 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_attriblistrecord ntfs_attriblistrecord;
#line 197
#pragma pack()
#line 28 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_datarun {
   byte *_mem ;
   byte *_datarun ;
   byte *_curpos ;
   bool sparse ;
   uint64 cluster ;
   uint64 length ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_datarun ntfsx_datarun;
#line 48 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_cluster {
   uint32 size ;
   byte *data ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_cluster ntfsx_cluster;
#line 62 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_attribute {
   ntfs_attribheader *_header ;
   byte *_mem ;
   uint32 _length ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_attribute ntfsx_attribute;
#line 80 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_record {
   partitioninfo *info ;
   ntfsx_cluster _clus ;
};
#line 80 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_record ntfsx_record;
#line 97 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_attrib_enum {
   ntfs_attribheader *_attrhead ;
   ntfs_attriblistrecord *_listrec ;
   unsigned char _flags ;
   uint32 type ;
};
#line 97 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_attrib_enum ntfsx_attrib_enum;
#line 115
struct _ntfsx_mftmap_block;
#line 116 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
struct _ntfsx_mftmap {
   partitioninfo *info ;
   struct _ntfsx_mftmap_block *_blocks ;
   uint32 _count ;
};
#line 116 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
typedef struct _ntfsx_mftmap ntfsx_mftmap;
#line 524 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
struct _ntfsx_mftmap_block {
   uint64 firstSector ;
   uint64 length ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
#pragma pack(1)
#line 197
#pragma pack()
#line 25 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/locks.h"
struct drivelock;
#line 26 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/locks.h"
struct _drivelocks {
   struct drivelock *_locks ;
   uint32 _count ;
   uint32 _current ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/locks.h"
typedef struct _drivelocks drivelocks;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
struct drivelock {
   uint64 beg ;
   uint64 end ;
};
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 128 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
typedef int32_t int32;
#line 51 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/drive.h"
#pragma pack(1)
#line 85
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
#pragma pack(1)
#line 167 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
struct _ntfs_attribfilename {
   uint64 refParent ;
   uint64 timeCreated ;
   uint64 timeAltered ;
   uint64 timeModified ;
   uint64 timeRead ;
   uint64 cbAllocated ;
   uint64 cbFileSize ;
   uint32 flags ;
   uint32 eaReparse ;
   byte cFileName ;
   byte nameSpace ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
typedef struct _ntfs_attribfilename ntfs_attribfilename;
#line 197
#pragma pack()
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
struct _filebasics {
   fchar_t filename[257] ;
   uint64 created ;
   uint64 modified ;
   uint64 accessed ;
   uint32 flags ;
   uint64 parent ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
typedef struct _filebasics filebasics;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
char const   kPrintData[135]  = 
#line 24 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'S',      (char const   )'t',      (char const   )'a',      (char const   )'r', 
        (char const   )'t',      (char const   )' ',      (char const   )'S',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'E',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'S',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'C',      (char const   )'l',      (char const   )'u',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'S',      (char const   )'i',      (char const   )'z',      (char const   )'e', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'M',      (char const   )'F',      (char const   )'T',      (char const   )' ', 
        (char const   )'O',      (char const   )'f',      (char const   )'f',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'\n',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'=',      (char const   )'=',      (char const   )'=', 
        (char const   )'=',      (char const   )'\n',      (char const   )'\000'};
#line 29 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
char const   kPrintDrive[12]  = 
#line 29
  {      (char const   )'\n',      (char const   )'D',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'u',      (char const   )'\n',      (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
char const   kPrintDrivePath[12]  = 
#line 30
  {      (char const   )'\n',      (char const   )'D',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\n',      (char const   )'\000'};
#line 31 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
char const   kPrintDriveInfo[17]  = 
#line 31
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'%',      (char const   )'-',      (char const   )'1',      (char const   )'5', 
        (char const   )'u',      (char const   )' ',      (char const   )'%',      (char const   )'-', 
        (char const   )'1',      (char const   )'5',      (char const   )'u',      (char const   )' ', 
        (char const   )'\000'};
#line 32 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
char const   kPrintNTFSInfo[12]  = 
#line 32
  {      (char const   )'%',      (char const   )'-',      (char const   )'1',      (char const   )'5', 
        (char const   )'u',      (char const   )' ',      (char const   )'%',      (char const   )'-', 
        (char const   )'1',      (char const   )'5',      (char const   )'u',      (char const   )'\000'};
#line 45
extern int ( /* missing proto */  err)() ;
#line 44
extern int ( /* missing proto */  lseek64)() ;
#line 52
extern int ( /* missing proto */  errx)() ;
#line 34 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
int printNTFSInfo(int dd , uint64 tblSector ) 
{ 
  byte sector[512] ;
  int64 pos ;
  size_t sz ;
  ntfs_bootsector *boot ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 42
  pos = (int64 )(tblSector * 512UL);
#line 44
  tmp = lseek64(dd, pos, 0);
  }
#line 44
  if (tmp == -1) {
    {
#line 45
    err(1, "couldn\'t seek drive");
    }
  }
  {
#line 47
  tmp___0 = read(dd, (void *)(& sector), (size_t )512);
#line 47
  sz = (size_t )tmp___0;
  }
#line 48
  if (sz == 0xffffffffffffffffUL) {
    {
#line 49
    err(1, "couldn\'t read drive");
    }
  }
#line 51
  if (sz != 512UL) {
    {
#line 52
    errx(1, "unexpected end of drive");
    }
  }
  {
#line 54
  boot = (ntfs_bootsector *)(sector);
#line 55
  tmp___1 = memcmp((void const   *)(boot->sysId), (void const   *)"NTFS    ", sizeof(boot->sysId));
  }
#line 55
  if (! tmp___1) {
    {
#line 56
    printf((char const   */* __restrict  */)(kPrintNTFSInfo), (int )boot->secPerClus,
           boot->offMFT * (uint64 )boot->secPerClus);
    }
  }
  {
#line 58
  printf((char const   */* __restrict  */)"\n");
  }
#line 59
  return (0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
int printPartitionInfo(int dd , uint64 tblSector ) 
{ 
  drive_mbr mbr ;
  int64 pos ;
  size_t sz ;
  int i ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 71
  pos = (int64 )(tblSector * 512UL);
#line 73
  tmp = lseek64(dd, pos, 0);
  }
#line 73
  if (tmp == -1) {
    {
#line 74
    err(1, "couldn\'t seek drive");
    }
  }
  {
#line 76
  tmp___0 = read(dd, (void *)(& mbr), sizeof(drive_mbr ));
#line 76
  sz = (size_t )tmp___0;
  }
#line 77
  if (sz == 0xffffffffffffffffUL) {
    {
#line 78
    err(1, "couldn\'t read drive");
    }
  }
#line 80
  if (sz != sizeof(drive_mbr )) {
    {
#line 81
    errx(1, "unexpected end of drive");
    }
  }
#line 83
  if ((int )mbr.sig == 43605) {
#line 85
    i = 0;
    {
#line 85
    while (1) {
      while_continue: /* CIL Label */ ;
#line 85
      if (! (i < 4)) {
#line 85
        goto while_break;
      }
#line 87
      if ((int )mbr.partitions[i].system == 5) {
        {
#line 90
        printPartitionInfo(dd, tblSector + (uint64 )mbr.partitions[i].startsec);
        }
      } else
#line 87
      if ((int )mbr.partitions[i].system == 15) {
        {
#line 90
        printPartitionInfo(dd, tblSector + (uint64 )mbr.partitions[i].startsec);
        }
      } else
#line 92
      if (! mbr.partitions[i].system == 0) {
        {
#line 94
        printf((char const   */* __restrict  */)(kPrintDriveInfo), (uint32 )tblSector + mbr.partitions[i].startsec,
               (uint32 )tblSector + mbr.partitions[i].endsec);
#line 95
        printNTFSInfo(dd, tblSector + (uint64 )mbr.partitions[i].startsec);
        }
      }
#line 85
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 100
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/list.c"
void scroungeListDrive(char *drive ) 
{ 
  int dd ;
  int tmp ;

  {
  {
#line 130
  tmp = open((char const   *)drive, 0);
#line 130
  dd = tmp;
  }
#line 131
  if (dd == -1) {
    {
#line 132
    err(1, "couldn\'t open drive: %s", drive);
    }
  }
  {
#line 134
  printf((char const   */* __restrict  */)(kPrintData));
#line 135
  printf((char const   */* __restrict  */)(kPrintDrivePath), drive);
#line 136
  printPartitionInfo(dd, (uint64 )0);
#line 137
  close(dd);
  }
#line 138
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/search.c"
void scroungeSearch(partitioninfo *pi ) 
{ 


  {
  {
#line 26
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Performing NTFS partition search...]");
#line 27
  errx(1, "search functionality not implemented yet.");
  }
#line 42
  return;
}
}
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 138 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/posix.c"
void ntfs_maketvs(uint64 *ft , struct timeval *tv ) 
{ 
  uint mod ;

  {
#line 49
  if ((long long )*ft < 116444736000000000LL) {
#line 51
    tv->tv_sec = (__time_t )0;
#line 52
    tv->tv_usec = (__suseconds_t )0;
  } else
#line 56
  if (sizeof(tv->tv_sec) == 32UL) {
#line 58
    tv->tv_sec = (__time_t )2147483647;
#line 59
    tv->tv_usec = (__suseconds_t )2147483647;
  } else {
#line 65
    mod = (uint )(*ft % 1000000000UL);
#line 66
    tv->tv_sec = (__time_t )((*ft - (uint64 )mod) / 1000000000UL);
#line 67
    tv->tv_usec = (__suseconds_t )(mod / 1000U);
  }
#line 69
  return;
}
}
#line 81
extern int ( /* missing proto */  warn)() ;
#line 71 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/posix.c"
void setFileTime(fchar_t *filename , uint64 *created , uint64 *accessed , uint64 *modified ) 
{ 
  struct timeval tvs[2] ;
  char *encoded ;
  int tmp ;

  {
  {
#line 78
  ntfs_maketvs(accessed, tvs);
#line 79
  ntfs_maketvs(modified, tvs + 1);
#line 80
  tmp = utimes((char const   *)filename, (struct timeval  const  *)(tvs));
  }
#line 80
  if (tmp == -1) {
    {
#line 81
    warn("couldn\'t set file times on: %s", encoded);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/posix.c"
void setFileAttributes(fchar_t *filename , uint32 flags ) 
{ 
  char *encoded ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
#line 89
  if (flags & 1U) {
    {
#line 91
    tmp___0 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
    }
#line 91
    if (tmp___0 == -1) {
      {
#line 93
      warn("couldn\'t read file status for: %s", encoded);
      }
    } else {
      {
#line 97
      st.st_mode &= (unsigned int )(~ ((128 | (128 >> 3)) | ((128 >> 3) >> 3)));
#line 98
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mode: %x",
              st.st_mode);
#line 100
      tmp = chmod((char const   *)filename, st.st_mode);
      }
#line 100
      if (tmp == -1) {
        {
#line 101
        warn("couldn\'t set file attributes for: %s", encoded);
        }
      }
    }
  }
#line 104
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.h"
void scroungeUsingMFT(partitioninfo *pi ) ;
#line 31
void scroungeUsingRaw(partitioninfo *pi ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/main.c"
char const   kPrintHelp[1058]  = 
#line 46 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/main.c"
  {      (char const   )'u',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'s', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'-',      (char const   )'l',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'k',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'L',      (char const   )'i',      (char const   )'s',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'d',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )'i', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'.',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'\n',      (char const   )'u',      (char const   )'s', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )':', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'r', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'-',      (char const   )'s', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'k',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'S',      (char const   )'e', 
        (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )' ',      (char const   )'d',      (char const   )'r',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'N', 
        (char const   )'T',      (char const   )'F',      (char const   )'S',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )'.',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'\n', 
        (char const   )'u',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'s', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'m',      (char const   )' ', 
        (char const   )'m',      (char const   )'f',      (char const   )'t',      (char const   )'o', 
        (char const   )'f',      (char const   )'f',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )']',      (char const   )' ',      (char const   )'[', 
        (char const   )'-',      (char const   )'c',      (char const   )' ',      (char const   )'c', 
        (char const   )'l',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )'i', 
        (char const   )'z',      (char const   )'e',      (char const   )']',      (char const   )' ', 
        (char const   )'[',      (char const   )'-',      (char const   )'o',      (char const   )' ', 
        (char const   )'o',      (char const   )'u',      (char const   )'t',      (char const   )'d', 
        (char const   )'i',      (char const   )'r',      (char const   )']',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'k', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )' ', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'S', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'u', 
        (char const   )'n',      (char const   )'g',      (char const   )'e',      (char const   )' ', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'a',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'m',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'O',      (char const   )'f',      (char const   )'f',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'m',      (char const   )'f', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'s',      (char const   )')',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'-', 
        (char const   )'c',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'C',      (char const   )'l', 
        (char const   )'u',      (char const   )'s',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'s',      (char const   )'i', 
        (char const   )'z',      (char const   )'e',      (char const   )' ',      (char const   )'(', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )'s',      (char const   )',',      (char const   )' ', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'a', 
        (char const   )'u',      (char const   )'l',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'8', 
        (char const   )')',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'-',      (char const   )'o',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'D',      (char const   )'i',      (char const   )'r',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'y',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'s',      (char const   )'c',      (char const   )'r', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'k',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'r',      (char const   )'a', 
        (char const   )'w',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'k',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )'i', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'s', 
        (char const   )' ',      (char const   )'(',      (char const   )'i',      (char const   )'e', 
        (char const   )':',      (char const   )' ',      (char const   )'/',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'/',      (char const   )'h', 
        (char const   )'d',      (char const   )'a',      (char const   )')',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )'s',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'F',      (char const   )'i',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'t', 
        (char const   )'i',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'L',      (char const   )'a', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'c',      (char const   )'t',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'r', 
        (char const   )'t',      (char const   )'i',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'\n',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\n',      (char const   )'\000'};
#line 71
void usage(void) ;
#line 218
extern int ( /* missing proto */  warnx)() ;
#line 77 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/main.c"
int main(int argc , char **argv ) 
{ 
  int ch ;
  int temp ;
  int mode ;
  int raw ;
  partitioninfo pi ;
  char driveName[257] ;
  int tmp ;

  {
  {
#line 79
  ch = 0;
#line 80
  temp = 0;
#line 81
  mode = 0;
#line 82
  raw = 0;
#line 89
  memset((void *)(& pi), 0, sizeof(pi));
#line 92
  pi.cluster = (byte )8;
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 97
    ch = getopt(argc, (char * const  *)argv, "c:hlm:o:sv");
    }
#line 97
    if (! (ch != -1)) {
#line 97
      goto while_break;
    }
    {
#line 104
    if (ch == 99) {
#line 104
      goto case_99;
    }
#line 133
    if (ch == 108) {
#line 133
      goto case_108;
    }
#line 143
    if (ch == 109) {
#line 143
      goto case_109;
    }
#line 157
    if (ch == 111) {
#line 157
      goto case_111;
    }
#line 163
    if (ch == 115) {
#line 163
      goto case_115;
    }
#line 181
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 106
    temp = atoi((char const   *)optarg);
    }
#line 109
    if (temp <= 0) {
      {
#line 110
      errx(2, "invalid cluster size (must be between 1 and 128)");
      }
    } else
#line 109
    if (temp > 128) {
      {
#line 110
      errx(2, "invalid cluster size (must be between 1 and 128)");
      }
    }
#line 112
    pi.cluster = (byte )temp;
#line 113
    mode = 1;
#line 115
    goto switch_break;
    case_108: /* CIL Label */ 
#line 135
    if (mode == 1) {
      {
#line 136
      errx(2, "invalid -l argument in scrounge mode");
      }
    }
#line 138
    mode = 2;
#line 140
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 145
    temp = atoi((char const   *)optarg);
    }
#line 148
    if (temp < 0) {
      {
#line 149
      errx(2, "invalid mft offset (must be positive)");
      }
    }
#line 151
    pi.mft = (uint32 )temp;
#line 152
    mode = 1;
#line 154
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 158
    tmp = chdir((char const   *)optarg);
    }
#line 158
    if (tmp == -1) {
      {
#line 159
      err(2, "couldn\'t change to output directory");
      }
    }
#line 160
    goto switch_break;
    case_115: /* CIL Label */ 
#line 165
    if (mode == 1) {
      {
#line 166
      errx(2, "invalid -s argument in scrounge mode");
      }
    }
#line 168
    mode = 3;
#line 170
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 182
    usage();
    }
#line 183
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 186
    if (mode != 1) {
#line 186
      if (mode != 0) {
#line 187
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  argc -= optind;
#line 191
  argv += optind;
#line 199
  if (argc < 1) {
    {
#line 200
    errx(2, "must specify drive name");
    }
  }
  {
#line 202
  strncpy((char */* __restrict  */)(driveName), (char const   */* __restrict  */)*(argv + 0),
          (size_t )256);
#line 203
  driveName[256] = (char)0;
#line 205
  argv ++;
#line 206
  argc --;
  }
#line 210
  if (mode == 1) {
#line 210
    goto _L;
  } else
#line 210
  if (mode == 0) {
    _L: /* CIL Label */ 
#line 214
    if (argc < 2) {
      {
#line 215
      errx(2, "must specify start and end sector of partition");
      }
    }
#line 217
    if (argc > 2) {
      {
#line 218
      warnx("ignoring extra arguments");
      }
    }
    {
#line 220
    temp = atoi((char const   *)*(argv + 0));
    }
#line 221
    if (temp < 0) {
      {
#line 222
      errx(2, "invalid start sector (must be positive)");
      }
    }
    {
#line 224
    pi.first = (uint32 )temp;
#line 226
    temp = atoi((char const   *)*(argv + 1));
    }
#line 227
    if (temp < 0) {
      {
#line 228
      errx(2, "invalid end sector (must be positive and greater than first)");
      }
    } else
#line 227
    if ((unsigned int )temp <= pi.first) {
      {
#line 228
      errx(2, "invalid end sector (must be positive and greater than first)");
      }
    }
    {
#line 230
    pi.end = (uint32 )temp;
#line 233
    pi.device = open((char const   *)(driveName), 0);
    }
#line 234
    if (pi.device == -1) {
      {
#line 235
      err(1, "couldn\'t open drive: %s", driveName);
      }
    }
#line 238
    if (pi.mft != 0U) {
      {
#line 240
      scroungeUsingMFT(& pi);
      }
    } else {
      {
#line 246
      warnx("Scrounging via raw search. Directory info will be discarded.");
#line 247
      scroungeUsingRaw(& pi);
      }
    }
  } else {
#line 253
    if (argc > 0) {
      {
#line 254
      warnx("ignoring extra arguments");
      }
    }
#line 257
    if (mode == 2) {
      {
#line 261
      scroungeListDrive(driveName);
      }
    }
#line 265
    if (mode == 3) {
      {
#line 266
      scroungeSearch(& pi);
      }
    }
  }
#line 269
  return (0);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/main.c"
void usage(void) 
{ 


  {
  {
#line 274
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          kPrintHelp);
#line 275
  exit(2);
  }
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.h"
void *reallocf(void *ptr , size_t size ) ;
#line 196
void *mallocf(size_t size ) ;
#line 207
wchar_t *itow(int val , wchar_t *out , int radix ) ;
#line 216
char *itoa(int val , char *out , int radix ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 288 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.c"
void *reallocf(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 290
  tmp = realloc(ptr, size);
#line 290
  ret = tmp;
  }
#line 291
  if (! ret) {
    {
#line 292
    errx(1, "out of memory");
    }
  }
#line 293
  return (ret);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.c"
void *mallocf(size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
  {
#line 302
  tmp = malloc(size);
#line 302
  ret = tmp;
  }
#line 303
  if (! ret) {
    {
#line 304
    errx(1, "out of memory");
    }
  }
#line 305
  return (ret);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.c"
wchar_t *itow(int val , wchar_t *out , int radix ) 
{ 
  int mod ;
  wchar_t temp ;
  wchar_t *end ;
  wchar_t *beg ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;
  wchar_t *tmp___1 ;

  {
#line 315
  end = out;
#line 316
  beg = out;
#line 318
  if (val != 0) {
#line 321
    if (radix == 10) {
#line 321
      if (val < 0) {
#line 322
        tmp = beg;
#line 322
        beg ++;
#line 322
        *tmp = 45;
      }
    }
    {
#line 325
    while (1) {
      while_continue: /* CIL Label */ ;
#line 325
      if (! (val != 0)) {
#line 325
        goto while_break;
      }
#line 327
      mod = val % radix;
#line 328
      val /= radix;
#line 330
      tmp___0 = end;
#line 330
      end ++;
#line 330
      if (mod < 10) {
#line 330
        *tmp___0 = 48 + mod;
      } else {
#line 330
        *tmp___0 = (97 + mod) - 10;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 333
    tmp___1 = end;
#line 333
    end --;
#line 333
    *tmp___1 = 0;
    {
#line 336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 336
      if (! ((unsigned long )end > (unsigned long )beg)) {
#line 336
        goto while_break___0;
      }
#line 338
      temp = *end;
#line 339
      *end = *beg;
#line 340
      *beg = temp;
#line 341
      beg ++;
#line 342
      end --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 347
    *(beg + 0) = 48;
#line 348
    *(beg + 1) = 0;
  }
#line 351
  return (out);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/compat.c"
char *itoa(int val , char *out , int radix ) 
{ 
  int mod ;
  char temp ;
  char *end ;
  char *beg ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 360
  end = out;
#line 361
  beg = out;
#line 363
  if (val != 0) {
#line 366
    if (radix == 10) {
#line 366
      if (val < 0) {
#line 367
        tmp = beg;
#line 367
        beg ++;
#line 367
        *tmp = (char )'-';
      }
    }
    {
#line 370
    while (1) {
      while_continue: /* CIL Label */ ;
#line 370
      if (! (val != 0)) {
#line 370
        goto while_break;
      }
#line 372
      mod = val % radix;
#line 373
      val /= radix;
#line 375
      tmp___0 = end;
#line 375
      end ++;
#line 375
      if (mod < 10) {
#line 375
        *tmp___0 = (char )(48 + mod);
      } else {
#line 375
        *tmp___0 = (char )((97 + mod) - 10);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 378
    tmp___1 = end;
#line 378
    end --;
#line 378
    *tmp___1 = (char)0;
    {
#line 381
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 381
      if (! ((unsigned long )end > (unsigned long )beg)) {
#line 381
        goto while_break___0;
      }
#line 383
      temp = *end;
#line 384
      *end = *beg;
#line 385
      *beg = temp;
#line 386
      beg ++;
#line 387
      end --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 392
    *(beg + 0) = (char )'0';
#line 393
    *(beg + 1) = (char)0;
  }
#line 396
  return (out);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
char *unicode_transcode16to8(ntfs_char const   *src , size_t len ) ;
#line 209
ntfs_char *unicode_transcode8to16(char const   *src , ntfs_char *out , size_t len ) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/unicode.c"
char *unicode_transcode16to8(ntfs_char const   *src , size_t len ) 
{ 
  char *ret ;
  size_t alloc ;
  size_t pos ;
  ntfs_char const   *c ;
  ntfs_char const   *e ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 14
  ret = (char *)((void *)0);
#line 15
  alloc = (size_t )0;
#line 16
  pos = (size_t )0;
#line 21
  alloc = (len + len / 4UL) + 1UL;
#line 22
  tmp = mallocf(alloc * sizeof(char ));
#line 22
  ret = (char *)tmp;
#line 24
  c = src;
#line 25
  e = c + len;
  }
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 27
    if (! ((unsigned long )c < (unsigned long )e)) {
#line 27
      goto while_break;
    }
#line 30
    if (pos + 4UL >= alloc) {
      {
#line 32
      alloc += len / 2UL + 1UL;
#line 33
      tmp___0 = reallocf((void *)ret, alloc * sizeof(char ));
#line 33
      ret = (char *)tmp___0;
      }
    }
#line 37
    if ((int const   )*c <= 127) {
#line 39
      tmp___1 = pos;
#line 39
      pos ++;
#line 39
      *(ret + tmp___1) = (char )*c;
    } else
#line 43
    if ((int const   )*c <= 2047) {
#line 45
      tmp___2 = pos;
#line 45
      pos ++;
#line 45
      *(ret + tmp___2) = (char )(192 | (int )((int const   )*c >> 6));
#line 46
      tmp___3 = pos;
#line 46
      pos ++;
#line 46
      *(ret + tmp___3) = (char )(128 | (int )((int const   )*c & 63));
    } else {
#line 52
      tmp___4 = pos;
#line 52
      pos ++;
#line 52
      *(ret + tmp___4) = (char )(224 | (int )((int const   )*c >> 12));
#line 53
      tmp___5 = pos;
#line 53
      pos ++;
#line 53
      *(ret + tmp___5) = (char )(128 | (int )(((int const   )*c >> 6) & 63));
#line 54
      tmp___6 = pos;
#line 54
      pos ++;
#line 54
      *(ret + tmp___6) = (char )(128 | (int )((int const   )*c & 63));
    }
#line 27
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  *(ret + pos) = (char)0;
#line 59
  return (ret);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/unicode.c"
ntfs_char *unicode_transcode8to16(char const   *src , ntfs_char *out , size_t len ) 
{ 
  size_t pos ;
  char const   *c ;
  char const   *e ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 72
  pos = (size_t )0;
#line 76
  c = src;
#line 77
  e = c + len;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )c < (unsigned long )e)) {
#line 79
      goto while_break;
    }
#line 86
    if ((unsigned long )(c + 3) < (unsigned long )e) {
#line 86
      if (((int const   )*(c + 0) & 248) == 240) {
#line 86
        if (((int const   )*(c + 1) & 192) == 128) {
#line 86
          if (((int const   )*(c + 2) & 192) == 128) {
#line 86
            if (((int const   )*(c + 3) & 192) == 128) {
#line 92
              tmp = pos;
#line 92
              pos ++;
#line 92
              *(out + tmp) = (ntfs_char )((((((int )((ntfs_char )*(c + 0)) & 7) << 18) | (((int )((ntfs_char )*(c + 1)) & 63) << 12)) | (((int )((ntfs_char )*(c + 2)) & 63) << 6)) | ((int )((ntfs_char )*(c + 3)) & 63));
#line 96
              c += 3;
            } else {
#line 86
              goto _L___7;
            }
          } else {
#line 86
            goto _L___7;
          }
        } else {
#line 86
          goto _L___7;
        }
      } else {
#line 86
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 100
    if ((unsigned long )(c + 2) < (unsigned long )e) {
#line 100
      if (((int const   )*(c + 0) & 240) == 224) {
#line 100
        if (((int const   )*(c + 1) & 192) == 128) {
#line 100
          if (((int const   )*(c + 2) & 192) == 128) {
#line 105
            tmp___0 = pos;
#line 105
            pos ++;
#line 105
            *(out + tmp___0) = (ntfs_char )(((((int )((ntfs_char )*(c + 0)) & 15) << 12) | (((int )((ntfs_char )*(c + 1)) & 63) << 6)) | ((int )((ntfs_char )*(c + 2)) & 63));
#line 108
            c += 2;
          } else {
#line 100
            goto _L___3;
          }
        } else {
#line 100
          goto _L___3;
        }
      } else {
#line 100
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 112
    if ((unsigned long )(c + 1) < (unsigned long )e) {
#line 112
      if (((int const   )*(c + 0) & 224) == 192) {
#line 112
        if (((int const   )*(c + 1) & 192) == 128) {
#line 116
          tmp___1 = pos;
#line 116
          pos ++;
#line 116
          *(out + tmp___1) = (ntfs_char )((((int )((ntfs_char )*(c + 0)) & 31) << 6) | ((int )((ntfs_char )*(c + 1)) & 63));
#line 118
          c ++;
        } else {
#line 112
          goto _L___0;
        }
      } else {
#line 112
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 122
    if (! ((int const   )*(c + 0) & 128)) {
#line 124
      tmp___2 = pos;
#line 124
      pos ++;
#line 124
      *(out + tmp___2) = (ntfs_char )*(c + 0);
    } else {
#line 130
      tmp___3 = pos;
#line 130
      pos ++;
#line 130
      *(out + tmp___3) = (ntfs_char )63;
    }
#line 79
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  *(out + pos) = (ntfs_char )0;
#line 135
  return (out);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/memref.h"
void *_refalloc(size_t sz ) ;
#line 36
void *_refadd(void *buf ) ;
#line 37
void _refrelease(void *buf ) ;
#line 199 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
ntfs_attribheader *ntfs_findattribute(ntfs_recordheader *record , uint32 attrType ,
                                      byte *end ) ;
#line 200
ntfs_attribheader *ntfs_nextattribute(ntfs_attribheader *attrib , uint32 attrType ,
                                      byte *end ) ;
#line 205
bool ntfs_dofixups(byte *cluster , uint32 size ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.h"
ntfsx_datarun *ntfsx_datarun_alloc(byte *mem , byte *datarun ) ;
#line 41
void ntfsx_datarun_free(ntfsx_datarun *dr ) ;
#line 42
bool ntfsx_datarun_first(ntfsx_datarun *dr ) ;
#line 43
bool ntfsx_datarun_next(ntfsx_datarun *dr ) ;
#line 55
void ntfsx_cluster_reserve(ntfsx_cluster *clus , partitioninfo *info ) ;
#line 56
bool ntfsx_cluster_read(ntfsx_cluster *clus , partitioninfo *info , uint64 begSector ,
                        int dd ) ;
#line 57
void ntfsx_cluster_release(ntfsx_cluster *clus ) ;
#line 70
ntfsx_attribute *ntfsx_attribute_alloc(ntfsx_cluster *clus , ntfs_attribheader *header ) ;
#line 71
void ntfsx_attribute_free(ntfsx_attribute *attr ) ;
#line 72
ntfs_attribheader *ntfsx_attribute_header(ntfsx_attribute *attr ) ;
#line 73
void *ntfsx_attribute_getresidentdata(ntfsx_attribute *attr ) ;
#line 74
uint32 ntfsx_attribute_getresidentsize(ntfsx_attribute *attr ) ;
#line 75
ntfsx_datarun *ntfsx_attribute_getdatarun(ntfsx_attribute *attr ) ;
#line 87
ntfsx_record *ntfsx_record_alloc(partitioninfo *info ) ;
#line 88
ntfsx_cluster *ntfsx_record_cluster(ntfsx_record *record ) ;
#line 89
void ntfsx_record_free(ntfsx_record *record ) ;
#line 90
bool ntfsx_record_read(ntfsx_record *record , uint64 begSector , int dd ) ;
#line 91
bool ntfsx_record_validate(ntfsx_record *record ) ;
#line 92
ntfs_recordheader *ntfsx_record_header(ntfsx_record *record ) ;
#line 93
ntfsx_attribute *ntfsx_record_findattribute(ntfsx_record *record , uint32 attrType ,
                                            int dd ) ;
#line 106
ntfsx_attrib_enum *ntfsx_attrib_enum_alloc(uint32 type , bool normal ) ;
#line 107
ntfsx_attribute *ntfsx_attrib_enum_all(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) ;
#line 108
ntfsx_attribute *ntfsx_attrib_enum_inline(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) ;
#line 109
ntfsx_attribute *ntfsx_attrib_enum_list(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) ;
#line 110
void ntfsx_attrib_enum_free(ntfsx_attrib_enum *attrenum ) ;
#line 124
void ntfsx_mftmap_init(ntfsx_mftmap *map , partitioninfo *info ) ;
#line 125
void ntfsx_mftmap_destroy(ntfsx_mftmap *map ) ;
#line 126
bool ntfsx_mftmap_load(ntfsx_mftmap *map , ntfsx_record *record , int dd ) ;
#line 127
uint64 ntfsx_mftmap_length(ntfsx_mftmap *map ) ;
#line 128
uint64 ntfsx_mftmap_sectorforindex(ntfsx_mftmap *map , uint64 index___0 ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_datarun *ntfsx_datarun_alloc(byte *mem , byte *datarun ) 
{ 
  ntfsx_datarun *dr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 27
  tmp = mallocf(sizeof(ntfsx_datarun ));
#line 27
  dr = (ntfsx_datarun *)tmp;
#line 30
  tmp___0 = _refadd((void *)mem);
#line 30
  dr->_mem = (byte *)tmp___0;
#line 31
  dr->_datarun = datarun;
#line 32
  dr->_curpos = (byte *)((void *)0);
#line 34
  dr->cluster = (uint64 )0;
#line 35
  dr->length = (uint64 )0;
#line 36
  dr->sparse = (bool )0;
  }
#line 38
  return (dr);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_datarun_free(ntfsx_datarun *dr ) 
{ 


  {
#line 43
  if (dr->_mem) {
    {
#line 45
    _refrelease((void *)dr->_mem);
#line 46
    dr->_mem = (byte *)((void *)0);
    }
  }
  {
#line 49
  free((void *)dr);
  }
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_datarun_first(ntfsx_datarun *dr ) 
{ 
  bool tmp ;

  {
  {
#line 54
  dr->_curpos = dr->_datarun;
#line 55
  dr->cluster = (uint64 )0;
#line 56
  dr->length = (uint64 )0;
#line 57
  dr->sparse = (bool )0;
#line 58
  tmp = ntfsx_datarun_next(dr);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_datarun_next(ntfsx_datarun *dr ) 
{ 
  byte length ;
  byte roffset ;
  int64 offset ;

  {
#line 69
  if (! *(dr->_curpos)) {
#line 70
    return ((bool )0);
  }
#line 72
  length = (byte )((int )*(dr->_curpos) & 15);
#line 73
  roffset = (byte )((int )*(dr->_curpos) >> 4);
#line 76
  if ((int )length == 0) {
#line 77
    return ((bool )0);
  } else
#line 76
  if ((int )length > 8) {
#line 77
    return ((bool )0);
  } else
#line 76
  if ((int )roffset > 8) {
#line 77
    return ((bool )0);
  }
  {
#line 82
  (dr->_curpos) ++;
#line 84
  memset((void *)(& dr->length), 0, sizeof(uint64 ));
#line 86
  memcpy((void */* __restrict  */)(& dr->length), (void const   */* __restrict  */)dr->_curpos,
         (size_t )length);
#line 87
  dr->_curpos += (int )length;
  }
#line 91
  if ((int )*(dr->_curpos + ((int )roffset - 1)) & 128) {
    {
#line 92
    memset((void *)(& offset), ~ 0, sizeof(int64 ));
    }
  } else {
    {
#line 94
    memset((void *)(& offset), 0, sizeof(int64 ));
    }
  }
  {
#line 96
  memcpy((void */* __restrict  */)(& offset), (void const   */* __restrict  */)dr->_curpos,
         (size_t )roffset);
#line 97
  dr->_curpos += (int )roffset;
  }
#line 99
  if (offset == 0L) {
#line 101
    dr->sparse = (bool )1;
  } else {
#line 105
    dr->sparse = (bool )0;
#line 106
    dr->cluster += (uint64 )offset;
  }
#line 109
  return ((bool )1);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_cluster_reserve(ntfsx_cluster *clus , partitioninfo *info ) 
{ 
  void *tmp ;

  {
  {
#line 119
  ntfsx_cluster_release(clus);
#line 120
  clus->size = (uint32 )((int )info->cluster * 512);
#line 123
  tmp = _refalloc((size_t )clus->size);
#line 123
  clus->data = (byte *)tmp;
  }
#line 124
  return;
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_cluster_read(ntfsx_cluster *clus , partitioninfo *info , uint64 begSector ,
                        int dd ) 
{ 
  int64 pos ;
  size_t sz ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
#line 131
  if (! clus->data) {
    {
#line 132
    ntfsx_cluster_reserve(clus, info);
    }
  }
  {
#line 134
  pos = (int64 )(begSector * 512UL);
#line 135
  tmp = lseek64(dd, pos, 0);
  }
#line 135
  if (tmp == -1) {
#line 136
    return ((bool )0);
  }
  {
#line 138
  tmp___0 = read(dd, (void *)clus->data, (size_t )clus->size);
#line 138
  sz = (size_t )tmp___0;
  }
#line 139
  if (sz == 0xffffffffffffffffUL) {
#line 140
    return ((bool )0);
  }
#line 142
  if (sz != (size_t )clus->size) {
    {
#line 144
    tmp___1 = __errno_location();
#line 144
    *tmp___1 = 34;
    }
#line 145
    return ((bool )0);
  }
#line 148
  return ((bool )1);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_cluster_release(ntfsx_cluster *clus ) 
{ 


  {
#line 153
  if (clus->data) {
    {
#line 154
    _refrelease((void *)clus->data);
    }
  }
#line 156
  clus->data = (byte *)((void *)0);
#line 157
  clus->size = (uint32 )0;
#line 158
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attribute *ntfsx_attribute_alloc(ntfsx_cluster *clus , ntfs_attribheader *header ) 
{ 
  ntfsx_attribute *attr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 165
  tmp = mallocf(sizeof(ntfsx_attribute ));
#line 165
  attr = (ntfsx_attribute *)tmp;
#line 166
  attr->_header = header;
#line 167
  tmp___0 = _refadd((void *)clus->data);
#line 167
  attr->_mem = (byte *)tmp___0;
#line 168
  attr->_length = clus->size;
  }
#line 169
  return (attr);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_attribute_free(ntfsx_attribute *attr ) 
{ 


  {
#line 174
  if (attr->_mem) {
    {
#line 176
    _refrelease((void *)attr->_mem);
#line 177
    attr->_mem = (byte *)((void *)0);
    }
  }
  {
#line 180
  free((void *)attr);
  }
#line 181
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfs_attribheader *ntfsx_attribute_header(ntfsx_attribute *attr ) 
{ 


  {
#line 185
  return (attr->_header);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void *ntfsx_attribute_getresidentdata(ntfsx_attribute *attr ) 
{ 
  ntfs_attribresident *res ;

  {
#line 190
  res = (ntfs_attribresident *)attr->_header;
#line 192
  return ((void *)((byte *)attr->_header + (int )res->offAttribData));
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
uint32 ntfsx_attribute_getresidentsize(ntfsx_attribute *attr ) 
{ 
  ntfs_attribresident *res ;

  {
#line 197
  res = (ntfs_attribresident *)attr->_header;
#line 199
  return (res->cbAttribData);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_datarun *ntfsx_attribute_getdatarun(ntfsx_attribute *attr ) 
{ 
  ntfs_attribnonresident *nonres ;
  ntfsx_datarun *tmp ;

  {
  {
#line 204
  nonres = (ntfs_attribnonresident *)attr->_header;
#line 206
  tmp = ntfsx_datarun_alloc(attr->_mem, (byte *)attr->_header + (int )nonres->offDataRuns);
  }
#line 206
  return (tmp);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_attribute_next(ntfsx_attribute *attr , uint32 attrType ) 
{ 
  ntfs_attribheader *header ;
  ntfs_attribheader *tmp ;

  {
  {
#line 211
  tmp = ntfs_nextattribute(attr->_header, attrType, attr->_mem + attr->_length);
#line 211
  header = tmp;
  }
#line 213
  if (header) {
#line 215
    attr->_header = header;
#line 216
    return ((bool )1);
  }
#line 219
  return ((bool )0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attrib_enum *ntfsx_attrib_enum_alloc(uint32 type , bool normal ) 
{ 
  ntfsx_attrib_enum *attrenum ;
  void *tmp ;

  {
  {
#line 231
  tmp = mallocf(sizeof(ntfsx_attrib_enum ));
#line 231
  attrenum = (ntfsx_attrib_enum *)tmp;
#line 232
  attrenum->type = type;
#line 233
  attrenum->_attrhead = (ntfs_attribheader *)((void *)0);
#line 234
  attrenum->_listrec = (ntfs_attriblistrecord *)((void *)0);
  }
#line 235
  if (normal) {
#line 235
    attrenum->_flags = (unsigned char )(1 << 1);
  } else {
#line 235
    attrenum->_flags = (unsigned char)0;
  }
#line 236
  return (attrenum);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attribute *ntfsx_attrib_enum_inline(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) 
{ 
  ntfsx_attribute *attr ;
  ntfsx_cluster *cluster ;
  ntfs_recordheader *rechead ;

  {
#line 246
  if ((int )attrenum->_flags & (1 << 2)) {
#line 247
    return ((ntfsx_attribute *)((void *)0));
  }
  {
#line 249
  cluster = ntfsx_record_cluster(record);
#line 250
  rechead = ntfsx_record_header(record);
  }
#line 253
  if (! attrenum->_attrhead) {
#line 253
    if (! attrenum->_listrec) {
      {
#line 255
      attrenum->_attrhead = ntfs_findattribute(rechead, attrenum->type, cluster->data + cluster->size);
      }
#line 258
      if (attrenum->_attrhead) {
        {
#line 260
        attr = ntfsx_attribute_alloc(cluster, attrenum->_attrhead);
        }
#line 261
        return (attr);
      }
    }
  }
#line 268
  if (attrenum->_attrhead) {
#line 268
    if ((attrenum->_attrhead)->type == attrenum->type) {
      {
#line 270
      attrenum->_attrhead = ntfs_nextattribute(attrenum->_attrhead, attrenum->type,
                                               cluster->data + cluster->size);
      }
#line 273
      if (attrenum->_attrhead) {
        {
#line 275
        attr = ntfsx_attribute_alloc(cluster, attrenum->_attrhead);
        }
#line 276
        return (attr);
      }
    }
  }
#line 282
  attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 2));
#line 283
  return ((ntfsx_attribute *)((void *)0));
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attribute *ntfsx_attrib_enum_list(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) 
{ 
  ntfsx_cluster *cluster ;
  ntfs_recordheader *rechead ;
  ntfs_attribresident *resident ;
  ntfs_attribheader *attrhead ;
  ntfsx_attribute *attr ;
  uint64 mftRecord ;
  ntfsx_record *r2 ;
  ntfsx_cluster *c2 ;
  bool tmp ;

  {
#line 300
  if ((int )attrenum->_flags & (1 << 3)) {
#line 301
    return ((ntfsx_attribute *)((void *)0));
  }
  {
#line 303
  cluster = ntfsx_record_cluster(record);
#line 304
  rechead = ntfsx_record_header(record);
  }
#line 307
  if (! attrenum->_listrec) {
#line 307
    if (! attrenum->_attrhead) {
      {
#line 309
      attrenum->_attrhead = ntfs_findattribute(rechead, (uint32 )32, cluster->data + cluster->size);
      }
#line 313
      if (! attrenum->_attrhead) {
#line 315
        attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 3));
#line 316
        return ((ntfsx_attribute *)((void *)0));
      }
#line 320
      if ((attrenum->_attrhead)->bNonResident) {
        {
#line 322
        warnx("brain dead, incredibly fragmented file data. skipping");
#line 323
        attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 3));
        }
#line 324
        return ((ntfsx_attribute *)((void *)0));
      }
#line 328
      if (! (record->info)->mftmap) {
        {
#line 330
        warnx("extended file attributes, but no MFT loaded. skipping");
#line 331
        attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 3));
        }
#line 332
        return ((ntfsx_attribute *)((void *)0));
      }
    }
  }
#line 340
  resident = (ntfs_attribresident *)attrenum->_attrhead;
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (attrenum->_listrec) {
#line 345
      attrenum->_listrec = (ntfs_attriblistrecord *)((byte *)attrenum->_listrec + (int )(attrenum->_listrec)->cbRecord);
    } else {
#line 348
      attrenum->_listrec = (ntfs_attriblistrecord *)((byte *)resident + (int )resident->offAttribData);
    }
#line 350
    if ((unsigned long )((byte *)attrenum->_listrec) >= (unsigned long )((byte *)attrenum->_attrhead + (attrenum->_attrhead)->cbAttribute)) {
#line 352
      attrenum->_listrec = (ntfs_attriblistrecord *)((void *)0);
#line 353
      attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 3));
#line 354
      return ((ntfsx_attribute *)((void *)0));
    }
#line 357
    if ((attrenum->_listrec)->type == attrenum->type) {
      {
#line 359
      attr = (ntfsx_attribute *)((void *)0);
#line 360
      r2 = (ntfsx_record *)((void *)0);
#line 363
      mftRecord = ntfsx_mftmap_sectorforindex((record->info)->mftmap, (uint64 )((long long )(attrenum->_listrec)->refAttrib & 281474976710655LL));
      }
#line 364
      if ((unsigned long long )mftRecord == 0xffffffffffffffffULL) {
        {
#line 366
        warnx("invalid sector in mft map. screwed up file. skipping data");
        }
      } else {
        {
#line 370
        r2 = ntfsx_record_alloc(record->info);
#line 372
        tmp = ntfsx_record_read(r2, mftRecord, (record->info)->device);
        }
#line 372
        if (tmp) {
          {
#line 374
          rechead = ntfsx_record_header(r2);
#line 375
          c2 = ntfsx_record_cluster(r2);
#line 376
          attrhead = ntfs_findattribute(rechead, attrenum->type, c2->data + c2->size);
          }
#line 379
          if (attrhead) {
            {
#line 380
            attr = ntfsx_attribute_alloc(c2, attrhead);
            }
          }
        }
      }
#line 384
      if (r2) {
        {
#line 385
        ntfsx_record_free(r2);
        }
      }
#line 387
      if (attr) {
#line 388
        return (attr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attribute *ntfsx_attrib_enum_all(ntfsx_attrib_enum *attrenum , ntfsx_record *record ) 
{ 
  ntfsx_attribute *attr ;

  {
#line 398
  attr = (ntfsx_attribute *)((void *)0);
#line 407
  if ((int )attrenum->_flags & (1 << 1)) {
#line 409
    if (! ((int )attrenum->_flags & (1 << 3))) {
      {
#line 411
      attr = ntfsx_attrib_enum_list(attrenum, record);
      }
#line 413
      if (attr) {
#line 414
        attrenum->_flags = (unsigned char )((int )attrenum->_flags | (1 << 4));
      }
    }
#line 417
    if (! attr) {
#line 417
      if (! ((int )attrenum->_flags & (1 << 4))) {
#line 417
        if (! ((int )attrenum->_flags & (1 << 2))) {
          {
#line 419
          attr = ntfsx_attrib_enum_inline(attrenum, record);
          }
        }
      }
    }
  } else {
#line 428
    if (! ((int )attrenum->_flags & (1 << 2))) {
      {
#line 429
      attr = ntfsx_attrib_enum_inline(attrenum, record);
      }
    }
#line 431
    if (! attr) {
#line 431
      if (! ((int )attrenum->_flags & (1 << 3))) {
        {
#line 432
        attr = ntfsx_attrib_enum_list(attrenum, record);
        }
      }
    }
  }
#line 435
  return (attr);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_attrib_enum_free(ntfsx_attrib_enum *attrenum ) 
{ 


  {
  {
#line 440
  free((void *)attrenum);
  }
#line 441
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_record *ntfsx_record_alloc(partitioninfo *info ) 
{ 
  ntfsx_record *rec ;
  void *tmp ;

  {
  {
#line 447
  tmp = mallocf(sizeof(ntfsx_record ));
#line 447
  rec = (ntfsx_record *)tmp;
#line 448
  rec->info = info;
#line 449
  memset((void *)(& rec->_clus), 0, sizeof(ntfsx_cluster ));
  }
#line 450
  return (rec);
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_record_free(ntfsx_record *record ) 
{ 


  {
  {
#line 455
  ntfsx_cluster_release(& record->_clus);
#line 456
  free((void *)record);
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_record_read(ntfsx_record *record , uint64 begSector , int dd ) 
{ 
  ntfs_recordheader *rechead ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;

  {
  {
#line 463
  tmp = ntfsx_cluster_read(& record->_clus, record->info, begSector, dd);
  }
#line 463
  if (! tmp) {
    {
#line 465
    warn("couldn\'t read mft record from drive");
    }
#line 466
    return ((bool )0);
  }
  {
#line 470
  rechead = ntfsx_record_header(record);
  }
#line 471
  if (rechead->magic != 1162627398U) {
    {
#line 475
    warnx("invalid mft record");
#line 476
    ntfsx_cluster_release(& record->_clus);
    }
#line 477
    return ((bool )0);
  } else {
    {
#line 471
    tmp___0 = ntfsx_record_validate(record);
    }
#line 471
    if (tmp___0) {
      {
#line 471
      tmp___1 = ntfs_dofixups(record->_clus.data, record->_clus.size);
      }
#line 471
      if (! tmp___1) {
        {
#line 475
        warnx("invalid mft record");
#line 476
        ntfsx_cluster_release(& record->_clus);
        }
#line 477
        return ((bool )0);
      }
    } else {
      {
#line 475
      warnx("invalid mft record");
#line 476
      ntfsx_cluster_release(& record->_clus);
      }
#line 477
      return ((bool )0);
    }
  }
#line 480
  return ((bool )1);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_record_validate(ntfsx_record *record ) 
{ 
  ntfs_recordheader *rechead ;

  {
  {
#line 486
  rechead = ntfsx_record_header(record);
  }
#line 494
  if ((int )rechead->offUpdSeq > 512) {
#line 495
    return ((bool )0);
  }
#line 497
  return ((bool )1);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_cluster *ntfsx_record_cluster(ntfsx_record *record ) 
{ 


  {
#line 502
  return (& record->_clus);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfs_recordheader *ntfsx_record_header(ntfsx_record *record ) 
{ 


  {
#line 507
  return ((ntfs_recordheader *)record->_clus.data);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
ntfsx_attribute *ntfsx_record_findattribute(ntfsx_record *record , uint32 attrType ,
                                            int dd ) 
{ 
  ntfsx_attrib_enum *attrenum ;
  ntfsx_attribute *attr ;

  {
  {
#line 512
  attrenum = (ntfsx_attrib_enum *)((void *)0);
#line 513
  attr = (ntfsx_attribute *)((void *)0);
#line 515
  attrenum = ntfsx_attrib_enum_alloc(attrType, (bool )1);
#line 516
  attr = ntfsx_attrib_enum_all(attrenum, record);
#line 517
  ntfsx_attrib_enum_free(attrenum);
  }
#line 518
  return (attr);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_mftmap_init(ntfsx_mftmap *map , partitioninfo *info ) 
{ 


  {
#line 532
  map->info = info;
#line 533
  map->_blocks = (struct _ntfsx_mftmap_block *)((void *)0);
#line 534
  map->_count = (uint32 )0;
#line 535
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
void ntfsx_mftmap_destroy(ntfsx_mftmap *map ) 
{ 


  {
#line 539
  if (map->_blocks) {
    {
#line 541
    free((void *)map->_blocks);
#line 542
    map->_blocks = (struct _ntfsx_mftmap_block *)((void *)0);
#line 543
    map->_count = (uint32 )0;
    }
  }
#line 545
  return;
}
}
#line 547 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
static void mftmap_expand(ntfsx_mftmap *map , uint32 *allocated ) 
{ 
  void *tmp ;

  {
#line 549
  if (map->_count >= *allocated) {
    {
#line 551
    *allocated += 16U;
#line 552
    tmp = reallocf((void *)map->_blocks, (unsigned long )*allocated * sizeof(struct _ntfsx_mftmap_block ));
#line 552
    map->_blocks = (struct _ntfsx_mftmap_block *)tmp;
    }
  }
#line 555
  return;
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
bool ntfsx_mftmap_load(ntfsx_mftmap *map , ntfsx_record *record , int dd ) 
{ 
  bool ret ;
  ntfsx_attribute *attribdata ;
  ntfsx_datarun *datarun ;
  ntfsx_attrib_enum *attrenum ;
  ntfs_attribheader *header ;
  ntfs_attribnonresident *nonres ;
  uint64 length ;
  uint64 firstSector ;
  uint32 allocated ;
  uint64 total ;
  bool hasdata ;
  bool tmp ;
  bool tmp___0 ;

  {
#line 559
  ret = (bool )1;
#line 560
  attribdata = (ntfsx_attribute *)((void *)0);
#line 561
  datarun = (ntfsx_datarun *)((void *)0);
#line 562
  attrenum = (ntfsx_attrib_enum *)((void *)0);
#line 571
  hasdata = (bool )0;
#line 573
  if (map->_blocks) {
    {
#line 575
    free((void *)map->_blocks);
#line 576
    map->_blocks = (struct _ntfsx_mftmap_block *)((void *)0);
    }
  }
  {
#line 579
  map->_count = (uint32 )0;
#line 580
  allocated = (uint32 )0;
#line 581
  total = (uint64 )0;
#line 583
  attrenum = ntfsx_attrib_enum_alloc((uint32 )128, (bool )0);
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 585
    attribdata = ntfsx_attrib_enum_all(attrenum, record);
    }
#line 585
    if (! ((unsigned long )attribdata != (unsigned long )((void *)0))) {
#line 585
      goto while_break;
    }
    {
#line 587
    header = ntfsx_attribute_header(attribdata);
    }
#line 588
    if (! header->bNonResident) {
      {
#line 590
      warnx("invalid mft. data attribute non-resident");
      }
    } else {
      {
#line 594
      datarun = ntfsx_attribute_getdatarun(attribdata);
      }
#line 595
      if (! datarun) {
        {
#line 597
        warnx("invalid mft. no data runs in data attribute");
        }
      } else {
#line 601
        hasdata = (bool )1;
#line 602
        nonres = (ntfs_attribnonresident *)header;
#line 605
        if (map->_count == 0U) {
#line 606
          total = nonres->cbAllocated;
        }
        {
#line 609
        tmp___0 = ntfsx_datarun_first(datarun);
        }
#line 609
        if (tmp___0) {
          {
#line 611
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 613
            if (datarun->sparse) {
              {
#line 615
              warnx("invalid mft. sparse data runs");
              }
            } else {
              {
#line 619
              mftmap_expand(map, & allocated);
#line 623
              length = datarun->length * (uint64 )(((int )(map->info)->cluster * 512) / 1024);
              }
#line 624
              if (length == 0UL) {
#line 625
                goto __Cont;
              }
#line 627
              firstSector = datarun->cluster * (uint64 )(map->info)->cluster + (uint64 )(map->info)->first;
#line 628
              if (firstSector >= (uint64 )(map->info)->end) {
#line 629
                goto __Cont;
              }
#line 636
              if (map->_count > 0U) {
#line 636
                if ((map->_blocks + (map->_count - 1U))->length == length) {
#line 636
                  if ((map->_blocks + (map->_count - 1U))->firstSector == firstSector) {
#line 638
                    goto __Cont;
                  }
                }
              }
#line 640
              (map->_blocks + map->_count)->length = length;
#line 641
              (map->_blocks + map->_count)->firstSector = firstSector;
#line 642
              (map->_count) ++;
#line 644
              total -= length * 512UL;
            }
            __Cont: /* CIL Label */ 
            {
#line 611
            tmp = ntfsx_datarun_next(datarun);
            }
#line 611
            if (! tmp) {
#line 611
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 650
        ntfsx_datarun_free(datarun);
#line 651
        datarun = (ntfsx_datarun *)((void *)0);
        }
      }
    }
    {
#line 655
    ntfsx_attribute_free(attribdata);
#line 656
    attribdata = (ntfsx_attribute *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  if (! hasdata) {
    {
#line 660
    ret = (bool )0;
#line 660
    warnx("invalid mft. no data attribute");
    }
#line 660
    goto cleanup;
  }
#line 662
  ret = (bool )1;
  cleanup: 
#line 667
  if (attribdata) {
    {
#line 668
    ntfsx_attribute_free(attribdata);
    }
  }
#line 669
  if (datarun) {
    {
#line 670
    ntfsx_datarun_free(datarun);
    }
  }
#line 671
  if (attrenum) {
    {
#line 672
    ntfsx_attrib_enum_free(attrenum);
    }
  }
#line 674
  return (ret);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
uint64 ntfsx_mftmap_length(ntfsx_mftmap *map ) 
{ 
  uint64 length ;
  uint32 i ;

  {
#line 679
  length = (uint64 )0;
#line 682
  i = (uint32 )0;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! (i < map->_count)) {
#line 682
      goto while_break;
    }
#line 683
    length += (map->_blocks + i)->length;
#line 682
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  return (length);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfsx.c"
uint64 ntfsx_mftmap_sectorforindex(ntfsx_mftmap *map , uint64 index___0 ) 
{ 
  uint32 i ;
  struct _ntfsx_mftmap_block *p ;
  uint64 sector ;

  {
#line 694
  i = (uint32 )0;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! (i < map->_count)) {
#line 694
      goto while_break;
    }
#line 696
    p = map->_blocks + i;
#line 698
    if (index___0 >= p->length) {
#line 700
      index___0 -= p->length;
    } else {
#line 704
      sector = index___0 * 2UL;
#line 705
      sector += p->firstSector;
#line 707
      if (sector >= (uint64 )(map->info)->end) {
#line 708
        return ((uint64 )0xffffffffffffffffULL);
      }
#line 710
      return (sector);
    }
#line 694
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return ((uint64 )0xffffffffffffffffULL);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.h"
byte *ntfs_getattributeheaders(ntfs_recordheader *record ) ;
#line 202
byte *ntfs_getattributedata(ntfs_attribresident *attrib , byte *end ) ;
#line 204
bool ntfs_isbetternamespace(byte n1 , byte n2 ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
ntfs_attribheader *ntfs_searchattribute(byte *location , uint32 attrType , byte *end ,
                                        bool skip ) 
{ 
  ntfs_attribheader *attrib ;

  {
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! end) {
#line 30
      goto _L;
    } else
#line 30
    if ((unsigned long )(location + sizeof(ntfs_attribheader )) < (unsigned long )end) {
      _L: /* CIL Label */ 
#line 30
      if (! (*((uint32 *)location) != 4294967295U)) {
#line 30
        goto while_break;
      }
    } else {
#line 30
      goto while_break;
    }
#line 33
    attrib = (ntfs_attribheader *)location;
#line 35
    if (! skip) {
#line 37
      if (attrib->type == attrType) {
#line 38
        return (attrib);
      }
    } else {
#line 41
      skip = (bool )0;
    }
#line 43
    location += attrib->cbAttribute;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return ((ntfs_attribheader *)((void *)0));
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
byte *ntfs_getattributeheaders(ntfs_recordheader *record ) 
{ 
  byte *location ;

  {
#line 51
  location = (byte *)record;
#line 54
  location += (int )record->offAttrs;
#line 55
  return (location);
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
ntfs_attribheader *ntfs_findattribute(ntfs_recordheader *record , uint32 attrType ,
                                      byte *end ) 
{ 
  byte *location ;
  byte *tmp ;
  ntfs_attribheader *tmp___0 ;

  {
  {
#line 60
  tmp = ntfs_getattributeheaders(record);
#line 60
  location = tmp;
#line 61
  tmp___0 = ntfs_searchattribute(location, attrType, end, (bool )0);
  }
#line 61
  return (tmp___0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
ntfs_attribheader *ntfs_nextattribute(ntfs_attribheader *attrib , uint32 attrType ,
                                      byte *end ) 
{ 
  ntfs_attribheader *tmp ;

  {
  {
#line 66
  tmp = ntfs_searchattribute((byte *)attrib, attrType, end, (bool )1);
  }
#line 66
  return (tmp);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
byte *ntfs_getattributedata(ntfs_attribresident *attrib , byte *end ) 
{ 
  byte *data ;

  {
#line 71
  data = (byte *)attrib + (int )attrib->offAttribData;
#line 72
  if ((unsigned long )data > (unsigned long )end) {
#line 73
    return ((byte *)((void *)0));
  }
#line 75
  return (data);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
bool ntfs_isbetternamespace(byte n1 , byte n2 ) 
{ 


  {
#line 88
  if ((int )n1 == 0) {
#line 89
    return ((bool )1);
  }
#line 90
  if ((int )n1 == 2) {
#line 90
    if ((int )n2 == 1) {
#line 92
      return ((bool )1);
    } else
#line 90
    if ((int )n2 == 3) {
#line 92
      return ((bool )1);
    }
  }
#line 93
  if ((int )n1 == 3) {
#line 93
    if ((int )n2 == 1) {
#line 95
      return ((bool )1);
    }
  }
#line 97
  return ((bool )0);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/ntfs.c"
bool ntfs_dofixups(byte *cluster , uint32 size ) 
{ 
  ntfs_recordheader *record ;
  byte numSectors ;
  uint16 *updSeq ;
  uint16 *sectorFooter ;
  byte i ;

  {
#line 102
  record = (ntfs_recordheader *)cluster;
#line 109
  numSectors = (byte )(size / 512U);
#line 112
  if ((int )record->cwUpdSeq - 1 < (int )numSectors) {
#line 113
    numSectors = (byte )((int )record->cwUpdSeq - 1);
  }
#line 115
  updSeq = (uint16 *)(cluster + (int )record->offUpdSeq);
#line 117
  i = (byte )0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((int )i < (int )numSectors)) {
#line 117
      goto while_break;
    }
#line 123
    sectorFooter = (uint16 *)((cluster + 510) + (int )i * 512);
#line 124
    if ((int )*sectorFooter == (int )*(updSeq + 0)) {
#line 125
      *sectorFooter = *(updSeq + ((int )i + 1));
    } else {
#line 127
      return ((bool )0);
    }
#line 117
    i = (byte )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((bool )1);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/locks.h"
void addLocationLock(drivelocks *locks , uint64 beg , uint64 end ) ;
#line 35
bool checkLocationLock(drivelocks *locks , uint64 sec ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
void addLocationLock(drivelocks *locks , uint64 beg , uint64 end ) 
{ 
  uint32 i ;
  void *tmp ;

  {
#line 37
  if (locks->_count <= locks->_current) {
    {
#line 39
    locks->_count += 1024U;
#line 40
    tmp = reallocf((void *)locks->_locks, sizeof(struct drivelock ) * (unsigned long )locks->_count);
#line 40
    locks->_locks = (struct drivelock *)tmp;
    }
  }
#line 44
  if (locks->_locks) {
#line 47
    i = (uint32 )0;
    {
#line 47
    while (1) {
      while_continue: /* CIL Label */ ;
#line 47
      if (! (i < locks->_current)) {
#line 47
        goto while_break;
      }
#line 49
      if ((locks->_locks + i)->beg < end) {
#line 49
        if ((locks->_locks + i)->end > beg) {
#line 51
          if ((locks->_locks + i)->beg < beg) {
#line 51
            (locks->_locks + i)->beg = (locks->_locks + i)->beg;
          } else {
#line 51
            (locks->_locks + i)->beg = beg;
          }
#line 52
          if ((locks->_locks + i)->end > end) {
#line 52
            (locks->_locks + i)->end = (locks->_locks + i)->end;
          } else {
#line 52
            (locks->_locks + i)->end = end;
          }
#line 53
          return;
        }
      }
#line 47
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    (locks->_locks + locks->_current)->beg = beg;
#line 58
    (locks->_locks + locks->_current)->end = end;
#line 59
    (locks->_current) ++;
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
bool checkLocationLock(drivelocks *locks , uint64 sec ) 
{ 
  uint32 i ;

  {
#line 67
  if (locks->_locks) {
#line 70
    i = (uint32 )0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < locks->_current)) {
#line 70
        goto while_break;
      }
#line 72
      if (sec >= (locks->_locks + i)->beg) {
#line 72
        if (sec < (locks->_locks + i)->end) {
#line 75
          sec = (locks->_locks + i)->end;
#line 76
          return ((bool )1);
        }
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 81
  return ((bool )0);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
void *_refalloc(size_t sz ) 
{ 
  size_t *mem ;
  void *tmp ;

  {
  {
#line 126
  tmp = mallocf(sz * sizeof(size_t ));
#line 126
  mem = (size_t *)tmp;
  }
#line 128
  if (mem) {
#line 130
    *(mem + 0) = (size_t )1;
#line 131
    return ((void *)(mem + 1));
  }
#line 134
  return ((void *)mem);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
void *_refadd(void *buf ) 
{ 


  {
#line 154
  if (buf) {
#line 156
    (*((size_t *)buf + -1)) ++;
  }
#line 158
  return (buf);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
void _refrelease(void *buf ) 
{ 
  size_t *mem ;

  {
#line 178
  if (buf) {
#line 181
    mem = (size_t *)buf - 1;
#line 183
    (*(mem + 0)) --;
#line 183
    if (! *(mem + 0)) {
      {
#line 184
      free((void *)mem);
      }
    }
  }
#line 186
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/misc.c"
int compareFileData(int f , void *data , size_t length ) 
{ 
  unsigned char buf[4096] ;
  unsigned char *d ;
  int num ;
  int r ;
  ssize_t tmp ;

  {
#line 193
  d = (unsigned char *)data;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (length > 0UL)) {
#line 196
      goto while_break;
    }
#line 198
    if (4096UL < length) {
#line 198
      num = 4096;
    } else {
#line 198
      num = (int )length;
    }
    {
#line 199
    tmp = read(f, (void *)(buf), (size_t )num);
#line 199
    r = (int )tmp;
    }
#line 201
    if (r < 0) {
      {
#line 202
      err(1, "error reading comparison file");
      }
    }
#line 204
    if (r < num) {
#line 205
      return (-1);
    }
    {
#line 207
    r = memcmp((void const   *)d, (void const   *)(buf), (size_t )num);
    }
#line 208
    if (r != 0) {
#line 209
      return (r);
    }
#line 211
    d += num;
#line 212
    length -= (size_t )num;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
void processRecordFileBasics(partitioninfo *pi , ntfsx_record *record , filebasics *basics ) 
{ 
  ntfsx_attribute *attr ;
  ntfsx_attrib_enum *attrenum ;
  byte *resident ;
  ntfs_attribfilename *filename ;
  byte nameSpace ;
  ntfs_char *name ;
  size_t len ;
  char *temp ;
  void *tmp ;
  bool tmp___0 ;
  ntfs_attribheader *tmp___1 ;

  {
  {
#line 44
  attr = (ntfsx_attribute *)((void *)0);
#line 45
  attrenum = (ntfsx_attrib_enum *)((void *)0);
#line 48
  resident = (byte *)((void *)0);
#line 58
  memset((void *)basics, 0, sizeof(filebasics ));
#line 59
  basics->parent = (uint64 )0xffffffffffffffffULL;
#line 62
  attrenum = ntfsx_attrib_enum_alloc((uint32 )48, (bool )1);
#line 64
  nameSpace = (byte )0;
#line 65
  memset((void *)(basics->filename), 0, sizeof(basics->filename));
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    attr = ntfsx_attrib_enum_all(attrenum, record);
    }
#line 67
    if (! ((unsigned long )attr != (unsigned long )((void *)0))) {
#line 67
      goto while_break;
    }
    {
#line 70
    tmp___1 = ntfsx_attribute_header(attr);
    }
#line 70
    if (! tmp___1->bNonResident) {
      {
#line 73
      tmp = ntfsx_attribute_getresidentdata(attr);
#line 73
      filename = (ntfs_attribfilename *)tmp;
#line 80
      tmp___0 = ntfs_isbetternamespace(nameSpace, filename->nameSpace);
      }
#line 80
      if (tmp___0) {
#line 83
        basics->created = filename->timeCreated;
#line 84
        basics->modified = filename->timeModified;
#line 85
        basics->accessed = filename->timeRead;
#line 88
        name = (ntfs_char *)((byte *)filename + sizeof(ntfs_attribfilename ));
#line 89
        len = (size_t )filename->cFileName;
#line 90
        if (len > 256UL) {
#line 91
          len = (size_t )256;
        }
        {
#line 96
        temp = unicode_transcode16to8((ntfs_char const   *)name, len);
#line 98
        len = strlen((char const   *)temp);
        }
#line 99
        if (len > 256UL) {
#line 100
          len = (size_t )256;
        }
        {
#line 102
        strncpy((char */* __restrict  */)(basics->filename), (char const   */* __restrict  */)temp,
                len);
#line 105
        basics->filename[len] = (fchar_t )0;
#line 109
        basics->flags = filename->flags;
#line 113
        basics->parent = (uint64 )((long long )filename->refParent & 281474976710655LL);
#line 117
        nameSpace = filename->nameSpace;
        }
      }
    }
    {
#line 121
    ntfsx_attribute_free(attr);
#line 122
    attr = (ntfsx_attribute *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if (attr) {
    {
#line 127
    ntfsx_attribute_free(attr);
    }
  }
#line 129
  if (attrenum) {
    {
#line 130
    ntfsx_attrib_enum_free(attrenum);
    }
  }
#line 131
  return;
}
}
#line 221
extern int ( /* missing proto */  mkdir)() ;
#line 133 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
void processMFTRecord(partitioninfo *pi , uint64 sector , uint32 flags ) 
{ 
  ntfsx_record *record ;
  ntfsx_attribute *attribdata ;
  ntfsx_attrib_enum *attrenum ;
  ntfsx_datarun *datarun ;
  int ofile ;
  ntfsx_cluster cluster ;
  filebasics basics ;
  ntfs_recordheader *header ;
  uint64 parentSector ;
  uint64 dataSector ;
  uint16 rename___0 ;
  uint64 dataSize ;
  uint64 sparseSize ;
  uint32 i ;
  bool haddata ;
  uint32 num ;
  fchar_t filename2[257] ;
  ntfs_attribheader *attrhead ;
  ntfs_attribnonresident *nonres ;
  bool tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int *tmp___6 ;
  uint32 tmp___7 ;
  uint32 length ;
  uint32 tmp___8 ;
  byte *data ;
  void *tmp___9 ;
  ssize_t tmp___10 ;
  ssize_t tmp___11 ;
  bool tmp___12 ;
  ssize_t tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  ssize_t tmp___16 ;

  {
  {
#line 135
  record = (ntfsx_record *)((void *)0);
#line 136
  attribdata = (ntfsx_attribute *)((void *)0);
#line 137
  attrenum = (ntfsx_attrib_enum *)((void *)0);
#line 138
  datarun = (ntfsx_datarun *)((void *)0);
#line 139
  ofile = -1;
#line 142
  memset((void *)(& cluster), 0, sizeof(cluster));
#line 149
  rename___0 = (uint16 )0;
#line 150
  dataSize = (uint64 )0;
#line 151
  sparseSize = (uint64 )0;
#line 153
  haddata = (bool )0;
#line 161
  record = ntfsx_record_alloc(pi);
#line 164
  tmp = ntfsx_record_read(record, sector, pi->device);
  }
#line 164
  if (! tmp) {
#line 165
    goto cleanup;
  }
  {
#line 167
  header = ntfsx_record_header(record);
  }
#line 170
  if (! ((int )header->flags & 1)) {
#line 171
    goto cleanup;
  }
  {
#line 174
  processRecordFileBasics(pi, record, & basics);
  }
#line 177
  if ((int )basics.filename[0] == 0) {
#line 178
    goto cleanup;
  }
  {
#line 181
  tmp___0 = strcmp((char const   *)(basics.filename), ".");
  }
#line 181
  if (! tmp___0) {
#line 182
    goto cleanup;
  }
#line 185
  if (basics.flags & 4U) {
#line 185
    if (basics.flags & 2U) {
#line 185
      if ((int )basics.filename[0] == 36) {
#line 188
        goto cleanup;
      }
    }
  }
#line 191
  if ((unsigned long long )basics.parent != 0xffffffffffffffffULL) {
#line 194
    if (pi->mftmap) {
      {
#line 196
      parentSector = ntfsx_mftmap_sectorforindex(pi->mftmap, basics.parent);
      }
#line 198
      if ((unsigned long long )parentSector == 0xffffffffffffffffULL) {
        {
#line 199
        warnx("invalid parent directory for file: %s", basics.filename);
        }
      } else {
        {
#line 201
        processMFTRecord(pi, parentSector, flags | (unsigned int )(1 << 1));
        }
      }
    }
  }
#line 205
  if (flags & (unsigned int )(1 << 1)) {
#line 205
    tmp___1 = "\\%s";
  } else {
#line 205
    tmp___1 = "\\%s\n";
  }
  {
#line 205
  printf((char const   */* __restrict  */)tmp___1, basics.filename);
  }
#line 209
  if ((int )header->flags & 2) {
    {
#line 212
    tmp___3 = chdir((char const   *)(basics.filename));
    }
#line 212
    if (tmp___3 == -1) {
      {
#line 221
      tmp___2 = mkdir(basics.filename, 448);
      }
#line 221
      if (tmp___2 == -1) {
        {
#line 224
        warn("couldn\'t create directory \'%s\' putting files in parent directory",
             basics.filename);
        }
      } else {
        {
#line 228
        setFileAttributes(basics.filename, basics.flags);
#line 229
        chdir((char const   *)(basics.filename));
        }
      }
    }
#line 234
    goto cleanup;
  }
  {
#line 254
  ofile = open((char const   *)(basics.filename), 193, 384);
#line 256
  strncpy((char */* __restrict  */)(filename2), (char const   */* __restrict  */)(basics.filename),
          (size_t )256);
#line 257
  filename2[256] = (fchar_t )0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (ofile == -1) {
      {
#line 259
      tmp___6 = __errno_location();
      }
#line 259
      if (*tmp___6 == 17) {
#line 259
        if (! ((int )rename___0 < 4096)) {
#line 259
          goto while_break;
        }
      } else {
#line 259
        goto while_break;
      }
    } else {
#line 259
      goto while_break;
    }
    {
#line 261
    tmp___4 = strlen((char const   *)(basics.filename));
    }
#line 261
    if (tmp___4 + 7UL >= 256UL) {
      {
#line 263
      warnx("file name too long on duplicate file: %s", basics.filename);
      }
#line 264
      goto cleanup;
    }
    {
#line 267
    strcpy((char */* __restrict  */)(basics.filename), (char const   */* __restrict  */)(filename2));
#line 268
    strcat((char */* __restrict  */)(basics.filename), (char const   */* __restrict  */)".");
#line 270
    tmp___5 = strlen((char const   *)(basics.filename));
#line 270
    itoa((int )rename___0, basics.filename + tmp___5, 10);
#line 271
    rename___0 = (uint16 )((int )rename___0 + 1);
#line 273
    ofile = open((char const   *)(basics.filename), 193, 384);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (ofile == -1) {
    {
#line 278
    warn("couldn\'t open output file: %s", basics.filename);
    }
#line 279
    goto cleanup;
  }
  {
#line 283
  attrenum = ntfsx_attrib_enum_alloc((uint32 )128, (bool )1);
  }
  {
#line 285
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 285
    attribdata = ntfsx_attrib_enum_all(attrenum, record);
    }
#line 285
    if (! ((unsigned long )attribdata != (unsigned long )((void *)0))) {
#line 285
      goto while_break___0;
    }
    {
#line 287
    attrhead = ntfsx_attribute_header(attribdata);
    }
#line 293
    if ((int )attrhead->flags & 1) {
      {
#line 294
      warnx("compressed file. skipping.");
      }
#line 294
      goto cleanup;
    }
#line 296
    if ((int )attrhead->flags & 2) {
      {
#line 297
      warnx("encrypted file. skipping.");
      }
#line 297
      goto cleanup;
    }
#line 300
    if (! haddata) {
#line 302
      if (attrhead->bNonResident) {
#line 304
        nonres = (ntfs_attribnonresident *)attrhead;
#line 306
        if (nonres->cbInitData > nonres->cbAttribData) {
          {
#line 307
          warnx("invalid file length.");
          }
#line 307
          goto cleanup;
        }
#line 309
        dataSize = nonres->cbInitData;
#line 310
        sparseSize = nonres->cbAttribData - nonres->cbInitData;
      } else {
        {
#line 314
        tmp___7 = ntfsx_attribute_getresidentsize(attribdata);
#line 314
        dataSize = (uint64 )tmp___7;
#line 315
        sparseSize = (uint64 )0;
        }
      }
    }
#line 319
    haddata = (bool )1;
#line 322
    if (! attrhead->bNonResident) {
      {
#line 324
      tmp___8 = ntfsx_attribute_getresidentsize(attribdata);
#line 324
      length = tmp___8;
#line 325
      tmp___9 = ntfsx_attribute_getresidentdata(attribdata);
#line 325
      data = (byte *)tmp___9;
      }
#line 327
      if (! data) {
        {
#line 328
        warnx("invalid mft record. resident data screwed up");
        }
#line 328
        goto cleanup;
      }
      {
#line 338
      tmp___10 = write(ofile, (void const   *)data, (size_t )length);
      }
#line 338
      if (tmp___10 != (ssize_t )((int32 )length)) {
        {
#line 339
        warn("couldn\'t write data to output file");
        }
#line 339
        goto cleanup;
      }
#line 341
      dataSize -= (uint64 )length;
    } else {
      {
#line 347
      datarun = ntfsx_attribute_getdatarun(attribdata);
#line 348
      nonres = (ntfs_attribnonresident *)attrhead;
#line 351
      ntfsx_cluster_reserve(& cluster, pi);
#line 353
      tmp___15 = ntfsx_datarun_first(datarun);
      }
#line 353
      if (tmp___15) {
        {
#line 355
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 362
          if (dataSize == 0UL) {
#line 363
            goto while_break___1;
          }
#line 366
          if (datarun->sparse) {
            {
#line 368
            memset((void *)cluster.data, 0, (size_t )cluster.size);
#line 370
            i = (uint32 )0;
            }
            {
#line 370
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 370
              if ((uint64 )i < datarun->length) {
#line 370
                if (! dataSize) {
#line 370
                  goto while_break___2;
                }
              } else {
#line 370
                goto while_break___2;
              }
#line 372
              num = cluster.size;
#line 374
              if (dataSize < 4294967295UL) {
#line 374
                if (num > (uint32 )dataSize) {
#line 375
                  num = (uint32 )dataSize;
                }
              }
              {
#line 385
              tmp___11 = write(ofile, (void const   *)cluster.data, (size_t )num);
              }
#line 385
              if (tmp___11 != (ssize_t )((int32 )num)) {
                {
#line 386
                err(1, "couldn\'t write to output file: %s", basics.filename);
                }
              }
#line 388
              dataSize -= (uint64 )num;
#line 370
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
#line 395
            if (pi->locks) {
              {
#line 399
              addLocationLock(pi->locks, datarun->cluster * (uint64 )pi->cluster + (uint64 )pi->first,
                              (datarun->cluster + datarun->length) * (uint64 )pi->cluster + (uint64 )pi->first);
              }
            }
#line 403
            i = (uint32 )0;
            {
#line 403
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 403
              if ((uint64 )i < datarun->length) {
#line 403
                if (! dataSize) {
#line 403
                  goto while_break___3;
                }
              } else {
#line 403
                goto while_break___3;
              }
#line 405
              if (cluster.size < (uint32 )dataSize) {
#line 405
                num = cluster.size;
              } else {
#line 405
                num = (uint32 )dataSize;
              }
              {
#line 406
              dataSector = (datarun->cluster + (uint64 )i) * (uint64 )pi->cluster + (uint64 )pi->first;
#line 408
              tmp___12 = ntfsx_cluster_read(& cluster, pi, dataSector, pi->device);
              }
#line 408
              if (! tmp___12) {
                {
#line 410
                warn("couldn\'t read sector from disk");
                }
#line 411
                goto while_break___3;
              }
              {
#line 422
              tmp___13 = write(ofile, (void const   *)cluster.data, (size_t )num);
              }
#line 422
              if (tmp___13 != (ssize_t )((int32 )num)) {
                {
#line 423
                err(1, "couldn\'t write to output file: %s", basics.filename);
                }
              }
#line 425
              dataSize -= (uint64 )num;
#line 403
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          {
#line 355
          tmp___14 = ntfsx_datarun_next(datarun);
          }
#line 355
          if (! tmp___14) {
#line 355
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 432
      ntfsx_datarun_free(datarun);
#line 433
      datarun = (ntfsx_datarun *)((void *)0);
      }
    }
    {
#line 436
    ntfsx_attribute_free(attribdata);
#line 437
    attribdata = (ntfsx_attribute *)((void *)0);
    }
#line 440
    if (dataSize == 0UL) {
#line 441
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 444
  if (! haddata) {
    {
#line 445
    warnx("invalid mft record. no data attribute found");
    }
#line 445
    goto cleanup;
  }
#line 447
  if (dataSize != 0UL) {
    {
#line 448
    warnx("invalid mft record. couldn\'t find all data for file");
    }
  }
#line 456
  if (sparseSize > 0UL) {
    {
#line 458
    ntfsx_cluster_reserve(& cluster, pi);
#line 459
    memset((void *)cluster.data, 0, (size_t )cluster.size);
    }
    {
#line 461
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 461
      if (! (sparseSize > 0UL)) {
#line 461
        goto while_break___4;
      }
#line 463
      num = cluster.size;
#line 465
      if (sparseSize < 4294967295UL) {
#line 465
        if (num > (uint32 )sparseSize) {
#line 466
          num = (uint32 )sparseSize;
        }
      }
      {
#line 476
      tmp___16 = write(ofile, (void const   *)cluster.data, (size_t )num);
      }
#line 476
      if (tmp___16 != (ssize_t )((int32 )num)) {
        {
#line 477
        err(1, "couldn\'t write to output file: %s", basics.filename);
        }
      }
#line 479
      sparseSize -= (uint64 )num;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 483
  close(ofile);
#line 484
  ofile = -1;
#line 490
  setFileTime(basics.filename, & basics.created, & basics.accessed, & basics.modified);
#line 493
  setFileAttributes(basics.filename, basics.flags);
  }
  cleanup: 
#line 498
  if (record) {
    {
#line 499
    ntfsx_record_free(record);
    }
  }
  {
#line 501
  ntfsx_cluster_release(& cluster);
  }
#line 503
  if (attribdata) {
    {
#line 504
    ntfsx_attribute_free(attribdata);
    }
  }
#line 506
  if (datarun) {
    {
#line 507
    ntfsx_datarun_free(datarun);
    }
  }
#line 509
  if (attrenum) {
    {
#line 510
    ntfsx_attrib_enum_free(attrenum);
    }
  }
#line 512
  if (ofile != -1) {
    {
#line 513
    close(ofile);
    }
  }
#line 514
  return;
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
void scroungeMFT(partitioninfo *pi , ntfsx_mftmap *map ) 
{ 
  ntfsx_record *record ;
  uint64 sector ;
  filebasics basics ;
  ntfs_recordheader *header ;
  bool tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  uint64 tmp___2 ;

  {
#line 519
  record = (ntfsx_record *)((void *)0);
#line 525
  sector = (uint64 )(pi->mft + pi->first);
#line 527
  if (sector >= (uint64 )pi->end) {
    {
#line 528
    errx(2, "invalid mft. past end of partition");
    }
  }
  {
#line 530
  record = ntfsx_record_alloc(pi);
#line 533
  tmp = ntfsx_record_read(record, sector, pi->device);
  }
#line 533
  if (! tmp) {
    {
#line 534
    err(1, "couldn\'t read mft");
    }
  }
  {
#line 536
  header = ntfsx_record_header(record);
  }
#line 539
  if (! ((int )header->flags & 1)) {
    {
#line 540
    errx(2, "invalid mft. marked as not in use");
    }
  }
  {
#line 544
  tmp___0 = ntfsx_mftmap_load(map, record, pi->device);
  }
#line 544
  if (! tmp___0) {
    {
#line 545
    err(1, "error reading in mft");
    }
  }
  {
#line 549
  processRecordFileBasics(pi, record, & basics);
#line 551
  tmp___1 = strcmp((char const   *)(basics.filename), "$MFT");
  }
#line 551
  if (tmp___1) {
    {
#line 552
    errx(2, "invalid mft. wrong record");
    }
  }
  {
#line 554
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Processing MFT...]\n");
#line 556
  tmp___2 = ntfsx_mftmap_length(map);
  }
#line 556
  if (tmp___2 == 0UL) {
    {
#line 557
    errx(1, "invalid mft. no records in mft");
    }
  }
  {
#line 559
  ntfsx_record_free(record);
  }
#line 560
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
void scroungeUsingMFT(partitioninfo *pi ) 
{ 
  uint64 numRecords ;
  fchar_t dir[256] ;
  ntfsx_mftmap map ;
  uint64 length ;
  uint64 sector ;
  uint64 i ;

  {
  {
#line 565
  numRecords = (uint64 )0;
#line 572
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Scrounging via MFT...]\n");
#line 575
  getcwd(dir, (size_t )256);
#line 578
  memset((void *)(& map), 0, sizeof(map));
#line 579
  ntfsx_mftmap_init(& map, pi);
#line 580
  pi->mftmap = & map;
#line 587
  scroungeMFT(pi, & map);
#line 588
  length = ntfsx_mftmap_length(& map);
#line 590
  i = (uint64 )1;
  }
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! (i < length)) {
#line 590
      goto while_break;
    }
    {
#line 592
    sector = ntfsx_mftmap_sectorforindex(& map, i);
    }
#line 593
    if ((unsigned long long )sector == 0xffffffffffffffffULL) {
      {
#line 595
      warnx("invalid index in mft: %d", i);
      }
#line 596
      goto __Cont;
    }
    {
#line 600
    processMFTRecord(pi, sector, (uint32 )0);
#line 603
    chdir((char const   *)(dir));
    }
    __Cont: /* CIL Label */ 
#line 590
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  pi->mftmap = (struct _ntfsx_mftmap *)((void *)0);
#line 607
  return;
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/scrounge-ntfs-0.9/src/scrounge.c"
void scroungeUsingRaw(partitioninfo *pi ) 
{ 
  byte buffSec[512] ;
  fchar_t dir[257] ;
  uint64 sec ;
  drivelocks locks ;
  int64 pos ;
  size_t sz ;
  uint32 magic ;
  bool tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 617
  magic = (uint32 )1162627398UL;
#line 619
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Scrounging raw records...]\n");
#line 622
  getcwd(dir, (size_t )256);
#line 625
  memset((void *)(& locks), 0, sizeof(locks));
#line 626
  pi->locks = & locks;
#line 629
  sec = (uint64 )pi->first;
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
#line 629
    if (! (sec < (uint64 )pi->end)) {
#line 629
      goto while_break;
    }
    {
#line 631
    tmp = checkLocationLock(& locks, sec);
    }
#line 631
    if (tmp) {
#line 632
      goto __Cont;
    }
    {
#line 635
    pos = (int64 )(sec * 512UL);
#line 636
    tmp___0 = lseek64(pi->device, pos, 0);
    }
#line 636
    if (tmp___0 == -1) {
      {
#line 637
      errx(1, "can\'t seek device to sector");
      }
    }
    {
#line 639
    tmp___1 = read(pi->device, (void *)(buffSec), (size_t )512);
#line 639
    sz = (size_t )tmp___1;
    }
#line 640
    if (sz == 0xffffffffffffffffUL) {
      {
#line 642
      warn("can\'t read drive sector");
      }
#line 643
      goto __Cont;
    } else
#line 640
    if (sz != 512UL) {
      {
#line 642
      warn("can\'t read drive sector");
      }
#line 643
      goto __Cont;
    }
    {
#line 647
    tmp___2 = memcmp((void const   *)(& magic), (void const   *)(& buffSec), sizeof(magic));
    }
#line 647
    if (! tmp___2) {
      {
#line 650
      processMFTRecord(pi, sec, (uint32 )0);
      }
    }
    {
#line 654
    chdir((char const   *)(dir));
    }
    __Cont: /* CIL Label */ 
#line 629
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 657
  pi->locks = (struct _drivelocks *)((void *)0);
#line 658
  return;
}
}
