/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_17 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_17 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_18 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_18 Depth;
#line 267
struct _XDisplay;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_19 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_19 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_20 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_20 ScreenFormat;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_35 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_35 *_XPrivDisplay;
#line 1865 "/usr/include/X11/Xlib.h"
typedef int (*XIOErrorHandler)(Display * );
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_104 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_105 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_106 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_107 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_108 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_109 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_110 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_103 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_104 _kill ;
   struct __anonstruct__timer_105 _timer ;
   struct __anonstruct__rt_106 _rt ;
   struct __anonstruct__sigchld_107 _sigchld ;
   struct __anonstruct__sigfault_108 _sigfault ;
   struct __anonstruct__sigpoll_109 _sigpoll ;
   struct __anonstruct__sigsys_110 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_102 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_103 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_102 siginfo_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_122 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_122 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_128 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_129 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_128 __wait_terminated ;
   struct __anonstruct___wait_stopped_129 __wait_stopped ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1869
extern XIOErrorHandler XSetIOErrorHandler(int (*)(Display * ) ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 134
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) killpg)(__pid_t __pgrp ,
                                                                             int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 256
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 125
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 97 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
char const   *bindir  =    "/usr/local/bin";
#line 62 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
char const   * const  server_names[8]  = 
#line 62
  {      (char const   */* const  */)"Xorg        Common X server for most displays",      (char const   */* const  */)"Xvfb        Virtual frame buffer",      (char const   */* const  */)"Xfake       kdrive-based virtual frame buffer",      (char const   */* const  */)"Xnest       X server nested in a window on another X server", 
        (char const   */* const  */)"Xephyr      kdrive-based nested X server",      (char const   */* const  */)"Xvnc        X server accessed over VNC\'s RFB protocol",      (char const   */* const  */)"Xdmx        Distributed Multi-head X server",      (char const   */* const  */)((void *)0)};
#line 83 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
char xinitrcbuf[256]  ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
char xserverrcbuf[256]  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *default_server  =    (char *)"X";
#line 94 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *default_display  =    (char *)":0";
#line 95 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *default_client[6]  = {      (char *)"xterm",      (char *)"-geometry",      (char *)"+1+1",      (char *)"-n", 
        (char *)"login",      (char *)((void *)0)};
#line 96 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *serverargv[100]  ;
#line 97 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *clientargv[100]  ;
#line 98 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char **server  =    serverargv + 2;
#line 99 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char **client  =    clientargv + 2;
#line 100 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *displayNum  =    (char *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *program  =    (char *)((void *)0);
#line 102 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static Display *xd  =    (Display *)((void *)0);
#line 103 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
int status  ;
#line 104 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
int serverpid  =    -1;
#line 105 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
int clientpid  =    -1;
#line 106 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
int volatile   gotSignal  =    (int volatile   )0;
#line 108
static void Execute(char **vec ) ;
#line 109
static int waitforserver(void) ;
#line 110
static int processTimeout(int timeout , char *string ) ;
#line 111
static int startServer(char **server___0 ) ;
#line 112
static int startClient(char **client___0 ) ;
#line 113
static int ignorexio(Display *dpy ) ;
#line 114
static void shutdown(void) ;
#line 115
static void set_environment(void) ;
#line 117
static void Fatal(char const   *fmt  , ...) ;
#line 118
static void Error(char const   *fmt  , ...) ;
#line 119
static void Fatalx(char const   *fmt  , ...) ;
#line 120
static void Errorx(char const   *fmt  , ...) ;
#line 122 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void sigCatch(int sig ) 
{ 


  {
#line 126
  gotSignal = (int volatile   )sig;
#line 127
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void sigIgnore(int sig ) 
{ 


  {
#line 132
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void Execute(char **vec ) 
{ 
  int tmp ;

  {
  {
#line 137
  execvp((char const   *)*(vec + 0), (char * const  *)vec);
#line 138
  tmp = access((char const   *)*(vec + 0), 4);
  }
#line 138
  if (tmp == 0) {
    {
#line 139
    vec --;
#line 140
    *(vec + 0) = (char *)"sh";
#line 141
    execvp((char const   *)*(vec + 0), (char * const  *)vec);
    }
  }
#line 143
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
int main(int argc , char **argv ) 
{ 
  register char **sptr ;
  register char **cptr ;
  register char **ptr ;
  int pid ;
  int client_given ;
  int server_given ;
  int client_args_given ;
  int server_args_given ;
  int start_of_client_args ;
  int start_of_server_args ;
  struct sigaction sa ;
  struct sigaction si ;
  char **tmp ;
  char **tmp___0 ;
  char **tmp___1 ;
  char **tmp___2 ;
  char **tmp___3 ;
  int tmp___4 ;
  char **tmp___5 ;
  char **tmp___6 ;
  char **tmp___7 ;
  char **tmp___8 ;
  char *tmp___9 ;
  unsigned short const   **tmp___10 ;
  char **tmp___11 ;
  char **tmp___12 ;
  char *cp ;
  int required ;
  int tmp___13 ;
  char *cp___0 ;
  int required___0 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 149
  sptr = server;
#line 150
  cptr = client;
#line 153
  client_given = 0;
#line 153
  server_given = 0;
#line 154
  client_args_given = 0;
#line 154
  server_args_given = 0;
#line 163
  tmp = argv;
#line 163
  argv ++;
#line 163
  program = *tmp;
#line 164
  argc --;
#line 168
  if (argc == 0) {
#line 168
    goto _L;
  } else
#line 168
  if ((int )*(*argv) != 47) {
#line 168
    if ((int )*(*argv) != 46) {
      _L: /* CIL Label */ 
#line 170
      ptr = default_client;
      {
#line 170
      while (1) {
        while_continue: /* CIL Label */ ;
#line 170
        if (! *ptr) {
#line 170
          goto while_break;
        }
#line 171
        tmp___0 = cptr;
#line 171
        cptr ++;
#line 171
        tmp___1 = ptr;
#line 171
        ptr ++;
#line 171
        *tmp___0 = *tmp___1;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 173
      client_given = 1;
    }
  } else {
#line 173
    client_given = 1;
  }
#line 175
  start_of_client_args = (int )(cptr - client);
  {
#line 176
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 176
    if (argc) {
      {
#line 176
      tmp___4 = strcmp((char const   *)*argv, "--");
      }
#line 176
      if (! tmp___4) {
#line 176
        goto while_break___0;
      }
    } else {
#line 176
      goto while_break___0;
    }
#line 177
    client_args_given ++;
#line 178
    tmp___2 = cptr;
#line 178
    cptr ++;
#line 178
    tmp___3 = argv;
#line 178
    argv ++;
#line 178
    *tmp___2 = *tmp___3;
#line 179
    argc --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  *cptr = (char *)((void *)0);
#line 182
  if (argc) {
#line 183
    argv ++;
#line 184
    argc --;
  }
#line 190
  if (argc == 0) {
#line 192
    tmp___5 = sptr;
#line 192
    sptr ++;
#line 192
    *tmp___5 = default_server;
  } else
#line 190
  if ((int )*(*argv) != 47) {
#line 190
    if ((int )*(*argv) != 46) {
#line 192
      tmp___5 = sptr;
#line 192
      sptr ++;
#line 192
      *tmp___5 = default_server;
    } else {
#line 190
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 194
    server_given = 1;
#line 195
    tmp___6 = sptr;
#line 195
    sptr ++;
#line 195
    tmp___7 = argv;
#line 195
    argv ++;
#line 195
    *tmp___6 = *tmp___7;
#line 196
    argc --;
  }
#line 198
  if (argc > 0) {
#line 198
    if ((int )*(*(argv + 0) + 0) == 58) {
      {
#line 198
      tmp___10 = __ctype_b_loc();
      }
#line 198
      if ((int const   )*(*tmp___10 + (int )*(*(argv + 0) + 1)) & 2048) {
#line 199
        displayNum = *argv;
      } else {
#line 201
        tmp___8 = sptr;
#line 201
        sptr ++;
#line 201
        tmp___9 = default_display;
#line 201
        *tmp___8 = tmp___9;
#line 201
        displayNum = tmp___9;
      }
    } else {
#line 201
      tmp___8 = sptr;
#line 201
      sptr ++;
#line 201
      tmp___9 = default_display;
#line 201
      *tmp___8 = tmp___9;
#line 201
      displayNum = tmp___9;
    }
  } else {
#line 201
    tmp___8 = sptr;
#line 201
    sptr ++;
#line 201
    tmp___9 = default_display;
#line 201
    *tmp___8 = tmp___9;
#line 201
    displayNum = tmp___9;
  }
#line 203
  start_of_server_args = (int )(sptr - server);
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 204
    argc --;
#line 204
    if (! (argc >= 0)) {
#line 204
      goto while_break___1;
    }
#line 205
    server_args_given ++;
#line 206
    tmp___11 = sptr;
#line 206
    sptr ++;
#line 206
    tmp___12 = argv;
#line 206
    argv ++;
#line 206
    *tmp___11 = *tmp___12;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 208
  *sptr = (char *)((void *)0);
#line 214
  if (! client_given) {
    {
#line 216
    required = 0;
#line 218
    xinitrcbuf[0] = (char )'\000';
#line 219
    cp = getenv("XINITRC");
    }
#line 219
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
      {
#line 220
      snprintf((char */* __restrict  */)(xinitrcbuf), sizeof(xinitrcbuf), (char const   */* __restrict  */)"%s",
               cp);
#line 221
      required = 1;
      }
    } else {
      {
#line 222
      cp = getenv("HOME");
      }
#line 222
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
        {
#line 223
        snprintf((char */* __restrict  */)(xinitrcbuf), sizeof(xinitrcbuf), (char const   */* __restrict  */)"%s/%s",
                 cp, ".xinitrc");
        }
      }
    }
#line 226
    if (xinitrcbuf[0]) {
      {
#line 227
      tmp___13 = access((char const   *)(xinitrcbuf), 0);
      }
#line 227
      if (tmp___13 == 0) {
#line 228
        client += start_of_client_args - 1;
#line 229
        *(client + 0) = xinitrcbuf;
      } else
#line 230
      if (required) {
        {
#line 231
        Error("warning, no client init file \"%s\"", xinitrcbuf);
        }
      }
    }
  }
#line 240
  if (! server_given) {
    {
#line 242
    required___0 = 0;
#line 244
    xserverrcbuf[0] = (char )'\000';
#line 245
    cp___0 = getenv("XSERVERRC");
    }
#line 245
    if ((unsigned long )cp___0 != (unsigned long )((void *)0)) {
      {
#line 246
      snprintf((char */* __restrict  */)(xserverrcbuf), sizeof(xserverrcbuf), (char const   */* __restrict  */)"%s",
               cp___0);
#line 247
      required___0 = 1;
      }
    } else {
      {
#line 248
      cp___0 = getenv("HOME");
      }
#line 248
      if ((unsigned long )cp___0 != (unsigned long )((void *)0)) {
        {
#line 249
        snprintf((char */* __restrict  */)(xserverrcbuf), sizeof(xserverrcbuf), (char const   */* __restrict  */)"%s/%s",
                 cp___0, ".xserverrc");
        }
      }
    }
#line 252
    if (xserverrcbuf[0]) {
      {
#line 253
      tmp___14 = access((char const   *)(xserverrcbuf), 0);
      }
#line 253
      if (tmp___14 == 0) {
#line 254
        server += start_of_server_args - 1;
#line 255
        *(server + 0) = xserverrcbuf;
      } else
#line 256
      if (required___0) {
        {
#line 257
        Error("warning, no server init file \"%s\"", xserverrcbuf);
        }
      }
    }
  }
  {
#line 265
  signal(17, (void (*)(int  ))0);
#line 268
  memset((void *)(& sa), 0, sizeof(sa));
#line 269
  sa.__sigaction_handler.sa_handler = & sigCatch;
#line 270
  sigemptyset(& sa.sa_mask);
#line 271
  sa.sa_flags = 0;
#line 273
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 274
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 275
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 276
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 277
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 279
  memset((void *)(& si), 0, sizeof(si));
#line 280
  si.__sigaction_handler.sa_handler = & sigIgnore;
#line 281
  sigemptyset(& si.sa_mask);
#line 282
  si.sa_flags = 268435456;
#line 284
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& si), (struct sigaction */* __restrict  */)((void *)0));
#line 285
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& si), (struct sigaction */* __restrict  */)((void *)0));
#line 293
  tmp___15 = startServer(server);
  }
#line 293
  if (tmp___15 > 0) {
    {
#line 293
    tmp___16 = startClient(client);
    }
#line 293
    if (tmp___16 > 0) {
#line 295
      pid = -1;
      {
#line 296
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 296
        if (pid != clientpid) {
#line 296
          if (pid != serverpid) {
#line 296
            if (! (gotSignal == (int volatile   )0)) {
#line 296
              goto while_break___2;
            }
          } else {
#line 296
            goto while_break___2;
          }
        } else {
#line 296
          goto while_break___2;
        }
        {
#line 299
        pid = wait((union wait *)((void *)0));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 308
  signal(15, (void (*)(int  ))1);
#line 309
  signal(3, (void (*)(int  ))1);
#line 310
  signal(2, (void (*)(int  ))1);
#line 311
  signal(1, (void (*)(int  ))1);
#line 312
  signal(13, (void (*)(int  ))1);
#line 314
  shutdown();
  }
#line 316
  if (gotSignal != (int volatile   )0) {
    {
#line 317
    Errorx("unexpected signal %d", gotSignal);
#line 318
    exit(1);
    }
  }
#line 321
  if (serverpid < 0) {
    {
#line 322
    Fatalx("server error");
    }
  }
#line 323
  if (clientpid < 0) {
    {
#line 324
    Fatalx("client error");
    }
  }
  {
#line 325
  exit(0);
  }
}
}
#line 332 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static int waitforserver(void) 
{ 
  int ncycles ;
  int cycles ;
  int tmp ;

  {
#line 335
  ncycles = 120;
#line 348
  cycles = 0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! (cycles < ncycles)) {
#line 348
      goto while_break;
    }
    {
#line 349
    xd = XOpenDisplay((char const   *)displayNum);
    }
#line 349
    if (xd) {
#line 350
      return (1);
    } else {
      {
#line 353
      tmp = processTimeout(1, (char *)"X server to begin accepting connections");
      }
#line 353
      if (! tmp) {
#line 354
        goto while_break;
      }
    }
#line 348
    cycles ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  Errorx("giving up");
  }
#line 360
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static char *laststring  ;
#line 366 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static int processTimeout(int timeout , char *string ) 
{ 
  int i ;
  int pidfound ;

  {
#line 369
  i = 0;
#line 369
  pidfound = -1;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 373
    pidfound = waitpid(serverpid, & status, 1);
    }
#line 373
    if (pidfound == serverpid) {
#line 374
      goto while_break;
    }
#line 375
    if (timeout) {
#line 376
      if (i == 0) {
#line 376
        if ((unsigned long )string != (unsigned long )laststring) {
          {
#line 377
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r\nwaiting for %s ",
                  string);
          }
        } else {
          {
#line 379
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 379
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
      }
      {
#line 380
      fflush(stderr);
#line 381
      sleep(1U);
      }
    }
#line 383
    i ++;
#line 383
    if (i > timeout) {
#line 384
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  if (i > 0) {
    {
#line 386
    fputc('\n', stderr);
    }
  }
#line 387
  laststring = string;
#line 388
  return (serverpid != pidfound);
}
}
#line 391 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static int startServer(char **server___0 ) 
{ 
  sigset_t mask ;
  sigset_t old ;
  char const   * const  *cpp ;
  __pid_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 397
  sigemptyset(& mask);
#line 398
  sigaddset(& mask, 10);
#line 399
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask), (sigset_t */* __restrict  */)(& old));
#line 401
  serverpid = fork();
  }
  {
#line 404
  if (serverpid == 0) {
#line 404
    goto case_0;
  }
#line 438
  if (serverpid == -1) {
#line 438
    goto case_neg_1;
  }
#line 440
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 406
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& old), (sigset_t */* __restrict  */)((void *)0));
#line 411
  signal(21, (void (*)(int  ))1);
#line 412
  signal(22, (void (*)(int  ))1);
#line 418
  signal(10, (void (*)(int  ))1);
#line 423
  tmp = getpid();
#line 423
  setpgid(0, tmp);
#line 424
  Execute(server___0);
#line 426
  Error("unable to run server \"%s\"", *(server___0 + 0));
#line 428
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Use the -- option, or make sure that %s is in your path and\n",
          bindir);
#line 429
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"that \"%s\" is a program or a link to the right type of server\n",
          *(server___0 + 0));
#line 430
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for your display.  Possible server names include:\n\n");
#line 431
  cpp = server_names;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! *cpp) {
#line 431
      goto while_break;
    }
    {
#line 432
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    %s\n",
            *cpp);
#line 431
    cpp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 435
  exit(1);
  }
#line 437
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 439
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 444
  setpriority(0, (id_t )serverpid, -1);
#line 446
  tmp___0 = __errno_location();
#line 446
  *tmp___0 = 0;
#line 447
  tmp___1 = processTimeout(0, (char *)"");
  }
#line 447
  if (! tmp___1) {
#line 448
    serverpid = -1;
#line 449
    goto switch_break;
  }
  {
#line 459
  alarm(15U);
#line 461
  sigsuspend((sigset_t const   *)(& old));
#line 462
  alarm(0U);
#line 463
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& old), (sigset_t */* __restrict  */)((void *)0));
#line 465
  tmp___2 = waitforserver();
  }
#line 465
  if (tmp___2 == 0) {
    {
#line 466
    Error("unable to connect to X server");
#line 467
    shutdown();
#line 468
    serverpid = -1;
    }
  }
#line 470
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 473
  return (serverpid);
}
}
#line 476 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void setWindowPath(void) 
{ 
  Atom prop ;
  Atom actualtype ;
  int actualformat ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  unsigned char *buf ;
  char const   *windowpath ;
  char *newwindowpath ;
  unsigned long num ;
  char nums[10] ;
  int numn ;
  size_t len ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 492
  prop = XInternAtom(xd, "XFree86_VT", 0);
  }
#line 493
  if (prop == 0UL) {
    {
#line 494
    Errorx("Unable to intern XFree86_VT atom");
    }
#line 495
    return;
  }
  {
#line 497
  tmp = XGetWindowProperty(xd, (((_XPrivDisplay )xd)->screens + ((_XPrivDisplay )xd)->default_screen)->root,
                           prop, 0L, 1L, 0, (Atom )0L, & actualtype, & actualformat,
                           & nitems, & bytes_after, & buf);
  }
#line 497
  if (tmp) {
    {
#line 500
    Errorx("No XFree86_VT property detected on X server, WINDOWPATH won\'t be set");
    }
#line 501
    return;
  }
#line 503
  if (nitems != 1UL) {
    {
#line 504
    Errorx("XFree86_VT property unexpectedly has %lu items instead of 1", nitems);
#line 505
    XFree((void *)buf);
    }
#line 506
    return;
  }
  {
#line 511
  if (actualtype == 33UL) {
#line 511
    goto case_33;
  }
#line 511
  if (actualtype == 19UL) {
#line 511
    goto case_33;
  }
#line 511
  if (actualtype == 6UL) {
#line 511
    goto case_33;
  }
#line 528
  goto switch_default___0;
  case_33: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 513
  if (actualformat == 8) {
#line 513
    goto case_8;
  }
#line 516
  if (actualformat == 16) {
#line 516
    goto case_16;
  }
#line 519
  if (actualformat == 32) {
#line 519
    goto case_32;
  }
#line 522
  goto switch_default;
  case_8: /* CIL Label */ 
#line 514
  num = (unsigned long )*((uint8_t *)((void *)buf));
#line 515
  goto switch_break___0;
  case_16: /* CIL Label */ 
#line 517
  num = (unsigned long )*((uint16_t *)((void *)buf));
#line 518
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 520
  num = (unsigned long )*((uint32_t *)((void *)buf));
#line 521
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 523
  Errorx("XFree86_VT property has unexpected format %d", actualformat);
#line 524
  XFree((void *)buf);
  }
#line 525
  return;
  switch_break___0: /* CIL Label */ ;
  }
#line 527
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 529
  Errorx("XFree86_VT property has unexpected type %lx", actualtype);
#line 530
  XFree((void *)buf);
  }
#line 531
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 533
  XFree((void *)buf);
#line 534
  tmp___0 = getenv("WINDOWPATH");
#line 534
  windowpath = (char const   *)tmp___0;
#line 535
  numn = snprintf((char */* __restrict  */)(nums), sizeof(nums), (char const   */* __restrict  */)"%lu",
                  num);
  }
#line 536
  if (! windowpath) {
    {
#line 537
    len = (size_t )(numn + 1);
#line 538
    tmp___1 = malloc(len);
#line 538
    newwindowpath = (char *)tmp___1;
    }
#line 539
    if ((unsigned long )newwindowpath == (unsigned long )((void *)0)) {
#line 540
      return;
    }
    {
#line 541
    snprintf((char */* __restrict  */)newwindowpath, len, (char const   */* __restrict  */)"%s",
             nums);
    }
  } else {
    {
#line 543
    tmp___2 = strlen(windowpath);
#line 543
    len = ((tmp___2 + 1UL) + (size_t )numn) + 1UL;
#line 544
    tmp___3 = malloc(len);
#line 544
    newwindowpath = (char *)tmp___3;
    }
#line 545
    if ((unsigned long )newwindowpath == (unsigned long )((void *)0)) {
#line 546
      return;
    }
    {
#line 547
    snprintf((char */* __restrict  */)newwindowpath, len, (char const   */* __restrict  */)"%s:%s",
             windowpath, nums);
    }
  }
  {
#line 550
  tmp___4 = setenv("WINDOWPATH", (char const   *)newwindowpath, 1);
  }
#line 550
  if (tmp___4 == -1) {
    {
#line 551
    Error("unable to set WINDOWPATH");
    }
  }
  {
#line 554
  free((void *)newwindowpath);
  }
#line 555
  return;
}
}
#line 557 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static int startClient(char **client___0 ) 
{ 
  __uid_t tmp ;
  int tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 560
  clientpid = fork();
  }
#line 561
  if (clientpid == 0) {
    {
#line 562
    set_environment();
#line 563
    setWindowPath();
#line 565
    tmp = getuid();
#line 565
    tmp___0 = setuid(tmp);
    }
#line 565
    if (tmp___0 == -1) {
      {
#line 566
      Error("cannot change uid");
#line 567
      _exit(1);
      }
    }
    {
#line 569
    tmp___1 = getpid();
#line 569
    setpgid(0, tmp___1);
#line 570
    Execute(client___0);
#line 571
    Error("Unable to run program \"%s\"", *(client___0 + 0));
#line 573
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Specify a program on the command line or make sure that %s\n",
            bindir);
#line 574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"is in your path.\n\n");
#line 576
    _exit(1);
    }
  } else {
#line 578
    return (clientpid);
  }
}
}
#line 582 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static jmp_buf close_env  ;
#line 584 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static int ignorexio(Display *dpy ) 
{ 


  {
  {
#line 587
  Errorx("connection to X server lost");
#line 588
  longjmp((struct __jmp_buf_tag *)(close_env), 1);
  }
#line 590
  return (0);
}
}
#line 593 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void shutdown(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 597
  if (clientpid > 0) {
    {
#line 598
    XSetIOErrorHandler(& ignorexio);
#line 599
    tmp = _setjmp((struct __jmp_buf_tag *)(close_env));
    }
#line 599
    if (! tmp) {
      {
#line 600
      XCloseDisplay(xd);
      }
    }
    {
#line 604
    tmp___0 = killpg(clientpid, 1);
    }
#line 604
    if (tmp___0 < 0) {
      {
#line 604
      tmp___1 = __errno_location();
      }
#line 604
      if (*tmp___1 != 3) {
        {
#line 605
        Error("can\'t send HUP to process group %d", clientpid);
        }
      }
    }
  }
#line 608
  if (serverpid < 0) {
#line 609
    return;
  }
  {
#line 611
  tmp___3 = killpg(serverpid, 15);
  }
#line 611
  if (tmp___3 < 0) {
    {
#line 612
    tmp___2 = __errno_location();
    }
#line 612
    if (*tmp___2 == 3) {
#line 613
      return;
    }
    {
#line 614
    Fatal("can\'t kill X server");
    }
  }
  {
#line 617
  tmp___4 = processTimeout(10, (char *)"X server to shut down");
  }
#line 617
  if (! tmp___4) {
#line 618
    return;
  }
  {
#line 620
  Errorx("X server slow to shut down, sending KILL signal");
#line 622
  tmp___6 = killpg(serverpid, 9);
  }
#line 622
  if (tmp___6 < 0) {
    {
#line 623
    tmp___5 = __errno_location();
    }
#line 623
    if (*tmp___5 == 3) {
#line 624
      return;
    }
    {
#line 625
    Error("can\'t SIGKILL X server");
    }
  }
  {
#line 628
  tmp___7 = processTimeout(3, (char *)"server to die");
  }
#line 628
  if (tmp___7) {
    {
#line 629
    Fatalx("X server refuses to die");
    }
  }
#line 630
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void set_environment(void) 
{ 
  int tmp ;

  {
  {
#line 635
  tmp = setenv("DISPLAY", (char const   *)displayNum, 1);
  }
#line 635
  if (tmp == -1) {
    {
#line 636
    Fatal("unable to set DISPLAY");
    }
  }
#line 637
  return;
}
}
#line 639 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void verror(char const   *fmt , va_list ap ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 642
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program);
#line 643
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 644
  tmp = __errno_location();
#line 644
  tmp___0 = strerror(*tmp);
#line 644
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
          tmp___0);
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void verrorx(char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 650
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          program);
#line 651
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 652
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 653
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void Fatal(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 659
  __builtin_va_start(ap, fmt);
#line 660
  verror(fmt, ap);
#line 661
  __builtin_va_end(ap);
#line 662
  exit(1);
  }
}
}
#line 665 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void Fatalx(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 669
  __builtin_va_start(ap, fmt);
#line 670
  verrorx(fmt, ap);
#line 671
  __builtin_va_end(ap);
#line 672
  exit(1);
  }
}
}
#line 675 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void Error(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 679
  __builtin_va_start(ap, fmt);
#line 680
  verror(fmt, ap);
#line 681
  __builtin_va_end(ap);
  }
#line 682
  return;
}
}
#line 684 "/home/june/repo/benchmarks/collector2/temp/xinit-1.3.2/xinit.c"
static void Errorx(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 688
  __builtin_va_start(ap, fmt);
#line 689
  verrorx(fmt, ap);
#line 690
  __builtin_va_end(ap);
  }
#line 691
  return;
}
}
