/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 28 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/.libs/libltdlS.c"
struct __anonstruct_lt_dlsymlist_1 {
   char const   *name ;
   void *address ;
};
#line 28 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/.libs/libltdlS.c"
typedef struct __anonstruct_lt_dlsymlist_1 lt_dlsymlist;
#line 57 "./libltdl/libltdl/slist.h"
struct slist {
   struct slist *next ;
   void const   *userdata ;
};
#line 57 "./libltdl/libltdl/slist.h"
typedef struct slist SList;
#line 62 "./libltdl/libltdl/slist.h"
typedef void *SListCallback(SList *item , void *userdata );
#line 63 "./libltdl/libltdl/slist.h"
typedef int SListCompare(SList const   *item1 , SList const   *item2 , void *userdata );
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 38 "libltdl/libltdl/lt_dlloader.h"
typedef void *lt_dlloader;
#line 39 "libltdl/libltdl/lt_dlloader.h"
typedef void *lt_module;
#line 40 "libltdl/libltdl/lt_dlloader.h"
typedef void *lt_user_data;
#line 41
struct lt__advise;
#line 41 "libltdl/libltdl/lt_dlloader.h"
typedef struct lt__advise *lt_dladvise;
#line 44 "libltdl/libltdl/lt_dlloader.h"
typedef lt_module lt_module_open(lt_user_data data , char const   *filename , lt_dladvise advise );
#line 47 "libltdl/libltdl/lt_dlloader.h"
typedef int lt_module_close(lt_user_data data , lt_module module );
#line 49 "libltdl/libltdl/lt_dlloader.h"
typedef void *lt_find_sym(lt_user_data data , lt_module module , char const   *symbolname );
#line 51 "libltdl/libltdl/lt_dlloader.h"
typedef int lt_dlloader_init(lt_user_data data );
#line 52 "libltdl/libltdl/lt_dlloader.h"
typedef int lt_dlloader_exit(lt_user_data data );
#line 55
enum __anonenum_lt_dlloader_priority_31 {
    LT_DLLOADER_PREPEND = 0,
    LT_DLLOADER_APPEND = 1
} ;
#line 55 "libltdl/libltdl/lt_dlloader.h"
typedef enum __anonenum_lt_dlloader_priority_31 lt_dlloader_priority;
#line 61 "libltdl/libltdl/lt_dlloader.h"
struct __anonstruct_lt_dlvtable_32 {
   char const   *name ;
   char const   *sym_prefix ;
   lt_module_open *module_open ;
   lt_module_close *module_close ;
   lt_find_sym *find_sym ;
   lt_dlloader_init *dlloader_init ;
   lt_dlloader_exit *dlloader_exit ;
   lt_user_data dlloader_data ;
   lt_dlloader_priority priority ;
};
#line 61 "libltdl/libltdl/lt_dlloader.h"
typedef struct __anonstruct_lt_dlvtable_32 lt_dlvtable;
#line 82 "libltdl/libltdl/lt_dlloader.h"
typedef lt_dlvtable const   *lt_get_vtable(lt_user_data data );
#line 50 "libltdl/ltdl.h"
struct lt__handle;
#line 50 "libltdl/ltdl.h"
typedef struct lt__handle *lt_dlhandle;
#line 97 "libltdl/ltdl.h"
typedef int lt_dlpreload_callback_func(lt_dlhandle handle );
#line 118 "libltdl/ltdl.h"
typedef void *lt_dlinterface_id;
#line 119 "libltdl/ltdl.h"
typedef int lt_dlhandle_interface(lt_dlhandle handle , char const   *id_string );
#line 131 "libltdl/ltdl.h"
struct __anonstruct_lt_dlinfo_34 {
   char *filename ;
   char *name ;
   int ref_count ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
};
#line 131 "libltdl/ltdl.h"
typedef struct __anonstruct_lt_dlinfo_34 lt_dlinfo;
#line 105 "./libltdl/libltdl/lt__private.h"
struct __anonstruct_lt_interface_data_35 {
   lt_dlinterface_id key ;
   void *data ;
};
#line 105 "./libltdl/libltdl/lt__private.h"
typedef struct __anonstruct_lt_interface_data_35 lt_interface_data;
#line 110 "./libltdl/libltdl/lt__private.h"
struct lt__handle {
   lt_dlhandle next ;
   lt_dlvtable const   *vtable ;
   lt_dlinfo info ;
   int depcount ;
   lt_dlhandle *deplibs ;
   lt_module module ;
   void *system ;
   lt_interface_data *interface_data ;
   int flags ;
};
#line 122 "./libltdl/libltdl/lt__private.h"
struct lt__advise {
   unsigned int try_ext : 1 ;
   unsigned int is_resident : 1 ;
   unsigned int is_symglobal : 1 ;
   unsigned int is_symlocal : 1 ;
   unsigned int try_preload_only : 1 ;
};
#line 99 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
typedef int foreach_callback_func(char *filename , void *data1 , void *data2 );
#line 102 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
typedef int file_worker_func(char const   *filename , void *data );
#line 2283 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
struct __anonstruct_lt__interface_id_36 {
   char const   *id_string ;
   lt_dlhandle_interface *iface ;
};
#line 2283 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
typedef struct __anonstruct_lt__interface_id_36 lt__interface_id;
#line 97 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
struct symlist_chain {
   struct symlist_chain *next ;
   lt_dlsymlist const   *symlist ;
};
#line 97 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
typedef struct symlist_chain symlist_chain;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 51 "./libltdl/libltdl/lt__alloc.h"
void *lt__realloc(void *mem , size_t n ) ;
#line 79 "libltdl/libltdl/lt_error.h"
int lt_dladderror(char const   *diagnostic ) ;
#line 80
int lt_dlseterror(int errindex ) ;
#line 143 "./libltdl/libltdl/lt__private.h"
char const   *lt__error_string(int errorcode ) ;
#line 144
char const   *lt__get_last_error(void) ;
#line 145
char const   *lt__set_last_error(char const   *errormsg ) ;
#line 34 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
static char const   *last_error  =    (char const   *)0;
#line 35 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
static char const   error_strings[20][42]  = 
#line 35
  { {        (char const   )'u',        (char const   )'n',        (char const   )'k',        (char const   )'n', 
            (char const   )'o',        (char const   )'w',        (char const   )'n',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'l',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'s', 
            (char const   )'u',        (char const   )'p',        (char const   )'p',        (char const   )'o', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'a', 
            (char const   )'v',        (char const   )'a',        (char const   )'i',        (char const   )'l', 
            (char const   )'a',        (char const   )'b',        (char const   )'l',        (char const   )'e', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'i', 
            (char const   )'n',        (char const   )'i',        (char const   )'t',        (char const   )'i', 
            (char const   )'a',        (char const   )'l',        (char const   )'i',        (char const   )'z', 
            (char const   )'a',        (char const   )'t',        (char const   )'i',        (char const   )'o', 
            (char const   )'n',        (char const   )' ',        (char const   )'f',        (char const   )'a', 
            (char const   )'i',        (char const   )'l',        (char const   )'e',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'o',        (char const   )'a',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )' ',        (char const   )'r', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'v', 
            (char const   )'a',        (char const   )'l',        (char const   )' ',        (char const   )'f', 
            (char const   )'a',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )' ',        (char const   )'n',        (char const   )'o',        (char const   )'t', 
            (char const   )' ',        (char const   )'f',        (char const   )'o',        (char const   )'u', 
            (char const   )'n',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'e',        (char const   )'p',        (char const   )'e', 
            (char const   )'n',        (char const   )'d',        (char const   )'e',        (char const   )'n', 
            (char const   )'c',        (char const   )'y',        (char const   )' ',        (char const   )'l', 
            (char const   )'i',        (char const   )'b',        (char const   )'r',        (char const   )'a', 
            (char const   )'r',        (char const   )'y',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )' ',        (char const   )'s', 
            (char const   )'y',        (char const   )'m',        (char const   )'b',        (char const   )'o', 
            (char const   )'l',        (char const   )'s',        (char const   )' ',        (char const   )'d', 
            (char const   )'e',        (char const   )'f',        (char const   )'i',        (char const   )'n', 
            (char const   )'e',        (char const   )'d',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'o',        (char const   )'p', 
            (char const   )'e',        (char const   )'n',        (char const   )' ',        (char const   )'t', 
            (char const   )'h',        (char const   )'e',        (char const   )' ',        (char const   )'m', 
            (char const   )'o',        (char const   )'d',        (char const   )'u',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'t',        (char const   )'h',        (char const   )'e',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'n', 
            (char const   )'o',        (char const   )'t',        (char const   )' ',        (char const   )'f', 
            (char const   )'o',        (char const   )'u',        (char const   )'n',        (char const   )'d', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'o',        (char const   )'t',        (char const   )' ', 
            (char const   )'e',        (char const   )'n',        (char const   )'o',        (char const   )'u', 
            (char const   )'g',        (char const   )'h',        (char const   )' ',        (char const   )'m', 
            (char const   )'e',        (char const   )'m',        (char const   )'o',        (char const   )'r', 
            (char const   )'y',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'m',        (char const   )'o',        (char const   )'d',        (char const   )'u', 
            (char const   )'l',        (char const   )'e',        (char const   )' ',        (char const   )'h', 
            (char const   )'a',        (char const   )'n',        (char const   )'d',        (char const   )'l', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'b',        (char const   )'u',        (char const   )'f', 
            (char const   )'f',        (char const   )'e',        (char const   )'r',        (char const   )' ', 
            (char const   )'o',        (char const   )'v',        (char const   )'e',        (char const   )'r', 
            (char const   )'f',        (char const   )'l',        (char const   )'o',        (char const   )'w', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'e',        (char const   )'r',        (char const   )'r',        (char const   )'o', 
            (char const   )'r',        (char const   )'c',        (char const   )'o',        (char const   )'d', 
            (char const   )'e',        (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'b',        (char const   )'r', 
            (char const   )'a',        (char const   )'r',        (char const   )'y',        (char const   )' ', 
            (char const   )'a',        (char const   )'l',        (char const   )'r',        (char const   )'e', 
            (char const   )'a',        (char const   )'d',        (char const   )'y',        (char const   )' ', 
            (char const   )'s',        (char const   )'h',        (char const   )'u',        (char const   )'t', 
            (char const   )'d',        (char const   )'o',        (char const   )'w',        (char const   )'n', 
            (char const   )'\000',        (char const   )'\000'}, 
   {        (char const   )'c',        (char const   )'a',        (char const   )'n',        (char const   )'\'', 
            (char const   )'t',        (char const   )' ',        (char const   )'c',        (char const   )'l', 
            (char const   )'o',        (char const   )'s',        (char const   )'e',        (char const   )' ', 
            (char const   )'r',        (char const   )'e',        (char const   )'s',        (char const   )'i', 
            (char const   )'d',        (char const   )'e',        (char const   )'n',        (char const   )'t', 
            (char const   )' ',        (char const   )'m',        (char const   )'o',        (char const   )'d', 
            (char const   )'u',        (char const   )'l',        (char const   )'e',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'t',        (char const   )'e', 
            (char const   )'r',        (char const   )'n',        (char const   )'a',        (char const   )'l', 
            (char const   )' ',        (char const   )'e',        (char const   )'r',        (char const   )'r', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'(', 
            (char const   )'c',        (char const   )'o',        (char const   )'d',        (char const   )'e', 
            (char const   )' ',        (char const   )'w',        (char const   )'i',        (char const   )'t', 
            (char const   )'h',        (char const   )'d',        (char const   )'r',        (char const   )'a', 
            (char const   )'w',        (char const   )'n',        (char const   )')',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'i',        (char const   )'n',        (char const   )'v',        (char const   )'a', 
            (char const   )'l',        (char const   )'i',        (char const   )'d',        (char const   )' ', 
            (char const   )'s',        (char const   )'e',        (char const   )'a',        (char const   )'r', 
            (char const   )'c',        (char const   )'h',        (char const   )' ',        (char const   )'p', 
            (char const   )'a',        (char const   )'t',        (char const   )'h',        (char const   )' ', 
            (char const   )'i',        (char const   )'n',        (char const   )'s',        (char const   )'e', 
            (char const   )'r',        (char const   )'t',        (char const   )' ',        (char const   )'p', 
            (char const   )'o',        (char const   )'s',        (char const   )'i',        (char const   )'t', 
            (char const   )'i',        (char const   )'o',        (char const   )'n',        (char const   )'\000', 
            (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'y',        (char const   )'m',        (char const   )'b', 
            (char const   )'o',        (char const   )'l',        (char const   )' ',        (char const   )'v', 
            (char const   )'i',        (char const   )'s',        (char const   )'i',        (char const   )'b', 
            (char const   )'i',        (char const   )'l',        (char const   )'i',        (char const   )'t', 
            (char const   )'y',        (char const   )' ',        (char const   )'c',        (char const   )'a', 
            (char const   )'n',        (char const   )' ',        (char const   )'b',        (char const   )'e', 
            (char const   )' ',        (char const   )'g',        (char const   )'l',        (char const   )'o', 
            (char const   )'b',        (char const   )'a',        (char const   )'l',        (char const   )' ', 
            (char const   )'o',        (char const   )'r',        (char const   )' ',        (char const   )'l', 
            (char const   )'o',        (char const   )'c',        (char const   )'a',        (char const   )'l', 
            (char const   )'\000',        (char const   )'\000'}};
#line 42 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
static char const   **user_error_strings  =    (char const   **)0;
#line 43 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
static int errorcount  =    20;
#line 45 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
int lt_dladderror(char const   *diagnostic ) 
{ 
  int errindex ;
  int result ;
  char const   **temp ;
  void *tmp ;
  int tmp___0 ;

  {
#line 48
  errindex = 0;
#line 49
  result = -1;
#line 50
  temp = (char const   **)0;
#line 52
  if (! diagnostic) {
    {
#line 52
    __assert_fail("diagnostic", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c",
                  52U, "lt_dladderror");
    }
  }
  {
#line 54
  errindex = errorcount - 20;
#line 55
  tmp = lt__realloc((void *)user_error_strings, (unsigned long )(1 + errindex) * sizeof(char const   *));
#line 55
  temp = (char const   **)tmp;
  }
#line 56
  if (temp) {
#line 58
    user_error_strings = temp;
#line 59
    *(user_error_strings + errindex) = diagnostic;
#line 60
    tmp___0 = errorcount;
#line 60
    errorcount ++;
#line 60
    result = tmp___0;
  }
#line 63
  return (result);
}
}
#line 66 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
int lt_dlseterror(int errindex ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 69
  errors = 0;
#line 71
  if (errindex >= errorcount) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 71
  if (errindex < 0) {
    {
#line 74
    tmp = lt__error_string(14);
#line 74
    lt__set_last_error(tmp);
#line 75
    errors ++;
    }
  } else
#line 77
  if (errindex < 20) {
    {
#line 80
    lt__set_last_error(error_strings[errindex]);
    }
  } else {
    {
#line 85
    lt__set_last_error(*(user_error_strings + (errindex - 20)));
    }
  }
#line 88
  return (errors);
}
}
#line 91 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
char const   *lt__error_string(int errorcode ) 
{ 


  {
#line 94
  if (! (errorcode >= 0)) {
    {
#line 94
    __assert_fail("errorcode >= 0", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c",
                  94U, "lt__error_string");
    }
  }
#line 95
  if (! (errorcode < 20)) {
    {
#line 95
    __assert_fail("errorcode < LT_ERROR_MAX", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c",
                  95U, "lt__error_string");
    }
  }
#line 97
  return (error_strings[errorcode]);
}
}
#line 100 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
char const   *lt__get_last_error(void) 
{ 


  {
#line 103
  return (last_error);
}
}
#line 106 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_error.c"
char const   *lt__set_last_error(char const   *errormsg ) 
{ 


  {
#line 109
  last_error = errormsg;
#line 109
  return (last_error);
}
}
#line 9 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/.libs/libltdlS.c"
#pragma GCC diagnostic ignored "-Wstrict-prototypes"
#line 25
extern int dlopen_LTX_get_vtable() ;
#line 32
lt_dlsymlist const   lt_libltdl_LTX_preloaded_symbols[4] ;
#line 34 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/.libs/libltdlS.c"
lt_dlsymlist const   lt_libltdl_LTX_preloaded_symbols[4]  = {      {"libltdl", (void *)0}, 
        {"dlopen.a", (void *)0}, 
        {"dlopen_LTX_get_vtable", (void *)(& dlopen_LTX_get_vtable)}, 
        {(char const   *)0, (void *)0}};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "./libltdl/libltdl/slist.h"
SList *lt__slist_concat(SList *head , SList *tail ) ;
#line 67
SList *lt__slist_cons(SList *item , SList *slist ) ;
#line 69
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) ;
#line 70
SList *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) ;
#line 72
SList *lt__slist_reverse(SList *slist ) ;
#line 73
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) ;
#line 76
SList *lt__slist_tail(SList *slist ) ;
#line 77
SList *lt__slist_nth(SList *slist , size_t n ) ;
#line 78
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) ;
#line 80
size_t lt__slist_length(SList *slist ) ;
#line 82
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) ;
#line 85
SList *lt__slist_box(void const   *userdata ) ;
#line 86
void *lt__slist_unbox(SList *item ) ;
#line 37 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) ;
#line 53 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_delete(SList *head , void (*delete_fct)(void *item ) ) 
{ 
  SList *next ;

  {
#line 56
  if (! delete_fct) {
    {
#line 56
    __assert_fail("delete_fct", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c",
                  56U, "lt__slist_delete");
    }
  }
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! head) {
#line 58
      goto while_break;
    }
    {
#line 60
    next = head->next;
#line 61
    (*delete_fct)((void *)head);
#line 62
    head = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return ((SList *)0);
}
}
#line 77 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_remove(SList **phead , SListCallback *find , void *matchdata ) 
{ 
  SList *stale ;
  void *result ;
  SList *head ;

  {
#line 80
  stale = (SList *)0;
#line 81
  result = (void *)0;
#line 83
  if (! find) {
    {
#line 83
    __assert_fail("find", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c",
                  83U, "lt__slist_remove");
    }
  }
#line 85
  if (! phead) {
#line 86
    return ((SList *)0);
  } else
#line 85
  if (! *phead) {
#line 86
    return ((SList *)0);
  }
  {
#line 89
  result = (*find)(*phead, matchdata);
  }
#line 90
  if (result) {
#line 92
    stale = *phead;
#line 93
    *phead = stale->next;
  } else {
#line 99
    head = *phead;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      if (! head->next) {
#line 99
        goto while_break;
      }
      {
#line 101
      result = (*find)(head->next, matchdata);
      }
#line 102
      if (result) {
#line 104
        stale = head->next;
#line 105
        head->next = stale->next;
#line 106
        goto while_break;
      }
#line 99
      head = head->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 111
  return ((SList *)result);
}
}
#line 117 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
void *lt__slist_find(SList *slist , SListCallback *find , void *matchdata ) 
{ 
  void *result ;

  {
#line 120
  result = (void *)0;
#line 122
  if (! find) {
    {
#line 122
    __assert_fail("find", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c",
                  122U, "lt__slist_find");
    }
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! slist) {
#line 124
      goto while_break;
    }
    {
#line 126
    result = (*find)(slist, matchdata);
    }
#line 127
    if (result) {
#line 128
      goto while_break;
    }
#line 124
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return (result);
}
}
#line 141 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_concat(SList *head , SList *tail ) 
{ 
  SList *last ;

  {
#line 146
  if (! head) {
#line 148
    return (tail);
  }
#line 151
  last = head;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! last->next) {
#line 152
      goto while_break;
    }
#line 153
    last = last->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  last->next = tail;
#line 157
  return (head);
}
}
#line 167 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_cons(SList *item , SList *slist ) 
{ 


  {
#line 170
  if (! item) {
#line 172
    return (slist);
  }
#line 175
  if (! (! item->next)) {
    {
#line 175
    __assert_fail("!item->next", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c",
                  175U, "lt__slist_cons");
    }
  }
#line 177
  item->next = slist;
#line 178
  return (item);
}
}
#line 182 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_tail(SList *slist ) 
{ 
  struct slist *tmp ;

  {
#line 185
  if (slist) {
#line 185
    tmp = slist->next;
  } else {
#line 185
    tmp = (struct slist *)((void *)0);
  }
#line 185
  return (tmp);
}
}
#line 193 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_nth(SList *slist , size_t n ) 
{ 


  {
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (n > 1UL) {
#line 196
      if (! slist) {
#line 196
        goto while_break;
      }
    } else {
#line 196
      goto while_break;
    }
#line 197
    slist = slist->next;
#line 196
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (slist);
}
}
#line 204 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
size_t lt__slist_length(SList *slist ) 
{ 
  size_t n ;

  {
#line 209
  n = (size_t )0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! slist) {
#line 209
      goto while_break;
    }
#line 210
    slist = slist->next;
#line 209
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  return (n);
}
}
#line 222 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_reverse(SList *slist ) 
{ 
  SList *result ;
  SList *next ;

  {
#line 225
  result = (SList *)0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! slist) {
#line 228
      goto while_break;
    }
#line 230
    next = slist->next;
#line 231
    slist->next = result;
#line 232
    result = slist;
#line 233
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (result);
}
}
#line 241 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
void *lt__slist_foreach(SList *slist , SListCallback *foreach , void *userdata ) 
{ 
  void *result ;
  SList *next ;

  {
#line 244
  result = (void *)0;
#line 246
  if (! foreach) {
    {
#line 246
    __assert_fail("foreach", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c",
                  246U, "lt__slist_foreach");
    }
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! slist) {
#line 248
      goto while_break;
    }
    {
#line 250
    next = slist->next;
#line 251
    result = (*foreach)(slist, userdata);
    }
#line 253
    if (result) {
#line 254
      goto while_break;
    }
#line 256
    slist = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  return (result);
}
}
#line 272 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
static SList *slist_sort_merge(SList *left , SList *right , SListCompare *compare ,
                               void *userdata ) 
{ 
  SList merged ;
  SList *insert ;
  struct slist *tmp ;
  struct slist *tmp___0 ;
  int tmp___1 ;

  {
#line 278
  insert = & merged;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (left) {
#line 280
      if (! right) {
#line 280
        goto while_break;
      }
    } else {
#line 280
      goto while_break;
    }
    {
#line 282
    tmp___1 = (*compare)((SList const   *)left, (SList const   *)right, userdata);
    }
#line 282
    if (tmp___1 <= 0) {
#line 284
      tmp = left;
#line 284
      insert->next = tmp;
#line 284
      insert = tmp;
#line 285
      left = left->next;
    } else {
#line 289
      tmp___0 = right;
#line 289
      insert->next = tmp___0;
#line 289
      insert = tmp___0;
#line 290
      right = right->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  if (left) {
#line 294
    insert->next = left;
  } else {
#line 294
    insert->next = right;
  }
#line 296
  return (merged.next);
}
}
#line 306 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_sort(SList *slist , SListCompare *compare , void *userdata ) 
{ 
  SList *left ;
  SList *right ;
  SList *tmp ;
  SList *tmp___0 ;
  SList *tmp___1 ;

  {
#line 311
  if (! slist) {
#line 312
    return (slist);
  }
#line 315
  left = slist;
#line 316
  right = slist->next;
#line 318
  if (! right) {
#line 319
    return (left);
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (right) {
#line 323
      right = right->next;
#line 323
      if (! right) {
#line 323
        goto while_break;
      }
    } else {
#line 323
      goto while_break;
    }
#line 325
    if (! right) {
#line 326
      goto while_break;
    } else {
#line 325
      right = right->next;
#line 325
      if (! right) {
#line 326
        goto while_break;
      }
    }
#line 327
    slist = slist->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 329
  right = slist->next;
#line 330
  slist->next = (struct slist *)0;
#line 333
  tmp = lt__slist_sort(right, compare, userdata);
#line 333
  tmp___0 = lt__slist_sort(left, compare, userdata);
#line 333
  tmp___1 = slist_sort_merge(tmp___0, tmp, compare, userdata);
  }
#line 333
  return (tmp___1);
}
}
#line 350 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
SList *lt__slist_box(void const   *userdata ) 
{ 
  SList *item ;
  void *tmp ;

  {
  {
#line 353
  tmp = malloc(sizeof(*item));
#line 353
  item = (SList *)tmp;
  }
#line 355
  if (item) {
#line 357
    item->next = (struct slist *)0;
#line 358
    item->userdata = userdata;
  }
#line 361
  return (item);
}
}
#line 365 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/slist.c"
void *lt__slist_unbox(SList *item ) 
{ 
  void *userdata ;

  {
#line 368
  userdata = (void *)0;
#line 370
  if (item) {
    {
#line 374
    userdata = (void *)item->userdata;
#line 375
    free((void *)item);
    }
  }
#line 378
  return (userdata);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 47 "./libltdl/libltdl/lt__alloc.h"
void (*lt__alloc_die)(void) ;
#line 49
void *lt__malloc(size_t n ) ;
#line 50
void *lt__zalloc(size_t n ) ;
#line 54
char *lt__strdup(char const   *string ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/usr/include/argz.h"
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_create_sep)(char const   * __restrict  __string ,
                                                                                          int __sep ,
                                                                                          char ** __restrict  __argz ,
                                                                                          size_t * __restrict  __len ) ;
#line 70
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) argz_stringify)(char *__argz ,
                                                                                      size_t __len ,
                                                                                      int __sep ) ;
#line 77
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_append)(char ** __restrict  __argz ,
                                                                                      size_t * __restrict  __argz_len ,
                                                                                      char const   * __restrict  __buf ,
                                                                                      size_t __buf_len ) ;
#line 119
extern  __attribute__((__nothrow__)) error_t ( __attribute__((__leaf__)) argz_insert)(char ** __restrict  __argz ,
                                                                                      size_t * __restrict  __argz_len ,
                                                                                      char * __restrict  __before ,
                                                                                      char const   * __restrict  __entry ) ;
#line 154
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) argz_next)(char const   * __restrict  __argz ,
                                                                                  size_t __argz_len ,
                                                                                  char const   * __restrict  __entry ) ;
#line 73 "libltdl/libltdl/lt_dlloader.h"
int lt_dlloader_add(lt_dlvtable const   *vtable___0 ) ;
#line 74
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) ;
#line 76
lt_dlvtable *lt_dlloader_remove(char const   *name ) ;
#line 77
lt_dlvtable const   *lt_dlloader_find(char const   *name ) ;
#line 78
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) ;
#line 53 "libltdl/ltdl.h"
int lt_dlinit(void) ;
#line 54
int lt_dlexit(void) ;
#line 57
int lt_dladdsearchdir(char const   *search_dir ) ;
#line 58
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) ;
#line 60
int lt_dlsetsearchpath(char const   *search_path ) ;
#line 61
char const   *lt_dlgetsearchpath(void) ;
#line 62
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) ;
#line 68
int lt_dladvise_init(lt_dladvise *padvise ) ;
#line 69
int lt_dladvise_destroy(lt_dladvise *padvise ) ;
#line 70
int lt_dladvise_ext(lt_dladvise *padvise ) ;
#line 71
int lt_dladvise_resident(lt_dladvise *padvise ) ;
#line 72
int lt_dladvise_local(lt_dladvise *padvise ) ;
#line 73
int lt_dladvise_global(lt_dladvise *padvise ) ;
#line 74
int lt_dladvise_preload(lt_dladvise *padvise ) ;
#line 77
lt_dlhandle lt_dlopen(char const   *filename ) ;
#line 78
lt_dlhandle lt_dlopenext(char const   *filename ) ;
#line 79
lt_dlhandle lt_dlopenadvise(char const   *filename , lt_dladvise advise ) ;
#line 81
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) ;
#line 82
char const   *lt_dlerror(void) ;
#line 83
int lt_dlclose(lt_dlhandle handle ) ;
#line 99
int lt_dlpreload(lt_dlsymlist const   *preloaded ) ;
#line 101
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) ;
#line 121
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) ;
#line 123
void lt_dlinterface_free(lt_dlinterface_id key ) ;
#line 124
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) ;
#line 126
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) ;
#line 143
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) ;
#line 145
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) ;
#line 147
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) ;
#line 149
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) ;
#line 156
int lt_dlmakeresident(lt_dlhandle handle ) ;
#line 157
int lt_dlisresident(lt_dlhandle handle ) ;
#line 93 "./libltdl/libltdl/lt__private.h"
void lt__alloc_die_callback(void) ;
#line 76 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   objdir[7]  = {      (char const   )'.',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )'s',      (char const   )'/',      (char const   )'\000'};
#line 77 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   archive_ext[4]  = {      (char const   )'.',      (char const   )'l',      (char const   )'a',      (char const   )'\000'};
#line 78 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   libext[2]  = {      (char const   )'a',      (char const   )'\000'};
#line 79 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   libprefix[4]  = {      (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'\000'};
#line 81 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   shlib_ext[4]  = {      (char const   )'.',      (char const   )'s',      (char const   )'o',      (char const   )'\000'};
#line 89 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char const   sys_dlsearch_path[181]  = 
#line 89
  {      (char const   )'/',      (char const   )'l',      (char const   )'i',      (char const   )'b', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'x', 
        (char const   )'8',      (char const   )'6',      (char const   )'_',      (char const   )'6', 
        (char const   )'4',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'f', 
        (char const   )'a',      (char const   )'k',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'o',      (char const   )'t',      (char const   )':', 
        (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'l',      (char const   )'o',      (char const   )'c', 
        (char const   )'a',      (char const   )'l',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )':',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'/', 
        (char const   )'x',      (char const   )'8',      (char const   )'6',      (char const   )'_', 
        (char const   )'6',      (char const   )'4',      (char const   )'-',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'u',      (char const   )'x', 
        (char const   )'-',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )':',      (char const   )'/',      (char const   )'u',      (char const   )'s', 
        (char const   )'r',      (char const   )'/',      (char const   )'l',      (char const   )'i', 
        (char const   )'b',      (char const   )'/',      (char const   )'x',      (char const   )'8', 
        (char const   )'6',      (char const   )'_',      (char const   )'6',      (char const   )'4', 
        (char const   )'-',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'u',      (char const   )'x',      (char const   )'-',      (char const   )'g', 
        (char const   )'n',      (char const   )'u',      (char const   )':',      (char const   )'/', 
        (char const   )'u',      (char const   )'s',      (char const   )'r',      (char const   )'/', 
        (char const   )'l',      (char const   )'i',      (char const   )'b',      (char const   )'/', 
        (char const   )'x',      (char const   )'8',      (char const   )'6',      (char const   )'_', 
        (char const   )'6',      (char const   )'4',      (char const   )'-',      (char const   )'l', 
        (char const   )'i',      (char const   )'n',      (char const   )'u',      (char const   )'x', 
        (char const   )'-',      (char const   )'g',      (char const   )'n',      (char const   )'u', 
        (char const   )'/',      (char const   )'m',      (char const   )'e',      (char const   )'s', 
        (char const   )'a',      (char const   )'-',      (char const   )'e',      (char const   )'g', 
        (char const   )'l',      (char const   )':',      (char const   )'/',      (char const   )'u', 
        (char const   )'s',      (char const   )'r',      (char const   )'/',      (char const   )'l', 
        (char const   )'i',      (char const   )'b',      (char const   )'/',      (char const   )'x', 
        (char const   )'8',      (char const   )'6',      (char const   )'_',      (char const   )'6', 
        (char const   )'4',      (char const   )'-',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'u',      (char const   )'x',      (char const   )'-', 
        (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'/', 
        (char const   )'m',      (char const   )'e',      (char const   )'s',      (char const   )'a', 
        (char const   )'\000'};
#line 105
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) ;
#line 109
static int find_file_callback(char *filename , void *data1 , void *data2 ) ;
#line 111
static int find_handle_callback(char *filename , void *data , void *data2 ) ;
#line 113
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) ;
#line 117
static int canonicalize_path(char const   *path , char **pcanonical ) ;
#line 118
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) ;
#line 120
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) ;
#line 122
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) ;
#line 126
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) ;
#line 130
static int has_library_ext(char const   *filename ) ;
#line 131
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) ;
#line 132
static int trim(char **dest , char const   *str ) ;
#line 133
static int try_dlopen(lt_dlhandle *phandle , char const   *filename , char const   *ext ,
                      lt_dladvise advise ) ;
#line 136
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___0 ) ;
#line 140
static int unload_deplibs(lt_dlhandle handle ) ;
#line 141
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) ;
#line 143
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) ;
#line 145
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) ;
#line 147
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) ;
#line 149
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) ;
#line 151
static int file_not_found(void) ;
#line 154
static int loader_init_callback(lt_dlhandle handle ) ;
#line 157
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) ;
#line 160 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static char *user_search_path  =    (char *)0;
#line 161 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static lt_dlhandle handles  =    (lt_dlhandle )0;
#line 162 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int initialized  =    0;
#line 167 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
void lt__alloc_die_callback(void) 
{ 
  char const   *tmp ;

  {
  {
#line 170
  tmp = lt__error_string(11);
#line 170
  lt__set_last_error(tmp);
  }
#line 171
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int loader_init_callback(lt_dlhandle handle ) 
{ 
  lt_get_vtable *vtable_func ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 180
  tmp = lt_dlsym(handle, "get_vtable");
#line 180
  vtable_func = (lt_get_vtable *)tmp;
#line 181
  tmp___0 = loader_init(vtable_func, (lt_user_data )0);
  }
#line 181
  return (tmp___0);
}
}
#line 185 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int loader_init(lt_get_vtable *vtable_func , lt_user_data data ) 
{ 
  lt_dlvtable const   *vtable___0 ;
  int errors ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 188
  vtable___0 = (lt_dlvtable const   *)0;
#line 189
  errors = 0;
#line 191
  if (vtable_func) {
    {
#line 193
    vtable___0 = (*vtable_func)(data);
    }
  }
  {
#line 197
  tmp = lt_dlloader_add(vtable___0);
#line 197
  errors += tmp;
  }
#line 199
  if (! errors) {
#line 199
    if (! vtable___0) {
      {
#line 199
      __assert_fail("errors || vtable", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    199U, "loader_init");
      }
    }
  }
#line 201
  if (! errors) {
#line 201
    if (vtable___0->dlloader_init) {
      {
#line 203
      tmp___1 = (*(vtable___0->dlloader_init))((lt_user_data )vtable___0->dlloader_data);
      }
#line 203
      if (tmp___1) {
        {
#line 205
        tmp___0 = lt__error_string(3);
#line 205
        lt__set_last_error(tmp___0);
#line 206
        errors ++;
        }
      }
    }
  }
#line 210
  return (errors);
}
}
#line 218
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) ;
#line 225 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlinit(void) 
{ 
  int errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 228
  errors = 0;
#line 231
  initialized ++;
#line 231
  if (initialized == 1) {
    {
#line 233
    lt__alloc_die = & lt__alloc_die_callback;
#line 234
    handles = (lt_dlhandle )0;
#line 235
    user_search_path = (char *)0;
#line 240
    tmp = loader_init(& preopen_LTX_get_vtable, (lt_user_data )0);
#line 240
    errors += tmp;
    }
#line 245
    if (! errors) {
      {
#line 247
      tmp___0 = lt_dlpreload(lt_libltdl_LTX_preloaded_symbols);
#line 247
      errors += tmp___0;
      }
    }
#line 250
    if (! errors) {
      {
#line 252
      tmp___1 = lt_dlpreload_open("libltdl", & loader_init_callback);
#line 252
      errors += tmp___1;
      }
    }
  }
#line 261
  return (errors);
}
}
#line 264 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlexit(void) 
{ 
  lt_dlloader *loader ;
  lt_dlhandle handle ;
  int errors ;
  char const   *tmp ;
  int level ;
  lt_dlhandle cur ;
  int saw_nonresident ;
  lt_dlhandle tmp___0 ;
  int tmp___1 ;
  lt_dlloader tmp___2 ;
  lt_dlloader *next ;
  lt_dlloader tmp___3 ;
  lt_dlvtable *vtable___0 ;
  lt_dlvtable const   *tmp___4 ;
  char const   *err ;

  {
#line 268
  loader = (lt_dlloader *)0;
#line 269
  handle = handles;
#line 270
  errors = 0;
#line 272
  if (! initialized) {
    {
#line 274
    tmp = lt__error_string(15);
#line 274
    lt__set_last_error(tmp);
#line 275
    errors ++;
    }
#line 276
    goto done;
  }
#line 280
  initialized --;
#line 280
  if (initialized == 0) {
    {
#line 284
    while (1) {
      while_continue: /* CIL Label */ ;
#line 284
      if (handles) {
#line 284
        if (! handles->info.is_resident) {
#line 284
          goto while_break;
        }
      } else {
#line 284
        goto while_break;
      }
#line 286
      handles = handles->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 290
    level = 1;
    {
#line 290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 290
      if (! handle) {
#line 290
        goto while_break___0;
      }
#line 292
      cur = handles;
#line 293
      saw_nonresident = 0;
      {
#line 295
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 295
        if (! cur) {
#line 295
          goto while_break___1;
        }
#line 297
        tmp___0 = cur;
#line 298
        cur = cur->next;
#line 299
        if (! tmp___0->info.is_resident) {
#line 301
          saw_nonresident = 1;
#line 302
          if (tmp___0->info.ref_count <= level) {
            {
#line 304
            tmp___1 = lt_dlclose(tmp___0);
            }
#line 304
            if (tmp___1) {
#line 306
              errors ++;
            }
#line 312
            if (cur) {
#line 314
              tmp___0 = handles;
              {
#line 314
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 314
                if (! tmp___0) {
#line 314
                  goto while_break___2;
                }
#line 315
                if ((unsigned long )tmp___0 == (unsigned long )cur) {
#line 316
                  goto while_break___2;
                }
#line 314
                tmp___0 = tmp___0->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 317
              if (! tmp___0) {
#line 318
                cur = handles;
              }
            }
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 324
      if (! saw_nonresident) {
#line 325
        goto while_break___0;
      }
#line 290
      level ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 331
    if (! errors) {
      {
#line 332
      lt__set_last_error((char const   *)0);
      }
    }
    {
#line 335
    tmp___2 = lt_dlloader_next((lt_dlloader const   )((void *)0));
#line 335
    loader = (lt_dlloader *)tmp___2;
    }
    {
#line 335
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 335
      if (! loader) {
#line 335
        goto while_break___3;
      }
      {
#line 337
      tmp___3 = lt_dlloader_next((lt_dlloader const   )loader);
#line 337
      next = (lt_dlloader *)tmp___3;
#line 338
      tmp___4 = lt_dlloader_get((lt_dlloader )loader);
#line 338
      vtable___0 = (lt_dlvtable *)tmp___4;
#line 340
      vtable___0 = lt_dlloader_remove((char const   *)((char *)vtable___0->name));
      }
#line 340
      if (vtable___0) {
#line 342
        if (vtable___0) {
          {
#line 342
          free((void *)vtable___0);
#line 342
          vtable___0 = (lt_dlvtable *)((void *)0);
          }
        }
      } else {
        {
#line 348
        err = lt__get_last_error();
        }
#line 349
        if (err) {
#line 350
          errors ++;
        }
      }
#line 353
      loader = next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 356
    if (user_search_path) {
      {
#line 356
      free((void *)user_search_path);
#line 356
      user_search_path = (char *)((void *)0);
      }
    }
  }
  done: 
#line 360
  return (errors);
}
}
#line 367 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int tryall_dlopen(lt_dlhandle *phandle , char const   *filename , lt_dladvise advise ,
                         lt_dlvtable const   *vtable___0 ) 
{ 
  lt_dlhandle handle ;
  char const   *saved_error ;
  int errors ;
  int tmp ;
  lt_dlloader loader ;
  lt_dlloader tmp___0 ;
  lt_dlvtable const   *loader_vtable ;

  {
  {
#line 371
  handle = handles;
#line 372
  saved_error = (char const   *)0;
#line 373
  errors = 0;
#line 381
  saved_error = lt__get_last_error();
  }
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! handle) {
#line 384
      goto while_break;
    }
#line 386
    if ((unsigned long )handle->info.filename == (unsigned long )filename) {
#line 390
      goto while_break;
    } else
#line 386
    if (handle->info.filename) {
#line 386
      if (filename) {
        {
#line 386
        tmp = strcmp((char const   *)handle->info.filename, filename);
        }
#line 386
        if (! tmp) {
#line 390
          goto while_break;
        }
      }
    }
#line 384
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  if (handle) {
#line 396
    (handle->info.ref_count) ++;
#line 397
    *phandle = handle;
#line 398
    goto done;
  }
#line 401
  handle = *phandle;
#line 402
  if (filename) {
    {
#line 416
    handle->info.filename = lt__strdup(filename);
    }
#line 417
    if (! handle->info.filename) {
#line 419
      errors ++;
#line 420
      goto done;
    }
  } else {
#line 425
    handle->info.filename = (char *)0;
  }
  {
#line 429
  tmp___0 = lt_dlloader_next((lt_dlloader const   )0);
#line 429
  loader = tmp___0;
  }
  {
#line 432
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 434
    if (vtable___0) {
#line 435
      loader_vtable = vtable___0;
    } else {
      {
#line 437
      loader_vtable = lt_dlloader_get(loader);
      }
    }
    {
#line 444
    handle->module = (*(loader_vtable->module_open))((lt_user_data )loader_vtable->dlloader_data,
                                                     filename, advise);
    }
#line 451
    if ((unsigned long )handle->module != (unsigned long )((lt_module )0)) {
#line 453
      if (advise) {
#line 455
        handle->info.is_resident = advise->is_resident;
#line 456
        handle->info.is_symglobal = advise->is_symglobal;
#line 457
        handle->info.is_symlocal = advise->is_symlocal;
      }
#line 459
      goto while_break___0;
    }
#line 432
    if (! vtable___0) {
      {
#line 432
      loader = lt_dlloader_next((lt_dlloader const   )loader);
      }
#line 432
      if (! loader) {
#line 432
        goto while_break___0;
      }
    } else {
#line 432
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 467
  if (vtable___0) {
#line 467
    if (! handle->module) {
#line 467
      goto _L;
    } else {
#line 467
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 467
  if (! vtable___0) {
#line 467
    if (! loader) {
      _L: /* CIL Label */ 
#line 470
      if (handle->info.filename) {
        {
#line 470
        free((void *)handle->info.filename);
#line 470
        handle->info.filename = (char *)((void *)0);
        }
      }
#line 471
      errors ++;
#line 472
      goto done;
    }
  }
  {
#line 475
  handle->vtable = loader_vtable;
#line 478
  lt__set_last_error(saved_error);
  }
  done: 
#line 481
  return (errors);
}
}
#line 485 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int tryall_dlopen_module(lt_dlhandle *handle , char const   *prefix , char const   *dirname ,
                                char const   *dlname , lt_dladvise advise ) 
{ 
  int error ;
  char *filename ;
  size_t filename_len ;
  size_t dirname_len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 490
  error = 0;
#line 491
  filename = (char *)0;
#line 492
  filename_len = (size_t )0;
#line 493
  if (dirname) {
#line 493
    if (*(dirname + 0)) {
      {
#line 493
      tmp = strlen(dirname);
#line 493
      tmp___0 = tmp;
      }
    } else {
#line 493
      tmp___0 = (size_t )0;
    }
  } else {
#line 493
    tmp___0 = (size_t )0;
  }
#line 493
  dirname_len = tmp___0;
#line 495
  if (! handle) {
    {
#line 495
    __assert_fail("handle", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  495U, "tryall_dlopen_module");
    }
  }
#line 496
  if (! dirname) {
    {
#line 496
    __assert_fail("dirname", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  496U, "tryall_dlopen_module");
    }
  }
#line 497
  if (! dlname) {
    {
#line 497
    __assert_fail("dlname", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  497U, "tryall_dlopen_module");
    }
  }
#line 504
  if (dirname_len > 0UL) {
#line 505
    if ((int const   )*(dirname + (dirname_len - 1UL)) == 47) {
#line 506
      dirname_len --;
    }
  }
#line 507
  if (dlname) {
#line 507
    if (*(dlname + 0)) {
      {
#line 507
      tmp___1 = strlen(dlname);
#line 507
      tmp___2 = tmp___1;
      }
    } else {
#line 507
      tmp___2 = (size_t )0;
    }
  } else {
#line 507
    tmp___2 = (size_t )0;
  }
  {
#line 507
  filename_len = (dirname_len + 1UL) + tmp___2;
#line 511
  tmp___3 = lt__malloc((filename_len + 1UL) * sizeof(char ));
#line 511
  filename = (char *)tmp___3;
  }
#line 512
  if (! filename) {
#line 513
    return (1);
  }
  {
#line 515
  sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%.*s/%s",
          (int )dirname_len, dirname, dlname);
  }
#line 520
  if (prefix) {
    {
#line 522
    tmp___4 = tryall_dlopen_module(handle, (char const   *)0, prefix, (char const   *)filename,
                                   advise);
#line 522
    error += tmp___4;
    }
  } else {
    {
#line 525
    tmp___5 = tryall_dlopen(handle, (char const   *)filename, advise, (lt_dlvtable const   *)0);
    }
#line 525
    if (tmp___5 != 0) {
#line 527
      error ++;
    }
  }
#line 530
  if (filename) {
    {
#line 530
    free((void *)filename);
#line 530
    filename = (char *)((void *)0);
    }
  }
#line 531
  return (error);
}
}
#line 534 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int find_module(lt_dlhandle *handle , char const   *dir , char const   *libdir ,
                       char const   *dlname , char const   *old_name , int installed ,
                       lt_dladvise advise ) 
{ 
  lt_dlvtable const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 542
  if (old_name) {
    {
#line 542
    tmp = lt_dlloader_find("lt_preopen");
#line 542
    tmp___0 = tryall_dlopen(handle, old_name, advise, tmp);
    }
#line 542
    if (tmp___0 == 0) {
#line 545
      return (0);
    }
  }
#line 549
  if (dlname) {
#line 552
    if (installed) {
#line 552
      if (libdir) {
        {
#line 554
        tmp___1 = tryall_dlopen_module(handle, (char const   *)0, libdir, dlname,
                                       advise);
        }
#line 554
        if (tmp___1 == 0) {
#line 556
          return (0);
        }
      }
    }
#line 560
    if (! installed) {
      {
#line 562
      tmp___2 = tryall_dlopen_module(handle, dir, objdir, dlname, advise);
      }
#line 562
      if (tmp___2 == 0) {
#line 564
        return (0);
      }
    }
#line 569
    if (dir) {
      {
#line 569
      tmp___3 = tryall_dlopen_module(handle, (char const   *)0, dir, dlname, advise);
      }
#line 569
      if (tmp___3 == 0) {
#line 571
        return (0);
      }
    }
  }
#line 575
  return (1);
}
}
#line 579 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int canonicalize_path(char const   *path , char **pcanonical ) 
{ 
  char *canonical ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t dest ;
  size_t src ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 582
  canonical = (char *)0;
#line 584
  if (path) {
#line 584
    if (! *path) {
      {
#line 584
      __assert_fail("path && *path", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    584U, "canonicalize_path");
      }
    }
  } else {
    {
#line 584
    __assert_fail("path && *path", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  584U, "canonicalize_path");
    }
  }
#line 585
  if (! pcanonical) {
    {
#line 585
    __assert_fail("pcanonical", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  585U, "canonicalize_path");
    }
  }
#line 587
  if (path) {
#line 587
    if (*(path + 0)) {
      {
#line 587
      tmp = strlen(path);
#line 587
      tmp___0 = tmp;
      }
    } else {
#line 587
      tmp___0 = (size_t )0;
    }
  } else {
#line 587
    tmp___0 = (size_t )0;
  }
  {
#line 587
  tmp___1 = lt__malloc((1UL + tmp___0) * sizeof(char ));
#line 587
  canonical = (char *)tmp___1;
  }
#line 588
  if (! canonical) {
#line 589
    return (1);
  }
#line 592
  dest = (size_t )0;
#line 594
  src = (size_t )0;
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (! ((int const   )*(path + src) != 0)) {
#line 594
      goto while_break;
    }
#line 599
    if ((int const   )*(path + src) == 58) {
#line 601
      if (dest == 0UL) {
#line 604
        goto __Cont;
      } else
#line 601
      if ((int const   )*(path + (1UL + src)) == 58) {
#line 604
        goto __Cont;
      } else
#line 601
      if ((int const   )*(path + (1UL + src)) == 0) {
#line 604
        goto __Cont;
      }
    }
#line 608
    if ((int const   )*(path + src) != 47) {
#line 614
      tmp___2 = dest;
#line 614
      dest ++;
#line 614
      *(canonical + tmp___2) = (char )*(path + src);
    } else
#line 619
    if ((int const   )*(path + (1UL + src)) != 58) {
#line 619
      if ((int const   )*(path + (1UL + src)) != 0) {
#line 619
        if ((int const   )*(path + (1UL + src)) != 47) {
#line 626
          tmp___3 = dest;
#line 626
          dest ++;
#line 626
          *(canonical + tmp___3) = (char )'/';
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 594
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  *(canonical + dest) = (char )'\000';
#line 635
  *pcanonical = canonical;
#line 637
  return (0);
}
}
#line 640 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int argzize_path(char const   *path , char **pargz , size_t *pargz_len ) 
{ 
  error_t error ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 645
  if (! path) {
    {
#line 645
    __assert_fail("path", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  645U, "argzize_path");
    }
  }
#line 646
  if (! pargz) {
    {
#line 646
    __assert_fail("pargz", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  646U, "argzize_path");
    }
  }
#line 647
  if (! pargz_len) {
    {
#line 647
    __assert_fail("pargz_len", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  647U, "argzize_path");
    }
  }
  {
#line 649
  error = argz_create_sep((char const   */* __restrict  */)path, ':', (char **/* __restrict  */)pargz,
                          (size_t */* __restrict  */)pargz_len);
  }
#line 649
  if (error) {
    {
#line 653
    if (error == 12) {
#line 653
      goto case_12;
    }
#line 656
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 654
    tmp = lt__error_string(11);
#line 654
    lt__set_last_error(tmp);
    }
#line 655
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 657
    tmp___0 = lt__error_string(0);
#line 657
    lt__set_last_error(tmp___0);
    }
#line 658
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 661
    return (1);
  }
#line 664
  return (0);
}
}
#line 671 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int foreach_dirinpath(char const   *search_path , char const   *base_name ,
                             foreach_callback_func *func , void *data1 , void *data2 ) 
{ 
  int result ;
  size_t filenamesize ;
  size_t lenbase ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t argz_len ;
  char *argz ;
  char *filename ;
  char *canonical ;
  char const   *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *dir_name ;
  size_t lendir ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;

  {
#line 675
  result = 0;
#line 676
  filenamesize = (size_t )0;
#line 677
  if (base_name) {
#line 677
    if (*(base_name + 0)) {
      {
#line 677
      tmp = strlen(base_name);
#line 677
      tmp___0 = tmp;
      }
    } else {
#line 677
      tmp___0 = (size_t )0;
    }
  } else {
#line 677
    tmp___0 = (size_t )0;
  }
#line 677
  lenbase = tmp___0;
#line 678
  argz_len = (size_t )0;
#line 679
  argz = (char *)0;
#line 680
  filename = (char *)0;
#line 681
  canonical = (char *)0;
#line 683
  if (! search_path) {
    {
#line 685
    tmp___1 = lt__error_string(5);
#line 685
    lt__set_last_error(tmp___1);
    }
#line 686
    goto cleanup;
  } else
#line 683
  if (! *search_path) {
    {
#line 685
    tmp___1 = lt__error_string(5);
#line 685
    lt__set_last_error(tmp___1);
    }
#line 686
    goto cleanup;
  }
  {
#line 689
  tmp___2 = canonicalize_path(search_path, & canonical);
  }
#line 689
  if (tmp___2 != 0) {
#line 690
    goto cleanup;
  }
  {
#line 692
  tmp___3 = argzize_path((char const   *)canonical, & argz, & argz_len);
  }
#line 692
  if (tmp___3 != 0) {
#line 693
    goto cleanup;
  }
#line 696
  dir_name = (char *)0;
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 697
    dir_name = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)dir_name);
    }
#line 697
    if (! dir_name) {
#line 697
      goto while_break;
    }
#line 699
    if (dir_name) {
#line 699
      if (*(dir_name + 0)) {
        {
#line 699
        tmp___4 = strlen((char const   *)dir_name);
#line 699
        tmp___5 = tmp___4;
        }
      } else {
#line 699
        tmp___5 = (size_t )0;
      }
    } else {
#line 699
      tmp___5 = (size_t )0;
    }
#line 699
    lendir = tmp___5;
#line 701
    if ((1UL + lendir) + lenbase >= filenamesize) {
#line 703
      if (filename) {
        {
#line 703
        free((void *)filename);
#line 703
        filename = (char *)((void *)0);
        }
      }
      {
#line 704
      filenamesize = ((1UL + lendir) + 1UL) + lenbase;
#line 705
      tmp___6 = lt__malloc(filenamesize * sizeof(char ));
#line 705
      filename = (char *)tmp___6;
      }
#line 706
      if (! filename) {
#line 707
        goto cleanup;
      }
    }
#line 710
    if (! (filenamesize > lendir)) {
      {
#line 710
      __assert_fail("filenamesize > lendir", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    710U, "foreach_dirinpath");
      }
    }
    {
#line 711
    strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)dir_name);
    }
#line 713
    if (base_name) {
#line 713
      if (*base_name) {
#line 715
        if ((int )*(filename + (lendir - 1UL)) != 47) {
#line 716
          tmp___7 = lendir;
#line 716
          lendir ++;
#line 716
          *(filename + tmp___7) = (char )'/';
        }
        {
#line 717
        strcpy((char */* __restrict  */)(filename + lendir), (char const   */* __restrict  */)base_name);
        }
      }
    }
    {
#line 720
    result = (*func)(filename, data1, data2);
    }
#line 720
    if (result) {
#line 722
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 728
  if (argz) {
    {
#line 728
    free((void *)argz);
#line 728
    argz = (char *)((void *)0);
    }
  }
#line 729
  if (canonical) {
    {
#line 729
    free((void *)canonical);
#line 729
    canonical = (char *)((void *)0);
    }
  }
#line 730
  if (filename) {
    {
#line 730
    free((void *)filename);
#line 730
    filename = (char *)((void *)0);
    }
  }
#line 732
  return (result);
}
}
#line 738 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int find_file_callback(char *filename , void *data1 , void *data2 ) 
{ 
  char **pdir ;
  FILE **pfile ;
  int is_done ;
  char *dirend ;
  char *tmp ;
  FILE *tmp___0 ;

  {
#line 741
  pdir = (char **)data1;
#line 742
  pfile = (FILE **)data2;
#line 743
  is_done = 0;
#line 745
  if (filename) {
#line 745
    if (! *filename) {
      {
#line 745
      __assert_fail("filename && *filename", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    745U, "find_file_callback");
      }
    }
  } else {
    {
#line 745
    __assert_fail("filename && *filename", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  745U, "find_file_callback");
    }
  }
#line 746
  if (! pdir) {
    {
#line 746
    __assert_fail("pdir", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  746U, "find_file_callback");
    }
  }
#line 747
  if (! pfile) {
    {
#line 747
    __assert_fail("pfile", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  747U, "find_file_callback");
    }
  }
  {
#line 749
  tmp___0 = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 749
  *pfile = tmp___0;
  }
#line 749
  if (tmp___0) {
    {
#line 751
    tmp = strrchr((char const   *)filename, '/');
#line 751
    dirend = tmp;
    }
#line 753
    if ((unsigned long )dirend > (unsigned long )filename) {
#line 754
      *dirend = (char )'\000';
    }
#line 756
    if (*pdir) {
      {
#line 756
      free((void *)*pdir);
#line 756
      *pdir = (char *)((void *)0);
      }
    }
    {
#line 757
    *pdir = lt__strdup((char const   *)filename);
    }
#line 758
    if ((unsigned long )*pdir == (unsigned long )((char *)0)) {
#line 758
      is_done = -1;
    } else {
#line 758
      is_done = 1;
    }
  }
#line 761
  return (is_done);
}
}
#line 764 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static FILE *find_file(char const   *search_path , char const   *base_name , char **pdir ) 
{ 
  FILE *file ;

  {
  {
#line 767
  file = (FILE *)0;
#line 769
  foreach_dirinpath(search_path, base_name, & find_file_callback, (void *)pdir, (void *)(& file));
  }
#line 771
  return (file);
}
}
#line 774 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int find_handle_callback(char *filename , void *data , void *data2 ) 
{ 
  lt_dlhandle *phandle ;
  int notfound ;
  int tmp ;
  lt_dladvise advise ;
  int tmp___0 ;

  {
  {
#line 777
  phandle = (lt_dlhandle *)data;
#line 778
  tmp = access((char const   *)filename, 4);
#line 778
  notfound = tmp;
#line 779
  advise = (lt_dladvise )data2;
  }
#line 782
  if (notfound) {
#line 783
    return (0);
  }
  {
#line 787
  tmp___0 = tryall_dlopen(phandle, (char const   *)filename, advise, (lt_dlvtable const   *)0);
  }
#line 787
  if (tmp___0 != 0) {
#line 788
    *phandle = (lt_dlhandle )0;
  }
#line 790
  return (1);
}
}
#line 795 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static lt_dlhandle *find_handle(char const   *search_path , char const   *base_name ,
                                lt_dlhandle *phandle , lt_dladvise advise ) 
{ 
  int tmp ;

  {
#line 799
  if (! search_path) {
#line 800
    return ((lt_dlhandle *)0);
  }
  {
#line 802
  tmp = foreach_dirinpath(search_path, base_name, & find_handle_callback, (void *)phandle,
                          (void *)advise);
  }
#line 802
  if (! tmp) {
#line 804
    return ((lt_dlhandle *)0);
  }
#line 806
  return (phandle);
}
}
#line 810 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int load_deplibs(lt_dlhandle handle , char *deplibs  __attribute__((__unused__)) ) 
{ 


  {
#line 813
  handle->depcount = 0;
#line 814
  return (0);
}
}
#line 974 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int unload_deplibs(lt_dlhandle handle ) 
{ 
  int i ;
  int errors ;
  lt_dlhandle cur ;
  int tmp ;

  {
#line 978
  errors = 0;
#line 979
  cur = handle;
#line 981
  if (cur->depcount) {
#line 983
    i = 0;
    {
#line 983
    while (1) {
      while_continue: /* CIL Label */ ;
#line 983
      if (! (i < cur->depcount)) {
#line 983
        goto while_break;
      }
#line 985
      if (! (*(cur->deplibs + i))->info.is_resident) {
        {
#line 987
        tmp = lt_dlclose(*(cur->deplibs + i));
#line 987
        errors += tmp;
        }
      }
#line 983
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 990
    if (cur->deplibs) {
      {
#line 990
      free((void *)cur->deplibs);
#line 990
      cur->deplibs = (lt_dlhandle *)((void *)0);
      }
    }
  }
#line 993
  return (errors);
}
}
#line 996 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int trim(char **dest , char const   *str ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1001
  tmp = strrchr(str, '\'');
#line 1001
  end = (char const   *)tmp;
  }
#line 1002
  if (str) {
#line 1002
    if (*(str + 0)) {
      {
#line 1002
      tmp___0 = strlen(str);
#line 1002
      tmp___1 = tmp___0;
      }
    } else {
#line 1002
      tmp___1 = (size_t )0;
    }
  } else {
#line 1002
    tmp___1 = (size_t )0;
  }
#line 1002
  len = tmp___1;
#line 1005
  if (*dest) {
    {
#line 1005
    free((void *)*dest);
#line 1005
    *dest = (char *)((void *)0);
    }
  }
#line 1007
  if (! end) {
#line 1008
    return (1);
  } else
#line 1007
  if ((unsigned long )end == (unsigned long )str) {
#line 1008
    return (1);
  }
#line 1010
  if (len > 3UL) {
#line 1010
    if ((int const   )*(str + 0) == 39) {
      {
#line 1012
      tmp___3 = lt__malloc((unsigned long )(end - str) * sizeof(char ));
#line 1012
      tmp___2 = (char *)tmp___3;
      }
#line 1013
      if (! tmp___2) {
#line 1014
        return (1);
      }
      {
#line 1016
      memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(str + 1),
             (size_t )((end - str) - 1L));
#line 1017
      *(tmp___2 + ((end - str) - 1L)) = (char )'\000';
#line 1018
      *dest = tmp___2;
      }
    } else {
#line 1022
      *dest = (char *)0;
    }
  } else {
#line 1022
    *dest = (char *)0;
  }
#line 1025
  return (0);
}
}
#line 1029 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int parse_dotla_file(FILE *file , char **dlname , char **libdir , char **deplibs ,
                            char **old_name , int *installed ) 
{ 
  int errors ;
  size_t line_len ;
  char *line ;
  void *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *last_libname ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 1033
  errors = 0;
#line 1034
  line_len = (size_t )2048;
#line 1035
  tmp = lt__malloc(line_len * sizeof(char ));
#line 1035
  line = (char *)tmp;
  }
#line 1037
  if (! line) {
    {
#line 1039
    tmp___0 = lt__error_string(5);
#line 1039
    lt__set_last_error(tmp___0);
    }
#line 1040
    return (1);
  }
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1043
    tmp___17 = feof(file);
    }
#line 1043
    if (tmp___17) {
#line 1043
      goto while_break;
    }
    {
#line 1045
    *(line + (line_len - 2UL)) = (char )'\000';
#line 1046
    tmp___1 = fgets((char */* __restrict  */)line, (int )line_len, (FILE */* __restrict  */)file);
    }
#line 1046
    if (! tmp___1) {
#line 1048
      goto while_break;
    }
    {
#line 1054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1054
      if ((int )*(line + (line_len - 2UL)) != 0) {
#line 1054
        if ((int )*(line + (line_len - 2UL)) != 10) {
          {
#line 1054
          tmp___4 = feof(file);
          }
#line 1054
          if (tmp___4) {
#line 1054
            goto while_break___0;
          }
        } else {
#line 1054
          goto while_break___0;
        }
      } else {
#line 1054
        goto while_break___0;
      }
      {
#line 1056
      tmp___2 = lt__realloc((void *)line, (line_len * 2UL) * sizeof(char ));
#line 1056
      line = (char *)tmp___2;
      }
#line 1057
      if (! line) {
#line 1059
        errors ++;
#line 1060
        goto cleanup;
      }
      {
#line 1062
      *(line + (line_len * 2UL - 2UL)) = (char )'\000';
#line 1063
      tmp___3 = fgets((char */* __restrict  */)(line + (line_len - 1UL)), (int )line_len + 1,
                      (FILE */* __restrict  */)file);
      }
#line 1063
      if (! tmp___3) {
#line 1065
        goto while_break___0;
      }
#line 1067
      line_len *= 2UL;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1070
    if ((int )*(line + 0) == 10) {
#line 1072
      goto while_continue;
    } else
#line 1070
    if ((int )*(line + 0) == 35) {
#line 1072
      goto while_continue;
    }
    {
#line 1077
    tmp___16 = strncmp((char const   *)line, "dlname=", sizeof("dlname=") - 1UL);
    }
#line 1077
    if (tmp___16 == 0) {
      {
#line 1079
      tmp___5 = trim(dlname, (char const   *)(line + (sizeof("dlname=") - 1UL)));
#line 1079
      errors += tmp___5;
      }
    } else {
      {
#line 1084
      tmp___15 = strncmp((char const   *)line, "old_library=", sizeof("old_library=") - 1UL);
      }
#line 1084
      if (tmp___15 == 0) {
        {
#line 1087
        tmp___6 = trim(old_name, (char const   *)(line + (sizeof("old_library=") - 1UL)));
#line 1087
        errors += tmp___6;
        }
      } else {
        {
#line 1094
        tmp___14 = strncmp((char const   *)line, "libdir=", sizeof("libdir=") - 1UL);
        }
#line 1094
        if (tmp___14 == 0) {
          {
#line 1096
          tmp___7 = trim(libdir, (char const   *)(line + (sizeof("libdir=") - 1UL)));
#line 1096
          errors += tmp___7;
          }
        } else {
          {
#line 1106
          tmp___13 = strncmp((char const   *)line, "dependency_libs=", sizeof("dependency_libs=") - 1UL);
          }
#line 1106
          if (tmp___13 == 0) {
            {
#line 1109
            tmp___8 = trim(deplibs, (char const   *)(line + (sizeof("dependency_libs=") - 1UL)));
#line 1109
            errors += tmp___8;
            }
          } else {
            {
#line 1111
            tmp___12 = strcmp((char const   *)line, "installed=yes\n");
            }
#line 1111
            if (tmp___12) {
              {
#line 1115
              tmp___11 = strcmp((char const   *)line, "installed=no\n");
              }
#line 1115
              if (tmp___11) {
#line 1122
                if (! *dlname) {
                  {
#line 1122
                  tmp___10 = strncmp((char const   *)line, "library_names=", sizeof("library_names=") - 1UL);
                  }
#line 1122
                  if (tmp___10 == 0) {
                    {
#line 1126
                    tmp___9 = trim(dlname, (char const   *)(line + (sizeof("library_names=") - 1UL)));
#line 1126
                    errors += tmp___9;
                    }
#line 1127
                    if (! errors) {
#line 1127
                      if (*dlname) {
                        {
#line 1127
                        last_libname = strrchr((char const   *)*dlname, ' ');
                        }
#line 1127
                        if ((unsigned long )last_libname != (unsigned long )((char *)0)) {
                          {
#line 1131
                          last_libname = lt__strdup((char const   *)(last_libname + 1));
                          }
#line 1132
                          if (! last_libname) {
#line 1134
                            errors ++;
#line 1135
                            goto cleanup;
                          }
#line 1137
                          if ((unsigned long )*dlname != (unsigned long )last_libname) {
#line 1137
                            if (*dlname) {
                              {
#line 1137
                              free((void *)*dlname);
                              }
                            }
#line 1137
                            *dlname = last_libname;
#line 1137
                            last_libname = (char *)0;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
#line 1117
                *installed = 0;
              }
            } else {
#line 1113
              *installed = 1;
            }
          }
        }
      }
    }
#line 1141
    if (errors) {
#line 1142
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1145
  if (line) {
    {
#line 1145
    free((void *)line);
#line 1145
    line = (char *)((void *)0);
    }
  }
#line 1146
  return (errors);
}
}
#line 1151 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int try_dlopen(lt_dlhandle *phandle , char const   *filename , char const   *ext ,
                      lt_dladvise advise ) 
{ 
  char const   *saved_error ;
  char *archive_name ;
  char *canonical ;
  char *base_name ;
  char *dir ;
  char *name ;
  char *attempt ;
  int errors ;
  lt_dlhandle newhandle ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  size_t dirlen ;
  void *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  int i ;
  unsigned short const   **tmp___12 ;
  lt_dlvtable const   *vtable___0 ;
  lt_dlvtable const   *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  FILE *file ;
  char *dlname ;
  char *old_name ;
  char *libdir ;
  char *deplibs ;
  int installed ;
  char const   *search_path ;
  char *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  lt_dlhandle *tmp___31 ;
  char *tmp___32 ;
  lt_dlhandle *tmp___33 ;
  char *tmp___34 ;
  lt_dlhandle *tmp___35 ;
  lt_dlhandle *tmp___36 ;
  int tmp___37 ;

  {
#line 1155
  saved_error = (char const   *)0;
#line 1156
  archive_name = (char *)0;
#line 1157
  canonical = (char *)0;
#line 1158
  base_name = (char *)0;
#line 1159
  dir = (char *)0;
#line 1160
  name = (char *)0;
#line 1161
  attempt = (char *)0;
#line 1162
  errors = 0;
#line 1165
  if (! phandle) {
    {
#line 1165
    __assert_fail("phandle", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1165U, "try_dlopen");
    }
  }
#line 1166
  if (! ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0))) {
    {
#line 1166
    __assert_fail("*phandle == 0", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1166U, "try_dlopen");
    }
  }
  {
#line 1174
  saved_error = lt__get_last_error();
  }
#line 1177
  if (! filename) {
    {
#line 1179
    tmp = lt__zalloc(sizeof(struct lt__handle ));
#line 1179
    *phandle = (lt_dlhandle )tmp;
    }
#line 1180
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1181
      return (1);
    }
    {
#line 1183
    newhandle = *phandle;
#line 1186
    newhandle->info.is_resident = 1U;
#line 1188
    tmp___0 = tryall_dlopen(& newhandle, (char const   *)0, advise, (lt_dlvtable const   *)0);
    }
#line 1188
    if (tmp___0 != 0) {
#line 1190
      if (*phandle) {
        {
#line 1190
        free((void *)*phandle);
#line 1190
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1191
      return (1);
    }
#line 1194
    goto register_handle;
  }
#line 1197
  if (filename) {
#line 1197
    if (! *filename) {
      {
#line 1197
      __assert_fail("filename && *filename", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1197U, "try_dlopen");
      }
    }
  } else {
    {
#line 1197
    __assert_fail("filename && *filename", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1197U, "try_dlopen");
    }
  }
#line 1199
  if (ext) {
#line 1201
    if (filename) {
#line 1201
      if (*(filename + 0)) {
        {
#line 1201
        tmp___1 = strlen(filename);
#line 1201
        tmp___2 = tmp___1;
        }
      } else {
#line 1201
        tmp___2 = (size_t )0;
      }
    } else {
#line 1201
      tmp___2 = (size_t )0;
    }
#line 1201
    if (ext) {
#line 1201
      if (*(ext + 0)) {
        {
#line 1201
        tmp___3 = strlen(ext);
#line 1201
        tmp___4 = tmp___3;
        }
      } else {
#line 1201
        tmp___4 = (size_t )0;
      }
    } else {
#line 1201
      tmp___4 = (size_t )0;
    }
    {
#line 1201
    tmp___5 = lt__malloc(((tmp___2 + tmp___4) + 1UL) * sizeof(char ));
#line 1201
    attempt = (char *)tmp___5;
    }
#line 1202
    if (! attempt) {
#line 1203
      return (1);
    }
    {
#line 1205
    sprintf((char */* __restrict  */)attempt, (char const   */* __restrict  */)"%s%s",
            filename, ext);
    }
  } else {
    {
#line 1209
    attempt = lt__strdup(filename);
    }
#line 1210
    if (! attempt) {
#line 1211
      return (1);
    }
  }
  {
#line 1216
  tmp___6 = canonicalize_path((char const   *)attempt, & canonical);
  }
#line 1216
  if (tmp___6 != 0) {
#line 1218
    errors ++;
#line 1219
    goto cleanup;
  }
  {
#line 1224
  base_name = strrchr((char const   *)canonical, '/');
  }
#line 1225
  if (base_name) {
    {
#line 1227
    dirlen = (size_t )((base_name + 1) - canonical);
#line 1229
    tmp___7 = lt__malloc((1UL + dirlen) * sizeof(char ));
#line 1229
    dir = (char *)tmp___7;
    }
#line 1230
    if (! dir) {
#line 1232
      errors ++;
#line 1233
      goto cleanup;
    }
    {
#line 1236
    strncpy((char */* __restrict  */)dir, (char const   */* __restrict  */)canonical,
            dirlen);
#line 1237
    *(dir + dirlen) = (char )'\000';
#line 1239
    base_name ++;
    }
  } else
#line 1242
  if ((unsigned long )base_name != (unsigned long )canonical) {
#line 1242
    if (base_name) {
      {
#line 1242
      free((void *)base_name);
      }
    }
#line 1242
    base_name = canonical;
#line 1242
    canonical = (char *)0;
  }
#line 1244
  if (base_name) {
#line 1244
    if (! *base_name) {
      {
#line 1244
      __assert_fail("base_name && *base_name", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1244U, "try_dlopen");
      }
    }
  } else {
    {
#line 1244
    __assert_fail("base_name && *base_name", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1244U, "try_dlopen");
    }
  }
  {
#line 1246
  tmp___8 = strrchr((char const   *)base_name, '.');
#line 1246
  ext = (char const   *)tmp___8;
  }
#line 1247
  if (! ext) {
#line 1249
    if (base_name) {
#line 1249
      if (*(base_name + 0)) {
        {
#line 1249
        tmp___9 = strlen((char const   *)base_name);
#line 1249
        tmp___10 = tmp___9;
        }
      } else {
#line 1249
        tmp___10 = (size_t )0;
      }
    } else {
#line 1249
      tmp___10 = (size_t )0;
    }
#line 1249
    ext = (char const   *)(base_name + tmp___10);
  }
  {
#line 1253
  tmp___11 = lt__malloc((unsigned long )((ext - (char const   *)base_name) + 1L) * sizeof(char ));
#line 1253
  name = (char *)tmp___11;
  }
#line 1254
  if (! name) {
#line 1256
    errors ++;
#line 1257
    goto cleanup;
  }
#line 1263
  i = 0;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1263
    if (! ((long )i < ext - (char const   *)base_name)) {
#line 1263
      goto while_break;
    }
    {
#line 1265
    tmp___12 = __ctype_b_loc();
    }
#line 1265
    if ((int const   )*(*tmp___12 + (int )((unsigned char )*(base_name + i))) & 8) {
#line 1267
      *(name + i) = *(base_name + i);
    } else {
#line 1271
      *(name + i) = (char )'_';
    }
#line 1263
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1274
  *(name + (ext - (char const   *)base_name)) = (char )'\000';
#line 1279
  if (! dir) {
    {
#line 1281
    tmp___13 = lt_dlloader_find("lt_preopen");
#line 1281
    vtable___0 = tmp___13;
    }
#line 1283
    if (vtable___0) {
      {
#line 1286
      tmp___14 = strlen(libprefix);
      }
#line 1286
      if (name) {
#line 1286
        if (*(name + 0)) {
          {
#line 1286
          tmp___15 = strlen((char const   *)name);
#line 1286
          tmp___16 = tmp___15;
          }
        } else {
#line 1286
          tmp___16 = (size_t )0;
        }
      } else {
#line 1286
        tmp___16 = (size_t )0;
      }
      {
#line 1286
      tmp___17 = strlen(libext);
#line 1286
      tmp___18 = lt__malloc((((tmp___14 + tmp___16) + tmp___17) + 2UL) * sizeof(char ));
#line 1286
      archive_name = (char *)tmp___18;
#line 1287
      tmp___19 = lt__zalloc(sizeof(struct lt__handle ));
#line 1287
      *phandle = (lt_dlhandle )tmp___19;
      }
#line 1289
      if ((unsigned long )*phandle == (unsigned long )((void *)0)) {
#line 1291
        errors ++;
#line 1292
        goto cleanup;
      } else
#line 1289
      if ((unsigned long )archive_name == (unsigned long )((void *)0)) {
#line 1291
        errors ++;
#line 1292
        goto cleanup;
      }
      {
#line 1294
      newhandle = *phandle;
#line 1298
      tmp___20 = strncmp((char const   *)name, "lib", (size_t )3);
      }
#line 1298
      if (tmp___20 == 0) {
        {
#line 1300
        sprintf((char */* __restrict  */)archive_name, (char const   */* __restrict  */)"%s%s.%s",
                libprefix, name + 3, libext);
        }
      } else {
        {
#line 1304
        sprintf((char */* __restrict  */)archive_name, (char const   */* __restrict  */)"%s.%s",
                name, libext);
        }
      }
      {
#line 1307
      tmp___21 = tryall_dlopen(& newhandle, (char const   *)archive_name, advise,
                               vtable___0);
      }
#line 1307
      if (tmp___21 == 0) {
#line 1309
        goto register_handle;
      }
#line 1314
      if (*phandle) {
        {
#line 1314
        free((void *)*phandle);
#line 1314
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1315
      newhandle = (lt_dlhandle )((void *)0);
    }
  }
#line 1321
  if (advise) {
#line 1321
    if (advise->try_preload_only) {
#line 1323
      goto cleanup;
    }
  }
#line 1327
  if (ext) {
    {
#line 1327
    tmp___37 = strcmp(ext, archive_ext);
    }
#line 1327
    if (tmp___37) {
#line 1327
      goto _L___0;
    } else {
#line 1330
      file = (FILE *)0;
#line 1331
      dlname = (char *)0;
#line 1332
      old_name = (char *)0;
#line 1333
      libdir = (char *)0;
#line 1334
      deplibs = (char *)0;
#line 1339
      installed = 1;
#line 1345
      if (! dir) {
#line 1347
        search_path = (char const   *)user_search_path;
#line 1349
        if (search_path) {
          {
#line 1350
          file = find_file((char const   *)user_search_path, (char const   *)base_name,
                           & dir);
          }
        }
#line 1352
        if (! file) {
          {
#line 1354
          tmp___22 = getenv("LTDL_LIBRARY_PATH");
#line 1354
          search_path = (char const   *)tmp___22;
          }
#line 1355
          if (search_path) {
            {
#line 1356
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1360
        if (! file) {
          {
#line 1362
          tmp___23 = getenv("LD_LIBRARY_PATH");
#line 1362
          search_path = (char const   *)tmp___23;
          }
#line 1363
          if (search_path) {
            {
#line 1364
            file = find_file(search_path, (char const   *)base_name, & dir);
            }
          }
        }
#line 1368
        if (! file) {
#line 1368
          if (sys_dlsearch_path[0]) {
            {
#line 1370
            file = find_file(sys_dlsearch_path, (char const   *)base_name, & dir);
            }
          }
        }
      } else {
        {
#line 1376
        file = fopen((char const   */* __restrict  */)attempt, (char const   */* __restrict  */)"r");
        }
      }
#line 1381
      if (! file) {
        {
#line 1383
        tmp___24 = lt__error_string(5);
#line 1383
        lt__set_last_error(tmp___24);
#line 1384
        errors ++;
        }
#line 1385
        goto cleanup;
      }
      {
#line 1389
      tmp___25 = parse_dotla_file(file, & dlname, & libdir, & deplibs, & old_name,
                                  & installed);
      }
#line 1389
      if (tmp___25 != 0) {
#line 1391
        errors ++;
      }
      {
#line 1393
      fclose(file);
#line 1396
      tmp___26 = lt__zalloc(sizeof(struct lt__handle ));
#line 1396
      *phandle = (lt_dlhandle )tmp___26;
      }
#line 1397
      if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1398
        errors ++;
      }
#line 1400
      if (errors) {
#line 1402
        if (dlname) {
          {
#line 1402
          free((void *)dlname);
#line 1402
          dlname = (char *)((void *)0);
          }
        }
#line 1403
        if (old_name) {
          {
#line 1403
          free((void *)old_name);
#line 1403
          old_name = (char *)((void *)0);
          }
        }
#line 1404
        if (libdir) {
          {
#line 1404
          free((void *)libdir);
#line 1404
          libdir = (char *)((void *)0);
          }
        }
#line 1405
        if (deplibs) {
          {
#line 1405
          free((void *)deplibs);
#line 1405
          deplibs = (char *)((void *)0);
          }
        }
#line 1406
        if (*phandle) {
          {
#line 1406
          free((void *)*phandle);
#line 1406
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1407
        goto cleanup;
      }
#line 1410
      if (! *phandle) {
        {
#line 1410
        __assert_fail("*phandle", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                      1410U, "try_dlopen");
        }
      }
      {
#line 1412
      tmp___28 = load_deplibs(*phandle, deplibs);
      }
#line 1412
      if (tmp___28 == 0) {
        {
#line 1414
        newhandle = *phandle;
#line 1416
        tmp___27 = find_module(& newhandle, (char const   *)dir, (char const   *)libdir,
                               (char const   *)dlname, (char const   *)old_name, installed,
                               advise);
        }
#line 1416
        if (tmp___27) {
          {
#line 1419
          unload_deplibs(*phandle);
#line 1420
          errors ++;
          }
        }
      } else {
#line 1425
        errors ++;
      }
#line 1428
      if (dlname) {
        {
#line 1428
        free((void *)dlname);
#line 1428
        dlname = (char *)((void *)0);
        }
      }
#line 1429
      if (old_name) {
        {
#line 1429
        free((void *)old_name);
#line 1429
        old_name = (char *)((void *)0);
        }
      }
#line 1430
      if (libdir) {
        {
#line 1430
        free((void *)libdir);
#line 1430
        libdir = (char *)((void *)0);
        }
      }
#line 1431
      if (deplibs) {
        {
#line 1431
        free((void *)deplibs);
#line 1431
        deplibs = (char *)((void *)0);
        }
      }
#line 1433
      if (errors) {
#line 1435
        if (*phandle) {
          {
#line 1435
          free((void *)*phandle);
#line 1435
          *phandle = (lt_dlhandle )((void *)0);
          }
        }
#line 1436
        goto cleanup;
      }
#line 1439
      if ((unsigned long )*phandle != (unsigned long )newhandle) {
        {
#line 1441
        unload_deplibs(*phandle);
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1447
    tmp___29 = lt__zalloc(sizeof(struct lt__handle ));
#line 1447
    *phandle = (lt_dlhandle )tmp___29;
    }
#line 1448
    if ((unsigned long )*phandle == (unsigned long )((lt_dlhandle )0)) {
#line 1450
      errors ++;
#line 1451
      goto cleanup;
    }
#line 1454
    newhandle = *phandle;
#line 1460
    if (dir) {
#line 1460
      goto _L;
    } else {
      {
#line 1460
      tmp___31 = find_handle((char const   *)user_search_path, (char const   *)base_name,
                             & newhandle, advise);
      }
#line 1460
      if (! tmp___31) {
        {
#line 1460
        tmp___32 = getenv("LTDL_LIBRARY_PATH");
#line 1460
        tmp___33 = find_handle((char const   *)tmp___32, (char const   *)base_name,
                               & newhandle, advise);
        }
#line 1460
        if (! tmp___33) {
          {
#line 1460
          tmp___34 = getenv("LD_LIBRARY_PATH");
#line 1460
          tmp___35 = find_handle((char const   *)tmp___34, (char const   *)base_name,
                                 & newhandle, advise);
          }
#line 1460
          if (! tmp___35) {
            {
#line 1460
            tmp___36 = find_handle(sys_dlsearch_path, (char const   *)base_name, & newhandle,
                                   advise);
            }
#line 1460
            if (! tmp___36) {
              _L: /* CIL Label */ 
              {
#line 1474
              tmp___30 = tryall_dlopen(& newhandle, (char const   *)attempt, advise,
                                       (lt_dlvtable const   *)0);
              }
#line 1474
              if (tmp___30 != 0) {
#line 1476
                newhandle = (lt_dlhandle )((void *)0);
              }
            }
          }
        }
      }
    }
#line 1480
    if (! newhandle) {
#line 1482
      if (*phandle) {
        {
#line 1482
        free((void *)*phandle);
#line 1482
        *phandle = (lt_dlhandle )((void *)0);
        }
      }
#line 1483
      errors ++;
#line 1484
      goto cleanup;
    }
  }
  register_handle: 
#line 1489
  if ((unsigned long )*phandle != (unsigned long )newhandle) {
#line 1489
    if (*phandle) {
      {
#line 1489
      free((void *)*phandle);
      }
    }
#line 1489
    *phandle = newhandle;
#line 1489
    newhandle = (lt_dlhandle )0;
  }
#line 1491
  if ((*phandle)->info.ref_count == 0) {
#line 1493
    (*phandle)->info.ref_count = 1;
#line 1494
    if ((unsigned long )(*phandle)->info.name != (unsigned long )name) {
#line 1494
      if ((*phandle)->info.name) {
        {
#line 1494
        free((void *)(*phandle)->info.name);
        }
      }
#line 1494
      (*phandle)->info.name = name;
#line 1494
      name = (char *)0;
    }
#line 1496
    (*phandle)->next = handles;
#line 1497
    handles = *phandle;
  }
  {
#line 1500
  lt__set_last_error(saved_error);
  }
  cleanup: 
#line 1503
  if (dir) {
    {
#line 1503
    free((void *)dir);
#line 1503
    dir = (char *)((void *)0);
    }
  }
#line 1504
  if (attempt) {
    {
#line 1504
    free((void *)attempt);
#line 1504
    attempt = (char *)((void *)0);
    }
  }
#line 1505
  if (name) {
    {
#line 1505
    free((void *)name);
#line 1505
    name = (char *)((void *)0);
    }
  }
#line 1506
  if (! canonical) {
#line 1507
    if (base_name) {
      {
#line 1507
      free((void *)base_name);
#line 1507
      base_name = (char *)((void *)0);
      }
    }
  }
#line 1508
  if (canonical) {
    {
#line 1508
    free((void *)canonical);
#line 1508
    canonical = (char *)((void *)0);
    }
  }
#line 1509
  if (archive_name) {
    {
#line 1509
    free((void *)archive_name);
#line 1509
    archive_name = (char *)((void *)0);
    }
  }
#line 1511
  return (errors);
}
}
#line 1517 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int file_not_found(void) 
{ 
  char const   *error ;
  char const   *tmp ;

  {
  {
#line 1520
  error = (char const   *)0;
#line 1522
  error = lt__get_last_error();
#line 1523
  tmp = lt__error_string(5);
  }
#line 1523
  if ((unsigned long )error == (unsigned long )tmp) {
#line 1524
    return (1);
  }
#line 1526
  return (0);
}
}
#line 1532 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int has_library_ext(char const   *filename ) 
{ 
  char const   *ext ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1535
  ext = (char const   *)0;
#line 1537
  if (! filename) {
    {
#line 1537
    __assert_fail("filename", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1537U, "has_library_ext");
    }
  }
  {
#line 1539
  tmp = strrchr(filename, '.');
#line 1539
  ext = (char const   *)tmp;
  }
#line 1541
  if (ext) {
    {
#line 1541
    tmp___0 = strcmp(ext, archive_ext);
    }
#line 1541
    if (tmp___0) {
      {
#line 1541
      tmp___1 = strcmp(ext, shlib_ext);
      }
#line 1541
      if (! tmp___1) {
#line 1550
        return (1);
      }
    } else {
#line 1550
      return (1);
    }
  }
#line 1553
  return (0);
}
}
#line 1559 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_init(lt_dladvise *padvise ) 
{ 
  lt_dladvise advise ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1562
  tmp = lt__zalloc(sizeof(struct lt__advise ));
#line 1562
  advise = (lt_dladvise )tmp;
#line 1563
  *padvise = advise;
  }
#line 1564
  if (advise) {
#line 1564
    tmp___0 = 0;
  } else {
#line 1564
    tmp___0 = 1;
  }
#line 1564
  return (tmp___0);
}
}
#line 1567 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_destroy(lt_dladvise *padvise ) 
{ 


  {
#line 1570
  if (padvise) {
#line 1571
    if (*padvise) {
      {
#line 1571
      free((void *)*padvise);
#line 1571
      *padvise = (lt_dladvise )((void *)0);
      }
    }
  }
#line 1572
  return (0);
}
}
#line 1575 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_ext(lt_dladvise *padvise ) 
{ 


  {
#line 1578
  if (padvise) {
#line 1578
    if (! *padvise) {
      {
#line 1578
      __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1578U, "lt_dladvise_ext");
      }
    }
  } else {
    {
#line 1578
    __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1578U, "lt_dladvise_ext");
    }
  }
#line 1579
  (*padvise)->try_ext = 1U;
#line 1580
  return (0);
}
}
#line 1583 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_resident(lt_dladvise *padvise ) 
{ 


  {
#line 1586
  if (padvise) {
#line 1586
    if (! *padvise) {
      {
#line 1586
      __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1586U, "lt_dladvise_resident");
      }
    }
  } else {
    {
#line 1586
    __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1586U, "lt_dladvise_resident");
    }
  }
#line 1587
  (*padvise)->is_resident = 1U;
#line 1588
  return (0);
}
}
#line 1591 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_local(lt_dladvise *padvise ) 
{ 


  {
#line 1594
  if (padvise) {
#line 1594
    if (! *padvise) {
      {
#line 1594
      __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1594U, "lt_dladvise_local");
      }
    }
  } else {
    {
#line 1594
    __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1594U, "lt_dladvise_local");
    }
  }
#line 1595
  (*padvise)->is_symlocal = 1U;
#line 1596
  return (0);
}
}
#line 1599 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_global(lt_dladvise *padvise ) 
{ 


  {
#line 1602
  if (padvise) {
#line 1602
    if (! *padvise) {
      {
#line 1602
      __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1602U, "lt_dladvise_global");
      }
    }
  } else {
    {
#line 1602
    __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1602U, "lt_dladvise_global");
    }
  }
#line 1603
  (*padvise)->is_symglobal = 1U;
#line 1604
  return (0);
}
}
#line 1607 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladvise_preload(lt_dladvise *padvise ) 
{ 


  {
#line 1610
  if (padvise) {
#line 1610
    if (! *padvise) {
      {
#line 1610
      __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1610U, "lt_dladvise_preload");
      }
    }
  } else {
    {
#line 1610
    __assert_fail("padvise && *padvise", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1610U, "lt_dladvise_preload");
    }
  }
#line 1611
  (*padvise)->try_preload_only = 1U;
#line 1612
  return (0);
}
}
#line 1616 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlhandle lt_dlopen(char const   *filename ) 
{ 
  lt_dlhandle tmp ;

  {
  {
#line 1619
  tmp = lt_dlopenadvise(filename, (lt_dladvise )((void *)0));
  }
#line 1619
  return (tmp);
}
}
#line 1627 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlhandle lt_dlopenext(char const   *filename ) 
{ 
  lt_dlhandle handle ;
  lt_dladvise advise ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1630
  handle = (lt_dlhandle )0;
#line 1633
  tmp = lt_dladvise_init(& advise);
  }
#line 1633
  if (! tmp) {
    {
#line 1633
    tmp___0 = lt_dladvise_ext(& advise);
    }
#line 1633
    if (! tmp___0) {
      {
#line 1634
      handle = lt_dlopenadvise(filename, advise);
      }
    }
  }
  {
#line 1636
  lt_dladvise_destroy(& advise);
  }
#line 1637
  return (handle);
}
}
#line 1641 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlhandle lt_dlopenadvise(char const   *filename , lt_dladvise advise ) 
{ 
  lt_dlhandle handle ;
  int errors ;
  char const   *saved_error ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 1644
  handle = (lt_dlhandle )0;
#line 1645
  errors = 0;
#line 1646
  saved_error = (char const   *)0;
#line 1648
  saved_error = lt__get_last_error();
  }
#line 1651
  if (advise) {
#line 1651
    if (advise->is_symlocal) {
#line 1651
      if (advise->is_symglobal) {
        {
#line 1653
        tmp = lt__error_string(19);
#line 1653
        lt__set_last_error(tmp);
        }
#line 1654
        return ((lt_dlhandle )0);
      }
    }
  }
#line 1657
  if (! filename) {
#line 1657
    goto _L;
  } else
#line 1657
  if (! advise) {
#line 1657
    goto _L;
  } else
#line 1657
  if (! advise->try_ext) {
#line 1657
    goto _L;
  } else {
    {
#line 1657
    tmp___4 = has_library_ext(filename);
    }
#line 1657
    if (tmp___4) {
      _L: /* CIL Label */ 
      {
#line 1664
      tmp___0 = try_dlopen(& handle, filename, (char const   *)((void *)0), advise);
      }
#line 1664
      if (tmp___0 != 0) {
#line 1665
        return ((lt_dlhandle )0);
      }
#line 1667
      return (handle);
    } else
#line 1669
    if (filename) {
#line 1669
      if (*filename) {
        {
#line 1673
        tmp___1 = try_dlopen(& handle, filename, archive_ext, advise);
#line 1673
        errors += tmp___1;
        }
#line 1680
        if (handle) {
#line 1681
          return (handle);
        } else
#line 1680
        if (errors > 0) {
          {
#line 1680
          tmp___2 = file_not_found();
          }
#line 1680
          if (! tmp___2) {
#line 1681
            return (handle);
          }
        }
        {
#line 1685
        lt__set_last_error(saved_error);
#line 1686
        errors = try_dlopen(& handle, filename, shlib_ext, advise);
        }
#line 1690
        if (handle) {
#line 1691
          return (handle);
        } else
#line 1690
        if (errors > 0) {
          {
#line 1690
          tmp___3 = file_not_found();
          }
#line 1690
          if (! tmp___3) {
#line 1691
            return (handle);
          }
        }
      }
    }
  }
  {
#line 1708
  tmp___5 = lt__error_string(5);
#line 1708
  lt__set_last_error(tmp___5);
  }
#line 1709
  return ((lt_dlhandle )0);
}
}
#line 1713 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int lt_argz_insert(char **pargz , size_t *pargz_len , char *before , char const   *entry ) 
{ 
  error_t error ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1721
  if (before) {
    {
#line 1722
    error = argz_insert((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char */* __restrict  */)before, (char const   */* __restrict  */)entry);
    }
  } else {
    {
#line 1724
    tmp = strlen(entry);
#line 1724
    error = argz_append((char **/* __restrict  */)pargz, (size_t */* __restrict  */)pargz_len,
                        (char const   */* __restrict  */)entry, 1UL + tmp);
    }
  }
#line 1726
  if (error) {
    {
#line 1730
    if (error == 12) {
#line 1730
      goto case_12;
    }
#line 1733
    goto switch_default;
    case_12: /* CIL Label */ 
    {
#line 1731
    tmp___0 = lt__error_string(11);
#line 1731
    lt__set_last_error(tmp___0);
    }
#line 1732
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1734
    tmp___1 = lt__error_string(0);
#line 1734
    lt__set_last_error(tmp___1);
    }
#line 1735
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1737
    return (1);
  }
#line 1740
  return (0);
}
}
#line 1743 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int lt_argz_insertinorder(char **pargz , size_t *pargz_len , char const   *entry ) 
{ 
  char *before ;
  int cmp ;
  int tmp ;
  int tmp___0 ;

  {
#line 1746
  before = (char *)0;
#line 1748
  if (! pargz) {
    {
#line 1748
    __assert_fail("pargz", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1748U, "lt_argz_insertinorder");
    }
  }
#line 1749
  if (! pargz_len) {
    {
#line 1749
    __assert_fail("pargz_len", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1749U, "lt_argz_insertinorder");
    }
  }
#line 1750
  if (entry) {
#line 1750
    if (! *entry) {
      {
#line 1750
      __assert_fail("entry && *entry", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1750U, "lt_argz_insertinorder");
      }
    }
  } else {
    {
#line 1750
    __assert_fail("entry && *entry", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1750U, "lt_argz_insertinorder");
    }
  }
#line 1752
  if (*pargz) {
    {
#line 1753
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1753
      before = argz_next((char const   */* __restrict  */)*pargz, *pargz_len, (char const   */* __restrict  */)before);
      }
#line 1753
      if (! before) {
#line 1753
        goto while_break;
      }
      {
#line 1755
      tmp = strcmp(entry, (char const   *)before);
#line 1755
      cmp = tmp;
      }
#line 1757
      if (cmp < 0) {
#line 1757
        goto while_break;
      }
#line 1758
      if (cmp == 0) {
#line 1758
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1761
  tmp___0 = lt_argz_insert(pargz, pargz_len, before, entry);
  }
#line 1761
  return (tmp___0);
}
}
#line 1764 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int lt_argz_insertdir(char **pargz , size_t *pargz_len , char const   *dirnam ,
                             struct dirent *dp ) 
{ 
  char *buf ;
  size_t buf_len ;
  char *end ;
  size_t end_offset ;
  size_t dir_len ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  char *p ;
  char *tmp___1 ;
  char *p___0 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1768
  buf = (char *)0;
#line 1769
  buf_len = (size_t )0;
#line 1770
  end = (char *)0;
#line 1771
  end_offset = (size_t )0;
#line 1772
  dir_len = (size_t )0;
#line 1773
  errors = 0;
#line 1775
  if (! pargz) {
    {
#line 1775
    __assert_fail("pargz", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1775U, "lt_argz_insertdir");
    }
  }
#line 1776
  if (! pargz_len) {
    {
#line 1776
    __assert_fail("pargz_len", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1776U, "lt_argz_insertdir");
    }
  }
#line 1777
  if (! dp) {
    {
#line 1777
    __assert_fail("dp", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1777U, "lt_argz_insertdir");
    }
  }
#line 1779
  if (dirnam) {
#line 1779
    if (*(dirnam + 0)) {
      {
#line 1779
      tmp = strlen(dirnam);
#line 1779
      dir_len = tmp;
      }
    } else {
#line 1779
      dir_len = (size_t )0;
    }
  } else {
#line 1779
    dir_len = (size_t )0;
  }
  {
#line 1780
  tmp___0 = strlen((char const   *)(dp->d_name));
#line 1780
  end = dp->d_name + tmp___0;
#line 1785
  p = end;
  }
  {
#line 1785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1785
    if (! ((unsigned long )(p - 1) > (unsigned long )(dp->d_name))) {
#line 1785
      goto while_break;
    }
    {
#line 1786
    tmp___1 = strchr(".0123456789", (int )*(p + -1));
    }
#line 1786
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
#line 1787
      goto while_break;
    }
#line 1785
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1789
  if ((int )*p == 46) {
#line 1790
    end = p;
  }
#line 1796
  p___0 = end - 1;
  {
#line 1796
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1796
    if (! ((unsigned long )p___0 > (unsigned long )(dp->d_name))) {
#line 1796
      goto while_break___0;
    }
#line 1797
    if ((int )*p___0 == 46) {
#line 1799
      end = p___0;
#line 1800
      goto while_break___0;
    }
#line 1796
    p___0 --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1805
  end_offset = (size_t )(end - dp->d_name);
#line 1806
  buf_len = (dir_len + 1UL) + end_offset;
#line 1807
  tmp___2 = lt__malloc((1UL + buf_len) * sizeof(char ));
#line 1807
  buf = (char *)tmp___2;
  }
#line 1808
  if (! buf) {
#line 1809
    errors ++;
#line 1809
    return (errors);
  }
#line 1811
  if (! buf) {
    {
#line 1811
    __assert_fail("buf", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1811U, "lt_argz_insertdir");
    }
  }
  {
#line 1813
  strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)dirnam);
#line 1814
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"/");
#line 1815
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(dp->d_name),
          end_offset);
#line 1816
  *(buf + buf_len) = (char )'\000';
#line 1819
  tmp___3 = lt_argz_insertinorder(pargz, pargz_len, (char const   *)buf);
  }
#line 1819
  if (tmp___3 != 0) {
#line 1820
    errors ++;
  }
#line 1822
  if (buf) {
    {
#line 1822
    free((void *)buf);
#line 1822
    buf = (char *)((void *)0);
    }
  }
#line 1824
  return (errors);
}
}
#line 1827 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int list_files_by_dir(char const   *dirnam , char **pargz , size_t *pargz_len ) 
{ 
  DIR *dirp ;
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  struct dirent *dp ;
  int tmp___1 ;

  {
#line 1830
  dirp = (DIR *)0;
#line 1831
  errors = 0;
#line 1833
  if (dirnam) {
#line 1833
    if (! *dirnam) {
      {
#line 1833
      __assert_fail("dirnam && *dirnam", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    1833U, "list_files_by_dir");
      }
    }
  } else {
    {
#line 1833
    __assert_fail("dirnam && *dirnam", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1833U, "list_files_by_dir");
    }
  }
#line 1834
  if (! pargz) {
    {
#line 1834
    __assert_fail("pargz", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1834U, "list_files_by_dir");
    }
  }
#line 1835
  if (! pargz_len) {
    {
#line 1835
    __assert_fail("pargz_len", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  1835U, "list_files_by_dir");
    }
  }
#line 1836
  if (dirnam) {
#line 1836
    if (*(dirnam + 0)) {
      {
#line 1836
      tmp = strlen(dirnam);
#line 1836
      tmp___0 = tmp;
      }
    } else {
#line 1836
      tmp___0 = (size_t )0;
    }
  } else {
#line 1836
    tmp___0 = (size_t )0;
  }
#line 1836
  if (! ((int const   )*(dirnam + (tmp___0 - 1UL)) != 47)) {
    {
#line 1836
    __assert_fail("dirnam[(((dirnam) && (dirnam)[0]) ? strlen (dirnam) : 0) -1] != \'/\'",
                  "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c", 1836U,
                  "list_files_by_dir");
    }
  }
  {
#line 1838
  dirp = opendir(dirnam);
  }
#line 1839
  if (dirp) {
#line 1841
    dp = (struct dirent *)0;
    {
#line 1843
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1843
      dp = readdir(dirp);
      }
#line 1843
      if (! dp) {
#line 1843
        goto while_break;
      }
#line 1844
      if ((int )dp->d_name[0] != 46) {
        {
#line 1845
        tmp___1 = lt_argz_insertdir(pargz, pargz_len, dirnam, dp);
        }
#line 1845
        if (tmp___1) {
#line 1847
          errors ++;
#line 1848
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1851
    closedir(dirp);
    }
  } else {
#line 1854
    errors ++;
  }
#line 1856
  return (errors);
}
}
#line 1862 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int foreachfile_callback(char *dirname , void *data1 , void *data2 ) 
{ 
  file_worker_func *func ;
  int is_done ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  char *filename ;

  {
  {
#line 1865
  func = *((file_worker_func **)data1);
#line 1867
  is_done = 0;
#line 1868
  argz = (char *)0;
#line 1869
  argz_len = (size_t )0;
#line 1871
  tmp = list_files_by_dir((char const   *)dirname, & argz, & argz_len);
  }
#line 1871
  if (tmp != 0) {
#line 1872
    goto cleanup;
  }
#line 1873
  if (! argz) {
#line 1874
    goto cleanup;
  }
#line 1877
  filename = (char *)0;
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1878
    filename = argz_next((char const   */* __restrict  */)argz, argz_len, (char const   */* __restrict  */)filename);
    }
#line 1878
    if (! filename) {
#line 1878
      goto while_break;
    }
    {
#line 1879
    is_done = (*func)((char const   *)filename, data2);
    }
#line 1879
    if (is_done) {
#line 1880
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  cleanup: 
#line 1884
  if (argz) {
    {
#line 1884
    free((void *)argz);
#line 1884
    argz = (char *)((void *)0);
    }
  }
#line 1886
  return (is_done);
}
}
#line 1896 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlforeachfile(char const   *search_path , int (*func)(char const   *filename ,
                                                             void *data ) , void *data ) 
{ 
  int is_done ;
  file_worker_func **fpptr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1901
  is_done = 0;
#line 1902
  fpptr = & func;
#line 1904
  if (search_path) {
    {
#line 1908
    is_done = foreach_dirinpath(search_path, (char const   *)0, & foreachfile_callback,
                                (void *)fpptr, data);
    }
  } else {
    {
#line 1914
    is_done = foreach_dirinpath((char const   *)user_search_path, (char const   *)0,
                                & foreachfile_callback, (void *)fpptr, data);
    }
#line 1916
    if (! is_done) {
      {
#line 1918
      tmp = getenv("LTDL_LIBRARY_PATH");
#line 1918
      is_done = foreach_dirinpath((char const   *)tmp, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1923
    if (! is_done) {
      {
#line 1925
      tmp___0 = getenv("LD_LIBRARY_PATH");
#line 1925
      is_done = foreach_dirinpath((char const   *)tmp___0, (char const   *)0, & foreachfile_callback,
                                  (void *)fpptr, data);
      }
    }
#line 1930
    if (! is_done) {
#line 1930
      if (sys_dlsearch_path[0]) {
        {
#line 1932
        is_done = foreach_dirinpath(sys_dlsearch_path, (char const   *)0, & foreachfile_callback,
                                    (void *)fpptr, data);
        }
      }
    }
  }
#line 1938
  return (is_done);
}
}
#line 1941 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlclose(lt_dlhandle handle ) 
{ 
  lt_dlhandle cur ;
  lt_dlhandle last ;
  int errors ;
  char const   *tmp ;
  lt_user_data data ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1945
  errors = 0;
#line 1948
  cur = handles;
#line 1948
  last = cur;
  {
#line 1949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1949
    if (cur) {
#line 1949
      if (! ((unsigned long )handle != (unsigned long )cur)) {
#line 1949
        goto while_break;
      }
    } else {
#line 1949
      goto while_break;
    }
#line 1951
    last = cur;
#line 1952
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1955
  if (! cur) {
    {
#line 1957
    tmp = lt__error_string(12);
#line 1957
    lt__set_last_error(tmp);
#line 1958
    errors ++;
    }
#line 1959
    goto done;
  }
#line 1962
  cur = handle;
#line 1963
  (cur->info.ref_count) --;
#line 1969
  if (cur->info.ref_count <= 0) {
#line 1969
    if (! cur->info.is_resident) {
#line 1971
      data = (lt_user_data )(cur->vtable)->dlloader_data;
#line 1973
      if ((unsigned long )cur != (unsigned long )handles) {
#line 1975
        last->next = cur->next;
      } else {
#line 1979
        handles = cur->next;
      }
      {
#line 1982
      tmp___0 = (*((cur->vtable)->module_close))(data, cur->module);
#line 1982
      errors += tmp___0;
#line 1983
      tmp___1 = unload_deplibs(handle);
#line 1983
      errors += tmp___1;
      }
#line 1986
      if (cur->interface_data) {
        {
#line 1986
        free((void *)cur->interface_data);
#line 1986
        cur->interface_data = (lt_interface_data *)((void *)0);
        }
      }
#line 1988
      if (cur->info.filename) {
        {
#line 1988
        free((void *)cur->info.filename);
#line 1988
        cur->info.filename = (char *)((void *)0);
        }
      }
#line 1989
      if (cur->info.name) {
        {
#line 1989
        free((void *)cur->info.name);
#line 1989
        cur->info.name = (char *)((void *)0);
        }
      }
#line 1990
      if (cur) {
        {
#line 1990
        free((void *)cur);
#line 1990
        cur = (lt_dlhandle )((void *)0);
        }
      }
#line 1992
      goto done;
    }
  }
#line 1995
  if (handle->info.is_resident) {
    {
#line 1997
    tmp___2 = lt__error_string(16);
#line 1997
    lt__set_last_error(tmp___2);
#line 1998
    errors ++;
    }
  }
  done: 
#line 2002
  return (errors);
}
}
#line 2005 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
void *lt_dlsym(lt_dlhandle place , char const   *symbol ) 
{ 
  size_t lensym ;
  char lsym[128] ;
  char *sym ;
  void *address ;
  lt_user_data data ;
  lt_dlhandle handle ;
  char const   *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char const   *saved_error ;

  {
#line 2015
  if (! place) {
    {
#line 2017
    tmp = lt__error_string(12);
#line 2017
    lt__set_last_error(tmp);
    }
#line 2018
    return ((void *)0);
  }
#line 2021
  handle = place;
#line 2023
  if (! symbol) {
    {
#line 2025
    tmp___0 = lt__error_string(10);
#line 2025
    lt__set_last_error(tmp___0);
    }
#line 2026
    return ((void *)0);
  }
#line 2029
  if (symbol) {
#line 2029
    if (*(symbol + 0)) {
      {
#line 2029
      tmp___1 = strlen(symbol);
#line 2029
      tmp___2 = tmp___1;
      }
    } else {
#line 2029
      tmp___2 = (size_t )0;
    }
  } else {
#line 2029
    tmp___2 = (size_t )0;
  }
#line 2029
  if ((handle->vtable)->sym_prefix) {
#line 2029
    if (*((handle->vtable)->sym_prefix + 0)) {
      {
#line 2029
      tmp___3 = strlen((char const   *)(handle->vtable)->sym_prefix);
#line 2029
      tmp___4 = tmp___3;
      }
    } else {
#line 2029
      tmp___4 = (size_t )0;
    }
  } else {
#line 2029
    tmp___4 = (size_t )0;
  }
#line 2029
  if (handle->info.name) {
#line 2029
    if (*(handle->info.name + 0)) {
      {
#line 2029
      tmp___5 = strlen((char const   *)handle->info.name);
#line 2029
      tmp___6 = tmp___5;
      }
    } else {
#line 2029
      tmp___6 = (size_t )0;
    }
  } else {
#line 2029
    tmp___6 = (size_t )0;
  }
#line 2029
  lensym = (tmp___2 + tmp___4) + tmp___6;
#line 2032
  if (lensym + 5UL < 128UL) {
#line 2034
    sym = lsym;
  } else {
    {
#line 2038
    tmp___7 = lt__malloc(((lensym + 5UL) + 1UL) * sizeof(char ));
#line 2038
    sym = (char *)tmp___7;
    }
#line 2039
    if (! sym) {
      {
#line 2041
      tmp___8 = lt__error_string(13);
#line 2041
      lt__set_last_error(tmp___8);
      }
#line 2042
      return ((void *)0);
    }
  }
#line 2046
  data = (lt_user_data )(handle->vtable)->dlloader_data;
#line 2047
  if (handle->info.name) {
    {
#line 2051
    saved_error = lt__get_last_error();
    }
#line 2054
    if ((handle->vtable)->sym_prefix) {
      {
#line 2056
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 2057
      strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    } else {
      {
#line 2061
      strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)handle->info.name);
      }
    }
    {
#line 2064
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)"_LTX_");
#line 2065
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
#line 2068
    address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
    }
#line 2069
    if (address) {
#line 2071
      if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2073
        if (sym) {
          {
#line 2073
          free((void *)sym);
#line 2073
          sym = (char *)((void *)0);
          }
        }
      }
#line 2075
      return (address);
    }
    {
#line 2077
    lt__set_last_error(saved_error);
    }
  }
#line 2081
  if ((handle->vtable)->sym_prefix) {
    {
#line 2083
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)(handle->vtable)->sym_prefix);
#line 2084
    strcat((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  } else {
    {
#line 2088
    strcpy((char */* __restrict  */)sym, (char const   */* __restrict  */)symbol);
    }
  }
  {
#line 2091
  address = (*((handle->vtable)->find_sym))(data, handle->module, (char const   *)sym);
  }
#line 2092
  if ((unsigned long )sym != (unsigned long )(lsym)) {
#line 2094
    if (sym) {
      {
#line 2094
      free((void *)sym);
#line 2094
      sym = (char *)((void *)0);
      }
    }
  }
#line 2097
  return (address);
}
}
#line 2100 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
char const   *lt_dlerror(void) 
{ 
  char const   *error ;

  {
  {
#line 2105
  error = lt__get_last_error();
#line 2106
  lt__set_last_error((char const   *)0);
  }
#line 2108
  return (error);
}
}
#line 2111 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
static int lt_dlpath_insertdir(char **ppath , char *before , char const   *dir ) 
{ 
  int errors ;
  char *canonical ;
  char *argz ;
  size_t argz_len ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2114
  errors = 0;
#line 2115
  canonical = (char *)0;
#line 2116
  argz = (char *)0;
#line 2117
  argz_len = (size_t )0;
#line 2119
  if (! ppath) {
    {
#line 2119
    __assert_fail("ppath", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2119U, "lt_dlpath_insertdir");
    }
  }
#line 2120
  if (dir) {
#line 2120
    if (! *dir) {
      {
#line 2120
      __assert_fail("dir && *dir", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2120U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2120
    __assert_fail("dir && *dir", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2120U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2122
  tmp = canonicalize_path(dir, & canonical);
  }
#line 2122
  if (tmp != 0) {
#line 2124
    errors ++;
#line 2125
    goto cleanup;
  }
#line 2128
  if (canonical) {
#line 2128
    if (! *canonical) {
      {
#line 2128
      __assert_fail("canonical && *canonical", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2128U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2128
    __assert_fail("canonical && *canonical", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2128U, "lt_dlpath_insertdir");
    }
  }
#line 2131
  if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2133
    if (! (! before)) {
      {
#line 2133
      __assert_fail("!before", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2133U, "lt_dlpath_insertdir");
      }
    }
#line 2134
    if (! dir) {
      {
#line 2134
      __assert_fail("dir", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2134U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2136
    *ppath = lt__strdup(dir);
    }
#line 2137
    if ((unsigned long )*ppath == (unsigned long )((char *)0)) {
#line 2138
      errors ++;
    }
#line 2140
    goto cleanup;
  }
#line 2143
  if (ppath) {
#line 2143
    if (! *ppath) {
      {
#line 2143
      __assert_fail("ppath && *ppath", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2143U, "lt_dlpath_insertdir");
      }
    }
  } else {
    {
#line 2143
    __assert_fail("ppath && *ppath", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2143U, "lt_dlpath_insertdir");
    }
  }
  {
#line 2145
  tmp___0 = argzize_path((char const   *)*ppath, & argz, & argz_len);
  }
#line 2145
  if (tmp___0 != 0) {
#line 2147
    errors ++;
#line 2148
    goto cleanup;
  }
#line 2156
  if (before) {
#line 2158
    if (! ((unsigned long )*ppath <= (unsigned long )before)) {
      {
#line 2158
      __assert_fail("*ppath <= before", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2158U, "lt_dlpath_insertdir");
      }
    }
    {
#line 2159
    tmp___1 = strlen((char const   *)*ppath);
    }
#line 2159
    if (! ((int )(before - *ppath) <= (int )tmp___1)) {
      {
#line 2159
      __assert_fail("(int) (before - *ppath) <= (int) strlen (*ppath)", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                    2159U, "lt_dlpath_insertdir");
      }
    }
#line 2161
    before = argz + (before - *ppath);
  }
  {
#line 2164
  tmp___2 = lt_argz_insert(& argz, & argz_len, before, dir);
  }
#line 2164
  if (tmp___2 != 0) {
#line 2166
    errors ++;
#line 2167
    goto cleanup;
  }
  {
#line 2170
  argz_stringify(argz, argz_len, ':');
  }
#line 2171
  if ((unsigned long )*ppath != (unsigned long )argz) {
#line 2171
    if (*ppath) {
      {
#line 2171
      free((void *)*ppath);
      }
    }
#line 2171
    *ppath = argz;
#line 2171
    argz = (char *)0;
  }
  cleanup: 
#line 2174
  if (argz) {
    {
#line 2174
    free((void *)argz);
#line 2174
    argz = (char *)((void *)0);
    }
  }
#line 2175
  if (canonical) {
    {
#line 2175
    free((void *)canonical);
#line 2175
    canonical = (char *)((void *)0);
    }
  }
#line 2177
  return (errors);
}
}
#line 2180 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dladdsearchdir(char const   *search_dir ) 
{ 
  int errors ;
  int tmp ;

  {
#line 2183
  errors = 0;
#line 2185
  if (search_dir) {
#line 2185
    if (*search_dir) {
      {
#line 2187
      tmp = lt_dlpath_insertdir(& user_search_path, (char *)0, search_dir);
      }
#line 2187
      if (tmp != 0) {
#line 2188
        errors ++;
      }
    }
  }
#line 2191
  return (errors);
}
}
#line 2194 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlinsertsearchdir(char const   *before , char const   *search_dir ) 
{ 
  int errors ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2197
  errors = 0;
#line 2199
  if (before) {
#line 2201
    if ((unsigned long )before < (unsigned long )user_search_path) {
      {
#line 2204
      tmp = lt__error_string(18);
#line 2204
      lt__set_last_error(tmp);
      }
#line 2205
      return (1);
    } else {
#line 2201
      if (user_search_path) {
#line 2201
        if (*(user_search_path + 0)) {
          {
#line 2201
          tmp___0 = strlen((char const   *)user_search_path);
#line 2201
          tmp___1 = tmp___0;
          }
        } else {
#line 2201
          tmp___1 = (size_t )0;
        }
      } else {
#line 2201
        tmp___1 = (size_t )0;
      }
#line 2201
      if ((unsigned long )before >= (unsigned long )(user_search_path + tmp___1)) {
        {
#line 2204
        tmp = lt__error_string(18);
#line 2204
        lt__set_last_error(tmp);
        }
#line 2205
        return (1);
      }
    }
  }
#line 2209
  if (search_dir) {
#line 2209
    if (*search_dir) {
      {
#line 2211
      tmp___2 = lt_dlpath_insertdir(& user_search_path, (char *)before, search_dir);
      }
#line 2211
      if (tmp___2 != 0) {
#line 2214
        errors ++;
      }
    }
  }
#line 2218
  return (errors);
}
}
#line 2221 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlsetsearchpath(char const   *search_path ) 
{ 
  int errors ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 2224
  errors = 0;
#line 2226
  if (user_search_path) {
    {
#line 2226
    free((void *)user_search_path);
#line 2226
    user_search_path = (char *)((void *)0);
    }
  }
#line 2228
  if (! search_path) {
#line 2230
    return (errors);
  } else {
#line 2228
    if (search_path) {
#line 2228
      if (*(search_path + 0)) {
        {
#line 2228
        tmp = strlen(search_path);
#line 2228
        tmp___0 = tmp;
        }
      } else {
#line 2228
        tmp___0 = (size_t )0;
      }
    } else {
#line 2228
      tmp___0 = (size_t )0;
    }
#line 2228
    if (! tmp___0) {
#line 2230
      return (errors);
    }
  }
  {
#line 2233
  tmp___1 = canonicalize_path(search_path, & user_search_path);
  }
#line 2233
  if (tmp___1 != 0) {
#line 2234
    errors ++;
  }
#line 2236
  return (errors);
}
}
#line 2239 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
char const   *lt_dlgetsearchpath(void) 
{ 
  char const   *saved_path ;

  {
#line 2244
  saved_path = (char const   *)user_search_path;
#line 2246
  return (saved_path);
}
}
#line 2249 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlmakeresident(lt_dlhandle handle ) 
{ 
  int errors ;
  char const   *tmp ;

  {
#line 2252
  errors = 0;
#line 2254
  if (! handle) {
    {
#line 2256
    tmp = lt__error_string(12);
#line 2256
    lt__set_last_error(tmp);
#line 2257
    errors ++;
    }
  } else {
#line 2261
    handle->info.is_resident = 1U;
  }
#line 2264
  return (errors);
}
}
#line 2267 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlisresident(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2270
  if (! handle) {
    {
#line 2272
    tmp = lt__error_string(12);
#line 2272
    lt__set_last_error(tmp);
    }
#line 2273
    return (-1);
  }
#line 2276
  return ((int )handle->info.is_resident);
}
}
#line 2288 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlinterface_id lt_dlinterface_register(char const   *id_string___0 , lt_dlhandle_interface *iface ) 
{ 
  lt__interface_id *interface_id ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 2291
  tmp = lt__malloc(sizeof(*interface_id));
#line 2291
  interface_id = (lt__interface_id *)tmp;
  }
#line 2295
  if (interface_id) {
    {
#line 2297
    tmp___0 = lt__strdup(id_string___0);
#line 2297
    interface_id->id_string = (char const   *)tmp___0;
    }
#line 2298
    if (! interface_id->id_string) {
#line 2299
      if (interface_id) {
        {
#line 2299
        free((void *)interface_id);
#line 2299
        interface_id = (lt__interface_id *)((void *)0);
        }
      }
    } else {
#line 2301
      interface_id->iface = iface;
    }
  }
#line 2304
  return ((lt_dlinterface_id )interface_id);
}
}
#line 2307 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
void lt_dlinterface_free(lt_dlinterface_id key ) 
{ 
  lt__interface_id *interface_id ;

  {
#line 2309
  interface_id = (lt__interface_id *)key;
#line 2310
  if (interface_id->id_string) {
    {
#line 2310
    free((void *)interface_id->id_string);
#line 2310
    interface_id->id_string = (char const   *)((void *)0);
    }
  }
#line 2311
  if (interface_id) {
    {
#line 2311
    free((void *)interface_id);
#line 2311
    interface_id = (lt__interface_id *)((void *)0);
    }
  }
#line 2312
  return;
}
}
#line 2314 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
void *lt_dlcaller_set_data(lt_dlinterface_id key , lt_dlhandle handle , void *data ) 
{ 
  int n_elements ;
  void *stale ;
  lt_dlhandle cur ;
  int i ;
  lt_interface_data *temp ;
  void *tmp ;

  {
#line 2317
  n_elements = 0;
#line 2318
  stale = (void *)0;
#line 2319
  cur = handle;
#line 2322
  if (cur->interface_data) {
    {
#line 2323
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2323
      if (! (cur->interface_data + n_elements)->key) {
#line 2323
        goto while_break;
      }
#line 2324
      n_elements ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2326
  i = 0;
  {
#line 2326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2326
    if (! (i < n_elements)) {
#line 2326
      goto while_break___0;
    }
#line 2328
    if ((unsigned long )(cur->interface_data + i)->key == (unsigned long )key) {
#line 2330
      stale = (cur->interface_data + i)->data;
#line 2331
      goto while_break___0;
    }
#line 2326
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2337
  if (i == n_elements) {
    {
#line 2339
    tmp = lt__realloc((void *)cur->interface_data, (unsigned long )(2 + n_elements) * sizeof(lt_interface_data ));
#line 2339
    temp = (lt_interface_data *)tmp;
    }
#line 2342
    if (! temp) {
#line 2344
      stale = (void *)0;
#line 2345
      goto done;
    }
#line 2348
    cur->interface_data = temp;
#line 2351
    (cur->interface_data + i)->key = key;
#line 2352
    (cur->interface_data + (1 + i))->key = (lt_dlinterface_id )0;
  }
#line 2355
  (cur->interface_data + i)->data = data;
  done: 
#line 2358
  return (stale);
}
}
#line 2361 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
void *lt_dlcaller_get_data(lt_dlinterface_id key , lt_dlhandle handle ) 
{ 
  void *result ;
  lt_dlhandle cur ;
  int i ;

  {
#line 2364
  result = (void *)0;
#line 2365
  cur = handle;
#line 2368
  if (cur->interface_data) {
#line 2371
    i = 0;
    {
#line 2371
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2371
      if (! (cur->interface_data + i)->key) {
#line 2371
        goto while_break;
      }
#line 2373
      if ((unsigned long )(cur->interface_data + i)->key == (unsigned long )key) {
#line 2375
        result = (cur->interface_data + i)->data;
#line 2376
        goto while_break;
      }
#line 2371
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2381
  return (result);
}
}
#line 2384 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlinfo const   *lt_dlgetinfo(lt_dlhandle handle ) 
{ 
  char const   *tmp ;

  {
#line 2387
  if (! handle) {
    {
#line 2389
    tmp = lt__error_string(12);
#line 2389
    lt__set_last_error(tmp);
    }
#line 2390
    return ((lt_dlinfo const   *)0);
  }
#line 2393
  return ((lt_dlinfo const   *)(& handle->info));
}
}
#line 2397 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_iterate(lt_dlinterface_id iface , lt_dlhandle place ) 
{ 
  lt_dlhandle handle ;
  lt__interface_id *iterator ;
  int tmp ;

  {
#line 2400
  handle = place;
#line 2401
  iterator = (lt__interface_id *)iface;
#line 2403
  if (! iface) {
    {
#line 2403
    __assert_fail("iface", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2403U, "lt_dlhandle_iterate");
    }
  }
#line 2405
  if (! handle) {
#line 2406
    handle = handles;
  } else {
#line 2408
    handle = handle->next;
  }
  {
#line 2411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2411
    if (handle) {
#line 2411
      if (iterator->iface) {
        {
#line 2411
        tmp = (*(iterator->iface))(handle, iterator->id_string);
        }
#line 2411
        if (! (tmp != 0)) {
#line 2411
          goto while_break;
        }
      } else {
#line 2411
        goto while_break;
      }
    } else {
#line 2411
      goto while_break;
    }
#line 2414
    handle = handle->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2417
  return (handle);
}
}
#line 2421 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
lt_dlhandle lt_dlhandle_fetch(lt_dlinterface_id iface , char const   *module_name ) 
{ 
  lt_dlhandle handle ;
  lt_dlhandle cur ;
  int tmp ;

  {
#line 2424
  handle = (lt_dlhandle )0;
#line 2426
  if (! iface) {
    {
#line 2426
    __assert_fail("iface", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2426U, "lt_dlhandle_fetch");
    }
  }
  {
#line 2428
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2428
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 2428
    if (! handle) {
#line 2428
      goto while_break;
    }
#line 2430
    cur = handle;
#line 2431
    if (cur) {
#line 2431
      if (cur->info.name) {
        {
#line 2431
        tmp = strcmp((char const   *)cur->info.name, module_name);
        }
#line 2431
        if (! tmp) {
#line 2432
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2435
  return (handle);
}
}
#line 2439 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c"
int lt_dlhandle_map(lt_dlinterface_id iface , int (*func)(lt_dlhandle handle , void *data ) ,
                    void *data ) 
{ 
  lt__interface_id *iterator ;
  lt_dlhandle cur ;
  int errorcode ;
  int tmp ;

  {
#line 2443
  iterator = (lt__interface_id *)iface;
#line 2444
  cur = handles;
#line 2446
  if (! iface) {
    {
#line 2446
    __assert_fail("iface", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/ltdl.c",
                  2446U, "lt_dlhandle_map");
    }
  }
  {
#line 2448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2448
    if (! cur) {
#line 2448
      goto while_break;
    }
#line 2450
    errorcode = 0;
    {
#line 2453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2453
      if (cur) {
#line 2453
        if (iterator->iface) {
          {
#line 2453
          tmp = (*(iterator->iface))(cur, iterator->id_string);
          }
#line 2453
          if (! (tmp != 0)) {
#line 2453
            goto while_break___0;
          }
        } else {
#line 2453
          goto while_break___0;
        }
      } else {
#line 2453
        goto while_break___0;
      }
#line 2456
      cur = cur->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2459
    errorcode = (*func)(cur, data);
    }
#line 2459
    if (errorcode != 0) {
#line 2460
      return (errorcode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2463
  return (0);
}
}
#line 45 "./libltdl/libltdl/lt__strl.h"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) ;
#line 50 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c"
size_t lt_strlcat(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;

  {
#line 57
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 57
    __assert_fail("dst != ((void *)0)", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  57U, "lt_strlcat");
    }
  }
#line 58
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 58
    __assert_fail("src != (const char *) ((void *)0)", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  58U, "lt_strlcat");
    }
  }
#line 59
  if (! (dstsize >= 1UL)) {
    {
#line 59
    __assert_fail("dstsize >= 1", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  59U, "lt_strlcat");
    }
  }
  {
#line 61
  length = strlen((char const   *)dst);
#line 67
  p = dst + length;
#line 67
  q = src;
  }
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if ((int const   )*q != 0) {
#line 67
      if (! (length < (size_t )(dstsize - 1UL))) {
#line 67
        goto while_break;
      }
    } else {
#line 67
      goto while_break;
    }
#line 70
    *p = (char )*q;
#line 67
    length ++;
#line 67
    p ++;
#line 67
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  *(dst + length) = (char )'\000';
  {
#line 77
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 77
    tmp = q;
#line 77
    q ++;
#line 77
    if (! *tmp) {
#line 77
      goto while_break___0;
    }
#line 78
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 80
  return (length);
}
}
#line 98 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c"
size_t lt_strlcpy(char *dst , char const   *src , size_t const   dstsize ) 
{ 
  size_t length ;
  char *p ;
  char const   *q ;
  char const   *tmp ;

  {
#line 101
  length = (size_t )0;
#line 105
  if (! ((unsigned long )dst != (unsigned long )((void *)0))) {
    {
#line 105
    __assert_fail("dst != ((void *)0)", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  105U, "lt_strlcpy");
    }
  }
#line 106
  if (! ((unsigned long )src != (unsigned long )((char const   *)((void *)0)))) {
    {
#line 106
    __assert_fail("src != (const char *) ((void *)0)", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  106U, "lt_strlcpy");
    }
  }
#line 107
  if (! (dstsize >= 1UL)) {
    {
#line 107
    __assert_fail("dstsize >= 1", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__strl.c",
                  107U, "lt_strlcpy");
    }
  }
#line 112
  p = dst;
#line 112
  q = src;
#line 112
  length = (size_t )0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((int const   )*q != 0) {
#line 112
      if (! (length < (size_t )(dstsize - 1UL))) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 115
    *p = (char )*q;
#line 112
    length ++;
#line 112
    p ++;
#line 112
    q ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  *(dst + length) = (char )'\000';
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 122
    tmp = q;
#line 122
    q ++;
#line 122
    if (! *tmp) {
#line 122
      goto while_break___0;
    }
#line 123
    length ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  return (length);
}
}
#line 100 "libltdl/ltdl.h"
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) ;
#line 48 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 49
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) ;
#line 50
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename ,
                         lt_dladvise advise  __attribute__((__unused__)) ) ;
#line 52
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) ;
#line 53
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) ;
#line 56 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static lt_dlvtable *vtable  =    (lt_dlvtable *)0;
#line 61 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
lt_dlvtable const   *preopen_LTX_get_vtable(lt_user_data loader_data ) 
{ 
  void *tmp ;
  char const   *tmp___0 ;

  {
#line 64
  if (! vtable) {
    {
#line 66
    tmp = lt__zalloc(sizeof(*vtable));
#line 66
    vtable = (lt_dlvtable *)tmp;
    }
  }
#line 69
  if (vtable) {
#line 69
    if (! vtable->name) {
#line 71
      vtable->name = "lt_preopen";
#line 72
      vtable->sym_prefix = (char const   *)0;
#line 73
      vtable->module_open = & vm_open;
#line 74
      vtable->module_close = & vm_close;
#line 75
      vtable->find_sym = & vm_sym;
#line 76
      vtable->dlloader_init = & vl_init;
#line 77
      vtable->dlloader_exit = & vl_exit;
#line 78
      vtable->dlloader_data = loader_data;
#line 79
      vtable->priority = (lt_dlloader_priority )0;
    }
  }
#line 82
  if (vtable) {
#line 82
    if ((unsigned long )vtable->dlloader_data != (unsigned long )loader_data) {
      {
#line 84
      tmp___0 = lt__error_string(3);
#line 84
      lt__set_last_error(tmp___0);
      }
#line 85
      return ((lt_dlvtable *)0);
    }
  }
#line 88
  return (vtable);
}
}
#line 104
static int add_symlist(lt_dlsymlist const   *symlist ) ;
#line 105
static int free_symlists(void) ;
#line 108 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static symlist_chain *preloaded_symlists  =    (symlist_chain *)0;
#line 111 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static lt_dlsymlist const   *default_preloaded_symbols  =    (lt_dlsymlist const   *)0;
#line 115 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int vl_init(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 
  int errors ;

  {
#line 118
  errors = 0;
#line 120
  preloaded_symlists = (symlist_chain *)0;
#line 121
  if (default_preloaded_symbols) {
    {
#line 123
    errors = lt_dlpreload(default_preloaded_symbols);
    }
  }
#line 126
  return (errors);
}
}
#line 132 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int vl_exit(lt_user_data loader_data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 135
  vtable = (lt_dlvtable *)((void *)0);
#line 136
  free_symlists();
  }
#line 137
  return (0);
}
}
#line 144 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static lt_module vm_open(lt_user_data loader_data  __attribute__((__unused__)) , char const   *filename ,
                         lt_dladvise advise  __attribute__((__unused__)) ) 
{ 
  symlist_chain *lists ;
  lt_module module ;
  char const   *tmp ;
  lt_dlsymlist const   *symbol ;
  lt_dlsymlist const   *next_symbol ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 149
  module = (lt_module )0;
#line 151
  if (! preloaded_symlists) {
    {
#line 153
    tmp = lt__error_string(7);
#line 153
    lt__set_last_error(tmp);
    }
#line 154
    goto done;
  }
#line 161
  if (! filename) {
#line 163
    filename = "@PROGRAM@";
  }
#line 166
  lists = preloaded_symlists;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! lists) {
#line 166
      goto while_break;
    }
#line 169
    symbol = lists->symlist;
    {
#line 169
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 169
      if (! symbol->name) {
#line 169
        goto while_break___0;
      }
#line 171
      if (! symbol->address) {
        {
#line 171
        tmp___0 = strcmp((char const   *)symbol->name, filename);
        }
#line 171
        if (! tmp___0) {
#line 178
          next_symbol = symbol + 1;
#line 179
          if (next_symbol->address) {
#line 179
            if (next_symbol->name) {
#line 181
              module = (lt_module )lists->symlist;
#line 182
              goto done;
            }
          }
        }
      }
#line 169
      symbol ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 166
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  tmp___1 = lt__error_string(5);
#line 188
  lt__set_last_error(tmp___1);
  }
  done: 
#line 191
  return (module);
}
}
#line 197 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int vm_close(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module  __attribute__((__unused__)) ) 
{ 


  {
#line 201
  module = (lt_module )0;
#line 202
  return (0);
}
}
#line 208 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static void *vm_sym(lt_user_data loader_data  __attribute__((__unused__)) , lt_module module ,
                    char const   *name ) 
{ 
  lt_dlsymlist *symbol ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 211
  symbol = (lt_dlsymlist *)module;
#line 213
  symbol += 2;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! symbol->name) {
#line 215
      goto while_break;
    }
    {
#line 217
    tmp = strcmp(symbol->name, name);
    }
#line 217
    if (! tmp) {
#line 219
      return (symbol->address);
    }
#line 222
    symbol ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  tmp___0 = lt__error_string(10);
#line 225
  lt__set_last_error(tmp___0);
  }
#line 227
  return ((void *)0);
}
}
#line 237 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int free_symlists(void) 
{ 
  symlist_chain *lists ;
  symlist_chain *next ;

  {
#line 242
  lists = preloaded_symlists;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! lists) {
#line 243
      goto while_break;
    }
#line 245
    next = lists->next;
#line 246
    if (lists) {
      {
#line 246
      free((void *)lists);
#line 246
      lists = (symlist_chain *)((void *)0);
      }
    }
#line 247
    lists = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  preloaded_symlists = (symlist_chain *)0;
#line 251
  return (0);
}
}
#line 255 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
static int add_symlist(lt_dlsymlist const   *symlist ) 
{ 
  symlist_chain *lists ;
  int errors ;
  symlist_chain *tmp ;
  void *tmp___0 ;

  {
#line 259
  errors = 0;
#line 262
  lists = preloaded_symlists;
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (lists) {
#line 262
      if (! ((unsigned long )lists->symlist != (unsigned long )symlist)) {
#line 262
        goto while_break;
      }
    } else {
#line 262
      goto while_break;
    }
#line 262
    lists = lists->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (! lists) {
    {
#line 269
    tmp___0 = lt__zalloc(sizeof(*tmp));
#line 269
    tmp = (symlist_chain *)tmp___0;
    }
#line 271
    if (tmp) {
#line 273
      tmp->symlist = symlist;
#line 274
      tmp->next = preloaded_symlists;
#line 275
      preloaded_symlists = tmp;
    } else {
#line 279
      errors ++;
    }
  }
#line 283
  return (errors);
}
}
#line 292 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
int lt_dlpreload_default(lt_dlsymlist const   *preloaded ) 
{ 


  {
#line 295
  default_preloaded_symbols = preloaded;
#line 296
  return (0);
}
}
#line 302 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
int lt_dlpreload(lt_dlsymlist const   *preloaded ) 
{ 
  int errors ;

  {
#line 305
  errors = 0;
#line 307
  if (preloaded) {
    {
#line 309
    errors = add_symlist(preloaded);
    }
  } else {
    {
#line 313
    free_symlists();
    }
#line 315
    if (default_preloaded_symbols) {
      {
#line 317
      errors = lt_dlpreload(default_preloaded_symbols);
      }
    }
  }
#line 321
  return (errors);
}
}
#line 328 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/loaders/preopen.c"
int lt_dlpreload_open(char const   *originator , lt_dlpreload_callback_func *func ) 
{ 
  symlist_chain *list ;
  int errors ;
  int found ;
  lt_dlsymlist const   *symbol ;
  unsigned int idx ;
  lt_dlhandle handle ;
  lt_dlhandle tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
#line 332
  errors = 0;
#line 333
  found = 0;
#line 336
  list = preloaded_symlists;
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! list) {
#line 336
      goto while_break;
    }
#line 339
    if (originator) {
      {
#line 339
      tmp___2 = strcmp((char const   *)(list->symlist)->name, originator);
      }
#line 339
      if (tmp___2) {
#line 339
        goto _L___0;
      } else {
#line 339
        goto _L;
      }
    } else
    _L___0: /* CIL Label */ 
#line 339
    if (! originator) {
      {
#line 339
      tmp___3 = strcmp((char const   *)(list->symlist)->name, "@PROGRAM@");
      }
#line 339
      if (! tmp___3) {
        _L: /* CIL Label */ 
#line 343
        idx = 0U;
#line 345
        found ++;
        {
#line 349
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 349
          idx ++;
#line 349
          symbol = list->symlist + idx;
#line 349
          if (! ((unsigned long )symbol->name != (unsigned long )((char const   */* const  */)0))) {
#line 349
            goto while_break___0;
          }
#line 351
          if ((unsigned long )symbol->address == (unsigned long )((void */* const  */)0)) {
            {
#line 351
            tmp___1 = strcmp((char const   *)symbol->name, "@PROGRAM@");
            }
#line 351
            if (tmp___1 != 0) {
              {
#line 354
              tmp = lt_dlopen((char const   *)symbol->name);
#line 354
              handle = tmp;
              }
#line 355
              if ((unsigned long )handle == (unsigned long )((lt_dlhandle )0)) {
#line 357
                errors ++;
              } else {
                {
#line 361
                tmp___0 = (*func)(handle);
#line 361
                errors += tmp___0;
                }
              }
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 336
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (! found) {
    {
#line 370
    tmp___4 = lt__error_string(8);
#line 370
    lt__set_last_error(tmp___4);
#line 371
    errors ++;
    }
  }
#line 374
  return (errors);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 52 "./libltdl/libltdl/lt__alloc.h"
void *lt__memdup(void const   *mem , size_t n ) ;
#line 37 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
static void alloc_die_default(void) ;
#line 39 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
void (*lt__alloc_die)(void)  =    & alloc_die_default;
#line 42 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
static void alloc_die_default(void) 
{ 


  {
  {
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory.\n");
#line 46
  exit(1);
  }
}
}
#line 49 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
void *lt__malloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 54
  mem = malloc(n);
  }
#line 54
  if (! mem) {
    {
#line 55
    (*lt__alloc_die)();
    }
  }
#line 57
  return (mem);
}
}
#line 60 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
void *lt__zalloc(size_t n ) 
{ 
  void *mem ;

  {
  {
#line 65
  mem = lt__malloc(n);
  }
#line 65
  if (mem) {
    {
#line 66
    memset(mem, 0, n);
    }
  }
#line 68
  return (mem);
}
}
#line 71 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
void *lt__realloc(void *mem , size_t n ) 
{ 


  {
  {
#line 74
  mem = realloc(mem, n);
  }
#line 74
  if (! mem) {
    {
#line 75
    (*lt__alloc_die)();
    }
  }
#line 77
  return (mem);
}
}
#line 80 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
void *lt__memdup(void const   *mem , size_t n ) 
{ 
  void *newmem ;
  void *tmp ;

  {
  {
#line 85
  newmem = lt__malloc(n);
  }
#line 85
  if (newmem) {
    {
#line 86
    tmp = memcpy((void */* __restrict  */)newmem, (void const   */* __restrict  */)mem,
                 n);
    }
#line 86
    return (tmp);
  }
#line 88
  return ((void *)0);
}
}
#line 91 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt__alloc.c"
char *lt__strdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 94
  tmp = strlen(string);
#line 94
  tmp___0 = lt__memdup((void const   *)string, tmp + 1UL);
  }
#line 94
  return ((char *)tmp___0);
}
}
#line 37 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) ;
#line 41 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
static SList *loaders  =    (SList *)0;
#line 47 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
static void *loader_callback(SList *item , void *userdata ) 
{ 
  lt_dlvtable const   *vtable___0 ;
  char const   *name ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 50
  vtable___0 = (lt_dlvtable const   *)item->userdata;
#line 51
  name = (char const   *)userdata;
#line 53
  if (! vtable___0) {
    {
#line 53
    __assert_fail("vtable", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c",
                  53U, "loader_callback");
    }
  }
  {
#line 55
  tmp___1 = strcmp((char const   *)vtable___0->name, name);
  }
#line 55
  if (tmp___1) {
#line 55
    tmp___0 = (void *)0;
  } else {
#line 55
    tmp___0 = (void *)item;
  }
#line 55
  return (tmp___0);
}
}
#line 61 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
int lt_dlloader_add(lt_dlvtable const   *vtable___0 ) 
{ 
  SList *item ;
  char const   *tmp ;

  {
#line 66
  if ((unsigned long )vtable___0 == (unsigned long )((lt_dlvtable const   *)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___0->module_open == (unsigned long )((lt_module_open */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___0->module_close == (unsigned long )((lt_module_close */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned long )vtable___0->find_sym == (unsigned long )((lt_find_sym */* const  */)0)) {
    {
#line 73
    tmp = lt__error_string(2);
#line 73
    lt__set_last_error(tmp);
    }
#line 74
    return (1);
  } else
#line 66
  if ((unsigned int const   )vtable___0->priority != 0U) {
#line 66
    if ((unsigned int const   )vtable___0->priority != 1U) {
      {
#line 73
      tmp = lt__error_string(2);
#line 73
      lt__set_last_error(tmp);
      }
#line 74
      return (1);
    }
  }
  {
#line 77
  item = lt__slist_box((void const   *)vtable___0);
  }
#line 78
  if (! item) {
    {
#line 80
    (*lt__alloc_die)();
    }
#line 84
    return (1);
  }
#line 87
  if ((unsigned int const   )vtable___0->priority == 0U) {
    {
#line 89
    loaders = lt__slist_cons(item, loaders);
    }
  } else {
#line 93
    if (! ((unsigned int const   )vtable___0->priority == 1U)) {
      {
#line 93
      __assert_fail("vtable->priority == LT_DLLOADER_APPEND", "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c",
                    93U, "lt_dlloader_add");
      }
    }
    {
#line 94
    loaders = lt__slist_concat(loaders, item);
    }
  }
#line 97
  return (0);
}
}
#line 130 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
lt_dlloader lt_dlloader_next(lt_dlloader const   loader ) 
{ 
  SList *item ;
  struct slist *tmp ;

  {
#line 133
  item = (SList *)loader;
#line 134
  if (item) {
#line 134
    tmp = item->next;
  } else {
#line 134
    tmp = loaders;
  }
#line 134
  return ((lt_dlloader )tmp);
}
}
#line 139 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_get(lt_dlloader loader ) 
{ 
  void const   *tmp ;

  {
#line 142
  if (loader) {
#line 142
    tmp = ((SList *)loader)->userdata;
  } else {
#line 142
    tmp = (void const   *)((void *)0);
  }
#line 142
  return ((lt_dlvtable const   *)tmp);
}
}
#line 156 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
static char const   id_string[19]  = 
#line 156
  {      (char const   )'l',      (char const   )'t',      (char const   )'_',      (char const   )'d', 
        (char const   )'l',      (char const   )'l',      (char const   )'o',      (char const   )'a', 
        (char const   )'d',      (char const   )'e',      (char const   )'r',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'m',      (char const   )'o', 
        (char const   )'v',      (char const   )'e',      (char const   )'\000'};
#line 152 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
lt_dlvtable *lt_dlloader_remove(char const   *name ) 
{ 
  lt_dlvtable const   *vtable___0 ;
  lt_dlvtable const   *tmp ;
  lt_dlinterface_id iface ;
  lt_dlhandle handle ;
  int in_use ;
  int in_use_by_resident ;
  char const   *tmp___0 ;
  lt_dlhandle cur ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  SList *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 155
  tmp = lt_dlloader_find(name);
#line 155
  vtable___0 = tmp;
#line 158
  handle = (lt_dlhandle )0;
#line 159
  in_use = 0;
#line 160
  in_use_by_resident = 0;
  }
#line 162
  if (! vtable___0) {
    {
#line 164
    tmp___0 = lt__error_string(2);
#line 164
    lt__set_last_error(tmp___0);
    }
#line 165
    return ((lt_dlvtable *)0);
  }
  {
#line 169
  iface = lt_dlinterface_register(id_string, (lt_dlhandle_interface *)((void *)0));
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 170
    handle = lt_dlhandle_iterate(iface, handle);
    }
#line 170
    if (! handle) {
#line 170
      goto while_break;
    }
#line 172
    cur = handle;
#line 173
    if ((unsigned long )cur->vtable == (unsigned long )vtable___0) {
      {
#line 175
      in_use = 1;
#line 176
      tmp___1 = lt_dlisresident(handle);
      }
#line 176
      if (tmp___1) {
#line 177
        in_use_by_resident = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  lt_dlinterface_free(iface);
  }
#line 181
  if (in_use) {
#line 183
    if (! in_use_by_resident) {
      {
#line 184
      tmp___2 = lt__error_string(4);
#line 184
      lt__set_last_error(tmp___2);
      }
    }
#line 185
    return ((lt_dlvtable *)0);
  }
#line 189
  if (vtable___0) {
#line 189
    if (vtable___0->dlloader_exit) {
      {
#line 191
      tmp___3 = (*(vtable___0->dlloader_exit))((lt_user_data )vtable___0->dlloader_data);
      }
#line 191
      if (tmp___3 != 0) {
#line 196
        return ((lt_dlvtable *)0);
      }
    }
  }
  {
#line 201
  tmp___4 = lt__slist_remove(& loaders, & loader_callback, (void *)name);
#line 201
  tmp___5 = lt__slist_unbox(tmp___4);
  }
#line 201
  return ((lt_dlvtable *)tmp___5);
}
}
#line 206 "/home/wheatley/newnew/temp/libtool-2.4.2/libltdl/lt_dlloader.c"
lt_dlvtable const   *lt_dlloader_find(char const   *name ) 
{ 
  void *tmp ;
  lt_dlvtable const   *tmp___0 ;

  {
  {
#line 209
  tmp = lt__slist_find(loaders, & loader_callback, (void *)name);
#line 209
  tmp___0 = lt_dlloader_get(tmp);
  }
#line 209
  return (tmp___0);
}
}
