/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_un;
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct line {
   char *line ;
   int labelcount ;
   int lineno ;
   struct line *next ;
};
#line 58 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct var {
   char *name ;
   int value ;
   struct var *next ;
};
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct env {
   struct line *lines ;
   struct var *vars ;
   char const   *scriptname ;
   int verbose ;
   jmp_buf ebuf ;
   int exstat ;
};
#line 670 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 672 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 671 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
#line 669 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
union __anonunion_65 {
   int __in ;
   int __i ;
};
#line 984 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct kw {
   char const   *command ;
   int (*fn)(char * ) ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/configsym.h"
struct pars {
   char value[128] ;
   int flags ;
   char const   *desc ;
};
#line 28 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
struct _elm {
   wchar_t value ;
   char attr ;
   char color ;
};
#line 28 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
typedef struct _elm ELM;
#line 37 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
struct _win {
   int x1 ;
   int y1 ;
   int x2 ;
   int y2 ;
   int sy1 ;
   int sy2 ;
   int xs ;
   int ys ;
   char border ;
   char cursor ;
   char attr ;
   char color ;
   char autocr ;
   char doscroll ;
   char wrap ;
   char direct ;
   short curx ;
   short cury ;
   char o_cursor ;
   short o_curx ;
   short o_cury ;
   char o_attr ;
   char o_color ;
   ELM *map ;
   ELM *histbuf ;
   int histlines ;
   int histline ;
};
#line 37 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
typedef struct _win WIN;
#line 52 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
struct escseq {
   int code ;
   char const   *vt100_st ;
   char const   *vt100_app ;
   char const   *ansi ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 151 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short ushort;
#line 27 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.h"
struct dirEntry {
   char fname[256] ;
   time_t time ;
   mode_t mode ;
   ushort cflags ;
};
#line 27 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.h"
typedef struct dirEntry GETSDIR_ENTRY;
#line 55 "/home/wheatley/newnew/temp/minicom-2.7/src/configsym.h"
struct macs {
   char value[257] ;
   int flags ;
   char const   *desc ;
};
#line 62
enum config_type {
    CONFIG_GLOBAL = 0,
    CONFIG_PERSONAL = 1
} ;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 159 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
struct dialent;
#line 52 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
struct v1_dialent {
   char name[32] ;
   char number[16] ;
   char script[16] ;
   char username[32] ;
   char password[32] ;
   char term ;
   char baud[8] ;
   char parity[2] ;
   char dialtype ;
   char flags ;
   char bits[2] ;
   struct dialent *next ;
};
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
struct v3_dialent {
   char name[32] ;
   char number[32] ;
   char script[32] ;
   char username[32] ;
   char password[32] ;
   char term ;
   char baud[8] ;
   char parity[2] ;
   char dialtype ;
   char flags ;
   char bits[2] ;
   struct dialent *next ;
};
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
struct v4_dialent {
   char name[32] ;
   char number[32] ;
   char script[32] ;
   char username[32] ;
   char password[32] ;
   char term ;
   char baud[8] ;
   char parity[2] ;
   char dialtype ;
   char flags ;
   char bits[2] ;
   char lastdate[9] ;
   char lasttime[9] ;
   int count ;
   char convfile[16] ;
   char stopb[2] ;
   struct dialent *next ;
};
#line 105 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
struct dialent {
   char name[32] ;
   char number[32] ;
   char script[32] ;
   char username[32] ;
   char password[32] ;
   char term ;
   char baud[8] ;
   char parity[2] ;
   char dialtype ;
   char flags ;
   char bits[2] ;
   char lastdate[9] ;
   char lasttime[9] ;
   uint32_t count ;
   char convfile[16] ;
   char stopb[2] ;
   struct dialent *next ;
} __attribute__((__packed__)) ;
#line 127 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
struct dver {
   short magic ;
   short version ;
   unsigned short size ;
   short res1 ;
   short res2 ;
   short res3 ;
   short res4 ;
} __attribute__((__packed__)) ;
#line 247 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
struct key {
   char *cap ;
   char len ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 81 "../lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 353 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned int wint_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_15 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_16 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_15 __wait_terminated ;
   struct __anonstruct___wait_stopped_16 __wait_stopped ;
};
#line 615 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 615 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 185 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
union __anonunion_buf_62 {
   char bytes[128] ;
   int kermit ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 116 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int portfd_is_socket  ;
#line 117 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int portfd_is_connected  ;
#line 118 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
struct sockaddr_un portfd_sock_addr  ;
#line 267
void m_flush(int fd ) ;
#line 39 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1_s.c"
void m_flush(int fd ) 
{ 


  {
#line 42
  if (portfd_is_socket) {
#line 43
    return;
  }
  {
#line 47
  ioctl(fd, 21515UL, 2);
  }
#line 55
  return;
}
}
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 469
extern int pause(void) ;
#line 545
extern char **environ ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 717
extern int system(char const   *__command ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 63
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 93 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char homedir[256]  ;
#line 94 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char logfname[128]  ;
#line 181
void do_log(char const   *line  , ...) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 76 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct env *curenv  ;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int gtimeout  =    120;
#line 78 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int etimeout  =    0;
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
jmp_buf ejmp  ;
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int inexpect  =    0;
#line 81 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char const   *newline  ;
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char const   *s_login  =    "name";
#line 83 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char const   *s_pass  =    "password";
#line 84 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct line *thisline  ;
#line 85 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int laststatus  =    0;
#line 89 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static char inbuf[65]  ;
#line 92
int s_exec(char *text ) ;
#line 93
int execscript(char const   *s___0 ) ;
#line 99 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void init_env(void) 
{ 
  char **e ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  e = environ;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! *e) {
#line 104
      goto while_break;
    }
    {
#line 105
    tmp = strncmp((char const   *)*e, "LOGIN=", (size_t )6);
    }
#line 105
    if (! tmp) {
#line 106
      s_login = (char const   *)(*e + 6);
#line 107
      *e = (char *)"LOGIN=";
    }
    {
#line 109
    tmp___0 = strncmp((char const   *)*e, "PASS=", (size_t )5);
    }
#line 109
    if (! tmp___0) {
#line 110
      s_pass = (char const   *)(*e + 5);
#line 111
      *e = (char *)"PASS=";
    }
#line 104
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 120 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char const   *mygetenv(char *env ) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 122
  tmp = strcmp((char const   *)env, "LOGIN");
  }
#line 122
  if (! tmp) {
#line 123
    return (s_login);
  }
  {
#line 124
  tmp___0 = strcmp((char const   *)env, "PASS");
  }
#line 124
  if (! tmp___0) {
#line 125
    return (s_pass);
  }
  {
#line 126
  tmp___1 = getenv((char const   *)env);
  }
#line 126
  return ((char const   *)tmp___1);
}
}
#line 132 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void syntaxerr(char const   *s___0 ) 
{ 
  char *tmp ;

  {
  {
#line 134
  tmp = gettext("script \"%s\": syntax error in line %d %s%s\n");
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp, curenv->scriptname,
          thisline->lineno, s___0, "\r");
#line 136
  exit(1);
  }
}
}
#line 142 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void skipspace(char **s___0 ) 
{ 


  {
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((int )*(*s___0) == 32)) {
#line 144
      if (! ((int )*(*s___0) == 9)) {
#line 144
        goto while_break;
      }
    }
#line 145
    (*s___0) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void myclock(int dummy ) 
{ 
  char *tmp ;

  {
  {
#line 154
  signal(14, & myclock);
#line 155
  alarm(1U);
#line 157
  gtimeout --;
  }
#line 157
  if (gtimeout == 0) {
    {
#line 158
    tmp = gettext("script \"%s\": global timeout%s\n");
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            curenv->scriptname, "\r");
#line 160
    exit(1);
    }
  }
#line 162
  if (inexpect) {
#line 162
    if (etimeout) {
#line 162
      etimeout --;
#line 162
      if (etimeout == 0) {
        {
#line 163
        siglongjmp((struct __jmp_buf_tag *)(ejmp), 1);
        }
      }
    }
  }
#line 164
  return;
}
}
#line 166 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static char *buffer  ;
#line 167 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static unsigned int buffersize  ;
#line 169 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static void buf_wr(unsigned int idx___0 , char val ) 
{ 
  void *tmp ;

  {
#line 171
  if (idx___0 >= buffersize) {
    {
#line 173
    buffersize += 64U;
#line 174
    tmp = realloc((void *)buffer, (size_t )buffersize);
#line 174
    buffer = (char *)tmp;
    }
  }
#line 176
  *(buffer + idx___0) = val;
#line 177
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
__inline static char buf_rd(unsigned int idx___0 ) 
{ 


  {
#line 181
  return (*(buffer + idx___0));
}
}
#line 184 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static unsigned int bufsize(void) 
{ 


  {
#line 186
  return (buffersize);
}
}
#line 189 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
__inline static char *buf(void) 
{ 


  {
#line 191
  return (buffer);
}
}
#line 198 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char *getword(char **s___0 ) 
{ 
  unsigned int len ;
  int f ;
  int idx___0 ;
  char const   *t ;
  int sawesc ;
  int sawq ;
  char const   *env ;
  char envbuf[32] ;
  char tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char c___0 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
#line 202
  idx___0 = 0;
#line 203
  t = (char const   *)*s___0;
#line 204
  sawesc = 0;
#line 205
  sawq = 0;
#line 209
  if ((int )*(*s___0) == 0) {
#line 210
    return ((char *)((void *)0));
  }
#line 212
  len = 0U;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (sawesc) {
#line 213
      if (*(t + len)) {
#line 214
        sawesc = 0;
#line 215
        if ((int const   )*(t + len) <= 55) {
#line 215
          if ((int const   )*(t + len) >= 48) {
            {
#line 216
            buf_wr((unsigned int )idx___0, (char)0);
#line 217
            f = 0;
            }
            {
#line 217
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 217
              if (f < 4) {
                {
#line 217
                tmp___1 = bufsize();
                }
#line 217
                if (len < tmp___1) {
#line 217
                  if ((int const   )*(t + len) <= 55) {
#line 217
                    if (! ((int const   )*(t + len) >= 48)) {
#line 217
                      goto while_break___0;
                    }
                  } else {
#line 217
                    goto while_break___0;
                  }
                } else {
#line 217
                  goto while_break___0;
                }
              } else {
#line 217
                goto while_break___0;
              }
              {
#line 219
              tmp = buf_rd((unsigned int )idx___0);
#line 219
              tmp___0 = len;
#line 219
              len ++;
#line 219
              buf_wr((unsigned int )idx___0, (char )((8 * (int )tmp + (int )*(t + tmp___0)) - 48));
#line 217
              f ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 220
            tmp___2 = buf_rd((unsigned int )idx___0);
            }
#line 220
            if ((int )tmp___2 == 0) {
              {
#line 221
              buf_wr((unsigned int )idx___0, (char)-2);
              }
            }
#line 222
            idx___0 ++;
#line 223
            len --;
#line 224
            goto __Cont;
          }
        }
        {
#line 227
        if ((int const   )*(t + len) == 114) {
#line 227
          goto case_114;
        }
#line 230
        if ((int const   )*(t + len) == 110) {
#line 230
          goto case_110;
        }
#line 233
        if ((int const   )*(t + len) == 98) {
#line 233
          goto case_98;
        }
#line 236
        if ((int const   )*(t + len) == 97) {
#line 236
          goto case_97;
        }
#line 239
        if ((int const   )*(t + len) == 102) {
#line 239
          goto case_102;
        }
#line 242
        if ((int const   )*(t + len) == 99) {
#line 242
          goto case_99;
        }
#line 245
        goto switch_default;
        case_114: /* CIL Label */ 
        {
#line 228
        tmp___3 = idx___0;
#line 228
        idx___0 ++;
#line 228
        buf_wr((unsigned int )tmp___3, (char )'\r');
        }
#line 229
        goto switch_break;
        case_110: /* CIL Label */ 
        {
#line 231
        tmp___4 = idx___0;
#line 231
        idx___0 ++;
#line 231
        buf_wr((unsigned int )tmp___4, (char )'\n');
        }
#line 232
        goto switch_break;
        case_98: /* CIL Label */ 
        {
#line 234
        tmp___5 = idx___0;
#line 234
        idx___0 ++;
#line 234
        buf_wr((unsigned int )tmp___5, (char )'\b');
        }
#line 235
        goto switch_break;
        case_97: /* CIL Label */ 
        {
#line 237
        tmp___6 = idx___0;
#line 237
        idx___0 ++;
#line 237
        buf_wr((unsigned int )tmp___6, (char )'\a');
        }
#line 238
        goto switch_break;
        case_102: /* CIL Label */ 
        {
#line 240
        tmp___7 = idx___0;
#line 240
        idx___0 ++;
#line 240
        buf_wr((unsigned int )tmp___7, (char )'\f');
        }
#line 241
        goto switch_break;
        case_99: /* CIL Label */ 
        {
#line 243
        tmp___8 = idx___0;
#line 243
        idx___0 ++;
#line 243
        buf_wr((unsigned int )tmp___8, (char)-1);
        }
#line 244
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 246
        tmp___9 = idx___0;
#line 246
        idx___0 ++;
#line 246
        buf_wr((unsigned int )tmp___9, (char )*(t + len));
        }
#line 247
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 249
        sawesc = 0;
#line 250
        goto __Cont;
      }
    }
#line 252
    if ((int const   )*(t + len) == 92) {
#line 253
      sawesc = 1;
#line 254
      goto __Cont;
    }
#line 256
    if ((int const   )*(t + len) == 34) {
#line 257
      if (sawq == 1) {
#line 258
        sawq = 0;
#line 259
        len ++;
#line 260
        goto while_break;
      }
#line 262
      sawq = 1;
#line 263
      goto __Cont;
    }
#line 265
    if ((int const   )*(t + len) == 36) {
#line 265
      if ((int const   )*(t + (len + 1U)) == 40) {
#line 266
        f = (int )len;
        {
#line 266
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 266
          if (*(t + f)) {
#line 266
            if (! ((int const   )*(t + f) != 41)) {
#line 266
              goto while_break___1;
            }
          } else {
#line 266
            goto while_break___1;
          }
#line 266
          f ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 268
        if ((int const   )*(t + f) == 41) {
          {
#line 269
          strncpy((char */* __restrict  */)(envbuf), (char const   */* __restrict  */)(t + (len + 2U)),
                  (size_t )(((unsigned int )f - len) - 2U));
#line 270
          envbuf[((unsigned int )f - len) - 2U] = (char)0;
#line 271
          len = (unsigned int )f;
#line 272
          env = mygetenv(envbuf);
          }
#line 273
          if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 274
            env = "";
          }
          {
#line 275
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 275
            if (! *env) {
#line 275
              goto while_break___2;
            }
            {
#line 276
            tmp___10 = env;
#line 276
            env ++;
#line 276
            tmp___11 = idx___0;
#line 276
            idx___0 ++;
#line 276
            buf_wr((unsigned int )tmp___11, (char )*tmp___10);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 277
          goto __Cont;
        }
      }
    }
#line 281
    if (sawq == 1) {
#line 281
      if ((int const   )*(t + len) == 94) {
#line 281
        if ((int const   )*(t + (len + 1U)) != 0) {
          {
#line 282
          tmp___12 = toupper((int )*(t + (len + 1U)));
#line 282
          c___0 = (char )tmp___12;
          }
#line 283
          if ((int )c___0 >= 65) {
#line 283
            if ((int )c___0 <= 95) {
              {
#line 284
              len ++;
#line 285
              tmp___13 = idx___0;
#line 285
              idx___0 ++;
#line 285
              buf_wr((unsigned int )tmp___13, (char )(((int )c___0 - 65) + 1));
              }
#line 286
              goto __Cont;
            }
          }
        }
      }
    }
#line 289
    if (! sawq) {
#line 289
      if ((int const   )*(t + len) == 32) {
#line 290
        goto while_break;
      } else
#line 289
      if ((int const   )*(t + len) == 9) {
#line 290
        goto while_break;
      } else {
#line 289
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 289
    if ((int const   )*(t + len) == 0) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp___14 = idx___0;
#line 291
    idx___0 ++;
#line 291
    buf_wr((unsigned int )tmp___14, (char )*(t + len));
    }
    __Cont: /* CIL Label */ 
#line 212
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 293
  buf_wr((unsigned int )idx___0, (char)0);
#line 294
  *s___0 += len;
#line 295
  skipspace(s___0);
  }
#line 296
  if (sawesc) {
    {
#line 297
    tmp___15 = gettext("(word contains ESC or quote)");
#line 297
    syntaxerr((char const   *)tmp___15);
    }
  } else
#line 296
  if (sawq) {
    {
#line 297
    tmp___15 = gettext("(word contains ESC or quote)");
#line 297
    syntaxerr((char const   *)tmp___15);
    }
  }
  {
#line 298
  tmp___16 = buf();
  }
#line 298
  return (tmp___16);
}
}
#line 304 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
char *strsave(char *s___0 ) 
{ 
  char *t ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 309
  tmp = strlen((char const   *)s___0);
#line 309
  len = (int )tmp;
  }
#line 310
  if (len) {
#line 310
    if ((int )*(s___0 + (len - 1)) == 10) {
#line 311
      len --;
#line 311
      *(s___0 + len) = (char)0;
    }
  }
  {
#line 312
  tmp___0 = malloc((size_t )(len + 1));
#line 312
  t = (char *)tmp___0;
  }
#line 312
  if (! t) {
#line 313
    return (t);
  }
  {
#line 314
  strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s___0);
  }
#line 315
  return (t);
}
}
#line 321 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void freemem(void) 
{ 
  struct line *l ;
  struct line *nextl ;
  struct var *v ;
  struct var *nextv ;

  {
#line 326
  l = curenv->lines;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! l) {
#line 326
      goto while_break;
    }
    {
#line 327
    nextl = l->next;
#line 328
    free((void *)l->line);
#line 329
    free((void *)l);
#line 326
    l = nextl;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 331
  v = curenv->vars;
  {
#line 331
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 331
    if (! v) {
#line 331
      goto while_break___0;
    }
    {
#line 332
    nextv = v->next;
#line 333
    free((void *)v->name);
#line 334
    free((void *)v);
#line 331
    v = nextv;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 336
  return;
}
}
#line 341 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static int readscript(char const   *s___0 ) 
{ 
  FILE *fp ;
  struct line *tl ;
  struct line *prev ;
  char *t ;
  char buf___6[500] ;
  int lineno ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 344
  prev = (struct line *)((void *)0);
#line 347
  lineno = 0;
#line 349
  fp = fopen((char const   */* __restrict  */)s___0, (char const   */* __restrict  */)"r");
  }
#line 349
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 350
    tmp = gettext("runscript: couldn\'t open \"%s\"%s\n");
#line 350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            s___0, "\r");
#line 351
    exit(1);
    }
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 355
    t = fgets((char */* __restrict  */)(buf___6), (int )sizeof(buf___6), (FILE */* __restrict  */)fp);
    }
#line 355
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 355
      goto while_break;
    }
    {
#line 356
    lineno ++;
#line 357
    tmp___0 = strlen((char const   *)t);
    }
#line 357
    if (tmp___0 == sizeof(buf___6) - 1UL) {
      {
#line 362
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input line %u too long, aborting (and fix me!)!\n",
              lineno);
#line 364
      exit(1);
      }
    }
    {
#line 366
    skipspace(& t);
    }
#line 367
    if ((int )*t == 10) {
#line 368
      goto while_continue;
    } else
#line 367
    if ((int )*t == 35) {
#line 368
      goto while_continue;
    }
    {
#line 369
    tmp___2 = malloc(sizeof(struct line ));
#line 369
    tl = (struct line *)tmp___2;
    }
#line 369
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
      {
#line 371
      tmp___1 = gettext("script \"%s\": out of memory%s\n");
#line 371
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              s___0, "\r");
#line 372
      exit(1);
      }
    } else {
      {
#line 369
      tmp___3 = strsave(t);
#line 369
      tl->line = tmp___3;
      }
#line 369
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
        {
#line 371
        tmp___1 = gettext("script \"%s\": out of memory%s\n");
#line 371
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
                s___0, "\r");
#line 372
        exit(1);
        }
      }
    }
#line 374
    if (prev) {
#line 375
      prev->next = tl;
    } else {
#line 377
      curenv->lines = tl;
    }
#line 378
    tl->next = (struct line *)((void *)0);
#line 379
    tl->labelcount = 0;
#line 380
    tl->lineno = lineno;
#line 381
    prev = tl;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 383
  fclose(fp);
  }
#line 384
  return (0);
}
}
#line 388 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void readchar(void) 
{ 
  char c___0 ;
  int n ;
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 393
    tmp___0 = read(0, (void *)(& c___0), (size_t )1);
#line 393
    n = (int )tmp___0;
    }
#line 393
    if (! (n != 1)) {
#line 393
      goto while_break;
    }
    {
#line 394
    tmp = __errno_location();
    }
#line 394
    if (*tmp != 4) {
#line 395
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  if (n <= 0) {
#line 398
    return;
  }
  {
#line 408
  memmove((void *)(inbuf), (void const   *)(inbuf + 1), (size_t )63);
  }
#line 411
  if (curenv->verbose) {
    {
#line 412
    fputc((int )c___0, stderr);
    }
  }
#line 413
  inbuf[63] = c___0;
#line 414
  return;
}
}
#line 417 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int expfound(char const   *word ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 421
  if ((unsigned long )word == (unsigned long )((void *)0)) {
    {
#line 422
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"NULL paramenter to %s!",
            "expfound");
#line 423
    exit(1);
    }
  }
  {
#line 426
  tmp = strlen(word);
#line 426
  len = (int )tmp;
  }
#line 427
  if (len > 64) {
#line 428
    len = 64;
  }
  {
#line 430
  tmp___0 = strcmp((char const   *)((inbuf + 64) - len), word);
  }
#line 430
  if (tmp___0) {
#line 430
    tmp___1 = 0;
  } else {
#line 430
    tmp___1 = 1;
  }
#line 430
  return (tmp___1);
}
}
#line 436 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int output(char *text , FILE *fp ) 
{ 
  unsigned char *w ;
  int first___0 ;
  int donl ;
  char *tmp ;

  {
#line 439
  first___0 = 1;
#line 440
  donl = 1;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 442
    tmp = getword(& text);
#line 442
    w = (unsigned char *)tmp;
    }
#line 442
    if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 442
      goto while_break;
    }
#line 443
    if (! first___0) {
      {
#line 444
      fputc(' ', fp);
      }
    }
#line 445
    first___0 = 0;
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 446
      if (! *w) {
#line 446
        goto while_break___0;
      }
#line 447
      if ((int )*w == 255) {
#line 448
        donl = 0;
#line 449
        goto __Cont;
      }
#line 451
      if ((int )*w == 10) {
        {
#line 452
        fputs((char const   */* __restrict  */)newline, (FILE */* __restrict  */)fp);
        }
      } else
#line 453
      if ((int )*w == 254) {
        {
#line 454
        fputc('\000', fp);
        }
      } else {
        {
#line 456
        fputc((int )*w, fp);
        }
      }
      __Cont: /* CIL Label */ 
#line 446
      w ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  if (donl) {
    {
#line 460
    fputs((char const   */* __restrict  */)newline, (FILE */* __restrict  */)fp);
    }
  }
  {
#line 461
  fflush(fp);
  }
#line 462
  return (0);
}
}
#line 469 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct var *getvar(char *name , int cr ) 
{ 
  struct var *v ;
  struct var *end ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 471
  end = (struct var *)((void *)0);
#line 473
  v = curenv->vars;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! v) {
#line 473
      goto while_break;
    }
    {
#line 474
    end = v;
#line 475
    tmp = strcmp((char const   *)v->name, (char const   *)name);
    }
#line 475
    if (! tmp) {
#line 476
      return (v);
    }
#line 473
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (! cr) {
    {
#line 479
    tmp___0 = gettext("script \"%s\" line %d: unknown variable \"%s\"%s\n");
#line 479
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            curenv->scriptname, thisline->lineno, name, "\r");
#line 481
    exit(1);
    }
  }
  {
#line 483
  tmp___2 = malloc(sizeof(struct var ));
#line 483
  v = (struct var *)tmp___2;
  }
#line 483
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 485
    tmp___1 = gettext("script \"%s\": out of memory%s\n");
#line 485
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            curenv->scriptname, "\r");
#line 487
    exit(1);
    }
  } else {
    {
#line 483
    tmp___3 = strsave(name);
#line 483
    v->name = tmp___3;
    }
#line 483
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 485
      tmp___1 = gettext("script \"%s\": out of memory%s\n");
#line 485
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              curenv->scriptname, "\r");
#line 487
      exit(1);
      }
    }
  }
#line 489
  if (end) {
#line 490
    end->next = v;
  } else {
#line 492
    curenv->vars = v;
  }
#line 493
  v->next = (struct var *)((void *)0);
#line 494
  v->value = 0;
#line 495
  return (v);
}
}
#line 501 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int getnum(char *text ) 
{ 
  int val ;
  int tmp ;
  struct var *tmp___0 ;

  {
  {
#line 505
  tmp = strcmp((char const   *)text, "$?");
  }
#line 505
  if (! tmp) {
#line 506
    return (laststatus);
  }
  {
#line 507
  val = atoi((char const   *)text);
  }
#line 507
  if (val != 0) {
#line 508
    return (val);
  } else
#line 507
  if ((int )*text == 48) {
#line 508
    return (val);
  }
  {
#line 509
  tmp___0 = getvar(text, 0);
  }
#line 509
  return (tmp___0->value);
}
}
#line 518 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static struct line *seq[17]  ;
#line 516 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct line **buildexpect(void) 
{ 
  int f ;
  char *w ;
  char *t ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 522
  f = 0;
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! (f < 16)) {
#line 522
      goto while_break;
    }
#line 523
    if ((unsigned long )thisline == (unsigned long )((void *)0)) {
      {
#line 524
      tmp = gettext("script \"%s\": unexpected end of file%s\n");
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              curenv->scriptname, "\r");
#line 526
      exit(1);
      }
    }
    {
#line 528
    t = thisline->line;
#line 529
    w = getword(& t);
#line 530
    tmp___1 = strcmp((char const   *)w, "}");
    }
#line 530
    if (! tmp___1) {
#line 531
      if (*t) {
        {
#line 532
        tmp___0 = gettext("(garbage after })");
#line 532
        syntaxerr((char const   *)tmp___0);
        }
      }
#line 533
      seq[f] = (struct line *)((void *)0);
#line 534
      return (seq);
    }
#line 536
    seq[f] = thisline;
#line 537
    thisline = thisline->next;
#line 522
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  if (f == 16) {
    {
#line 540
    tmp___2 = gettext("(too many arguments)");
#line 540
    syntaxerr((char const   *)tmp___2);
    }
  }
#line 541
  return (seq);
}
}
#line 547 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int expect(char *text ) 
{ 
  char *s___0 ;
  char *w ;
  struct line ** volatile  seq___0 ;
  struct line oneline ;
  struct line *dflseq[2] ;
  char * volatile  toact ;
  int volatile   found ;
  int f ;
  int val ;
  int c___0 ;
  char *action ;
  char *tmp ;
  char *tmp___0 ;
  struct line **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 553
  toact = (char */* volatile  */)"exit 1";
#line 554
  found = (int volatile   )0;
#line 556
  action = (char *)((void *)0);
#line 558
  if (inexpect) {
    {
#line 559
    tmp = gettext("script \"%s\" line %d: nested expect%s\n");
#line 559
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            curenv->scriptname, thisline->lineno, "\r");
#line 561
    exit(1);
    }
  }
  {
#line 563
  etimeout = 120;
#line 564
  inexpect = 1;
#line 566
  s___0 = getword(& text);
#line 567
  tmp___2 = strcmp((char const   *)s___0, "{");
  }
#line 567
  if (tmp___2) {
#line 573
    oneline.line = s___0;
#line 574
    oneline.next = (struct line *)((void *)0);
#line 575
    dflseq[0] = & oneline;
#line 576
    dflseq[1] = (struct line *)((void *)0);
#line 577
    seq___0 = (struct line **/* volatile  */)(dflseq);
  } else {
#line 568
    if (*text) {
      {
#line 569
      tmp___0 = gettext("(garbage after {)");
#line 569
      syntaxerr((char const   *)tmp___0);
      }
    }
    {
#line 570
    thisline = thisline->next;
#line 571
    tmp___1 = buildexpect();
#line 571
    seq___0 = (struct line **/* volatile  */)tmp___1;
    }
  }
#line 580
  f = 0;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! *(seq___0 + f)) {
#line 580
      goto while_break;
    }
    {
#line 581
    tmp___5 = strncmp((char const   *)(*(seq___0 + f))->line, "timeout", (size_t )7);
    }
#line 581
    if (! tmp___5) {
#line 582
      c___0 = (int )*((*(seq___0 + f))->line + 7);
#line 583
      if (c___0 == 0) {
#line 584
        goto __Cont;
      } else
#line 583
      if (c___0 != 32) {
#line 583
        if (c___0 != 9) {
#line 584
          goto __Cont;
        }
      }
      {
#line 585
      s___0 = (*(seq___0 + f))->line + 7;
#line 587
      skipspace(& s___0);
#line 588
      w = getword(& s___0);
      }
#line 589
      if ((unsigned long )w == (unsigned long )((void *)0)) {
        {
#line 590
        tmp___3 = gettext("(argument expected)");
#line 590
        syntaxerr((char const   *)tmp___3);
        }
      }
      {
#line 591
      val = getnum(w);
      }
#line 592
      if (val == 0) {
        {
#line 593
        tmp___4 = gettext("(invalid argument)");
#line 593
        syntaxerr((char const   *)tmp___4);
        }
      }
      {
#line 594
      etimeout = val;
#line 595
      skipspace(& s___0);
      }
#line 596
      if ((int )*s___0 != 0) {
#line 597
        toact = (char */* volatile  */)s___0;
      }
#line 598
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 580
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 601
  tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)(ejmp), 1);
  }
#line 601
  if (tmp___6 != 0) {
    {
#line 602
    f = s_exec((char *)toact);
#line 603
    inexpect = 0;
    }
#line 604
    return (f);
  }
#line 608
  c___0 = 0;
  {
#line 609
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 609
    if (! (! found)) {
#line 609
      goto while_break___0;
    }
    {
#line 610
    action = (char *)((void *)0);
#line 611
    readchar();
#line 612
    f = 0;
    }
    {
#line 612
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 612
      if (! *(seq___0 + f)) {
#line 612
        goto while_break___1;
      }
      {
#line 613
      s___0 = (*(seq___0 + f))->line;
#line 614
      w = getword(& s___0);
#line 615
      tmp___7 = expfound((char const   *)w);
      }
#line 615
      if (tmp___7) {
#line 616
        action = s___0;
#line 617
        found = (int volatile   )1;
#line 618
        goto while_break___1;
      }
#line 612
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 621
    if ((unsigned long )action != (unsigned long )((void *)0)) {
#line 621
      if (*action) {
        {
#line 622
        found = (int volatile   )0;
#line 624
        c___0 = s_exec(action);
        }
#line 624
        if (c___0 != 0) {
#line 625
          found = (int volatile   )1;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 628
  inexpect = 0;
#line 629
  etimeout = 0;
#line 630
  return (c___0);
}
}
#line 636 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int shell(char *text ) 
{ 


  {
  {
#line 638
  laststatus = system((char const   *)text);
  }
#line 639
  return (0);
}
}
#line 645 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int pipedshell(char *text ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char received[64] ;
  size_t read___0 ;
  char *sent ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int status ;
  int tmp___3 ;
  union __anonunion_62 __constr_expr_0 ;
  union __anonunion_63 __constr_expr_1 ;
  union __anonunion_64 __constr_expr_2 ;
  union __anonunion_65 __constr_expr_3 ;

  {
  {
#line 647
  tmp = popen((char const   *)text, "r");
#line 647
  fp = tmp;
  }
#line 648
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 649
    tmp___0 = __errno_location();
#line 649
    laststatus = *tmp___0;
    }
#line 650
    return (0);
  }
#line 654
  read___0 = (size_t )0;
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 655
    read___0 = fread((void */* __restrict  */)(received), sizeof(char ), (size_t )64,
                     (FILE */* __restrict  */)fp);
    }
#line 655
    if (! read___0) {
#line 655
      goto while_break;
    }
    {
#line 658
    usleep((__useconds_t )200000);
#line 661
    sent = received;
    }
    {
#line 662
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 662
      tmp___2 = read___0;
#line 662
      read___0 --;
#line 662
      if (! (tmp___2 > 0UL)) {
#line 662
        goto while_break___0;
      }
      {
#line 663
      tmp___1 = sent;
#line 663
      sent ++;
#line 663
      fputc((int )*tmp___1, stdout);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 665
    fflush(stdout);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 668
  tmp___3 = pclose(fp);
#line 668
  status = tmp___3;
#line 669
  __constr_expr_3.__in = status;
  }
#line 669
  if ((__constr_expr_3.__i & 127) == 0) {
#line 670
    __constr_expr_0.__in = status;
#line 670
    laststatus = (__constr_expr_0.__i & 65280) >> 8;
  } else {
#line 671
    __constr_expr_2.__in = status;
#line 671
    if ((int )((signed char )((__constr_expr_2.__i & 127) + 1)) >> 1 > 0) {
#line 672
      __constr_expr_1.__in = status;
#line 672
      laststatus = __constr_expr_1.__i & 127;
    } else {
#line 674
      laststatus = status;
    }
  }
#line 675
  return (0);
}
}
#line 681 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dosend(char *text ) 
{ 
  int tmp ;

  {
  {
#line 685
  usleep((__useconds_t )200000);
#line 689
  m_flush(0);
#line 690
  memset((void *)(inbuf), 0, sizeof(inbuf));
#line 692
  newline = "\r";
#line 693
  tmp = output(text, stdout);
  }
#line 693
  return (tmp);
}
}
#line 699 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doexit(char *text ) 
{ 
  char *w ;
  int ret ;

  {
  {
#line 702
  ret = 0;
#line 704
  w = getword(& text);
  }
#line 705
  if ((unsigned long )w != (unsigned long )((void *)0)) {
    {
#line 706
    ret = getnum(w);
    }
  }
  {
#line 707
  curenv->exstat = ret;
#line 708
  longjmp((struct __jmp_buf_tag *)(curenv->ebuf), 1);
  }
#line 709
  return (0);
}
}
#line 715 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dogoto(char *text ) 
{ 
  char *w ;
  struct line *l ;
  char buf___6[32] ;
  int len ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 722
  w = getword(& text);
  }
#line 723
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 724
    tmp = gettext("(in goto/gosub label)");
#line 724
    syntaxerr((char const   *)tmp);
    }
  } else
#line 723
  if (*text) {
    {
#line 724
    tmp = gettext("(in goto/gosub label)");
#line 724
    syntaxerr((char const   *)tmp);
    }
  }
  {
#line 725
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%s:",
           w);
#line 726
  tmp___0 = strlen((char const   *)(buf___6));
#line 726
  len = (int )tmp___0;
#line 727
  l = curenv->lines;
  }
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! l) {
#line 727
      goto while_break;
    }
    {
#line 728
    tmp___1 = strncmp((char const   *)l->line, (char const   *)(buf___6), (size_t )len);
    }
#line 728
    if (! tmp___1) {
#line 729
      goto while_break;
    }
#line 727
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 730
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    {
#line 731
    tmp___2 = gettext("script \"%s\" line %d: label \"%s\" not found%s\n");
#line 731
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            curenv->scriptname, thisline->lineno, w, "\r");
#line 733
    exit(1);
    }
  }
#line 735
  thisline = l;
#line 737
  return (2);
}
}
#line 743 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dogosub(char *text ) 
{ 
  struct line *oldline ;
  int ret ;
  char *tmp ;

  {
  {
#line 746
  ret = 0;
#line 748
  oldline = thisline;
#line 749
  dogoto(text);
  }
  {
#line 751
  while (1) {
    while_continue: /* CIL Label */ ;
#line 751
    if (! (ret != -1)) {
#line 751
      goto while_break;
    }
#line 752
    thisline = thisline->next;
#line 752
    if ((unsigned long )thisline == (unsigned long )((void *)0)) {
      {
#line 753
      tmp = gettext("script \"%s\": no return from gosub%s\n");
#line 753
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              curenv->scriptname, "\r");
#line 755
      exit(1);
      }
    }
    {
#line 757
    ret = s_exec(thisline->line);
    }
#line 758
    if (ret == 1) {
#line 759
      ret = 0;
#line 760
      thisline = oldline;
#line 761
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  return (ret);
}
}
#line 770 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doreturn(char *text ) 
{ 


  {
#line 773
  return (1);
}
}
#line 779 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int print(char *text ) 
{ 
  int tmp ;

  {
  {
#line 781
  newline = "\r\n";
#line 783
  tmp = output(text, stderr);
  }
#line 783
  return (tmp);
}
}
#line 789 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doset(char *text ) 
{ 
  char *w ;
  struct var *v ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 794
  w = getword(& text);
  }
#line 795
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 796
    tmp = gettext("(missing var name)");
#line 796
    syntaxerr((char const   *)tmp);
    }
  }
  {
#line 797
  v = getvar(w, 1);
  }
#line 798
  if (*text) {
    {
#line 799
    tmp___0 = getword(& text);
#line 799
    v->value = getnum(tmp___0);
    }
  }
#line 800
  return (0);
}
}
#line 806 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dodec(char *text ) 
{ 
  char *w ;
  struct var *v ;
  char *tmp ;

  {
  {
#line 811
  w = getword(& text);
  }
#line 812
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 813
    tmp = gettext("(expected variable)");
#line 813
    syntaxerr((char const   *)tmp);
    }
  }
  {
#line 814
  v = getvar(w, 0);
#line 815
  (v->value) --;
  }
#line 816
  return (0);
}
}
#line 822 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doinc(char *text ) 
{ 
  char *w ;
  struct var *v ;
  char *tmp ;

  {
  {
#line 827
  w = getword(& text);
  }
#line 828
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 829
    tmp = gettext("(expected variable)");
#line 829
    syntaxerr((char const   *)tmp);
    }
  }
  {
#line 830
  v = getvar(w, 0);
#line 831
  (v->value) ++;
  }
#line 832
  return (0);
}
}
#line 838 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doif(char *text ) 
{ 
  char *w ;
  int n1 ;
  int n2 ;
  char op ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 845
  w = getword(& text);
  }
#line 845
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 846
    syntaxerr("(if)");
    }
  }
  {
#line 847
  n1 = getnum(w);
#line 848
  w = getword(& text);
  }
#line 848
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 849
    syntaxerr("(if)");
    }
  }
  {
#line 850
  tmp = strcmp((char const   *)w, "!=");
  }
#line 850
  if (tmp == 0) {
#line 851
    op = (char )'!';
  } else {
#line 853
    if ((int )*w == 0) {
      {
#line 854
      syntaxerr("(if)");
      }
    } else
#line 853
    if ((int )*(w + 1) != 0) {
      {
#line 854
      syntaxerr("(if)");
      }
    }
#line 855
    op = *w;
  }
  {
#line 857
  w = getword(& text);
  }
#line 857
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 858
    syntaxerr("(if)");
    }
  }
  {
#line 859
  n2 = getnum(w);
  }
#line 860
  if (! *text) {
    {
#line 861
    tmp___0 = gettext("(expected command after if)");
#line 861
    syntaxerr((char const   *)tmp___0);
    }
  }
#line 863
  if ((int )op == 61) {
#line 864
    if (n1 != n2) {
#line 865
      return (0);
    }
  } else
#line 866
  if ((int )op == 33) {
#line 867
    if (n1 == n2) {
#line 868
      return (0);
    }
  } else
#line 869
  if ((int )op == 62) {
#line 870
    if (n1 <= n2) {
#line 871
      return (0);
    }
  } else
#line 872
  if ((int )op == 60) {
#line 873
    if (n1 >= n2) {
#line 874
      return (0);
    }
  } else {
    {
#line 876
    tmp___1 = gettext("(unknown operator)");
#line 876
    syntaxerr((char const   *)tmp___1);
    }
  }
  {
#line 878
  tmp___2 = s_exec(text);
  }
#line 878
  return (tmp___2);
}
}
#line 884 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dotimeout(char *text ) 
{ 
  char *w ;
  int val ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 889
  w = getword(& text);
  }
#line 890
  if ((unsigned long )w == (unsigned long )((void *)0)) {
    {
#line 891
    tmp = gettext("(argument expected)");
#line 891
    syntaxerr((char const   *)tmp);
    }
  }
  {
#line 892
  val = getnum(w);
  }
#line 892
  if (val == 0) {
    {
#line 893
    tmp___0 = gettext("(invalid argument)");
#line 893
    syntaxerr((char const   *)tmp___0);
    }
  }
#line 894
  gtimeout = val;
#line 895
  return (0);
}
}
#line 901 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int doverbose(char *text ) 
{ 
  char *w ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 905
  curenv->verbose = 1;
#line 907
  w = getword(& text);
  }
#line 907
  if ((unsigned long )w != (unsigned long )((void *)0)) {
    {
#line 908
    tmp = strcmp((char const   *)w, "on");
    }
#line 908
    if (! tmp) {
#line 909
      return (0);
    }
    {
#line 910
    tmp___0 = strcmp((char const   *)w, "off");
    }
#line 910
    if (! tmp___0) {
#line 911
      curenv->verbose = 0;
#line 912
      return (0);
    }
  }
  {
#line 915
  tmp___1 = gettext("(unexpected argument)");
#line 915
  syntaxerr((char const   *)tmp___1);
  }
#line 916
  return (-1);
}
}
#line 922 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dosleep(char *text ) 
{ 
  int foo ;
  int tm ;

  {
  {
#line 926
  tm = getnum(text);
#line 927
  foo = gtimeout - tm;
  }
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! (gtimeout != foo)) {
#line 930
      goto while_break;
    }
    {
#line 931
    pause();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 932
  return (0);
}
}
#line 938 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int dobreak(char *dummy ) 
{ 
  char *tmp ;

  {
#line 941
  if (! inexpect) {
    {
#line 942
    tmp = gettext("script \"%s\" line %d: break outside of expect%s\n");
#line 942
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            curenv->scriptname, thisline->lineno, "\r");
#line 944
    exit(1);
    }
  }
#line 946
  return (2);
}
}
#line 952 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int docall(char *text ) 
{ 
  struct line *oldline ;
  struct env *oldenv ;
  int er ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 958
  if ((int )*text == 0) {
    {
#line 959
    tmp = gettext("(argument expected)");
#line 959
    syntaxerr((char const   *)tmp);
    }
  }
#line 961
  if (inexpect) {
    {
#line 962
    tmp___0 = gettext("script \"%s\" line %d: call inside expect%s\n");
#line 962
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            curenv->scriptname, thisline->lineno, "\r");
#line 964
    exit(1);
    }
  }
  {
#line 967
  oldline = thisline;
#line 968
  oldenv = curenv;
#line 969
  er = execscript((char const   *)text);
  }
#line 969
  if (er != 0) {
    {
#line 970
    exit(er);
    }
  }
#line 972
  thisline = oldline;
#line 973
  curenv = oldenv;
#line 974
  return (0);
}
}
#line 977 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
static int do_log_wrapper(char *s___0 ) 
{ 


  {
  {
#line 979
  do_log("%s", s___0);
  }
#line 980
  return (0);
}
}
#line 984 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
struct kw keywords[20]  = 
#line 984
  {      {"expect", & expect}, 
        {"send", & dosend}, 
        {"!<", & pipedshell}, 
        {"!", & shell}, 
        {"goto", & dogoto}, 
        {"gosub", & dogosub}, 
        {"return", & doreturn}, 
        {"exit", & doexit}, 
        {"print", & print}, 
        {"set", & doset}, 
        {"inc", & doinc}, 
        {"dec", & dodec}, 
        {"if", & doif}, 
        {"timeout", & dotimeout}, 
        {"verbose", & doverbose}, 
        {"sleep", & dosleep}, 
        {"break", & dobreak}, 
        {"call", & docall}, 
        {"log", & do_log_wrapper}, 
        {(char const   *)((void *)0), (int (*)(char * ))0}};
#line 1013 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int s_exec(char *text ) 
{ 
  char *w ;
  struct kw *k ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1018
  w = getword(& text);
  }
#line 1021
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 1022
    return (0);
  } else
#line 1021
  if ((int )*w == 35) {
#line 1022
    return (0);
  } else {
    {
#line 1021
    tmp = strlen((char const   *)w);
    }
#line 1021
    if ((int )*(w + (tmp - 1UL)) == 58) {
#line 1022
      return (0);
    }
  }
#line 1025
  k = keywords;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! k->command) {
#line 1025
      goto while_break;
    }
    {
#line 1026
    tmp___0 = strcmp((char const   *)w, k->command);
    }
#line 1026
    if (! tmp___0) {
#line 1027
      goto while_break;
    }
#line 1025
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1030
  if ((unsigned long )k->command == (unsigned long )((void *)0)) {
    {
#line 1031
    tmp___1 = gettext("script \"%s\" line %d: unknown command \"%s\"%s\n");
#line 1031
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            curenv->scriptname, thisline->lineno, w, "\r");
#line 1033
    exit(1);
    }
  }
  {
#line 1035
  tmp___2 = (*(k->fn))(text);
  }
#line 1035
  return (tmp___2);
}
}
#line 1041 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int execscript(char const   *s___0 ) 
{ 
  int volatile   ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1043
  ret = (int volatile   )0;
#line 1045
  tmp = malloc(sizeof(struct env ));
#line 1045
  curenv = (struct env *)tmp;
#line 1046
  curenv->lines = (struct line *)((void *)0);
#line 1047
  curenv->vars = (struct var *)((void *)0);
#line 1048
  curenv->verbose = 1;
#line 1049
  curenv->scriptname = s___0;
#line 1051
  tmp___0 = readscript(s___0);
  }
#line 1051
  if (tmp___0 < 0) {
    {
#line 1052
    freemem();
#line 1053
    free((void *)curenv);
    }
#line 1054
    return (-1);
  }
  {
#line 1057
  signal(14, & myclock);
#line 1058
  alarm(1U);
#line 1059
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(curenv->ebuf));
  }
#line 1059
  if (tmp___2 == 0) {
#line 1060
    thisline = curenv->lines;
    {
#line 1061
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1061
      if ((unsigned long )thisline != (unsigned long )((void *)0)) {
        {
#line 1061
        tmp___1 = s_exec(thisline->line);
#line 1061
        ret = (int volatile   )tmp___1;
        }
#line 1061
        if (! (ret != (int volatile   )-1)) {
#line 1061
          goto while_break;
        }
      } else {
#line 1061
        goto while_break;
      }
#line 1062
      thisline = thisline->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1064
  if (curenv->exstat) {
#line 1064
    ret = (int volatile   )-1;
  } else {
#line 1064
    ret = (int volatile   )0;
  }
  {
#line 1065
  free((void *)curenv);
  }
#line 1066
  return ((int )ret);
}
}
#line 1069 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
void do_args(int argc , char **argv ) 
{ 
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 1071
  if (argc > 1) {
    {
#line 1071
    tmp___0 = strcmp((char const   *)*(argv + 1), "--version");
    }
#line 1071
    if (! tmp___0) {
      {
#line 1072
      tmp = gettext("runscript, part of minicom version %s\n");
#line 1072
      printf((char const   */* __restrict  */)tmp, "2.7");
#line 1073
      exit(0);
      }
    }
  }
#line 1076
  if (argc < 2) {
    {
#line 1077
    tmp___1 = gettext("Usage: runscript <scriptfile> [logfile [homedir]]%s\n");
#line 1077
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            "\r");
#line 1078
    exit(1);
    }
  }
#line 1080
  return;
}
}
#line 1082 "/home/wheatley/newnew/temp/minicom-2.7/src/script.c"
int main(int argc , char **argv ) 
{ 
  char *s___0 ;
  int tmp ;

  {
  {
#line 1090
  setlocale(6, "");
#line 1091
  bindtextdomain("minicom", "/usr/local/share/locale");
#line 1092
  textdomain("minicom");
#line 1094
  init_env();
#line 1096
  do_args(argc, argv);
#line 1098
  memset((void *)(inbuf), 0, sizeof(inbuf));
  }
#line 1100
  if (argc > 2) {
    {
#line 1101
    strncpy((char */* __restrict  */)(logfname), (char const   */* __restrict  */)*(argv + 2),
            sizeof(logfname));
    }
#line 1102
    if (argc > 3) {
      {
#line 1103
      strncpy((char */* __restrict  */)(homedir), (char const   */* __restrict  */)*(argv + 3),
              sizeof(homedir));
      }
    } else {
      {
#line 1104
      s___0 = getenv("HOME");
      }
#line 1104
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
        {
#line 1105
        strncpy((char */* __restrict  */)(homedir), (char const   */* __restrict  */)s___0,
                sizeof(homedir));
        }
      } else {
#line 1107
        homedir[0] = (char)0;
      }
    }
  } else {
#line 1110
    logfname[0] = (char)0;
  }
  {
#line 1112
  tmp = execscript((char const   *)*(argv + 1));
  }
#line 1112
  return (tmp != 0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 866 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbtowc)(wchar_t * __restrict  __pwc ,
                                                                             char const   * __restrict  __s ,
                                                                             size_t __n ) ;
#line 870
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctomb)(char *__s ,
                                                                             wchar_t __wchar ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 180 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *pfix_home(char *s___0 ) ;
#line 182
size_t one_mbtowc(wchar_t *pwc , char const   *s___0 , size_t n ) ;
#line 183
size_t one_wctomb(char *s___0 , wchar_t wchar ) ;
#line 184
size_t mbslen(char const   *s___0 ) ;
#line 41 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
static char buf___0[4096]  ;
#line 38 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
char *pfix_home(char *s___0 ) 
{ 


  {
#line 46
  if (s___0) {
#line 46
    if ((int )*s___0 != 47) {
      {
#line 47
      snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"%s/%s",
               homedir, s___0);
      }
#line 48
      return (buf___0);
    }
  }
#line 50
  return (s___0);
}
}
#line 53 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
void do_log(char const   *line  , ...) 
{ 
  FILE *logfile ;
  char *logname ;
  char *tmp ;
  struct tm *ptr___1 ;
  time_t ttime ;
  va_list ap ;

  {
  {
#line 58
  tmp = pfix_home(logfname);
#line 58
  logname = tmp;
  }
#line 63
  if ((int )logfname[0] == 0) {
#line 64
    return;
  }
  {
#line 65
  logfile = fopen((char const   */* __restrict  */)logname, (char const   */* __restrict  */)"a");
  }
#line 66
  if (! logfile) {
#line 67
    return;
  }
  {
#line 69
  __builtin_va_start(ap, line);
#line 70
  ttime = time((time_t *)((void *)0));
#line 71
  ptr___1 = localtime((time_t const   *)(& ttime));
#line 73
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"%04d%02d%02d %02d:%02d:%02d ",
          ptr___1->tm_year + 1900, ptr___1->tm_mon + 1, ptr___1->tm_mday, ptr___1->tm_hour,
          ptr___1->tm_min, ptr___1->tm_sec);
#line 76
  vfprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)line,
           ap);
#line 77
  fprintf((FILE */* __restrict  */)logfile, (char const   */* __restrict  */)"\n");
#line 78
  fclose(logfile);
  }
#line 83
  return;
}
}
#line 87 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
size_t one_mbtowc(wchar_t *pwc , char const   *s___0 , size_t n ) 
{ 
  int len ;

  {
  {
#line 91
  len = mbtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s___0,
               n);
  }
#line 92
  if (len == -1) {
#line 93
    *pwc = (wchar_t )*s___0;
  }
#line 94
  if (len <= 0) {
#line 95
    len = 1;
  }
#line 96
  return ((size_t )len);
}
}
#line 101 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
size_t one_wctomb(char *s___0 , wchar_t wchar ) 
{ 
  int len ;

  {
  {
#line 106
  len = wctomb(s___0, wchar);
  }
#line 107
  if (len == -1) {
#line 108
    *(s___0 + 0) = (char )wchar;
  }
#line 109
  if (len <= 0) {
#line 110
    len = 1;
  }
#line 111
  return ((size_t )len);
}
}
#line 115 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
size_t mbslen(char const   *s___0 ) 
{ 
  size_t len ;
  wchar_t wc ;
  size_t tmp ;

  {
#line 120
  len = (size_t )0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((int const   )*s___0 != 0)) {
#line 121
      goto while_break;
    }
    {
#line 124
    tmp = one_mbtowc(& wc, s___0, (size_t )16);
#line 124
    s___0 += tmp;
#line 125
    len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (len);
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/configsym.h"
struct pars mpars[94] ;
#line 145 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
void mc_wflush(void) ;
#line 152
void mc_wredraw(WIN *w , int newdirect ) ;
#line 153
void mc_wscroll(WIN *win , int dir ) ;
#line 154
void mc_wlocate(WIN *win , int x , int y ) ;
#line 155
void mc_wputc(WIN *win , wchar_t c___0 ) ;
#line 157
void mc_wputs(WIN *win , char const   *s___0 ) ;
#line 161
void mc_wcursor(WIN *win , int type ) ;
#line 167
void mc_wclrch(WIN *w , int n ) ;
#line 168
void mc_wclrel(WIN *w ) ;
#line 169
void mc_wclreol(WIN *w ) ;
#line 170
void mc_wclrbol(WIN *w ) ;
#line 171
void mc_wclreos(WIN *w ) ;
#line 172
void mc_wclrbos(WIN *w ) ;
#line 173
void mc_winclr(WIN *w ) ;
#line 174
void mc_winsline(WIN *w ) ;
#line 175
void mc_wdelline(WIN *w ) ;
#line 176
void mc_winschar(WIN *w ) ;
#line 177
void mc_winschar2(WIN *w , wchar_t c___0 , int move ) ;
#line 178
void mc_wdelchar(WIN *w ) ;
#line 30 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.h"
int vt_nl_delay  ;
#line 31 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.h"
int vt_ch_delay  ;
#line 34
void vt_install(void (*fun1)(char const   * , int  ) , void (*fun2)(int  , int  ) ,
                WIN *win ) ;
#line 35
void vt_init(int type , int fg , int bg , int wrap , int add_lf , int add_cr ) ;
#line 36
void vt_pinit(WIN *win , int fg , int bg ) ;
#line 37
void vt_set(int addlf___0 , int wrap , int docap___0 , int bscode , int echo , int cursor ,
            int asis , int timestamp , int addcr___0 ) ;
#line 38
void vt_out(int ch ) ;
#line 39
void vt_send(int c___0 ) ;
#line 83 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
FILE *capfp ;
#line 144
unsigned char vt_outmap[256] ;
#line 144
unsigned char vt_inmap[256] ;
#line 156
int local_echo ;
#line 249
int using_iconv(void) ;
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int esc_s  =    0;
#line 60 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static struct escseq vt_keys[23]  = 
#line 60
  {      {257, "OP", "OP", "OP"}, 
        {258, "OQ", "OQ", "OQ"}, 
        {259, "OR", "OR", "OR"}, 
        {260, "OS", "OS", "OS"}, 
        {261, "[16~", "[16~", "OT"}, 
        {262, "[17~", "[17~", "OU"}, 
        {263, "[18~", "[18~", "OV"}, 
        {264, "[19~", "[19~", "OW"}, 
        {265, "[20~", "[20~", "OX"}, 
        {266, "[21~", "[21~", "OY"}, 
        {277, "[23~", "[23~", "OY"}, 
        {278, "[24~", "[24~", "OY"}, 
        {267, "[1~", "[1~", "[H"}, 
        {268, "[5~", "[5~", "[V"}, 
        {269, "[A", "OA", "[A"}, 
        {270, "[D", "OD", "[D"}, 
        {271, "[C", "OC", "[C"}, 
        {272, "[B", "OB", "[B"}, 
        {273, "[4~", "[4~", "[Y"}, 
        {274, "[6~", "[6~", "[U"}, 
        {275, "[2~", "[2~", "[@"}, 
        {276, "[3~", "[3~", "\177"}, 
        {0, (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 91 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
unsigned char vt_inmap[256]  = 
#line 91
  {      (unsigned char )'\000',      (unsigned char )'\001',      (unsigned char )'\002',      (unsigned char )'\003', 
        (unsigned char )'\004',      (unsigned char )'\005',      (unsigned char )'\006',      (unsigned char )'\a', 
        (unsigned char )'\b',      (unsigned char )'\t',      (unsigned char )'\n',      (unsigned char )'\v', 
        (unsigned char )'\f',      (unsigned char )'\r',      (unsigned char )'\016',      (unsigned char )'\017', 
        (unsigned char )'\020',      (unsigned char )'\021',      (unsigned char )'\022',      (unsigned char )'\023', 
        (unsigned char )'\024',      (unsigned char )'\025',      (unsigned char )'\026',      (unsigned char )'\027', 
        (unsigned char )'\030',      (unsigned char )'\031',      (unsigned char )'\032',      (unsigned char )'\033', 
        (unsigned char )'\034',      (unsigned char )'\035',      (unsigned char )'\036',      (unsigned char )'\037', 
        (unsigned char )' ',      (unsigned char )'!',      (unsigned char )'\"',      (unsigned char )'#', 
        (unsigned char )'$',      (unsigned char )'%',      (unsigned char )'&',      (unsigned char )'\'', 
        (unsigned char )'(',      (unsigned char )')',      (unsigned char )'*',      (unsigned char )'+', 
        (unsigned char )',',      (unsigned char )'-',      (unsigned char )'.',      (unsigned char )'/', 
        (unsigned char )'0',      (unsigned char )'1',      (unsigned char )'2',      (unsigned char )'3', 
        (unsigned char )'4',      (unsigned char )'5',      (unsigned char )'6',      (unsigned char )'7', 
        (unsigned char )'8',      (unsigned char )'9',      (unsigned char )':',      (unsigned char )';', 
        (unsigned char )'<',      (unsigned char )'=',      (unsigned char )'>',      (unsigned char )'?', 
        (unsigned char )'@',      (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'C', 
        (unsigned char )'D',      (unsigned char )'E',      (unsigned char )'F',      (unsigned char )'G', 
        (unsigned char )'H',      (unsigned char )'I',      (unsigned char )'J',      (unsigned char )'K', 
        (unsigned char )'L',      (unsigned char )'M',      (unsigned char )'N',      (unsigned char )'O', 
        (unsigned char )'P',      (unsigned char )'Q',      (unsigned char )'R',      (unsigned char )'S', 
        (unsigned char )'T',      (unsigned char )'U',      (unsigned char )'V',      (unsigned char )'W', 
        (unsigned char )'X',      (unsigned char )'Y',      (unsigned char )'Z',      (unsigned char )'[', 
        (unsigned char )'\\',      (unsigned char )']',      (unsigned char )'^',      (unsigned char )'_', 
        (unsigned char )'`',      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char )'{', 
        (unsigned char )'|',      (unsigned char )'}',      (unsigned char )'~',      (unsigned char )'\177', 
        (unsigned char )'\200',      (unsigned char )'\201',      (unsigned char )'\202',      (unsigned char )'\203', 
        (unsigned char )'\204',      (unsigned char )'\205',      (unsigned char )'\206',      (unsigned char )'\207', 
        (unsigned char )'\210',      (unsigned char )'\211',      (unsigned char )'\212',      (unsigned char )'\213', 
        (unsigned char )'\214',      (unsigned char )'\215',      (unsigned char )'\216',      (unsigned char )'\217', 
        (unsigned char )'\220',      (unsigned char )'\221',      (unsigned char )'\222',      (unsigned char )'\223', 
        (unsigned char )'\224',      (unsigned char )'\225',      (unsigned char )'\226',      (unsigned char )'\227', 
        (unsigned char )'\230',      (unsigned char )'\231',      (unsigned char )'\232',      (unsigned char )'\233', 
        (unsigned char )'\234',      (unsigned char )'\235',      (unsigned char )'\236',      (unsigned char )'\237', 
        (unsigned char )'\240',      (unsigned char )'\241',      (unsigned char )'\242',      (unsigned char )'\243', 
        (unsigned char )'\244',      (unsigned char )'\245',      (unsigned char )'\246',      (unsigned char )'\247', 
        (unsigned char )'\250',      (unsigned char )'\251',      (unsigned char )'\252',      (unsigned char )'\253', 
        (unsigned char )'\254',      (unsigned char )'\255',      (unsigned char )'\256',      (unsigned char )'\257', 
        (unsigned char )'\260',      (unsigned char )'\261',      (unsigned char )'\262',      (unsigned char )'\263', 
        (unsigned char )'\264',      (unsigned char )'\265',      (unsigned char )'\266',      (unsigned char )'\267', 
        (unsigned char )'\270',      (unsigned char )'\271',      (unsigned char )'\272',      (unsigned char )'\273', 
        (unsigned char )'\274',      (unsigned char )'\275',      (unsigned char )'\276',      (unsigned char )'\277', 
        (unsigned char )'\300',      (unsigned char )'\301',      (unsigned char )'\302',      (unsigned char )'\303', 
        (unsigned char )'\304',      (unsigned char )'\305',      (unsigned char )'\306',      (unsigned char )'\307', 
        (unsigned char )'\310',      (unsigned char )'\311',      (unsigned char )'\312',      (unsigned char )'\313', 
        (unsigned char )'\314',      (unsigned char )'\315',      (unsigned char )'\316',      (unsigned char )'\317', 
        (unsigned char )'\320',      (unsigned char )'\321',      (unsigned char )'\322',      (unsigned char )'\323', 
        (unsigned char )'\324',      (unsigned char )'\325',      (unsigned char )'\326',      (unsigned char )'\327', 
        (unsigned char )'\330',      (unsigned char )'\331',      (unsigned char )'\332',      (unsigned char )'\333', 
        (unsigned char )'\334',      (unsigned char )'\335',      (unsigned char )'\336',      (unsigned char )'\337', 
        (unsigned char )'\340',      (unsigned char )'\341',      (unsigned char )'\342',      (unsigned char )'\343', 
        (unsigned char )'\344',      (unsigned char )'\345',      (unsigned char )'\346',      (unsigned char )'\347', 
        (unsigned char )'\350',      (unsigned char )'\351',      (unsigned char )'\352',      (unsigned char )'\353', 
        (unsigned char )'\354',      (unsigned char )'\355',      (unsigned char )'\356',      (unsigned char )'\357', 
        (unsigned char )'\360',      (unsigned char )'\361',      (unsigned char )'\362',      (unsigned char )'\363', 
        (unsigned char )'\364',      (unsigned char )'\365',      (unsigned char )'\366',      (unsigned char )'\367', 
        (unsigned char )'\370',      (unsigned char )'\371',      (unsigned char )'\372',      (unsigned char )'\373', 
        (unsigned char )'\374',      (unsigned char )'\375',      (unsigned char )'\376',      (unsigned char )'\377'};
#line 94 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
unsigned char vt_outmap[256]  = 
#line 94
  {      (unsigned char )'\000',      (unsigned char )'\001',      (unsigned char )'\002',      (unsigned char )'\003', 
        (unsigned char )'\004',      (unsigned char )'\005',      (unsigned char )'\006',      (unsigned char )'\a', 
        (unsigned char )'\b',      (unsigned char )'\t',      (unsigned char )'\n',      (unsigned char )'\v', 
        (unsigned char )'\f',      (unsigned char )'\r',      (unsigned char )'\016',      (unsigned char )'\017', 
        (unsigned char )'\020',      (unsigned char )'\021',      (unsigned char )'\022',      (unsigned char )'\023', 
        (unsigned char )'\024',      (unsigned char )'\025',      (unsigned char )'\026',      (unsigned char )'\027', 
        (unsigned char )'\030',      (unsigned char )'\031',      (unsigned char )'\032',      (unsigned char )'\033', 
        (unsigned char )'\034',      (unsigned char )'\035',      (unsigned char )'\036',      (unsigned char )'\037', 
        (unsigned char )' ',      (unsigned char )'!',      (unsigned char )'\"',      (unsigned char )'#', 
        (unsigned char )'$',      (unsigned char )'%',      (unsigned char )'&',      (unsigned char )'\'', 
        (unsigned char )'(',      (unsigned char )')',      (unsigned char )'*',      (unsigned char )'+', 
        (unsigned char )',',      (unsigned char )'-',      (unsigned char )'.',      (unsigned char )'/', 
        (unsigned char )'0',      (unsigned char )'1',      (unsigned char )'2',      (unsigned char )'3', 
        (unsigned char )'4',      (unsigned char )'5',      (unsigned char )'6',      (unsigned char )'7', 
        (unsigned char )'8',      (unsigned char )'9',      (unsigned char )':',      (unsigned char )';', 
        (unsigned char )'<',      (unsigned char )'=',      (unsigned char )'>',      (unsigned char )'?', 
        (unsigned char )'@',      (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'C', 
        (unsigned char )'D',      (unsigned char )'E',      (unsigned char )'F',      (unsigned char )'G', 
        (unsigned char )'H',      (unsigned char )'I',      (unsigned char )'J',      (unsigned char )'K', 
        (unsigned char )'L',      (unsigned char )'M',      (unsigned char )'N',      (unsigned char )'O', 
        (unsigned char )'P',      (unsigned char )'Q',      (unsigned char )'R',      (unsigned char )'S', 
        (unsigned char )'T',      (unsigned char )'U',      (unsigned char )'V',      (unsigned char )'W', 
        (unsigned char )'X',      (unsigned char )'Y',      (unsigned char )'Z',      (unsigned char )'[', 
        (unsigned char )'\\',      (unsigned char )']',      (unsigned char )'^',      (unsigned char )'_', 
        (unsigned char )'`',      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char )'{', 
        (unsigned char )'|',      (unsigned char )'}',      (unsigned char )'~',      (unsigned char )'\177', 
        (unsigned char )'\200',      (unsigned char )'\201',      (unsigned char )'\202',      (unsigned char )'\203', 
        (unsigned char )'\204',      (unsigned char )'\205',      (unsigned char )'\206',      (unsigned char )'\207', 
        (unsigned char )'\210',      (unsigned char )'\211',      (unsigned char )'\212',      (unsigned char )'\213', 
        (unsigned char )'\214',      (unsigned char )'\215',      (unsigned char )'\216',      (unsigned char )'\217', 
        (unsigned char )'\220',      (unsigned char )'\221',      (unsigned char )'\222',      (unsigned char )'\223', 
        (unsigned char )'\224',      (unsigned char )'\225',      (unsigned char )'\226',      (unsigned char )'\227', 
        (unsigned char )'\230',      (unsigned char )'\231',      (unsigned char )'\232',      (unsigned char )'\233', 
        (unsigned char )'\234',      (unsigned char )'\235',      (unsigned char )'\236',      (unsigned char )'\237', 
        (unsigned char )'\240',      (unsigned char )'\241',      (unsigned char )'\242',      (unsigned char )'\243', 
        (unsigned char )'\244',      (unsigned char )'\245',      (unsigned char )'\246',      (unsigned char )'\247', 
        (unsigned char )'\250',      (unsigned char )'\251',      (unsigned char )'\252',      (unsigned char )'\253', 
        (unsigned char )'\254',      (unsigned char )'\255',      (unsigned char )'\256',      (unsigned char )'\257', 
        (unsigned char )'\260',      (unsigned char )'\261',      (unsigned char )'\262',      (unsigned char )'\263', 
        (unsigned char )'\264',      (unsigned char )'\265',      (unsigned char )'\266',      (unsigned char )'\267', 
        (unsigned char )'\270',      (unsigned char )'\271',      (unsigned char )'\272',      (unsigned char )'\273', 
        (unsigned char )'\274',      (unsigned char )'\275',      (unsigned char )'\276',      (unsigned char )'\277', 
        (unsigned char )'\300',      (unsigned char )'\301',      (unsigned char )'\302',      (unsigned char )'\303', 
        (unsigned char )'\304',      (unsigned char )'\305',      (unsigned char )'\306',      (unsigned char )'\307', 
        (unsigned char )'\310',      (unsigned char )'\311',      (unsigned char )'\312',      (unsigned char )'\313', 
        (unsigned char )'\314',      (unsigned char )'\315',      (unsigned char )'\316',      (unsigned char )'\317', 
        (unsigned char )'\320',      (unsigned char )'\321',      (unsigned char )'\322',      (unsigned char )'\323', 
        (unsigned char )'\324',      (unsigned char )'\325',      (unsigned char )'\326',      (unsigned char )'\327', 
        (unsigned char )'\330',      (unsigned char )'\331',      (unsigned char )'\332',      (unsigned char )'\333', 
        (unsigned char )'\334',      (unsigned char )'\335',      (unsigned char )'\336',      (unsigned char )'\337', 
        (unsigned char )'\340',      (unsigned char )'\341',      (unsigned char )'\342',      (unsigned char )'\343', 
        (unsigned char )'\344',      (unsigned char )'\345',      (unsigned char )'\346',      (unsigned char )'\347', 
        (unsigned char )'\350',      (unsigned char )'\351',      (unsigned char )'\352',      (unsigned char )'\353', 
        (unsigned char )'\354',      (unsigned char )'\355',      (unsigned char )'\356',      (unsigned char )'\357', 
        (unsigned char )'\360',      (unsigned char )'\361',      (unsigned char )'\362',      (unsigned char )'\363', 
        (unsigned char )'\364',      (unsigned char )'\365',      (unsigned char )'\366',      (unsigned char )'\367', 
        (unsigned char )'\370',      (unsigned char )'\371',      (unsigned char )'\372',      (unsigned char )'\373', 
        (unsigned char )'\374',      (unsigned char )'\375',      (unsigned char )'\376',      (unsigned char )'\377'};
#line 100 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *vt_map[2]  = {      (char *)"................................ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~.................................\377\255\233\234\376\235|\025\376\376\246\256\252-\376\376\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376\376\245\376\376\376\376\231\376\350\376\376\376\232\376\376\341\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213\376\244\225\242\223\376\224\366\355\227\243\226\201\376\376\230",      (char *)"................\000\000\000\000\000\000\000\000\000\000\376\000\000\000\000\000 !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ \004\261\a\a\a\a\370\361\a\a\331\277\332\300\305\304\304\304__\303\264\301\302\263\363\362\343\330\234\a\000................................\377\255\233\234\376\235|\025\376\376\246\256\252-\376\376\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376\376\245\376\376\376\376\231\376\376\376\376\376\232\376\376\341\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213\376\244\225\242\223\376\224\366\376\227\243\226\201\376\376\230"};
#line 131 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *vt_trans[2]  ;
#line 132 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_charset  ;
#line 135 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_echo  ;
#line 138 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_type  =    3;
#line 139 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_wrap  ;
#line 140 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_addlf  ;
#line 141 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_addcr  ;
#line 142 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_fg  ;
#line 143 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_bg  ;
#line 144 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_keypad  ;
#line 145 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_cursor  ;
#line 146 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_asis  ;
#line 147 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_line_timestamp  ;
#line 148 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_bs  =    8;
#line 149 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_insert  ;
#line 150 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_crlf  ;
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_om  ;
#line 152 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
WIN *vt_win  ;
#line 153 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_docap  ;
#line 154 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void (*vt_keyb)(int  , int  )  ;
#line 155 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void (*termout)(char const   * , int  )  ;
#line 157 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int escparms[8]  ;
#line 158 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int ptr  ;
#line 159 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static long vt_tabs[5]  ;
#line 161 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short newy1  =    (short)0;
#line 162 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short newy2  =    (short)23;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savex  ;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savey  ;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short saveattr  =    (short)0;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savecol  =    (short)112;
#line 168 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savecharset  ;
#line 169 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *savetrans[2]  ;
#line 175 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_install(void (*fun1)(char const   * , int  ) , void (*fun2)(int  , int  ) ,
                WIN *win ) 
{ 


  {
#line 178
  termout = fun1;
#line 179
  vt_keyb = fun2;
#line 180
  vt_win = win;
#line 181
  return;
}
}
#line 184 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_pinit(WIN *win , int fg , int bg ) 
{ 


  {
#line 186
  vt_win = win;
#line 187
  newy1 = (short)0;
#line 188
  newy2 = (short )(vt_win->ys - 1);
#line 189
  vt_win->sy1 = vt_win->y1;
#line 189
  vt_win->sy2 = vt_win->y2;
#line 190
  if (fg > 0) {
#line 191
    vt_fg = fg;
  }
#line 192
  if (bg > 0) {
#line 193
    vt_bg = bg;
  }
#line 194
  vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg << 4));
#line 195
  vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg);
#line 196
  return;
}
}
#line 199 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_init(int type , int fg , int bg , int wrap , int add_lf , int add_cr ) 
{ 


  {
#line 201
  vt_type = type;
#line 202
  if (vt_type == 3) {
#line 203
    vt_fg = 7;
#line 204
    vt_bg = 0;
  } else {
#line 206
    vt_fg = fg;
#line 207
    vt_bg = bg;
  }
#line 209
  if (wrap >= 0) {
#line 210
    vt_wrap = wrap;
#line 210
    vt_win->wrap = (char )vt_wrap;
  }
  {
#line 211
  vt_addlf = add_lf;
#line 212
  vt_addcr = add_cr;
#line 213
  vt_insert = 0;
#line 214
  vt_crlf = 0;
#line 215
  vt_om = 0;
#line 217
  newy1 = (short)0;
#line 218
  newy2 = (short )(vt_win->ys - 1);
#line 219
  vt_win->sy1 = vt_win->y1;
#line 219
  vt_win->sy2 = vt_win->y2;
#line 220
  vt_keypad = 1;
#line 221
  vt_cursor = 1;
#line 222
  vt_echo = local_echo;
#line 223
  vt_tabs[0] = 16843008L;
#line 224
  vt_tabs[4] = 16843009L;
#line 224
  vt_tabs[3] = vt_tabs[4];
#line 224
  vt_tabs[2] = vt_tabs[3];
#line 224
  vt_tabs[1] = vt_tabs[2];
#line 229
  vt_charset = 0;
#line 230
  savetrans[0] = vt_map[0];
#line 230
  vt_trans[0] = savetrans[0];
#line 231
  savetrans[1] = vt_map[1];
#line 231
  vt_trans[1] = savetrans[1];
#line 233
  ptr = 0;
#line 234
  memset((void *)(escparms), 0, sizeof(escparms));
#line 235
  esc_s = 0;
  }
#line 237
  if (vt_keyb) {
    {
#line 238
    (*vt_keyb)(vt_keypad, vt_cursor);
    }
  }
#line 239
  vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg << 4));
#line 240
  vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg);
#line 241
  return;
}
}
#line 244 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_set(int addlf___0 , int wrap , int docap___0 , int bscode , int echo , int cursor ,
            int asis , int timestamp , int addcr___0 ) 
{ 


  {
#line 248
  if (addlf___0 >= 0) {
#line 249
    vt_addlf = addlf___0;
  }
#line 250
  if (wrap >= 0) {
#line 251
    vt_wrap = wrap;
#line 251
    vt_win->wrap = (char )vt_wrap;
  }
#line 252
  if (docap___0 >= 0) {
#line 253
    vt_docap = docap___0;
  }
#line 254
  if (bscode >= 0) {
#line 255
    vt_bs = bscode;
  }
#line 256
  if (echo >= 0) {
#line 257
    vt_echo = echo;
  }
#line 258
  if (cursor >= 0) {
#line 259
    vt_cursor = cursor;
  }
#line 260
  if (asis >= 0) {
#line 261
    vt_asis = asis;
  }
#line 262
  if (timestamp >= 0) {
#line 263
    vt_line_timestamp = timestamp;
  }
#line 264
  if (addcr___0 >= 0) {
#line 265
    vt_addcr = addcr___0;
  }
#line 266
  return;
}
}
#line 269 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void v_termout(char const   *s___0 , int len ) 
{ 
  char const   *p ;

  {
#line 273
  if (vt_echo) {
#line 274
    p = s___0;
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (! *p) {
#line 274
        goto while_break;
      }
      {
#line 275
      vt_out((int )*p);
      }
#line 276
      if (! vt_addlf) {
#line 276
        if ((int const   )*p == 13) {
          {
#line 277
          vt_out('\n');
          }
        }
      }
#line 274
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 279
    mc_wflush();
    }
  }
  {
#line 282
  (*termout)(s___0, len);
  }
#line 283
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state1(int c___0 ) 
{ 
  short x ;
  short y ;
  short f ;

  {
  {
#line 297
  if (c___0 == 91) {
#line 297
    goto case_91;
  }
#line 300
  if (c___0 == 40) {
#line 300
    goto case_40;
  }
#line 303
  if (c___0 == 41) {
#line 303
    goto case_41;
  }
#line 306
  if (c___0 == 35) {
#line 306
    goto case_35;
  }
#line 309
  if (c___0 == 80) {
#line 309
    goto case_80;
  }
#line 313
  if (c___0 == 77) {
#line 313
    goto case_77;
  }
#line 313
  if (c___0 == 68) {
#line 313
    goto case_77;
  }
#line 330
  if (c___0 == 69) {
#line 330
    goto case_69;
  }
#line 334
  if (c___0 == 115) {
#line 334
    goto case_115;
  }
#line 334
  if (c___0 == 55) {
#line 334
    goto case_115;
  }
#line 346
  if (c___0 == 117) {
#line 346
    goto case_117;
  }
#line 346
  if (c___0 == 56) {
#line 346
    goto case_117;
  }
#line 356
  if (c___0 == 61) {
#line 356
    goto case_61;
  }
#line 361
  if (c___0 == 62) {
#line 361
    goto case_62;
  }
#line 366
  if (c___0 == 90) {
#line 366
    goto case_90;
  }
#line 372
  if (c___0 == 99) {
#line 372
    goto case_99;
  }
#line 382
  if (c___0 == 72) {
#line 382
    goto case_72;
  }
#line 391
  goto switch_default;
  case_91: /* CIL Label */ 
#line 298
  esc_s = 2;
#line 299
  return;
  case_40: /* CIL Label */ 
#line 301
  esc_s = 4;
#line 302
  return;
  case_41: /* CIL Label */ 
#line 304
  esc_s = 5;
#line 305
  return;
  case_35: /* CIL Label */ 
#line 307
  esc_s = 6;
#line 308
  return;
  case_80: /* CIL Label */ 
#line 310
  esc_s = 7;
#line 311
  return;
  case_77: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 314
  x = vt_win->curx;
#line 315
  if (c___0 == 68) {
#line 316
    y = (short )((int )vt_win->cury + 1);
#line 317
    if ((int )y == (int )newy2 + 1) {
      {
#line 318
      mc_wscroll(vt_win, 1);
      }
    } else
#line 319
    if ((int )vt_win->cury < vt_win->ys) {
      {
#line 320
      mc_wlocate(vt_win, (int )x, (int )y);
      }
    }
  }
#line 322
  if (c___0 == 77) {
#line 323
    y = (short )((int )vt_win->cury - 1);
#line 324
    if ((int )y == (int )newy1 - 1) {
      {
#line 325
      mc_wscroll(vt_win, 2);
      }
    } else
#line 326
    if ((int )y >= 0) {
      {
#line 327
      mc_wlocate(vt_win, (int )x, (int )y);
      }
    }
  }
#line 329
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 331
  mc_wputs(vt_win, "\r\n");
  }
#line 332
  goto switch_break;
  case_115: /* CIL Label */ 
  case_55: /* CIL Label */ 
#line 335
  savex = vt_win->curx;
#line 336
  savey = vt_win->cury;
#line 337
  saveattr = (short )vt_win->attr;
#line 338
  savecol = (short )vt_win->color;
#line 340
  savecharset = (short )vt_charset;
#line 341
  savetrans[0] = vt_trans[0];
#line 342
  savetrans[1] = vt_trans[1];
#line 344
  goto switch_break;
  case_117: /* CIL Label */ 
  case_56: /* CIL Label */ 
  {
#line 348
  vt_charset = (int )savecharset;
#line 349
  vt_trans[0] = savetrans[0];
#line 350
  vt_trans[1] = savetrans[1];
#line 352
  vt_win->color = (char )savecol;
#line 353
  vt_win->attr = (char )saveattr;
#line 354
  mc_wlocate(vt_win, (int )savex, (int )savey);
  }
#line 355
  goto switch_break;
  case_61: /* CIL Label */ 
#line 357
  vt_keypad = 2;
#line 358
  if (vt_keyb) {
    {
#line 359
    (*vt_keyb)(vt_keypad, vt_cursor);
    }
  }
#line 360
  goto switch_break;
  case_62: /* CIL Label */ 
#line 362
  vt_keypad = 1;
#line 363
  if (vt_keyb) {
    {
#line 364
    (*vt_keyb)(vt_keypad, vt_cursor);
    }
  }
#line 365
  goto switch_break;
  case_90: /* CIL Label */ 
#line 367
  if (vt_type == 1) {
    {
#line 368
    v_termout("\033[?1;0c", 0);
    }
  } else {
    {
#line 370
    v_termout("\033[?c", 0);
    }
  }
#line 371
  goto switch_break;
  case_99: /* CIL Label */ 
#line 373
  f = (short)0;
#line 374
  vt_win->attr = (char )f;
#line 375
  vt_win->wrap = (char )(vt_type != 1);
#line 376
  if (vt_wrap != -1) {
#line 377
    vt_win->wrap = (char )vt_wrap;
  }
  {
#line 378
  vt_insert = 0;
#line 378
  vt_crlf = vt_insert;
#line 379
  vt_init(vt_type, vt_fg, vt_bg, (int )vt_win->wrap, 0, 0);
#line 380
  mc_wlocate(vt_win, 0, 0);
  }
#line 381
  goto switch_break;
  case_72: /* CIL Label */ 
#line 383
  x = vt_win->curx;
#line 384
  if ((int )x > 159) {
#line 385
    x = (short)159;
  }
#line 386
  vt_tabs[(int )x / 32] |= (long )(1 << (int )x % 32);
#line 387
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 393
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 395
  esc_s = 0;
#line 396
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void ansi_mode(int on_off ) 
{ 
  int i ;

  {
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i <= ptr)) {
#line 403
      goto while_break;
    }
    {
#line 405
    if (escparms[i] == 4) {
#line 405
      goto case_4;
    }
#line 408
    if (escparms[i] == 20) {
#line 408
      goto case_20;
    }
#line 404
    goto switch_break;
    case_4: /* CIL Label */ 
#line 406
    vt_insert = on_off;
#line 407
    goto switch_break;
    case_20: /* CIL Label */ 
#line 409
    vt_crlf = on_off;
#line 410
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return;
}
}
#line 418 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state2(int c___0 ) 
{ 
  short x ;
  short y ;
  short attr ;
  short f ;
  char temp[32] ;
  int tmp ;

  {
#line 424
  if (c___0 >= 48) {
#line 424
    if (c___0 <= 57) {
#line 425
      escparms[ptr] = (10 * escparms[ptr] + c___0) - 48;
#line 426
      return;
    }
  }
#line 429
  if (c___0 == 59) {
#line 430
    if (ptr < 15) {
#line 431
      ptr ++;
    }
#line 432
    return;
  }
#line 435
  if (escparms[0] == 0) {
#line 435
    if (ptr == 0) {
#line 435
      if (c___0 == 63) {
#line 437
        esc_s = 3;
#line 438
        return;
      }
    }
  }
  {
#line 446
  if (c___0 == 68) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 67) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 66) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 65) {
#line 446
    goto case_68;
  }
#line 472
  if (c___0 == 88) {
#line 472
    goto case_88;
  }
#line 477
  if (c___0 == 75) {
#line 477
    goto case_75;
  }
#line 490
  if (c___0 == 74) {
#line 490
    goto case_74;
  }
#line 514
  if (c___0 == 110) {
#line 514
    goto case_110;
  }
#line 525
  if (c___0 == 99) {
#line 525
    goto case_99;
  }
#line 532
  if (c___0 == 120) {
#line 532
    goto case_120;
  }
#line 537
  if (c___0 == 115) {
#line 537
    goto case_115;
  }
#line 548
  if (c___0 == 117) {
#line 548
    goto case_117;
  }
#line 558
  if (c___0 == 104) {
#line 558
    goto case_104;
  }
#line 561
  if (c___0 == 108) {
#line 561
    goto case_108;
  }
#line 565
  if (c___0 == 102) {
#line 565
    goto case_102;
  }
#line 565
  if (c___0 == 72) {
#line 565
    goto case_102;
  }
#line 574
  if (c___0 == 103) {
#line 574
    goto case_103;
  }
#line 585
  if (c___0 == 109) {
#line 585
    goto case_109;
  }
#line 632
  if (c___0 == 76) {
#line 632
    goto case_76;
  }
#line 638
  if (c___0 == 77) {
#line 638
    goto case_77;
  }
#line 644
  if (c___0 == 80) {
#line 644
    goto case_80;
  }
#line 650
  if (c___0 == 64) {
#line 650
    goto case_64;
  }
#line 656
  if (c___0 == 114) {
#line 656
    goto case_114;
  }
#line 679
  goto switch_default;
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 447
  f = (short )escparms[0];
#line 447
  if ((int )f == 0) {
#line 448
    f = (short)1;
  }
#line 449
  x = vt_win->curx;
#line 450
  y = vt_win->cury;
#line 451
  x = (short )((int )x + (int )f * ((c___0 == 67) - (c___0 == 68)));
#line 452
  if ((int )x < 0) {
#line 453
    x = (short)0;
  }
#line 454
  if ((int )x >= vt_win->xs) {
#line 455
    x = (short )(vt_win->xs - 1);
  }
#line 456
  if (c___0 == 66) {
#line 457
    y = (short )((int )y + (int )f);
#line 458
    if ((int )y >= vt_win->ys) {
#line 459
      y = (short )(vt_win->ys - 1);
    }
#line 460
    if ((int )y >= (int )newy2 + 1) {
#line 461
      y = newy2;
    }
  }
#line 463
  if (c___0 == 65) {
#line 464
    y = (short )((int )y - (int )f);
#line 465
    if ((int )y < 0) {
#line 466
      y = (short)0;
    }
#line 467
    if ((int )y <= (int )newy1 - 1) {
#line 468
      y = newy1;
    }
  }
  {
#line 470
  mc_wlocate(vt_win, (int )x, (int )y);
  }
#line 471
  goto switch_break;
  case_88: /* CIL Label */ 
#line 473
  f = (short )escparms[0];
#line 473
  if ((int )f == 0) {
#line 474
    f = (short)1;
  }
  {
#line 475
  mc_wclrch(vt_win, (int )f);
  }
#line 476
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 479
  if (escparms[0] == 0) {
#line 479
    goto case_0;
  }
#line 482
  if (escparms[0] == 1) {
#line 482
    goto case_1;
  }
#line 485
  if (escparms[0] == 2) {
#line 485
    goto case_2;
  }
#line 478
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 480
  mc_wclreol(vt_win);
  }
#line 481
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 483
  mc_wclrbol(vt_win);
  }
#line 484
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 486
  mc_wclrel(vt_win);
  }
#line 487
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 489
  goto switch_break;
  case_74: /* CIL Label */ 
#line 491
  x = (short )vt_win->color;
#line 492
  y = (short )vt_win->attr;
#line 493
  if (vt_type == 3) {
#line 494
    vt_win->attr = (char)0;
#line 495
    vt_win->color = (char )(((int )vt_win->color & 15) + (7 << 4));
#line 496
    vt_win->color = (char )((int )vt_win->color & 240);
  }
  {
#line 499
  if (escparms[0] == 0) {
#line 499
    goto case_0___0;
  }
#line 502
  if (escparms[0] == 1) {
#line 502
    goto case_1___0;
  }
#line 505
  if (escparms[0] == 2) {
#line 505
    goto case_2___0;
  }
#line 498
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
  {
#line 500
  mc_wclreos(vt_win);
  }
#line 501
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 503
  mc_wclrbos(vt_win);
  }
#line 504
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 506
  mc_winclr(vt_win);
  }
#line 507
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 509
  if (vt_type == 3) {
#line 510
    vt_win->color = (char )x;
#line 511
    vt_win->attr = (char )y;
  }
#line 513
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 516
  if (escparms[0] == 5) {
#line 516
    goto case_5;
  }
#line 519
  if (escparms[0] == 6) {
#line 519
    goto case_6;
  }
#line 515
  goto switch_break___2;
  case_5: /* CIL Label */ 
  {
#line 517
  v_termout("\033[0n", 0);
  }
#line 518
  goto switch_break___2;
  case_6: /* CIL Label */ 
  {
#line 520
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"\033[%d;%dR",
          (int )vt_win->cury + 1, (int )vt_win->curx + 1);
#line 521
  v_termout((char const   *)(temp), 0);
  }
#line 522
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 524
  goto switch_break;
  case_99: /* CIL Label */ 
#line 526
  if (vt_type == 1) {
    {
#line 527
    v_termout("\033[?1;2c", 0);
    }
#line 528
    goto switch_break;
  }
  {
#line 530
  v_termout("\033[?c", 0);
  }
#line 531
  goto switch_break;
  case_120: /* CIL Label */ 
#line 534
  if (escparms[0] == 1) {
#line 534
    tmp = '3';
  } else {
#line 534
    tmp = '2';
  }
  {
#line 534
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"\033[%c;1;1;120;120;1;0x",
          tmp);
#line 535
  v_termout((char const   *)(temp), 0);
  }
#line 536
  goto switch_break;
  case_115: /* CIL Label */ 
#line 538
  savex = vt_win->curx;
#line 539
  savey = vt_win->cury;
#line 540
  saveattr = (short )vt_win->attr;
#line 541
  savecol = (short )vt_win->color;
#line 543
  savecharset = (short )vt_charset;
#line 544
  savetrans[0] = vt_trans[0];
#line 545
  savetrans[1] = vt_trans[1];
#line 547
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 550
  vt_charset = (int )savecharset;
#line 551
  vt_trans[0] = savetrans[0];
#line 552
  vt_trans[1] = savetrans[1];
#line 554
  vt_win->color = (char )savecol;
#line 555
  vt_win->attr = (char )saveattr;
#line 556
  mc_wlocate(vt_win, (int )savex, (int )savey);
  }
#line 557
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 559
  ansi_mode(1);
  }
#line 560
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 562
  ansi_mode(0);
  }
#line 563
  goto switch_break;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 566
  y = (short )escparms[0];
#line 566
  if ((int )y == 0) {
#line 567
    y = (short)1;
  }
#line 568
  x = (short )escparms[1];
#line 568
  if ((int )x == 0) {
#line 569
    x = (short)1;
  }
#line 570
  if (vt_om) {
#line 571
    y = (short )((int )y + (int )newy1);
  }
  {
#line 572
  mc_wlocate(vt_win, (int )x - 1, (int )y - 1);
  }
#line 573
  goto switch_break;
  case_103: /* CIL Label */ 
#line 575
  if (escparms[0] == 0) {
#line 576
    x = vt_win->curx;
#line 577
    if ((int )x > 159) {
#line 578
      x = (short)159;
    }
#line 579
    vt_tabs[(int )x / 32] &= (long )(~ (1 << (int )x % 32));
  }
#line 581
  if (escparms[0] == 3) {
#line 582
    x = (short)0;
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 582
      if (! ((int )x < 5)) {
#line 582
        goto while_break;
      }
#line 583
      vt_tabs[x] = 0L;
#line 582
      x = (short )((int )x + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 584
  goto switch_break;
  case_109: /* CIL Label */ 
#line 586
  attr = (short )vt_win->attr;
#line 587
  f = (short)0;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! ((int )f <= ptr)) {
#line 587
      goto while_break___0;
    }
#line 588
    if (escparms[f] >= 30) {
#line 588
      if (escparms[f] <= 37) {
#line 589
        vt_win->color = (char )(((int )vt_win->color & 15) + ((escparms[f] - 30) << 4));
      }
    }
#line 590
    if (escparms[f] >= 40) {
#line 590
      if (escparms[f] <= 47) {
#line 591
        vt_win->color = (char )(((int )vt_win->color & 240) + (escparms[f] - 40));
      }
    }
    {
#line 593
    if (escparms[f] == 0) {
#line 593
      goto case_0___1;
    }
#line 598
    if (escparms[f] == 1) {
#line 598
      goto case_1___1;
    }
#line 601
    if (escparms[f] == 4) {
#line 601
      goto case_4;
    }
#line 604
    if (escparms[f] == 5) {
#line 604
      goto case_5___0;
    }
#line 607
    if (escparms[f] == 7) {
#line 607
      goto case_7;
    }
#line 610
    if (escparms[f] == 22) {
#line 610
      goto case_22;
    }
#line 613
    if (escparms[f] == 24) {
#line 613
      goto case_24;
    }
#line 616
    if (escparms[f] == 25) {
#line 616
      goto case_25;
    }
#line 619
    if (escparms[f] == 27) {
#line 619
      goto case_27;
    }
#line 622
    if (escparms[f] == 39) {
#line 622
      goto case_39;
    }
#line 625
    if (escparms[f] == 49) {
#line 625
      goto case_49;
    }
#line 592
    goto switch_break___3;
    case_0___1: /* CIL Label */ 
#line 594
    attr = (short)0;
#line 595
    vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg << 4));
#line 596
    vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg);
#line 597
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
#line 599
    attr = (short )((int )attr | 2);
#line 600
    goto switch_break___3;
    case_4: /* CIL Label */ 
#line 602
    attr = (short )((int )attr | 16);
#line 603
    goto switch_break___3;
    case_5___0: /* CIL Label */ 
#line 605
    attr = (short )((int )attr | 1);
#line 606
    goto switch_break___3;
    case_7: /* CIL Label */ 
#line 608
    attr = (short )((int )attr | 4);
#line 609
    goto switch_break___3;
    case_22: /* CIL Label */ 
#line 611
    attr = (short )((int )attr & -3);
#line 612
    goto switch_break___3;
    case_24: /* CIL Label */ 
#line 614
    attr = (short )((int )attr & -17);
#line 615
    goto switch_break___3;
    case_25: /* CIL Label */ 
#line 617
    attr = (short )((int )attr & -2);
#line 618
    goto switch_break___3;
    case_27: /* CIL Label */ 
#line 620
    attr = (short )((int )attr & -5);
#line 621
    goto switch_break___3;
    case_39: /* CIL Label */ 
#line 623
    vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg << 4));
#line 624
    goto switch_break___3;
    case_49: /* CIL Label */ 
#line 626
    vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg);
#line 627
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 587
    f = (short )((int )f + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 630
  vt_win->attr = (char )attr;
#line 631
  goto switch_break;
  case_76: /* CIL Label */ 
#line 633
  x = (short )escparms[0];
#line 633
  if ((int )x == 0) {
#line 634
    x = (short)1;
  }
#line 635
  f = (short)0;
  {
#line 635
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 635
    if (! ((int )f < (int )x)) {
#line 635
      goto while_break___1;
    }
    {
#line 636
    mc_winsline(vt_win);
#line 635
    f = (short )((int )f + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 637
  goto switch_break;
  case_77: /* CIL Label */ 
#line 639
  x = (short )escparms[0];
#line 639
  if ((int )x == 0) {
#line 640
    x = (short)1;
  }
#line 641
  f = (short)0;
  {
#line 641
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 641
    if (! ((int )f < (int )x)) {
#line 641
      goto while_break___2;
    }
    {
#line 642
    mc_wdelline(vt_win);
#line 641
    f = (short )((int )f + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 643
  goto switch_break;
  case_80: /* CIL Label */ 
#line 645
  x = (short )escparms[0];
#line 645
  if ((int )x == 0) {
#line 646
    x = (short)1;
  }
#line 647
  f = (short)0;
  {
#line 647
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 647
    if (! ((int )f < (int )x)) {
#line 647
      goto while_break___3;
    }
    {
#line 648
    mc_wdelchar(vt_win);
#line 647
    f = (short )((int )f + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 649
  goto switch_break;
  case_64: /* CIL Label */ 
#line 651
  x = (short )escparms[0];
#line 651
  if ((int )x == 0) {
#line 652
    x = (short)1;
  }
#line 653
  f = (short)0;
  {
#line 653
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 653
    if (! ((int )f < (int )x)) {
#line 653
      goto while_break___4;
    }
    {
#line 654
    mc_winschar(vt_win);
#line 653
    f = (short )((int )f + 1);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 655
  goto switch_break;
  case_114: /* CIL Label */ 
#line 657
  newy1 = (short )escparms[0];
#line 657
  if ((int )newy1 == 0) {
#line 658
    newy1 = (short)1;
  }
#line 659
  newy2 = (short )escparms[1];
#line 659
  if ((int )newy2 == 0) {
#line 660
    newy2 = (short )vt_win->ys;
  }
#line 661
  newy1 = (short )((int )newy1 - 1);
#line 661
  newy2 = (short )((int )newy2 - 1);
#line 662
  if ((int )newy1 < 0) {
#line 663
    newy1 = (short)0;
  }
#line 664
  if ((int )newy2 < 0) {
#line 665
    newy2 = (short)0;
  }
#line 666
  if ((int )newy1 >= vt_win->ys) {
#line 667
    newy1 = (short )(vt_win->ys - 1);
  }
#line 668
  if ((int )newy2 >= vt_win->ys) {
#line 669
    newy2 = (short )(vt_win->ys - 1);
  }
#line 670
  if ((int )newy1 >= (int )newy2) {
#line 671
    newy1 = (short)0;
#line 672
    newy2 = (short )(vt_win->ys - 1);
  }
  {
#line 674
  vt_win->sy1 = vt_win->y1 + (int )newy1;
#line 674
  vt_win->sy2 = vt_win->y1 + (int )newy2;
#line 675
  mc_wlocate(vt_win, 0, (int )newy1);
  }
#line 676
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 681
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 684
  esc_s = 0;
#line 685
  ptr = 0;
#line 686
  memset((void *)(escparms), 0, sizeof(escparms));
  }
#line 687
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void dec_mode(int on_off ) 
{ 
  int i ;
  int tmp ;

  {
#line 695
  i = 0;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (i <= ptr)) {
#line 695
      goto while_break;
    }
    {
#line 697
    if (escparms[i] == 1) {
#line 697
      goto case_1;
    }
#line 702
    if (escparms[i] == 6) {
#line 702
      goto case_6;
    }
#line 706
    if (escparms[i] == 7) {
#line 706
      goto case_7;
    }
#line 709
    if (escparms[i] == 25) {
#line 709
      goto case_25;
    }
#line 712
    if (escparms[i] == 67) {
#line 712
      goto case_67;
    }
#line 715
    goto switch_default;
    case_1: /* CIL Label */ 
#line 698
    if (on_off) {
#line 698
      vt_cursor = 2;
    } else {
#line 698
      vt_cursor = 1;
    }
#line 699
    if (vt_keyb) {
      {
#line 700
      (*vt_keyb)(vt_keypad, vt_cursor);
      }
    }
#line 701
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 703
    vt_om = on_off;
#line 704
    mc_wlocate(vt_win, 0, (int )newy1);
    }
#line 705
    goto switch_break;
    case_7: /* CIL Label */ 
#line 707
    vt_win->wrap = (char )on_off;
#line 708
    goto switch_break;
    case_25: /* CIL Label */ 
#line 710
    if (on_off) {
#line 710
      tmp = 1;
    } else {
#line 710
      tmp = 0;
    }
    {
#line 710
    mc_wcursor(vt_win, tmp);
    }
#line 711
    goto switch_break;
    case_67: /* CIL Label */ 
#line 714
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 717
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 725 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state3(int c___0 ) 
{ 


  {
#line 728
  if (c___0 >= 48) {
#line 728
    if (c___0 <= 57) {
#line 729
      escparms[ptr] = (10 * escparms[ptr] + c___0) - 48;
#line 730
      return;
    }
  }
  {
#line 733
  if (c___0 == 104) {
#line 733
    goto case_104;
  }
#line 736
  if (c___0 == 108) {
#line 736
    goto case_108;
  }
#line 741
  goto switch_default;
  case_104: /* CIL Label */ 
  {
#line 734
  dec_mode(1);
  }
#line 735
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 737
  dec_mode(0);
  }
#line 738
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 743
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 745
  esc_s = 0;
#line 746
  ptr = 0;
#line 747
  memset((void *)(escparms), 0, sizeof(escparms));
  }
#line 748
  return;
}
}
#line 754 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state4(int c___0 ) 
{ 


  {
  {
#line 763
  if (c___0 == 66) {
#line 763
    goto case_66;
  }
#line 763
  if (c___0 == 65) {
#line 763
    goto case_66;
  }
#line 767
  if (c___0 == 79) {
#line 767
    goto case_79;
  }
#line 767
  if (c___0 == 48) {
#line 767
    goto case_79;
  }
#line 761
  goto switch_break;
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 764
  vt_trans[0] = vt_map[0];
#line 765
  goto switch_break;
  case_79: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 768
  vt_trans[0] = vt_map[1];
#line 769
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 772
  esc_s = 0;
#line 773
  return;
}
}
#line 778 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state5(int c___0 ) 
{ 


  {
  {
#line 787
  if (c___0 == 66) {
#line 787
    goto case_66;
  }
#line 787
  if (c___0 == 65) {
#line 787
    goto case_66;
  }
#line 791
  if (c___0 == 48) {
#line 791
    goto case_48;
  }
#line 791
  if (c___0 == 79) {
#line 791
    goto case_48;
  }
#line 785
  goto switch_break;
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 788
  vt_trans[1] = vt_map[0];
#line 789
  goto switch_break;
  case_48: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 792
  vt_trans[1] = vt_map[1];
#line 793
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 796
  esc_s = 0;
#line 797
  return;
}
}
#line 802 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state6(int c___0 ) 
{ 
  int x ;
  int y ;

  {
  {
#line 808
  if (c___0 == 56) {
#line 808
    goto case_56;
  }
#line 822
  goto switch_default;
  case_56: /* CIL Label */ 
  {
#line 810
  vt_win->doscroll = (char)0;
#line 811
  vt_win->direct = (char)0;
#line 812
  mc_wlocate(vt_win, 0, 0);
#line 813
  y = 0;
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! (y < vt_win->ys)) {
#line 813
      goto while_break;
    }
    {
#line 814
    mc_wlocate(vt_win, 0, y);
#line 815
    x = 0;
    }
    {
#line 815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 815
      if (! (x < vt_win->xs)) {
#line 815
        goto while_break___0;
      }
      {
#line 816
      mc_wputc(vt_win, 'E');
#line 815
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 813
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  mc_wlocate(vt_win, 0, 0);
#line 819
  vt_win->doscroll = (char)1;
#line 820
  mc_wredraw(vt_win, 1);
  }
#line 821
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 824
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 826
  esc_s = 0;
#line 827
  return;
}
}
#line 839 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char buf___1[17]  ;
#line 840
static void state7(int c___0 ) ;
#line 840 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int pos  =    0;
#line 841 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int state  =    0;
#line 832 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state7(int c___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 843
  if (c___0 == 27) {
#line 844
    state = 1;
#line 845
    return;
  }
#line 847
  if (state == 1) {
#line 848
    buf___1[pos] = (char)0;
#line 849
    pos = 0;
#line 850
    state = 0;
#line 851
    esc_s = 0;
#line 852
    if (c___0 != 92) {
#line 853
      return;
    }
    {
#line 855
    tmp = strcmp((char const   *)(buf___1), "cursor.on");
    }
#line 855
    if (! tmp) {
      {
#line 856
      mc_wcursor(vt_win, 1);
      }
    }
    {
#line 857
    tmp___0 = strcmp((char const   *)(buf___1), "cursor.off");
    }
#line 857
    if (! tmp___0) {
      {
#line 858
      mc_wcursor(vt_win, 0);
      }
    }
    {
#line 859
    tmp___1 = strcmp((char const   *)(buf___1), "linewrap.on");
    }
#line 859
    if (! tmp___1) {
#line 860
      vt_wrap = -1;
#line 861
      vt_win->wrap = (char)1;
    }
    {
#line 863
    tmp___2 = strcmp((char const   *)(buf___1), "linewrap.off");
    }
#line 863
    if (! tmp___2) {
#line 864
      vt_wrap = -1;
#line 865
      vt_win->wrap = (char)0;
    }
#line 867
    return;
  }
#line 869
  if (pos > 15) {
#line 870
    return;
  }
#line 871
  tmp___3 = pos;
#line 871
  pos ++;
#line 871
  buf___1[tmp___3] = (char )c___0;
#line 872
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void output_s(char const   *s___0 ) 
{ 


  {
  {
#line 876
  mc_wputs(vt_win, s___0);
  }
#line 877
  if (vt_docap == 1) {
    {
#line 878
    fputs((char const   */* __restrict  */)s___0, (FILE */* __restrict  */)capfp);
    }
  }
#line 879
  return;
}
}
#line 881 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void output_c(char const   c___0 ) 
{ 


  {
  {
#line 883
  mc_wputc(vt_win, (wchar_t )c___0);
  }
#line 884
  if (vt_docap == 1) {
    {
#line 885
    fputc((int )c___0, capfp);
    }
  }
#line 886
  return;
}
}
#line 890 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static unsigned char last_ch  ;
#line 903 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static time_t tmstmp_last  ;
#line 888 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_out(int ch ) 
{ 
  int f ;
  unsigned char c___0 ;
  int go_on ;
  wchar_t wc ;
  struct timeval tmstmp_now ;
  char s___0[36] ;
  struct tm tmstmp_tm ;
  struct tm *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 893
  go_on = 0;
#line 896
  if (! ch) {
#line 897
    return;
  }
#line 899
  if ((int )last_ch == 10) {
#line 899
    if (vt_line_timestamp != 0) {
      {
#line 907
      gettimeofday((struct timeval */* __restrict  */)(& tmstmp_now), (__timezone_ptr_t )((void *)0));
      }
#line 908
      if (vt_line_timestamp == 3) {
#line 908
        if (tmstmp_now.tv_sec != tmstmp_last) {
#line 908
          goto _L;
        } else {
#line 908
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 908
      if (vt_line_timestamp == 1) {
#line 908
        goto _L;
      } else
#line 908
      if (vt_line_timestamp == 2) {
        _L: /* CIL Label */ 
        {
#line 913
        tmp = localtime_r((time_t const   */* __restrict  */)(& tmstmp_now.tv_sec),
                          (struct tm */* __restrict  */)(& tmstmp_tm));
        }
#line 913
        if (tmp) {
          {
#line 913
          tmp___0 = strftime((char */* __restrict  */)(s___0), sizeof(s___0), (char const   */* __restrict  */)"[%F %T",
                             (struct tm  const  */* __restrict  */)(& tmstmp_tm));
          }
#line 913
          if (tmp___0) {
            {
#line 916
            output_s((char const   *)(s___0));
            }
            {
#line 919
            if (vt_line_timestamp == 1) {
#line 919
              goto case_1;
            }
#line 922
            if (vt_line_timestamp == 2) {
#line 922
              goto case_2;
            }
#line 926
            if (vt_line_timestamp == 3) {
#line 926
              goto case_3;
            }
#line 917
            goto switch_break;
            case_1: /* CIL Label */ 
            {
#line 920
            output_s("] ");
            }
#line 921
            goto switch_break;
            case_2: /* CIL Label */ 
            {
#line 923
            snprintf((char */* __restrict  */)(s___0), sizeof(s___0), (char const   */* __restrict  */)".%03ld] ",
                     tmstmp_now.tv_usec / 1000L);
#line 924
            output_s((char const   *)(s___0));
            }
#line 925
            goto switch_break;
            case_3: /* CIL Label */ 
            {
#line 927
            output_s("\r\n");
            }
#line 928
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
#line 931
        tmstmp_last = tmstmp_now.tv_sec;
      }
    }
  }
#line 935
  c___0 = (unsigned char )ch;
#line 936
  last_ch = c___0;
#line 938
  if (vt_docap == 2) {
    {
#line 939
    fputc((int )c___0, capfp);
    }
  }
  {
#line 943
  if ((int )c___0 == 5) {
#line 943
    goto case_5;
  }
#line 950
  if ((int )c___0 == 13) {
#line 950
    goto case_13;
  }
#line 955
  if ((int )c___0 == 9) {
#line 955
    goto case_9;
  }
#line 966
  if ((int )c___0 == 11) {
#line 966
    goto case_11;
  }
#line 969
  if ((int )c___0 == 12) {
#line 969
    goto case_12;
  }
#line 978
  if ((int )c___0 == 14) {
#line 978
    goto case_14;
  }
#line 981
  if ((int )c___0 == 15) {
#line 981
    goto case_15;
  }
#line 986
  if ((int )c___0 == 26) {
#line 986
    goto case_26;
  }
#line 986
  if ((int )c___0 == 24) {
#line 986
    goto case_26;
  }
#line 989
  if ((int )c___0 == 27) {
#line 989
    goto case_27;
  }
#line 992
  if ((int )c___0 == 155) {
#line 992
    goto case_155;
  }
#line 995
  if ((int )c___0 == 10) {
#line 995
    goto case_10;
  }
#line 1001
  if ((int )c___0 == 7) {
#line 1001
    goto case_7;
  }
#line 1001
  if ((int )c___0 == 8) {
#line 1001
    goto case_7;
  }
#line 1004
  goto switch_default;
  case_5: /* CIL Label */ 
#line 944
  if (vt_type != 1) {
#line 945
    go_on = 1;
#line 946
    goto switch_break___0;
  }
  {
#line 948
  v_termout((char const   *)(mpars[92].value), 0);
  }
#line 949
  goto switch_break___0;
  case_13: /* CIL Label */ 
  {
#line 951
  mc_wputc(vt_win, (wchar_t )c___0);
  }
#line 952
  if (vt_addlf) {
    {
#line 953
    output_c((char const   )'\n');
    }
  }
#line 954
  goto switch_break___0;
  case_9: /* CIL Label */ 
#line 957
  f = (int )vt_win->curx + 1;
  {
#line 957
  while (1) {
    while_continue: /* CIL Label */ ;
#line 957
    if (! (f < 160)) {
#line 957
      goto while_break;
    }
#line 958
    if (vt_tabs[f / 32] & (long )(1 << f % 32)) {
#line 959
      goto while_break;
    }
#line 957
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 960
  if (f >= vt_win->xs) {
#line 961
    f = vt_win->xs - 1;
  }
  {
#line 962
  mc_wlocate(vt_win, f, (int )vt_win->cury);
  }
#line 963
  if (vt_docap == 1) {
    {
#line 964
    fputc((int )c___0, capfp);
    }
  }
#line 965
  goto switch_break___0;
  case_11: /* CIL Label */ 
  {
#line 967
  mc_wlocate(vt_win, (int )vt_win->curx, (int )vt_win->cury - 1);
  }
#line 968
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 970
  mc_winclr(vt_win);
#line 971
  mc_wlocate(vt_win, 0, 0);
  }
#line 972
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 979
  vt_charset = 1;
#line 980
  goto switch_break___0;
  case_15: /* CIL Label */ 
#line 982
  vt_charset = 0;
#line 983
  goto switch_break___0;
  case_26: /* CIL Label */ 
  case_24: /* CIL Label */ 
#line 987
  esc_s = 0;
#line 988
  goto switch_break___0;
  case_27: /* CIL Label */ 
#line 990
  esc_s = 1;
#line 991
  goto switch_break___0;
  case_155: /* CIL Label */ 
#line 993
  esc_s = 2;
#line 994
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 996
  if (vt_addcr) {
    {
#line 997
    mc_wputc(vt_win, '\r');
    }
  }
  {
#line 998
  output_c((char const   )c___0);
  }
#line 999
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 1002
  output_c((char const   )c___0);
  }
#line 1003
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1005
  go_on = 1;
#line 1006
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1008
  if (! go_on) {
#line 1009
    return;
  }
  {
#line 1013
  if (esc_s == 0) {
#line 1013
    goto case_0;
  }
#line 1038
  if (esc_s == 1) {
#line 1038
    goto case_1___0;
  }
#line 1041
  if (esc_s == 2) {
#line 1041
    goto case_2___0;
  }
#line 1044
  if (esc_s == 3) {
#line 1044
    goto case_3___0;
  }
#line 1047
  if (esc_s == 4) {
#line 1047
    goto case_4;
  }
#line 1050
  if (esc_s == 5) {
#line 1050
    goto case_5___0;
  }
#line 1053
  if (esc_s == 6) {
#line 1053
    goto case_6;
  }
#line 1056
  if (esc_s == 7) {
#line 1056
    goto case_7___0;
  }
#line 1012
  goto switch_break___1;
  case_0: /* CIL Label */ 
#line 1014
  if (vt_docap == 1) {
#line 1015
    if ((int )mpars[80].value[0] == 89) {
#line 1015
      tmp___1 = (int )vt_inmap[c___0];
    } else {
#line 1015
      tmp___1 = (int )c___0;
    }
    {
#line 1015
    fputc(tmp___1, capfp);
    }
  }
  {
#line 1016
  tmp___2 = using_iconv();
  }
#line 1016
  if (! tmp___2) {
#line 1017
    c___0 = vt_inmap[c___0];
#line 1019
    if (vt_type == 1) {
#line 1019
      if (vt_trans[vt_charset]) {
#line 1019
        if (vt_asis == 0) {
#line 1020
          c___0 = (unsigned char )*(vt_trans[vt_charset] + c___0);
        }
      }
    }
  }
  {
#line 1028
  tmp___3 = using_iconv();
  }
#line 1028
  if (tmp___3) {
    {
#line 1035
    mc_wputc(vt_win, (wchar_t )c___0);
    }
  } else {
    {
#line 1029
    one_mbtowc(& wc, (char const   *)((char *)(& c___0)), (size_t )1);
    }
#line 1030
    if (vt_insert) {
      {
#line 1031
      mc_winschar2(vt_win, wc, 1);
      }
    } else {
      {
#line 1033
      mc_wputc(vt_win, wc);
      }
    }
  }
#line 1037
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 1039
  state1((int )c___0);
  }
#line 1040
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 1042
  state2((int )c___0);
  }
#line 1043
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 1045
  state3((int )c___0);
  }
#line 1046
  goto switch_break___1;
  case_4: /* CIL Label */ 
  {
#line 1048
  state4((int )c___0);
  }
#line 1049
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 1051
  state5((int )c___0);
  }
#line 1052
  goto switch_break___1;
  case_6: /* CIL Label */ 
  {
#line 1054
  state6((int )c___0);
  }
#line 1055
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
  {
#line 1057
  state7((int )c___0);
  }
#line 1058
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 1063
  if (capfp) {
    {
#line 1064
    fflush(capfp);
    }
  }
#line 1065
  return;
}
}
#line 1068 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
void vt_send(int c___0 ) 
{ 
  char s___0[3] ;
  int f ;
  int len ;

  {
#line 1072
  len = 1;
#line 1075
  if (c___0 < 256) {
#line 1077
    if (c___0 == 8) {
#line 1078
      c___0 = vt_bs;
    }
#line 1079
    s___0[0] = (char )vt_outmap[c___0];
#line 1080
    s___0[1] = (char)0;
#line 1082
    if (c___0 == 13) {
#line 1082
      if (vt_crlf) {
#line 1083
        s___0[1] = (char )'\n';
#line 1084
        s___0[2] = (char)0;
#line 1085
        len = 2;
      }
    }
    {
#line 1087
    v_termout((char const   *)(s___0), len);
    }
#line 1088
    if (vt_nl_delay > 0) {
#line 1088
      if (c___0 == 13) {
        {
#line 1089
        usleep((__useconds_t )(1000 * vt_nl_delay));
        }
      }
    }
#line 1090
    return;
  }
#line 1094
  f = 0;
  {
#line 1094
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1094
    if (! vt_keys[f].code) {
#line 1094
      goto while_break;
    }
#line 1095
    if (vt_keys[f].code == c___0) {
#line 1096
      goto while_break;
    }
#line 1094
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1097
  if (vt_keys[f].code == 0) {
#line 1098
    return;
  }
  {
#line 1101
  v_termout("\033", 0);
  }
#line 1102
  if (vt_type == 1) {
#line 1103
    if (vt_cursor == 1) {
      {
#line 1104
      v_termout(vt_keys[f].vt100_st, 0);
      }
    } else {
      {
#line 1106
      v_termout(vt_keys[f].vt100_app, 0);
      }
    }
  } else {
    {
#line 1108
    v_termout(vt_keys[f].ansi, 0);
    }
  }
#line 1109
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 143 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int wxgetch(void) ;
#line 76 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
short portfd ;
#line 89
int escape ;
#line 213
int check_io(int fd1 , int fd2 , int tmout , char *buf___6 , int bufsize___0 , int *bytes_read ) ;
#line 214
int keyboard(int cmd , int arg ) ;
#line 225
void term_socket_close(void) ;
#line 296
int io_pending ;
#line 32 "/home/wheatley/newnew/temp/minicom-2.7/src/ipc.c"
int check_io(int fd1 , int fd2 , int tmout , char *buf___6 , int bufsize___0 , int *bytes_read ) 
{ 
  int n ;
  int i ;
  struct timeval tv ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
#line 35
  n = 0;
#line 39
  tv.tv_sec = (__time_t )(tmout / 1000);
#line 40
  tv.tv_usec = (long )(tmout % 1000) * 1000L;
#line 42
  i = fd1;
#line 43
  if (fd2 > fd1) {
#line 44
    i = fd2;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
#line 46
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  if (fd1 >= 0) {
#line 48
    fds.fds_bits[fd1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd1 % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 50
    fd1 = 0;
  }
#line 51
  if (fd2 >= 0) {
#line 52
    fds.fds_bits[fd2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd2 % (8 * (int )sizeof(__fd_mask ));
  } else {
#line 54
    fd2 = 0;
  }
#line 56
  if (fd2 == 0) {
#line 56
    if (io_pending) {
#line 57
      n = 2;
    } else {
#line 56
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 58
    tmp = select(i + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 58
    if (tmp > 0) {
#line 59
      n = (((fds.fds_bits[fd1 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd1 % (8 * (int )sizeof(__fd_mask )))) != 0L) > 0) + 2 * (((fds.fds_bits[fd2 / (8 * (int )sizeof(__fd_mask ))] & (1L << fd2 % (8 * (int )sizeof(__fd_mask )))) != 0L) > 0);
    }
  }
#line 62
  if (buf___6) {
#line 63
    i = 0;
#line 64
    if ((n & 1) == 1) {
      {
#line 65
      tmp___0 = read(fd1, (void *)buf___6, (size_t )(bufsize___0 - 1));
#line 65
      i = (int )tmp___0;
      }
#line 67
      if (! i) {
#line 67
        if (portfd_is_socket) {
#line 67
          if ((int )portfd == fd1) {
            {
#line 68
            term_socket_close();
            }
          }
        }
      }
    }
#line 71
    if (i > 0) {
#line 71
      tmp___1 = i;
    } else {
#line 71
      tmp___1 = 0;
    }
#line 71
    *(buf___6 + tmp___1) = (char)0;
#line 72
    if (bytes_read) {
#line 73
      *bytes_read = i;
    }
  }
#line 76
  return (n);
}
}
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/ipc.c"
int keyboard(int cmd , int arg ) 
{ 
  int tmp ;

  {
  {
#line 83
  if (cmd == 1) {
#line 83
    goto case_1;
  }
#line 83
  if (cmd == 6) {
#line 83
    goto case_1;
  }
#line 85
  if (cmd == 10) {
#line 85
    goto case_10;
  }
#line 87
  if (cmd == 13) {
#line 87
    goto case_13;
  }
#line 89
  if (cmd == 11) {
#line 89
    goto case_11;
  }
#line 92
  if (cmd == 12) {
#line 92
    goto case_12;
  }
#line 95
  if (cmd == 8) {
#line 95
    goto case_8;
  }
#line 98
  if (cmd == 9) {
#line 98
    goto case_9;
  }
#line 101
  goto switch_default;
  case_1: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 84
  goto switch_break;
  case_10: /* CIL Label */ 
#line 86
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 88
  tmp = wxgetch();
  }
#line 88
  return (tmp);
  case_11: /* CIL Label */ 
#line 90
  escape = arg;
#line 91
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 93
  vt_set(-1, -1, -1, arg, -1, -1, -1, -1, -1);
  }
#line 94
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 96
  vt_set(-1, -1, -1, -1, -1, 1, -1, -1, -1);
  }
#line 97
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 99
  vt_set(-1, -1, -1, -1, -1, 2, -1, -1, -1);
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 103
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 105
  return (0);
}
}
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 30 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
static struct termios savetty  ;
#line 37 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
void getrowcols(int *rows , int *cols___0 ) 
{ 
  char *p ;
  struct winsize ws ;
  int tmp ;

  {
  {
#line 44
  tmp = ioctl(0, 21523UL, & ws);
  }
#line 44
  if (tmp >= 0) {
#line 45
    *rows = (int )ws.ws_row;
#line 46
    *cols___0 = (int )ws.ws_col;
  }
#line 62
  if (*rows == 0) {
    {
#line 62
    p = getenv("LINES");
    }
#line 62
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 63
      *rows = atoi((char const   *)p);
      }
    }
  }
#line 64
  if (*cols___0 == 0) {
    {
#line 64
    p = getenv("COLUMNS");
    }
#line 64
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 65
      *cols___0 = atoi((char const   *)p);
      }
    }
  }
#line 66
  return;
}
}
#line 81
int setcbreak(int mode ) ;
#line 81 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
static int init  =    0;
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
static int erasechar  ;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
int setcbreak(int mode ) 
{ 
  struct termios tty ;

  {
#line 92
  if (init == 0) {
    {
#line 93
    tcgetattr(0, & savetty);
#line 94
    erasechar = (int )savetty.c_cc[2];
#line 95
    init ++;
    }
  }
#line 98
  if (mode == 3) {
#line 99
    return (erasechar);
  }
  {
#line 102
  tcsetattr(0, 1, (struct termios  const  *)(& savetty));
  }
#line 104
  if (mode == 0) {
#line 105
    return (erasechar);
  }
  {
#line 108
  tcgetattr(0, & tty);
  }
#line 109
  if (mode == 1) {
#line 110
    tty.c_oflag &= 4294967294U;
#line 111
    tty.c_lflag &= 4294967099U;
#line 112
    tty.c_lflag &= 4294967284U;
#line 113
    tty.c_iflag &= 4294966975U;
#line 114
    tty.c_cflag |= 128U;
#line 115
    tty.c_cc[5] = (cc_t )5;
#line 116
    tty.c_cc[6] = (cc_t )1;
  }
#line 118
  if (mode == 2) {
#line 119
    tty.c_iflag &= 4294959118U;
#line 121
    tty.c_iflag |= 6U;
#line 122
    tty.c_oflag &= 4294967294U;
#line 123
    tty.c_lflag &= 4294967099U;
#line 124
    tty.c_lflag &= 4294967284U;
#line 125
    tty.c_cflag |= 128U;
#line 126
    tty.c_cc[5] = (cc_t )5;
#line 127
    tty.c_cc[6] = (cc_t )1;
  }
  {
#line 129
  tcsetattr(0, 1, (struct termios  const  *)(& tty));
  }
#line 130
  return (erasechar);
}
}
#line 177 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep2.c"
void enab_sig(int onoff , int intchar ) 
{ 
  struct termios tty ;

  {
  {
#line 182
  tcgetattr(0, & tty);
  }
#line 183
  if (onoff) {
#line 184
    tty.c_lflag |= 1U;
  } else {
#line 186
    tty.c_lflag &= 4294967294U;
  }
#line 188
  if (onoff) {
#line 188
    if (intchar) {
#line 189
      tty.c_cc[0] = (cc_t )intchar;
#line 190
      tty.c_cc[1] = (cc_t )-1;
#line 192
      tty.c_cc[10] = (cc_t )-1;
    }
  }
  {
#line 196
  tcsetattr(0, 1, (struct termios  const  *)(& tty));
  }
#line 218
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
WIN *stdwin ;
#line 65
int COLS ;
#line 67
int useattr ;
#line 68
int dirflush ;
#line 77
int mfcolor ;
#line 78
int mbcolor ;
#line 146
WIN *mc_wopen(int x1 , int y1 , int x2 , int y2 , int border , int attr , int fg ,
              int bg , int direct , int histlines , int doclr ) ;
#line 148
void mc_wclose(WIN *win , int replace ) ;
#line 158
int ( /* format attribute */  mc_wprintf)(WIN *win , char const   *fmt___0  , ...) ;
#line 179
int mc_wgets(WIN *w , char *s___0 , int linelen , int maxlen ) ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char stdattr ;
#line 287
WIN *mc_tell(char const   *s___0  , ...) ;
#line 288
void werror(char const   *s___0  , ...) ;
#line 289
int ask(char const   *what___1 , char const   **s___0 ) ;
#line 290
char *input(char *s___0 , char *buf___6 ) ;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/windiv.c"
static WIN *vmc_tell(char const   *fmt___0 , va_list va ) 
{ 
  WIN *w ;
  char buf___6[128] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 45
  if ((unsigned long )stdwin == (unsigned long )((void *)0)) {
#line 46
    return ((WIN *)((void *)0));
  }
  {
#line 48
  vsnprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)fmt___0,
            va);
#line 50
  tmp = mbslen((char const   *)(buf___6));
#line 50
  tmp___0 = mbslen((char const   *)(buf___6));
#line 50
  w = mc_wopen((int )((size_t )(COLS / 2 - 2) - tmp___0 / 2UL), 8, (int )((size_t )(COLS / 2 + 2) + tmp / 2UL),
               10, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 53
  mc_wcursor(w, 0);
#line 54
  mc_wlocate(w, 2, 1);
#line 55
  mc_wputs(w, (char const   *)(buf___6));
#line 56
  mc_wredraw(w, 1);
  }
#line 57
  return (w);
}
}
#line 60 "/home/wheatley/newnew/temp/minicom-2.7/src/windiv.c"
WIN *mc_tell(char const   *s___0  , ...) 
{ 
  WIN *w ;
  va_list ap ;

  {
  {
#line 65
  __builtin_va_start(ap, s___0);
#line 66
  w = vmc_tell(s___0, ap);
#line 67
  __builtin_va_end(ap);
  }
#line 68
  return (w);
}
}
#line 74 "/home/wheatley/newnew/temp/minicom-2.7/src/windiv.c"
void werror(char const   *s___0  , ...) 
{ 
  WIN *tellwin ;
  va_list ap ;

  {
  {
#line 79
  __builtin_va_start(ap, s___0);
#line 80
  tellwin = vmc_tell(s___0, ap);
#line 81
  __builtin_va_end(ap);
#line 82
  sleep(2U);
#line 83
  mc_wclose(tellwin, 1);
  }
#line 84
  return;
}
}
#line 89 "/home/wheatley/newnew/temp/minicom-2.7/src/windiv.c"
int ask(char const   *what___1 , char const   **s___0 ) 
{ 
  int num ;
  int cur___1 ;
  int ocur___1 ;
  int f ;
  int c___0 ;
  WIN *w ;
  unsigned int size ;
  unsigned int offs ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 91
  num = 0;
#line 92
  cur___1 = 0;
#line 92
  ocur___1 = 0;
#line 97
  f = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *(s___0 + f)) {
#line 97
      goto while_break;
    }
#line 98
    num ++;
#line 97
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  size = (unsigned int )(5 * num);
#line 101
  offs = 0U;
#line 102
  tmp___0 = mbslen(what___1);
  }
#line 102
  if (tmp___0 > (size_t )(2U * size + 4U)) {
    {
#line 103
    tmp = mbslen(what___1);
#line 103
    size = (unsigned int )(tmp / 2UL + 2UL);
#line 104
    offs = size - (unsigned int )(5 * num);
    }
  }
  {
#line 106
  w = mc_wopen((int )((unsigned int )(COLS / 2) - size), 8, (int )((unsigned int )(COLS / 2 + 1) + size),
               9, 1, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 109
  dirflush = 0;
#line 111
  mc_wcursor(w, 0);
#line 112
  tmp___1 = mbslen(what___1);
#line 112
  mc_wlocate(w, (int )((size_t )(1U + size) - tmp___1 / 2UL), 0);
#line 113
  mc_wputs(w, what___1);
#line 115
  f = 1;
  }
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! (f < num)) {
#line 115
      goto while_break___0;
    }
    {
#line 116
    mc_wlocate(w, (int )((2U + offs) + (unsigned int )(10 * f)), 1);
#line 117
    tmp___2 = gettext(*(s___0 + f));
#line 117
    mc_wputs(w, (char const   *)tmp___2);
#line 115
    f ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 119
  mc_wredraw(w, 1);
  }
  {
#line 121
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 122
    mc_wlocate(w, (int )((2U + offs) + (unsigned int )(10 * cur___1)), 1);
    }
#line 123
    if (! useattr) {
      {
#line 124
      tmp___3 = gettext(*(s___0 + cur___1));
#line 124
      mc_wprintf(w, ">%s", tmp___3 + 1);
      }
    } else {
      {
#line 126
      w->attr = (char )(4 | (int )stdattr);
#line 127
      tmp___4 = gettext(*(s___0 + cur___1));
#line 127
      mc_wputs(w, (char const   *)tmp___4);
      }
    }
    {
#line 129
    ocur___1 = cur___1;
#line 130
    mc_wflush();
#line 131
    c___0 = wxgetch();
    }
    {
#line 134
    if (c___0 == 3) {
#line 134
      goto case_3;
    }
#line 134
    if (c___0 == 27) {
#line 134
      goto case_3;
    }
#line 134
    if (c___0 == 32) {
#line 134
      goto case_3;
    }
#line 139
    if (c___0 == 10) {
#line 139
      goto case_10;
    }
#line 139
    if (c___0 == 13) {
#line 139
      goto case_10;
    }
#line 144
    if (c___0 == 104) {
#line 144
      goto case_104;
    }
#line 144
    if (c___0 == 270) {
#line 144
      goto case_104;
    }
#line 149
    goto switch_default;
    case_3: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 135
    dirflush = 1;
#line 136
    mc_wclose(w, 1);
    }
#line 137
    return (-1);
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    {
#line 140
    dirflush = 1;
#line 141
    mc_wclose(w, 1);
    }
#line 142
    return (cur___1);
    case_104: /* CIL Label */ 
    case_270: /* CIL Label */ 
#line 145
    cur___1 --;
#line 146
    if (cur___1 < 0) {
#line 147
      cur___1 = num - 1;
    }
#line 148
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 150
    cur___1 = (cur___1 + 1) % num;
#line 151
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 153
    mc_wlocate(w, (int )((2U + offs) + (unsigned int )(10 * ocur___1)), 1);
#line 154
    w->attr = stdattr;
    }
#line 155
    if (! useattr) {
      {
#line 156
      mc_wputs(w, " ");
      }
    } else {
      {
#line 158
      tmp___5 = gettext(*(s___0 + ocur___1));
#line 158
      mc_wputs(w, (char const   *)tmp___5);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/windiv.c"
char *input(char *s___0 , char *buf___6 ) 
{ 
  WIN *w ;
  int tmp ;

  {
  {
#line 169
  w = mc_wopen(COLS / 2 - 20, 11, COLS / 2 + 20, 12, 2, (int )stdattr, mfcolor, mbcolor,
               1, 0, 1);
#line 171
  mc_wputs(w, (char const   *)s___0);
#line 172
  mc_wlocate(w, 0, 1);
#line 173
  mc_wprintf(w, "> %-38.38s", buf___6);
#line 174
  mc_wlocate(w, 2, 1);
#line 175
  tmp = mc_wgets(w, buf___6, 38, 128);
  }
#line 175
  if (tmp < 0) {
#line 176
    buf___6 = (char *)((void *)0);
  }
  {
#line 177
  mc_wclose(w, 1);
  }
#line 178
  return (buf___6);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int LINES ;
#line 160
void mc_wbell(void) ;
#line 162
void mc_wtitle(WIN *w , int pos___1 , char const   *s___0 ) ;
#line 201 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *filedir(int howmany , int downloading ) ;
#line 202
void init_dir(char dir ) ;
#line 293
int wildmat(char const   *s___0 , char const   *p ) ;
#line 45 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.h"
int getsdir(char const   *dirpath , char const   *pattern , int sortflags , mode_t modemask ,
            GETSDIR_ENTRY **datptr , int *len ) ;
#line 41 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int nrents  =    1;
#line 43
static void file_tell(char const   *s___0 ) ;
#line 44
static void dhili(int k ) ;
#line 45
static void prdir(WIN *dirw , int top___1 , int cur___1 , GETSDIR_ENTRY *dirdat ,
                  int longest___0 ) ;
#line 46
static void prone(WIN *dirw , GETSDIR_ENTRY *dirdat , int longest___0 , int inverse ) ;
#line 47
static void *set_work_dir(void *existing , size_t min_len___0 ) ;
#line 48
static int new_filedir(GETSDIR_ENTRY *dirdat , int flushit ) ;
#line 49
static void goto_filedir(char *new_dir , int absolut ) ;
#line 50
static int tag_untag(char *pat , int tag ) ;
#line 51
static char *concat_list(GETSDIR_ENTRY *dirdat ) ;
#line 53 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static WIN *dsub  ;
#line 54 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char const   * const  what[6]  = {      (char const   */* const  */)"[Goto]",      (char const   */* const  */)"[Prev]",      (char const   */* const  */)"[Show]",      (char const   */* const  */)"[Tag]", 
        (char const   */* const  */)"[Untag]",      (char const   */* const  */)"[Okay]"};
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int what_lens[sizeof(what) / sizeof(what[0])]  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int what_padding[sizeof(what) / sizeof(what[0])][2]  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int dprev  ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char const   *d_yesno[3]  = {      "   Yes  ",      "   No   ",      (char const   *)((void *)0)};
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void file_tell(char const   *s___0 ) 
{ 
  WIN *w ;

  {
  {
#line 81
  w = mc_tell("%s", s___0);
#line 82
  sleep(1U);
#line 83
  mc_wclose(w, 1);
  }
#line 84
  return;
}
}
#line 89
static void horiz_draw(size_t k , char start_attr , char end_attr ) ;
#line 89 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char const   spaces[9]  = 
#line 89
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\000'};
#line 87 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void horiz_draw(size_t k , char start_attr , char end_attr ) 
{ 
  char *tmp ;

  {
  {
#line 91
  mc_wprintf(dsub, "%.*s", what_padding[k][0], spaces);
#line 92
  dsub->attr = start_attr;
#line 93
  tmp = gettext((char const   *)what[k]);
#line 93
  mc_wprintf(dsub, "%.*s", what_lens[k], tmp);
#line 94
  dsub->attr = end_attr;
#line 95
  mc_wprintf(dsub, "%.*s", what_padding[k][1], spaces);
  }
#line 96
  return;
}
}
#line 101 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void dhili(int k ) 
{ 
  int initial_y ;
  unsigned long tmp ;

  {
#line 103
  if ((sizeof(what) / sizeof(what[0])) * 8UL >= 76UL) {
#line 103
    tmp = 74UL;
  } else {
#line 103
    tmp = (sizeof(what) / sizeof(what[0])) * 8UL;
  }
#line 103
  initial_y = (int )((76UL - tmp) / 2UL);
#line 106
  if (k == dprev) {
#line 107
    return;
  }
#line 109
  if (dprev >= 0) {
    {
#line 110
    mc_wlocate(dsub, initial_y + 8 * dprev, 0);
    }
#line 111
    if (! useattr) {
      {
#line 112
      mc_wputs(dsub, " ");
      }
    } else {
      {
#line 114
      horiz_draw((size_t )dprev, stdattr, stdattr);
      }
    }
  }
  {
#line 116
  dprev = k;
#line 118
  mc_wlocate(dsub, initial_y + 8 * k, 0);
  }
#line 119
  if (! useattr) {
    {
#line 120
    mc_wputs(dsub, ">");
    }
  } else {
    {
#line 122
    horiz_draw((size_t )k, (char )(4 | (int )stdattr), stdattr);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
__inline static GETSDIR_ENTRY *getno(int no , GETSDIR_ENTRY *d ) 
{ 


  {
#line 127
  if (no >= nrents) {
#line 128
    return ((GETSDIR_ENTRY *)((void *)0));
  }
#line 129
  return (d + no);
}
}
#line 135 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void prdir(WIN *dirw , int top___1 , int cur___1 , GETSDIR_ENTRY *dirdat ,
                  int longest___0 ) 
{ 
  int f ;
  int start___1 ;
  char f_str[8192] ;
  char t_str[8192] ;
  GETSDIR_ENTRY *d ;

  {
  {
#line 142
  start___1 = cur___1 - top___1;
#line 143
  dirflush = 0;
#line 144
  sprintf((char */* __restrict  */)(f_str), (char const   */* __restrict  */)" %%-%ds",
          longest___0 + 2);
#line 145
  mc_wlocate(dirw, 0, start___1 + 1);
#line 146
  f = start___1;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (f < dirw->ys - 2)) {
#line 146
      goto while_break;
    }
    {
#line 148
    d = getno(f + top___1, dirdat);
    }
#line 148
    if (! d) {
#line 149
      goto while_break;
    }
#line 150
    if ((int )d->cflags & 128) {
#line 151
      dirw->attr = (char )(4 | (int )stdattr);
    }
#line 152
    if ((d->mode & 61440U) == 16384U) {
      {
#line 153
      snprintf((char */* __restrict  */)(t_str), sizeof(t_str), (char const   */* __restrict  */)"[%s]",
               d->fname);
#line 154
      mc_wprintf(dirw, (char const   *)(f_str), t_str);
      }
    } else {
      {
#line 156
      mc_wprintf(dirw, (char const   *)(f_str), d->fname);
      }
    }
    {
#line 157
    dirw->attr = (char )((int )stdattr);
#line 158
    mc_wputc(dirw, '\n');
#line 146
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 160
  dirflush = 1;
#line 161
  mc_wflush();
  }
#line 162
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void prone(WIN *dirw , GETSDIR_ENTRY *dirdat , int longest___0 , int inverse ) 
{ 
  char f_str[8192] ;
  char t_str[8192] ;

  {
  {
#line 172
  dirflush = 0;
#line 173
  sprintf((char */* __restrict  */)(f_str), (char const   */* __restrict  */)" %%-%ds",
          longest___0 + 2);
  }
#line 178
  if (inverse) {
#line 179
    dirw->attr = (char )(4 | (int )stdattr);
  }
#line 180
  if ((dirdat->mode & 61440U) == 16384U) {
    {
#line 181
    snprintf((char */* __restrict  */)(t_str), sizeof(t_str), (char const   */* __restrict  */)"[%s]",
             dirdat->fname);
#line 182
    mc_wprintf(dirw, (char const   *)(f_str), t_str);
    }
  } else {
    {
#line 184
    mc_wprintf(dirw, (char const   *)(f_str), dirdat->fname);
    }
  }
  {
#line 185
  dirw->attr = (char )((int )stdattr);
#line 186
  dirflush = 1;
#line 187
  mc_wflush();
  }
#line 188
  return;
}
}
#line 190 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static WIN *main_w  ;
#line 191 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static GETSDIR_ENTRY *global_dirdat  ;
#line 192 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int cur  =    0;
#line 193 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int ocur  =    0;
#line 194 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int subm  =    5;
#line 195 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int quit  =    0;
#line 196 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int top  =    0;
#line 197 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int c  =    0;
#line 198 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int pgud  =    0;
#line 199 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int first  =    1;
#line 200 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *s  ;
#line 201 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int longest  ;
#line 202 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char file_title[8192]  ;
#line 203 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char cwd_str[8192]  ;
#line 204 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *prev_dir  =    (char *)((void *)0);
#line 205 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *work_dir  =    (char *)((void *)0);
#line 206 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *d_work_dir  =    (char *)((void *)0);
#line 207 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *u_work_dir  =    (char *)((void *)0);
#line 208 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int min_len  =    1;
#line 209 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char wc_str[128]  = {      (char )'\000'};
#line 210 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char wc_mem[128]  = {      (char )'\000'};
#line 211 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int tag_cnt  =    0;
#line 212 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int how_many  =    0;
#line 213 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int down_loading  =    0;
#line 214 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *ret_buf  =    (char *)((void *)0);
#line 220 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
void init_dir(char dir ) 
{ 
  char *p ;

  {
#line 222
  p = (char *)((void *)0);
  {
#line 225
  if ((int )dir == 117) {
#line 225
    goto case_117;
  }
#line 229
  if ((int )dir == 100) {
#line 229
    goto case_100;
  }
#line 224
  goto switch_break;
  case_117: /* CIL Label */ 
#line 226
  p = u_work_dir;
#line 227
  u_work_dir = (char *)((void *)0);
#line 228
  goto switch_break;
  case_100: /* CIL Label */ 
#line 230
  p = d_work_dir;
#line 231
  d_work_dir = (char *)((void *)0);
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  free((void *)p);
  }
#line 235
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void *set_work_dir(void *existing , size_t min_len___0 ) 
{ 
  void *vp ;
  void *tmp ;

  {
  {
#line 240
  tmp = realloc(existing, min_len___0);
#line 240
  vp = tmp;
  }
#line 242
  if (down_loading) {
#line 243
    d_work_dir = (char *)vp;
  } else {
#line 245
    u_work_dir = (char *)vp;
  }
#line 247
  return (vp);
}
}
#line 258 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static size_t dp_len  =    (size_t )0;
#line 259 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char cwd_str_fmt[8192]  = {      (char )'\000'};
#line 256 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int new_filedir(GETSDIR_ENTRY *dirdat , int flushit ) 
{ 
  size_t new_dp_len ;
  size_t fmt_len ;
  char disp_dir[80] ;
  int initial_y ;
  unsigned long tmp ;
  size_t i ;
  char *new_prev_dir ;
  char *s___0 ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *s___1 ;
  char *tmp___14 ;
  size_t i___0 ;
  char *tmp_dir ;
  wchar_t wc ;
  size_t tmp___15 ;
  char const   *str ;
  char const   *c___0 ;
  size_t j ;
  char *tmp___16 ;
  wchar_t wc___0 ;
  size_t tmp___17 ;
  char *tmp___18 ;

  {
#line 262
  if ((sizeof(what) / sizeof(what[0])) * 8UL >= 76UL) {
#line 262
    tmp = 74UL;
  } else {
#line 262
    tmp = (sizeof(what) / sizeof(what[0])) * 8UL;
  }
#line 262
  initial_y = (int )((76UL - tmp) / 2UL);
#line 267
  cur = 0;
#line 268
  ocur = 0;
#line 269
  subm = 5;
#line 270
  quit = 0;
#line 271
  top = 0;
#line 272
  c = 0;
#line 273
  pgud = 0;
#line 274
  first = 1;
#line 275
  min_len = 1;
#line 276
  dprev = -1;
#line 277
  tag_cnt = 0;
#line 282
  if (down_loading) {
#line 282
    work_dir = d_work_dir;
  } else {
#line 282
    work_dir = u_work_dir;
  }
#line 287
  if ((unsigned long )work_dir == (unsigned long )((void *)0)) {
#line 288
    if (down_loading) {
#line 288
      tmp___0 = mpars[59].value;
    } else {
#line 288
      tmp___0 = mpars[58].value;
    }
#line 288
    s___0 = tmp___0;
#line 289
    min_len = 1;
#line 291
    if ((int )*s___0 != 47) {
      {
#line 292
      tmp___1 = strlen((char const   *)(homedir));
#line 292
      min_len = (int )((size_t )min_len + (tmp___1 + 1UL));
      }
    }
    {
#line 293
    tmp___2 = strlen((char const   *)s___0);
#line 293
    min_len = (int )((size_t )min_len + tmp___2);
    }
#line 294
    if (min_len < 8192) {
#line 295
      min_len = 8192;
    }
    {
#line 297
    tmp___3 = set_work_dir((void *)0, (size_t )min_len);
#line 297
    work_dir = (char *)tmp___3;
    }
#line 299
    if ((int )*s___0 == 47) {
      {
#line 300
      strncpy((char */* __restrict  */)work_dir, (char const   */* __restrict  */)s___0,
              (size_t )min_len);
      }
    } else {
      {
#line 302
      snprintf((char */* __restrict  */)work_dir, (size_t )min_len, (char const   */* __restrict  */)"%s/%s",
               homedir, s___0);
      }
    }
  }
  {
#line 305
  tmp___5 = strlen((char const   *)work_dir);
  }
#line 305
  if (tmp___5 > 1UL) {
    {
#line 305
    tmp___6 = strlen((char const   *)work_dir);
    }
#line 305
    if ((int )*(work_dir + (tmp___6 - 1UL)) == 47) {
      {
#line 306
      tmp___4 = strlen((char const   *)work_dir);
#line 306
      *(work_dir + (tmp___4 - 1UL)) = (char)0;
      }
    }
  }
  {
#line 309
  new_prev_dir = getcwd((char *)((void *)0), (size_t )8192);
  }
#line 310
  if (! new_prev_dir) {
#line 311
    return (-1);
  }
  {
#line 313
  tmp___12 = access((char const   *)work_dir, 5);
  }
#line 313
  if (tmp___12) {
    _L: /* CIL Label */ 
    {
#line 320
    mc_wbell();
#line 321
    tmp___7 = __errno_location();
#line 321
    tmp___8 = strerror(*tmp___7);
#line 321
    tmp___9 = gettext("Could not change to directory %s (%s)");
#line 321
    werror((char const   *)tmp___9, work_dir, tmp___8);
#line 327
    free((void *)work_dir);
#line 328
    tmp___10 = strlen((char const   *)new_prev_dir);
#line 328
    tmp___11 = set_work_dir((void *)new_prev_dir, tmp___10);
#line 328
    work_dir = (char *)tmp___11;
    }
  } else {
    {
#line 313
    tmp___13 = chdir((char const   *)work_dir);
    }
#line 313
    if (tmp___13) {
#line 313
      goto _L;
    } else {
      {
#line 315
      free((void *)prev_dir);
#line 316
      prev_dir = new_prev_dir;
      }
    }
  }
#line 333
  if (flushit) {
    {
#line 334
    dirflush = 0;
#line 335
    mc_winclr(main_w);
#line 336
    mc_wredraw(main_w, 1);
    }
  }
  {
#line 339
  mc_wcursor(main_w, 1);
  }
#line 344
  if (down_loading) {
#line 345
    if (how_many < 0) {
      {
#line 346
      s___1 = gettext("Select one or more files for download");
      }
    } else
#line 347
    if (how_many) {
      {
#line 348
      s___1 = gettext("Select a file for download");
      }
    } else {
      {
#line 350
      s___1 = gettext("Select a directory for download");
      }
    }
  } else
#line 352
  if (how_many < 0) {
    {
#line 353
    s___1 = gettext("Select one or more files for upload");
    }
  } else
#line 354
  if (how_many) {
    {
#line 355
    s___1 = gettext("Select a file for upload");
    }
  } else {
    {
#line 357
    s___1 = gettext("Select a directory for upload");
    }
  }
  {
#line 359
  snprintf((char */* __restrict  */)(file_title), sizeof(file_title), (char const   */* __restrict  */)"%s",
           s___1);
#line 362
  mc_wtitle(main_w, 1, (char const   *)(file_title));
#line 363
  new_dp_len = strlen((char const   *)work_dir);
  }
#line 363
  if (new_dp_len > dp_len) {
    {
#line 364
    dp_len = new_dp_len;
#line 365
    tmp___14 = gettext("Directory: %%-%ds");
#line 365
    snprintf((char */* __restrict  */)(cwd_str_fmt), sizeof(cwd_str_fmt), (char const   */* __restrict  */)tmp___14,
             (int )dp_len);
    }
  }
  {
#line 368
  new_dp_len = mbslen((char const   *)work_dir);
#line 369
  fmt_len = mbslen((char const   *)(cwd_str_fmt));
  }
#line 369
  if (new_dp_len + fmt_len > 75UL) {
#line 371
    tmp_dir = work_dir;
#line 374
    i___0 = (size_t )0;
    {
#line 374
    while (1) {
      while_continue: /* CIL Label */ ;
#line 374
      if (! (73UL + i___0 < new_dp_len + fmt_len)) {
#line 374
        goto while_break;
      }
      {
#line 377
      tmp___15 = one_mbtowc(& wc, (char const   *)work_dir, (size_t )16);
#line 377
      tmp_dir += tmp___15;
#line 374
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 379
    snprintf((char */* __restrict  */)(disp_dir), sizeof(disp_dir), (char const   */* __restrict  */)"...%s",
             tmp_dir);
#line 380
    snprintf((char */* __restrict  */)(cwd_str), sizeof(cwd_str), (char const   */* __restrict  */)(cwd_str_fmt),
             disp_dir);
    }
  } else {
    {
#line 382
    snprintf((char */* __restrict  */)(cwd_str), sizeof(cwd_str), (char const   */* __restrict  */)(cwd_str_fmt),
             work_dir);
    }
  }
  {
#line 384
  mc_wlocate(main_w, 0, 0);
#line 385
  mc_wputs(main_w, (char const   *)(cwd_str));
#line 387
  i = (size_t )0;
  }
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    if (! (i < sizeof(what) / sizeof(what[0]))) {
#line 387
      goto while_break___0;
    }
    {
#line 391
    tmp___16 = gettext((char const   *)what[i]);
#line 391
    str = (char const   *)tmp___16;
#line 392
    c___0 = str;
#line 393
    j = (size_t )0;
    }
    {
#line 393
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 393
      if (j < 7UL) {
#line 393
        if (! ((int const   )*c___0 != 0)) {
#line 393
          goto while_break___1;
        }
      } else {
#line 393
        goto while_break___1;
      }
      {
#line 395
      tmp___17 = one_mbtowc(& wc___0, c___0, (size_t )16);
#line 395
      c___0 += tmp___17;
#line 393
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 397
    what_lens[i] = (int )(c___0 - str);
#line 398
    j = 8UL - j;
#line 399
    what_padding[i][1] = (int )(j / 2UL);
#line 400
    what_padding[i][0] = (int )(j - (size_t )what_padding[i][1]);
#line 387
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 402
  mc_wlocate(dsub, initial_y, 0);
#line 403
  i = (size_t )0;
  }
  {
#line 403
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 403
    if (! (i < sizeof(what) / sizeof(what[0]))) {
#line 403
      goto while_break___2;
    }
    {
#line 404
    horiz_draw(i, dsub->attr, dsub->attr);
#line 403
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 406
  main_w->sy1 = main_w->y1 + 1;
#line 406
  main_w->sy2 = main_w->y1 + (main_w->ys - 1);
#line 407
  main_w->doscroll = (char)0;
#line 410
  free((void *)dirdat);
#line 411
  dirdat = (GETSDIR_ENTRY *)((void *)0);
#line 414
  nrents = getsdir(".", (char const   *)(wc_str), 11, (mode_t )0, & dirdat, & longest);
  }
#line 414
  if (nrents < 0) {
    {
#line 418
    mc_wclose(main_w, 1);
#line 419
    mc_wclose(dsub, 1);
#line 420
    free((void *)dirdat);
#line 421
    dirdat = (GETSDIR_ENTRY *)((void *)0);
    }
#line 422
    return (-1);
  }
  {
#line 425
  global_dirdat = dirdat;
#line 427
  prdir(main_w, top, top, dirdat, longest);
#line 428
  mc_wlocate(main_w, initial_y, main_w->ys - 1);
#line 429
  tmp___18 = gettext("( Escape to exit, Space to tag )");
#line 429
  mc_wputs(main_w, (char const   *)tmp___18);
#line 430
  dhili(subm);
#line 432
  mc_wlocate(main_w, 0, (cur + 1) - top);
  }
#line 433
  if (flushit) {
    {
#line 434
    dirflush = 1;
#line 435
    mc_wredraw(dsub, 1);
    }
  }
#line 438
  return (0);
}
}
#line 445 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static void goto_filedir(char *new_dir , int absolut ) 
{ 
  char *sp___0 ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int new_len ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int new_len___0 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 447
  tmp___10 = strcmp((char const   *)new_dir, "..");
  }
#line 447
  if (tmp___10 == 0) {
    {
#line 448
    tmp___2 = strcmp((char const   *)work_dir, "/");
    }
#line 448
    if (tmp___2) {
      {
#line 449
      tmp = strrchr((char const   *)work_dir, '/');
#line 449
      sp___0 = tmp;
#line 450
      *sp___0 = (char)0;
#line 451
      tmp___0 = strlen((char const   *)work_dir);
      }
#line 451
      if (tmp___0 == 0UL) {
        {
#line 452
        strcpy((char */* __restrict  */)work_dir, (char const   */* __restrict  */)"/");
        }
      }
    } else {
      {
#line 454
      tmp___1 = gettext("Can\'t back up!");
#line 454
      file_tell((char const   *)tmp___1);
      }
#line 455
      return;
    }
  } else
#line 457
  if (! absolut) {
    {
#line 458
    tmp___3 = strlen((char const   *)work_dir);
#line 458
    new_len = (int )(tmp___3 + 1UL);
#line 459
    tmp___5 = strlen((char const   *)new_dir);
#line 459
    new_len = (int )((size_t )new_len + (tmp___5 + 1UL));
    }
#line 459
    if (new_len > min_len) {
      {
#line 460
      min_len = new_len;
#line 461
      tmp___4 = set_work_dir((void *)work_dir, (size_t )min_len);
#line 461
      work_dir = (char *)tmp___4;
      }
    }
    {
#line 463
    tmp___6 = strcmp((char const   *)work_dir, "/");
    }
#line 463
    if (tmp___6 != 0) {
      {
#line 464
      strcat((char */* __restrict  */)work_dir, (char const   */* __restrict  */)"/");
      }
    }
    {
#line 465
    strcat((char */* __restrict  */)work_dir, (char const   */* __restrict  */)new_dir);
    }
  } else {
#line 467
    new_len___0 = 1;
#line 468
    if ((int )*new_dir != 47) {
      {
#line 469
      tmp___7 = strlen((char const   *)(homedir));
#line 469
      new_len___0 = (int )((size_t )new_len___0 + (tmp___7 + 1UL));
      }
    }
    {
#line 470
    tmp___8 = strlen((char const   *)new_dir);
#line 470
    new_len___0 = (int )((size_t )new_len___0 + tmp___8);
    }
#line 471
    if (min_len < new_len___0) {
#line 472
      min_len = new_len___0;
    }
    {
#line 474
    tmp___9 = set_work_dir((void *)work_dir, (size_t )min_len);
#line 474
    work_dir = (char *)tmp___9;
    }
#line 476
    if ((int )*new_dir == 47) {
      {
#line 477
      strncpy((char */* __restrict  */)work_dir, (char const   */* __restrict  */)new_dir,
              (size_t )min_len);
      }
    } else {
      {
#line 479
      snprintf((char */* __restrict  */)work_dir, (size_t )min_len, (char const   */* __restrict  */)"%s/%s",
               homedir, new_dir);
      }
    }
  }
  {
#line 481
  new_filedir(global_dirdat, 1);
  }
#line 482
  return;
}
}
#line 488 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int init_filedir(void) 
{ 
  int x1 ;
  int x2 ;
  int retstat ;
  void *tmp___0 ;

  {
  {
#line 491
  retstat = -1;
#line 493
  dirflush = 0;
#line 494
  x1 = COLS / 2 - 37;
#line 495
  x2 = COLS / 2 + 37;
#line 496
  dsub = mc_wopen(x1 - 1, LINES - 3, x2 + 1, LINES - 3, 0, (int )stdattr, mfcolor,
                  mbcolor, 0, 0, 1);
#line 498
  main_w = mc_wopen(x1, 2, x2, LINES - 6, 1, (int )stdattr, mfcolor, mbcolor, 0, 0,
                    1);
  }
#line 501
  if ((unsigned long )ret_buf != (unsigned long )((void *)0)) {
    {
#line 503
    retstat = new_filedir((GETSDIR_ENTRY *)((void *)0), 0);
#line 504
    dirflush = 1;
#line 505
    mc_wredraw(dsub, 1);
    }
  } else {
    {
#line 501
    tmp___0 = malloc((size_t )8192);
#line 501
    ret_buf = (char *)tmp___0;
    }
#line 501
    if ((unsigned long )ret_buf == (unsigned long )((void *)0)) {
#line 501
      retstat = -1;
    } else {
#line 501
      retstat = 0;
    }
#line 501
    if (retstat == 0) {
      {
#line 503
      retstat = new_filedir((GETSDIR_ENTRY *)((void *)0), 0);
#line 504
      dirflush = 1;
#line 505
      mc_wredraw(dsub, 1);
      }
    }
  }
#line 507
  return (retstat);
}
}
#line 511 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static int tag_untag(char *pat , int tag ) 
{ 
  GETSDIR_ENTRY *d ;
  int indxr ;
  int cntr ;
  int tmp ;

  {
#line 513
  d = global_dirdat;
#line 516
  if (nrents < 1) {
#line 517
    return (0);
  }
#line 519
  indxr = nrents;
#line 519
  cntr = 0;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if (! indxr) {
#line 519
      goto while_break;
    }
#line 520
    if ((d->mode & 61440U) == 32768U) {
      {
#line 520
      tmp = wildmat((char const   *)(d->fname), (char const   *)pat);
      }
#line 520
      if (tmp) {
#line 521
        if (tag) {
#line 522
          d->cflags = (ushort )((int )d->cflags | 128);
#line 523
          cntr ++;
        } else
#line 524
        if ((int )d->cflags & 128) {
#line 525
          d->cflags = (ushort )((int )d->cflags & -129);
#line 526
          cntr ++;
        }
      }
    }
#line 519
    indxr --;
#line 519
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return (cntr);
}
}
#line 537 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
static char *concat_list(GETSDIR_ENTRY *dirdat ) 
{ 
  GETSDIR_ENTRY *d ;
  int indxr ;
  int len ;
  int i ;
  char *j ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
#line 544
  d = dirdat;
#line 545
  indxr = nrents;
#line 545
  len = 0;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! indxr) {
#line 545
      goto while_break;
    }
#line 546
    if ((int )d->cflags & 128) {
      {
#line 547
      tmp = strlen((char const   *)(d->fname));
#line 547
      len = (int )((size_t )len + (tmp + 1UL));
      }
    }
#line 545
    indxr --;
#line 545
    d ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  if (len) {
#line 550
    if (len > 8192) {
      {
#line 551
      tmp___1 = realloc((void *)ret_buf, (size_t )len);
#line 551
      ret_buf = (char *)tmp___1;
      }
#line 551
      if ((unsigned long )ret_buf == (unsigned long )((void *)0)) {
        {
#line 552
        tmp___0 = gettext("Too many files tagged - buffer would overflow");
#line 552
        file_tell((char const   *)tmp___0);
        }
#line 553
        return ((char *)((void *)0));
      }
    }
#line 557
    *ret_buf = (char)0;
#line 558
    d = dirdat;
#line 559
    indxr = nrents;
    {
#line 559
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 559
      if (! indxr) {
#line 559
        goto while_break___0;
      }
#line 560
      if ((int )d->cflags & 128) {
        {
#line 562
        tmp___2 = strlen((char const   *)ret_buf);
#line 562
        i = (int )tmp___2;
#line 562
        j = d->fname;
        }
        {
#line 562
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 562
          if (! *j) {
#line 562
            goto while_break___1;
          }
#line 563
          if ((int )*j == 32) {
            {
#line 564
            len ++;
#line 564
            tmp___4 = realloc((void *)ret_buf, (size_t )len);
#line 564
            ret_buf = (char *)tmp___4;
            }
#line 564
            if ((unsigned long )ret_buf == (unsigned long )((void *)0)) {
              {
#line 565
              tmp___3 = gettext("Too many files tagged - buffer would overflow");
#line 565
              file_tell((char const   *)tmp___3);
              }
#line 566
              return ((char *)((void *)0));
            }
#line 568
            tmp___5 = i;
#line 568
            i ++;
#line 568
            *(ret_buf + tmp___5) = (char )'\\';
          }
#line 570
          tmp___6 = i;
#line 570
          i ++;
#line 570
          *(ret_buf + tmp___6) = *j;
#line 562
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 572
        tmp___7 = i;
#line 572
        i ++;
#line 572
        *(ret_buf + tmp___7) = (char )' ';
#line 573
        *(ret_buf + i) = (char )'\000';
      }
#line 559
      indxr --;
#line 559
      d ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 576
    tmp___8 = strlen((char const   *)ret_buf);
#line 576
    *(ret_buf + (tmp___8 - 1UL)) = (char)0;
    }
#line 577
    return (ret_buf);
  }
#line 580
  return ((char *)((void *)0));
}
}
#line 596 "/home/wheatley/newnew/temp/minicom-2.7/src/file.c"
char *filedir(int howmany , int downloading ) 
{ 
  time_t click_time ;
  size_t i ;
  GETSDIR_ENTRY *d ;
  GETSDIR_ENTRY *tmp ;
  time_t this_time ;
  time_t tmp___0 ;
  GETSDIR_ENTRY *d2 ;
  GETSDIR_ENTRY *tmp___1 ;
  char *tmp___2 ;
  ushort tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char buf___6[128] ;
  char *s___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *s___1 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char tag_buf[128] ;
  char *s___2 ;
  char *tmp___12 ;
  int newly_tagged ;
  char *tmp___13 ;
  char tag_buf___0[128] ;
  char *s___3 ;
  int untagged ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *ret_ptr ;
  char *tmp___16 ;
  int f_exist ;
  int tmp___17 ;
  char buf___7[8192] ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 598
  click_time = (time_t )0;
#line 601
  how_many = howmany;
#line 602
  down_loading = downloading;
#line 603
  init_filedir();
  }
  again: 
  {
#line 606
  mc_wlocate(main_w, 0, (cur + 1) - top);
  }
#line 607
  if (first) {
    {
#line 608
    mc_wredraw(main_w, 1);
#line 609
    first = 0;
    }
  }
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (! quit)) {
#line 611
      goto while_break;
    }
    {
#line 612
    tmp = getno(cur, global_dirdat);
#line 612
    d = tmp;
#line 617
    c = wxgetch();
    }
    {
#line 619
    if (c == 107) {
#line 619
      goto case_107;
    }
#line 619
    if (c == 269) {
#line 619
      goto case_107;
    }
#line 627
    if (c == 106) {
#line 627
      goto case_106;
    }
#line 627
    if (c == 272) {
#line 627
      goto case_106;
    }
#line 635
    if (c == 104) {
#line 635
      goto case_104;
    }
#line 635
    if (c == 270) {
#line 635
      goto case_104;
    }
#line 641
    if (c == 108) {
#line 641
      goto case_108;
    }
#line 641
    if (c == 271) {
#line 641
      goto case_108;
    }
#line 645
    if (c == 2) {
#line 645
      goto case_2;
    }
#line 645
    if (c == 268) {
#line 645
      goto case_2;
    }
#line 650
    if (c == 6) {
#line 650
      goto case_6;
    }
#line 650
    if (c == 274) {
#line 650
      goto case_6;
    }
#line 654
    if (c == 32) {
#line 654
      goto case_32;
    }
#line 685
    if (c == 10) {
#line 685
      goto case_10;
    }
#line 685
    if (c == 13) {
#line 685
      goto case_10;
    }
#line 685
    if (c == 27) {
#line 685
      goto case_10;
    }
#line 689
    goto switch_default;
    case_107: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 624
    cur -= cur > 0;
#line 625
    goto switch_break;
    case_106: /* CIL Label */ 
    case_272: /* CIL Label */ 
#line 632
    cur += cur < nrents - 1;
#line 633
    goto switch_break;
    case_104: /* CIL Label */ 
    case_270: /* CIL Label */ 
#line 636
    subm --;
#line 637
    if (subm < 0) {
#line 638
      subm = 5;
    }
#line 639
    goto switch_break;
    case_108: /* CIL Label */ 
    case_271: /* CIL Label */ 
#line 642
    subm = (subm + 1) % 6;
#line 643
    goto switch_break;
    case_2: /* CIL Label */ 
    case_268: /* CIL Label */ 
#line 646
    pgud = 1;
#line 647
    quit = 1;
#line 648
    goto switch_break;
    case_6: /* CIL Label */ 
    case_274: /* CIL Label */ 
#line 651
    pgud = 2;
#line 652
    quit = 1;
#line 653
    goto switch_break;
    case_32: /* CIL Label */ 
#line 655
    if ((d->mode & 61440U) == 16384U) {
      {
#line 656
      tmp___0 = time((time_t *)((void *)0));
#line 656
      this_time = tmp___0;
      }
#line 657
      if (this_time - click_time < 2L) {
        {
#line 658
        tmp___1 = getno(cur, global_dirdat);
#line 658
        d2 = tmp___1;
#line 659
        goto_filedir(d2->fname, 0);
#line 660
        click_time = (time_t )0;
        }
      } else {
#line 662
        click_time = this_time;
      }
    } else
#line 665
    if (how_many) {
#line 666
      tmp___3 = (ushort )((int )d->cflags ^ 128);
#line 666
      d->cflags = tmp___3;
#line 666
      if ((int )tmp___3 & 128) {
#line 667
        if (tag_cnt) {
#line 667
          if (how_many == 1) {
            {
#line 668
            d->cflags = (ushort )((int )d->cflags & -129);
#line 669
            tmp___2 = gettext("Can select only one!");
#line 669
            file_tell((char const   *)tmp___2);
            }
#line 670
            goto switch_break;
          }
        }
#line 672
        tag_cnt ++;
      } else {
#line 674
        tag_cnt --;
      }
      {
#line 675
      mc_wlocate(main_w, 0, (cur + 1) - top);
#line 676
      prone(main_w, d, longest, (int )d->cflags & 128);
#line 677
      mc_wputc(main_w, '\n');
#line 678
      cur += cur < nrents - 1;
      }
    }
#line 681
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 686
    quit = 1;
#line 687
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 690
    i = (size_t )0;
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! (i < sizeof(what) / sizeof(what[0]))) {
#line 690
        goto while_break___0;
      }
      {
#line 691
      tmp___4 = toupper(c);
#line 691
      tmp___5 = gettext((char const   *)what[i]);
#line 691
      tmp___6 = strchr((char const   *)tmp___5, tmp___4);
      }
#line 691
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 692
        subm = (int )i;
#line 693
        c = '\n';
#line 694
        quit = 1;
#line 695
        goto while_break___0;
      }
#line 690
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 699
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 702
    if (c != 32) {
#line 703
      click_time = (time_t )0;
    }
#line 705
    if (cur < top) {
      {
#line 706
      top --;
#line 707
      prdir(main_w, top, top, global_dirdat, longest);
      }
    }
#line 709
    if (cur - top > main_w->ys - 3) {
      {
#line 710
      top ++;
#line 711
      prdir(main_w, top, top, global_dirdat, longest);
      }
    }
    {
#line 718
    ocur = cur;
#line 719
    dhili(subm);
#line 721
    mc_wlocate(main_w, 0, (cur + 1) - top);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  quit = 0;
#line 726
  if (c == 27) {
    {
#line 727
    mc_wclose(main_w, 1);
#line 728
    mc_wclose(dsub, 1);
#line 729
    free((void *)global_dirdat);
#line 730
    global_dirdat = (GETSDIR_ENTRY *)((void *)0);
    }
#line 731
    return ((char *)((void *)0));
  }
#line 734
  if (pgud == 1) {
#line 735
    ocur = top;
#line 736
    top -= main_w->ys - 2;
#line 737
    if (top < 0) {
#line 738
      top = 0;
    }
#line 739
    cur = top;
#line 740
    pgud = 0;
#line 741
    if (ocur != top) {
      {
#line 742
      prdir(main_w, top, cur, global_dirdat, longest);
      }
    }
#line 743
    ocur = cur;
#line 744
    goto again;
  }
#line 746
  if (pgud == 2) {
#line 747
    ocur = top;
#line 748
    if (top < (nrents - main_w->ys) + 2) {
#line 749
      top += main_w->ys - 2;
#line 750
      if (top > (nrents - main_w->ys) + 2) {
#line 751
        top = (nrents - main_w->ys) + 2;
      }
#line 753
      cur = top;
    } else {
#line 755
      cur = nrents - 1;
    }
#line 756
    pgud = 0;
#line 757
    if (ocur != top) {
      {
#line 758
      prdir(main_w, top, cur, global_dirdat, longest);
      }
    }
#line 759
    ocur = cur;
#line 760
    goto again;
  }
#line 763
  if (c == 13) {
#line 763
    goto _L___0;
  } else
#line 763
  if (c == 10) {
    _L___0: /* CIL Label */ 
    {
#line 765
    if (subm == 0) {
#line 765
      goto case_0;
    }
#line 778
    if (subm == 1) {
#line 778
      goto case_1;
    }
#line 782
    if (subm == 2) {
#line 782
      goto case_2___0;
    }
#line 793
    if (subm == 3) {
#line 793
      goto case_3;
    }
#line 815
    if (subm == 4) {
#line 815
      goto case_4;
    }
#line 835
    if (subm == 5) {
#line 835
      goto case_5;
    }
#line 893
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 770
    if (down_loading) {
#line 770
      tmp___7 = mpars[59].value;
    } else {
#line 770
      tmp___7 = mpars[58].value;
    }
    {
#line 770
    strncpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)tmp___7,
            sizeof(buf___6) - 1UL);
#line 771
    tmp___8 = gettext("Goto directory:");
#line 771
    s___0 = input(tmp___8, buf___6);
    }
#line 773
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 774
      goto switch_break___0;
    }
    {
#line 775
    goto_filedir(buf___6, 1);
    }
#line 777
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 780
    goto_filedir(prev_dir, 1);
    }
#line 781
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 785
    tmp___9 = gettext("Filename pattern:");
#line 785
    tmp___10 = input(tmp___9, wc_mem);
#line 785
    s___1 = tmp___10;
    }
#line 786
    if ((unsigned long )s___1 == (unsigned long )((void *)0)) {
#line 787
      goto switch_break___0;
    } else
#line 786
    if ((int )*s___1 == 0) {
#line 787
      goto switch_break___0;
    }
    {
#line 788
    strcpy((char */* __restrict  */)(wc_str), (char const   */* __restrict  */)(wc_mem));
#line 789
    new_filedir(global_dirdat, 1);
#line 790
    wc_str[0] = (char)0;
    }
#line 792
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 795
    if (how_many == 1) {
      {
#line 796
      tmp___11 = gettext("Can select only one!");
#line 796
      file_tell((char const   *)tmp___11);
      }
    } else
#line 797
    if (how_many == -1) {
      {
#line 800
      strncpy((char */* __restrict  */)(tag_buf), (char const   */* __restrict  */)(wc_mem),
              (size_t )128);
#line 802
      tmp___12 = gettext("Tag pattern:");
#line 802
      s___2 = input(tmp___12, tag_buf);
      }
#line 803
      if ((unsigned long )s___2 != (unsigned long )((void *)0)) {
#line 803
        if ((int )*s___2 != 0) {
          {
#line 805
          newly_tagged = tag_untag(tag_buf, 1);
          }
#line 805
          if (newly_tagged == 0) {
            {
#line 806
            tmp___13 = gettext("No file(s) tagged");
#line 806
            file_tell((char const   *)tmp___13);
            }
#line 807
            goto tag_end;
          }
          {
#line 809
          tag_cnt += newly_tagged;
#line 810
          prdir(main_w, top, top, global_dirdat, longest);
          }
        }
      }
    }
    tag_end: 
#line 814
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 821
    strncpy((char */* __restrict  */)(tag_buf___0), (char const   */* __restrict  */)(wc_mem),
            (size_t )128);
#line 823
    tmp___14 = gettext("Untag pattern:");
#line 823
    s___3 = input(tmp___14, tag_buf___0);
    }
#line 824
    if ((unsigned long )s___3 == (unsigned long )((void *)0)) {
#line 825
      goto untag_end;
    } else
#line 824
    if ((int )*s___3 == 0) {
#line 825
      goto untag_end;
    }
    {
#line 826
    untagged = tag_untag(tag_buf___0, 0);
    }
#line 826
    if (untagged == 0) {
      {
#line 827
      tmp___15 = gettext("No file(s) untagged");
#line 827
      file_tell((char const   *)tmp___15);
      }
#line 828
      goto untag_end;
    }
    {
#line 830
    tag_cnt -= untagged;
#line 831
    prdir(main_w, top, top, global_dirdat, longest);
    }
    untag_end: 
#line 834
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 838
    ret_ptr = (char *)((void *)0);
#line 840
    if (how_many != 0) {
#line 840
      if (! tag_cnt) {
        {
#line 842
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 843
          tmp___16 = gettext("No file selected - enter filename:");
#line 843
          s = input(tmp___16, ret_buf);
          }
#line 845
          if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 845
            if ((int )*s != 0) {
              {
#line 846
              tmp___17 = access((char const   *)ret_buf, 0);
#line 846
              f_exist = tmp___17;
              }
#line 847
              if (down_loading) {
#line 848
                if (f_exist != -1) {
                  {
#line 852
                  tmp___18 = gettext("File: \"%s\" exists! Overwrite?");
#line 852
                  snprintf((char */* __restrict  */)(buf___7), sizeof(buf___7), (char const   */* __restrict  */)tmp___18,
                           ret_buf);
#line 854
                  tmp___19 = ask((char const   *)(buf___7), d_yesno);
                  }
#line 854
                  if (tmp___19 == 0) {
#line 855
                    ret_ptr = ret_buf;
#line 856
                    goto while_break___1;
                  }
                } else {
#line 859
                  ret_ptr = ret_buf;
#line 860
                  goto while_break___1;
                }
              } else
#line 863
              if (f_exist == -1) {
                {
#line 864
                tmp___20 = gettext("no such file!");
#line 864
                file_tell((char const   *)tmp___20);
                }
              } else {
#line 866
                ret_ptr = ret_buf;
#line 867
                goto while_break___1;
              }
            } else {
#line 872
              goto again;
            }
          } else {
#line 872
            goto again;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 840
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 878
    if (how_many == 0) {
#line 880
      ret_ptr = work_dir;
    } else {
      {
#line 882
      ret_ptr = concat_list(global_dirdat);
      }
    }
    {
#line 886
    mc_wclose(main_w, 1);
#line 887
    mc_wclose(dsub, 1);
#line 888
    free((void *)global_dirdat);
#line 889
    global_dirdat = (GETSDIR_ENTRY *)((void *)0);
    }
#line 890
    return (ret_ptr);
#line 892
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 895
    file_tell("BEEP!");
    }
#line 896
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 900
  goto again;
}
}
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int esc_s___0  =    0;
#line 60 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static struct escseq vt_keys___0[23]  = 
#line 60
  {      {257, "OP", "OP", "OP"}, 
        {258, "OQ", "OQ", "OQ"}, 
        {259, "OR", "OR", "OR"}, 
        {260, "OS", "OS", "OS"}, 
        {261, "[16~", "[16~", "OT"}, 
        {262, "[17~", "[17~", "OU"}, 
        {263, "[18~", "[18~", "OV"}, 
        {264, "[19~", "[19~", "OW"}, 
        {265, "[20~", "[20~", "OX"}, 
        {266, "[21~", "[21~", "OY"}, 
        {277, "[23~", "[23~", "OY"}, 
        {278, "[24~", "[24~", "OY"}, 
        {267, "[1~", "[1~", "[H"}, 
        {268, "[5~", "[5~", "[V"}, 
        {269, "[A", "OA", "[A"}, 
        {270, "[D", "OD", "[D"}, 
        {271, "[C", "OC", "[C"}, 
        {272, "[B", "OB", "[B"}, 
        {273, "[4~", "[4~", "[Y"}, 
        {274, "[6~", "[6~", "[U"}, 
        {275, "[2~", "[2~", "[@"}, 
        {276, "[3~", "[3~", "\177"}, 
        {0, (char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
#line 100 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *vt_map___0[2]  = {      (char *)"................................ !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~.................................\377\255\233\234\376\235|\025\376\376\246\256\252-\376\376\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376\376\245\376\376\376\376\231\376\350\376\376\376\232\376\376\341\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213\376\244\225\242\223\376\224\366\355\227\243\226\201\376\376\230",      (char *)"................\000\000\000\000\000\000\000\000\000\000\376\000\000\000\000\000 !\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ \004\261\a\a\a\a\370\361\a\a\331\277\332\300\305\304\304\304__\303\264\301\302\263\363\362\343\330\234\a\000................................\377\255\233\234\376\235|\025\376\376\246\256\252-\376\376\370\361\375\376\376\346\024\371\376\376\247\257\254\253\376\250\376\376\376\376\216\217\222\200\376\220\376\376\376\376\376\376\376\245\376\376\376\376\231\376\376\376\376\376\232\376\376\341\205\240\203\376\204\206\221\207\212\202\210\211\215\241\214\213\376\244\225\242\223\376\224\366\376\227\243\226\201\376\376\230"};
#line 131 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *vt_trans___0[2]  ;
#line 132 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_charset___0  ;
#line 135 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_echo___0  ;
#line 138 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_type___0  =    3;
#line 139 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_wrap___0  ;
#line 140 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_addlf___0  ;
#line 141 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_addcr___0  ;
#line 142 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_fg___0  ;
#line 143 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_bg___0  ;
#line 144 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_keypad___0  ;
#line 145 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_cursor___0  ;
#line 146 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_asis___0  ;
#line 147 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_line_timestamp___0  ;
#line 148 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_bs___0  =    8;
#line 149 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_insert___0  ;
#line 150 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_crlf___0  ;
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_om___0  ;
#line 153 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int vt_docap___0  ;
#line 154 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void (*vt_keyb___0)(int  , int  )  ;
#line 155 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void (*termout___0)(char const   * , int  )  ;
#line 157 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int escparms___0[8]  ;
#line 158 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int ptr___0  ;
#line 159 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static long vt_tabs___0[5]  ;
#line 161 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short newy1___0  =    (short)0;
#line 162 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short newy2___0  =    (short)23;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savex___0  ;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savey___0  ;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short saveattr___0  =    (short)0;
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savecol___0  =    (short)112;
#line 168 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static short savecharset___0  ;
#line 169 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char *savetrans___0[2]  ;
#line 269 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void v_termout___0(char const   *s___0 , int len ) 
{ 
  char const   *p ;

  {
#line 273
  if (vt_echo___0) {
#line 274
    p = s___0;
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (! *p) {
#line 274
        goto while_break;
      }
      {
#line 275
      vt_out((int )*p);
      }
#line 276
      if (! vt_addlf___0) {
#line 276
        if ((int const   )*p == 13) {
          {
#line 277
          vt_out('\n');
          }
        }
      }
#line 274
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 279
    mc_wflush();
    }
  }
  {
#line 282
  (*termout___0)(s___0, len);
  }
#line 283
  return;
}
}
#line 292 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state1___0(int c___0 ) 
{ 
  short x ;
  short y ;
  short f ;

  {
  {
#line 297
  if (c___0 == 91) {
#line 297
    goto case_91;
  }
#line 300
  if (c___0 == 40) {
#line 300
    goto case_40;
  }
#line 303
  if (c___0 == 41) {
#line 303
    goto case_41;
  }
#line 306
  if (c___0 == 35) {
#line 306
    goto case_35;
  }
#line 309
  if (c___0 == 80) {
#line 309
    goto case_80;
  }
#line 313
  if (c___0 == 77) {
#line 313
    goto case_77;
  }
#line 313
  if (c___0 == 68) {
#line 313
    goto case_77;
  }
#line 330
  if (c___0 == 69) {
#line 330
    goto case_69;
  }
#line 334
  if (c___0 == 115) {
#line 334
    goto case_115;
  }
#line 334
  if (c___0 == 55) {
#line 334
    goto case_115;
  }
#line 346
  if (c___0 == 117) {
#line 346
    goto case_117;
  }
#line 346
  if (c___0 == 56) {
#line 346
    goto case_117;
  }
#line 356
  if (c___0 == 61) {
#line 356
    goto case_61;
  }
#line 361
  if (c___0 == 62) {
#line 361
    goto case_62;
  }
#line 366
  if (c___0 == 90) {
#line 366
    goto case_90;
  }
#line 372
  if (c___0 == 99) {
#line 372
    goto case_99;
  }
#line 382
  if (c___0 == 72) {
#line 382
    goto case_72;
  }
#line 391
  goto switch_default;
  case_91: /* CIL Label */ 
#line 298
  esc_s___0 = 2;
#line 299
  return;
  case_40: /* CIL Label */ 
#line 301
  esc_s___0 = 4;
#line 302
  return;
  case_41: /* CIL Label */ 
#line 304
  esc_s___0 = 5;
#line 305
  return;
  case_35: /* CIL Label */ 
#line 307
  esc_s___0 = 6;
#line 308
  return;
  case_80: /* CIL Label */ 
#line 310
  esc_s___0 = 7;
#line 311
  return;
  case_77: /* CIL Label */ 
  case_68: /* CIL Label */ 
#line 314
  x = vt_win->curx;
#line 315
  if (c___0 == 68) {
#line 316
    y = (short )((int )vt_win->cury + 1);
#line 317
    if ((int )y == (int )newy2___0 + 1) {
      {
#line 318
      mc_wscroll(vt_win, 1);
      }
    } else
#line 319
    if ((int )vt_win->cury < vt_win->ys) {
      {
#line 320
      mc_wlocate(vt_win, (int )x, (int )y);
      }
    }
  }
#line 322
  if (c___0 == 77) {
#line 323
    y = (short )((int )vt_win->cury - 1);
#line 324
    if ((int )y == (int )newy1___0 - 1) {
      {
#line 325
      mc_wscroll(vt_win, 2);
      }
    } else
#line 326
    if ((int )y >= 0) {
      {
#line 327
      mc_wlocate(vt_win, (int )x, (int )y);
      }
    }
  }
#line 329
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 331
  mc_wputs(vt_win, "\r\n");
  }
#line 332
  goto switch_break;
  case_115: /* CIL Label */ 
  case_55: /* CIL Label */ 
#line 335
  savex___0 = vt_win->curx;
#line 336
  savey___0 = vt_win->cury;
#line 337
  saveattr___0 = (short )vt_win->attr;
#line 338
  savecol___0 = (short )vt_win->color;
#line 340
  savecharset___0 = (short )vt_charset___0;
#line 341
  savetrans___0[0] = vt_trans___0[0];
#line 342
  savetrans___0[1] = vt_trans___0[1];
#line 344
  goto switch_break;
  case_117: /* CIL Label */ 
  case_56: /* CIL Label */ 
  {
#line 348
  vt_charset___0 = (int )savecharset___0;
#line 349
  vt_trans___0[0] = savetrans___0[0];
#line 350
  vt_trans___0[1] = savetrans___0[1];
#line 352
  vt_win->color = (char )savecol___0;
#line 353
  vt_win->attr = (char )saveattr___0;
#line 354
  mc_wlocate(vt_win, (int )savex___0, (int )savey___0);
  }
#line 355
  goto switch_break;
  case_61: /* CIL Label */ 
#line 357
  vt_keypad___0 = 2;
#line 358
  if (vt_keyb___0) {
    {
#line 359
    (*vt_keyb___0)(vt_keypad___0, vt_cursor___0);
    }
  }
#line 360
  goto switch_break;
  case_62: /* CIL Label */ 
#line 362
  vt_keypad___0 = 1;
#line 363
  if (vt_keyb___0) {
    {
#line 364
    (*vt_keyb___0)(vt_keypad___0, vt_cursor___0);
    }
  }
#line 365
  goto switch_break;
  case_90: /* CIL Label */ 
#line 367
  if (vt_type___0 == 1) {
    {
#line 368
    v_termout___0("\033[?1;0c", 0);
    }
  } else {
    {
#line 370
    v_termout___0("\033[?c", 0);
    }
  }
#line 371
  goto switch_break;
  case_99: /* CIL Label */ 
#line 373
  f = (short)0;
#line 374
  vt_win->attr = (char )f;
#line 375
  vt_win->wrap = (char )(vt_type___0 != 1);
#line 376
  if (vt_wrap___0 != -1) {
#line 377
    vt_win->wrap = (char )vt_wrap___0;
  }
  {
#line 378
  vt_insert___0 = 0;
#line 378
  vt_crlf___0 = vt_insert___0;
#line 379
  vt_init(vt_type___0, vt_fg___0, vt_bg___0, (int )vt_win->wrap, 0, 0);
#line 380
  mc_wlocate(vt_win, 0, 0);
  }
#line 381
  goto switch_break;
  case_72: /* CIL Label */ 
#line 383
  x = vt_win->curx;
#line 384
  if ((int )x > 159) {
#line 385
    x = (short)159;
  }
#line 386
  vt_tabs___0[(int )x / 32] |= (long )(1 << (int )x % 32);
#line 387
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 393
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 395
  esc_s___0 = 0;
#line 396
  return;
}
}
#line 399 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void ansi_mode___0(int on_off ) 
{ 
  int i ;

  {
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i <= ptr___0)) {
#line 403
      goto while_break;
    }
    {
#line 405
    if (escparms___0[i] == 4) {
#line 405
      goto case_4;
    }
#line 408
    if (escparms___0[i] == 20) {
#line 408
      goto case_20;
    }
#line 404
    goto switch_break;
    case_4: /* CIL Label */ 
#line 406
    vt_insert___0 = on_off;
#line 407
    goto switch_break;
    case_20: /* CIL Label */ 
#line 409
    vt_crlf___0 = on_off;
#line 410
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 403
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return;
}
}
#line 418 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state2___0(int c___0 ) 
{ 
  short x ;
  short y ;
  short attr ;
  short f ;
  char temp[32] ;
  int tmp ;

  {
#line 424
  if (c___0 >= 48) {
#line 424
    if (c___0 <= 57) {
#line 425
      escparms___0[ptr___0] = (10 * escparms___0[ptr___0] + c___0) - 48;
#line 426
      return;
    }
  }
#line 429
  if (c___0 == 59) {
#line 430
    if (ptr___0 < 15) {
#line 431
      ptr___0 ++;
    }
#line 432
    return;
  }
#line 435
  if (escparms___0[0] == 0) {
#line 435
    if (ptr___0 == 0) {
#line 435
      if (c___0 == 63) {
#line 437
        esc_s___0 = 3;
#line 438
        return;
      }
    }
  }
  {
#line 446
  if (c___0 == 68) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 67) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 66) {
#line 446
    goto case_68;
  }
#line 446
  if (c___0 == 65) {
#line 446
    goto case_68;
  }
#line 472
  if (c___0 == 88) {
#line 472
    goto case_88;
  }
#line 477
  if (c___0 == 75) {
#line 477
    goto case_75;
  }
#line 490
  if (c___0 == 74) {
#line 490
    goto case_74;
  }
#line 514
  if (c___0 == 110) {
#line 514
    goto case_110;
  }
#line 525
  if (c___0 == 99) {
#line 525
    goto case_99;
  }
#line 532
  if (c___0 == 120) {
#line 532
    goto case_120;
  }
#line 537
  if (c___0 == 115) {
#line 537
    goto case_115;
  }
#line 548
  if (c___0 == 117) {
#line 548
    goto case_117;
  }
#line 558
  if (c___0 == 104) {
#line 558
    goto case_104;
  }
#line 561
  if (c___0 == 108) {
#line 561
    goto case_108;
  }
#line 565
  if (c___0 == 102) {
#line 565
    goto case_102;
  }
#line 565
  if (c___0 == 72) {
#line 565
    goto case_102;
  }
#line 574
  if (c___0 == 103) {
#line 574
    goto case_103;
  }
#line 585
  if (c___0 == 109) {
#line 585
    goto case_109;
  }
#line 632
  if (c___0 == 76) {
#line 632
    goto case_76;
  }
#line 638
  if (c___0 == 77) {
#line 638
    goto case_77;
  }
#line 644
  if (c___0 == 80) {
#line 644
    goto case_80;
  }
#line 650
  if (c___0 == 64) {
#line 650
    goto case_64;
  }
#line 656
  if (c___0 == 114) {
#line 656
    goto case_114;
  }
#line 679
  goto switch_default;
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 447
  f = (short )escparms___0[0];
#line 447
  if ((int )f == 0) {
#line 448
    f = (short)1;
  }
#line 449
  x = vt_win->curx;
#line 450
  y = vt_win->cury;
#line 451
  x = (short )((int )x + (int )f * ((c___0 == 67) - (c___0 == 68)));
#line 452
  if ((int )x < 0) {
#line 453
    x = (short)0;
  }
#line 454
  if ((int )x >= vt_win->xs) {
#line 455
    x = (short )(vt_win->xs - 1);
  }
#line 456
  if (c___0 == 66) {
#line 457
    y = (short )((int )y + (int )f);
#line 458
    if ((int )y >= vt_win->ys) {
#line 459
      y = (short )(vt_win->ys - 1);
    }
#line 460
    if ((int )y >= (int )newy2___0 + 1) {
#line 461
      y = newy2___0;
    }
  }
#line 463
  if (c___0 == 65) {
#line 464
    y = (short )((int )y - (int )f);
#line 465
    if ((int )y < 0) {
#line 466
      y = (short)0;
    }
#line 467
    if ((int )y <= (int )newy1___0 - 1) {
#line 468
      y = newy1___0;
    }
  }
  {
#line 470
  mc_wlocate(vt_win, (int )x, (int )y);
  }
#line 471
  goto switch_break;
  case_88: /* CIL Label */ 
#line 473
  f = (short )escparms___0[0];
#line 473
  if ((int )f == 0) {
#line 474
    f = (short)1;
  }
  {
#line 475
  mc_wclrch(vt_win, (int )f);
  }
#line 476
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 479
  if (escparms___0[0] == 0) {
#line 479
    goto case_0;
  }
#line 482
  if (escparms___0[0] == 1) {
#line 482
    goto case_1;
  }
#line 485
  if (escparms___0[0] == 2) {
#line 485
    goto case_2;
  }
#line 478
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 480
  mc_wclreol(vt_win);
  }
#line 481
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 483
  mc_wclrbol(vt_win);
  }
#line 484
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
#line 486
  mc_wclrel(vt_win);
  }
#line 487
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 489
  goto switch_break;
  case_74: /* CIL Label */ 
#line 491
  x = (short )vt_win->color;
#line 492
  y = (short )vt_win->attr;
#line 493
  if (vt_type___0 == 3) {
#line 494
    vt_win->attr = (char)0;
#line 495
    vt_win->color = (char )(((int )vt_win->color & 15) + (7 << 4));
#line 496
    vt_win->color = (char )((int )vt_win->color & 240);
  }
  {
#line 499
  if (escparms___0[0] == 0) {
#line 499
    goto case_0___0;
  }
#line 502
  if (escparms___0[0] == 1) {
#line 502
    goto case_1___0;
  }
#line 505
  if (escparms___0[0] == 2) {
#line 505
    goto case_2___0;
  }
#line 498
  goto switch_break___1;
  case_0___0: /* CIL Label */ 
  {
#line 500
  mc_wclreos(vt_win);
  }
#line 501
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 503
  mc_wclrbos(vt_win);
  }
#line 504
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 506
  mc_winclr(vt_win);
  }
#line 507
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 509
  if (vt_type___0 == 3) {
#line 510
    vt_win->color = (char )x;
#line 511
    vt_win->attr = (char )y;
  }
#line 513
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 516
  if (escparms___0[0] == 5) {
#line 516
    goto case_5;
  }
#line 519
  if (escparms___0[0] == 6) {
#line 519
    goto case_6;
  }
#line 515
  goto switch_break___2;
  case_5: /* CIL Label */ 
  {
#line 517
  v_termout___0("\033[0n", 0);
  }
#line 518
  goto switch_break___2;
  case_6: /* CIL Label */ 
  {
#line 520
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"\033[%d;%dR",
          (int )vt_win->cury + 1, (int )vt_win->curx + 1);
#line 521
  v_termout___0((char const   *)(temp), 0);
  }
#line 522
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 524
  goto switch_break;
  case_99: /* CIL Label */ 
#line 526
  if (vt_type___0 == 1) {
    {
#line 527
    v_termout___0("\033[?1;2c", 0);
    }
#line 528
    goto switch_break;
  }
  {
#line 530
  v_termout___0("\033[?c", 0);
  }
#line 531
  goto switch_break;
  case_120: /* CIL Label */ 
#line 534
  if (escparms___0[0] == 1) {
#line 534
    tmp = '3';
  } else {
#line 534
    tmp = '2';
  }
  {
#line 534
  sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"\033[%c;1;1;120;120;1;0x",
          tmp);
#line 535
  v_termout___0((char const   *)(temp), 0);
  }
#line 536
  goto switch_break;
  case_115: /* CIL Label */ 
#line 538
  savex___0 = vt_win->curx;
#line 539
  savey___0 = vt_win->cury;
#line 540
  saveattr___0 = (short )vt_win->attr;
#line 541
  savecol___0 = (short )vt_win->color;
#line 543
  savecharset___0 = (short )vt_charset___0;
#line 544
  savetrans___0[0] = vt_trans___0[0];
#line 545
  savetrans___0[1] = vt_trans___0[1];
#line 547
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 550
  vt_charset___0 = (int )savecharset___0;
#line 551
  vt_trans___0[0] = savetrans___0[0];
#line 552
  vt_trans___0[1] = savetrans___0[1];
#line 554
  vt_win->color = (char )savecol___0;
#line 555
  vt_win->attr = (char )saveattr___0;
#line 556
  mc_wlocate(vt_win, (int )savex___0, (int )savey___0);
  }
#line 557
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 559
  ansi_mode___0(1);
  }
#line 560
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 562
  ansi_mode___0(0);
  }
#line 563
  goto switch_break;
  case_102: /* CIL Label */ 
  case_72: /* CIL Label */ 
#line 566
  y = (short )escparms___0[0];
#line 566
  if ((int )y == 0) {
#line 567
    y = (short)1;
  }
#line 568
  x = (short )escparms___0[1];
#line 568
  if ((int )x == 0) {
#line 569
    x = (short)1;
  }
#line 570
  if (vt_om___0) {
#line 571
    y = (short )((int )y + (int )newy1___0);
  }
  {
#line 572
  mc_wlocate(vt_win, (int )x - 1, (int )y - 1);
  }
#line 573
  goto switch_break;
  case_103: /* CIL Label */ 
#line 575
  if (escparms___0[0] == 0) {
#line 576
    x = vt_win->curx;
#line 577
    if ((int )x > 159) {
#line 578
      x = (short)159;
    }
#line 579
    vt_tabs___0[(int )x / 32] &= (long )(~ (1 << (int )x % 32));
  }
#line 581
  if (escparms___0[0] == 3) {
#line 582
    x = (short)0;
    {
#line 582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 582
      if (! ((int )x < 5)) {
#line 582
        goto while_break;
      }
#line 583
      vt_tabs___0[x] = 0L;
#line 582
      x = (short )((int )x + 1);
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 584
  goto switch_break;
  case_109: /* CIL Label */ 
#line 586
  attr = (short )vt_win->attr;
#line 587
  f = (short)0;
  {
#line 587
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 587
    if (! ((int )f <= ptr___0)) {
#line 587
      goto while_break___0;
    }
#line 588
    if (escparms___0[f] >= 30) {
#line 588
      if (escparms___0[f] <= 37) {
#line 589
        vt_win->color = (char )(((int )vt_win->color & 15) + ((escparms___0[f] - 30) << 4));
      }
    }
#line 590
    if (escparms___0[f] >= 40) {
#line 590
      if (escparms___0[f] <= 47) {
#line 591
        vt_win->color = (char )(((int )vt_win->color & 240) + (escparms___0[f] - 40));
      }
    }
    {
#line 593
    if (escparms___0[f] == 0) {
#line 593
      goto case_0___1;
    }
#line 598
    if (escparms___0[f] == 1) {
#line 598
      goto case_1___1;
    }
#line 601
    if (escparms___0[f] == 4) {
#line 601
      goto case_4;
    }
#line 604
    if (escparms___0[f] == 5) {
#line 604
      goto case_5___0;
    }
#line 607
    if (escparms___0[f] == 7) {
#line 607
      goto case_7;
    }
#line 610
    if (escparms___0[f] == 22) {
#line 610
      goto case_22;
    }
#line 613
    if (escparms___0[f] == 24) {
#line 613
      goto case_24;
    }
#line 616
    if (escparms___0[f] == 25) {
#line 616
      goto case_25;
    }
#line 619
    if (escparms___0[f] == 27) {
#line 619
      goto case_27;
    }
#line 622
    if (escparms___0[f] == 39) {
#line 622
      goto case_39;
    }
#line 625
    if (escparms___0[f] == 49) {
#line 625
      goto case_49;
    }
#line 592
    goto switch_break___3;
    case_0___1: /* CIL Label */ 
#line 594
    attr = (short)0;
#line 595
    vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg___0 << 4));
#line 596
    vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg___0);
#line 597
    goto switch_break___3;
    case_1___1: /* CIL Label */ 
#line 599
    attr = (short )((int )attr | 2);
#line 600
    goto switch_break___3;
    case_4: /* CIL Label */ 
#line 602
    attr = (short )((int )attr | 16);
#line 603
    goto switch_break___3;
    case_5___0: /* CIL Label */ 
#line 605
    attr = (short )((int )attr | 1);
#line 606
    goto switch_break___3;
    case_7: /* CIL Label */ 
#line 608
    attr = (short )((int )attr | 4);
#line 609
    goto switch_break___3;
    case_22: /* CIL Label */ 
#line 611
    attr = (short )((int )attr & -3);
#line 612
    goto switch_break___3;
    case_24: /* CIL Label */ 
#line 614
    attr = (short )((int )attr & -17);
#line 615
    goto switch_break___3;
    case_25: /* CIL Label */ 
#line 617
    attr = (short )((int )attr & -2);
#line 618
    goto switch_break___3;
    case_27: /* CIL Label */ 
#line 620
    attr = (short )((int )attr & -5);
#line 621
    goto switch_break___3;
    case_39: /* CIL Label */ 
#line 623
    vt_win->color = (char )(((int )vt_win->color & 15) + (vt_fg___0 << 4));
#line 624
    goto switch_break___3;
    case_49: /* CIL Label */ 
#line 626
    vt_win->color = (char )(((int )vt_win->color & 240) + vt_bg___0);
#line 627
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 587
    f = (short )((int )f + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 630
  vt_win->attr = (char )attr;
#line 631
  goto switch_break;
  case_76: /* CIL Label */ 
#line 633
  x = (short )escparms___0[0];
#line 633
  if ((int )x == 0) {
#line 634
    x = (short)1;
  }
#line 635
  f = (short)0;
  {
#line 635
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 635
    if (! ((int )f < (int )x)) {
#line 635
      goto while_break___1;
    }
    {
#line 636
    mc_winsline(vt_win);
#line 635
    f = (short )((int )f + 1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 637
  goto switch_break;
  case_77: /* CIL Label */ 
#line 639
  x = (short )escparms___0[0];
#line 639
  if ((int )x == 0) {
#line 640
    x = (short)1;
  }
#line 641
  f = (short)0;
  {
#line 641
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 641
    if (! ((int )f < (int )x)) {
#line 641
      goto while_break___2;
    }
    {
#line 642
    mc_wdelline(vt_win);
#line 641
    f = (short )((int )f + 1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 643
  goto switch_break;
  case_80: /* CIL Label */ 
#line 645
  x = (short )escparms___0[0];
#line 645
  if ((int )x == 0) {
#line 646
    x = (short)1;
  }
#line 647
  f = (short)0;
  {
#line 647
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 647
    if (! ((int )f < (int )x)) {
#line 647
      goto while_break___3;
    }
    {
#line 648
    mc_wdelchar(vt_win);
#line 647
    f = (short )((int )f + 1);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 649
  goto switch_break;
  case_64: /* CIL Label */ 
#line 651
  x = (short )escparms___0[0];
#line 651
  if ((int )x == 0) {
#line 652
    x = (short)1;
  }
#line 653
  f = (short)0;
  {
#line 653
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 653
    if (! ((int )f < (int )x)) {
#line 653
      goto while_break___4;
    }
    {
#line 654
    mc_winschar(vt_win);
#line 653
    f = (short )((int )f + 1);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 655
  goto switch_break;
  case_114: /* CIL Label */ 
#line 657
  newy1___0 = (short )escparms___0[0];
#line 657
  if ((int )newy1___0 == 0) {
#line 658
    newy1___0 = (short)1;
  }
#line 659
  newy2___0 = (short )escparms___0[1];
#line 659
  if ((int )newy2___0 == 0) {
#line 660
    newy2___0 = (short )vt_win->ys;
  }
#line 661
  newy1___0 = (short )((int )newy1___0 - 1);
#line 661
  newy2___0 = (short )((int )newy2___0 - 1);
#line 662
  if ((int )newy1___0 < 0) {
#line 663
    newy1___0 = (short)0;
  }
#line 664
  if ((int )newy2___0 < 0) {
#line 665
    newy2___0 = (short)0;
  }
#line 666
  if ((int )newy1___0 >= vt_win->ys) {
#line 667
    newy1___0 = (short )(vt_win->ys - 1);
  }
#line 668
  if ((int )newy2___0 >= vt_win->ys) {
#line 669
    newy2___0 = (short )(vt_win->ys - 1);
  }
#line 670
  if ((int )newy1___0 >= (int )newy2___0) {
#line 671
    newy1___0 = (short)0;
#line 672
    newy2___0 = (short )(vt_win->ys - 1);
  }
  {
#line 674
  vt_win->sy1 = vt_win->y1 + (int )newy1___0;
#line 674
  vt_win->sy2 = vt_win->y1 + (int )newy2___0;
#line 675
  mc_wlocate(vt_win, 0, (int )newy1___0);
  }
#line 676
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 681
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 684
  esc_s___0 = 0;
#line 685
  ptr___0 = 0;
#line 686
  memset((void *)(escparms___0), 0, sizeof(escparms___0));
  }
#line 687
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void dec_mode___0(int on_off ) 
{ 
  int i ;
  int tmp ;

  {
#line 695
  i = 0;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (i <= ptr___0)) {
#line 695
      goto while_break;
    }
    {
#line 697
    if (escparms___0[i] == 1) {
#line 697
      goto case_1;
    }
#line 702
    if (escparms___0[i] == 6) {
#line 702
      goto case_6;
    }
#line 706
    if (escparms___0[i] == 7) {
#line 706
      goto case_7;
    }
#line 709
    if (escparms___0[i] == 25) {
#line 709
      goto case_25;
    }
#line 712
    if (escparms___0[i] == 67) {
#line 712
      goto case_67;
    }
#line 715
    goto switch_default;
    case_1: /* CIL Label */ 
#line 698
    if (on_off) {
#line 698
      vt_cursor___0 = 2;
    } else {
#line 698
      vt_cursor___0 = 1;
    }
#line 699
    if (vt_keyb___0) {
      {
#line 700
      (*vt_keyb___0)(vt_keypad___0, vt_cursor___0);
      }
    }
#line 701
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 703
    vt_om___0 = on_off;
#line 704
    mc_wlocate(vt_win, 0, (int )newy1___0);
    }
#line 705
    goto switch_break;
    case_7: /* CIL Label */ 
#line 707
    vt_win->wrap = (char )on_off;
#line 708
    goto switch_break;
    case_25: /* CIL Label */ 
#line 710
    if (on_off) {
#line 710
      tmp = 1;
    } else {
#line 710
      tmp = 0;
    }
    {
#line 710
    mc_wcursor(vt_win, tmp);
    }
#line 711
    goto switch_break;
    case_67: /* CIL Label */ 
#line 714
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 717
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 720
  return;
}
}
#line 725 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state3___0(int c___0 ) 
{ 


  {
#line 728
  if (c___0 >= 48) {
#line 728
    if (c___0 <= 57) {
#line 729
      escparms___0[ptr___0] = (10 * escparms___0[ptr___0] + c___0) - 48;
#line 730
      return;
    }
  }
  {
#line 733
  if (c___0 == 104) {
#line 733
    goto case_104;
  }
#line 736
  if (c___0 == 108) {
#line 736
    goto case_108;
  }
#line 741
  goto switch_default;
  case_104: /* CIL Label */ 
  {
#line 734
  dec_mode___0(1);
  }
#line 735
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 737
  dec_mode___0(0);
  }
#line 738
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 743
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 745
  esc_s___0 = 0;
#line 746
  ptr___0 = 0;
#line 747
  memset((void *)(escparms___0), 0, sizeof(escparms___0));
  }
#line 748
  return;
}
}
#line 754 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state4___0(int c___0 ) 
{ 


  {
  {
#line 763
  if (c___0 == 66) {
#line 763
    goto case_66;
  }
#line 763
  if (c___0 == 65) {
#line 763
    goto case_66;
  }
#line 767
  if (c___0 == 79) {
#line 767
    goto case_79;
  }
#line 767
  if (c___0 == 48) {
#line 767
    goto case_79;
  }
#line 761
  goto switch_break;
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 764
  vt_trans___0[0] = vt_map___0[0];
#line 765
  goto switch_break;
  case_79: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 768
  vt_trans___0[0] = vt_map___0[1];
#line 769
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 772
  esc_s___0 = 0;
#line 773
  return;
}
}
#line 778 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state5___0(int c___0 ) 
{ 


  {
  {
#line 787
  if (c___0 == 66) {
#line 787
    goto case_66;
  }
#line 787
  if (c___0 == 65) {
#line 787
    goto case_66;
  }
#line 791
  if (c___0 == 48) {
#line 791
    goto case_48;
  }
#line 791
  if (c___0 == 79) {
#line 791
    goto case_48;
  }
#line 785
  goto switch_break;
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 788
  vt_trans___0[1] = vt_map___0[0];
#line 789
  goto switch_break;
  case_48: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 792
  vt_trans___0[1] = vt_map___0[1];
#line 793
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 796
  esc_s___0 = 0;
#line 797
  return;
}
}
#line 802 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state6___0(int c___0 ) 
{ 
  int x ;
  int y ;

  {
  {
#line 808
  if (c___0 == 56) {
#line 808
    goto case_56;
  }
#line 822
  goto switch_default;
  case_56: /* CIL Label */ 
  {
#line 810
  vt_win->doscroll = (char)0;
#line 811
  vt_win->direct = (char)0;
#line 812
  mc_wlocate(vt_win, 0, 0);
#line 813
  y = 0;
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (! (y < vt_win->ys)) {
#line 813
      goto while_break;
    }
    {
#line 814
    mc_wlocate(vt_win, 0, y);
#line 815
    x = 0;
    }
    {
#line 815
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 815
      if (! (x < vt_win->xs)) {
#line 815
        goto while_break___0;
      }
      {
#line 816
      mc_wputc(vt_win, 'E');
#line 815
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 813
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 818
  mc_wlocate(vt_win, 0, 0);
#line 819
  vt_win->doscroll = (char)1;
#line 820
  mc_wredraw(vt_win, 1);
  }
#line 821
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 824
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 826
  esc_s___0 = 0;
#line 827
  return;
}
}
#line 839 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static char buf___2[17]  ;
#line 840
static void state7___0(int c___0 ) ;
#line 840 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int pos___0  =    0;
#line 841 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static int state___0  =    0;
#line 832 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void state7___0(int c___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 843
  if (c___0 == 27) {
#line 844
    state___0 = 1;
#line 845
    return;
  }
#line 847
  if (state___0 == 1) {
#line 848
    buf___2[pos___0] = (char)0;
#line 849
    pos___0 = 0;
#line 850
    state___0 = 0;
#line 851
    esc_s___0 = 0;
#line 852
    if (c___0 != 92) {
#line 853
      return;
    }
    {
#line 855
    tmp = strcmp((char const   *)(buf___2), "cursor.on");
    }
#line 855
    if (! tmp) {
      {
#line 856
      mc_wcursor(vt_win, 1);
      }
    }
    {
#line 857
    tmp___0 = strcmp((char const   *)(buf___2), "cursor.off");
    }
#line 857
    if (! tmp___0) {
      {
#line 858
      mc_wcursor(vt_win, 0);
      }
    }
    {
#line 859
    tmp___1 = strcmp((char const   *)(buf___2), "linewrap.on");
    }
#line 859
    if (! tmp___1) {
#line 860
      vt_wrap___0 = -1;
#line 861
      vt_win->wrap = (char)1;
    }
    {
#line 863
    tmp___2 = strcmp((char const   *)(buf___2), "linewrap.off");
    }
#line 863
    if (! tmp___2) {
#line 864
      vt_wrap___0 = -1;
#line 865
      vt_win->wrap = (char)0;
    }
#line 867
    return;
  }
#line 869
  if (pos___0 > 15) {
#line 870
    return;
  }
#line 871
  tmp___3 = pos___0;
#line 871
  pos___0 ++;
#line 871
  buf___2[tmp___3] = (char )c___0;
#line 872
  return;
}
}
#line 874 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void output_s___0(char const   *s___0 ) 
{ 


  {
  {
#line 876
  mc_wputs(vt_win, s___0);
  }
#line 877
  if (vt_docap___0 == 1) {
    {
#line 878
    fputs((char const   */* __restrict  */)s___0, (FILE */* __restrict  */)capfp);
    }
  }
#line 879
  return;
}
}
#line 881 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static void output_c___0(char const   c___0 ) 
{ 


  {
  {
#line 883
  mc_wputc(vt_win, (wchar_t )c___0);
  }
#line 884
  if (vt_docap___0 == 1) {
    {
#line 885
    fputc((int )c___0, capfp);
    }
  }
#line 886
  return;
}
}
#line 890 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static unsigned char last_ch___0  ;
#line 903 "/home/wheatley/newnew/temp/minicom-2.7/src/vt100.c"
static time_t tmstmp_last___0  ;
#line 348 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 60 "/home/wheatley/newnew/temp/minicom-2.7/src/configsym.h"
struct macs mmacs[11] ;
#line 252 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int writepars(FILE *fp , int all ) ;
#line 253
int writemacs(FILE *fp ) ;
#line 254
int readpars(FILE *fp , enum config_type conftype ) ;
#line 255
int readmacs(FILE *fp , int init___3 ) ;
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
struct macs mmacs[11]  = 
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
  {      {{(char )'\000'}, 0, "pmac1"}, 
        {{(char )'\000'}, 0, "pmac2"}, 
        {{(char )'\000'}, 0, "pmac3"}, 
        {{(char )'\000'}, 0, "pmac4"}, 
        {{(char )'\000'}, 0, "pmac5"}, 
        {{(char )'\000'}, 0, "pmac6"}, 
        {{(char )'\000'}, 0, "pmac7"}, 
        {{(char )'\000'}, 0, "pmac8"}, 
        {{(char )'\000'}, 0, "pmac9"}, 
        {{(char )'\000'}, 0, "pmac10"}, 
        {{(char )'\000'}, 0, (char const   *)((void *)0)}};
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
struct pars mpars[94]  = 
#line 64
  {      {{(char )'Y', (char )'U', (char )'N', (char )'Y', (char )'Y', (char )'z', (char )'m',
       (char )'o', (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname1"}, 
        {{(char )'Y',
       (char )'U', (char )'N', (char )'Y', (char )'Y', (char )'y', (char )'m', (char )'o',
       (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname2"}, 
        {{(char )'Y', (char )'U', (char )'N', (char )'Y', (char )'N', (char )'x', (char )'m',
       (char )'o', (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname3"}, 
        {{(char )'N',
       (char )'D', (char )'N', (char )'Y', (char )'Y', (char )'z', (char )'m', (char )'o',
       (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname4"}, 
        {{(char )'N', (char )'D', (char )'N', (char )'Y', (char )'Y', (char )'y', (char )'m',
       (char )'o', (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname5"}, 
        {{(char )'Y',
       (char )'D', (char )'N', (char )'Y', (char )'N', (char )'x', (char )'m', (char )'o',
       (char )'d', (char )'e', (char )'m', (char )'\000'}, 0, "pname6"}, 
        {{(char )'Y', (char )'U', (char )'Y', (char )'N', (char )'N', (char )'k', (char )'e',
       (char )'r', (char )'m', (char )'i', (char )'t', (char )'\000'}, 0, "pname7"}, 
        {{(char )'N',
       (char )'D', (char )'Y', (char )'N', (char )'N', (char )'k', (char )'e', (char )'r',
       (char )'m', (char )'i', (char )'t', (char )'\000'}, 0, "pname8"}, 
        {{(char )'Y', (char )'U', (char )'N', (char )'Y', (char )'N', (char )'a', (char )'s',
       (char )'c', (char )'i', (char )'i', (char )'\000'}, 0, "pname9"}, 
        {{(char )'\000'}, 0, "pname10"}, 
        {{(char )'\000'}, 0, "pname11"}, 
        {{(char )'\000'}, 0, "pname12"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'s', (char )'z', (char )' ', (char )'-', (char )'v',
       (char )'v', (char )' ', (char )'-', (char )'b', (char )'\000'}, 0, "pprog1"}, 
        {{(char )'/',
       (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i', (char )'n',
       (char )'/', (char )'s', (char )'b', (char )' ', (char )'-', (char )'v', (char )'v',
       (char )'\000'}, 0, "pprog2"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'s', (char )'x', (char )' ', (char )'-', (char )'v',
       (char )'v', (char )'\000'}, 0, "pprog3"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'r', (char )'z', (char )' ', (char )'-', (char )'v',
       (char )'v', (char )' ', (char )'-', (char )'b', (char )' ', (char )'-', (char )'E',
       (char )'\000'}, 0, "pprog4"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'r', (char )'b', (char )' ', (char )'-', (char )'v',
       (char )'v', (char )'\000'}, 0, "pprog5"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'r', (char )'x', (char )' ', (char )'-', (char )'v',
       (char )'v', (char )'\000'}, 0, "pprog6"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'k', (char )'e', (char )'r', (char )'m', (char )'i',
       (char )'t', (char )' ', (char )'-', (char )'i', (char )' ', (char )'-', (char )'l',
       (char )' ', (char )'%', (char )'l', (char )' ', (char )'-', (char )'b', (char )' ',
       (char )'%', (char )'b', (char )' ', (char )'-', (char )'s', (char )'\000'},
      0, "pprog7"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'k', (char )'e', (char )'r', (char )'m', (char )'i',
       (char )'t', (char )' ', (char )'-', (char )'i', (char )' ', (char )'-', (char )'l',
       (char )' ', (char )'%', (char )'l', (char )' ', (char )'-', (char )'b', (char )' ',
       (char )'%', (char )'b', (char )' ', (char )'-', (char )'r', (char )'\000'},
      0, "pprog8"}, 
        {{(char )'/', (char )'u', (char )'s', (char )'r', (char )'/', (char )'b', (char )'i',
       (char )'n', (char )'/', (char )'a', (char )'s', (char )'c', (char )'i', (char )'i',
       (char )'-', (char )'x', (char )'f', (char )'r', (char )' ', (char )'-', (char )'d',
       (char )'s', (char )'v', (char )'\000'}, 0, "pprog9"}, 
        {{(char )'\000'}, 0, "pprog10"}, 
        {{(char )'\000'}, 0, "pprog11"}, 
        {{(char )'\000'}, 0, "pprog12"}, 
        {{(char )'/', (char )'d', (char )'e', (char )'v', (char )'/', (char )'t', (char )'t',
       (char )'y', (char )'S', (char )'1', (char )'\000'}, 0, "port"}, 
        {{(char )'\000'}, 0, "callin"}, 
        {{(char )'\000'}, 0, "callout"}, 
        {{(char )'/', (char )'v', (char )'a', (char )'r', (char )'/', (char )'l', (char )'o',
       (char )'c', (char )'k', (char )'\000'}, 0, "lock"}, 
        {{(char )'1', (char )'1', (char )'5', (char )'2', (char )'0', (char )'0', (char )'\000'},
      0, "baudrate"}, 
        {{(char )'8', (char )'\000'}, 0, "bits"}, 
        {{(char )'N', (char )'\000'}, 0, "parity"}, 
        {{(char )'1', (char )'\000'}, 0, "stopbits"}, 
        {{(char )'\000'}, 0, "kermit"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "kermallow"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "kermreal"}, 
        {{(char )'3', (char )'\000'}, 0, "colusage"}, 
        {{(char )'r', (char )'u', (char )'n', (char )'s', (char )'c', (char )'r', (char )'i',
       (char )'p', (char )'t', (char )'\000'}, 0, "scriptprog"}, 
        {{(char )'\000'}, 0, "minit"}, 
        {{(char )'\000'}, 0, "mreset"}, 
        {{(char )'A', (char )'T', (char )'D', (char )'T', (char )'\000'}, 0, "mdialpre"}, 
        {{(char )'^',
       (char )'M', (char )'\000'}, 0, "mdialsuf"}, 
        {{(char )'A', (char )'T', (char )'D', (char )'P', (char )'\000'}, 0, "mdialpre2"}, 
        {{(char )'^',
       (char )'M', (char )'\000'}, 0, "mdialsuf2"}, 
        {{(char )'A', (char )'T', (char )'X', (char )'1', (char )'D', (char )'T', (char )'\000'},
      0, "mdialpre3"}, 
        {{(char )';', (char )'X', (char )'4', (char )'D', (char )'^', (char )'M', (char )'\000'},
      0, "mdialsuf3"}, 
        {{(char )'C', (char )'O', (char )'N', (char )'N', (char )'E', (char )'C', (char )'T',
       (char )'\000'}, 0, "mconnect"}, 
        {{(char )'N', (char )'O', (char )' ', (char )'C', (char )'A', (char )'R', (char )'R',
       (char )'I', (char )'E', (char )'R', (char )'\000'}, 0, "mnocon1"}, 
        {{(char )'B', (char )'U', (char )'S', (char )'Y', (char )'\000'}, 0, "mnocon2"}, 
        {{(char )'N',
       (char )'O', (char )' ', (char )'D', (char )'I', (char )'A', (char )'L', (char )'T',
       (char )'O', (char )'N', (char )'E', (char )'\000'}, 0, "mnocon3"}, 
        {{(char )'V', (char )'O', (char )'I', (char )'C', (char )'E', (char )'\000'},
      0, "mnocon4"}, 
        {{(char )'~', (char )'~', (char )'+', (char )'+', (char )'+', (char )'~', (char )'~',
       (char )'A', (char )'T', (char )'H', (char )'^', (char )'M', (char )'\000'},
      0, "mhangup"}, 
        {{(char )'^', (char )'M', (char )'\000'}, 0, "mdialcan"}, 
        {{(char )'4', (char )'5', (char )'\000'}, 0, "mdialtime"}, 
        {{(char )'2', (char )'\000'}, 0, "mrdelay"}, 
        {{(char )'1', (char )'0', (char )'\000'}, 0, "mretries"}, 
        {{(char )'1', (char )'\000'}, 0, "mdropdtr"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "mautobaud"}, 
        {{(char )'d', (char )'\000'}, 0, "showspeed"}, 
        {{(char )'\000'}, 0, "updir"}, 
        {{(char )'\000'}, 0, "downdir"}, 
        {{(char )'\000'}, 0, "scriptdir"}, 
        {{(char )'^', (char )'A', (char )'\000'}, 0, "escape-key"}, 
        {{(char )'B', (char )'S', (char )'\000'}, 0, "backspace"}, 
        {{(char )'e', (char )'n', (char )'a', (char )'b', (char )'l', (char )'e', (char )'d',
       (char )'\000'}, 0, "statusline"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "hasdcd"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "rtscts"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "xonxoff"}, 
        {{(char )'D', (char )'\000'}, 0, "zauto"}, 
        {{(char )'Y', (char )'E', (char )'L', (char )'L', (char )'O', (char )'W', (char )'\000'},
      0, "mfcolor"}, 
        {{(char )'B', (char )'L', (char )'U', (char )'E', (char )'\000'}, 0, "mbcolor"}, 
        {{(char )'W',
       (char )'H', (char )'I', (char )'T', (char )'E', (char )'\000'}, 0, "tfcolor"}, 
        {{(char )'B',
       (char )'L', (char )'A', (char )'C', (char )'K', (char )'\000'}, 0, "tbcolor"}, 
        {{(char )'W',
       (char )'H', (char )'I', (char )'T', (char )'E', (char )'\000'}, 0, "sfcolor"}, 
        {{(char )'R',
       (char )'E', (char )'D', (char )'\000'}, 0, "sbcolor"}, 
        {{(char )'.', (char )'m', (char )'a', (char )'c', (char )'r', (char )'o', (char )'s',
       (char )'\000'}, 0, "macros"}, 
        {{(char )'\000'}, 0, "changed"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "macenab"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "sound"}, 
        {{(char )'2', (char )'0', (char )'0', (char )'0', (char )'\000'}, 0, "histlines"}, 
        {{(char )'\000'},
      0, "convf"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "convcap"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "fselw"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "askdndir"}, 
        {{(char )'m', (char )'i', (char )'n', (char )'i', (char )'c', (char )'o', (char )'m',
       (char )'.', (char )'l', (char )'o', (char )'g', (char )'\000'}, 0, "logfname"}, 
        {{(char )'Y',
       (char )'e', (char )'s', (char )'\000'}, 0, "logconn"}, 
        {{(char )'Y', (char )'e', (char )'s', (char )'\000'}, 0, "logxfer"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "multiline"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "localecho"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "addlinefeed"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "linewrap"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "displayhex"}, 
        {{(char )'N', (char )'o', (char )'\000'}, 0, "addcarreturn"}, 
        {{(char )'M', (char )'i', (char )'n', (char )'i', (char )'c', (char )'o', (char )'m',
       (char )'2', (char )'.', (char )'7', (char )'\000'}, 0, "answerback"}, 
        {{(char )'\000'}, 0, (char const   *)((void *)0)}};
#line 208 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
int writemacs(FILE *fp ) 
{ 
  struct macs *m ;

  {
#line 212
  m = mmacs;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! m->desc) {
#line 212
      goto while_break;
    }
#line 213
    if (m->flags & 3) {
      {
#line 214
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pu %-16.16s %s\n",
              m->desc, m->value);
      }
    }
#line 212
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 221 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
int writepars(FILE *fp , int all ) 
{ 
  struct pars *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 225
  if (all) {
    {
#line 226
    tmp = gettext("# Machine-generated file - use \"minicom -s\" to change parameters.\n");
#line 226
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp);
    }
  } else {
    {
#line 228
    tmp___0 = gettext("# Machine-generated file - use setup menu in minicom to change parameters.\n");
#line 228
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___0);
    }
  }
#line 230
  p = mpars;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! p->desc) {
#line 230
      goto while_break;
    }
#line 231
    if (p->flags & 3) {
      {
#line 232
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"pu %-16.16s %s\n",
              p->desc, p->value);
      }
    }
#line 230
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 239 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
int readpars(FILE *fp , enum config_type conftype ) 
{ 
  struct pars *p ;
  int line_size ;
  char *line ;
  char *s___0 ;
  int dosleep___0 ;
  int lineno ;
  int matched ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  unsigned short const   **tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  unsigned short const   **tmp___15 ;
  size_t tmp___16 ;
  unsigned short const   **tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;

  {
#line 242
  line_size = 100;
#line 244
  dosleep___0 = 0;
#line 245
  lineno = 0;
#line 248
  if ((unsigned int )conftype == 0U) {
    {
#line 249
    strcpy((char */* __restrict  */)(mpars[36].value), (char const   */* __restrict  */)"runscript");
    }
  }
  {
#line 251
  tmp = malloc((size_t )line_size);
#line 251
  line = (char *)tmp;
  }
#line 252
  if (! line) {
    {
#line 253
    tmp___0 = gettext("Memory allocation failed.\n");
#line 253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
    }
#line 254
    return (1);
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 257
    tmp___25 = fgets((char */* __restrict  */)line, line_size - 1, (FILE */* __restrict  */)fp);
    }
#line 257
    if (! tmp___25) {
#line 257
      goto while_break;
    }
    {
#line 260
    tmp___3 = strlen((char const   *)line);
    }
#line 260
    if ((int )*(line + (tmp___3 - 1UL)) != 10) {
      {
#line 262
      tmp___1 = strlen((char const   *)line);
#line 262
      fseek(fp, (long )(- tmp___1), 1);
#line 264
      line_size += 100;
#line 265
      tmp___2 = realloc((void *)line, (size_t )line_size);
#line 265
      line = (char *)tmp___2;
      }
#line 266
      goto while_continue;
    }
#line 269
    lineno ++;
#line 271
    s___0 = line;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 272
      tmp___4 = __ctype_b_loc();
      }
#line 272
      if (! ((int const   )*(*tmp___4 + (int )*s___0) & 8192)) {
#line 272
        goto while_break___0;
      }
#line 273
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    if (! *s___0) {
#line 276
      goto while_continue;
    } else
#line 275
    if ((int )*s___0 == 35) {
#line 276
      goto while_continue;
    }
    {
#line 279
    tmp___5 = strlen((char const   *)s___0);
    }
#line 279
    if (tmp___5 >= 3UL) {
      {
#line 279
      tmp___6 = strncmp((char const   *)s___0, "pr", (size_t )2);
      }
#line 279
      if (tmp___6 == 0) {
#line 279
        goto _L;
      } else {
        {
#line 279
        tmp___7 = strncmp((char const   *)s___0, "pu", (size_t )2);
        }
#line 279
        if (tmp___7 == 0) {
          _L: /* CIL Label */ 
#line 279
          if ((int )*(s___0 + 2) == 32) {
#line 283
            s___0 += 3;
          } else
#line 279
          if ((int )*(s___0 + 2) == 9) {
#line 283
            s___0 += 3;
          }
        }
      }
    }
#line 285
    matched = 0;
#line 286
    p = mpars;
    {
#line 286
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 286
      if (! p->desc) {
#line 286
        goto while_break___1;
      }
      {
#line 289
      tmp___8 = strlen(p->desc);
#line 289
      tmp___9 = strncmp(p->desc, (char const   *)s___0, tmp___8);
      }
#line 289
      if (tmp___9) {
#line 290
        goto __Cont;
      }
      {
#line 293
      tmp___10 = strlen((char const   *)s___0);
#line 293
      tmp___11 = strlen(p->desc);
      }
#line 293
      if (tmp___10 > tmp___11) {
        {
#line 293
        tmp___12 = __ctype_b_loc();
#line 293
        tmp___13 = strlen(p->desc);
        }
#line 293
        if (! ((int const   )*(*tmp___12 + (int )*(s___0 + tmp___13)) & 8192)) {
#line 295
          goto __Cont;
        }
      }
      {
#line 297
      matched = 1;
#line 300
      tmp___14 = strlen(p->desc);
#line 300
      s___0 += tmp___14;
      }
      {
#line 301
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 301
        tmp___15 = __ctype_b_loc();
        }
#line 301
        if (! ((int const   )*(*tmp___15 + (int )*s___0) & 8192)) {
#line 301
          goto while_break___2;
        }
#line 302
        s___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 305
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 305
        tmp___17 = __ctype_b_loc();
#line 305
        tmp___18 = strlen((char const   *)s___0);
        }
#line 305
        if (! ((int const   )*(*tmp___17 + (int )*(s___0 + (tmp___18 - 1UL))) & 8192)) {
#line 305
          goto while_break___3;
        }
        {
#line 306
        tmp___16 = strlen((char const   *)s___0);
#line 306
        *(s___0 + (tmp___16 - 1UL)) = (char)0;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 309
      tmp___20 = strcmp((char const   *)(p->value), (char const   *)s___0);
      }
#line 309
      if (tmp___20 == 0) {
#line 310
        p->flags &= -4;
      } else {
#line 312
        if ((unsigned int )conftype == 0U) {
#line 312
          tmp___19 = 1;
        } else {
#line 312
          tmp___19 = 2;
        }
        {
#line 312
        p->flags |= tmp___19;
#line 313
        strncpy((char */* __restrict  */)(p->value), (char const   */* __restrict  */)s___0,
                sizeof(p->value) - 1UL);
#line 314
        p->value[sizeof(p->value) - 1UL] = (char)0;
        }
      }
#line 318
      goto while_break___1;
      __Cont: /* CIL Label */ 
#line 286
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 320
    if (! matched) {
#line 321
      if ((unsigned int )conftype == 0U) {
        {
#line 321
        tmp___21 = gettext("global");
#line 321
        tmp___23 = tmp___21;
        }
      } else {
        {
#line 321
        tmp___22 = gettext("personal");
#line 321
        tmp___23 = tmp___22;
        }
      }
      {
#line 321
      tmp___24 = gettext("** Line %d of the %s config file is unparsable.\n");
#line 321
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24,
              lineno, tmp___23);
#line 324
      dosleep___0 = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 328
  free((void *)line);
  }
#line 330
  if (dosleep___0) {
    {
#line 331
    sleep(3U);
    }
  }
#line 333
  return (0);
}
}
#line 339 "/home/wheatley/newnew/temp/minicom-2.7/src/rwconf.c"
int readmacs(FILE *fp , int init___3 ) 
{ 
  struct macs *m ;
  char line[257] ;
  int public ;
  int max_macs ;
  char *s___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 343
  max_macs = 11;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 346
    tmp___3 = fgets((char */* __restrict  */)(line), 257, (FILE */* __restrict  */)fp);
    }
#line 346
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 346
      tmp___4 = max_macs;
#line 346
      max_macs --;
#line 346
      if (! tmp___4) {
#line 346
        goto while_break;
      }
    } else {
#line 346
      goto while_break;
    }
    {
#line 347
    s___0 = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)"\n\t ");
#line 349
    public = 0;
#line 350
    tmp = strcmp((char const   *)s___0, "pr");
    }
#line 350
    if (tmp == 0) {
      {
#line 351
      public = 0;
#line 352
      s___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n\t ");
      }
    }
    {
#line 354
    tmp___0 = strcmp((char const   *)(line), "pu");
    }
#line 354
    if (tmp___0 == 0) {
      {
#line 355
      public = 1;
#line 356
      s___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n\t ");
      }
    }
#line 359
    if (! init___3) {
#line 359
      if (public == 0) {
#line 360
        goto while_continue;
      }
    }
#line 362
    m = mmacs;
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 362
      if (! ((unsigned long )m->desc != (unsigned long )((void *)0))) {
#line 362
        goto while_break___0;
      }
      {
#line 363
      tmp___2 = strcmp(m->desc, (char const   *)s___0);
      }
#line 363
      if (tmp___2 == 0) {
        {
#line 365
        s___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\n");
        }
#line 365
        if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 366
          s___0 = (char *)"";
        }
        {
#line 367
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 367
          if (*s___0) {
#line 367
            if (! ((int )*s___0 == 9)) {
#line 367
              if (! ((int )*s___0 == 32)) {
#line 367
                goto while_break___1;
              }
            }
          } else {
#line 367
            goto while_break___1;
          }
#line 368
          s___0 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 371
        tmp___1 = strcmp((char const   *)(m->value), (char const   *)s___0);
        }
#line 371
        if (tmp___1 == 0) {
#line 372
          m->flags = 0;
        } else {
#line 374
          if (init___3) {
#line 375
            m->flags |= 1;
          } else {
#line 377
            m->flags |= 2;
          }
          {
#line 378
          strcpy((char */* __restrict  */)(m->value), (char const   */* __restrict  */)s___0);
          }
        }
#line 380
        goto while_break___0;
      }
#line 362
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 163 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
void mc_wcurbar(WIN *w , int y , int attr ) ;
#line 70 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
WIN *us ;
#line 73
short terminal ;
#line 74
time_t online ;
#line 75
long linespd ;
#line 97
int bogus_dcd ;
#line 110
char *dial_name ;
#line 111
char *dial_number ;
#line 112 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *dial_user  ;
#line 113 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *dial_pass  ;
#line 167
void get_bbp(char *ba , char *bi , char *pa , char *stopb , int curr_ok ) ;
#line 168
int update_bbp_from_char(char c___0 , char *ba , char *bi , char *pa , char *stopb ,
                         int curr_ok ) ;
#line 170
char const   *yesno(int k ) ;
#line 175
int loadconv(char *buf___6 ) ;
#line 188
void music(void) ;
#line 190
void mputs(char const   *s___0 , int how ) ;
#line 191
void modeminit(void) ;
#line 192
void modemreset(void) ;
#line 193
void hangup(void) ;
#line 194
void sendbreak(void) ;
#line 195
long dial(struct dialent *d , struct dialent **d2 ) ;
#line 196
int readdialdir(void) ;
#line 197
void dialone(char *entry ) ;
#line 198
void dialdir(void) ;
#line 221
time_t old_online ;
#line 227
void init_emul(int type , int do_init ) ;
#line 228
void timer_update(void) ;
#line 229
void show_status(void) ;
#line 236
void port_init(void) ;
#line 237
void toggle_addlf(void) ;
#line 238
void toggle_local_echo(void) ;
#line 259
void m_dtrtoggle(int fd , int sec ) ;
#line 260
void m_break(int fd ) ;
#line 261
int m_getdcd(int fd ) ;
#line 283
void runscript(int ask___0 , char const   *s___0 , char const   *l , char const   *p ) ;
#line 138 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void writedialdir(void) ;
#line 142 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static struct dialent *dialents  ;
#line 143 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static struct dialent *d_man  ;
#line 144 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int nrents___0  =    1;
#line 145 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int newtype  ;
#line 147 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int dendd  =    0;
#line 148 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char *tagged  ;
#line 157 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
char const   *change_baud(char const   *s___0 ) 
{ 
  int tmp ;

  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (s___0) {
#line 159
      if (*s___0) {
        {
#line 159
        tmp = update_bbp_from_char((char )*s___0, mpars[28].value, mpars[29].value,
                                   mpars[30].value, mpars[31].value, 0);
        }
#line 159
        if (! tmp) {
#line 159
          goto while_break;
        }
      } else {
#line 159
        goto while_break;
      }
    } else {
#line 159
      goto while_break;
    }
#line 161
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if ((int )portfd >= 0) {
    {
#line 165
    port_init();
    }
  }
  {
#line 166
  show_status();
  }
#line 168
  return (s___0);
}
}
#line 180 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void mputs(char const   *s___0 , int how ) 
{ 
  char c___0 ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! *s___0) {
#line 184
      goto while_break;
    }
#line 185
    if ((int const   )*s___0 == 94) {
#line 185
      if (*(s___0 + 1)) {
#line 186
        s___0 ++;
#line 187
        if ((int const   )*s___0 == 94) {
#line 188
          c___0 = (char )*s___0;
        } else
#line 189
        if (how == 1) {
#line 189
          if ((int const   )*s___0 == 126) {
            {
#line 190
            sleep(1U);
#line 191
            s___0 ++;
            }
#line 192
            goto while_continue;
          } else {
#line 194
            c___0 = (char )((int const   )*s___0 & 31);
          }
        } else {
#line 194
          c___0 = (char )((int const   )*s___0 & 31);
        }
      } else {
#line 185
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 195
    if ((int const   )*s___0 == 92) {
#line 195
      if (*(s___0 + 1)) {
        {
#line 196
        s___0 ++;
#line 197
        tmp = toupper((int )*s___0);
        }
        {
#line 198
        if (tmp == 92) {
#line 198
          goto case_92;
        }
#line 201
        if (tmp == 85) {
#line 201
          goto case_85;
        }
#line 206
        if (tmp == 80) {
#line 206
          goto case_80;
        }
#line 211
        if (tmp == 66) {
#line 211
          goto case_66;
        }
#line 214
        if (tmp == 76) {
#line 214
          goto case_76;
        }
#line 218
        if (tmp == 69) {
#line 218
          goto case_69;
        }
#line 222
        if (tmp == 71) {
#line 222
          goto case_71;
        }
#line 225
        goto switch_default;
        case_92: /* CIL Label */ 
#line 199
        c___0 = (char )*s___0;
#line 200
        goto switch_break;
        case_85: /* CIL Label */ 
#line 202
        if (dial_user) {
#line 202
          if (*dial_user) {
            {
#line 203
            mputs((char const   *)dial_user, how);
            }
          }
        }
#line 204
        s___0 ++;
#line 205
        goto while_continue;
        case_80: /* CIL Label */ 
#line 207
        if (dial_pass) {
#line 207
          if (*dial_pass) {
            {
#line 208
            mputs((char const   *)dial_pass, how);
            }
          }
        }
#line 209
        s___0 ++;
#line 210
        goto while_continue;
        case_66: /* CIL Label */ 
        {
#line 212
        s___0 ++;
#line 212
        s___0 = change_baud(s___0);
        }
#line 213
        goto while_continue;
        case_76: /* CIL Label */ 
        {
#line 215
        toggle_addlf();
#line 216
        s___0 ++;
        }
#line 217
        goto while_continue;
        case_69: /* CIL Label */ 
        {
#line 219
        toggle_local_echo();
#line 220
        s___0 ++;
        }
#line 221
        goto while_continue;
        case_71: /* CIL Label */ 
        {
#line 223
        runscript(0, s___0 + 1, "", "");
        }
#line 224
        return;
        switch_default: /* CIL Label */ 
#line 226
        s___0 ++;
#line 227
        goto while_continue;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 230
        c___0 = (char )*s___0;
      }
    } else {
#line 230
      c___0 = (char )*s___0;
    }
#line 231
    if (how == 0) {
#line 231
      if ((int )c___0 == 126) {
        {
#line 232
        sleep(1U);
        }
      } else {
#line 231
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 234
      tmp___0 = write((int )portfd, (void const   *)(& c___0), (size_t )1);
      }
#line 234
      if (tmp___0 != 1L) {
#line 235
        goto while_break;
      }
    }
#line 236
    s___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 243 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void modeminit(void) 
{ 
  WIN *w ;
  char *tmp ;

  {
#line 247
  if ((int )mpars[37].value[0] == 0) {
#line 248
    return;
  }
  {
#line 250
  tmp = gettext("Initializing Modem");
#line 250
  w = mc_tell((char const   *)tmp);
#line 251
  m_dtrtoggle((int )portfd, 1);
#line 252
  mputs((char const   *)(mpars[37].value), 0);
#line 253
  mc_wclose(w, 1);
  }
#line 254
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void modemreset(void) 
{ 
  WIN *w ;
  char *tmp ;

  {
#line 263
  if ((int )mpars[38].value[0] == 0) {
#line 264
    return;
  }
  {
#line 266
  tmp = gettext("Resetting Modem");
#line 266
  w = mc_tell((char const   *)tmp);
#line 267
  mputs((char const   *)(mpars[38].value), 0);
#line 268
  sleep(1U);
#line 269
  mc_wclose(w, 1);
  }
#line 270
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void hangup(void) 
{ 
  WIN *w ;
  int sec ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 278
  sec = 1;
#line 280
  tmp = gettext("Hanging up");
#line 280
  w = mc_tell((char const   *)tmp);
#line 282
  timer_update();
  }
#line 283
  if ((int )mpars[84].value[0] == 89) {
#line 284
    if (online > 0L) {
#line 284
      tmp___0 = online % 60L;
    } else {
#line 284
      tmp___0 = 0L;
    }
    {
#line 284
    tmp___1 = gettext("Hangup (%ld:%02ld:%02ld)");
#line 284
    do_log((char const   *)tmp___1, online / 3600L, (online / 60L) % 60L, tmp___0);
    }
  }
  {
#line 286
  online = (time_t )-1;
#line 287
  old_online = (time_t )-1;
#line 289
  tmp___2 = __ctype_b_loc();
  }
#line 289
  if ((int const   )*(*tmp___2 + (int )mpars[55].value[0]) & 2048) {
    {
#line 290
    sscanf((char const   */* __restrict  */)(mpars[55].value), (char const   */* __restrict  */)"%2d",
           & sec);
    }
  }
#line 292
  if ((int )mpars[55].value[0] == 89) {
    {
#line 293
    m_dtrtoggle((int )portfd, sec);
    }
  } else {
    {
#line 292
    tmp___3 = __ctype_b_loc();
    }
#line 292
    if ((int const   )*(*tmp___3 + (int )mpars[55].value[0]) & 2048) {
#line 292
      if (sec > 0) {
        {
#line 293
        m_dtrtoggle((int )portfd, sec);
        }
      } else {
        {
#line 295
        mputs((char const   *)(mpars[50].value), 0);
#line 296
        sleep(1U);
        }
      }
    } else {
      {
#line 295
      mputs((char const   *)(mpars[50].value), 0);
#line 296
      sleep(1U);
      }
    }
  }
  {
#line 303
  bogus_dcd = 0;
#line 304
  mc_wclose(w, 1);
#line 305
  show_status();
  }
#line 306
  return;
}
}
#line 312 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void sendbreak(void) 
{ 
  WIN *w ;
  char *tmp ;

  {
  {
#line 316
  tmp = gettext("Sending BREAK");
#line 316
  w = mc_tell((char const   *)tmp);
#line 317
  mc_wcursor(w, 0);
#line 319
  m_break((int )portfd);
#line 320
  mc_wclose(w, 1);
  }
#line 321
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
WIN *dialwin  ;
#line 324 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
int dialtime  ;
#line 331 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void music(void) 
{ 
  int x ;
  int i ;
  int k ;
  int consolefd ;
  char *disp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 334
  consolefd = 0;
#line 338
  tmp = getenv("TERM");
#line 338
  tmp___0 = strncmp((char const   *)tmp, "xterm", (size_t )5);
  }
#line 338
  if (tmp___0 == 0) {
    {
#line 338
    disp = getenv("DISPLAY");
    }
#line 338
    if ((unsigned long )disp != (unsigned long )((void *)0)) {
      {
#line 338
      tmp___1 = strcmp((char const   *)disp, ":0.0");
      }
#line 338
      if (tmp___1 == 0) {
#line 338
        goto _L;
      } else {
        {
#line 338
        tmp___2 = strcmp((char const   *)disp, ":0");
        }
#line 338
        if (tmp___2 == 0) {
          _L: /* CIL Label */ 
          {
#line 342
          consolefd = open("/dev/console", 1);
          }
#line 343
          if (consolefd < 0) {
#line 343
            consolefd = 0;
          }
        }
      }
    }
  }
  {
#line 347
  keyboard(10, 0);
#line 350
  i = 0;
  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (i < 9)) {
#line 350
      goto while_break;
    }
    {
#line 351
    k = 2000 - 200 * (i % 3);
#line 352
    ioctl(consolefd, 19247UL, k);
#line 355
    x = check_io(-1, 0, 160, (char *)((void *)0), 0, (int *)((void *)0));
    }
#line 356
    if (x & 2) {
#line 357
      goto while_break;
    }
#line 350
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 359
  ioctl(consolefd, 19247UL, 0);
  }
#line 360
  if (consolefd) {
    {
#line 361
    close(consolefd);
    }
  }
  {
#line 364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 364
    if (! ((x & 2) == 0)) {
#line 364
      goto while_break___0;
    }
    {
#line 365
    x = check_io(-1, 0, 10000, (char *)((void *)0), 0, (int *)((void *)0));
#line 366
    timer_update();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 368
  keyboard(13, 0);
  }
#line 369
  return;
}
}
#line 376 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int dialfailed(char *s___0 , int rtime ) 
{ 
  int f ;
  int x ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 379
  ret = 0;
#line 381
  mc_wlocate(dialwin, 1, 5);
#line 382
  tmp = gettext("    No connection: %s.      \n");
#line 382
  mc_wprintf(dialwin, (char const   *)tmp, s___0);
  }
#line 383
  if (rtime < 0) {
    {
#line 384
    tmp___0 = gettext("   Press any key to continue..    ");
#line 384
    mc_wprintf(dialwin, (char const   *)tmp___0);
#line 385
    tmp___1 = check_io(-1, 0, 10000, (char *)((void *)0), 0, (int *)((void *)0));
    }
#line 385
    if (tmp___1 & 2) {
      {
#line 386
      keyboard(13, 0);
      }
    }
#line 387
    return (0);
  }
  {
#line 389
  tmp___2 = gettext("     Retry in %2d seconds             ");
#line 389
  mc_wprintf(dialwin, (char const   *)tmp___2, rtime);
#line 391
  f = rtime - 1;
  }
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (f >= 0)) {
#line 391
      goto while_break;
    }
    {
#line 392
    x = check_io(-1, 0, 1000, (char *)((void *)0), 0, (int *)((void *)0));
    }
#line 393
    if (x & 2) {
      {
#line 395
      x = keyboard(13, 0);
      }
#line 396
      if (x != 32) {
#line 397
        ret = -1;
      }
#line 398
      goto while_break;
    }
    {
#line 400
    mc_wlocate(dialwin, 0, 6);
#line 401
    tmp___3 = gettext("     Retry in %2d seconds             ");
#line 401
    mc_wprintf(dialwin, (char const   *)tmp___3, f);
#line 391
    f --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  if (f < 0) {
    {
#line 406
    usleep((__useconds_t )350000);
    }
  }
  {
#line 411
  mc_wlocate(dialwin, 1, 5);
#line 412
  mc_wprintf(dialwin, "                                       \n");
#line 413
  mc_wprintf(dialwin, "                                             ");
  }
#line 414
  return (ret);
}
}
#line 420 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
long dial(struct dialent *d , struct dialent **d2 ) 
{ 
  char *s___0 ;
  char *t ;
  int f ;
  int x ;
  int modidx ;
  int retries ;
  int maxretries ;
  int rdelay ;
  long nb ;
  long retst ;
  char *reason ;
  char *tmp ;
  time_t now ;
  time_t last___0 ;
  struct tm *ptime ;
  char buf___6[128] ;
  char modbuf[128] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  struct dialent *d3 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___21 ;

  {
  {
#line 422
  s___0 = (char *)0;
#line 422
  t = (char *)0;
#line 423
  x = 0;
#line 424
  retries = 0;
#line 425
  maxretries = 1;
#line 425
  rdelay = 45;
#line 426
  retst = -1L;
#line 427
  tmp = gettext("Max retries");
#line 427
  reason = tmp;
#line 434
  timer_update();
  }
#line 436
  if ((int )mpars[64].value[0] == 89) {
#line 436
    if (online >= 0L) {
      {
#line 437
      tmp___0 = gettext("You are already online! Hang up first.");
#line 437
      werror((char const   *)tmp___0);
      }
#line 438
      return (retst);
    }
  }
  {
#line 441
  dialwin = mc_wopen(18, 9, 62, 16, 1, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 442
  tmp___1 = gettext("Autodial");
#line 442
  mc_wtitle(dialwin, 1, (char const   *)tmp___1);
#line 443
  mc_wcursor(dialwin, 0);
#line 445
  mc_wputs(dialwin, "\n");
#line 446
  tmp___2 = gettext("Dialing");
#line 446
  mc_wprintf(dialwin, " %s : %s\n", tmp___2, d->name);
#line 447
  tmp___3 = gettext("      At : %s");
#line 447
  mc_wprintf(dialwin, (char const   *)tmp___3, d->number);
#line 448
  mc_wprintf(dialwin, "\n");
  }
#line 449
  if (d->lastdate[0]) {
#line 449
    if (d->lasttime[0]) {
      {
#line 450
      tmp___4 = gettext(" Last on : %s at %s");
#line 450
      mc_wprintf(dialwin, (char const   *)tmp___4, d->lastdate, d->lasttime);
      }
    }
  }
  {
#line 451
  mc_wprintf(dialwin, "\n");
#line 452
  mc_wredraw(dialwin, 1);
#line 455
  keyboard(10, 0);
#line 457
  maxretries = atoi((char const   *)(mpars[54].value));
  }
#line 458
  if (maxretries <= 0) {
#line 459
    maxretries = 1;
  }
  {
#line 460
  rdelay = atoi((char const   *)(mpars[53].value));
  }
#line 461
  if (rdelay < 0) {
#line 462
    rdelay = 0;
  }
  MainLoop: 
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    retries ++;
#line 466
    if (! (retries <= maxretries)) {
#line 466
      goto while_break;
    }
#line 469
    if (retries > 1) {
#line 469
      if ((int )d->flags & 128) {
        {
#line 470
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 471
          d = d->next;
#line 472
          if ((unsigned long )d == (unsigned long )((struct dialent *)((void *)0))) {
#line 473
            d = dialents;
          }
#line 470
          if (! (! ((int )d->flags & 128))) {
#line 470
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 475
        mc_wlocate(dialwin, 0, 1);
#line 476
        tmp___5 = gettext("Dialing");
#line 476
        mc_wprintf(dialwin, " %s : %s", tmp___5, d->name);
#line 477
        mc_wclreol(dialwin);
#line 478
        mc_wprintf(dialwin, "\n");
#line 479
        tmp___6 = gettext("      At : %s");
#line 479
        mc_wprintf(dialwin, (char const   *)tmp___6, d->number);
#line 480
        mc_wclreol(dialwin);
        }
#line 481
        if (d->lastdate[0]) {
#line 481
          if (d->lasttime[0]) {
            {
#line 482
            mc_wprintf(dialwin, "\n");
#line 483
            tmp___7 = gettext(" Last on : %s at %s");
#line 483
            mc_wprintf(dialwin, (char const   *)tmp___7, d->lastdate, d->lasttime);
#line 485
            mc_wclreol(dialwin);
            }
          }
        }
      }
    }
    {
#line 490
    dialtime = atoi((char const   *)(mpars[52].value));
    }
#line 491
    if (dialtime == 0) {
#line 492
      dialtime = 45;
    }
    {
#line 493
    time(& now);
#line 494
    last___0 = now;
#line 497
    mc_wlocate(dialwin, 0, 4);
#line 498
    tmp___8 = gettext("    Time : %-3d");
#line 498
    mc_wprintf(dialwin, (char const   *)tmp___8, dialtime);
    }
#line 499
    if (maxretries > 1) {
      {
#line 500
      tmp___9 = gettext("     Attempt #%d");
#line 500
      mc_wprintf(dialwin, (char const   *)tmp___9, retries);
      }
    }
    {
#line 501
    tmp___10 = gettext("\n\n\n Escape to cancel, space to retry.");
#line 501
    mc_wputs(dialwin, (char const   *)tmp___10);
#line 504
    m_flush((int )portfd);
    }
    {
#line 506
    if ((int )d->dialtype == 0) {
#line 506
      goto case_0;
    }
#line 511
    if ((int )d->dialtype == 1) {
#line 511
      goto case_1;
    }
#line 516
    if ((int )d->dialtype == 2) {
#line 516
      goto case_2;
    }
#line 505
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 507
    mputs((char const   *)(mpars[39].value), 0);
#line 508
    mputs((char const   *)(d->number), 0);
#line 509
    mputs((char const   *)(mpars[40].value), 0);
    }
#line 510
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 512
    mputs((char const   *)(mpars[41].value), 0);
#line 513
    mputs((char const   *)(d->number), 0);
#line 514
    mputs((char const   *)(mpars[42].value), 0);
    }
#line 515
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 517
    mputs((char const   *)(mpars[43].value), 0);
#line 518
    mputs((char const   *)(d->number), 0);
#line 519
    mputs((char const   *)(mpars[44].value), 0);
    }
#line 520
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 524
    modbuf[0] = (char)0;
#line 525
    modidx = 0;
#line 526
    s___0 = buf___6;
#line 527
    buf___6[0] = (char)0;
    {
#line 528
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 528
      if (! (dialtime > 0)) {
#line 528
        goto while_break___1;
      }
#line 529
      if ((int )*s___0 == 0) {
#line 530
        if (portfd_is_socket) {
#line 530
          if (! portfd_is_connected) {
#line 530
            tmp___11 = -1;
          } else {
#line 530
            tmp___11 = (int )portfd;
          }
        } else {
#line 530
          tmp___11 = (int )portfd;
        }
        {
#line 530
        x = check_io(tmp___11, 0, 1000, buf___6, (int )sizeof(buf___6), (int *)((void *)0));
#line 531
        s___0 = buf___6;
        }
      }
#line 533
      if (x & 2) {
        {
#line 534
        f = keyboard(13, 0);
        }
#line 536
        if (f == 27) {
          {
#line 537
          mputs((char const   *)(mpars[51].value), 0);
          }
        }
#line 540
        if (f == 32) {
          {
#line 541
          mputs((char const   *)(mpars[51].value), 0);
#line 542
          tmp___12 = gettext("Cancelled");
#line 542
          dialfailed(tmp___12, 4);
#line 543
          m_flush((int )portfd);
          }
#line 544
          goto while_break___1;
        }
        {
#line 546
        keyboard(1, 0);
#line 547
        mc_wclose(dialwin, 1);
        }
#line 548
        return (retst);
      }
#line 550
      if (x & 1) {
#line 552
        if ((int )*s___0 == 13) {
#line 554
          modbuf[modidx] = (char)0;
#line 555
          modidx = 0;
        } else
#line 552
        if ((int )*s___0 == 10) {
#line 554
          modbuf[modidx] = (char)0;
#line 555
          modidx = 0;
        } else
#line 556
        if (modidx < 127) {
#line 558
          tmp___13 = modidx;
#line 558
          modidx ++;
#line 558
          modbuf[tmp___13] = *s___0;
#line 559
          modbuf[modidx] = (char)0;
        }
#line 562
        if (*s___0) {
#line 563
          s___0 ++;
        }
#line 565
        if (modidx == 0) {
          {
#line 565
          tmp___18 = strlen((char const   *)(mpars[45].value));
#line 565
          tmp___19 = strncmp((char const   *)(modbuf), (char const   *)(mpars[45].value),
                             tmp___18);
          }
#line 565
          if (! tmp___19) {
            {
#line 567
            timer_update();
#line 568
            retst = 0L;
#line 570
            tmp___14 = strlen((char const   *)(mpars[45].value));
#line 570
            tmp___15 = sscanf((char const   */* __restrict  */)(modbuf + tmp___14),
                              (char const   */* __restrict  */)"%ld", & nb);
            }
#line 570
            if (tmp___15 == 1) {
#line 571
              retst = nb;
            }
            {
#line 572
            linespd = retst;
#line 575
            f = m_getdcd((int )portfd);
#line 576
            bogus_dcd = 1;
            }
#line 579
            if ((int )mpars[84].value[0] == 89) {
              {
#line 580
              do_log("%s %s, %s", modbuf, d->name, d->number);
              }
            }
            {
#line 582
            ptime = localtime((time_t const   *)(& now));
#line 583
            sprintf((char */* __restrict  */)(d->lastdate), (char const   */* __restrict  */)"%4.4d%2.2d%2.2d",
                    ptime->tm_year + 1900, ptime->tm_mon + 1, ptime->tm_mday);
#line 586
            sprintf((char */* __restrict  */)(d->lasttime), (char const   */* __restrict  */)"%02d:%02d",
                    ptime->tm_hour, ptime->tm_min);
#line 588
            (d->count) ++;
            }
#line 590
            if (d->convfile[0]) {
              {
#line 591
              loadconv(d->convfile);
#line 592
              strcpy((char */* __restrict  */)(mpars[79].value), (char const   */* __restrict  */)(d->convfile));
              }
            }
            {
#line 595
            mc_wlocate(dialwin, 1, 7);
            }
#line 596
            if ((int )d->script[0] == 0) {
              {
#line 597
              tmp___16 = gettext("Connected. Press any key to continue");
#line 597
              mc_wputs(dialwin, (char const   *)tmp___16);
              }
#line 600
              if ((int )mpars[77].value[0] == 89) {
                {
#line 601
                music();
                }
              } else {
                {
#line 603
                x = check_io(-1, 0, 0, (char *)((void *)0), 0, (int *)((void *)0));
                }
#line 604
                if ((x & 2) == 2) {
                  {
#line 605
                  keyboard(13, 0);
                  }
                }
              }
              {
#line 613
              x = check_io(-1, 0, 0, (char *)((void *)0), 0, (int *)((void *)0));
              }
#line 614
              if ((x & 2) == 2) {
                {
#line 615
                keyboard(13, 0);
                }
              }
            }
            {
#line 617
            keyboard(1, 0);
#line 618
            mc_wclose(dialwin, 1);
#line 620
            mc_wprintf(us, "\r\n%s\r\n", modbuf);
#line 621
            dialwin = (WIN *)((void *)0);
#line 624
            d->flags = (char )((int )d->flags & -129);
            }
#line 627
            if ((unsigned long )d2 != (unsigned long )((struct dialent **)((void *)0))) {
#line 628
              *d2 = d;
            }
#line 631
            if ((int )mpars[86].value[0] == 89) {
#line 632
              d3 = dialents;
              {
#line 634
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 634
                if (! ((unsigned long )d3 != (unsigned long )((struct dialent *)((void *)0)))) {
#line 634
                  goto while_break___2;
                }
                {
#line 635
                tmp___17 = strcmp((char const   *)(d3->name), (char const   *)(d->name));
                }
#line 635
                if (! tmp___17) {
#line 636
                  d3->flags = (char )((int )d3->flags & -129);
                }
#line 637
                d3 = d3->next;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 640
            return (retst);
          }
        }
#line 643
        f = 0;
        {
#line 643
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 643
          if (! (f < 3)) {
#line 643
            goto while_break___3;
          }
#line 644
          if (f == 0) {
#line 645
            t = mpars[46].value;
          }
#line 646
          if (f == 1) {
#line 647
            t = mpars[47].value;
          }
#line 648
          if (f == 2) {
#line 649
            t = mpars[48].value;
          }
#line 650
          if (f == 3) {
#line 651
            t = mpars[49].value;
          }
#line 652
          if (*t) {
            {
#line 652
            tmp___20 = strlen((char const   *)t);
#line 652
            tmp___21 = strncmp((char const   *)(modbuf), (char const   *)t, tmp___20);
            }
#line 652
            if (! tmp___21) {
#line 653
              if (retries < maxretries) {
                {
#line 654
                x = dialfailed(t, rdelay);
                }
#line 655
                if (x < 0) {
                  {
#line 656
                  keyboard(1, 0);
#line 657
                  mc_wclose(dialwin, 1);
                  }
#line 658
                  return (retst);
                }
              }
#line 661
              if (maxretries == 1) {
#line 662
                reason = t;
              }
#line 663
              goto MainLoop;
            }
          }
#line 643
          f ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 669
      time(& now);
      }
#line 670
      if (last___0 != now) {
#line 671
        dialtime = (int )((time_t )dialtime - (now - last___0));
#line 672
        if (dialtime < 0) {
#line 673
          dialtime = 0;
        }
        {
#line 674
        mc_wlocate(dialwin, 11, 4);
#line 675
        mc_wprintf(dialwin, "%-3d  ", dialtime);
        }
#line 676
        if (dialtime <= 0) {
          {
#line 677
          mputs((char const   *)(mpars[51].value), 0);
#line 678
          reason = gettext("Timeout");
#line 679
          retst = -1L;
          }
#line 680
          if (retries < maxretries) {
            {
#line 681
            x = dialfailed(reason, rdelay);
            }
#line 682
            if (x < 0) {
              {
#line 683
              keyboard(1, 0);
#line 684
              mc_wclose(dialwin, 1);
              }
#line 685
              return (retst);
            }
          }
        }
      }
#line 690
      last___0 = now;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 693
  dialfailed(reason, -1);
#line 694
  keyboard(1, 0);
#line 695
  mc_wclose(dialwin, 1);
  }
#line 696
  return (retst);
}
}
#line 702 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static struct dialent *mkstdent(void) 
{ 
  struct dialent *d ;
  void *tmp ;

  {
  {
#line 704
  tmp = malloc(sizeof(struct dialent ));
#line 704
  d = (struct dialent *)tmp;
  }
#line 706
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 707
    return (d);
  }
  {
#line 709
  d->name[0] = (char)0;
#line 710
  d->number[0] = (char)0;
#line 711
  d->script[0] = (char)0;
#line 712
  d->username[0] = (char)0;
#line 713
  d->password[0] = (char)0;
#line 714
  d->term = (char)1;
#line 715
  d->dialtype = (char)0;
#line 716
  d->flags = (char)2;
#line 717
  strcpy((char */* __restrict  */)(d->baud), (char const   */* __restrict  */)"Curr");
#line 718
  strcpy((char */* __restrict  */)(d->bits), (char const   */* __restrict  */)"8");
#line 719
  strcpy((char */* __restrict  */)(d->parity), (char const   */* __restrict  */)"N");
#line 720
  d->lastdate[0] = (char)0;
#line 721
  d->lasttime[0] = (char)0;
#line 722
  d->count = (uint32_t )0;
#line 723
  d->convfile[0] = (char)0;
#line 724
  strcpy((char */* __restrict  */)(d->stopb), (char const   */* __restrict  */)"1");
#line 725
  d->next = (struct dialent *)((void *)0);
  }
#line 727
  return (d);
}
}
#line 730 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void convert_to_save_order(struct dialent *dst , struct dialent  const  *src ) 
{ 


  {
  {
#line 732
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(*dst));
#line 733
  dst->count = htonl(dst->count);
  }
#line 734
  return;
}
}
#line 736 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void convert_to_host_order(struct dialent *dst , struct dialent  const  *src ) 
{ 


  {
  {
#line 738
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(*dst));
#line 739
  dst->count = ntohl(dst->count);
  }
#line 740
  return;
}
}
#line 743 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v5_read(FILE *fp , struct dialent *d ) 
{ 
  struct dialent dent_n ;
  size_t tmp ;

  {
  {
#line 746
  tmp = fread((void */* __restrict  */)(& dent_n), sizeof(dent_n), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 746
  if (tmp != 1UL) {
#line 747
    return (1);
  }
  {
#line 748
  convert_to_host_order(d, (struct dialent  const  *)(& dent_n));
  }
#line 749
  return (0);
}
}
#line 752 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v6_read(FILE *fp , struct dialent *d ) 
{ 
  struct dialent dent_n ;
  size_t tmp ;

  {
  {
#line 755
  tmp = fread((void */* __restrict  */)(& dent_n), sizeof(dent_n) - sizeof(void *),
              (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 755
  if (tmp != 1UL) {
#line 756
    return (1);
  }
  {
#line 757
  convert_to_host_order(d, (struct dialent  const  *)(& dent_n));
  }
#line 758
  return (0);
}
}
#line 762 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v4_read(FILE *fp , struct dialent *d , struct dver *dv ) 
{ 
  struct v4_dialent v4 ;
  size_t tmp ;

  {
  {
#line 766
  tmp = fread((void */* __restrict  */)(& v4), (size_t )dv->size, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 766
  if (tmp != 1UL) {
#line 767
    return (1);
  }
#line 769
  if ((unsigned long )dv->size < sizeof(struct dialent )) {
#line 770
    if ((unsigned long )dv->size < (unsigned long )(& ((struct dialent *)0)->count) + sizeof(struct dialent *)) {
#line 771
      d->count = (uint32_t )0;
#line 772
      d->lasttime[0] = (char)0;
#line 773
      d->lastdate[0] = (char)0;
    }
#line 775
    if ((unsigned long )dv->size < (unsigned long )(& ((struct dialent *)0)->stopb) + sizeof(struct dialent *)) {
#line 776
      d->convfile[0] = (char)0;
    }
    {
#line 777
    strcpy((char */* __restrict  */)(d->stopb), (char const   */* __restrict  */)"1");
    }
  }
#line 780
  return (0);
}
}
#line 784 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v3_read(FILE *fp , struct dialent *d ) 
{ 
  struct v3_dialent v3 ;
  size_t tmp ;

  {
  {
#line 788
  tmp = fread((void */* __restrict  */)(& v3), sizeof(v3), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 788
  if (tmp != 1UL) {
#line 789
    return (1);
  }
  {
#line 791
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)(& v3), (unsigned long )(& ((struct v3_dialent *)0)->next));
#line 793
  d->lastdate[0] = (char)0;
#line 794
  d->lasttime[0] = (char)0;
#line 795
  d->count = (uint32_t )0;
#line 796
  d->convfile[0] = (char)0;
#line 797
  strcpy((char */* __restrict  */)(d->stopb), (char const   */* __restrict  */)"1");
  }
#line 799
  return (0);
}
}
#line 803 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v2_read(FILE *fp , struct dialent *d ) 
{ 
  struct v3_dialent v3 ;
  size_t tmp ;

  {
  {
#line 807
  tmp = fread((void */* __restrict  */)((char *)(& v3)), sizeof(v3), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 807
  if (tmp != 1UL) {
#line 808
    return (1);
  }
  {
#line 810
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)(& v3), (unsigned long )(& ((struct v3_dialent *)0)->next));
  }
#line 811
  if ((int )d->flags & 8) {
#line 812
    d->flags = (char )((int )d->flags | 4);
  }
  {
#line 813
  d->lastdate[0] = (char)0;
#line 814
  d->lasttime[0] = (char)0;
#line 815
  d->count = (uint32_t )0;
#line 816
  d->convfile[0] = (char)0;
#line 817
  strcpy((char */* __restrict  */)(d->stopb), (char const   */* __restrict  */)"1");
  }
#line 819
  return (0);
}
}
#line 823 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v1_read(FILE *fp , struct dialent *d ) 
{ 
  struct v1_dialent v1 ;
  size_t tmp ;

  {
  {
#line 827
  tmp = fread((void */* __restrict  */)((char *)(& v1)), sizeof(v1), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 827
  if (tmp != 1UL) {
#line 828
    return (1);
  }
  {
#line 830
  memcpy((void */* __restrict  */)(d->username), (void const   */* __restrict  */)(v1.username),
         sizeof(v1) - (unsigned long )(& ((struct v1_dialent *)0)->username));
#line 831
  strncpy((char */* __restrict  */)(d->name), (char const   */* __restrict  */)(v1.name),
          sizeof(d->name));
#line 832
  strncpy((char */* __restrict  */)(d->number), (char const   */* __restrict  */)(v1.number),
          sizeof(d->number));
#line 833
  strncpy((char */* __restrict  */)(d->script), (char const   */* __restrict  */)(v1.script),
          sizeof(d->script));
#line 834
  d->lastdate[0] = (char)0;
#line 835
  d->lasttime[0] = (char)0;
#line 836
  d->count = (uint32_t )0;
#line 837
  d->convfile[0] = (char)0;
#line 838
  strcpy((char */* __restrict  */)(d->stopb), (char const   */* __restrict  */)"1");
  }
#line 840
  return (0);
}
}
#line 844 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int v0_read(FILE *fp , struct dialent *d ) 
{ 
  int tmp ;

  {
  {
#line 846
  tmp = v1_read(fp, d);
  }
#line 846
  if (tmp) {
#line 847
    return (1);
  }
#line 848
  d->dialtype = (char)0;
#line 849
  d->flags = (char)0;
#line 851
  return (0);
}
}
#line 863 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int didread  =    0;
#line 857 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
int readdialdir(void) 
{ 
  long size ;
  FILE *fp ;
  char dfile[256] ;
  char copycmd[512] ;
  int f ;
  struct dialent *d ;
  struct dialent *tail ;
  struct dver dial_ver ;
  WIN *w ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  int r ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 865
  d = (struct dialent *)((void *)0);
#line 865
  tail = (struct dialent *)((void *)0);
#line 869
  if (didread) {
#line 870
    return (0);
  }
  {
#line 871
  didread = 1;
#line 872
  nrents___0 = 1;
#line 873
  tmp = malloc((size_t )1);
#line 873
  tagged = (char *)tmp;
  }
#line 874
  if (! tagged) {
#line 875
    return (0);
  }
  {
#line 876
  *(tagged + 0) = (char)0;
#line 879
  d_man = mkstdent();
#line 880
  tmp___0 = gettext("Manually entered number");
#line 880
  strncpy((char */* __restrict  */)(d_man->name), (char const   */* __restrict  */)tmp___0,
          sizeof(d_man->name));
#line 881
  d_man->name[sizeof(d_man->name) - 1UL] = (char)0;
#line 884
  snprintf((char */* __restrict  */)(dfile), sizeof(dfile), (char const   */* __restrict  */)"%s/.dialdir",
           homedir);
#line 887
  fp = fopen((char const   */* __restrict  */)(dfile), (char const   */* __restrict  */)"r");
  }
#line 887
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 888
    tmp___2 = __errno_location();
    }
#line 888
    if (*tmp___2 == 1) {
      {
#line 889
      tmp___1 = gettext("Cannot open ~/.dialdir: permission denied");
#line 889
      werror((char const   *)tmp___1);
#line 890
      dialents = mkstdent();
#line 891
      dendd = 1;
      }
#line 892
      return (0);
    }
    {
#line 894
    dialents = mkstdent();
    }
#line 895
    return (0);
  }
  {
#line 899
  fseek(fp, 0L, 2);
#line 900
  size = ftell(fp);
  }
#line 901
  if (size == 0L) {
    {
#line 902
    dialents = mkstdent();
#line 903
    fclose(fp);
    }
#line 904
    return (0);
  }
  {
#line 908
  fseek(fp, 0L, 0);
#line 909
  tmp___4 = fread((void */* __restrict  */)(& dial_ver), sizeof(dial_ver), (size_t )1,
                  (FILE */* __restrict  */)fp);
  }
#line 909
  if (tmp___4 != 1UL) {
    {
#line 911
    tmp___3 = gettext("Failed to read dialing directory\n");
#line 911
    werror((char const   *)tmp___3);
    }
#line 912
    return (-1);
  }
#line 914
  if ((int )dial_ver.magic != 21930) {
    {
#line 916
    dial_ver.version = (short)0;
#line 917
    fseek(fp, 0L, 0);
    }
  } else {
    {
#line 919
    dial_ver.size = ntohs(dial_ver.size);
#line 920
    size = (long )((unsigned long )size - sizeof(dial_ver));
    }
  }
  {
#line 926
  if ((int )dial_ver.version == 1) {
#line 926
    goto case_1;
  }
#line 926
  if ((int )dial_ver.version == 0) {
#line 926
    goto case_1;
  }
#line 930
  if ((int )dial_ver.version == 3) {
#line 930
    goto case_3;
  }
#line 930
  if ((int )dial_ver.version == 2) {
#line 930
    goto case_3;
  }
#line 933
  if ((int )dial_ver.version == 4) {
#line 933
    goto case_4;
  }
#line 950
  if ((int )dial_ver.version == 5) {
#line 950
    goto case_5;
  }
#line 956
  if ((int )dial_ver.version == 6) {
#line 956
    goto case_6;
  }
#line 964
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 927
  dial_ver.size = (unsigned short )sizeof(struct v1_dialent );
#line 928
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 931
  dial_ver.size = (unsigned short )sizeof(struct v3_dialent );
#line 932
  goto switch_break;
  case_4: /* CIL Label */ 
#line 943
  if ((int )dial_ver.size < 200) {
    {
#line 945
    tmp___5 = gettext("Phonelist garbled (unknown version?)");
#line 945
    werror((char const   *)tmp___5);
#line 946
    dialents = mkstdent();
    }
#line 947
    return (-1);
  } else
#line 943
  if ((unsigned long )dial_ver.size > sizeof(struct v4_dialent )) {
    {
#line 945
    tmp___5 = gettext("Phonelist garbled (unknown version?)");
#line 945
    werror((char const   *)tmp___5);
#line 946
    dialents = mkstdent();
    }
#line 947
    return (-1);
  }
#line 949
  goto switch_break;
  case_5: /* CIL Label */ 
#line 951
  if ((unsigned long )dial_ver.size != sizeof(struct dialent )) {
    {
#line 952
    tmp___6 = gettext("Phonelist corrupted");
#line 952
    werror((char const   *)tmp___6);
    }
#line 953
    return (-1);
  }
#line 955
  goto switch_break;
  case_6: /* CIL Label */ 
#line 959
  if ((unsigned long )dial_ver.size != sizeof(struct dialent ) - sizeof(void *)) {
    {
#line 960
    tmp___7 = gettext("Phonelist corrupted");
#line 960
    werror((char const   *)tmp___7);
    }
#line 961
    return (-1);
  }
#line 963
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 965
  tmp___8 = gettext("Unknown dialing directory version");
#line 965
  werror((char const   *)tmp___8);
#line 966
  dendd = 1;
#line 967
  dialents = mkstdent();
  }
#line 968
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 971
  if (size % (long )dial_ver.size != 0L) {
    {
#line 972
    tmp___9 = gettext("Phonelist garbled (?)");
#line 972
    werror((char const   *)tmp___9);
#line 973
    fclose(fp);
#line 974
    dendd = 1;
#line 975
    dialents = mkstdent();
    }
#line 976
    return (-1);
  }
#line 980
  nrents___0 = (int )(size / (long )dial_ver.size);
#line 981
  if (nrents___0 == 0) {
    {
#line 982
    dialents = mkstdent();
#line 983
    nrents___0 = 1;
#line 984
    fclose(fp);
    }
#line 985
    return (0);
  }
#line 987
  f = 1;
  {
#line 987
  while (1) {
    while_continue: /* CIL Label */ ;
#line 987
    if (! (f <= nrents___0)) {
#line 987
      goto while_break;
    }
    {
#line 988
    tmp___11 = malloc(sizeof(struct dialent ));
#line 988
    d = (struct dialent *)tmp___11;
    }
#line 988
    if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 989
      if (f == 1) {
        {
#line 990
        dialents = mkstdent();
        }
      } else {
#line 992
        tail->next = (struct dialent *)((void *)0);
      }
      {
#line 994
      tmp___10 = gettext("Out of memory while reading dialing directory");
#line 994
      werror((char const   *)tmp___10);
#line 995
      fclose(fp);
      }
#line 996
      return (-1);
    }
#line 998
    r = 0;
    {
#line 1000
    if ((int )dial_ver.version == 0) {
#line 1000
      goto case_0___0;
    }
#line 1003
    if ((int )dial_ver.version == 1) {
#line 1003
      goto case_1___0;
    }
#line 1006
    if ((int )dial_ver.version == 2) {
#line 1006
      goto case_2___0;
    }
#line 1009
    if ((int )dial_ver.version == 3) {
#line 1009
      goto case_3___0;
    }
#line 1012
    if ((int )dial_ver.version == 4) {
#line 1012
      goto case_4___0;
    }
#line 1015
    if ((int )dial_ver.version == 5) {
#line 1015
      goto case_5___0;
    }
#line 1018
    if ((int )dial_ver.version == 6) {
#line 1018
      goto case_6___0;
    }
#line 999
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 1001
    r = v0_read(fp, d);
    }
#line 1002
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1004
    r = v1_read(fp, d);
    }
#line 1005
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 1007
    r = v2_read(fp, d);
    }
#line 1008
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 1010
    r = v3_read(fp, d);
    }
#line 1011
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 1013
    r = v4_read(fp, d, & dial_ver);
    }
#line 1014
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 1016
    r = v5_read(fp, d);
    }
#line 1017
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 1019
    r = v6_read(fp, d);
    }
#line 1020
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1023
    if (r) {
      {
#line 1024
      werror("Failed to read phonelist\n");
      }
    }
#line 1027
    if ((int )d->term == 2) {
#line 1028
      d->term = (char)1;
    }
#line 1030
    if (tail) {
#line 1031
      tail->next = d;
    } else {
#line 1033
      dialents = d;
    }
#line 1034
    tail = d;
#line 987
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1036
  d->next = (struct dialent *)((void *)0);
#line 1037
  fclose(fp);
  }
#line 1039
  if ((int )dial_ver.version != 6) {
    {
#line 1040
    tmp___14 = snprintf((char */* __restrict  */)(copycmd), sizeof(copycmd), (char const   */* __restrict  */)"cp -p %s %s.v%hd",
                        dfile, dfile, (int )dial_ver.version);
    }
#line 1040
    if (tmp___14 > 0) {
#line 1042
      if ((int )mpars[83].value[0] != 0) {
        {
#line 1043
        do_log("%s", copycmd);
        }
      }
      {
#line 1044
      tmp___13 = system((char const   *)(copycmd));
      }
#line 1044
      if (tmp___13 == 0) {
        {
#line 1045
        tmp___12 = gettext("Converted dialdir to new format, old saved as %s.v%hd");
#line 1045
        snprintf((char */* __restrict  */)(copycmd), sizeof(copycmd), (char const   */* __restrict  */)tmp___12,
                 dfile, (int )dial_ver.version);
#line 1048
        w = mc_tell("%s", copycmd);
        }
#line 1049
        if (w) {
          {
#line 1050
          sleep(2U);
#line 1051
          mc_wclose(w, 1);
          }
        }
        {
#line 1053
        writedialdir();
        }
      }
    }
  }
#line 1057
  return (0);
}
}
#line 1063 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void writedialdir(void) 
{ 
  struct dialent *d ;
  char dfile[256] ;
  FILE *fp ;
  struct dver dial_ver ;
  char oldfl ;
  int omask ;
  __mode_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  struct dialent dent_n ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 1073
  if (dendd) {
#line 1074
    return;
  }
  {
#line 1076
  snprintf((char */* __restrict  */)(dfile), sizeof(dfile), (char const   */* __restrict  */)"%s/.dialdir",
           homedir);
#line 1078
  tmp = umask((__mode_t )63);
#line 1078
  omask = (int )tmp;
#line 1079
  fp = fopen((char const   */* __restrict  */)(dfile), (char const   */* __restrict  */)"w");
  }
#line 1079
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1080
    umask((__mode_t )omask);
#line 1081
    tmp___0 = gettext("Cannot open ~/.dialdir for writing!");
#line 1081
    werror((char const   *)tmp___0);
#line 1082
    dendd = 1;
    }
#line 1083
    return;
  }
  {
#line 1085
  umask((__mode_t )omask);
#line 1087
  d = dialents;
#line 1089
  dial_ver.magic = (short)21930;
#line 1090
  dial_ver.version = (short)6;
#line 1091
  dial_ver.size = htons((uint16_t )(sizeof(struct dialent ) - sizeof(void *)));
#line 1092
  dial_ver.res1 = (short)0;
#line 1093
  dial_ver.res2 = (short)0;
#line 1094
  dial_ver.res3 = (short)0;
#line 1095
  dial_ver.res4 = (short)0;
#line 1096
  tmp___2 = fwrite((void const   */* __restrict  */)(& dial_ver), sizeof(dial_ver),
                   (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 1096
  if (tmp___2 != 1UL) {
    {
#line 1097
    tmp___1 = gettext("Error writing to ~/.dialdir!");
#line 1097
    werror((char const   *)tmp___1);
#line 1098
    fclose(fp);
    }
#line 1099
    return;
  }
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (! d) {
#line 1103
      goto while_break;
    }
    {
#line 1105
    oldfl = d->flags;
#line 1106
    d->flags = (char )((int )d->flags & 15);
#line 1107
    convert_to_save_order(& dent_n, (struct dialent  const  *)d);
#line 1108
    tmp___4 = fwrite((void const   */* __restrict  */)(& dent_n), sizeof(dent_n) - sizeof(void *),
                     (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 1108
    if (tmp___4 != 1UL) {
      {
#line 1109
      tmp___3 = gettext("Error writing to ~/.dialdir!");
#line 1109
      werror((char const   *)tmp___3);
#line 1110
      fclose(fp);
      }
#line 1111
      return;
    }
#line 1113
    d->flags = oldfl;
#line 1114
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1116
  fclose(fp);
  }
#line 1117
  return;
}
}
#line 1123 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static struct dialent *getno___0(int no ) 
{ 
  struct dialent *d ;
  int tmp ;

  {
#line 1127
  d = dialents;
#line 1129
  if (no < 0) {
#line 1130
    return ((struct dialent *)((void *)0));
  } else
#line 1129
  if (no >= nrents___0) {
#line 1130
    return ((struct dialent *)((void *)0));
  }
  {
#line 1132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1132
    tmp = no;
#line 1132
    no --;
#line 1132
    if (! tmp) {
#line 1132
      goto while_break;
    }
#line 1133
    d = d->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  return (d);
}
}
#line 1139 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   *te[3]  = {      "VT102",      "MINIX",      "ANSI "};
#line 1146 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void dedit_toggle_entry(WIN *w , int x , int y , int toggle , char *toggle_true ,
                               char *toggle_false ) 
{ 
  int lt ;
  size_t tmp ;
  int lf ;
  size_t tmp___0 ;
  int l ;
  int tmp___1 ;
  char *buf___6 ;
  char *s___0 ;
  char *tmp___2 ;
  int i ;
  void *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 1149
  tmp = mbslen((char const   *)toggle_true);
#line 1149
  lt = (int )tmp;
#line 1150
  tmp___0 = mbslen((char const   *)toggle_false);
#line 1150
  lf = (int )tmp___0;
  }
#line 1151
  if (lt > lf) {
#line 1151
    tmp___1 = lt;
  } else {
#line 1151
    tmp___1 = lf;
  }
#line 1151
  l = tmp___1 + 1;
#line 1152
  if (toggle) {
#line 1152
    tmp___2 = toggle_true;
  } else {
#line 1152
    tmp___2 = toggle_false;
  }
  {
#line 1152
  s___0 = tmp___2;
#line 1155
  tmp___3 = __builtin_alloca((unsigned long )l);
#line 1155
  buf___6 = (char *)tmp___3;
  }
#line 1155
  if (! buf___6) {
#line 1156
    return;
  }
  {
#line 1158
  strncpy((char */* __restrict  */)buf___6, (char const   */* __restrict  */)s___0,
          (size_t )l);
#line 1159
  tmp___4 = mbslen((char const   *)s___0);
#line 1159
  i = (int )tmp___4;
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1159
    if (! (i < l - 1)) {
#line 1159
      goto while_break;
    }
#line 1160
    *(buf___6 + i) = (char )' ';
#line 1159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1161
  *(buf___6 + (l - 1)) = (char)0;
#line 1163
  mc_wlocate(w, x, y);
#line 1164
  mc_wputs(w, (char const   *)buf___6);
  }
#line 1165
  return;
}
}
#line 1170 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void dedit(struct dialent *d ) 
{ 
  WIN *w ;
  int c___0 ;
  char *name ;
  char *tmp ;
  char *number ;
  char *tmp___0 ;
  char *dial_string ;
  char *tmp___1 ;
  char *local_echo_str ;
  char *tmp___2 ;
  char *script ;
  char *tmp___3 ;
  char *username___0 ;
  char *tmp___4 ;
  char *password ;
  char *tmp___5 ;
  char *terminal_emulation ;
  char *tmp___6 ;
  char *backspace_key_sends ;
  char *tmp___7 ;
  char *linewrap ;
  char *tmp___8 ;
  char *line_settings ;
  char *tmp___9 ;
  char *conversion_table ;
  char *tmp___10 ;
  char *question ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  size_t tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;

  {
  {
#line 1174
  tmp = gettext(" A -  Name                :");
#line 1174
  name = tmp;
#line 1174
  tmp___0 = gettext(" B -  Number              :");
#line 1174
  number = tmp___0;
#line 1174
  tmp___1 = gettext(" C -  Dial string #       :");
#line 1174
  dial_string = tmp___1;
#line 1174
  tmp___2 = gettext(" D -  Local echo          :");
#line 1174
  local_echo_str = tmp___2;
#line 1174
  tmp___3 = gettext(" E -  Script              :");
#line 1174
  script = tmp___3;
#line 1174
  tmp___4 = gettext(" F -  Username            :");
#line 1174
  username___0 = tmp___4;
#line 1174
  tmp___5 = gettext(" G -  Password            :");
#line 1174
  password = tmp___5;
#line 1174
  tmp___6 = gettext(" H -  Terminal Emulation  :");
#line 1174
  terminal_emulation = tmp___6;
#line 1174
  tmp___7 = gettext(" I -  Backspace key sends :");
#line 1174
  backspace_key_sends = tmp___7;
#line 1174
  tmp___8 = gettext(" J -  Linewrap            :");
#line 1174
  linewrap = tmp___8;
#line 1174
  tmp___9 = gettext(" K -  Line Settings       :");
#line 1174
  line_settings = tmp___9;
#line 1174
  tmp___10 = gettext(" L -  Conversion table    :");
#line 1174
  conversion_table = tmp___10;
#line 1174
  tmp___11 = gettext("Change which setting?");
#line 1174
  question = tmp___11;
#line 1188
  w = mc_wopen(5, 4, 75, 19, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1189
  mc_wprintf(w, "%s %s\n", name, d->name);
#line 1190
  mc_wprintf(w, "%s %s\n", number, d->number);
#line 1191
  mc_wprintf(w, "%s %d\n", dial_string, (int )d->dialtype + 1);
#line 1192
  tmp___12 = yesno((int )d->flags & 1);
#line 1192
  tmp___13 = gettext(tmp___12);
#line 1192
  mc_wprintf(w, "%s %s\n", local_echo_str, tmp___13);
#line 1193
  mc_wprintf(w, "%s %s\n", script, d->script);
#line 1194
  mc_wprintf(w, "%s %s\n", username___0, d->username);
#line 1195
  mc_wprintf(w, "%s %s\n", password, d->password);
#line 1196
  mc_wprintf(w, "%s %s\n", terminal_emulation, te[(int )d->term - 1]);
  }
#line 1197
  if ((int )d->flags & 2) {
    {
#line 1197
    tmp___14 = gettext("Delete");
#line 1197
    tmp___16 = tmp___14;
    }
  } else {
    {
#line 1197
    tmp___15 = gettext("Backspace");
#line 1197
    tmp___16 = tmp___15;
    }
  }
  {
#line 1197
  mc_wprintf(w, "%s %s\n", backspace_key_sends, tmp___16);
  }
#line 1199
  if ((int )d->flags & 4) {
    {
#line 1199
    tmp___17 = gettext("On");
#line 1199
    tmp___19 = tmp___17;
    }
  } else {
    {
#line 1199
    tmp___18 = gettext("Off");
#line 1199
    tmp___19 = tmp___18;
    }
  }
  {
#line 1199
  mc_wprintf(w, "%s %s\n", linewrap, tmp___19);
#line 1201
  mc_wprintf(w, "%s %s %s%s%s\n", line_settings, d->baud, d->bits, d->parity, d->stopb);
#line 1203
  mc_wprintf(w, "%s %s\n", conversion_table, d->convfile);
#line 1204
  tmp___20 = gettext("      Last dialed         : %s %s\n");
#line 1204
  mc_wprintf(w, (char const   *)tmp___20, d->lastdate, d->lasttime);
#line 1205
  tmp___21 = gettext("      Times on            : %d");
#line 1205
  mc_wprintf(w, (char const   *)tmp___21, d->count);
#line 1206
  mc_wlocate(w, 4, 15);
#line 1207
  mc_wputs(w, (char const   *)question);
#line 1208
  mc_wredraw(w, 1);
  }
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1211
    tmp___22 = mbslen((char const   *)question);
#line 1211
    mc_wlocate(w, (int )(tmp___22 + 5UL), 15);
#line 1212
    c___0 = wxgetch();
    }
#line 1213
    if (c___0 >= 97) {
#line 1214
      c___0 -= 32;
    }
    {
#line 1218
    if (c___0 == 10) {
#line 1218
      goto case_10;
    }
#line 1218
    if (c___0 == 13) {
#line 1218
      goto case_10;
    }
#line 1218
    if (c___0 == 27) {
#line 1218
      goto case_10;
    }
#line 1221
    if (c___0 == 65) {
#line 1221
      goto case_65;
    }
#line 1225
    if (c___0 == 66) {
#line 1225
      goto case_66;
    }
#line 1229
    if (c___0 == 67) {
#line 1229
      goto case_67;
    }
#line 1235
    if (c___0 == 68) {
#line 1235
      goto case_68;
    }
#line 1241
    if (c___0 == 69) {
#line 1241
      goto case_69;
    }
#line 1245
    if (c___0 == 70) {
#line 1245
      goto case_70;
    }
#line 1249
    if (c___0 == 71) {
#line 1249
      goto case_71;
    }
#line 1253
    if (c___0 == 72) {
#line 1253
      goto case_72;
    }
#line 1274
    if (c___0 == 73) {
#line 1274
      goto case_73;
    }
#line 1279
    if (c___0 == 74) {
#line 1279
      goto case_74;
    }
#line 1284
    if (c___0 == 75) {
#line 1284
      goto case_75;
    }
#line 1290
    if (c___0 == 76) {
#line 1290
      goto case_76;
    }
#line 1294
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 1219
    mc_wclose(w, 1);
    }
#line 1220
    return;
    case_65: /* CIL Label */ 
    {
#line 1222
    tmp___23 = mbslen((char const   *)name);
#line 1222
    mc_wlocate(w, (int )(tmp___23 + 1UL), 0);
#line 1223
    mc_wgets(w, d->name, 31, 32);
    }
#line 1224
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1226
    tmp___24 = mbslen((char const   *)number);
#line 1226
    mc_wlocate(w, (int )(tmp___24 + 1UL), 1);
#line 1227
    mc_wgets(w, d->number, 31, 32);
    }
#line 1228
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 1230
    d->dialtype = (char )(((int )d->dialtype + 1) % 3);
#line 1231
    tmp___25 = mbslen((char const   *)dial_string);
#line 1231
    mc_wlocate(w, (int )(tmp___25 + 1UL), 2);
#line 1232
    mc_wprintf(w, "%d", (int )d->dialtype + 1);
#line 1233
    mc_wflush();
    }
#line 1234
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 1236
    d->flags = (char )((int )d->flags ^ 1);
#line 1237
    tmp___26 = mbslen((char const   *)local_echo_str);
#line 1237
    mc_wlocate(w, (int )(tmp___26 + 1UL), 3);
#line 1238
    tmp___27 = yesno((int )d->flags & 1);
#line 1238
    tmp___28 = gettext(tmp___27);
#line 1238
    mc_wprintf(w, "%s", tmp___28);
#line 1239
    mc_wflush();
    }
#line 1240
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 1242
    tmp___29 = mbslen((char const   *)script);
#line 1242
    mc_wlocate(w, (int )(tmp___29 + 1UL), 4);
#line 1243
    mc_wgets(w, d->script, 31, 32);
    }
#line 1244
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1246
    tmp___30 = mbslen((char const   *)username___0);
#line 1246
    mc_wlocate(w, (int )(tmp___30 + 1UL), 5);
#line 1247
    mc_wgets(w, d->username, 31, 32);
    }
#line 1248
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 1250
    tmp___31 = mbslen((char const   *)password);
#line 1250
    mc_wlocate(w, (int )(tmp___31 + 1UL), 6);
#line 1251
    mc_wgets(w, d->password, 31, 32);
    }
#line 1252
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1254
    d->term = (char )((int )d->term % 3 + 1);
#line 1256
    if ((int )d->term == 2) {
#line 1257
      d->term = (char)3;
    }
    {
#line 1258
    tmp___32 = mbslen((char const   *)terminal_emulation);
#line 1258
    mc_wlocate(w, (int )(tmp___32 + 1UL), 7);
#line 1259
    mc_wputs(w, te[(int )d->term - 1]);
    }
#line 1262
    if ((int )d->term == 3) {
#line 1263
      d->flags = (char )((int )d->flags & -3);
#line 1264
      d->flags = (char )((int )d->flags | 4);
    } else {
#line 1266
      d->flags = (char )((int )d->flags | 2);
#line 1267
      d->flags = (char )((int )d->flags & -5);
    }
    {
#line 1269
    tmp___33 = gettext("Backspace");
#line 1269
    tmp___34 = gettext("Delete");
#line 1269
    tmp___35 = mbslen((char const   *)backspace_key_sends);
#line 1269
    dedit_toggle_entry(w, (int )(tmp___35 + 1UL), 8, (int )d->flags & 2, tmp___34,
                       tmp___33);
#line 1271
    tmp___36 = gettext("Off");
#line 1271
    tmp___37 = gettext("On");
#line 1271
    tmp___38 = mbslen((char const   *)linewrap);
#line 1271
    dedit_toggle_entry(w, (int )(tmp___38 + 1UL), 9, (int )d->flags & 4, tmp___37,
                       tmp___36);
    }
#line 1273
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 1275
    d->flags = (char )((int )d->flags ^ 2);
#line 1276
    tmp___39 = gettext("Backspace");
#line 1276
    tmp___40 = gettext("Delete");
#line 1276
    tmp___41 = mbslen((char const   *)backspace_key_sends);
#line 1276
    dedit_toggle_entry(w, (int )(tmp___41 + 1UL), 8, (int )d->flags & 2, tmp___40,
                       tmp___39);
    }
#line 1278
    goto switch_break;
    case_74: /* CIL Label */ 
    {
#line 1280
    d->flags = (char )((int )d->flags ^ 4);
#line 1281
    tmp___42 = gettext("Off");
#line 1281
    tmp___43 = gettext("On");
#line 1281
    tmp___44 = mbslen((char const   *)linewrap);
#line 1281
    dedit_toggle_entry(w, (int )(tmp___44 + 1UL), 9, (int )d->flags & 4, tmp___43,
                       tmp___42);
    }
#line 1283
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1285
    get_bbp(d->baud, d->bits, d->parity, d->stopb, 1);
#line 1286
    tmp___45 = mbslen((char const   *)line_settings);
#line 1286
    mc_wlocate(w, (int )(tmp___45 + 1UL), 10);
#line 1287
    mc_wprintf(w, "%s %s%s%s  ", d->baud, d->bits, d->parity, d->stopb);
    }
#line 1289
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1291
    tmp___46 = mbslen((char const   *)conversion_table);
#line 1291
    mc_wlocate(w, (int )(tmp___46 + 1UL), 11);
#line 1292
    mc_wgets(w, d->convfile, 15, 16);
    }
#line 1293
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1300 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static WIN *dsub___0  ;
#line 1301 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   * const  what___0[7]  = {      (char const   */* const  */)"Dial",      (char const   */* const  */)"Find",      (char const   */* const  */)"Add",      (char const   */* const  */)"Edit", 
        (char const   */* const  */)"Remove",      (char const   */* const  */)"moVe",      (char const   */* const  */)"Manual"};
#line 1312 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int what_lens___0[sizeof(what___0) / sizeof(what___0[0])]  ;
#line 1314 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int what_padding___0[sizeof(what___0) / sizeof(what___0[0])][2]  ;
#line 1316 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int dprev___0  ;
#line 1321
static void horiz_draw___0(size_t k ) ;
#line 1321 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   spaces___0[9]  = 
#line 1321
  {      (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )'\000'};
#line 1319 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void horiz_draw___0(size_t k ) 
{ 
  char *tmp ;

  {
  {
#line 1323
  mc_wprintf(dsub___0, "%.*s", what_padding___0[k][0], spaces___0);
#line 1324
  tmp = gettext((char const   *)what___0[k]);
#line 1324
  mc_wprintf(dsub___0, "%.*s", what_lens___0[k], tmp);
#line 1325
  mc_wprintf(dsub___0, "%.*s", what_padding___0[k][1], spaces___0);
  }
#line 1326
  return;
}
}
#line 1331 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void dhili___0(int position_dialing_directory , int k ) 
{ 


  {
#line 1333
  if (k == dprev___0) {
#line 1334
    return;
  }
#line 1336
  if (dprev___0 >= 0) {
    {
#line 1337
    mc_wlocate(dsub___0, position_dialing_directory + 8 * dprev___0, 0);
    }
#line 1338
    if (! useattr) {
      {
#line 1339
      mc_wputs(dsub___0, " ");
      }
    } else {
      {
#line 1341
      dsub___0->attr = (char )(4 | (int )stdattr);
#line 1342
      horiz_draw___0((size_t )dprev___0);
      }
    }
  }
  {
#line 1345
  dprev___0 = k;
#line 1346
  mc_wlocate(dsub___0, position_dialing_directory + 8 * k, 0);
  }
#line 1347
  if (! useattr) {
    {
#line 1348
    mc_wputs(dsub___0, ">");
    }
  } else {
    {
#line 1350
    dsub___0->attr = stdattr;
#line 1351
    horiz_draw___0((size_t )k);
    }
  }
#line 1353
  return;
}
}
#line 1355 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   *fmt  =    "\r %2d %c%-16.16s%-16.16s%8.8s %5.5s %4d %-15.15s\n";
#line 1360 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void prdir___0(WIN *dialw , int top___1 , int cur___1 ) 
{ 
  int f ;
  int start___1 ;
  struct dialent *d ;
  int tmp ;

  {
  {
#line 1365
  start___1 = cur___1 - top___1;
#line 1366
  dirflush = 0;
#line 1367
  mc_wlocate(dialw, 0, start___1 + 1);
#line 1368
  f = start___1;
  }
  {
#line 1368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1368
    if (! (f < dialw->ys - 2)) {
#line 1368
      goto while_break;
    }
    {
#line 1369
    d = getno___0(f + top___1);
    }
#line 1370
    if ((unsigned long )d == (unsigned long )((struct dialent *)0)) {
#line 1371
      goto while_break;
    }
#line 1372
    if ((int )d->flags & 128) {
#line 1372
      tmp = '>';
    } else {
#line 1372
      tmp = ' ';
    }
    {
#line 1372
    mc_wprintf(dialw, fmt, (f + 1) + top___1, tmp, d->name, d->number, d->lastdate,
               d->lasttime, d->count, d->script);
#line 1368
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1376
  dirflush = 1;
#line 1377
  mc_wflush();
  }
#line 1378
  return;
}
}
#line 1383 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
int move_entry(WIN *dialw , struct dialent *d , int cur___1 , int *top___1 ) 
{ 
  int ocur___1 ;
  int quit___0 ;
  int c___0 ;
  struct dialent *dtmp ;

  {
#line 1385
  ocur___1 = cur___1;
#line 1385
  quit___0 = 0;
#line 1385
  c___0 = 0;
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1390
    if (! (! quit___0)) {
#line 1390
      goto while_break;
    }
    {
#line 1391
    c___0 = wxgetch();
    }
    {
#line 1393
    if (c___0 == 106) {
#line 1393
      goto case_106;
    }
#line 1393
    if (c___0 == 272) {
#line 1393
      goto case_106;
    }
#line 1410
    if (c___0 == 107) {
#line 1410
      goto case_107;
    }
#line 1410
    if (c___0 == 269) {
#line 1410
      goto case_107;
    }
#line 1428
    if (c___0 == 10) {
#line 1428
      goto case_10;
    }
#line 1428
    if (c___0 == 13) {
#line 1428
      goto case_10;
    }
#line 1428
    if (c___0 == 27) {
#line 1428
      goto case_10;
    }
#line 1431
    goto switch_default;
    case_106: /* CIL Label */ 
    case_272: /* CIL Label */ 
#line 1394
    if (! d->next) {
#line 1395
      goto switch_break;
    }
#line 1396
    if (cur___1 == 0) {
#line 1397
      dtmp = d->next;
#line 1398
      d->next = dtmp->next;
#line 1399
      dtmp->next = d;
#line 1400
      dialents = dtmp;
    } else {
      {
#line 1402
      dtmp = getno___0(cur___1 - 1);
#line 1403
      dtmp->next = d->next;
#line 1404
      d->next = (d->next)->next;
#line 1405
      (dtmp->next)->next = d;
      }
    }
#line 1407
    cur___1 ++;
#line 1408
    goto switch_break;
    case_107: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 1411
    if (cur___1 == 0) {
#line 1412
      goto switch_break;
    }
#line 1413
    if (cur___1 == 1) {
#line 1414
      dtmp = dialents;
#line 1415
      dtmp->next = d->next;
#line 1416
      d->next = dtmp;
#line 1417
      dialents = d;
    } else {
      {
#line 1419
      dtmp = getno___0(cur___1 - 2);
#line 1420
      (dtmp->next)->next = d->next;
#line 1421
      d->next = dtmp->next;
#line 1422
      dtmp->next = d;
      }
    }
#line 1424
    cur___1 --;
#line 1425
    goto switch_break;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 1429
    quit___0 = 1;
#line 1430
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1432
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1436
    if (cur___1 != ocur___1) {
      {
#line 1438
      mc_wcurbar(dialw, (ocur___1 + 1) - *top___1, (int )stdattr);
      }
#line 1439
      if (cur___1 < *top___1) {
#line 1440
        (*top___1) --;
      } else
#line 1441
      if (cur___1 - *top___1 > dialw->ys - 3) {
#line 1442
        (*top___1) ++;
      }
      {
#line 1443
      prdir___0(dialw, *top___1, *top___1);
#line 1444
      mc_wcurbar(dialw, (cur___1 + 1) - *top___1, 4 | (int )stdattr);
#line 1445
      ocur___1 = cur___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1449
  return (cur___1);
}
}
#line 1453 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   *d_yesno___0[3]  = {      "   Yes  ",      "   No   ",      (char const   *)((void *)0)};
#line 1456 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static void dial_entry(struct dialent *d ) 
{ 
  long nb ;
  struct dialent *d2 ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1462
  tmp = atoi((char const   *)(d->baud));
  }
#line 1462
  if (tmp != 0) {
    {
#line 1463
    strcpy((char */* __restrict  */)(mpars[28].value), (char const   */* __restrict  */)(d->baud));
#line 1464
    strcpy((char */* __restrict  */)(mpars[30].value), (char const   */* __restrict  */)(d->parity));
#line 1465
    strcpy((char */* __restrict  */)(mpars[29].value), (char const   */* __restrict  */)(d->bits));
#line 1466
    strcpy((char */* __restrict  */)(mpars[31].value), (char const   */* __restrict  */)(d->stopb));
#line 1467
    port_init();
#line 1468
    show_status();
    }
  }
  {
#line 1470
  newtype = (int )d->term;
#line 1471
  vt_set(-1, (int )d->flags & 4, -1, -1, (int )d->flags & 1, -1, -1, -1, -1);
#line 1472
  local_echo = (int )d->flags & 1;
  }
#line 1473
  if (newtype != (int )terminal) {
    {
#line 1474
    init_emul(newtype, 1);
    }
  }
#line 1477
  if ((int )d->flags & 2) {
#line 1477
    tmp___0 = 127;
  } else {
#line 1477
    tmp___0 = 8;
  }
  {
#line 1477
  keyboard(12, tmp___0);
  }
#line 1478
  if ((int )d->flags & 2) {
#line 1478
    tmp___1 = "DEL";
  } else {
#line 1478
    tmp___1 = "BS";
  }
  {
#line 1478
  strcpy((char */* __restrict  */)(mpars[62].value), (char const   */* __restrict  */)tmp___1);
#line 1481
  nb = dial(d, & d2);
  }
#line 1481
  if (nb < 0L) {
#line 1482
    return;
  }
#line 1484
  if ((unsigned long )d2 != (unsigned long )((struct dialent *)((void *)0))) {
#line 1485
    d = d2;
  }
#line 1488
  if ((int )mpars[56].value[0] == 89) {
#line 1488
    if (nb) {
      {
#line 1489
      sprintf((char */* __restrict  */)(mpars[28].value), (char const   */* __restrict  */)"%ld",
              nb);
#line 1490
      port_init();
#line 1491
      show_status();
      }
    } else {
#line 1488
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1492
  if ((int )mpars[57].value[0] == 108) {
    {
#line 1493
    show_status();
    }
  }
  {
#line 1496
  writedialdir();
  }
#line 1499
  if (d->script[0]) {
    {
#line 1500
    runscript(0, (char const   *)(d->script), (char const   *)(d->username), (char const   *)(d->password));
    }
  }
#line 1503
  dial_name = d->name;
#line 1504
  dial_number = d->number;
#line 1505
  dial_user = d->username;
#line 1506
  dial_pass = d->password;
#line 1508
  return;
}
}
#line 1516 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void dialone(char *entry ) 
{ 
  int num ;
  struct dialent *d ;
  struct dialent *d1 ;
  char *s___0 ;
  char buf___6[128] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1520
  d1 = (struct dialent *)((void *)0);
#line 1524
  s___0 = strtok((char */* __restrict  */)entry, (char const   */* __restrict  */)",;");
  }
  {
#line 1525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1525
    if (! s___0) {
#line 1525
      goto while_break;
    }
    {
#line 1527
    num = atoi((char const   *)s___0);
    }
#line 1527
    if (num != 0) {
      {
#line 1528
      d = getno___0(num - 1);
      }
#line 1528
      if (d) {
#line 1529
        d->flags = (char )((int )d->flags | 128);
#line 1530
        if ((unsigned long )d1 == (unsigned long )((struct dialent *)((void *)0))) {
#line 1531
          d1 = d;
        }
      }
    } else {
#line 1534
      d = dialents;
      {
#line 1534
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1534
        if (! d) {
#line 1534
          goto while_break___0;
        }
        {
#line 1535
        tmp = strstr((char const   *)(d->name), (char const   *)s___0);
        }
#line 1535
        if (tmp) {
#line 1536
          d->flags = (char )((int )d->flags | 128);
#line 1537
          if ((unsigned long )d1 == (unsigned long )((struct dialent *)((void *)0))) {
#line 1538
            d1 = d;
          }
        }
#line 1534
        d = d->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1541
    s___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",;");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1545
  if ((unsigned long )d1 == (unsigned long )((void *)0)) {
    {
#line 1546
    tmp___0 = gettext("Entry \"%s\" not found. Enter dialdir?");
#line 1546
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)tmp___0,
             entry);
#line 1547
    tmp___1 = ask((char const   *)(buf___6), d_yesno___0);
    }
#line 1547
    if (tmp___1 != 0) {
#line 1548
      return;
    }
    {
#line 1549
    dialdir();
    }
#line 1550
    return;
  }
  {
#line 1553
  sleep(1U);
#line 1554
  dial_entry(d1);
  }
#line 1555
  return;
}
}
#line 1564 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int cur___0  =    0;
#line 1565 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int ocur___0  =    0;
#line 1568 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static int top___0  =    0;
#line 1574 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char manual[128]  ;
#line 1576 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   *tag_exit  =    "( Escape to exit, Space to tag )";
#line 1576 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
static char const   *move_exit  =    " Move entry up/down, Escape to exit";
#line 1560 "/home/wheatley/newnew/temp/minicom-2.7/src/dial.c"
void dialdir(void) 
{ 
  WIN *w ;
  struct dialent *d ;
  struct dialent *d1 ;
  struct dialent *d2 ;
  int subm___0 ;
  int quit___0 ;
  int c___0 ;
  int pgud___0 ;
  int first___0 ;
  int x1 ;
  int x2 ;
  char *s___0 ;
  char dname[128] ;
  int changed ;
  unsigned int tagmvlen ;
  size_t i ;
  int position_dialing_directory ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *str ;
  char const   *c___1 ;
  size_t j ;
  char *tmp___7 ;
  wchar_t wc ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  struct dialent *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 1563
  d = (struct dialent *)((void *)0);
#line 1566
  subm___0 = 0;
#line 1567
  quit___0 = 0;
#line 1569
  c___0 = 0;
#line 1570
  pgud___0 = 0;
#line 1571
  first___0 = 1;
#line 1575
  changed = 0;
#line 1578
  tagmvlen = 0U;
#line 1580
  position_dialing_directory = (int )(((unsigned long )(COLS / 2 + 32) - (sizeof(what___0) / sizeof(what___0[0])) * 8UL) / 2UL);
#line 1582
  dprev___0 = -1;
#line 1583
  dname[0] = (char)0;
#line 1584
  tmp = gettext(move_exit);
#line 1584
  tmp___0 = strlen((char const   *)tmp);
#line 1584
  tagmvlen = (unsigned int )tmp___0;
#line 1585
  tmp___3 = gettext(tag_exit);
#line 1585
  tmp___4 = strlen((char const   *)tmp___3);
  }
#line 1585
  if (tmp___4 > (size_t )tagmvlen) {
    {
#line 1586
    tmp___1 = gettext(tag_exit);
#line 1586
    tmp___2 = strlen((char const   *)tmp___1);
#line 1586
    tagmvlen = (unsigned int )tmp___2;
    }
  }
  {
#line 1590
  dirflush = 0;
#line 1591
  x1 = COLS / 2 - 37;
#line 1592
  x2 = COLS / 2 + 37;
#line 1593
  dsub___0 = mc_wopen(x1 - 1, LINES - 3, x2 + 1, LINES - 3, 0, 4 | (int )stdattr,
                      mfcolor, mbcolor, 0, 0, 1);
#line 1595
  w = mc_wopen(x1, 2, x2, LINES - 6, 1, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1596
  mc_wcursor(w, 0);
#line 1597
  tmp___5 = gettext("Dialing Directory");
#line 1597
  mc_wtitle(w, 1, (char const   *)tmp___5);
#line 1598
  tmp___6 = gettext("     Name            Number            Last on      Times Script\n");
#line 1598
  mc_wputs(w, (char const   *)tmp___6);
#line 1600
  i = (size_t )0;
  }
  {
#line 1600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1600
    if (! (i < sizeof(what___0) / sizeof(what___0[0]))) {
#line 1600
      goto while_break;
    }
    {
#line 1604
    tmp___7 = gettext((char const   *)what___0[i]);
#line 1604
    str = (char const   *)tmp___7;
#line 1605
    c___1 = str;
#line 1606
    j = (size_t )0;
    }
    {
#line 1606
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1606
      if (j < 7UL) {
#line 1606
        if (! ((int const   )*c___1 != 0)) {
#line 1606
          goto while_break___0;
        }
      } else {
#line 1606
        goto while_break___0;
      }
      {
#line 1608
      tmp___8 = one_mbtowc(& wc, c___1, (size_t )16);
#line 1608
      c___1 += tmp___8;
#line 1606
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1610
    what_lens___0[i] = (int )(c___1 - str);
#line 1611
    j = 8UL - j;
#line 1612
    what_padding___0[i][1] = (int )(j / 2UL);
#line 1613
    what_padding___0[i][0] = (int )(j - (size_t )what_padding___0[i][1]);
#line 1600
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1615
  mc_wlocate(dsub___0, position_dialing_directory, 0);
#line 1616
  i = (size_t )0;
  }
  {
#line 1616
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1616
    if (! (i < sizeof(what___0) / sizeof(what___0[0]))) {
#line 1616
      goto while_break___1;
    }
    {
#line 1617
    horiz_draw___0(i);
#line 1616
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1619
  w->sy1 = w->y1 + 1;
#line 1619
  w->sy2 = w->y1 + (w->ys - 1);
#line 1620
  w->doscroll = (char)0;
#line 1622
  prdir___0(w, top___0, top___0);
#line 1623
  mc_wlocate(w, position_dialing_directory, w->ys - 1);
#line 1624
  mc_wprintf(w, "%*.*s", tagmvlen, tagmvlen, tag_exit);
#line 1625
  dhili___0(position_dialing_directory, subm___0);
#line 1626
  dirflush = 1;
#line 1627
  mc_wredraw(dsub___0, 1);
  }
  again: 
  {
#line 1630
  mc_wcurbar(w, (cur___0 + 1) - top___0, 4 | (int )stdattr);
  }
#line 1631
  if (first___0) {
    {
#line 1632
    mc_wredraw(w, 1);
#line 1633
    first___0 = 0;
    }
  }
  {
#line 1635
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1635
    if (! (! quit___0)) {
#line 1635
      goto while_break___2;
    }
    {
#line 1636
    d = getno___0(cur___0);
#line 1637
    c___0 = wxgetch();
    }
    {
#line 1639
    if (c___0 == 107) {
#line 1639
      goto case_107;
    }
#line 1639
    if (c___0 == 269) {
#line 1639
      goto case_107;
    }
#line 1643
    if (c___0 == 106) {
#line 1643
      goto case_106;
    }
#line 1643
    if (c___0 == 272) {
#line 1643
      goto case_106;
    }
#line 1647
    if (c___0 == 104) {
#line 1647
      goto case_104;
    }
#line 1647
    if (c___0 == 270) {
#line 1647
      goto case_104;
    }
#line 1653
    if (c___0 == 108) {
#line 1653
      goto case_108;
    }
#line 1653
    if (c___0 == 271) {
#line 1653
      goto case_108;
    }
#line 1657
    if (c___0 == 2) {
#line 1657
      goto case_2;
    }
#line 1657
    if (c___0 == 268) {
#line 1657
      goto case_2;
    }
#line 1662
    if (c___0 == 6) {
#line 1662
      goto case_6;
    }
#line 1662
    if (c___0 == 274) {
#line 1662
      goto case_6;
    }
#line 1666
    if (c___0 == 32) {
#line 1666
      goto case_32;
    }
#line 1676
    if (c___0 == 10) {
#line 1676
      goto selected;
    }
#line 1676
    if (c___0 == 13) {
#line 1676
      goto selected;
    }
#line 1676
    if (c___0 == 27) {
#line 1676
      goto selected;
    }
#line 1680
    goto switch_default;
    case_107: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 1640
    cur___0 -= cur___0 > 0;
#line 1641
    goto switch_break;
    case_106: /* CIL Label */ 
    case_272: /* CIL Label */ 
#line 1644
    cur___0 += cur___0 < nrents___0 - 1;
#line 1645
    goto switch_break;
    case_104: /* CIL Label */ 
    case_270: /* CIL Label */ 
#line 1648
    subm___0 --;
#line 1649
    if (subm___0 < 0) {
#line 1650
      subm___0 = (int )(sizeof(what___0) / sizeof(what___0[0]) - 1UL);
    }
#line 1651
    goto switch_break;
    case_108: /* CIL Label */ 
    case_271: /* CIL Label */ 
#line 1654
    subm___0 = (int )((unsigned long )(subm___0 + 1) % (sizeof(what___0) / sizeof(what___0[0])));
#line 1655
    goto switch_break;
    case_2: /* CIL Label */ 
    case_268: /* CIL Label */ 
#line 1658
    pgud___0 = 1;
#line 1659
    quit___0 = 1;
#line 1660
    goto switch_break;
    case_6: /* CIL Label */ 
    case_274: /* CIL Label */ 
#line 1663
    pgud___0 = 2;
#line 1664
    quit___0 = 1;
#line 1665
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 1667
    mc_wlocate(w, 4, (cur___0 + 1) - top___0);
#line 1668
    d->flags = (char )((int )d->flags ^ 128);
#line 1669
    w->attr = (char )(4 | (int )stdattr);
    }
#line 1670
    if ((int )d->flags & 128) {
#line 1670
      tmp___9 = '>';
    } else {
#line 1670
      tmp___9 = ' ';
    }
    {
#line 1670
    mc_wprintf(w, "%c", tmp___9);
#line 1671
    w->attr = (char )((int )stdattr);
#line 1672
    cur___0 += cur___0 < nrents___0 - 1;
    }
#line 1673
    goto switch_break;
    selected: 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 1678
    if (subm___0 == 5) {
#line 1678
      quit___0 = 2;
    } else {
#line 1678
      quit___0 = 1;
    }
#line 1679
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1681
    i = (size_t )0;
    {
#line 1681
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1681
      if (! (i < sizeof(what___0) / sizeof(what___0[0]))) {
#line 1681
        goto while_break___3;
      }
      {
#line 1682
      tmp___10 = toupper(c___0);
#line 1682
      tmp___11 = gettext((char const   *)what___0[i]);
#line 1682
      tmp___12 = strchr((char const   *)tmp___11, tmp___10);
      }
#line 1682
      if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 1683
        subm___0 = (int )i;
#line 1684
        goto selected;
      }
#line 1681
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1687
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1690
    if (cur___0 != ocur___0) {
      {
#line 1691
      mc_wcurbar(w, (ocur___0 + 1) - top___0, (int )stdattr);
      }
    } else
#line 1690
    if (quit___0 == 1) {
      {
#line 1691
      mc_wcurbar(w, (ocur___0 + 1) - top___0, (int )stdattr);
      }
    }
#line 1693
    if (cur___0 < top___0) {
      {
#line 1694
      top___0 --;
#line 1695
      prdir___0(w, top___0, top___0);
      }
    }
#line 1697
    if (cur___0 - top___0 > w->ys - 3) {
      {
#line 1698
      top___0 ++;
#line 1699
      prdir___0(w, top___0, top___0);
      }
    }
#line 1701
    if (cur___0 != ocur___0) {
      {
#line 1702
      mc_wcurbar(w, (cur___0 + 1) - top___0, 4 | (int )stdattr);
      }
    }
    {
#line 1703
    ocur___0 = cur___0;
#line 1704
    dhili___0(position_dialing_directory, subm___0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1706
  quit___0 = 0;
#line 1708
  if (c___0 == 27) {
#line 1709
    if (changed) {
      {
#line 1710
      writedialdir();
      }
    }
    {
#line 1711
    mc_wclose(w, 1);
#line 1712
    mc_wclose(dsub___0, 1);
    }
#line 1713
    return;
  }
#line 1716
  if (pgud___0 == 1) {
#line 1717
    ocur___0 = top___0;
#line 1718
    top___0 -= w->ys - 2;
#line 1719
    if (top___0 < 0) {
#line 1720
      top___0 = 0;
    }
#line 1721
    cur___0 = top___0;
#line 1722
    pgud___0 = 0;
#line 1723
    if (ocur___0 != top___0) {
      {
#line 1724
      prdir___0(w, top___0, cur___0);
      }
    }
#line 1725
    ocur___0 = cur___0;
#line 1726
    goto again;
  }
#line 1728
  if (pgud___0 == 2) {
#line 1729
    ocur___0 = top___0;
#line 1730
    if (top___0 < (nrents___0 - w->ys) + 2) {
#line 1731
      top___0 += w->ys - 2;
#line 1732
      if (top___0 > (nrents___0 - w->ys) + 2) {
#line 1733
        top___0 = (nrents___0 - w->ys) + 2;
      }
#line 1734
      cur___0 = top___0;
    } else {
#line 1736
      cur___0 = nrents___0 - 1;
    }
#line 1737
    pgud___0 = 0;
#line 1738
    if (ocur___0 != top___0) {
      {
#line 1739
      prdir___0(w, top___0, cur___0);
      }
    }
#line 1740
    ocur___0 = cur___0;
#line 1741
    goto again;
  }
#line 1745
  if (subm___0 == 0) {
    {
#line 1746
    mc_wclose(w, 1);
#line 1747
    mc_wclose(dsub___0, 1);
    }
#line 1748
    if (changed) {
      {
#line 1749
      writedialdir();
      }
    }
#line 1752
    if (! ((int )d->flags & 128)) {
#line 1754
      d1 = d;
      {
#line 1754
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1754
        if (! d1) {
#line 1754
          goto while_break___4;
        }
#line 1755
        if ((int )d1->flags & 128) {
#line 1756
          d = d1;
#line 1757
          goto while_break___4;
        }
#line 1754
        d1 = d1->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1760
      if (! d1) {
#line 1761
        d1 = dialents;
        {
#line 1761
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1761
          if (d1) {
#line 1761
            if (! ((unsigned long )d1 != (unsigned long )d)) {
#line 1761
              goto while_break___5;
            }
          } else {
#line 1761
            goto while_break___5;
          }
#line 1762
          if ((int )d1->flags & 128) {
#line 1763
            d = d1;
#line 1764
            goto while_break___5;
          }
#line 1761
          d1 = d1->next;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
    {
#line 1768
    dial_entry(d);
    }
#line 1769
    return;
  }
#line 1772
  if (subm___0 == 1) {
    {
#line 1773
    tmp___13 = gettext("Find an entry");
#line 1773
    s___0 = input(tmp___13, dname);
    }
#line 1774
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 1775
      goto again;
    } else
#line 1774
    if ((int )*(s___0 + 0) == 0) {
#line 1775
      goto again;
    }
#line 1776
    x1 = 0;
#line 1777
    d = dialents;
    {
#line 1777
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1777
      if (! d) {
#line 1777
        goto while_break___6;
      }
      {
#line 1778
      tmp___14 = strstr((char const   *)(d->name), (char const   *)s___0);
      }
#line 1778
      if (tmp___14) {
#line 1779
        goto while_break___6;
      }
#line 1777
      d = d->next;
#line 1777
      x1 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1780
    if ((unsigned long )d == (unsigned long )((void *)0)) {
      {
#line 1781
      mc_wbell();
      }
#line 1782
      goto again;
    }
#line 1785
    ocur___0 = top___0;
#line 1786
    cur___0 = x1;
#line 1788
    if (cur___0 < top___0) {
#line 1788
      goto _L;
    } else
#line 1788
    if (cur___0 >= (top___0 + w->ys) - 2) {
      _L: /* CIL Label */ 
#line 1790
      top___0 = (cur___0 - w->ys / 2) + 1;
#line 1791
      if (top___0 < 0) {
#line 1792
        top___0 = 0;
      }
#line 1793
      if (top___0 > (nrents___0 - w->ys) + 2) {
#line 1794
        top___0 = (nrents___0 - w->ys) + 2;
      }
    }
#line 1796
    if (ocur___0 != top___0) {
      {
#line 1797
      prdir___0(w, top___0, top___0);
      }
    }
#line 1798
    ocur___0 = cur___0;
  }
#line 1802
  if (subm___0 == 2) {
    {
#line 1803
    d1 = mkstdent();
    }
#line 1804
    if ((unsigned long )d1 == (unsigned long )((struct dialent *)0)) {
      {
#line 1805
      mc_wbell();
      }
#line 1806
      goto again;
    }
#line 1808
    changed ++;
#line 1809
    cur___0 ++;
#line 1810
    ocur___0 = cur___0;
#line 1811
    d2 = d->next;
#line 1812
    d->next = d1;
#line 1813
    d1->next = d2;
#line 1815
    nrents___0 ++;
#line 1816
    if (cur___0 - top___0 > w->ys - 3) {
      {
#line 1817
      top___0 ++;
#line 1818
      prdir___0(w, top___0, top___0);
      }
    } else {
      {
#line 1820
      prdir___0(w, top___0, cur___0);
      }
    }
  }
#line 1825
  if (subm___0 == 3) {
    {
#line 1826
    dedit(d);
#line 1827
    changed ++;
#line 1828
    mc_wlocate(w, 0, (cur___0 + 1) - top___0);
    }
#line 1829
    if ((int )d->flags & 128) {
#line 1829
      tmp___15 = 16;
    } else {
#line 1829
      tmp___15 = ' ';
    }
    {
#line 1829
    mc_wprintf(w, fmt, cur___0 + 1, tmp___15, d->name, d->number, d->lastdate, d->lasttime,
               d->count, d->script);
    }
  }
#line 1834
  if (subm___0 == 4) {
    {
#line 1834
    tmp___17 = gettext("Remove entry?");
#line 1834
    tmp___18 = ask((char const   *)tmp___17, d_yesno___0);
    }
#line 1834
    if (tmp___18 == 0) {
#line 1835
      changed ++;
#line 1836
      if (nrents___0 == 1) {
        {
#line 1837
        free((void *)((char *)d));
#line 1838
        dialents = mkstdent();
#line 1838
        d = dialents;
#line 1839
        prdir___0(w, top___0, top___0);
        }
#line 1840
        goto again;
      }
#line 1842
      if (cur___0 == 0) {
#line 1843
        dialents = d->next;
      } else {
        {
#line 1845
        tmp___16 = getno___0(cur___0 - 1);
#line 1845
        tmp___16->next = d->next;
        }
      }
      {
#line 1846
      free((void *)((char *)d));
#line 1847
      nrents___0 --;
      }
#line 1848
      if (cur___0 - top___0 == 0) {
#line 1848
        if (top___0 == nrents___0) {
          {
#line 1849
          top___0 --;
#line 1850
          cur___0 --;
#line 1851
          prdir___0(w, top___0, top___0);
          }
        } else {
#line 1848
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1853
        if (cur___0 == nrents___0) {
#line 1854
          cur___0 --;
        }
        {
#line 1855
        prdir___0(w, top___0, cur___0);
        }
      }
#line 1857
      if (nrents___0 - top___0 <= w->ys - 3) {
        {
#line 1858
        mc_wlocate(w, 0, (nrents___0 - top___0) + 1);
#line 1859
        mc_wclreol(w);
        }
      }
#line 1861
      ocur___0 = cur___0;
    }
  }
#line 1865
  if (subm___0 == 5) {
    {
#line 1866
    mc_wlocate(w, position_dialing_directory, w->ys - 1);
#line 1867
    mc_wprintf(w, "%*.*s", tagmvlen, tagmvlen, move_exit);
#line 1868
    cur___0 = move_entry(w, d, cur___0, & top___0);
    }
#line 1869
    if (cur___0 != ocur___0) {
#line 1870
      changed ++;
    }
    {
#line 1871
    ocur___0 = cur___0;
#line 1872
    mc_wlocate(w, position_dialing_directory, w->ys - 1);
#line 1873
    mc_wprintf(w, "%*.*s", tagmvlen, tagmvlen, tag_exit);
    }
  }
#line 1877
  if (subm___0 == 6) {
    {
#line 1878
    tmp___19 = gettext("Enter number");
#line 1878
    s___0 = input(tmp___19, manual);
    }
#line 1879
    if (s___0) {
#line 1879
      if (*s___0) {
#line 1880
        if (changed) {
          {
#line 1881
          writedialdir();
          }
        }
        {
#line 1882
        mc_wclose(w, 1);
#line 1883
        mc_wclose(dsub___0, 1);
#line 1885
        strncpy((char */* __restrict  */)(d_man->number), (char const   */* __restrict  */)(manual),
                sizeof(d_man->number));
#line 1886
        dial(d_man, (struct dialent **)((void *)0));
        }
#line 1887
        if ((int )mpars[57].value[0] == 108) {
          {
#line 1888
          show_status();
          }
        }
#line 1889
        return;
      }
    }
  }
#line 1892
  goto again;
}
}
#line 210 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int help(void) ;
#line 223
char *esc_key(void) ;
#line 29 "/home/wheatley/newnew/temp/minicom-2.7/src/help.c"
int help(void) 
{ 
  WIN *w ;
  int c___0 ;
  int x1 ;
  int x2 ;
  char const   *s___0 ;
  char buf___6[40] ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;

  {
  {
#line 37
  x1 = COLS / 2 - 34;
#line 38
  x2 = COLS / 2 + 32;
#line 39
  w = mc_wopen(x1, 2, x2, 18, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 41
  tmp = gettext("Minicom Command Summary");
#line 41
  s___0 = (char const   *)tmp;
#line 42
  tmp___0 = strlen(s___0);
#line 42
  mc_wlocate(w, (int )((size_t )((x2 - x1) / 2) - tmp___0 / 2UL), 0);
#line 43
  mc_wputs(w, s___0);
#line 45
  tmp___1 = esc_key();
#line 45
  tmp___2 = gettext("Commands can be called by %s<key>");
#line 45
  snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)tmp___2,
           tmp___1);
#line 46
  buf___6[sizeof(buf___6) - 1UL] = (char)0;
#line 47
  tmp___3 = strlen((char const   *)(buf___6));
#line 47
  mc_wlocate(w, (int )((size_t )((x2 - x1) / 2) - tmp___3 / 2UL), 2);
#line 48
  mc_wprintf(w, "%s", buf___6);
#line 50
  mc_wlocate(w, 15, 4);
#line 51
  tmp___4 = gettext("Main Functions");
#line 51
  mc_wputs(w, (char const   *)tmp___4);
#line 52
  mc_wlocate(w, 47, 4);
#line 53
  tmp___5 = gettext("Other Functions");
#line 53
  mc_wputs(w, (char const   *)tmp___5);
#line 54
  mc_wlocate(w, 0, 6);
#line 55
  tmp___6 = gettext(" Dialing directory..D  run script (Go)....G | Clear Screen.......C\n");
#line 55
  mc_wputs(w, (char const   *)tmp___6);
#line 56
  tmp___7 = gettext(" Send files.........S  Receive files......R | cOnfigure Minicom..O\n");
#line 56
  mc_wputs(w, (char const   *)tmp___7);
#line 57
  tmp___8 = gettext(" comm Parameters....P  Add linefeed.......A | ");
#line 57
  mc_wputs(w, (char const   *)tmp___8);
#line 59
  tmp___9 = gettext("Suspend minicom....J\n");
#line 59
  mc_wputs(w, (char const   *)tmp___9);
#line 63
  tmp___10 = gettext(" Capture on/off.....L  Hangup.............H | eXit and reset.....X\n");
#line 63
  mc_wputs(w, (char const   *)tmp___10);
#line 64
  tmp___11 = gettext(" send break.........F  initialize Modem...M | Quit with no reset.Q\n");
#line 64
  mc_wputs(w, (char const   *)tmp___11);
#line 65
  tmp___12 = gettext(" Terminal settings..T  run Kermit.........K | Cursor key mode....I\n");
#line 65
  mc_wputs(w, (char const   *)tmp___12);
#line 66
  tmp___13 = gettext(" lineWrap on/off....W");
#line 66
  mc_wputs(w, (char const   *)tmp___13);
#line 67
  tmp___14 = gettext("  local Echo on/off..E | Help screen........Z\n");
#line 67
  mc_wputs(w, (char const   *)tmp___14);
#line 68
  tmp___15 = gettext(" Paste file.........Y  Timestamp toggle...N | scroll Back........B\n");
#line 68
  mc_wputs(w, (char const   *)tmp___15);
#line 69
  tmp___16 = gettext(" Add Carriage Ret...U");
#line 69
  mc_wputs(w, (char const   *)tmp___16);
#line 71
  tmp___17 = gettext("Select function or press Enter for none.");
#line 71
  s___0 = (char const   *)tmp___17;
#line 72
  tmp___18 = strlen(s___0);
#line 72
  mc_wlocate(w, (int )((size_t )((x2 - x1) / 2) - tmp___18 / 2UL), 16);
#line 73
  mc_wputs(w, s___0);
#line 85
  mc_wredraw(w, 1);
#line 87
  c___0 = wxgetch();
#line 88
  mc_wclose(w, 1);
  }
#line 89
  return (c___0);
}
}
#line 41 "/home/wheatley/newnew/temp/minicom-2.7/src/common.c"
static char buf___3[4096]  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/wildmat.c"
static int Star(char const   *s___0 , char const   *p ) ;
#line 68
static int DoMatch(char const   *s___0 , char const   *p ) ;
#line 70 "/home/wheatley/newnew/temp/minicom-2.7/src/wildmat.c"
static int Star(char const   *s___0 , char const   *p ) 
{ 
  int retval ;

  {
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 74
    retval = DoMatch(s___0, p);
    }
#line 74
    if (! (retval == 0)) {
#line 74
      goto while_break;
    }
#line 75
    s___0 ++;
#line 75
    if ((int const   )*s___0 == 0) {
#line 76
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (retval);
}
}
#line 81 "/home/wheatley/newnew/temp/minicom-2.7/src/wildmat.c"
static int DoMatch(char const   *s___0 , char const   *p ) 
{ 
  register int last___0 ;
  register int matched ;
  register int reverse ;
  char const   *ss ;
  int escaped ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! *p) {
#line 89
      goto while_break;
    }
#line 91
    if ((int const   )*s___0 == 0) {
#line 92
      if ((int const   )*p == 42) {
#line 92
        p ++;
#line 92
        if ((int const   )*p == 0) {
#line 92
          tmp = 1;
        } else {
#line 92
          tmp = -1;
        }
      } else {
#line 92
        tmp = -1;
      }
#line 92
      return (tmp);
    }
    {
#line 96
    if ((int const   )*p == 92) {
#line 96
      goto case_92;
    }
#line 106
    if ((int const   )*p == 63) {
#line 106
      goto case_63;
    }
#line 110
    if ((int const   )*p == 42) {
#line 110
      goto case_42;
    }
#line 114
    if ((int const   )*p == 91) {
#line 114
      goto case_91;
    }
#line 101
    goto switch_default;
    case_92: /* CIL Label */ 
#line 98
    p ++;
    switch_default: /* CIL Label */ 
#line 102
    if ((int const   )*s___0 != (int const   )*p) {
#line 103
      return (0);
    }
#line 104
    goto __Cont;
    case_63: /* CIL Label */ 
#line 108
    goto __Cont;
    case_42: /* CIL Label */ 
#line 112
    p ++;
#line 112
    if (*p) {
      {
#line 112
      tmp___0 = Star(s___0, p);
#line 112
      tmp___1 = tmp___0;
      }
    } else {
#line 112
      tmp___1 = 1;
    }
#line 112
    return (tmp___1);
    case_91: /* CIL Label */ 
#line 116
    reverse = (int const   )*(p + 1) == 33;
#line 116
    if (reverse) {
#line 117
      p ++;
    }
#line 118
    ss = p + 1;
#line 120
    last___0 = 256;
#line 120
    matched = 0;
#line 120
    escaped = matched;
    {
#line 120
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 120
      p ++;
#line 120
      if (! *p) {
#line 120
        goto while_break___0;
      }
#line 121
      if ((int const   )*p == 93) {
#line 121
        if (! escaped) {
#line 121
          if (! ((unsigned long )p == (unsigned long )ss)) {
#line 122
            goto while_break___0;
          }
        }
      }
#line 123
      if (escaped) {
#line 124
        escaped = 0;
      } else
#line 125
      if ((int const   )*p == 92) {
#line 126
        escaped = 1;
#line 127
        goto __Cont___0;
      }
#line 132
      if ((int const   )*p == 45) {
#line 132
        p ++;
#line 132
        if ((int const   )*s___0 <= (int const   )*p) {
#line 132
          if ((int const   )*s___0 >= (int const   )last___0) {
#line 132
            tmp___2 = 1;
          } else {
#line 132
            tmp___2 = 0;
          }
        } else {
#line 132
          tmp___2 = 0;
        }
#line 132
        tmp___3 = tmp___2;
      } else {
#line 132
        tmp___3 = (int const   )*s___0 == (int const   )*p;
      }
#line 132
      if (tmp___3) {
#line 133
        matched = 1;
      }
      __Cont___0: /* CIL Label */ 
#line 120
      last___0 = (int )*p;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 136
    if (matched == reverse) {
#line 137
      return (0);
    }
#line 138
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 89
    s___0 ++;
#line 89
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return ((int const   )*s___0 == 0);
}
}
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/wildmat.c"
int wildmat(char const   *s___0 , char const   *p ) 
{ 
  int tmp ;

  {
#line 153
  if ((int const   )*p == 63) {
#line 153
    goto _L;
  } else
#line 153
  if ((int const   )*p == 42) {
    _L: /* CIL Label */ 
#line 153
    if ((int const   )*s___0 == 46) {
#line 154
      return (0);
    } else {
      {
#line 156
      tmp = DoMatch(s___0, p);
      }
#line 156
      return (tmp == 1);
    }
  } else {
    {
#line 156
    tmp = DoMatch(s___0, p);
    }
#line 156
    return (tmp == 1);
  }
}
}
#line 63 "/usr/include/termcap.h"
extern char *tgetstr(char const   * , char ** ) ;
#line 65
extern int tgetent(char * , char const   * ) ;
#line 72 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
char *_tptr ;
#line 296 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int pendingkeys ;
#line 39 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static struct key _keys[23]  ;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int keys_in_buf  ;
#line 42 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static char erasechar___0  ;
#line 43 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int gotalrm  ;
#line 44 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
int pendingkeys  =    0;
#line 45 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
int io_pending  =    0;
#line 51 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static char const   *func_key[24]  = 
#line 51
  {      "",      "k1",      "k2",      "k3", 
        "k4",      "k5",      "k6",      "k7", 
        "k8",      "k9",      "k0",      "kh", 
        "kP",      "ku",      "kl",      "kr", 
        "kd",      "kH",      "kN",      "kI", 
        "kD",      "F1",      "F2",      (char const   *)((void *)0)};
#line 63 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int isconsole  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int testconsole(void) 
{ 
  int info ;
  int tmp ;

  {
  {
#line 70
  tmp = ioctl(0, 19249UL, & info);
  }
#line 70
  return (tmp == 0);
}
}
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static char buf___4[32]  ;
#line 80
static int cread(char *c___0 ) ;
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int idx  =    0;
#line 81 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int lastread  =    0;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int cread(char *c___0 ) 
{ 
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
#line 83
  if (idx > 0) {
#line 83
    if (idx < lastread) {
#line 84
      tmp = idx;
#line 84
      idx ++;
#line 84
      *c___0 = buf___4[tmp];
#line 85
      keys_in_buf --;
#line 86
      if (keys_in_buf == 0) {
#line 86
        if (pendingkeys == 0) {
#line 87
          io_pending = 0;
        }
      }
#line 88
      return (lastread);
    }
  }
#line 90
  idx = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    tmp___0 = read(0, (void *)(buf___4), (size_t )32);
#line 92
    lastread = (int )tmp___0;
#line 93
    keys_in_buf = lastread - 1;
    }
#line 91
    if (lastread < 0) {
      {
#line 91
      tmp___1 = __errno_location();
      }
#line 91
      if (! (*tmp___1 == 4)) {
#line 91
        goto while_break;
      }
    } else {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  *c___0 = buf___4[0];
#line 97
  if (lastread > 1) {
#line 98
    idx = 1;
#line 99
    io_pending ++;
  }
#line 101
  return (lastread);
}
}
#line 108 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static char *cbuf  ;
#line 108 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static char *tbuf  ;
#line 105 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static void _initkeys(void) 
{ 
  int i ;
  char *term ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
#line 111
  if ((unsigned long )_tptr == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___0 = malloc((size_t )512);
#line 112
    tbuf = (char *)tmp___0;
    }
#line 112
    if ((unsigned long )tbuf == (unsigned long )((void *)0)) {
      {
#line 114
      tmp = gettext("Out of memory.\n");
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 115
      exit(1);
      }
    } else {
      {
#line 112
      tmp___1 = malloc((size_t )2048);
#line 112
      cbuf = (char *)tmp___1;
      }
#line 112
      if ((unsigned long )cbuf == (unsigned long )((void *)0)) {
        {
#line 114
        tmp = gettext("Out of memory.\n");
#line 114
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
#line 115
        exit(1);
        }
      }
    }
    {
#line 117
    term = getenv("TERM");
#line 118
    tmp___2 = tgetent(cbuf, (char const   *)term);
    }
    {
#line 119
    if (tmp___2 == 0) {
#line 119
      goto case_0;
    }
#line 122
    if (tmp___2 == -1) {
#line 122
      goto case_neg_1;
    }
#line 125
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 120
    tmp___3 = gettext("No termcap entry.\n");
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3);
#line 121
    exit(1);
    }
    case_neg_1: /* CIL Label */ 
    {
#line 123
    tmp___4 = gettext("No /etc/termcap present!\n");
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 124
    exit(1);
    }
    switch_default: /* CIL Label */ 
#line 126
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 128
    _tptr = tbuf;
  }
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! func_key[i]) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp___5 = tgetstr(func_key[i], & _tptr);
#line 132
    _keys[i].cap = tmp___5;
    }
#line 132
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 133
      _keys[i].cap = (char *)"";
    }
    {
#line 134
    tmp___6 = strlen((char const   *)_keys[i].cap);
#line 134
    _keys[i].len = (char )tmp___6;
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  isconsole = testconsole();
  }
#line 139
  return;
}
}
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static unsigned char mem[8]  ;
#line 152 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int leftmem  =    0;
#line 153 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
static int init___0  =    0;
#line 145 "/home/wheatley/newnew/temp/minicom-2.7/src/wkeys.c"
int wxgetch(void) 
{ 
  int f ;
  int g ;
  int match ;
  int len ;
  char c___0 ;
  int nfound ;
  int start_match ;
  struct timeval timeout ;
  fd_set readfds ;
  int tmp ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 148
  match = 1;
#line 154
  nfound = 0;
#line 162
  if (init___0 == 0) {
    {
#line 163
    _initkeys();
#line 164
    init___0 ++;
#line 165
    tmp = setcbreak(3);
#line 165
    erasechar___0 = (char )tmp;
    }
  }
#line 169
  if (leftmem > 0) {
#line 170
    leftmem --;
#line 171
    if (leftmem == 0) {
#line 172
      pendingkeys = 0;
    }
#line 173
    if (pendingkeys == 0) {
#line 173
      if (keys_in_buf == 0) {
#line 174
        io_pending = 0;
      }
    }
#line 175
    return ((int )mem[leftmem]);
  }
#line 177
  gotalrm = 0;
#line 178
  pendingkeys = 0;
#line 180
  len = 1;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (len < 8) {
#line 180
      if (! match) {
#line 180
        goto while_break;
      }
    } else {
#line 180
      goto while_break;
    }
#line 182
    if (len > 1) {
#line 182
      if (keys_in_buf == 0) {
#line 187
        timeout.tv_sec = (__time_t )0;
#line 188
        timeout.tv_usec = (__suseconds_t )400000;
        {
#line 189
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 189
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                               "1" (& readfds.fds_bits[0]): "memory");
#line 189
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 190
        readfds.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 191
        nfound = select(1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
        }
#line 191
        if (! nfound) {
#line 192
          goto while_break;
        }
      }
    }
    {
#line 196
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 196
      nfound = cread(& c___0);
      }
#line 196
      if (nfound < 0) {
        {
#line 196
        tmp___0 = __errno_location();
        }
#line 196
        if (*tmp___0 == 4) {
#line 196
          if (! (! gotalrm)) {
#line 196
            goto while_break___1;
          }
        } else {
#line 196
          goto while_break___1;
        }
      } else {
#line 196
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 203
    if (nfound < 1) {
#line 204
      return (-1);
    }
#line 206
    if (len == 1) {
#line 208
      if ((int )c___0 == 10) {
#line 209
        return ((int )c___0);
      }
#line 210
      if ((int )c___0 == (int )erasechar___0) {
#line 211
        return ('\b');
      }
    }
#line 215
    if (isconsole) {
#line 215
      if (nfound == 1) {
#line 215
        if (len == 1) {
#line 216
          return ((int )c___0);
        }
      }
    }
#line 219
    if (isconsole) {
#line 219
      if (nfound == 2) {
#line 219
        if (len == 1) {
#line 219
          if ((int )c___0 == 27) {
#line 219
            if (escape == 27) {
              {
#line 220
              cread(& c___0);
              }
#line 221
              return ((int )c___0 + 512);
            }
          }
        }
      }
    }
#line 224
    mem[len - 1] = (unsigned char )c___0;
#line 225
    match = 0;
#line 237
    start_match = 0;
#line 238
    f = 0;
    {
#line 238
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 238
      if (! (f < 23)) {
#line 238
        goto while_break___2;
      }
#line 244
      if ((int )_keys[f].len >= len) {
        {
#line 244
        tmp___1 = strncmp((char const   *)_keys[f].cap, (char const   *)((char *)(mem)),
                          (size_t )len);
        }
#line 244
        if (tmp___1 == 0) {
#line 248
          match ++;
#line 249
          if ((int )_keys[f].len == len) {
#line 250
            return (f + 256);
          }
        }
      }
#line 254
      if ((int )_keys[f].len > 1) {
#line 254
        if (len == 2) {
          {
#line 254
          tmp___2 = strncmp((char const   *)_keys[f].cap, (char const   *)((char *)(mem)),
                            (size_t )2);
          }
#line 254
          if (tmp___2 == 0) {
#line 256
            start_match ++;
          }
        }
      }
#line 238
      f ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 259
    if (! isconsole) {
#line 263
      if (escape == 27) {
#line 263
        if (! start_match) {
#line 263
          if (len == 2) {
#line 263
            if ((int )mem[0] == 27) {
#line 264
              return ((int )c___0 + 512);
            }
          }
        }
      }
    }
#line 180
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  len --;
#line 269
  if (len == 1) {
#line 270
    return ((int )mem[0]);
  }
#line 272
  pendingkeys ++;
#line 273
  io_pending ++;
#line 276
  f = 0;
  {
#line 276
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 276
    if (! (f < len / 2)) {
#line 276
      goto while_break___3;
    }
#line 277
    g = (int )mem[f];
#line 278
    mem[f] = mem[(len - f) - 1];
#line 279
    mem[(len - f) - 1] = (unsigned char )g;
#line 276
    f ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 281
  leftmem = len - 1;
#line 282
  return ((int )mem[leftmem]);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.c"
static int g_sortflags  ;
#line 72 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.c"
static int namecmpr(GETSDIR_ENTRY *d1 , GETSDIR_ENTRY *d2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 74
  if (g_sortflags & 24) {
#line 75
    if ((d1->mode & 61440U) == 16384U) {
#line 75
      if (! ((d2->mode & 61440U) == 16384U)) {
#line 76
        if (g_sortflags & 8) {
#line 76
          tmp = -1;
        } else {
#line 76
          tmp = 1;
        }
#line 76
        return (tmp);
      } else {
#line 75
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 77
    if ((d2->mode & 61440U) == 16384U) {
#line 77
      if (! ((d1->mode & 61440U) == 16384U)) {
#line 78
        if (g_sortflags & 8) {
#line 78
          tmp___0 = 1;
        } else {
#line 78
          tmp___0 = -1;
        }
#line 78
        return (tmp___0);
      }
    }
  }
#line 81
  if (g_sortflags & 32) {
    {
#line 81
    tmp___1 = strcmp((char const   *)(d2->fname), (char const   *)(d1->fname));
#line 81
    tmp___3 = tmp___1;
    }
  } else {
    {
#line 81
    tmp___2 = strcmp((char const   *)(d1->fname), (char const   *)(d2->fname));
#line 81
    tmp___3 = tmp___2;
    }
  }
#line 81
  return (tmp___3);
}
}
#line 105 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.c"
static int timecmpr(GETSDIR_ENTRY *d1 , GETSDIR_ENTRY *d2 ) 
{ 
  int tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
#line 107
  if (g_sortflags & 24) {
#line 108
    if ((d1->mode & 61440U) == 16384U) {
#line 108
      if (! ((d2->mode & 61440U) == 16384U)) {
#line 109
        if (g_sortflags & 8) {
#line 109
          tmp = -1;
        } else {
#line 109
          tmp = 1;
        }
#line 109
        return (tmp);
      } else {
#line 108
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 110
    if ((d2->mode & 61440U) == 16384U) {
#line 110
      if (! ((d1->mode & 61440U) == 16384U)) {
#line 111
        if (g_sortflags & 8) {
#line 111
          tmp___0 = 1;
        } else {
#line 111
          tmp___0 = -1;
        }
#line 111
        return (tmp___0);
      }
    }
  }
#line 114
  if (g_sortflags & 32) {
#line 114
    tmp___1 = d2->time - d1->time;
  } else {
#line 114
    tmp___1 = d1->time - d2->time;
  }
#line 114
  return ((int )tmp___1);
}
}
#line 195 "/home/wheatley/newnew/temp/minicom-2.7/src/getsdir.c"
int getsdir(char const   *dirpath , char const   *pattern , int sortflags , mode_t modemask ,
            GETSDIR_ENTRY **datptr , int *len ) 
{ 
  unsigned int cnt ;
  DIR *dirp ;
  struct dirent *dp ;
  struct stat statbuf ;
  char fpath[8192] ;
  int cmprstat ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int l ;
  size_t tmp___3 ;

  {
  {
#line 198
  cnt = 0U;
#line 206
  g_sortflags = sortflags;
#line 207
  *len = 0;
#line 210
  dirp = opendir(dirpath);
  }
#line 210
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 211
    return (-1);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    dp = readdir(dirp);
    }
#line 213
    if (! dp) {
#line 213
      goto while_break;
    }
    {
#line 215
    tmp = strcmp((char const   *)(dp->d_name), ".");
    }
#line 215
    if (! tmp) {
#line 216
      goto while_continue;
    }
#line 218
    if (sortflags & 1) {
      {
#line 218
      tmp___0 = strcmp((char const   *)(dp->d_name), "..");
      }
#line 218
      if (tmp___0) {
#line 218
        goto _L;
      } else {
#line 219
        cmprstat = 1;
      }
    } else
    _L: /* CIL Label */ 
#line 220
    if (pattern) {
#line 220
      if (*pattern) {
        {
#line 221
        cmprstat = wildmat((char const   *)(dp->d_name), pattern);
        }
      } else {
#line 223
        cmprstat = 1;
      }
    } else {
#line 223
      cmprstat = 1;
    }
#line 225
    if (cmprstat) {
      {
#line 227
      tmp___1 = realloc((void *)*datptr, sizeof(*(*datptr)) * (unsigned long )(cnt + 1U));
#line 227
      *datptr = (GETSDIR_ENTRY *)tmp___1;
      }
#line 228
      if (! *datptr) {
        {
#line 230
        free((void *)*datptr);
        }
#line 231
        return (-1);
      }
      {
#line 235
      strncpy((char */* __restrict  */)((*datptr + cnt)->fname), (char const   */* __restrict  */)(dp->d_name),
              (size_t )255);
#line 238
      snprintf((char */* __restrict  */)(fpath), sizeof(fpath), (char const   */* __restrict  */)"%s/%s",
               dirpath, dp->d_name);
#line 239
      tmp___2 = stat((char const   */* __restrict  */)(fpath), (struct stat */* __restrict  */)(& statbuf));
      }
#line 239
      if (tmp___2) {
#line 240
        goto while_continue;
      }
#line 242
      if (modemask) {
#line 242
        if (! ((61440U & modemask) & statbuf.st_mode)) {
#line 243
          goto while_continue;
        }
      }
      {
#line 246
      tmp___3 = strlen((char const   *)(dp->d_name));
#line 246
      l = (int )tmp___3;
      }
#line 246
      if (l > *len) {
#line 247
        *len = l;
      }
#line 249
      (*datptr + cnt)->time = statbuf.st_mtim.tv_sec;
#line 250
      (*datptr + cnt)->mode = statbuf.st_mode;
#line 251
      (*datptr + cnt)->cflags = (ushort )0;
#line 253
      cnt ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  closedir(dirp);
  }
#line 260
  if (cnt) {
#line 260
    if (sortflags) {
#line 261
      if (sortflags & 2) {
        {
#line 262
        qsort((void *)*datptr, (size_t )cnt, sizeof(GETSDIR_ENTRY ), (int (*)(void const   * ,
                                                                              void const   * ))(& namecmpr));
        }
      } else
#line 264
      if (sortflags & 4) {
        {
#line 265
        qsort((void *)*datptr, (size_t )cnt, sizeof(GETSDIR_ENTRY ), (int (*)(void const   * ,
                                                                              void const   * ))(& timecmpr));
        }
      }
    }
  }
#line 269
  return ((int )cnt);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 149 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
void mc_wleave(void) ;
#line 150
void mc_wreturn(void) ;
#line 164
int mc_wselect(int x , int y , char const   * const  *choices , void (* const  *funlist)(void) ,
               char const   *title , int attr , int fg , int bg ) ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
WIN *st ;
#line 77
short lines ;
#line 88
int tempst ;
#line 92
char lockfile[128] ;
#line 103
char scr_name[256] ;
#line 104
char scr_user[33] ;
#line 105
char scr_passwd[33] ;
#line 108
char *dial_tty ;
#line 205
int fastexec(char *cmd ) ;
#line 231
void scriptname(char const   *s___0 ) ;
#line 272
int m_wait(int *stt ) ;
#line 280
void updown(int what___1 , int nr ) ;
#line 281
int mc_setenv(char const   *name , char const   *value ) ;
#line 282
void kermit(void) ;
#line 284
int paste_file(void) ;
#line 302
int lockfile_create(int no_msgs ) ;
#line 303
void lockfile_remove(void) ;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int udpid  ;
#line 41 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int script_running  ;
#line 50 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static char odir[256]  ;
#line 51
static int mcd(char *dir ) ;
#line 51 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int init___1  =    0;
#line 46 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int mcd(char *dir ) 
{ 
  char buf___6[256] ;
  char err[50] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 53
  if (! init___1) {
#line 54
    if ((int )*dir == 0) {
#line 55
      return (0);
    }
    {
#line 56
    init___1 = 1;
#line 57
    tmp = getcwd(odir, sizeof(odir));
    }
#line 57
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 58
      return (-1);
    }
  }
#line 60
  if ((int )*dir == 0) {
    {
#line 61
    tmp___0 = chdir((char const   *)(odir));
    }
#line 61
    if (tmp___0 == -1) {
#line 62
      return (-1);
    }
#line 63
    return (0);
  }
#line 66
  if ((int )*dir != 47) {
    {
#line 67
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%s/%s",
             homedir, dir);
#line 68
    dir = buf___6;
    }
  }
  {
#line 70
  tmp___2 = chdir((char const   *)dir);
  }
#line 70
  if (tmp___2 < 0) {
    {
#line 73
    tmp___1 = gettext("Cannot chdir to %.30s");
#line 73
    snprintf((char */* __restrict  */)(err), sizeof(err), (char const   */* __restrict  */)tmp___1,
             dir);
#line 74
    err[sizeof(err) - 1UL] = (char)0;
#line 75
    werror("%s", err);
    }
#line 76
    return (-1);
  }
#line 78
  return (0);
}
}
#line 84 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static void udcatch(int dummy ) 
{ 


  {
  {
#line 87
  signal(2, & udcatch);
  }
#line 88
  if (udpid) {
    {
#line 89
    kill(udpid, 9);
    }
  }
#line 90
  script_running = 0;
#line 91
  return;
}
}
#line 100 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static char *translate(char *s___0 ) 
{ 
  char *ptr___1 ;
  char *translation ;
  size_t translation_length ;
  char str_portfd[8] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 108
  translation_length = (size_t )0;
#line 109
  ptr___1 = s___0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! ((int )*ptr___1 != 0)) {
#line 109
      goto while_break;
    }
#line 110
    if ((int )*ptr___1 != 37) {
#line 111
      translation_length ++;
    } else {
#line 114
      ptr___1 ++;
      {
#line 116
      if ((int )*ptr___1 == 108) {
#line 116
        goto case_108;
      }
#line 120
      if ((int )*ptr___1 == 98) {
#line 120
        goto case_98;
      }
#line 124
      if ((int )*ptr___1 == 102) {
#line 124
        goto case_102;
      }
#line 129
      goto switch_default;
      case_108: /* CIL Label */ 
      {
#line 117
      tmp = strlen((char const   *)dial_tty);
#line 117
      translation_length += tmp;
      }
#line 118
      goto switch_break;
      case_98: /* CIL Label */ 
      {
#line 121
      tmp___0 = strlen((char const   *)(mpars[28].value));
#line 121
      translation_length += tmp___0;
      }
#line 122
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 125
      sprintf((char */* __restrict  */)(str_portfd), (char const   */* __restrict  */)"%d",
              (int )portfd);
#line 126
      tmp___1 = strlen((char const   *)(str_portfd));
#line 126
      translation_length += tmp___1;
      }
#line 127
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 130
      translation_length += 2UL;
#line 131
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 109
    ptr___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp___2 = malloc(translation_length + 1UL);
#line 136
  translation = (char *)tmp___2;
  }
#line 137
  if ((unsigned long )translation == (unsigned long )((void *)0)) {
    {
#line 138
    do_log("out of memory");
    }
#line 139
    return ((char *)((void *)0));
  }
#line 143
  ptr___1 = translation;
  {
#line 143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 143
    if (! ((int )*s___0 != 0)) {
#line 143
      goto while_break___0;
    }
#line 144
    if ((int )*s___0 != 37) {
#line 145
      tmp___3 = ptr___1;
#line 145
      ptr___1 ++;
#line 145
      *tmp___3 = *s___0;
#line 146
      goto __Cont;
    }
#line 148
    s___0 ++;
    {
#line 149
    if ((int )*s___0 == 108) {
#line 149
      goto case_108___0;
    }
#line 154
    if ((int )*s___0 == 98) {
#line 154
      goto case_98___0;
    }
#line 159
    if ((int )*s___0 == 102) {
#line 159
      goto case_102___0;
    }
#line 165
    goto switch_default___0;
    case_108___0: /* CIL Label */ 
    {
#line 150
    strcpy((char */* __restrict  */)ptr___1, (char const   */* __restrict  */)dial_tty);
#line 151
    tmp___4 = strlen((char const   *)dial_tty);
#line 151
    ptr___1 += tmp___4;
    }
#line 152
    goto switch_break___0;
    case_98___0: /* CIL Label */ 
    {
#line 155
    strcpy((char */* __restrict  */)ptr___1, (char const   */* __restrict  */)(mpars[28].value));
#line 156
    tmp___5 = strlen((char const   *)(mpars[28].value));
#line 156
    ptr___1 += tmp___5;
    }
#line 157
    goto switch_break___0;
    case_102___0: /* CIL Label */ 
    {
#line 160
    sprintf((char */* __restrict  */)(str_portfd), (char const   */* __restrict  */)"%d",
            (int )portfd);
#line 161
    strcpy((char */* __restrict  */)ptr___1, (char const   */* __restrict  */)(str_portfd));
#line 162
    tmp___6 = strlen((char const   *)(str_portfd));
#line 162
    ptr___1 += tmp___6;
    }
#line 163
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 166
    tmp___7 = ptr___1;
#line 166
    ptr___1 ++;
#line 166
    *tmp___7 = (char )'%';
#line 167
    tmp___8 = ptr___1;
#line 167
    ptr___1 ++;
#line 167
    *tmp___8 = *s___0;
#line 168
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 143
    s___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 171
  *ptr___1 = (char )'\000';
#line 173
  return (translation);
}
}
#line 180 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
char *trim(char *outstring , char *instring , int n ) 
{ 
  char *p ;
  char *ip ;
  char *op ;
  char *np ;

  {
#line 187
  ip = instring;
#line 188
  np = ip + n;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if ((int )*ip <= 32) {
#line 189
      if (! ((unsigned long )ip < (unsigned long )np)) {
#line 189
        goto while_break;
      }
    } else {
#line 189
      goto while_break;
    }
#line 190
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  op = outstring;
#line 193
  np = op + n;
  {
#line 194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 194
    if ((int )*ip >= 32) {
#line 194
      if (! ((unsigned long )op <= (unsigned long )np)) {
#line 194
        goto while_break___0;
      }
    } else {
#line 194
      goto while_break___0;
    }
#line 195
    *op = *ip;
#line 196
    ip ++;
#line 197
    op ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 200
  if ((unsigned long )op < (unsigned long )np) {
#line 201
    *op = (char)0;
  }
  {
#line 203
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 203
    if ((unsigned long )op > (unsigned long )outstring) {
#line 203
      if (! ((int )*op <= 32)) {
#line 203
        goto while_break___1;
      }
    } else {
#line 203
      goto while_break___1;
    }
#line 204
    *op = (char)0;
#line 205
    op --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 208
  p = outstring;
#line 209
  return (p);
}
}
#line 216 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
void updown(int what___1 , int nr ) 
{ 
  char const   *name[13] ;
  int idx___0[13] ;
  int r ;
  int f ;
  int g ;
  char *t ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char buf___6[160] ;
  char buffirst[20] ;
  char xfrstr[160] ;
  unsigned int tmp___2 ;
  char trimbuf[160] ;
  unsigned int tmp___3 ;
  char title[64] ;
  char const   *s___0 ;
  int pipefd[2] ;
  int n ;
  int status ;
  char *cmdline ;
  char *translated_cmdline ;
  WIN *win ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int multiple ;
  size_t cmdline_length ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  ssize_t tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 224
  g = 0;
#line 225
  if (what___1 == 85) {
    {
#line 225
    tmp = gettext("Upload");
#line 225
    tmp___1 = tmp;
    }
  } else {
    {
#line 225
    tmp___0 = gettext("Download");
#line 225
    tmp___1 = tmp___0;
    }
  }
#line 225
  t = tmp___1;
#line 228
  xfrstr[0] = (char )'\000';
#line 228
  tmp___2 = 1U;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (tmp___2 >= 160U) {
#line 228
      goto while_break;
    }
#line 228
    xfrstr[tmp___2] = (char)0;
#line 228
    tmp___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  trimbuf[0] = (char )'\000';
#line 229
  tmp___3 = 1U;
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 229
    if (tmp___3 >= 160U) {
#line 229
      goto while_break___0;
    }
#line 229
    trimbuf[tmp___3] = (char)0;
#line 229
    tmp___3 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 231
  s___0 = "";
#line 234
  cmdline = (char *)((void *)0);
#line 235
  translated_cmdline = (char *)((void *)0);
#line 236
  win = (WIN *)((void *)0);
#line 238
  if (what___1 == 85) {
#line 238
    tmp___4 = mpars[58].value;
  } else {
#line 238
    tmp___4 = mpars[59].value;
  }
  {
#line 238
  tmp___5 = mcd(tmp___4);
  }
#line 238
  if (tmp___5 < 0) {
#line 239
    return;
  }
#line 242
  if (nr == 0) {
#line 243
    f = 0;
    {
#line 243
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 243
      if (! (f < 12)) {
#line 243
        goto while_break___1;
      }
#line 244
      if (*(& mpars[f].value[5] + 0)) {
#line 244
        if ((int )mpars[f].value[1] == what___1) {
#line 245
          name[g] = (char const   *)(& mpars[f].value[5]);
#line 246
          tmp___6 = g;
#line 246
          g ++;
#line 246
          idx___0[tmp___6] = f;
        }
      }
#line 243
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 249
    name[g] = (char const   *)((void *)0);
#line 250
    if (g == 0) {
#line 251
      return;
    }
    {
#line 253
    tmp___7 = mc_wselect(30, 7, (char const   * const  *)(name), (void (* const  *)(void))((void *)0),
                         (char const   *)t, (int )stdattr, mfcolor, mbcolor);
#line 253
    r = tmp___7 - 1;
    }
#line 254
    if (r < 0) {
#line 255
      return;
    }
#line 257
    g = idx___0[r];
  } else {
#line 259
    g = nr;
  }
#line 261
  buf___6[0] = (char)0;
#line 269
  if ((int )mpars[g].value[4] == 89) {
#line 271
    if (what___1 == 85) {
#line 271
      multiple = -1;
    } else {
#line 271
      multiple = 0;
    }
  } else {
#line 273
    multiple = 1;
  }
#line 275
  if ((int )mpars[81].value[0] == 89) {
#line 275
    if (what___1 == 85) {
#line 275
      goto _L___0;
    } else
#line 275
    if ((int )mpars[82].value[0] == 89) {
      _L___0: /* CIL Label */ 
#line 276
      if (what___1 == 85) {
#line 276
        tmp___8 = 0;
      } else {
#line 276
        tmp___8 = 1;
      }
      {
#line 276
      tmp___9 = filedir(multiple, tmp___8);
#line 276
      s___0 = (char const   *)tmp___9;
      }
#line 277
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 278
        return;
      }
    } else {
#line 275
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 280
  if ((int )mpars[g].value[0] == 89) {
    {
#line 281
    tmp___10 = gettext("Please enter file names");
#line 281
    tmp___11 = input(tmp___10, buf___6);
#line 281
    s___0 = (char const   *)tmp___11;
    }
#line 282
    if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 283
      return;
    }
  }
  {
#line 287
  tmp___12 = strlen((char const   *)(mpars[12 + g].value));
  }
#line 287
  if (multiple == 0) {
#line 287
    tmp___13 = "";
  } else {
#line 287
    tmp___13 = s___0;
  }
  {
#line 287
  tmp___14 = strlen((char const   *)((char *)tmp___13));
#line 287
  cmdline_length = (tmp___12 + tmp___14) + 1UL;
#line 288
  tmp___15 = malloc(cmdline_length + 1UL);
#line 288
  cmdline = (char *)tmp___15;
  }
#line 289
  if ((unsigned long )cmdline == (unsigned long )((void *)0)) {
    {
#line 290
    tmp___16 = gettext("Out of memory: could allocate buffer for command line");
#line 290
    werror((char const   *)tmp___16);
    }
#line 291
    return;
  }
#line 293
  if (multiple == 0) {
#line 293
    tmp___17 = "";
  } else {
#line 293
    tmp___17 = s___0;
  }
  {
#line 293
  snprintf((char */* __restrict  */)cmdline, cmdline_length + 1UL, (char const   */* __restrict  */)"%s %s",
           mpars[12 + g].value, tmp___17);
  }
#line 297
  if ((int )mpars[85].value[0] == 89) {
    {
#line 298
    do_log("%s", cmdline);
    }
  }
#line 300
  if ((int )mpars[g].value[2] == 78) {
    {
#line 301
    win = mc_wopen(10, 7, 70, 13, 1, (int )stdattr, mfcolor, mbcolor, 1, 0, 1);
    }
#line 302
    if (what___1 == 85) {
      {
#line 302
      tmp___18 = gettext("upload");
#line 302
      tmp___20 = tmp___18;
      }
    } else {
      {
#line 302
      tmp___19 = gettext("download");
#line 302
      tmp___20 = tmp___19;
      }
    }
    {
#line 302
    tmp___21 = gettext("%.30s %s - Press CTRL-C to quit");
#line 302
    snprintf((char */* __restrict  */)(title), sizeof(title), (char const   */* __restrict  */)tmp___21,
             & mpars[g].value[5], tmp___20);
#line 304
    mc_wtitle(win, 1, (char const   *)(title));
#line 305
    tmp___22 = pipe((int *)(pipefd));
    }
#line 305
    if (tmp___22 == -1) {
      {
#line 306
      werror("pipe() call failed");
      }
    }
  } else {
    {
#line 308
    mc_wleave();
    }
  }
  {
#line 310
  m_flush((int )portfd);
#line 312
  udpid = fork();
  }
  {
#line 313
  if (udpid == -1) {
#line 313
    goto case_neg_1;
  }
#line 325
  if (udpid == 0) {
#line 325
    goto case_0;
  }
#line 350
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 314
  tmp___23 = gettext("Out of memory: could not fork()");
#line 314
  werror((char const   *)tmp___23);
  }
#line 315
  if (win) {
    {
#line 316
    close(pipefd[0]);
#line 317
    close(pipefd[1]);
#line 318
    mc_wclose(win, 1);
    }
  } else {
    {
#line 320
    mc_wreturn();
    }
  }
  {
#line 321
  mcd((char *)"");
  }
#line 322
  if (cmdline) {
    {
#line 323
    free((void *)cmdline);
    }
  }
#line 324
  return;
  case_0: /* CIL Label */ 
#line 326
  if ((int )mpars[g].value[3] == 89) {
    {
#line 327
    dup2((int )portfd, 0);
#line 328
    dup2((int )portfd, 1);
    }
  }
#line 330
  if (win) {
    {
#line 331
    dup2(pipefd[1], 2);
#line 332
    close(pipefd[0]);
    }
#line 333
    if (pipefd[1] != 2) {
      {
#line 334
      close(pipefd[1]);
      }
    }
  }
  {
#line 337
  lockfile_remove();
#line 339
  n = 1;
  }
  {
#line 339
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 339
    if (! (n < 65)) {
#line 339
      goto while_break___2;
    }
    {
#line 340
    signal(n, (void (*)(int  ))0);
#line 339
    n ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 342
  translated_cmdline = translate(cmdline);
  }
#line 343
  if ((unsigned long )translated_cmdline != (unsigned long )((void *)0)) {
    {
#line 344
    fastexec(translated_cmdline);
#line 345
    free((void *)translated_cmdline);
    }
  }
#line 347
  if (cmdline) {
    {
#line 348
    free((void *)cmdline);
    }
  }
  {
#line 349
  exit(1);
  }
  switch_default: /* CIL Label */ 
#line 351
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 354
  if (cmdline) {
    {
#line 355
    free((void *)cmdline);
    }
  }
#line 357
  if (win) {
    {
#line 358
    setcbreak(1);
#line 359
    enab_sig(1, 0);
    }
  }
  {
#line 361
  signal(2, & udcatch);
  }
#line 362
  if ((int )mpars[g].value[3] == 89) {
    {
#line 363
    close(pipefd[1]);
    }
    {
#line 367
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 367
      tmp___28 = read(pipefd[0], (void *)(buf___6), sizeof(buf___6));
#line 367
      n = (int )tmp___28;
      }
#line 367
      if (! (n > 0)) {
#line 367
        goto while_break___3;
      }
      {
#line 368
      buf___6[n] = (char )'\000';
#line 369
      mc_wputs(win, (char const   *)(buf___6));
#line 370
      timer_update();
      }
#line 372
      if ((int )mpars[85].value[0] == 89) {
        {
#line 377
        tmp___27 = sscanf((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%19s",
                          buffirst);
        }
#line 377
        if (tmp___27) {
          {
#line 378
          tmp___25 = strncmp((char const   *)(buffirst), "Receiving", (size_t )9);
          }
#line 378
          if (tmp___25) {
            {
#line 378
            tmp___26 = strncmp((char const   *)(buffirst), "Sending", (size_t )7);
            }
#line 378
            if (tmp___26) {
              {
#line 387
              tmp___24 = strncmp((char const   *)(buffirst), "Bytes", (size_t )5);
              }
#line 387
              if (! tmp___24) {
                {
#line 388
                strncpy((char */* __restrict  */)(xfrstr), (char const   */* __restrict  */)(buf___6),
                        sizeof(xfrstr));
                }
              }
            } else {
              _L___1: /* CIL Label */ 
#line 380
              if (xfrstr[0]) {
                {
#line 381
                trim(trimbuf, xfrstr, (int )sizeof(trimbuf));
#line 382
                do_log("%s", trimbuf);
#line 383
                xfrstr[0] = (char)0;
                }
              }
              {
#line 385
              trim(trimbuf, buf___6, (int )sizeof(trimbuf));
#line 386
              do_log("%s", trimbuf);
              }
            }
          } else {
#line 378
            goto _L___1;
          }
#line 390
          buffirst[0] = (char)0;
#line 391
          trimbuf[0] = (char)0;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 401
  if ((int )mpars[85].value[0] == 89) {
#line 401
    if (xfrstr[0]) {
      {
#line 402
      trim(trimbuf, xfrstr, (int )sizeof(trimbuf));
#line 403
      do_log("%s", trimbuf);
#line 404
      xfrstr[0] = (char)0;
      }
    }
  }
  {
#line 407
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 407
    tmp___29 = m_wait(& status);
    }
#line 407
    if (! (udpid != tmp___29)) {
#line 407
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 408
  if (win) {
    {
#line 409
    enab_sig(0, 0);
#line 410
    signal(2, (void (*)(int  ))1);
    }
  }
#line 413
  if ((unsigned long )win == (unsigned long )((WIN *)0)) {
    {
#line 414
    mc_wreturn();
    }
  }
  {
#line 416
  lockfile_create(0);
#line 421
  m_flush((int )portfd);
#line 422
  port_init();
#line 423
  setcbreak(2);
  }
#line 424
  if (win) {
    {
#line 425
    close(pipefd[0]);
    }
  }
  {
#line 426
  mcd((char *)"");
#line 427
  timer_update();
  }
#line 430
  if (win) {
#line 430
    if (status == 1) {
#line 432
      if ((int )mpars[77].value[0] == 89) {
        {
#line 433
        tmp___30 = gettext("\n Failure executing protocol. Press any key to continue...");
#line 433
        mc_wprintf(win, (char const   *)tmp___30);
#line 434
        music();
        }
      } else {
        {
#line 436
        sleep(1U);
        }
      }
    } else {
#line 430
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 446
  if (win) {
#line 446
    if ((status & 65280) == 0) {
#line 448
      if ((int )mpars[77].value[0] == 89) {
        {
#line 449
        tmp___31 = gettext("\n READY: press any key to continue...");
#line 449
        mc_wprintf(win, (char const   *)tmp___31);
#line 450
        music();
        }
      } else {
        {
#line 452
        sleep(1U);
        }
      }
    }
  }
#line 461
  if (win) {
    {
#line 462
    mc_wclose(win, 1);
    }
  }
#line 463
  return;
}
}
#line 465 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
void lockfile_remove(void) 
{ 


  {
#line 467
  if (portfd_is_socket) {
#line 468
    return;
  }
#line 471
  if (lockfile[0]) {
    {
#line 472
    unlink((char const   *)(lockfile));
    }
  }
#line 476
  return;
}
}
#line 478 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
int lockfile_create(int no_msgs ) 
{ 
  int n ;
  int fd ;
  __mode_t tmp ;
  char *tmp___0 ;
  char buf___6[12] ;
  __pid_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 482
  if (portfd_is_socket) {
#line 483
    return (0);
  }
#line 486
  if (! lockfile[0]) {
#line 487
    return (0);
  }
  {
#line 490
  tmp = umask((__mode_t )18);
#line 490
  n = (int )tmp;
#line 492
  fd = open((char const   *)(lockfile), 193, 438);
  }
#line 492
  if (fd < 0) {
#line 493
    if (! no_msgs) {
      {
#line 494
      tmp___0 = gettext("Cannot create lockfile!");
#line 494
      werror((char const   *)tmp___0);
      }
    }
  } else {
    {
#line 498
    tmp___1 = getpid();
#line 498
    snprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)"%10d\n",
             tmp___1);
#line 499
    buf___6[sizeof(buf___6) - 1UL] = (char)0;
#line 500
    tmp___3 = strlen((char const   *)(buf___6));
#line 500
    tmp___4 = write(fd, (void const   *)(buf___6), tmp___3);
#line 500
    tmp___5 = strlen((char const   *)(buf___6));
    }
#line 500
    if (tmp___4 < (ssize_t )tmp___5) {
#line 501
      if (! no_msgs) {
        {
#line 502
        tmp___2 = gettext("Failed to write lockfile %s\n");
#line 502
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                lockfile);
        }
      }
    }
    {
#line 503
    close(fd);
    }
  }
  {
#line 505
  umask((__mode_t )n);
  }
#line 506
  return (0);
}
}
#line 525 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
void kermit(void) 
{ 
  int status ;
  int pid ;
  int n ;
  char *translated_cmdline ;
  char *kermit_path ;
  char *tmp ;

  {
#line 529
  kermit_path = mpars[32].value;
#line 531
  if (! kermit_path) {
    {
#line 532
    werror("No kermit path defined!");
    }
#line 533
    return;
  } else
#line 531
  if (! *kermit_path) {
    {
#line 532
    werror("No kermit path defined!");
    }
#line 533
    return;
  }
  {
#line 537
  mc_wleave();
#line 539
  pid = fork();
  }
  {
#line 540
  if (pid == -1) {
#line 540
    goto case_neg_1;
  }
#line 544
  if (pid == 0) {
#line 544
    goto case_0;
  }
#line 559
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 541
  mc_wreturn();
#line 542
  tmp = gettext("Out of memory: could not fork()");
#line 542
  werror((char const   *)tmp);
  }
#line 543
  return;
  case_0: /* CIL Label */ 
  {
#line 545
  close((int )portfd);
#line 548
  lockfile_remove();
#line 550
  n = 0;
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (n < 65)) {
#line 550
      goto while_break;
    }
    {
#line 551
    signal(n, (void (*)(int  ))0);
#line 550
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  translated_cmdline = translate(mpars[32].value);
  }
#line 554
  if ((unsigned long )translated_cmdline != (unsigned long )((void *)0)) {
    {
#line 555
    fastexec(translated_cmdline);
#line 556
    free((void *)translated_cmdline);
    }
  }
  {
#line 558
  exit(1);
  }
  switch_default: /* CIL Label */ 
#line 560
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 563
  m_wait(& status);
#line 566
  mc_wreturn();
#line 569
  lockfile_create(0);
#line 571
  m_flush((int )portfd);
#line 572
  port_init();
  }
#line 573
  return;
}
}
#line 579 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int varcmp(char const   *s1 , char const   *s2 ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (*s1) {
#line 581
      if (! *s2) {
#line 581
        goto while_break;
      }
    } else {
#line 581
      goto while_break;
    }
#line 582
    if ((int const   )*s1 == 61) {
#line 582
      if ((int const   )*s2 == 61) {
#line 583
        return (1);
      }
    }
#line 584
    tmp = s1;
#line 584
    s1 ++;
#line 584
    tmp___0 = s2;
#line 584
    s2 ++;
#line 584
    if ((int const   )*tmp != (int const   )*tmp___0) {
#line 585
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  return (1);
}
}
#line 593 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static char *makenv(char const   *name , char const   *value ) 
{ 
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 597
  tmp = strlen(name);
#line 597
  tmp___0 = strlen(value);
#line 597
  tmp___1 = malloc((tmp + tmp___0) + 3UL);
#line 597
  p = (char *)tmp___1;
  }
#line 597
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 598
    return (p);
  }
  {
#line 599
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s=%s", name,
          value);
  }
#line 600
  return (p);
}
}
#line 608 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
static int init___2  =    0;
#line 606 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
int mc_setenv(char const   *name , char const   *value ) 
{ 
  char *p ;
  char **e ;
  char **newe ;
  int count ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 610
  count = 0;
#line 612
  p = makenv(name, value);
  }
#line 612
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 613
    return (-1);
  }
#line 615
  e = environ;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! *e) {
#line 615
      goto while_break;
    }
    {
#line 616
    count ++;
#line 617
    tmp = varcmp((char const   *)p, (char const   *)*e);
    }
#line 617
    if (tmp) {
#line 618
      *e = p;
#line 619
      return (0);
    }
#line 615
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  count += 2;
#line 623
  tmp___0 = malloc(sizeof(char *) * (unsigned long )count);
#line 623
  newe = (char **)tmp___0;
  }
#line 623
  if ((unsigned long )newe == (unsigned long )((char **)0)) {
    {
#line 624
    free((void *)p);
    }
#line 625
    return (-1);
  }
  {
#line 627
  memcpy((void */* __restrict  */)((char *)newe), (void const   */* __restrict  */)((char *)environ),
         (size_t )((int )((unsigned long )count * sizeof(char *))));
  }
#line 628
  if (init___2) {
    {
#line 629
    free((void *)((char *)environ));
    }
  }
#line 630
  init___2 = 1;
#line 631
  environ = newe;
#line 632
  e = environ;
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! *e) {
#line 632
      goto while_break___0;
    }
#line 632
    e ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 634
  tmp___1 = e;
#line 634
  e ++;
#line 634
  *tmp___1 = p;
#line 635
  *e = (char *)((void *)0);
#line 636
  return (0);
}
}
#line 646 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
void runscript(int ask___0 , char const   *s___0 , char const   *l , char const   *p ) 
{ 
  int status ;
  int n ;
  int i ;
  int pipefd[2] ;
  char buf___6[81] ;
  char scr_lines[5] ;
  char cmdline[128] ;
  struct pollfd fds[2] ;
  char *translated_cmdline ;
  char *ptr___1 ;
  WIN *w ;
  int done ;
  char *msg ;
  char *tmp ;
  char *username___0 ;
  char *tmp___0 ;
  char *password ;
  char *tmp___1 ;
  char *name_of_script ;
  char *tmp___2 ;
  char *question ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  ssize_t tmp___19 ;
  int tmp___20 ;

  {
  {
#line 658
  done = 0;
#line 659
  tmp = gettext("Same as last");
#line 659
  msg = tmp;
#line 660
  tmp___0 = gettext(" A -   Username        :");
#line 660
  username___0 = tmp___0;
#line 660
  tmp___1 = gettext(" B -   Password        :");
#line 660
  password = tmp___1;
#line 660
  tmp___2 = gettext(" C -   Name of script  :");
#line 660
  name_of_script = tmp___2;
#line 660
  tmp___3 = gettext("Change which setting?     (Return to run, ESC to stop)");
#line 660
  question = tmp___3;
  }
#line 666
  if (ask___0) {
    {
#line 667
    w = mc_wopen(10, 5, 70, 10, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 668
    tmp___4 = gettext("Run a script");
#line 668
    mc_wtitle(w, 1, (char const   *)tmp___4);
#line 669
    mc_wputs(w, "\n");
    }
#line 670
    if (scr_user[0]) {
#line 670
      tmp___5 = (char const   *)msg;
    } else {
#line 670
      tmp___5 = "";
    }
    {
#line 670
    mc_wprintf(w, "%s %s\n", username___0, tmp___5);
    }
#line 671
    if (scr_passwd[0]) {
#line 671
      tmp___6 = (char const   *)msg;
    } else {
#line 671
      tmp___6 = "";
    }
    {
#line 671
    mc_wprintf(w, "%s %s\n", password, tmp___6);
#line 672
    mc_wprintf(w, "%s %s\n", name_of_script, scr_name);
#line 673
    mc_wlocate(w, 4, 5);
#line 674
    mc_wputs(w, (char const   *)question);
#line 675
    mc_wredraw(w, 1);
    }
    {
#line 677
    while (1) {
      while_continue: /* CIL Label */ ;
#line 677
      if (! (! done)) {
#line 677
        goto while_break;
      }
      {
#line 678
      tmp___7 = mbslen((char const   *)question);
#line 678
      mc_wlocate(w, (int )(tmp___7 + 5UL), 5);
#line 679
      n = wxgetch();
#line 680
      tmp___8 = __ctype_b_loc();
      }
#line 680
      if ((int const   )*(*tmp___8 + n) & 512) {
        {
#line 681
        n = toupper(n);
        }
      }
      {
#line 684
      if (n == 10) {
#line 684
        goto case_10;
      }
#line 684
      if (n == 13) {
#line 684
        goto case_10;
      }
#line 692
      if (n == 27) {
#line 692
        goto case_27;
      }
#line 695
      if (n == 65) {
#line 695
        goto case_65;
      }
#line 701
      if (n == 66) {
#line 701
        goto case_66;
      }
#line 707
      if (n == 67) {
#line 707
        goto case_67;
      }
#line 711
      goto switch_default;
      case_10: /* CIL Label */ 
      case_13: /* CIL Label */ 
#line 685
      if ((int )scr_name[0] == 0) {
        {
#line 686
        mc_wbell();
        }
#line 687
        goto switch_break;
      }
      {
#line 689
      mc_wclose(w, 1);
#line 690
      done = 1;
      }
#line 691
      goto switch_break;
      case_27: /* CIL Label */ 
      {
#line 693
      mc_wclose(w, 1);
      }
#line 694
      return;
      case_65: /* CIL Label */ 
      {
#line 696
      tmp___9 = mbslen((char const   *)username___0);
#line 696
      mc_wlocate(w, (int )(tmp___9 + 1UL), 1);
#line 697
      mc_wclreol(w);
#line 698
      scr_user[0] = (char)0;
#line 699
      mc_wgets(w, scr_user, 32, 32);
      }
#line 700
      goto switch_break;
      case_66: /* CIL Label */ 
      {
#line 702
      tmp___10 = mbslen((char const   *)password);
#line 702
      mc_wlocate(w, (int )(tmp___10 + 1UL), 2);
#line 703
      mc_wclreol(w);
#line 704
      scr_passwd[0] = (char)0;
#line 705
      mc_wgets(w, scr_passwd, 32, 32);
      }
#line 706
      goto switch_break;
      case_67: /* CIL Label */ 
      {
#line 708
      tmp___11 = mbslen((char const   *)name_of_script);
#line 708
      mc_wlocate(w, (int )(tmp___11 + 1UL), 3);
#line 709
      mc_wgets(w, scr_name, 32, (int )(sizeof(scr_name) - 1UL));
      }
#line 710
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 712
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 716
    strncpy((char */* __restrict  */)(scr_user), (char const   */* __restrict  */)l,
            sizeof(scr_user));
#line 717
    strncpy((char */* __restrict  */)(scr_name), (char const   */* __restrict  */)s___0,
            sizeof(scr_name));
#line 718
    strncpy((char */* __restrict  */)(scr_passwd), (char const   */* __restrict  */)p,
            sizeof(scr_passwd));
    }
  }
  {
#line 720
  sprintf((char */* __restrict  */)(scr_lines), (char const   */* __restrict  */)"%d",
          (int )lines);
  }
#line 723
  if (tempst) {
    {
#line 724
    mc_wclose(st, 1);
#line 725
    tempst = 0;
#line 726
    st = (WIN *)((void *)0);
    }
  }
  {
#line 728
  scriptname((char const   *)(scr_name));
#line 730
  tmp___12 = pipe((int *)(pipefd));
  }
#line 730
  if (tmp___12 < 0) {
#line 731
    return;
  }
  {
#line 733
  tmp___13 = mcd(mpars[60].value);
  }
#line 733
  if (tmp___13 < 0) {
#line 734
    return;
  }
#line 736
  if ((int )logfname[0] == 0) {
#line 736
    tmp___14 = "";
  } else {
#line 736
    tmp___14 = (char const   *)(homedir);
  }
  {
#line 736
  snprintf((char */* __restrict  */)(cmdline), sizeof(cmdline), (char const   */* __restrict  */)"%s %s %s %s",
           mpars[36].value, scr_name, logfname, tmp___14);
#line 739
  udpid = fork();
  }
  {
#line 740
  if (udpid == -1) {
#line 740
    goto case_neg_1;
  }
#line 746
  if (udpid == 0) {
#line 746
    goto case_0;
  }
#line 766
  goto switch_default___0;
  case_neg_1: /* CIL Label */ 
  {
#line 741
  tmp___15 = gettext("Out of memory: could not fork()");
#line 741
  werror((char const   *)tmp___15);
#line 742
  close(pipefd[0]);
#line 743
  close(pipefd[1]);
#line 744
  mcd((char *)"");
  }
#line 745
  return;
  case_0: /* CIL Label */ 
  {
#line 747
  dup2((int )portfd, 0);
#line 748
  dup2((int )portfd, 1);
#line 749
  dup2(pipefd[1], 2);
#line 750
  close(pipefd[0]);
#line 751
  close(pipefd[1]);
#line 753
  n = 1;
  }
  {
#line 753
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 753
    if (! (n < 65)) {
#line 753
      goto while_break___0;
    }
    {
#line 754
    signal(n, (void (*)(int  ))0);
#line 753
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 756
  mc_setenv("LOGIN", (char const   *)(scr_user));
#line 757
  mc_setenv("PASS", (char const   *)(scr_passwd));
#line 758
  mc_setenv("TERMLIN", (char const   *)(scr_lines));
#line 759
  translated_cmdline = translate(cmdline);
  }
#line 761
  if ((unsigned long )translated_cmdline != (unsigned long )((void *)0)) {
    {
#line 762
    fastexec(translated_cmdline);
#line 763
    free((void *)translated_cmdline);
    }
  }
  {
#line 765
  exit(1);
  }
  switch_default___0: /* CIL Label */ 
#line 767
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 769
  setcbreak(1);
#line 770
  enab_sig(1, 0);
#line 771
  signal(2, & udcatch);
#line 772
  close(pipefd[1]);
#line 775
  fds[0].fd = pipefd[0];
#line 776
  fds[0].events = (short)1;
#line 777
  fds[1].fd = 0;
#line 778
  fds[1].events = (short)1;
#line 779
  script_running = 1;
  }
  {
#line 780
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 780
    if (script_running) {
      {
#line 780
      tmp___20 = poll(fds, (nfds_t )2, -1);
      }
#line 780
      if (! (tmp___20 > 0)) {
#line 780
        goto while_break___1;
      }
    } else {
#line 780
      goto while_break___1;
    }
#line 781
    i = 0;
    {
#line 781
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 781
      if (! (i < 2)) {
#line 781
        goto while_break___2;
      }
#line 782
      if ((int )fds[i].revents & 56) {
#line 783
        script_running = 0;
      } else
#line 784
      if ((int )fds[i].revents & 1) {
        {
#line 784
        tmp___19 = read(fds[i].fd, (void *)(buf___6), sizeof(buf___6) - 1UL);
#line 784
        n = (int )tmp___19;
        }
#line 784
        if (n > 0) {
#line 786
          ptr___1 = buf___6;
          {
#line 787
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 787
            tmp___18 = n;
#line 787
            n --;
#line 787
            if (! tmp___18) {
#line 787
              goto while_break___3;
            }
#line 788
            if (i) {
              {
#line 789
              tmp___16 = ptr___1;
#line 789
              ptr___1 ++;
#line 789
              vt_send((int )*tmp___16);
              }
            } else {
              {
#line 791
              tmp___17 = ptr___1;
#line 791
              ptr___1 ++;
#line 791
              vt_out((int )*tmp___17);
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 792
          timer_update();
#line 793
          mc_wflush();
          }
        }
      }
#line 781
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 798
  m_wait(& status);
#line 799
  enab_sig(0, 0);
#line 800
  signal(2, (void (*)(int  ))1);
#line 801
  setcbreak(2);
#line 802
  close(pipefd[0]);
#line 803
  scriptname("");
#line 804
  mcd((char *)"");
  }
#line 805
  return;
}
}
#line 816 "/home/wheatley/newnew/temp/minicom-2.7/src/updown.c"
int paste_file(void) 
{ 
  FILE *fp ;
  char line[1024] ;
  char *s___0 ;
  int dotrans___0 ;
  int ldelay___0 ;
  char buf___6[128] ;
  unsigned int tmp ;
  char *ptr___1 ;
  int bytes_read ;
  unsigned long bdone___0 ;
  int x ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 821
  dotrans___0 = 0;
#line 822
  ldelay___0 = 1;
#line 823
  buf___6[0] = (char )'\000';
#line 823
  tmp = 1U;
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (tmp >= 128U) {
#line 823
      goto while_break;
    }
#line 823
    buf___6[tmp] = (char)0;
#line 823
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  bdone___0 = 0UL;
#line 829
  s___0 = filedir(1, 0);
  }
#line 829
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 830
    return (0);
  }
  {
#line 831
  fp = fopen((char const   */* __restrict  */)s___0, (char const   */* __restrict  */)"r");
  }
#line 831
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 832
    perror((char const   *)s___0);
    }
#line 833
    return (-1);
  }
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 836
    tmp___5 = fgets((char */* __restrict  */)(line), (int )sizeof(line), (FILE */* __restrict  */)fp);
    }
#line 836
    if (! tmp___5) {
#line 836
      goto while_break___0;
    }
#line 838
    if (portfd_is_socket) {
#line 838
      if (! portfd_is_connected) {
#line 838
        tmp___0 = -1;
      } else {
#line 838
        tmp___0 = (int )portfd;
      }
    } else {
#line 838
      tmp___0 = (int )portfd;
    }
    {
#line 838
    x = check_io(tmp___0, 0, 1000, buf___6, (int )sizeof(buf___6), & bytes_read);
    }
#line 841
    if (x & 1) {
#line 842
      ptr___1 = buf___6;
      {
#line 843
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 843
        tmp___2 = bytes_read;
#line 843
        bytes_read --;
#line 843
        if (! (tmp___2 > 0)) {
#line 843
          goto while_break___1;
        }
#line 844
        if ((int )mpars[30].value[0] == 77) {
#line 845
          *ptr___1 = (char )((int )*ptr___1 & 127);
        } else
#line 844
        if ((int )mpars[30].value[0] == 83) {
#line 845
          *ptr___1 = (char )((int )*ptr___1 & 127);
        }
        {
#line 846
        tmp___1 = ptr___1;
#line 846
        ptr___1 ++;
#line 846
        vt_out((int )*tmp___1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 848
      mc_wflush();
      }
    }
#line 851
    if (dotrans___0) {
      {
#line 851
      s___0 = strrchr((char const   *)(line), '\n');
      }
#line 851
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 852
        if ((unsigned long )s___0 > (unsigned long )(line)) {
#line 852
          if ((int )*(s___0 - 1) == 13) {
#line 853
            s___0 --;
          }
        }
#line 854
        *s___0 = (char)0;
#line 855
        s___0 = line;
#line 856
        s___0 = line;
        {
#line 856
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 856
          if (! *s___0) {
#line 856
            goto while_break___2;
          }
          {
#line 857
          vt_send((int )*s___0);
#line 856
          s___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 858
        vt_send('\r');
#line 859
        vt_send('\n');
#line 860
        tmp___3 = strlen((char const   *)(line));
#line 860
        bdone___0 += tmp___3 + 2UL;
        }
      } else {
#line 851
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 862
      s___0 = line;
      {
#line 862
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 862
        if (! *s___0) {
#line 862
          goto while_break___3;
        }
        {
#line 863
        vt_send((int )*s___0);
#line 862
        s___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 864
      tmp___4 = strlen((char const   *)s___0);
#line 864
      bdone___0 += tmp___4;
      }
    }
#line 866
    if (ldelay___0) {
      {
#line 868
      usleep((__useconds_t )(ldelay___0 * 1000));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 872
  fclose(fp);
  }
#line 873
  return (0);
}
}
#line 35 "../lib/getopt.h"
extern char *optarg ;
#line 49
extern int optind ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 277 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcsstr)(wchar_t const   *__haystack ,
                                                                                  wchar_t const   *__needle )  __attribute__((__pure__)) ;
#line 287
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 197 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int usecolor ;
#line 69
int screen_ibmpc ;
#line 70
int screen_iso ;
#line 73
int use_status ;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int mfcolor  ;
#line 78 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int mbcolor  ;
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int tfcolor  ;
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int tbcolor  ;
#line 81 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int sfcolor  ;
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int sbcolor  ;
#line 156
void mc_wdrawelm(WIN *w , int y , ELM *e ) ;
#line 180
int mc_wgetwcs(WIN *w , wchar_t *s___0 , int linelen , int maxlen ) ;
#line 185
int win_init(int fg , int bg , int attr ) ;
#line 188
void mc_wdrawelm_inverse(WIN *w , int y , ELM *e ) ;
#line 189
void mc_wdrawelm_var(WIN *w , ELM *e , wchar_t *buf___6 ) ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int dosetup  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char stdattr  ;
#line 70 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
WIN *us  ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
WIN *st  ;
#line 73 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
short terminal  ;
#line 74 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
time_t online  ;
#line 75 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
long linespd  ;
#line 76 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
short portfd  ;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
short lines  ;
#line 78 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
short cols  ;
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int keypadmode  ;
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int cursormode  ;
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int docap  ;
#line 83 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
FILE *capfp  ;
#line 84 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int addlf  ;
#line 85 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int addcr  ;
#line 86 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int wrapln  ;
#line 87 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int display_hex  ;
#line 88 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int tempst  ;
#line 89 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int escape  ;
#line 90 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int option_T_used  ;
#line 92 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char lockfile[128]  ;
#line 95 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char username[16]  ;
#line 97 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int bogus_dcd  ;
#line 98 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int alt_override  ;
#line 100 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char parfile[256]  ;
#line 101 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char pparfile[256]  ;
#line 103 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char scr_name[256]  ;
#line 104 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char scr_user[33]  ;
#line 105 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char scr_passwd[33]  ;
#line 107 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char termtype[32]  ;
#line 108 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *dial_tty  ;
#line 110 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *dial_name  ;
#line 111 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char *dial_number  ;
#line 141 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int st_attr  ;
#line 147 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int num_hist_lines  ;
#line 153 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int size_changed  ;
#line 156 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int local_echo  ;
#line 164
void read_parms(void) ;
#line 166
int config(int setup ) ;
#line 171
int dotermmenu(void) ;
#line 172
int dodflsave(void) ;
#line 177
int speed_valid(unsigned int speed ) ;
#line 206
int fastsystem(char *cmd , char *in , char *out , char *err ) ;
#line 207
char *get_port(char *port_list ) ;
#line 222
 __attribute__((__noreturn__)) void leave(char const   *s___0 ) ;
#line 226
int open_term(int doinit , int show_win_on_error , int no_msgs ) ;
#line 230
void set_status_line_format(char const   *s___0 ) ;
#line 232
int do_terminal(void) ;
#line 233
void status_set_display(char const   *text , int duration_s ) ;
#line 240
void drawhist_look(WIN *w , int y , int r , wchar_t *look , int case_matters ) ;
#line 241
void searchhist(WIN *w_hist , wchar_t *str ) ;
#line 242
int find_next(WIN *w , WIN *w_hist , int hit_line , wchar_t *look , int case_matters ) ;
#line 244
wchar_t const   *upcase(wchar_t *dest , wchar_t *src ) ;
#line 245
wchar_t *StrStr(wchar_t *str1 , wchar_t *str2 , int case_matters ) ;
#line 247
void do_iconv(char **inbuf___0 , size_t *inbytesleft , char **outbuf , size_t *outbytesleft ) ;
#line 264
void m_restorestate(int fd ) ;
#line 266
void m_hupcl(int fd , int on ) ;
#line 270
void m_setparms(int fd , char *baudr , char *par , char *bits , char *stopb , int hwf ,
                int swf ) ;
#line 42 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static char const   option_string[6]  = {      (char const   )'I',      (char const   )'1',      (char const   )'8',      (char const   )'n', 
        (char const   )' ',      (char const   )'\000'};
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static int line_timestamp  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static char const   *c1[3]  = {      "   Yes  ",      "   No   ",      (char const   *)((void *)0)};
#line 69 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static char const   *c2[4]  = {      "  Close ",      " Pause  ",      "  Exit  ",      (char const   *)((void *)0)};
#line 70 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static char const   *c3[4]  = {      "  Close ",      " Unpause",      "  Exit  ",      (char const   *)((void *)0)};
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static char const   *c7[3]  = {      "   Yes  ",      "   No   ",      (char const   *)((void *)0)};
#line 74 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void port_init(void) 
{ 


  {
  {
#line 76
  m_setparms((int )portfd, mpars[28].value, mpars[30].value, mpars[29].value, mpars[31].value,
             (int )mpars[65].value[0] == 89, (int )mpars[66].value[0] == 89);
  }
#line 78
  return;
}
}
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void do_hang(int askit ) 
{ 
  int c___0 ;
  char *tmp ;

  {
#line 82
  c___0 = 0;
#line 84
  if (askit) {
    {
#line 85
    tmp = gettext("Hang-up line?");
#line 85
    c___0 = ask((char const   *)tmp, c7);
    }
  }
#line 86
  if (c___0 == 0) {
    {
#line 87
    hangup();
    }
  }
#line 88
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void hangsig(int sig ) 
{ 
  char *tmp ;

  {
#line 95
  if (stdwin) {
    {
#line 96
    tmp = gettext("Killed by signal %d !\n");
#line 96
    werror((char const   *)tmp, sig);
    }
  }
#line 97
  if (capfp) {
    {
#line 98
    fclose(capfp);
    }
  }
  {
#line 100
  keyboard(101, 0);
#line 101
  hangup();
#line 102
  modemreset();
#line 103
  leave("\n");
  }
}
}
#line 110 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void shjump(int sig ) 
{ 
  sigset_t ss ;
  sigset_t oldss ;
  char *tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 115
  mc_wleave();
#line 116
  signal(20, (void (*)(int  ))0);
#line 117
  sigemptyset(& ss);
#line 118
  sigaddset(& ss, 20);
#line 119
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& ss), (sigset_t */* __restrict  */)(& oldss));
#line 120
  tmp = gettext("Suspended. Type \"fg\" to resume.\n");
#line 120
  fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stdout);
#line 121
  tmp___0 = getpid();
#line 121
  kill(tmp___0, 20);
#line 122
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oldss), (sigset_t */* __restrict  */)((void *)0));
#line 123
  signal(20, & shjump);
#line 124
  mc_wreturn();
  }
#line 125
  if (use_status) {
    {
#line 126
    show_status();
    }
  }
#line 127
  return;
}
}
#line 168
static ELM *mc_getline(WIN *w , int no ) ;
#line 168 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static ELM outofrange[256]  = {      {0, (char)0, (char)0}};
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static ELM *mc_getline(WIN *w , int no ) 
{ 
  int i ;

  {
#line 170
  if (no < us->histlines) {
#line 172
    i = no + us->histline;
#line 173
    if (i >= us->histlines) {
#line 174
      i -= us->histlines;
    }
#line 175
    if (i < 0) {
#line 176
      i = us->histlines - 1;
    }
#line 177
    return (us->histbuf + i * us->xs);
  }
#line 181
  no -= us->histlines;
#line 182
  if (no >= w->ys) {
#line 183
    if (outofrange[0].value == 0) {
#line 184
      i = 0;
      {
#line 184
      while (1) {
        while_continue: /* CIL Label */ ;
#line 184
        if (! (i < 256)) {
#line 184
          goto while_break;
        }
#line 185
        outofrange[i].value = ' ';
#line 186
        outofrange[i].color = us->color;
#line 187
        outofrange[i].attr = us->attr;
#line 184
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 189
      outofrange[0].value = '~';
    }
#line 191
    return (outofrange);
  }
#line 193
  return (w->map + no * us->xs);
}
}
#line 197 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void drawhist(WIN *w , int y , int r ) 
{ 
  int f ;
  int tmp ;
  ELM *tmp___0 ;

  {
#line 201
  w->direct = (char)0;
#line 202
  f = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (f < w->ys)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = y;
#line 203
    y ++;
#line 203
    tmp___0 = mc_getline(w, tmp);
#line 203
    mc_wdrawelm(w, f, tmp___0);
#line 202
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  if (r) {
    {
#line 205
    mc_wredraw(w, 1);
    }
  }
#line 206
  w->direct = (char)1;
#line 207
  return;
}
}
#line 216 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void drawhist_look(WIN *w , int y , int r , wchar_t *look , int case_matters ) 
{ 
  int f ;
  ELM *tmp_e ;
  wchar_t tmp_line[256] ;
  int tmp ;
  wchar_t *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 222
  tmp_line[0] = '\000';
#line 223
  w->direct = (char)0;
#line 224
  f = 0;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! (f < w->ys)) {
#line 224
      goto while_break;
    }
    {
#line 225
    tmp = y;
#line 225
    y ++;
#line 225
    tmp_e = mc_getline(w, tmp);
#line 228
    mc_wdrawelm_var(w, tmp_e, tmp_line);
#line 231
    tmp___1 = wcslen((wchar_t const   *)look);
    }
#line 231
    if (tmp___1 > 1UL) {
      {
#line 231
      tmp___2 = wcslen((wchar_t const   *)(tmp_line));
      }
#line 231
      if (tmp___2 > 1UL) {
        {
#line 232
        tmp___0 = StrStr(tmp_line, look, case_matters);
        }
#line 232
        if (tmp___0) {
          {
#line 233
          mc_wdrawelm_inverse(w, f, tmp_e);
          }
        } else {
          {
#line 235
          mc_wdrawelm(w, f, tmp_e);
          }
        }
      }
    }
#line 224
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  if (r) {
    {
#line 240
    mc_wredraw(w, 1);
    }
  }
#line 241
  w->direct = (char)1;
#line 242
  return;
}
}
#line 249 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void searchhist(WIN *w_hist , wchar_t *str ) 
{ 
  int y ;
  WIN *w_new ;
  char const   *hline ;
  size_t i ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 257
  y = w_hist->y2;
#line 258
  if ((unsigned long )st == (unsigned long )((WIN *)0)) {
#line 259
    y --;
  } else
#line 258
  if (st) {
#line 258
    if (tempst) {
#line 259
      y --;
    }
  }
  {
#line 262
  w_new = mc_wopen(0, y + 1, w_hist->x2, y + 1, 0, st_attr, sfcolor, sbcolor, 0, 0,
                   1);
#line 263
  w_new->doscroll = (char)0;
#line 264
  w_new->wrap = (char)0;
#line 266
  tmp = gettext("SEARCH FOR (ESC=Exit)");
#line 266
  hline = (char const   *)tmp;
#line 267
  mc_wprintf(w_new, "%s(%d):", hline, 30);
#line 268
  mc_wredraw(w_new, 1);
#line 269
  mc_wflush();
#line 271
  tmp___0 = mbslen(hline);
#line 271
  mc_wlocate(w_new, (int )(tmp___0 + 6UL), 0);
#line 272
  i = (size_t )0;
  }
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (*(str + i) != 0)) {
#line 272
      goto while_break;
    }
    {
#line 273
    mc_wputc(w_new, *(str + i));
#line 272
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  tmp___1 = mbslen(hline);
#line 274
  mc_wlocate(w_new, (int )(tmp___1 + 6UL), 0);
#line 275
  mc_wgetwcs(w_new, str, 30, 30);
#line 284
  mc_wredraw(w_hist, 1);
#line 285
  mc_wclose(w_new, 1);
#line 286
  mc_wflush();
  }
#line 288
  return;
}
}
#line 297 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
int find_next(WIN *w , WIN *w_hist , int hit_line , wchar_t *look , int case_matters ) 
{ 
  int next_line ;
  ELM *tmp_e ;
  wchar_t tmp_line[256] ;
  int all_lines ;
  char *tmp ;
  wchar_t *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
#line 307
  if (! look) {
#line 308
    hit_line ++;
#line 308
    return (hit_line);
  }
#line 310
  tmp_line[0] = '\000';
#line 312
  hit_line ++;
#line 313
  all_lines = w->histlines + w_hist->ys;
#line 315
  if (hit_line >= all_lines) {
    {
#line 316
    tmp = gettext("Search Wrapping Around to Start!");
#line 316
    werror((char const   *)tmp);
#line 317
    hit_line = 0;
    }
  }
#line 320
  next_line = hit_line;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! (next_line <= all_lines)) {
#line 320
      goto while_break;
    }
    {
#line 322
    tmp_e = mc_getline(w_hist, next_line);
#line 328
    mc_wdrawelm_var(w, tmp_e, tmp_line);
#line 331
    tmp___1 = wcslen((wchar_t const   *)(tmp_line));
    }
#line 331
    if (tmp___1 > 1UL) {
      {
#line 331
      tmp___2 = wcslen((wchar_t const   *)look);
      }
#line 331
      if (tmp___2 > 1UL) {
        {
#line 332
        tmp___0 = StrStr(tmp_line, look, case_matters);
        }
#line 332
        if (tmp___0) {
#line 333
          return (next_line);
        }
      }
    }
#line 320
    next_line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  if (hit_line >= all_lines) {
    {
#line 337
    tmp___3 = gettext("Search Wrapping Around to Start!");
#line 337
    werror((char const   *)tmp___3);
#line 338
    hit_line = 0;
    }
  }
#line 341
  return (-1);
}
}
#line 349 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
wchar_t const   *upcase(wchar_t *dest , wchar_t *src ) 
{ 
  wchar_t *d ;
  wchar_t *tmp ;
  wchar_t *tmp___0 ;
  wint_t tmp___1 ;

  {
#line 351
  d = dest;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! *src) {
#line 353
      goto while_break;
    }
    {
#line 354
    tmp = d;
#line 354
    d ++;
#line 354
    tmp___0 = src;
#line 354
    src ++;
#line 354
    tmp___1 = towupper((wint_t )*tmp___0);
#line 354
    *tmp = (wchar_t )tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  *d = '\000';
#line 356
  return ((wchar_t const   *)dest);
}
}
#line 364 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
wchar_t *StrStr(wchar_t *str1 , wchar_t *str2 , int case_matters ) 
{ 
  wchar_t tmpstr1[256] ;
  wchar_t tmpstr2[256] ;
  wchar_t *tmp ;
  wchar_t const   *tmp___0 ;
  wchar_t const   *tmp___1 ;
  wchar_t *tmp___2 ;

  {
#line 368
  if (case_matters) {
    {
#line 369
    tmp = wcsstr((wchar_t const   *)str1, (wchar_t const   *)str2);
    }
#line 369
    return (tmp);
  } else {
    {
#line 371
    tmp___0 = upcase(tmpstr2, str2);
#line 371
    tmp___1 = upcase(tmpstr1, str1);
#line 371
    tmp___2 = wcsstr(tmp___1, tmp___0);
    }
#line 371
    return (tmp___2);
  }
}
}
#line 374 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void drawcite(WIN *w , int y , int citey , int start___1 , int end ) 
{ 
  ELM *tmp ;
  ELM *tmp___0 ;

  {
#line 376
  if (y + citey >= start___1) {
#line 376
    if (y + citey <= end) {
      {
#line 377
      tmp = mc_getline(w, y + citey);
#line 377
      mc_wdrawelm_inverse(w, y, tmp);
      }
    } else {
      {
#line 379
      tmp___0 = mc_getline(w, y + citey);
#line 379
      mc_wdrawelm(w, y, tmp___0);
      }
    }
  } else {
    {
#line 379
    tmp___0 = mc_getline(w, y + citey);
#line 379
    mc_wdrawelm(w, y, tmp___0);
    }
  }
#line 380
  return;
}
}
#line 382 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void drawcite_whole(WIN *w , int y , int start___1 , int end ) 
{ 
  int sy ;

  {
#line 385
  sy = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (sy < w->ys)) {
#line 385
      goto while_break;
    }
    {
#line 386
    drawcite(w, sy, y, start___1, end);
#line 385
    sy ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  return;
}
}
#line 389 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void do_cite(WIN *w , int start___1 , int end ) 
{ 
  wchar_t tmp_line[256] ;
  ELM *tmp_e ;
  int x ;
  int y ;
  char buf___6[16] ;
  size_t i ;
  size_t len ;

  {
#line 395
  y = start___1;
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    if (! (y <= end)) {
#line 395
      goto while_break;
    }
    {
#line 396
    vt_send('>');
#line 397
    vt_send(' ');
#line 398
    tmp_e = mc_getline(w, y);
#line 399
    mc_wdrawelm_var(w, tmp_e, tmp_line);
#line 400
    tmp_line[w->xs] = 0;
#line 401
    x = w->xs - 1;
    }
    {
#line 401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 401
      if (! (x >= 0)) {
#line 401
        goto while_break___0;
      }
#line 402
      if (tmp_line[x] <= 32) {
#line 403
        tmp_line[x] = 0;
      } else {
#line 405
        goto while_break___0;
      }
#line 401
      x --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    x = 0;
    {
#line 407
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 407
      if (! tmp_line[x]) {
#line 407
        goto while_break___1;
      }
      {
#line 411
      len = one_wctomb(buf___6, tmp_line[x]);
#line 412
      i = (size_t )0;
      }
      {
#line 412
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 412
        if (! (i < len)) {
#line 412
          goto while_break___2;
        }
        {
#line 413
        vt_send((int )buf___6[i]);
#line 412
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 407
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 415
    vt_send(13);
#line 395
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  return;
}
}
#line 426 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static wchar_t look_for[30]  ;
#line 436
static void scrollback(void) ;
#line 436 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static int hit  =    0;
#line 420 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void scrollback(void) 
{ 
  int y ;
  int c___0 ;
  WIN *b_us ;
  WIN *b_st ;
  ELM *tmp_e ;
  int case_matters ;
  wchar_t tmp_line[256] ;
  int citemode ;
  int cite_ystart ;
  int cite_yend ;
  int cite_y ;
  int inverse ;
  int loop ;
  char hline0[128] ;
  char hline1[128] ;
  char *hline ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  wchar_t *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  ELM *tmp___10 ;
  ELM *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  wchar_t *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  ELM *tmp___17 ;
  ELM *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  ELM *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 425
  case_matters = 0;
#line 428
  citemode = 0;
#line 429
  cite_ystart = 1000000;
#line 429
  cite_yend = -1;
#line 429
  cite_y = 0;
#line 433
  loop = 1;
#line 439
  y = us->y2;
#line 441
  if ((unsigned long )st == (unsigned long )((WIN *)0)) {
#line 442
    y --;
  } else
#line 441
  if (st) {
#line 441
    if (tempst) {
#line 442
      y --;
    }
  }
  {
#line 445
  b_us = mc_wopen(0, 0, us->x2, y, 0, (int )us->attr, (int )us->color >> 4, (int )us->color % 16,
                  0, 0, 0);
#line 447
  mc_wcursor(b_us, 0);
#line 450
  b_st = mc_wopen(0, y + 1, us->x2, y + 1, 0, st_attr, sfcolor, sbcolor, 0, 0, 1);
#line 451
  b_st->doscroll = (char)0;
#line 452
  b_st->wrap = (char)0;
#line 461
  tmp = gettext("HISTORY: U=Up D=Down F=PgDn B=PgUp s=Srch S=CaseLess N=Next C=Cite ESC=Exit ");
#line 461
  strcpy((char */* __restrict  */)(hline0), (char const   */* __restrict  */)tmp);
  }
#line 464
  if (b_st->xs < 127) {
#line 465
    hline0[b_st->xs] = (char)0;
  }
  {
#line 466
  hline = hline0;
#line 467
  mc_wprintf(b_st, "%s", hline);
#line 468
  mc_wredraw(b_st, 1);
#line 469
  mc_wflush();
#line 472
  y = us->histlines;
#line 479
  hit = 0;
#line 481
  drawhist(b_us, y, 0);
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! loop) {
#line 483
      goto while_break;
    }
    {
#line 484
    c___0 = wxgetch();
    }
    {
#line 491
    if (c___0 == 83) {
#line 491
      goto case_83;
    }
#line 491
    if (c___0 == 92) {
#line 491
      goto case_83;
    }
#line 498
    if (c___0 == 115) {
#line 498
      goto case_115;
    }
#line 498
    if (c___0 == 47) {
#line 498
      goto case_115;
    }
#line 547
    if (c___0 == 78) {
#line 547
      goto case_78;
    }
#line 547
    if (c___0 == 110) {
#line 547
      goto case_78;
    }
#line 571
    if (c___0 == 269) {
#line 571
      goto case_269;
    }
#line 571
    if (c___0 == 85) {
#line 571
      goto case_269;
    }
#line 571
    if (c___0 == 117) {
#line 571
      goto case_269;
    }
#line 618
    if (c___0 == 272) {
#line 618
      goto case_272;
    }
#line 618
    if (c___0 == 68) {
#line 618
      goto case_272;
    }
#line 618
    if (c___0 == 100) {
#line 618
      goto case_272;
    }
#line 668
    if (c___0 == 268) {
#line 668
      goto case_268;
    }
#line 668
    if (c___0 == 66) {
#line 668
      goto case_268;
    }
#line 668
    if (c___0 == 98) {
#line 668
      goto case_268;
    }
#line 694
    if (c___0 == 274) {
#line 694
      goto case_274;
    }
#line 694
    if (c___0 == 32) {
#line 694
      goto case_274;
    }
#line 694
    if (c___0 == 70) {
#line 694
      goto case_274;
    }
#line 694
    if (c___0 == 102) {
#line 694
      goto case_274;
    }
#line 716
    if (c___0 == 99) {
#line 716
      goto case_99;
    }
#line 716
    if (c___0 == 67) {
#line 716
      goto case_99;
    }
#line 734
    if (c___0 == 13) {
#line 734
      goto case_13;
    }
#line 734
    if (c___0 == 10) {
#line 734
      goto case_13;
    }
#line 754
    if (c___0 == 27) {
#line 754
      goto case_27;
    }
#line 485
    goto switch_break;
    case_83: /* CIL Label */ 
    case_92: /* CIL Label */ 
#line 492
    case_matters = 0;
    case_115: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 499
    if (! us->histlines) {
      {
#line 500
      mc_wbell();
#line 501
      tmp___0 = gettext("History buffer Disabled!");
#line 501
      werror((char const   *)tmp___0);
      }
#line 502
      goto switch_break;
    }
#line 504
    if (! us->histline) {
      {
#line 505
      mc_wbell();
#line 506
      tmp___1 = gettext("History buffer empty!");
#line 506
      werror((char const   *)tmp___1);
      }
#line 507
      goto switch_break;
    }
#line 509
    if (citemode) {
#line 510
      goto switch_break;
    }
#line 513
    if (c___0 == 47) {
#line 514
      case_matters = 1;
    } else
#line 513
    if (c___0 == 115) {
#line 514
      case_matters = 1;
    }
    {
#line 517
    searchhist(b_us, look_for);
#line 519
    mc_wlocate(b_st, 0, 0);
#line 520
    mc_wprintf(b_st, "%s", hline);
#line 521
    mc_wredraw(b_st, 1);
#line 523
    tmp___2 = wcslen((wchar_t const   *)(look_for));
    }
#line 523
    if (tmp___2 > 1UL) {
      {
#line 524
      hit = find_next(us, b_us, y, look_for, case_matters);
      }
#line 526
      if (hit == -1) {
        {
#line 527
        mc_wbell();
#line 528
        mc_wflush();
#line 529
        hit = 0;
        }
#line 530
        goto switch_break;
      }
      {
#line 532
      drawhist_look(b_us, hit, 1, look_for, case_matters);
#line 533
      y = hit;
      }
    } else {
      {
#line 535
      mc_wbell();
      }
#line 536
      goto switch_break;
    }
    {
#line 538
    mc_wflush();
    }
#line 539
    goto switch_break;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 549
    if (citemode) {
#line 550
      goto switch_break;
    }
    {
#line 551
    tmp___4 = wcslen((wchar_t const   *)(look_for));
    }
#line 551
    if (tmp___4 > 1UL) {
      {
#line 552
      hit = find_next(us, b_us, y, look_for, case_matters);
      }
#line 554
      if (hit == -1) {
        {
#line 555
        mc_wbell();
#line 556
        mc_wflush();
#line 557
        hit = 0;
        }
#line 558
        goto switch_break;
      }
      {
#line 560
      drawhist_look(b_us, hit, 1, look_for, case_matters);
#line 561
      y = hit;
      }
    } else {
      {
#line 563
      mc_wbell();
#line 564
      tmp___3 = gettext("No previous search!\n  Please \'s\' or \'S\' first!");
#line 564
      werror((char const   *)tmp___3);
      }
    }
    {
#line 566
    mc_wflush();
    }
#line 567
    goto switch_break;
    case_269: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_117: /* CIL Label */ 
#line 572
    if (citemode) {
#line 572
      if (cite_y) {
#line 573
        cite_y --;
#line 574
        if (cite_ystart != 1000000) {
          {
#line 575
          cite_yend = y + cite_y;
#line 576
          drawcite(b_us, cite_y + 1, y, cite_ystart, cite_yend);
#line 577
          drawcite(b_us, cite_y, y, cite_ystart, cite_yend);
          }
        }
        {
#line 579
        mc_wlocate(b_us, 0, cite_y);
        }
#line 580
        goto switch_break;
      }
    }
#line 582
    if (y <= 0) {
#line 583
      goto switch_break;
    }
#line 584
    y --;
#line 585
    if (cite_ystart != 1000000) {
#line 586
      cite_yend = y + cite_y;
    }
    {
#line 587
    mc_wscroll(b_us, 2);
    }
#line 595
    if (citemode) {
#line 596
      if (y + cite_y >= cite_ystart) {
#line 596
        if (y + cite_y <= cite_yend) {
#line 596
          tmp___5 = 1;
        } else {
#line 596
          tmp___5 = 0;
        }
      } else {
#line 596
        tmp___5 = 0;
      }
#line 596
      inverse = tmp___5;
    } else {
      {
#line 598
      tmp_e = mc_getline(b_us, y);
#line 599
      tmp___9 = wcslen((wchar_t const   *)(look_for));
      }
#line 599
      if (tmp___9 > 1UL) {
        {
#line 601
        mc_wdrawelm_var(b_us, tmp_e, tmp_line);
#line 602
        tmp___6 = wcslen((wchar_t const   *)(tmp_line));
        }
#line 602
        if (tmp___6 > 1UL) {
          {
#line 602
          tmp___7 = StrStr(tmp_line, look_for, case_matters);
          }
#line 602
          if (tmp___7) {
#line 602
            tmp___8 = 1;
          } else {
#line 602
            tmp___8 = 0;
          }
        } else {
#line 602
          tmp___8 = 0;
        }
#line 602
        inverse = tmp___8;
      } else {
#line 605
        inverse = 0;
      }
    }
#line 608
    if (inverse) {
      {
#line 609
      tmp___10 = mc_getline(b_us, y);
#line 609
      mc_wdrawelm_inverse(b_us, 0, tmp___10);
      }
    } else {
      {
#line 611
      tmp___11 = mc_getline(b_us, y);
#line 611
      mc_wdrawelm(b_us, 0, tmp___11);
      }
    }
#line 612
    if (citemode) {
      {
#line 613
      mc_wlocate(b_us, 0, cite_y);
      }
    }
    {
#line 614
    mc_wflush();
    }
#line 615
    goto switch_break;
    case_272: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
#line 619
    if (citemode) {
#line 619
      if (cite_y < b_us->ys - 1) {
#line 620
        cite_y ++;
#line 621
        if (cite_ystart != 1000000) {
          {
#line 622
          cite_yend = y + cite_y;
#line 623
          drawcite(b_us, cite_y - 1, y, cite_ystart, cite_yend);
#line 624
          drawcite(b_us, cite_y, y, cite_ystart, cite_yend);
          }
        }
        {
#line 626
        mc_wlocate(b_us, 0, cite_y);
        }
#line 627
        goto switch_break;
      }
    }
#line 630
    if (y >= us->histlines) {
#line 631
      goto switch_break;
    }
#line 632
    y ++;
#line 633
    if (cite_ystart != 1000000) {
#line 634
      cite_yend = y + cite_y;
    }
    {
#line 635
    mc_wscroll(b_us, 1);
    }
#line 643
    if (citemode) {
#line 644
      if (y + cite_y >= cite_ystart) {
#line 644
        if (y + cite_y <= cite_yend) {
#line 644
          tmp___12 = 1;
        } else {
#line 644
          tmp___12 = 0;
        }
      } else {
#line 644
        tmp___12 = 0;
      }
#line 644
      inverse = tmp___12;
    } else {
      {
#line 646
      tmp_e = mc_getline(b_us, (y + b_us->ys) - 1);
#line 647
      tmp___16 = wcslen((wchar_t const   *)(look_for));
      }
#line 647
      if (tmp___16 > 1UL) {
        {
#line 649
        mc_wdrawelm_var(b_us, tmp_e, tmp_line);
#line 650
        tmp___13 = wcslen((wchar_t const   *)(tmp_line));
        }
#line 650
        if (tmp___13 > 1UL) {
          {
#line 650
          tmp___14 = StrStr(tmp_line, look_for, case_matters);
          }
#line 650
          if (tmp___14) {
#line 650
            tmp___15 = 1;
          } else {
#line 650
            tmp___15 = 0;
          }
        } else {
#line 650
          tmp___15 = 0;
        }
#line 650
        inverse = tmp___15;
      } else {
#line 653
        inverse = 0;
      }
    }
#line 656
    if (inverse) {
      {
#line 657
      tmp___17 = mc_getline(b_us, (y + b_us->ys) - 1);
#line 657
      mc_wdrawelm_inverse(b_us, b_us->ys - 1, tmp___17);
      }
    } else {
      {
#line 660
      tmp___18 = mc_getline(b_us, (y + b_us->ys) - 1);
#line 660
      mc_wdrawelm(b_us, b_us->ys - 1, tmp___18);
      }
    }
#line 662
    if (citemode) {
      {
#line 663
      mc_wlocate(b_us, 0, cite_y);
      }
    }
    {
#line 664
    mc_wflush();
    }
#line 665
    goto switch_break;
    case_268: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 669
    if (y <= 0) {
#line 670
      goto switch_break;
    }
#line 671
    y -= b_us->ys;
#line 672
    if (y < 0) {
#line 673
      y = 0;
    }
#line 674
    if (cite_ystart != 1000000) {
#line 675
      cite_yend = y + cite_y;
    }
    {
#line 683
    tmp___19 = wcslen((wchar_t const   *)(look_for));
    }
#line 683
    if (tmp___19 > 1UL) {
#line 683
      if (us->histline) {
        {
#line 684
        drawhist_look(b_us, y, 1, look_for, case_matters);
        }
      } else {
        {
#line 686
        drawhist(b_us, y, 1);
        }
      }
    } else {
      {
#line 686
      drawhist(b_us, y, 1);
      }
    }
#line 688
    if (citemode) {
      {
#line 689
      mc_wlocate(b_us, 0, cite_y);
      }
    }
#line 690
    goto switch_break;
    case_274: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 695
    if (y >= us->histlines) {
#line 696
      goto switch_break;
    }
#line 697
    y += b_us->ys;
#line 698
    if (y > us->histlines) {
#line 699
      y = us->histlines;
    }
#line 700
    if (cite_ystart != 1000000) {
#line 701
      cite_yend = y + cite_y;
    }
    {
#line 709
    tmp___20 = wcslen((wchar_t const   *)(look_for));
    }
#line 709
    if (tmp___20 > 1UL) {
#line 709
      if (us->histline) {
        {
#line 710
        drawhist_look(b_us, y, 1, look_for, case_matters);
        }
      } else {
        {
#line 712
        drawhist(b_us, y, 1);
        }
      }
    } else {
      {
#line 712
      drawhist(b_us, y, 1);
      }
    }
#line 713
    if (citemode) {
      {
#line 714
      mc_wlocate(b_us, 0, cite_y);
      }
    }
#line 715
    goto switch_break;
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 717
    citemode ^= 1;
#line 717
    if (citemode) {
      {
#line 718
      cite_y = 0;
#line 719
      cite_ystart = 1000000;
#line 720
      cite_yend = -1;
#line 721
      tmp___21 = gettext("  CITATION: ENTER=select start line ESC=exit                               ");
#line 721
      strcpy((char */* __restrict  */)(hline1), (char const   */* __restrict  */)tmp___21);
      }
#line 722
      if (b_st->xs < 127) {
#line 723
        hline1[b_st->xs] = (char)0;
      }
#line 724
      hline = hline1;
    } else {
#line 726
      hline = hline0;
    }
    {
#line 728
    mc_wlocate(b_st, 0, 0);
#line 729
    mc_wprintf(b_st, "%s", hline);
#line 730
    mc_wredraw(b_st, 1);
    }
#line 731
    if (citemode) {
      {
#line 732
      mc_wlocate(b_us, 0, cite_y);
      }
    }
#line 733
    goto switch_break;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 735
    if (! citemode) {
#line 735
      goto switch_break;
    }
#line 736
    if (cite_ystart == 1000000) {
      {
#line 737
      cite_ystart = y + cite_y;
#line 737
      cite_yend = cite_ystart;
#line 738
      tmp___22 = gettext("  CITATION: ENTER=select end line ESC=exit                                 ");
#line 738
      strcpy((char */* __restrict  */)(hline1), (char const   */* __restrict  */)tmp___22);
      }
#line 739
      if (b_st->xs < 127) {
#line 740
        hline1[b_st->xs] = (char)0;
      }
    } else {
#line 742
      if (cite_ystart > cite_yend) {
#line 743
        goto switch_break;
      }
      {
#line 744
      drawcite_whole(b_us, y, 1000000, -1);
#line 745
      loop = 0;
      }
#line 746
      goto switch_break;
    }
    {
#line 748
    mc_wlocate(b_st, 0, 0);
#line 749
    mc_wprintf(b_st, "%s", hline);
#line 750
    mc_wredraw(b_st, 1);
#line 751
    tmp___23 = mc_getline(b_us, cite_ystart);
#line 751
    mc_wdrawelm_inverse(b_us, cite_y, tmp___23);
#line 752
    mc_wlocate(b_us, 0, cite_y);
    }
#line 753
    goto switch_break;
    case_27: /* CIL Label */ 
#line 755
    if (! citemode) {
#line 756
      loop = 0;
#line 757
      goto switch_break;
    }
#line 759
    if (cite_ystart == 1000000) {
#line 760
      citemode = 0;
#line 761
      hline = hline0;
    } else {
      {
#line 763
      cite_ystart = 1000000;
#line 764
      tmp___24 = gettext("  CITATION: ENTER=select start line ESC=exit                               ");
#line 764
      strcpy((char */* __restrict  */)(hline1), (char const   */* __restrict  */)tmp___24);
      }
    }
    {
#line 766
    drawcite_whole(b_us, y, cite_ystart, cite_yend);
#line 767
    mc_wlocate(b_st, 0, 0);
#line 768
    mc_wprintf(b_st, "%s", hline);
#line 769
    mc_wredraw(b_st, 1);
    }
#line 770
    if (citemode) {
      {
#line 771
      mc_wlocate(b_us, 0, cite_y);
      }
    }
#line 772
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 776
  if (citemode) {
    {
#line 777
    do_cite(b_us, cite_ystart, cite_yend);
    }
  }
#line 778
  if (y == us->histlines) {
#line 778
    tmp___25 = 0;
  } else {
#line 778
    tmp___25 = 1;
  }
  {
#line 778
  mc_wclose(b_us, tmp___25);
#line 779
  mc_wclose(b_st, 1);
#line 780
  mc_wlocate(us, (int )us->curx, (int )us->cury);
#line 781
  mc_wflush();
#line 782
  mc_wredraw(us, 1);
  }
#line 783
  return;
}
}
#line 787 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void change_size(int sig ) 
{ 


  {
  {
#line 790
  size_changed = 1;
#line 791
  signal(28, & change_size);
  }
#line 792
  return;
}
}
#line 795 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void usage___0(int env_args , int optind___0 , char *mc ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 797
  if (env_args >= optind___0) {
#line 797
    if (mc) {
      {
#line 798
      tmp = gettext("Wrong option in environment MINICOM=\"%s\"\n");
#line 798
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              mc);
      }
    }
  }
  {
#line 799
  tmp___0 = gettext("Type \"minicom %s\" for help.\n");
#line 799
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          "--help");
#line 800
  exit(1);
  }
}
}
#line 804 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void helpthem(void) 
{ 
  char *mc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 806
  tmp = getenv("MINICOM");
#line 806
  mc = tmp;
#line 808
  tmp___0 = gettext("Usage: %s [OPTION]... [configuration]\nA terminal program for Linux and other unix-like systems.\n\n  -b, --baudrate         : set baudrate (ignore the value from config)\n  -D, --device           : set device name (ignore the value from config)\n  -s, --setup            : enter setup mode\n  -o, --noinit           : do not initialize modem & lockfiles at startup\n  -m, --metakey          : use meta or alt key for commands\n  -M, --metakey8         : use 8bit meta key for commands\n  -l, --ansi             : literal; assume screen uses non IBM-PC character set\n  -L, --iso              : don\'t assume screen uses ISO8859\n  -w, --wrap             : Linewrap on\n  -H, --displayhex       : display output in hex\n  -z, --statline         : try to use terminal\'s status line\n  -7, --7bit             : force 7bit mode\n  -8, --8bit             : force 8bit mode\n  -c, --color=on/off     : ANSI style color usage on or off\n  -a, --attrib=on/off    : use reverse or highlight attributes on or off\n  -t, --term=TERM        : override TERM environment variable\n  -S, --script=SCRIPT    : run SCRIPT at startup\n  -d, --dial=ENTRY       : dial ENTRY from the dialing directory\n  -p, --ptty=TTYP        : connect to pseudo terminal\n  -C, --capturefile=FILE : start capturing to FILE\n  -F, --statlinefmt      : format of status line\n  -R, --remotecharset    : character set of communication partner\n  -v, --version          : output version information and exit\n  -h, --help             : show help\n  configuration          : configuration file to use\n\nThese options can also be specified in the MINICOM environment variable.\n");
#line 808
  printf((char const   */* __restrict  */)tmp___0, "minicom");
  }
#line 838
  if (mc) {
    {
#line 839
    tmp___1 = gettext("This variable is currently set to \"%s\".\n");
#line 839
    printf((char const   */* __restrict  */)tmp___1, mc);
    }
  } else {
    {
#line 841
    tmp___2 = gettext("This variable is currently unset.\n");
#line 841
    printf((char const   */* __restrict  */)tmp___2);
    }
  }
  {
#line 843
  tmp___3 = gettext("The configuration directory for the access file and the configurations\nis compiled to %s.\n\nReport bugs to <minicom-devel@lists.alioth.debian.org>.\n");
#line 843
  printf((char const   */* __restrict  */)tmp___3, "/usr/local/etc");
  }
#line 847
  return;
}
}
#line 849 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void set_addlf(int val ) 
{ 


  {
  {
#line 851
  vt_set(val, -1, -1, -1, -1, -1, -1, -1, -1);
  }
#line 852
  return;
}
}
#line 855 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void toggle_addlf(void) 
{ 


  {
  {
#line 857
  addlf = ! addlf;
#line 858
  set_addlf(addlf);
  }
#line 859
  return;
}
}
#line 861 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void set_addcr(int val ) 
{ 


  {
  {
#line 863
  vt_set(-1, -1, -1, -1, -1, -1, -1, -1, val);
  }
#line 864
  return;
}
}
#line 867 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void toggle_addcr(void) 
{ 


  {
  {
#line 869
  addcr = ! addcr;
#line 870
  set_addcr(addcr);
  }
#line 871
  return;
}
}
#line 873 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void set_local_echo(int val ) 
{ 


  {
  {
#line 875
  vt_set(-1, -1, -1, -1, val, -1, -1, -1, -1);
  }
#line 876
  return;
}
}
#line 879 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void toggle_local_echo(void) 
{ 


  {
  {
#line 881
  local_echo = ! local_echo;
#line 882
  set_local_echo(local_echo);
  }
#line 883
  return;
}
}
#line 885 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void set_line_timestamp(int val ) 
{ 


  {
  {
#line 887
  vt_set(-1, -1, -1, -1, -1, -1, -1, val, -1);
  }
#line 888
  return;
}
}
#line 891 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void toggle_line_timestamp(void) 
{ 


  {
  {
#line 893
  line_timestamp ++;
#line 894
  line_timestamp %= 4;
#line 895
  set_line_timestamp(line_timestamp);
  }
#line 896
  return;
}
}
#line 900 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void do_iconv_just_copy(char **inbuf___0 , size_t *inbytesleft , char **outbuf ,
                               size_t *outbytesleft ) 
{ 


  {
  {
#line 903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 903
    if (*outbytesleft) {
#line 903
      if (! *inbytesleft) {
#line 903
        goto while_break;
      }
    } else {
#line 903
      goto while_break;
    }
#line 905
    *(*outbuf) = *(*inbuf___0);
#line 906
    (*outbuf) ++;
#line 907
    (*inbuf___0) ++;
#line 908
    (*outbytesleft) --;
#line 909
    (*inbytesleft) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 911
  return;
}
}
#line 914 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static iconv_t iconv_rem2local  ;
#line 915 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static int iconv_enabled  ;
#line 917 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
int using_iconv(void) 
{ 


  {
#line 919
  return (iconv_enabled);
}
}
#line 922 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void init_iconv(char const   *remote_charset ) 
{ 
  char local_charset[40] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 927
  if (! remote_charset) {
#line 928
    return;
  }
  {
#line 931
  tmp = getenv("LC_CTYPE");
  }
#line 932
  if (! tmp) {
    {
#line 933
    tmp = getenv("LC_ALL");
    }
  }
#line 934
  if (! tmp) {
    {
#line 935
    tmp = getenv("LANG");
    }
  }
#line 936
  if (! tmp) {
#line 937
    tmp = (char *)"ASCII";
  }
  {
#line 940
  tmp___1 = strchr((char const   *)tmp, '.');
  }
#line 940
  if (tmp___1) {
    {
#line 941
    tmp___0 = strchr((char const   *)tmp, '.');
#line 941
    tmp = tmp___0 + 1;
    }
  }
  {
#line 943
  snprintf((char */* __restrict  */)(local_charset), sizeof(local_charset), (char const   */* __restrict  */)"%s//TRANSLIT",
           tmp);
#line 945
  local_charset[sizeof(local_charset) - 1UL] = (char)0;
#line 953
  iconv_rem2local = iconv_open((char const   *)(local_charset), remote_charset);
  }
#line 954
  if ((unsigned long )iconv_rem2local != (unsigned long )((iconv_t )-1)) {
#line 955
    iconv_enabled = 1;
  } else {
    {
#line 957
    tmp___2 = __errno_location();
#line 957
    tmp___3 = __errno_location();
#line 957
    tmp___4 = strerror(*tmp___3);
#line 957
    printf((char const   */* __restrict  */)"Activating iconv failed with: %s(%d)\n",
           tmp___4, *tmp___2);
    }
  }
#line 959
  return;
}
}
#line 961 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
void do_iconv(char **inbuf___0 , size_t *inbytesleft , char **outbuf , size_t *outbytesleft ) 
{ 
  size_t tmp ;

  {
#line 964
  if (! iconv_enabled) {
#line 964
    goto _L;
  } else {
    {
#line 964
    tmp = iconv(iconv_rem2local, (char **/* __restrict  */)inbuf___0, (size_t */* __restrict  */)inbytesleft,
                (char **/* __restrict  */)outbuf, (size_t */* __restrict  */)outbytesleft);
    }
#line 964
    if (tmp == 0xffffffffffffffffUL) {
      _L: /* CIL Label */ 
      {
#line 969
      do_iconv_just_copy(inbuf___0, inbytesleft, outbuf, outbytesleft);
      }
#line 973
      if (iconv_enabled) {
        {
#line 974
        iconv(iconv_rem2local, (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0),
              (char **/* __restrict  */)((void *)0), (size_t */* __restrict  */)((void *)0));
        }
      }
    }
  }
#line 976
  return;
}
}
#line 978 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static void close_iconv(void) 
{ 


  {
#line 980
  if (iconv_enabled) {
    {
#line 981
    iconv_close(iconv_rem2local);
    }
  }
#line 982
  return;
}
}
#line 1029 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.c"
static struct option long_options[26]  = 
#line 1029
  {      {"setup", 0, (int *)((void *)0), 's'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"ptty", 1, (int *)((void *)0), 'p'}, 
        {"metakey", 0, (int *)((void *)0), 'm'}, 
        {"metakey8", 0, (int *)((void *)0), 'M'}, 
        {"ansi", 0, (int *)((void *)0), 'l'}, 
        {"iso", 0, (int *)((void *)0), 'L'}, 
        {"term", 1, (int *)((void *)0), 't'}, 
        {"noinit", 0, (int *)((void *)0), 'o'}, 
        {"color", 1, (int *)((void *)0), 'c'}, 
        {"attrib", 1, (int *)((void *)0), 'a'}, 
        {"dial", 1, (int *)((void *)0), 'd'}, 
        {"statline", 0, (int *)((void *)0), 'z'}, 
        {"capturefile", 1, (int *)((void *)0), 'C'}, 
        {"script", 1, (int *)((void *)0), 'S'}, 
        {"7bit", 0, (int *)((void *)0), '7'}, 
        {"8bit", 0, (int *)((void *)0), '8'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"wrap", 0, (int *)((void *)0), 'w'}, 
        {"displayhex", 0, (int *)((void *)0), 'H'}, 
        {"disabletime", 0, (int *)((void *)0), 'T'}, 
        {"baudrate", 1, (int *)((void *)0), 'b'}, 
        {"device", 1, (int *)((void *)0), 'D'}, 
        {"remotecharset", 1, (int *)((void *)0), 'R'}, 
        {"statlinefmt", 1, (int *)((void *)0), 'F'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 147 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcscpy)(wchar_t * __restrict  __dest ,
                                                                                  wchar_t const   * __restrict  __src ) ;
#line 150
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcsncpy)(wchar_t * __restrict  __dest ,
                                                                                   wchar_t const   * __restrict  __src ,
                                                                                   size_t __n ) ;
#line 227
extern  __attribute__((__nothrow__)) wchar_t *( __attribute__((__leaf__)) wcschr)(wchar_t const   *__wcs ,
                                                                                  wchar_t __wc )  __attribute__((__pure__)) ;
#line 59 "/usr/include/termcap.h"
extern char *BC ;
#line 64
extern char *tgoto(char const   * , int  , int  ) ;
#line 66
extern int tgetflag(char const   * ) ;
#line 67
extern int tgetnum(char const   * ) ;
#line 68
extern int tputs(char const   * , int  , int (*)(int  ) ) ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
WIN *stdwin  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int LINES  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
int COLS  ;
#line 71
int w_init ;
#line 181
void win_end(void) ;
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CM  ;
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *IS  ;
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *RS  ;
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *AC  ;
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *EA  ;
#line 63 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *ME  ;
#line 63 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *SE  ;
#line 63 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *UE  ;
#line 63 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *AE  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *AS  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *MB  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *MD  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *MR  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *SO  ;
#line 64 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *US  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CE  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *Al  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *Dl  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *AL  ;
#line 65 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *DL  ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CS  ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *SF  ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *SR  ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *VB  ;
#line 66 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *BL  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *VE  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *VI  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *KS  ;
#line 67 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *KE  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CD  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CL  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *IC  ;
#line 68 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *DC  ;
#line 69 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *CR  ;
#line 69 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *NL  ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *TS  ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *FS  ;
#line 71 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *DS  ;
#line 75 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_UL  ;
#line 76 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_HOR  ;
#line 77 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_UR  ;
#line 78 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_LL  ;
#line 79 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_VER  ;
#line 80 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char D_LR  ;
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_UL  ;
#line 83 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_HOR  ;
#line 84 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_UR  ;
#line 85 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_LL  ;
#line 86 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_VER  ;
#line 87 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char S_LR  ;
#line 89 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char _bufstart[2048]  ;
#line 90 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char *_bufpos  =    _bufstart;
#line 91 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char *_buffend  ;
#line 92 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static ELM *gmap  ;
#line 94 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char curattr  =    (char)-1;
#line 95 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char curcolor  =    (char)-1;
#line 96 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int curx  =    -1;
#line 97 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int cury  =    -1;
#line 98 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int _intern  =    0;
#line 99 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int _curstype  =    1;
#line 100 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int _has_am  =    0;
#line 101 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int _mv_standout  =    0;
#line 102 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static ELM oldc  ;
#line 103 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int sflag  =    0;
#line 115 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int useattr  =    1;
#line 116 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int dirflush  =    1;
#line 118 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int usecolor  =    0;
#line 125 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
char *_tptr  =    (char *)((void *)0);
#line 126 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int screen_ibmpc  =    0;
#line 127 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int screen_iso  =    0;
#line 128 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int w_init  =    0;
#line 129 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int use_status  =    0;
#line 132 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char const   *def_ac  =    "+\273,\253aaffggjjkkllmmnnooqqssttuuvvwwxx";
#line 157 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wflush(void) 
{ 
  int todo ;
  int done ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 161
  todo = (int )(_bufpos - _bufstart);
#line 162
  _bufpos = _bufstart;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (todo > 0)) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp = write(1, (void const   *)_bufpos, (size_t )todo);
#line 165
    done = (int )tmp;
    }
#line 166
    if (done > 0) {
#line 167
      todo -= done;
#line 168
      _bufpos += done;
    }
#line 170
    if (done < 0) {
      {
#line 170
      tmp___0 = __errno_location();
      }
#line 170
      if (*tmp___0 != 4) {
#line 171
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  _bufpos = _bufstart;
#line 174
  return;
}
}
#line 179 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int outchar(int c___0 ) 
{ 
  char *tmp ;

  {
#line 181
  tmp = _bufpos;
#line 181
  _bufpos ++;
#line 181
  *tmp = (char )c___0;
#line 182
  if ((unsigned long )_bufpos >= (unsigned long )_buffend) {
    {
#line 183
    mc_wflush();
    }
  }
#line 188
  return (0);
}
}
#line 194 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void outstr(char const   *s___0 ) 
{ 


  {
  {
#line 196
  tputs(s___0, 1, & outchar);
  }
#line 197
  return;
}
}
#line 203 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _attroff(void) 
{ 


  {
#line 205
  if (ME) {
    {
#line 206
    outstr(ME);
    }
  } else {
#line 208
    if (SE) {
      {
#line 209
      outstr(SE);
      }
    }
#line 210
    if (UE) {
      {
#line 211
      outstr(UE);
      }
    }
  }
#line 213
  if (AE) {
    {
#line 214
    outstr(AE);
    }
  }
#line 215
  return;
}
}
#line 220 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _attron(char attr ) 
{ 


  {
#line 222
  if ((int )attr & 4) {
#line 222
    if (MR) {
      {
#line 223
      outstr(MR);
      }
    }
  }
#line 224
  if ((int )attr & 2) {
#line 224
    if (MD) {
      {
#line 225
      outstr(MD);
      }
    }
  }
#line 226
  if ((int )attr & 8) {
#line 226
    if (SO) {
      {
#line 227
      outstr(SO);
      }
    }
  }
#line 228
  if ((int )attr & 16) {
#line 228
    if (US) {
      {
#line 229
      outstr(US);
      }
    }
  }
#line 230
  if ((int )attr & 1) {
#line 230
    if (MB) {
      {
#line 231
      outstr(MB);
      }
    }
  }
#line 232
  if ((int )attr & 32) {
#line 232
    if (AS) {
      {
#line 233
      outstr(AS);
      }
    }
  }
#line 234
  return;
}
}
#line 239 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _colson(char color ) 
{ 
  char buf___6[12] ;

  {
  {
#line 242
  sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"\033[%d;%dm",
          ((int )color >> 4) + 30, (int )color % 16 + 40);
#line 243
  outstr((char const   *)(buf___6));
  }
#line 244
  return;
}
}
#line 249 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _setattr(char attr , char color ) 
{ 


  {
#line 251
  if (! useattr) {
#line 252
    return;
  }
#line 254
  if (! usecolor) {
#line 255
    curcolor = color;
#line 256
    if ((int )attr == (int )curattr) {
#line 257
      return;
    }
    {
#line 258
    curattr = attr;
#line 259
    _attroff();
#line 260
    _attron(attr);
    }
#line 261
    return;
  }
#line 263
  if ((int )attr == (int )curattr) {
#line 263
    if ((int )color == (int )curcolor) {
#line 264
      return;
    }
  }
  {
#line 265
  _attroff();
#line 266
  _colson(color);
#line 267
  _attron(attr);
#line 268
  curattr = attr;
#line 269
  curcolor = color;
  }
#line 270
  return;
}
}
#line 275 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _gotoxy(int x , int y ) 
{ 
  int oldattr ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 277
  oldattr = -1;
#line 283
  if (x >= COLS) {
#line 284
    return;
  } else
#line 283
  if (y > LINES) {
#line 284
    return;
  } else
#line 283
  if (x == curx) {
#line 283
    if (y == cury) {
#line 284
      return;
    }
  }
#line 286
  if (use_status) {
#line 288
    if (cury == LINES) {
#line 288
      if (y < cury) {
        {
#line 289
        outstr(FS);
#line 291
        tmp = (int )curattr;
#line 292
        curattr = (char)-1;
#line 293
        _setattr((char )tmp, curcolor);
#line 294
        tmp___0 = tgoto(CM, x, y);
#line 294
        outstr((char const   *)tmp___0);
#line 295
        curx = x;
#line 295
        cury = y;
        }
#line 296
        return;
      } else {
#line 288
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 299
    if (y == LINES) {
#line 301
      if (cury < y) {
        {
#line 302
        tmp___1 = tgoto(TS, x, x);
#line 302
        outstr((char const   *)tmp___1);
#line 303
        curx = x;
#line 304
        cury = y;
#line 306
        tmp = (int )curattr;
#line 307
        curattr = (char)-1;
#line 308
        _setattr((char )tmp, curcolor);
        }
#line 309
        return;
      }
    }
  }
#line 325
  if (! _mv_standout) {
#line 325
    if ((int )curattr != 0) {
      {
#line 326
      oldattr = (int )curattr;
#line 327
      _setattr((char)0, curcolor);
      }
    }
  }
#line 329
  if ((unsigned long )CR != (unsigned long )((void *)0)) {
#line 329
    if (y == cury) {
#line 329
      if (x == 0) {
        {
#line 330
        outstr(CR);
        }
      } else {
#line 329
        goto _L___4;
      }
    } else {
#line 329
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 335
  if ((unsigned long )NL != (unsigned long )((void *)0)) {
#line 335
    if (x == 0) {
#line 335
      if (x == curx) {
#line 335
        if (y == cury + 1) {
          {
#line 336
          outstr(NL);
          }
        } else {
#line 335
          goto _L___2;
        }
      } else {
#line 335
        goto _L___2;
      }
    } else {
#line 335
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 338
  if ((unsigned long )BC != (unsigned long )((void *)0)) {
#line 338
    if (y == cury) {
#line 338
      if (x == curx - 1) {
        {
#line 339
        outstr((char const   *)BC);
        }
      } else {
        {
#line 341
        tmp___2 = tgoto(CM, x, y);
#line 341
        outstr((char const   *)tmp___2);
        }
      }
    } else {
      {
#line 341
      tmp___2 = tgoto(CM, x, y);
#line 341
      outstr((char const   *)tmp___2);
      }
    }
  } else {
    {
#line 341
    tmp___2 = tgoto(CM, x, y);
#line 341
    outstr((char const   *)tmp___2);
    }
  }
#line 342
  curx = x;
#line 343
  cury = y;
#line 344
  if (oldattr != -1) {
    {
#line 345
    _setattr((char )oldattr, curcolor);
    }
  }
#line 346
  return;
}
}
#line 376
static void _write(wchar_t c___0 , int doit , int x , int y , char attr , char color ) ;
#line 376 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int x0  =    -1;
#line 376 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int y0  =    -1;
#line 376 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int c0  =    0;
#line 377 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char attr0  ;
#line 377 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char color0  ;
#line 354 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _write(wchar_t c___0 , int doit , int x , int y , char attr , char color ) 
{ 
  ELM *e ;
  char buf___6[16] ;
  size_t i ;
  size_t len ;
  int tmp ;

  {
#line 362
  if (_has_am) {
#line 362
    if (y >= LINES - 1) {
#line 362
      if (x >= COLS - 1) {
#line 363
        doit = 0;
#line 364
        sflag = 1;
#line 365
        oldc.value = c___0;
#line 366
        oldc.attr = attr;
#line 367
        oldc.color = color;
      }
    }
  }
#line 370
  if (x < COLS) {
#line 370
    if (y <= LINES) {
#line 375
      if (doit != 0) {
#line 378
        if (x != x0 + 1) {
          {
#line 379
          _gotoxy(x, y);
#line 380
          _setattr(attr, color);
          }
        } else
#line 378
        if (y != y0) {
          {
#line 379
          _gotoxy(x, y);
#line 380
          _setattr(attr, color);
          }
        } else
#line 378
        if ((int )attr != (int )attr0) {
          {
#line 379
          _gotoxy(x, y);
#line 380
          _setattr(attr, color);
          }
        } else
#line 378
        if ((int )color != (int )color0) {
          {
#line 379
          _gotoxy(x, y);
#line 380
          _setattr(attr, color);
          }
        } else
#line 378
        if (! (c0 & 128)) {
          {
#line 379
          _gotoxy(x, y);
#line 380
          _setattr(attr, color);
          }
        }
        {
#line 382
        x0 = x;
#line 382
        y0 = y;
#line 382
        attr0 = attr;
#line 382
        color0 = color;
#line 382
        c0 = c___0;
#line 383
        tmp = using_iconv();
        }
#line 383
        if (tmp) {
          {
#line 384
          outchar((int )((char )c___0));
          }
        } else
#line 383
        if (((int )attr & 32) != 0) {
          {
#line 384
          outchar((int )((char )c___0));
          }
        } else {
          {
#line 389
          len = one_wctomb(buf___6, c___0);
#line 390
          i = (size_t )0;
          }
          {
#line 390
          while (1) {
            while_continue: /* CIL Label */ ;
#line 390
            if (! (i < len)) {
#line 390
              goto while_break;
            }
            {
#line 391
            outchar((int )buf___6[i]);
#line 390
            i ++;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 394
        curx ++;
      }
#line 396
      if (doit >= 0) {
#line 397
        e = gmap + (x + y * COLS);
#line 398
        e->value = c___0;
#line 399
        e->attr = attr;
#line 400
        e->color = color;
      }
    }
  }
#line 403
  return;
}
}
#line 408 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void _cursor(int type ) 
{ 


  {
#line 410
  _curstype = type;
#line 412
  if (type == 1) {
#line 412
    if ((unsigned long )VE != (unsigned long )((void *)0)) {
      {
#line 413
      outstr(VE);
      }
    }
  }
#line 414
  if (type == 0) {
#line 414
    if ((unsigned long )VE != (unsigned long )((void *)0)) {
#line 414
      if ((unsigned long )VI != (unsigned long )((void *)0)) {
        {
#line 415
        outstr(VI);
        }
      }
    }
  }
#line 416
  return;
}
}
#line 473 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
WIN *mc_wopen(int x1 , int y1 , int x2 , int y2 , int border , int attr , int fg ,
              int bg , int direct , int histlines , int doclr ) 
{ 
  WIN *w ;
  ELM *e ;
  int bytes ;
  int x ;
  int y ;
  int color ;
  int offs ;
  int xattr ;
  void *tmp ;
  int d ;
  int d___0 ;
  int tmp___0 ;
  int tmp___1 ;
  char tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ELM *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 487
  tmp = malloc(sizeof(WIN ));
#line 487
  w = (WIN *)tmp;
  }
#line 487
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 488
    return (w);
  }
#line 490
  offs = border != 0;
#line 491
  if (! screen_ibmpc) {
#line 491
    if (AS) {
#line 492
      xattr = attr | 32;
    } else {
#line 494
      xattr = attr;
    }
  } else {
#line 494
    xattr = attr;
  }
#line 496
  if (x1 > x2) {
#line 497
    d = x1;
#line 497
    x1 = x2;
#line 497
    x2 = d;
  }
#line 498
  if (y1 > y2) {
#line 499
    d___0 = y1;
#line 499
    y1 = y2;
#line 499
    y2 = d___0;
  }
#line 500
  if (x1 < offs) {
#line 501
    x1 = offs;
  }
#line 502
  if (y1 < offs) {
#line 503
    y1 = offs;
  }
#line 511
  w->xs = (x2 - x1) + 1;
#line 512
  w->ys = (y2 - y1) + 1;
#line 513
  w->x1 = x1;
#line 514
  w->x2 = x2;
#line 515
  tmp___0 = y1;
#line 515
  w->sy1 = tmp___0;
#line 515
  w->y1 = tmp___0;
#line 516
  tmp___1 = y2;
#line 516
  w->sy2 = tmp___1;
#line 516
  w->y2 = tmp___1;
#line 517
  w->doscroll = (char)1;
#line 518
  w->border = (char )border;
#line 519
  w->cursor = (char)1;
#line 520
  w->attr = (char )attr;
#line 521
  w->autocr = (char)1;
#line 522
  w->wrap = (char)1;
#line 523
  tmp___2 = (char )((fg << 4) + bg);
#line 523
  w->color = tmp___2;
#line 523
  color = (int )tmp___2;
#line 524
  w->curx = (short)0;
#line 525
  w->cury = (short)0;
#line 527
  w->o_curx = (short )curx;
#line 528
  w->o_cury = (short )cury;
#line 529
  w->o_attr = curattr;
#line 530
  w->o_color = curcolor;
#line 531
  w->o_cursor = (char )_curstype;
#line 532
  w->direct = (char )direct;
#line 534
  if (border != 0) {
#line 535
    x1 --;
#line 536
    x2 ++;
#line 537
    y1 --;
#line 538
    y2 ++;
  }
  {
#line 541
  bytes = (int )((unsigned long )(((y2 - y1) + 1) * ((x2 - x1) + 1)) * sizeof(ELM ) + 100UL);
#line 542
  tmp___3 = malloc((size_t )bytes);
#line 542
  e = (ELM *)tmp___3;
  }
#line 542
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 543
    free((void *)w);
    }
#line 544
    return ((WIN *)((void *)0));
  }
#line 546
  w->map = e;
#line 548
  bytes = (int )((unsigned long )((x2 - x1) + 1) * sizeof(ELM ));
#line 550
  y = y1;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (y <= y2)) {
#line 550
      goto while_break;
    }
    {
#line 551
    memcpy((void */* __restrict  */)e, (void const   */* __restrict  */)((gmap + COLS * y) + x1),
           (size_t )bytes);
#line 552
    e += (x2 - x1) + 1;
#line 550
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  tmp___4 = 0;
#line 556
  w->histlines = tmp___4;
#line 556
  w->histline = tmp___4;
#line 557
  w->histbuf = (ELM *)((void *)0);
#line 558
  if (histlines) {
    {
#line 560
    bytes = (int )((unsigned long )(w->xs * histlines) * sizeof(ELM ));
#line 561
    tmp___6 = malloc((size_t )bytes);
#line 561
    tmp___5 = (ELM *)tmp___6;
#line 561
    w->histbuf = tmp___5;
    }
#line 561
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 562
      free((void *)w->map);
#line 563
      free((void *)w);
      }
#line 564
      return ((WIN *)((void *)0));
    }
#line 566
    w->histlines = histlines;
#line 569
    e = w->histbuf;
#line 570
    y = 0;
    {
#line 570
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 570
      if (! (y < w->xs * histlines)) {
#line 570
        goto while_break___0;
      }
#line 571
      e->value = ' ';
#line 572
      e->attr = (char )attr;
#line 573
      e->color = (char )color;
#line 574
      e ++;
#line 570
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 579
  if (border) {
#line 580
    if (border == 1) {
#line 580
      tmp___7 = (int )S_UL;
    } else {
#line 580
      tmp___7 = (int )D_UL;
    }
    {
#line 580
    _write(tmp___7, (int )w->direct, x1, y1, (char )xattr, (char )color);
#line 581
    x = x1 + 1;
    }
    {
#line 581
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 581
      if (! (x < x2)) {
#line 581
        goto while_break___1;
      }
#line 582
      if (border == 1) {
#line 582
        tmp___8 = (int )S_HOR;
      } else {
#line 582
        tmp___8 = (int )D_HOR;
      }
      {
#line 582
      _write(tmp___8, (int )w->direct, x, y1, (char )xattr, (char )color);
#line 581
      x ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 583
    if (border == 1) {
#line 583
      tmp___9 = (int )S_UR;
    } else {
#line 583
      tmp___9 = (int )D_UR;
    }
    {
#line 583
    _write(tmp___9, (int )w->direct, x2, y1, (char )xattr, (char )color);
#line 584
    y = y1 + 1;
    }
    {
#line 584
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 584
      if (! (y < y2)) {
#line 584
        goto while_break___2;
      }
#line 585
      if (border == 1) {
#line 585
        tmp___10 = (int )S_VER;
      } else {
#line 585
        tmp___10 = (int )D_VER;
      }
      {
#line 585
      _write(tmp___10, (int )w->direct, x1, y, (char )xattr, (char )color);
#line 586
      x = x1 + 1;
      }
      {
#line 586
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 586
        if (! (x < x2)) {
#line 586
          goto while_break___3;
        }
        {
#line 587
        _write(' ', (int )w->direct, x, y, (char )attr, (char )color);
#line 586
        x ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 588
      if (border == 1) {
#line 588
        tmp___11 = (int )S_VER;
      } else {
#line 588
        tmp___11 = (int )D_VER;
      }
      {
#line 588
      _write(tmp___11, (int )w->direct, x2, y, (char )xattr, (char )color);
#line 584
      y ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 590
    if (border == 1) {
#line 590
      tmp___12 = (int )S_LL;
    } else {
#line 590
      tmp___12 = (int )D_LL;
    }
    {
#line 590
    _write(tmp___12, (int )w->direct, x1, y2, (char )xattr, (char )color);
#line 591
    x = x1 + 1;
    }
    {
#line 591
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 591
      if (! (x < x2)) {
#line 591
        goto while_break___4;
      }
#line 592
      if (border == 1) {
#line 592
        tmp___13 = (int )S_HOR;
      } else {
#line 592
        tmp___13 = (int )D_HOR;
      }
      {
#line 592
      _write(tmp___13, (int )w->direct, x, y2, (char )xattr, (char )color);
#line 591
      x ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 593
    if (border == 1) {
#line 593
      tmp___14 = (int )S_LR;
    } else {
#line 593
      tmp___14 = (int )D_LR;
    }
    {
#line 593
    _write(tmp___14, (int )w->direct, x2, y2, (char )xattr, (char )color);
    }
#line 594
    if (w->direct) {
      {
#line 595
      _gotoxy(x1 + 1, y1 + 1);
      }
    }
  } else
#line 597
  if (doclr) {
    {
#line 598
    mc_winclr(w);
    }
  }
  {
#line 599
  mc_wcursor(w, 1);
  }
#line 601
  if (w->direct) {
    {
#line 602
    mc_wflush();
    }
  }
#line 603
  return (w);
}
}
#line 609 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclose(WIN *win , int replace ) 
{ 
  ELM *e ;
  int x ;
  int y ;
  ELM *g ;

  {
#line 618
  if (! win) {
#line 619
    return;
  }
#line 621
  if ((unsigned long )win == (unsigned long )stdwin) {
    {
#line 622
    win_end();
    }
#line 623
    return;
  }
#line 625
  e = win->map;
#line 627
  if (win->border) {
#line 628
    (win->x1) --;
#line 629
    (win->x2) ++;
#line 630
    (win->y1) --;
#line 631
    (win->y2) ++;
  }
  {
#line 633
  mc_wcursor(win, (int )win->o_cursor);
  }
#line 634
  if (replace) {
#line 635
    y = win->y1;
    {
#line 635
    while (1) {
      while_continue: /* CIL Label */ ;
#line 635
      if (! (y <= win->y2)) {
#line 635
        goto while_break;
      }
#line 639
      g = gmap + y * stdwin->xs;
#line 640
      x = 0;
      {
#line 640
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 640
        if (! (x < win->x1)) {
#line 640
          goto while_break___0;
        }
        {
#line 641
        _write(g->value, 1, x, y, g->attr, g->color);
#line 642
        g ++;
#line 640
        x ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 645
      x = win->x1;
      {
#line 645
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 645
        if (! (x <= win->x2)) {
#line 645
          goto while_break___1;
        }
        {
#line 646
        _write(e->value, 1, x, y, e->attr, e->color);
#line 647
        e ++;
#line 645
        x ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 635
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 650
    _gotoxy((int )win->o_curx, (int )win->o_cury);
#line 651
    _setattr(win->o_attr, win->o_color);
    }
  }
  {
#line 653
  free((void *)win->map);
  }
#line 654
  if (win->histbuf) {
    {
#line 655
    free((void *)win->histbuf);
    }
  }
  {
#line 656
  free((void *)win);
#line 657
  mc_wflush();
  }
#line 658
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int oldx  ;
#line 660 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int oldy  ;
#line 661 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int ocursor  ;
#line 666 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wleave(void) 
{ 


  {
  {
#line 668
  oldx = curx;
#line 669
  oldy = cury;
#line 670
  ocursor = _curstype;
#line 672
  setcbreak(0);
#line 673
  _gotoxy(0, LINES - 1);
#line 674
  _setattr((char)0, (char )(7 << 4));
#line 675
  _cursor(1);
  }
#line 676
  if ((unsigned long )CL != (unsigned long )((void *)0)) {
    {
#line 677
    outstr(CL);
    }
  } else {
    {
#line 679
    outstr("\n");
    }
  }
#line 681
  if (DS) {
    {
#line 682
    outstr(DS);
    }
  }
#line 684
  if ((unsigned long )KE != (unsigned long )((void *)0)) {
    {
#line 685
    outstr(KE);
    }
  }
#line 686
  if ((unsigned long )RS != (unsigned long )((void *)0)) {
    {
#line 687
    outstr(RS);
    }
  }
  {
#line 688
  mc_wflush();
  }
#line 689
  return;
}
}
#line 691 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wreturn(void) 
{ 
  int x ;
  int y ;
  ELM *e ;

  {
  {
#line 700
  curattr = (char)-1;
#line 701
  curcolor = (char)-1;
#line 703
  setcbreak(1);
  }
#line 705
  if ((unsigned long )IS != (unsigned long )((void *)0)) {
    {
#line 706
    outstr(IS);
    }
  }
#line 707
  if ((unsigned long )EA != (unsigned long )((void *)0)) {
    {
#line 708
    outstr(EA);
    }
  }
#line 709
  if ((unsigned long )KS != (unsigned long )((void *)0)) {
    {
#line 710
    outstr(KS);
    }
  }
  {
#line 712
  _gotoxy(0, 0);
#line 713
  _cursor(ocursor);
#line 715
  e = gmap;
#line 716
  y = 0;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (y < LINES)) {
#line 716
      goto while_break;
    }
#line 717
    x = 0;
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 717
      if (! (x < COLS)) {
#line 717
        goto while_break___0;
      }
      {
#line 718
      _write(e->value, -1, x, y, e->attr, e->color);
#line 719
      e ++;
#line 717
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 722
  _gotoxy(oldx, oldy);
#line 723
  mc_wflush();
  }
#line 724
  return;
}
}
#line 729 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wredraw(WIN *w , int newdirect ) 
{ 
  int minx ;
  int maxx ;
  int miny ;
  int maxy ;
  ELM *e ;
  int x ;
  int y ;
  int addcnt ;

  {
#line 736
  minx = w->x1;
#line 737
  maxx = w->x2;
#line 738
  miny = w->y1;
#line 739
  maxy = w->y2;
#line 740
  addcnt = stdwin->xs - w->xs;
#line 742
  if (w->border) {
#line 743
    minx --;
#line 744
    maxx ++;
#line 745
    miny --;
#line 746
    maxy ++;
#line 747
    addcnt -= 2;
  }
  {
#line 750
  _gotoxy(minx, miny);
#line 751
  _cursor(0);
#line 752
  e = (gmap + miny * stdwin->xs) + minx;
#line 754
  y = miny;
  }
  {
#line 754
  while (1) {
    while_continue: /* CIL Label */ ;
#line 754
    if (! (y <= maxy)) {
#line 754
      goto while_break;
    }
#line 755
    x = minx;
    {
#line 755
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 755
      if (! (x <= maxx)) {
#line 755
        goto while_break___0;
      }
      {
#line 756
      _write(e->value, -1, x, y, e->attr, e->color);
#line 757
      e ++;
#line 755
      x ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    e += addcnt;
#line 754
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 761
  _gotoxy(w->x1 + (int )w->curx, w->y1 + (int )w->cury);
#line 762
  _cursor((int )w->cursor);
#line 763
  mc_wflush();
#line 764
  w->direct = (char )newdirect;
  }
#line 765
  return;
}
}
#line 770 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int _wclreol(WIN *w ) 
{ 
  int x ;
  int doit ;
  int y ;
  int tmp ;

  {
#line 773
  doit = 1;
#line 779
  y = (int )w->cury + w->y1;
#line 781
  if (w->direct) {
#line 781
    if (w->x2 == COLS - 1) {
#line 781
      if (CE) {
        {
#line 782
        _gotoxy((int )w->curx + w->x1, y);
#line 783
        _setattr(w->attr, w->color);
#line 784
        outstr(CE);
#line 785
        doit = 0;
        }
      }
    }
  }
#line 787
  x = (int )w->curx + w->x1;
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (! (x <= w->x2)) {
#line 787
      goto while_break;
    }
#line 788
    if (w->direct) {
#line 788
      if (doit) {
#line 788
        tmp = 1;
      } else {
#line 788
        tmp = 0;
      }
    } else {
#line 788
      tmp = 0;
    }
    {
#line 788
    _write(' ', tmp, x, y, w->attr, w->color);
#line 787
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  return (doit);
}
}
#line 796 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wscroll(WIN *win , int dir ) 
{ 
  ELM *e ;
  ELM *f ;
  char *src ;
  char *dst ;
  int x ;
  int y ;
  int doit ;
  int ocurx ;
  int fs ;
  int len ;
  int phys_scr ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 801
  doit = 1;
#line 802
  fs = 0;
#line 803
  phys_scr = 0;
#line 813
  if (win->direct) {
#line 813
    if ((unsigned long )SF != (unsigned long )((void *)0)) {
#line 813
      if (dir == 1) {
#line 813
        goto _L___6;
      } else
#line 813
      if ((unsigned long )SR != (unsigned long )((void *)0)) {
        _L___6: /* CIL Label */ 
#line 813
        if (LINES == (win->sy2 - win->sy1) + 1) {
          {
#line 815
          doit = 0;
#line 816
          phys_scr = 1;
#line 817
          _setattr(win->attr, win->color);
          }
#line 818
          if (dir == 1) {
            {
#line 819
            _gotoxy(0, LINES - 1);
#line 820
            outstr(SF);
            }
          } else {
            {
#line 822
            _gotoxy(0, 0);
#line 823
            outstr(SR);
            }
          }
        } else {
#line 813
          goto _L___7;
        }
      } else {
#line 813
        goto _L___7;
      }
    } else {
#line 813
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 830
  if (win->direct) {
#line 830
    if (win->xs == COLS) {
#line 830
      if ((unsigned long )CS != (unsigned long )((void *)0)) {
#line 830
        if ((unsigned long )SF != (unsigned long )((void *)0)) {
#line 830
          if ((unsigned long )SR != (unsigned long )((void *)0)) {
#line 830
            goto _L___1;
          } else {
#line 830
            goto _L___3;
          }
        } else {
#line 830
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 830
      if ((unsigned long )Dl != (unsigned long )((void *)0)) {
#line 830
        if ((unsigned long )Al != (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
          {
#line 833
          doit = 0;
#line 834
          phys_scr = 1;
#line 835
          _setattr(win->attr, win->color);
          }
#line 836
          if ((unsigned long )CS != (unsigned long )((void *)0)) {
#line 836
            if ((unsigned long )SF != (unsigned long )((void *)0)) {
#line 836
              if ((unsigned long )SR != (unsigned long )((void *)0)) {
#line 841
                if (win->sy2 == LINES - 1) {
#line 841
                  if (win->sy1 == 0) {
#line 842
                    fs = 1;
                  }
                }
#line 843
                if (! fs) {
                  {
#line 844
                  tmp = tgoto(CS, win->sy2, win->sy1);
#line 844
                  outstr((char const   *)tmp);
#line 845
                  cury = 0;
                  }
                }
#line 847
                if (dir == 1) {
                  {
#line 848
                  _gotoxy(0, win->sy2);
#line 849
                  outstr(SF);
                  }
                } else {
                  {
#line 851
                  _gotoxy(0, win->sy1);
#line 852
                  outstr(SR);
                  }
                }
#line 854
                if (! fs) {
                  {
#line 855
                  tmp___0 = tgoto(CS, LINES - 1, 0);
#line 855
                  outstr((char const   *)tmp___0);
#line 856
                  cury = 0;
                  }
                }
                {
#line 858
                _gotoxy(0, win->sy2);
                }
              } else {
#line 836
                goto _L___0;
              }
            } else {
#line 836
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 860
          if (dir == 1) {
            {
#line 861
            _gotoxy(0, win->sy1);
#line 862
            outstr(Dl);
#line 863
            _gotoxy(0, win->sy2);
#line 864
            outstr(Al);
            }
          } else {
            {
#line 866
            _gotoxy(0, win->sy2);
#line 867
            outstr(Dl);
#line 868
            _gotoxy(0, win->sy1);
#line 869
            outstr(Al);
            }
          }
        }
      }
    }
  }
#line 878
  if (sflag) {
#line 878
    if (win->sy2 == LINES - 1) {
#line 878
      if (win->sy1 != win->sy2) {
#line 879
        if (dir == 1) {
          {
#line 880
          _write(oldc.value, 1, COLS - 1, LINES - 2, oldc.attr, oldc.color);
          }
        }
#line 883
        sflag = 0;
      }
    }
  }
#line 886
  ocurx = (int )win->curx;
#line 889
  if (win->histbuf) {
#line 889
    if (dir == 1) {
#line 889
      if (win->sy2 == win->y2) {
#line 889
        if (win->sy1 == win->y1) {
          {
#line 893
          e = (gmap + win->y1 * COLS) + win->x1;
#line 896
          f = win->histbuf + win->xs * win->histline;
#line 899
          memcpy((void */* __restrict  */)((char *)f), (void const   */* __restrict  */)((char *)e),
                 (unsigned long )win->xs * sizeof(ELM ));
#line 902
          (win->histline) ++;
          }
#line 903
          if (win->histline >= win->histlines) {
#line 904
            win->histline = 0;
          }
        }
      }
    }
  }
#line 910
  if (phys_scr) {
#line 911
    len = (int )((unsigned long )((win->sy2 - win->sy1) * win->xs) * sizeof(ELM ));
#line 912
    if (dir == 1) {
#line 913
      dst = (char *)(gmap + 0);
#line 914
      src = (char *)(gmap + win->xs);
#line 915
      win->cury = (short )(win->sy2 - win->y1);
    } else {
#line 917
      src = (char *)(gmap + 0);
#line 918
      dst = (char *)(gmap + win->xs);
#line 919
      win->cury = (short )(win->sy1 - win->y1);
    }
    {
#line 924
    fflush(stdout);
#line 931
    memmove((void *)dst, (void const   *)src, (size_t )len);
    }
  } else
#line 936
  if (dir == 1) {
#line 937
    y = win->sy1 + 1;
    {
#line 937
    while (1) {
      while_continue: /* CIL Label */ ;
#line 937
      if (! (y <= win->sy2)) {
#line 937
        goto while_break;
      }
#line 938
      e = (gmap + y * COLS) + win->x1;
#line 939
      x = win->x1;
      {
#line 939
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 939
        if (! (x <= win->x2)) {
#line 939
          goto while_break___0;
        }
#line 940
        if (win->direct) {
#line 940
          if (doit) {
#line 940
            tmp___1 = 1;
          } else {
#line 940
            tmp___1 = 0;
          }
        } else {
#line 940
          tmp___1 = 0;
        }
        {
#line 940
        _write(e->value, tmp___1, x, y - 1, e->attr, e->color);
#line 941
        e ++;
#line 939
        x ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 937
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 944
    win->curx = (short)0;
#line 945
    win->cury = (short )(win->sy2 - win->y1);
#line 946
    if (doit) {
      {
#line 947
      _wclreol(win);
      }
    }
  } else {
#line 949
    y = win->sy2 - 1;
    {
#line 949
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 949
      if (! (y >= win->sy1)) {
#line 949
        goto while_break___1;
      }
#line 950
      e = (gmap + y * COLS) + win->x1;
#line 951
      x = win->x1;
      {
#line 951
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 951
        if (! (x <= win->x2)) {
#line 951
          goto while_break___2;
        }
#line 952
        if (win->direct) {
#line 952
          if (doit) {
#line 952
            tmp___2 = 1;
          } else {
#line 952
            tmp___2 = 0;
          }
        } else {
#line 952
          tmp___2 = 0;
        }
        {
#line 952
        _write(e->value, tmp___2, x, y + 1, e->attr, e->color);
#line 953
        e ++;
#line 951
        x ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 949
      y --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 956
    win->curx = (short)0;
#line 957
    win->cury = (short )(win->sy1 - win->y1);
#line 958
    if (doit) {
      {
#line 959
      _wclreol(win);
      }
    }
  }
#line 963
  win->curx = (short )ocurx;
#line 965
  if (! doit) {
#line 966
    x = win->x1;
    {
#line 966
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 966
      if (! (x <= win->x2)) {
#line 966
        goto while_break___3;
      }
      {
#line 967
      _write(' ', 0, x, win->y1 + (int )win->cury, win->attr, win->color);
#line 966
      x ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 968
  if (! _intern) {
#line 968
    if (win->direct) {
      {
#line 969
      _gotoxy(win->x1 + (int )win->curx, win->y1 + (int )win->cury);
      }
    }
  }
#line 970
  if (dirflush) {
#line 970
    if (! _intern) {
#line 970
      if (win->direct) {
        {
#line 971
        mc_wflush();
        }
      }
    }
  }
#line 972
  return;
}
}
#line 977 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wlocate(WIN *win , int x , int y ) 
{ 


  {
#line 979
  if (x < 0) {
#line 980
    x = 0;
  }
#line 981
  if (y < 0) {
#line 982
    y = 0;
  }
#line 983
  if (x >= win->xs) {
#line 984
    x = win->xs - 1;
  }
#line 985
  if (y >= win->ys) {
#line 986
    y = win->ys - 1;
  }
#line 988
  win->curx = (short )x;
#line 989
  win->cury = (short )y;
#line 990
  if (win->direct) {
    {
#line 991
    _gotoxy(win->x1 + x, win->y1 + y);
    }
  }
#line 993
  if (dirflush) {
    {
#line 994
    mc_wflush();
    }
  }
#line 995
  return;
}
}
#line 1000 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wputc(WIN *win , wchar_t c___0 ) 
{ 
  int mv ;

  {
#line 1002
  mv = 0;
  {
#line 1009
  if (c___0 == 13) {
#line 1009
    goto case_13;
  }
#line 1013
  if (c___0 == 8) {
#line 1013
    goto case_8;
  }
#line 1019
  if (c___0 == 7) {
#line 1019
    goto case_7;
  }
#line 1022
  if (c___0 == 9) {
#line 1022
    goto case_9;
  }
#line 1027
  if (c___0 == 10) {
#line 1027
    goto case_10;
  }
#line 1031
  goto switch_default;
  case_13: /* CIL Label */ 
#line 1010
  win->curx = (short)0;
#line 1011
  mv ++;
#line 1012
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1014
  if ((int )win->curx == 0) {
#line 1015
    goto switch_break;
  }
#line 1016
  win->curx = (short )((int )win->curx - 1);
#line 1017
  mv ++;
#line 1018
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1020
  mc_wbell();
  }
#line 1021
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1023
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1024
    mc_wputc(win, ' ');
    }
#line 1023
    if (! ((int )win->curx % 8)) {
#line 1023
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1026
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1028
  if (win->autocr) {
#line 1029
    win->curx = (short)0;
  }
  switch_default: /* CIL Label */ 
#line 1033
  if (c___0 == 10) {
#line 1033
    goto _L;
  } else
#line 1033
  if ((int )win->curx >= win->xs) {
#line 1033
    if (win->wrap) {
      _L: /* CIL Label */ 
#line 1034
      if (c___0 != 10) {
#line 1035
        win->curx = (short)0;
      }
#line 1036
      win->cury = (short )((int )win->cury + 1);
#line 1037
      mv ++;
#line 1038
      if ((int )win->cury == (win->sy2 - win->y1) + 1) {
#line 1039
        if (win->doscroll) {
          {
#line 1040
          mc_wscroll(win, 1);
          }
        } else {
#line 1042
          win->cury = (short )(win->sy1 - win->y1);
        }
      }
#line 1044
      if ((int )win->cury >= win->ys) {
#line 1045
        win->cury = (short )(win->ys - 1);
      }
    }
  }
#line 1048
  if (c___0 != 10) {
#line 1049
    if (! win->wrap) {
#line 1049
      if ((int )win->curx >= win->xs) {
#line 1050
        c___0 = '>';
      }
    }
    {
#line 1051
    _write(c___0, (int )win->direct, (int )win->curx + win->x1, (int )win->cury + win->y1,
           win->attr, win->color);
#line 1053
    win->curx = (short )((int )win->curx + 1);
    }
#line 1053
    if ((int )win->curx >= win->xs) {
#line 1053
      if (! win->wrap) {
#line 1054
        win->curx = (short )((int )win->curx - 1);
#line 1055
        curx = 0;
#line 1056
        mv ++;
      }
    }
  }
#line 1059
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1061
  if (mv) {
#line 1061
    if (win->direct) {
      {
#line 1062
      _gotoxy(win->x1 + (int )win->curx, win->y1 + (int )win->cury);
      }
    }
  }
#line 1064
  if (win->direct) {
#line 1064
    if (dirflush) {
#line 1064
      if (! _intern) {
        {
#line 1065
        mc_wflush();
        }
      }
    }
  }
#line 1066
  return;
}
}
#line 1069 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wdrawelm(WIN *w , int y , ELM *e ) 
{ 
  int x ;

  {
#line 1074
  x = w->x1;
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1074
    if (! (x <= w->x2)) {
#line 1074
      goto while_break;
    }
    {
#line 1075
    _write(e->value, (int )w->direct, x, y + w->y1, e->attr, e->color);
#line 1077
    e ++;
#line 1074
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1079
  return;
}
}
#line 1086 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wdrawelm_var(WIN *w , ELM *e , wchar_t *buf___6 ) 
{ 
  int x ;
  int c___0 ;
  int tmp ;

  {
#line 1088
  c___0 = 0;
#line 1091
  x = w->x1;
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1091
    if (! (x <= w->x2)) {
#line 1091
      goto while_break;
    }
#line 1092
    tmp = c___0;
#line 1092
    c___0 ++;
#line 1092
    *(buf___6 + tmp) = e->value;
#line 1093
    e ++;
#line 1091
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return;
}
}
#line 1102 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wdrawelm_inverse(WIN *w , int y , ELM *e ) 
{ 
  int x ;

  {
  {
#line 1109
  x = w->x1;
#line 1110
  _write(e->value, (int )w->direct, x, y + w->y1, (char)0, e->color);
#line 1112
  e ++;
#line 1115
  x = w->x1 + 1;
  }
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1115
    if (! (x <= w->x2 - 1)) {
#line 1115
      goto while_break;
    }
    {
#line 1116
    _write(e->value, (int )w->direct, x, y + w->y1, (char)2, (char)7);
#line 1117
    e ++;
#line 1115
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1121
  x = w->x2;
#line 1122
  _write(e->value, (int )w->direct, x, y + w->y1, (char)0, e->color);
  }
#line 1123
  return;
}
}
#line 1128 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wputs(WIN *win , char const   *s___0 ) 
{ 
  wchar_t wc ;
  size_t tmp ;

  {
#line 1130
  _intern = 1;
  {
#line 1132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1132
    if (! *s___0) {
#line 1132
      goto while_break;
    }
    {
#line 1135
    tmp = one_mbtowc(& wc, s___0, (size_t )16);
#line 1135
    s___0 += tmp;
#line 1136
    mc_wputc(win, wc);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1138
  if (dirflush) {
#line 1138
    if (win->direct) {
      {
#line 1139
      mc_wflush();
      }
    }
  }
#line 1140
  _intern = 0;
#line 1141
  return;
}
}
#line 1147 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int ( /* format attribute */  mc_wprintf)(WIN *win , char const   *fmt___0  , ...) 
{ 
  char buf___6[160] ;
  va_list va ;

  {
  {
#line 1152
  __builtin_va_start(va, fmt___0);
#line 1153
  vsnprintf((char */* __restrict  */)(buf___6), sizeof(buf___6), (char const   */* __restrict  */)fmt___0,
            va);
#line 1154
  __builtin_va_end(va);
#line 1155
  mc_wputs(win, (char const   *)(buf___6));
  }
#line 1157
  return (0);
}
}
#line 1163 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wbell(void) 
{ 


  {
#line 1165
  if ((unsigned long )BL != (unsigned long )((void *)0)) {
    {
#line 1166
    outstr(BL);
    }
  } else
#line 1167
  if ((unsigned long )VB != (unsigned long )((void *)0)) {
    {
#line 1168
    outstr(VB);
    }
  } else {
    {
#line 1170
    outchar('\a');
    }
  }
  {
#line 1171
  mc_wflush();
  }
#line 1172
  return;
}
}
#line 1177 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wcursor(WIN *win , int type ) 
{ 


  {
#line 1179
  win->cursor = (char )type;
#line 1180
  if (win->direct) {
    {
#line 1181
    _cursor(type);
    }
#line 1182
    if (dirflush) {
      {
#line 1183
      mc_wflush();
      }
    }
  }
#line 1185
  return;
}
}
#line 1187 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wtitle(WIN *w , int pos___1 , char const   *s___0 ) 
{ 
  int x ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  wchar_t wc ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1189
  x = 0;
#line 1195
  if ((int )w->border == 0) {
#line 1196
    return;
  }
#line 1198
  if (pos___1 == 0) {
#line 1199
    x = w->x1;
  }
#line 1200
  if (pos___1 == 2) {
    {
#line 1201
    tmp = mbslen(s___0);
#line 1201
    x = (int )(((size_t )w->x2 - tmp) - 1UL);
    }
  }
#line 1202
  if (pos___1 == 1) {
    {
#line 1203
    tmp___0 = mbslen(s___0);
#line 1203
    x = (int )(((size_t )w->x1 + ((size_t )w->xs - tmp___0) / 2UL) - 1UL);
    }
  }
#line 1204
  if (x < w->x1) {
#line 1205
    x = w->x1;
  }
#line 1207
  if (x < w->x2) {
    {
#line 1208
    tmp___1 = x;
#line 1208
    x ++;
#line 1208
    _write('[', (int )w->direct, tmp___1, w->y1 - 1, w->attr, w->color);
    }
  }
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1209
    if (*s___0) {
#line 1209
      if (! (x <= w->x2)) {
#line 1209
        goto while_break;
      }
    } else {
#line 1209
      goto while_break;
    }
    {
#line 1212
    tmp___2 = one_mbtowc(& wc, s___0, (size_t )16);
#line 1212
    s___0 += tmp___2;
#line 1213
    tmp___3 = x;
#line 1213
    x ++;
#line 1213
    _write(wc, (int )w->direct, tmp___3, w->y1 - 1, w->attr, w->color);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1215
  if (x <= w->x2) {
    {
#line 1216
    tmp___4 = x;
#line 1216
    x ++;
#line 1216
    _write(']', (int )w->direct, tmp___4, w->y1 - 1, w->attr, w->color);
    }
  }
#line 1218
  if (w->direct) {
    {
#line 1219
    _gotoxy(w->x1 + (int )w->curx, w->y1 + (int )w->cury);
    }
#line 1220
    if (dirflush) {
      {
#line 1221
      mc_wflush();
      }
    }
  }
#line 1223
  return;
}
}
#line 1231 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wcurbar(WIN *w , int y , int attr ) 
{ 
  ELM *e ;
  int x ;

  {
#line 1240
  y += w->y1;
#line 1242
  e = (gmap + y * COLS) + w->x1;
#line 1247
  if (! useattr) {
#line 1247
    goto _L;
  } else
#line 1247
  if ((unsigned long )MR == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1248
    if (attr & 4) {
#line 1249
      x = '>';
    } else {
#line 1251
      x = ' ';
    }
    {
#line 1252
    _write(x, (int )w->direct, w->x1, y, (char )attr, e->color);
    }
  } else {
#line 1254
    x = w->x1;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! (x <= w->x2)) {
#line 1254
        goto while_break;
      }
      {
#line 1255
      _write(e->value, (int )w->direct, x, y, (char )attr, e->color);
#line 1256
      e ++;
#line 1254
      x ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1259
  if ((unsigned long )VI == (unsigned long )((void *)0)) {
#line 1259
    goto _L___0;
  } else
#line 1259
  if (_curstype == 1) {
    _L___0: /* CIL Label */ 
#line 1259
    if (w->direct) {
      {
#line 1260
      _gotoxy(w->x1, y);
      }
    }
  }
#line 1261
  if (w->direct) {
    {
#line 1262
    mc_wflush();
    }
  }
#line 1263
  return;
}
}
#line 1268 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int mc_wselect(int x , int y , char const   * const  *choices , void (* const  *funlist)(void) ,
               char const   *title , int attr , int fg , int bg ) 
{ 
  char const   * const  *a ;
  unsigned int len ;
  int count ;
  int cur___1 ;
  int c___0 ;
  WIN *w ;
  int high_on ;
  int high_off ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
#line 1272
  a = choices;
#line 1273
  len = 0U;
#line 1274
  count = 0;
#line 1275
  cur___1 = 0;
#line 1278
  high_on = 4 | attr;
#line 1279
  high_off = attr;
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1283
    if (! ((unsigned long )*a != (unsigned long )((void *)0))) {
#line 1283
      goto while_break;
    }
    {
#line 1284
    count ++;
#line 1285
    tmp___1 = gettext((char const   *)*a);
#line 1285
    tmp___2 = mbslen((char const   *)tmp___1);
    }
#line 1285
    if (tmp___2 > (size_t )len) {
      {
#line 1286
      tmp = gettext((char const   *)*a);
#line 1286
      tmp___0 = mbslen((char const   *)tmp);
#line 1286
      len = (unsigned int )tmp___0;
      }
    }
#line 1287
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1289
  if ((unsigned long )title != (unsigned long )((void *)0)) {
    {
#line 1289
    tmp___4 = mbslen(title);
    }
#line 1289
    if (tmp___4 + 2UL > (size_t )len) {
      {
#line 1290
      tmp___3 = mbslen(title);
#line 1290
      len = (unsigned int )(tmp___3 + 2UL);
      }
    }
  }
#line 1291
  if (attr & 4) {
#line 1292
    high_on = attr & -5;
#line 1293
    high_off = attr;
  }
  {
#line 1296
  w = mc_wopen(x, y, (int )(((unsigned int )x + len) + 2U), (y + count) - 1, 2, attr,
               fg, bg, 0, 0, 0);
  }
#line 1296
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 1298
    return (-1);
  }
  {
#line 1299
  mc_wcursor(w, 0);
  }
#line 1301
  if ((unsigned long )title != (unsigned long )((void *)0)) {
    {
#line 1302
    mc_wtitle(w, 1, title);
    }
  }
#line 1304
  c___0 = 0;
  {
#line 1304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1304
    if (! (c___0 < count)) {
#line 1304
      goto while_break___0;
    }
#line 1305
    if (c___0 == count - 1) {
#line 1305
      tmp___5 = "";
    } else {
#line 1305
      tmp___5 = "\n";
    }
    {
#line 1305
    tmp___6 = gettext((char const   *)*(choices + c___0));
#line 1305
    mc_wprintf(w, " %s%s", tmp___6, tmp___5);
#line 1304
    c___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1307
  mc_wcurbar(w, cur___1, high_on);
#line 1308
  mc_wredraw(w, 1);
  }
  {
#line 1310
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1311
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1311
      c___0 = wxgetch();
      }
#line 1311
      if (c___0 != 27) {
#line 1311
        if (c___0 != 10) {
#line 1311
          if (c___0 != 13) {
#line 1311
            if (! (c___0 != 32)) {
#line 1311
              goto while_break___2;
            }
          } else {
#line 1311
            goto while_break___2;
          }
        } else {
#line 1311
          goto while_break___2;
        }
      } else {
#line 1311
        goto while_break___2;
      }
#line 1312
      if (c___0 == 269) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      } else
#line 1312
      if (c___0 == 272) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      } else
#line 1312
      if (c___0 == 106) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      } else
#line 1312
      if (c___0 == 107) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      } else
#line 1312
      if (c___0 == 267) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      } else
#line 1312
      if (c___0 == 273) {
        {
#line 1314
        mc_wcurbar(w, cur___1, high_off);
        }
      }
      {
#line 1317
      if (c___0 == 107) {
#line 1317
        goto case_107;
      }
#line 1317
      if (c___0 == 269) {
#line 1317
        goto case_107;
      }
#line 1323
      if (c___0 == 106) {
#line 1323
        goto case_106;
      }
#line 1323
      if (c___0 == 272) {
#line 1323
        goto case_106;
      }
#line 1328
      if (c___0 == 267) {
#line 1328
        goto case_267;
      }
#line 1331
      if (c___0 == 273) {
#line 1331
        goto case_273;
      }
#line 1315
      goto switch_break;
      case_107: /* CIL Label */ 
      case_269: /* CIL Label */ 
#line 1318
      cur___1 --;
#line 1319
      if (cur___1 < 0) {
#line 1320
        cur___1 = count - 1;
      }
#line 1321
      goto switch_break;
      case_106: /* CIL Label */ 
      case_272: /* CIL Label */ 
#line 1324
      cur___1 ++;
#line 1325
      if (cur___1 >= count) {
#line 1326
        cur___1 = 0;
      }
#line 1327
      goto switch_break;
      case_267: /* CIL Label */ 
#line 1329
      cur___1 = 0;
#line 1330
      goto switch_break;
      case_273: /* CIL Label */ 
#line 1332
      cur___1 = count - 1;
#line 1333
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1335
      if (c___0 == 269) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      } else
#line 1335
      if (c___0 == 272) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      } else
#line 1335
      if (c___0 == 106) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      } else
#line 1335
      if (c___0 == 107) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      } else
#line 1335
      if (c___0 == 267) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      } else
#line 1335
      if (c___0 == 273) {
        {
#line 1337
        mc_wcurbar(w, cur___1, high_on);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1339
    mc_wcursor(w, 1);
    }
#line 1340
    if (c___0 == 32) {
      {
#line 1341
      mc_wclose(w, 1);
      }
#line 1342
      return (0);
    } else
#line 1340
    if (c___0 == 27) {
      {
#line 1341
      mc_wclose(w, 1);
      }
#line 1342
      return (0);
    }
#line 1344
    if ((unsigned long )funlist == (unsigned long )((void *)0)) {
      {
#line 1345
      mc_wclose(w, 1);
      }
#line 1346
      return (cur___1 + 1);
    } else
#line 1344
    if ((unsigned long )*(funlist + cur___1) == (unsigned long )((void *)0)) {
      {
#line 1345
      mc_wclose(w, 1);
      }
#line 1346
      return (cur___1 + 1);
    }
    {
#line 1348
    (*(*(funlist + cur___1)))();
#line 1349
    mc_wcursor(w, 0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 1359 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclrch(WIN *w , int n ) 
{ 
  int x ;
  int y ;
  int x_end ;

  {
#line 1367
  y = (int )w->cury + w->y1;
#line 1368
  x_end = (int )w->curx + w->x1;
#line 1368
  x = x_end;
#line 1369
  x_end += n - 1;
#line 1371
  if (x_end > w->x2) {
#line 1372
    x_end = w->x2;
  }
#line 1374
  if (w->direct) {
    {
#line 1375
    _gotoxy(w->x1, y);
    }
  }
  {
#line 1377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1377
    if (! (x <= x_end)) {
#line 1377
      goto while_break;
    }
    {
#line 1378
    _write(' ', (int )w->direct, x, y, w->attr, w->color);
#line 1377
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1380
  if (w->direct) {
#line 1380
    if (dirflush) {
      {
#line 1381
      mc_wflush();
      }
    }
  }
#line 1382
  return;
}
}
#line 1387 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclrel(WIN *w ) 
{ 
  int ocurx ;

  {
  {
#line 1389
  ocurx = (int )w->curx;
#line 1391
  w->curx = (short)0;
#line 1392
  _wclreol(w);
#line 1393
  w->curx = (short )ocurx;
#line 1394
  mc_wlocate(w, ocurx, (int )w->cury);
  }
#line 1395
  return;
}
}
#line 1400 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclreol(WIN *w ) 
{ 
  int tmp ;

  {
  {
#line 1402
  tmp = _wclreol(w);
  }
#line 1402
  if (tmp) {
#line 1402
    if (w->direct) {
      {
#line 1403
      _gotoxy(w->x1 + (int )w->curx, w->y1 + (int )w->cury);
      }
    }
  }
#line 1404
  if (dirflush) {
    {
#line 1405
    mc_wflush();
    }
  }
#line 1406
  return;
}
}
#line 1411 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclrbol(WIN *w ) 
{ 
  int x ;
  int y ;
  int n ;

  {
#line 1419
  y = (int )w->cury + w->y1;
#line 1421
  if (w->direct) {
    {
#line 1422
    _gotoxy(w->x1, y);
    }
  }
#line 1424
  n = w->x1 + (int )w->curx;
#line 1425
  if (n > w->x2) {
#line 1426
    n = w->x2;
  }
#line 1427
  x = w->x1;
  {
#line 1427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (x <= n)) {
#line 1427
      goto while_break;
    }
    {
#line 1428
    _write(' ', (int )w->direct, x, y, w->attr, w->color);
#line 1427
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1429
  if (w->direct) {
    {
#line 1430
    _gotoxy(n, y);
    }
#line 1431
    if (dirflush) {
      {
#line 1432
      mc_wflush();
      }
    }
  }
#line 1434
  return;
}
}
#line 1439 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclreos(WIN *w ) 
{ 
  int y ;
  int ocurx ;
  int ocury ;
  int tmp ;

  {
#line 1444
  ocurx = (int )w->curx;
#line 1445
  ocury = (int )w->cury;
#line 1447
  w->curx = (short)0;
#line 1449
  y = (int )w->cury + 1;
  {
#line 1449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1449
    if (! (y <= w->y2 - w->y1)) {
#line 1449
      goto while_break;
    }
    {
#line 1450
    w->cury = (short )y;
#line 1451
    _wclreol(w);
#line 1449
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1453
  w->curx = (short )ocurx;
#line 1454
  w->cury = (short )ocury;
#line 1455
  tmp = _wclreol(w);
  }
#line 1455
  if (tmp) {
#line 1455
    if (w->direct) {
      {
#line 1456
      _gotoxy(w->x1 + (int )w->curx, w->y1 + (int )w->cury);
      }
    }
  }
#line 1457
  if (dirflush) {
#line 1457
    if (w->direct) {
      {
#line 1458
      mc_wflush();
      }
    }
  }
#line 1459
  return;
}
}
#line 1464 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wclrbos(WIN *w ) 
{ 
  int ocurx ;
  int ocury ;
  int y ;

  {
#line 1469
  ocurx = (int )w->curx;
#line 1470
  ocury = (int )w->cury;
#line 1472
  w->curx = (short)0;
#line 1474
  y = 0;
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1474
    if (! (y < ocury)) {
#line 1474
      goto while_break;
    }
    {
#line 1475
    w->cury = (short )y;
#line 1476
    _wclreol(w);
#line 1474
    y ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1478
  w->curx = (short )ocurx;
#line 1479
  w->cury = (short )ocury;
#line 1480
  mc_wclrbol(w);
  }
#line 1481
  return;
}
}
#line 1486 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_winclr(WIN *w ) 
{ 
  int y ;
  int olddir ;
  ELM *e ;
  ELM *f ;
  int i ;
  int m ;

  {
#line 1489
  olddir = (int )w->direct;
#line 1495
  if (w->histbuf) {
#line 1500
    m = w->y2;
    {
#line 1500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1500
      if (! (m >= w->y1)) {
#line 1500
        goto while_break;
      }
#line 1502
      e = (gmap + m * COLS) + w->x1;
#line 1505
      i = 0;
      {
#line 1505
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1505
        if (! (i < w->xs)) {
#line 1505
          goto while_break___0;
        }
#line 1506
        if ((e + i)->value != 32) {
#line 1507
          goto while_break___0;
        }
#line 1505
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1509
      if (i != w->xs) {
#line 1510
        goto while_break;
      }
#line 1500
      m --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1514
    y = w->y1;
    {
#line 1514
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1514
      if (! (y <= m)) {
#line 1514
        goto while_break___1;
      }
      {
#line 1516
      e = (gmap + y * COLS) + w->x1;
#line 1519
      f = w->histbuf + w->xs * w->histline;
#line 1520
      memcpy((void */* __restrict  */)((char *)f), (void const   */* __restrict  */)((char *)e),
             (unsigned long )w->xs * sizeof(ELM ));
#line 1521
      (w->histline) ++;
      }
#line 1522
      if (w->histline >= w->histlines) {
#line 1523
        w->histline = 0;
      }
#line 1514
      y ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1527
  _setattr(w->attr, w->color);
#line 1528
  w->curx = (short)0;
  }
#line 1530
  if (CL) {
#line 1530
    if (w->y1 == 0) {
#line 1530
      if (w->y2 == LINES - 1) {
#line 1530
        if (w->x1 == 0) {
#line 1530
          if (w->x2 == COLS - 1) {
            {
#line 1531
            w->direct = (char)0;
#line 1532
            curx = 0;
#line 1533
            cury = 0;
#line 1534
            outstr(CL);
            }
          }
        }
      }
    }
  }
#line 1536
  y = w->ys - 1;
  {
#line 1536
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1536
    if (! (y >= 0)) {
#line 1536
      goto while_break___2;
    }
    {
#line 1537
    w->cury = (short )y;
#line 1538
    _wclreol(w);
#line 1536
    y --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1540
  w->direct = (char )olddir;
#line 1541
  _gotoxy(w->x1, w->y1);
  }
#line 1542
  if (dirflush) {
    {
#line 1543
    mc_wflush();
    }
  }
#line 1544
  return;
}
}
#line 1548 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_winsline(WIN *w ) 
{ 
  int osy1 ;
  int osy2 ;

  {
#line 1552
  osy1 = w->sy1;
#line 1553
  osy2 = w->sy2;
#line 1555
  w->sy1 = w->y1 + (int )w->cury;
#line 1556
  w->sy2 = w->y2;
#line 1557
  if (w->sy1 < osy1) {
#line 1558
    w->sy1 = osy1;
  }
#line 1559
  if (w->sy2 > osy2) {
#line 1560
    w->sy2 = osy2;
  }
  {
#line 1561
  mc_wscroll(w, 2);
#line 1563
  w->sy1 = osy1;
#line 1564
  w->sy2 = osy2;
  }
#line 1565
  return;
}
}
#line 1567 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wdelline(WIN *w ) 
{ 
  int osy1 ;
  int osy2 ;
  int ocury ;

  {
#line 1572
  ocury = (int )w->cury;
#line 1573
  osy1 = w->sy1;
#line 1574
  osy2 = w->sy2;
#line 1576
  w->sy1 = w->y1 + (int )w->cury;
#line 1577
  w->sy2 = w->y2;
#line 1578
  if (w->sy1 < osy1) {
#line 1579
    w->sy1 = osy1;
  }
#line 1580
  if (w->sy2 > osy2) {
#line 1581
    w->sy2 = osy2;
  }
  {
#line 1583
  _intern = 1;
#line 1584
  mc_wscroll(w, 1);
#line 1585
  _intern = 0;
#line 1586
  mc_wlocate(w, 0, ocury);
#line 1588
  w->sy1 = osy1;
#line 1589
  w->sy2 = osy2;
  }
#line 1590
  return;
}
}
#line 1595 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_winschar2(WIN *w , wchar_t c___0 , int move ) 
{ 
  int y ;
  int x ;
  int doit ;
  ELM *buf___6 ;
  ELM *e ;
  int len ;
  int odir___0 ;
  int oldx___0 ;
  wchar_t *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 1599
  doit = 1;
#line 1609
  if (c___0 == 0) {
    {
#line 1610
    mc_wputc(w, c___0);
    }
#line 1611
    return;
  } else {
    {
#line 1609
    tmp = wcschr((wchar_t const   *)L"\r\n\t\b\a", c___0);
    }
#line 1609
    if (tmp) {
      {
#line 1610
      mc_wputc(w, c___0);
      }
#line 1611
      return;
    } else
#line 1609
    if ((int )w->curx >= w->xs - 1) {
      {
#line 1610
      mc_wputc(w, c___0);
      }
#line 1611
      return;
    }
  }
#line 1614
  odir___0 = (int )w->direct;
#line 1615
  if (w->xs == COLS) {
#line 1615
    if ((unsigned long )IC != (unsigned long )((void *)0)) {
#line 1617
      if (w->direct) {
        {
#line 1618
        outstr(IC);
        }
      }
#line 1621
      if (c___0 == 32) {
#line 1622
        w->direct = (char)0;
      }
#line 1625
      doit = 0;
    }
  }
  {
#line 1629
  y = w->y1 + (int )w->cury;
#line 1630
  x = w->x1 + (int )w->curx;
#line 1631
  oldx___0 = (int )w->curx;
#line 1632
  len = w->xs - (int )w->curx;
#line 1634
  tmp___0 = malloc(sizeof(ELM ) * (unsigned long )len);
#line 1634
  buf___6 = (ELM *)tmp___0;
  }
#line 1635
  if (! buf___6) {
#line 1636
    return;
  }
  {
#line 1637
  memcpy((void */* __restrict  */)buf___6, (void const   */* __restrict  */)((gmap + COLS * y) + x),
         sizeof(ELM ) * (unsigned long )len);
#line 1640
  mc_wputc(w, c___0);
  }
#line 1641
  if (! move) {
#line 1642
    w->curx = (short )oldx___0;
  }
#line 1645
  e = buf___6;
#line 1646
  x ++;
  {
#line 1646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1646
    if (! (x <= w->x2)) {
#line 1646
      goto while_break;
    }
#line 1647
    if (doit) {
#line 1647
      if (w->direct) {
#line 1647
        tmp___1 = 1;
      } else {
#line 1647
        tmp___1 = 0;
      }
    } else {
#line 1647
      tmp___1 = 0;
    }
    {
#line 1647
    _write(e->value, tmp___1, x, y, e->attr, e->color);
#line 1648
    e ++;
#line 1646
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1650
  free((void *)buf___6);
#line 1652
  w->direct = (char )odir___0;
#line 1653
  mc_wlocate(w, (int )w->curx, (int )w->cury);
  }
#line 1654
  return;
}
}
#line 1656 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_winschar(WIN *w ) 
{ 


  {
  {
#line 1658
  mc_winschar2(w, ' ', 0);
  }
#line 1659
  return;
}
}
#line 1664 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void mc_wdelchar(WIN *w ) 
{ 
  int x ;
  int y ;
  int doit ;
  ELM *e ;
  int tmp ;
  int tmp___0 ;

  {
#line 1667
  doit = 1;
#line 1674
  x = w->x1 + (int )w->curx;
#line 1675
  y = w->y1 + (int )w->cury;
#line 1677
  if (w->direct) {
#line 1677
    if (w->xs == COLS) {
#line 1677
      if ((unsigned long )DC != (unsigned long )((void *)0)) {
        {
#line 1679
        _gotoxy(x, y);
#line 1680
        outstr(DC);
#line 1681
        doit = 0;
        }
      }
    }
  }
#line 1684
  e = ((gmap + y * COLS) + x) + 1;
  {
#line 1686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1686
    if (! (x < w->x2)) {
#line 1686
      goto while_break;
    }
#line 1687
    if (doit) {
#line 1687
      if (w->direct) {
#line 1687
        tmp = 1;
      } else {
#line 1687
        tmp = 0;
      }
    } else {
#line 1687
      tmp = 0;
    }
    {
#line 1687
    _write(e->value, tmp, x, y, e->attr, e->color);
#line 1688
    e ++;
#line 1686
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1690
  if (doit) {
#line 1690
    if (w->direct) {
#line 1690
      tmp___0 = 1;
    } else {
#line 1690
      tmp___0 = 0;
    }
  } else {
#line 1690
    tmp___0 = 0;
  }
  {
#line 1690
  _write(' ', tmp___0, x, y, w->attr, w->color);
#line 1691
  mc_wlocate(w, (int )w->curx, (int )w->cury);
  }
#line 1692
  return;
}
}
#line 1697 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static void lredraw(WIN *w , int x , int y , wchar_t *s___0 , int len ) 
{ 
  int i ;
  int f ;
  int tmp ;

  {
  {
#line 1701
  i = 0;
#line 1702
  mc_wlocate(w, x, y);
#line 1703
  f = 0;
  }
  {
#line 1703
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1703
    if (! (f < len)) {
#line 1703
      goto while_break;
    }
#line 1704
    if (*(s___0 + f) == 0) {
#line 1705
      i ++;
    }
#line 1706
    if (i) {
#line 1706
      tmp = ' ';
    } else {
#line 1706
      tmp = *(s___0 + f);
    }
    {
#line 1706
    mc_wputc(w, tmp);
#line 1703
    f ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1708
  return;
}
}
#line 1717 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int mc_wgetwcs(WIN *w , wchar_t *s___0 , int linelen , int maxlen ) 
{ 
  int c___0 ;
  int idx___0 ;
  int offs ;
  int f ;
  int st___0 ;
  int i ;
  wchar_t buf___6[257] ;
  int quit___0 ;
  int once ;
  int x ;
  int y ;
  int r ;
  int direct ;
  int delete ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1721
  offs = 0;
#line 1722
  st___0 = 0;
#line 1724
  quit___0 = 0;
#line 1725
  once = 1;
#line 1727
  direct = dirflush;
#line 1728
  delete = 1;
#line 1730
  x = (int )w->curx;
#line 1731
  y = (int )w->cury;
#line 1733
  i = w->xs - x;
#line 1734
  if (linelen >= i - 1) {
#line 1735
    linelen = i - 1;
  }
  {
#line 1738
  tmp = wcslen((wchar_t const   *)s___0);
#line 1738
  idx___0 = (int )tmp;
  }
#line 1738
  if (idx___0 > linelen) {
#line 1739
    idx___0 = linelen;
  }
  {
#line 1740
  wcsncpy((wchar_t */* __restrict  */)(buf___6), (wchar_t const   */* __restrict  */)s___0,
          sizeof(buf___6) / sizeof(buf___6[0]));
#line 1741
  mc_wlocate(w, x + idx___0, y);
#line 1742
  dirflush = 0;
#line 1743
  mc_wflush();
  }
  {
#line 1745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1745
    if (! (! quit___0)) {
#line 1745
      goto while_break;
    }
#line 1746
    if (once) {
#line 1747
      c___0 = 273;
#line 1748
      once --;
    } else {
      {
#line 1750
      c___0 = wxgetch();
      }
#line 1751
      if (c___0 > 255) {
#line 1752
        delete = 0;
      } else
#line 1751
      if (c___0 == 8) {
#line 1752
        delete = 0;
      } else
#line 1751
      if (c___0 == 276) {
#line 1752
        delete = 0;
      }
    }
    {
#line 1756
    if (c___0 == 10) {
#line 1756
      goto case_10;
    }
#line 1756
    if (c___0 == 13) {
#line 1756
      goto case_10;
    }
#line 1760
    if (c___0 == 27) {
#line 1760
      goto case_27;
    }
#line 1767
    if (c___0 == 267) {
#line 1767
      goto case_267;
    }
#line 1776
    if (c___0 == 273) {
#line 1776
      goto case_273;
    }
#line 1789
    if (c___0 == 8) {
#line 1789
      goto case_8;
    }
#line 1789
    if (c___0 == 270) {
#line 1789
      goto case_8;
    }
#line 1804
    if (c___0 == 276) {
#line 1804
      goto case_276;
    }
#line 1813
    if (c___0 == 271) {
#line 1813
      goto case_271;
    }
#line 1824
    goto switch_default;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 1757
    st___0 = 0;
#line 1758
    quit___0 = 1;
#line 1759
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 1761
    mc_wlocate(w, x, y);
#line 1762
    lredraw(w, x, y, s___0, linelen);
#line 1763
    mc_wflush();
#line 1764
    st___0 = -1;
#line 1765
    quit___0 = 1;
    }
#line 1766
    goto switch_break;
    case_267: /* CIL Label */ 
#line 1768
    r = offs > 0;
#line 1769
    offs = 0;
#line 1770
    idx___0 = 0;
#line 1771
    if (r) {
      {
#line 1772
      lredraw(w, x, y, buf___6, linelen);
      }
    }
    {
#line 1773
    mc_wlocate(w, x, y);
#line 1774
    mc_wflush();
    }
#line 1775
    goto switch_break;
    case_273: /* CIL Label */ 
    {
#line 1777
    tmp___0 = wcslen((wchar_t const   *)(buf___6));
#line 1777
    idx___0 = (int )tmp___0;
#line 1778
    r = 0;
    }
    {
#line 1779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1779
      if (! (idx___0 - offs > linelen)) {
#line 1779
        goto while_break___0;
      }
#line 1780
      r = 1;
#line 1781
      offs += 4;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1783
    if (r) {
      {
#line 1784
      lredraw(w, x, y, buf___6 + offs, linelen);
      }
    }
    {
#line 1785
    mc_wlocate(w, (x + idx___0) - offs, y);
#line 1786
    mc_wflush();
    }
#line 1787
    goto switch_break;
    case_8: /* CIL Label */ 
    case_270: /* CIL Label */ 
#line 1790
    if (idx___0 == 0) {
#line 1791
      goto switch_break;
    }
#line 1792
    idx___0 --;
#line 1793
    if (idx___0 < offs) {
      {
#line 1794
      offs -= 4;
#line 1796
      lredraw(w, x, y, buf___6 + offs, linelen);
      }
    }
#line 1798
    if (c___0 == 270) {
      {
#line 1799
      mc_wlocate(w, (x + idx___0) - offs, y);
#line 1800
      mc_wflush();
      }
#line 1801
      goto switch_break;
    }
    case_276: /* CIL Label */ 
#line 1805
    if (buf___6[idx___0] == 0) {
#line 1806
      goto switch_break;
    }
#line 1807
    f = idx___0;
    {
#line 1807
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1807
      if (! buf___6[f]) {
#line 1807
        goto while_break___1;
      }
#line 1808
      buf___6[f] = buf___6[f + 1];
#line 1807
      f ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1809
    lredraw(w, (x + idx___0) - offs, y, buf___6 + idx___0, linelen - (idx___0 - offs));
#line 1810
    mc_wlocate(w, (x + idx___0) - offs, y);
#line 1811
    mc_wflush();
    }
#line 1812
    goto switch_break;
    case_271: /* CIL Label */ 
#line 1814
    if (buf___6[idx___0] == 0) {
#line 1815
      goto switch_break;
    }
#line 1816
    idx___0 ++;
#line 1817
    if (idx___0 - offs > linelen) {
      {
#line 1818
      offs += 4;
#line 1819
      lredraw(w, x, y, buf___6 + offs, linelen);
      }
    }
    {
#line 1821
    mc_wlocate(w, (x + idx___0) - offs, y);
#line 1822
    mc_wflush();
    }
#line 1823
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1826
    if (delete) {
      {
#line 1827
      tmp___1 = wcslen((wchar_t const   *)(buf___6));
#line 1827
      i = (int )tmp___1;
      }
#line 1827
      if (i > linelen) {
#line 1828
        i = linelen;
      }
      {
#line 1829
      buf___6[0] = 0;
#line 1830
      idx___0 = 0;
#line 1831
      offs = 0;
#line 1832
      mc_wlocate(w, x, y);
#line 1833
      f = 0;
      }
      {
#line 1833
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1833
        if (! (f < i)) {
#line 1833
          goto while_break___2;
        }
        {
#line 1834
        mc_wputc(w, ' ');
#line 1833
        f ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1835
      delete = 0;
    }
#line 1839
    if (c___0 < 32) {
#line 1840
      goto switch_break;
    } else
#line 1839
    if (c___0 > 255) {
#line 1840
      goto switch_break;
    }
    {
#line 1841
    tmp___2 = wcslen((wchar_t const   *)(buf___6));
#line 1841
    f = (int )(tmp___2 + 2UL);
    }
#line 1842
    if (f >= maxlen) {
#line 1843
      goto switch_break;
    }
    {
#line 1844
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1844
      if (! (f > idx___0)) {
#line 1844
        goto while_break___3;
      }
#line 1845
      buf___6[f] = buf___6[f - 1];
#line 1846
      f --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1848
    buf___6[idx___0] = c___0;
#line 1849
    if (idx___0 - offs >= linelen) {
      {
#line 1850
      offs += 4;
#line 1851
      lredraw(w, x, y, buf___6 + offs, linelen);
      }
    } else {
      {
#line 1853
      lredraw(w, (x + idx___0) - offs, y, buf___6 + idx___0, linelen - (idx___0 - offs));
      }
    }
    {
#line 1854
    idx___0 ++;
#line 1855
    mc_wlocate(w, (x + idx___0) - offs, y);
#line 1856
    mc_wflush();
    }
#line 1857
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1860
  if (st___0 == 0) {
    {
#line 1861
    wcscpy((wchar_t */* __restrict  */)s___0, (wchar_t const   */* __restrict  */)(buf___6));
    }
  }
#line 1862
  dirflush = direct;
#line 1863
  return (st___0);
}
}
#line 1867 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int mc_wgets(WIN *w , char *s___0 , int linelen , int maxlen ) 
{ 
  int st___0 ;
  wchar_t buf___6[257] ;
  size_t i ;
  char *sptr ;
  size_t tmp ;
  char tmp___0[16] ;
  size_t l ;

  {
#line 1874
  sptr = s___0;
#line 1875
  i = (size_t )0;
  {
#line 1875
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1875
    if ((int )*sptr != 0) {
#line 1875
      if (! (i < sizeof(buf___6) - 1UL)) {
#line 1875
        goto while_break;
      }
    } else {
#line 1875
      goto while_break;
    }
    {
#line 1876
    tmp = one_mbtowc(buf___6 + i, (char const   *)sptr, (size_t )16);
#line 1876
    sptr += tmp;
#line 1875
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1877
  buf___6[i] = 0;
#line 1878
  st___0 = mc_wgetwcs(w, buf___6, linelen, maxlen);
  }
#line 1879
  if (st___0 == 0) {
#line 1880
    sptr = s___0;
#line 1881
    i = (size_t )0;
    {
#line 1881
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1881
      if (! (buf___6[i] != 0)) {
#line 1881
        goto while_break___0;
      }
      {
#line 1887
      l = one_wctomb(tmp___0, buf___6[i]);
      }
#line 1888
      if ((unsigned long )(sptr + l) >= (unsigned long )(s___0 + maxlen)) {
#line 1889
        goto while_break___0;
      }
      {
#line 1890
      memcpy((void */* __restrict  */)sptr, (void const   */* __restrict  */)(tmp___0),
             l);
#line 1891
      sptr += l;
#line 1881
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1893
    *sptr = (char)0;
  }
#line 1895
  return (st___0);
}
}
#line 1900 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char tbuf___0[1024]  ;
#line 1901 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static char cbuf___0[2048]  ;
#line 1904 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static int acmap(int c___0 ) 
{ 
  char const   *p ;

  {
#line 1908
  p = AC;
  {
#line 1908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1908
    if (! *p) {
#line 1908
      goto while_break;
    }
#line 1909
    if ((int const   )*p == (int const   )c___0) {
#line 1910
      p ++;
#line 1910
      return ((int )*p);
    }
#line 1908
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1911
  return ('.');
}
}
#line 1930 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
static WIN _stdwin  ;
#line 1926 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
int win_init(int fg , int bg , int attr ) 
{ 
  char *term ;
  int f ;
  int olduseattr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  void *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;

  {
#line 1933
  if (w_init) {
#line 1934
    return (0);
  }
  {
#line 1937
  term = getenv("TERM");
  }
#line 1937
  if ((unsigned long )term == (unsigned long )((void *)0)) {
    {
#line 1938
    tmp = gettext("Environment variable TERM not set\n");
#line 1938
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 1939
    return (-1);
  }
  {
#line 1942
  f = tgetent(cbuf___0, (char const   *)term);
  }
  {
#line 1943
  if (f == 0) {
#line 1943
    goto case_0;
  }
#line 1946
  if (f == -1) {
#line 1946
    goto case_neg_1;
  }
#line 1949
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1944
  tmp___0 = gettext("No termcap entry for %s\n");
#line 1944
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          term);
  }
#line 1945
  return (-1);
  case_neg_1: /* CIL Label */ 
  {
#line 1947
  tmp___1 = gettext("No termcap database present!\n");
#line 1947
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
  }
#line 1948
  return (-1);
  switch_default: /* CIL Label */ 
#line 1950
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1952
  _tptr = tbuf___0;
#line 1954
  tmp___3 = tgetstr("cm", & _tptr);
#line 1954
  CM = (char const   *)tmp___3;
  }
#line 1954
  if ((unsigned long )CM == (unsigned long )((void *)0)) {
    {
#line 1955
    tmp___2 = gettext("No cursor motion capability (cm)\n");
#line 1955
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
    }
#line 1956
    return (-1);
  }
  {
#line 1958
  COLS = 0;
#line 1958
  LINES = COLS;
#line 1959
  getrowcols(& LINES, & COLS);
  }
#line 1963
  if (LINES == 0) {
    {
#line 1963
    LINES = tgetnum("li");
    }
#line 1963
    if (LINES <= 0) {
      {
#line 1964
      tmp___4 = gettext("Number of terminal lines unknown\n");
#line 1964
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
      }
#line 1965
      return (-1);
    }
  }
#line 1967
  if (COLS == 0) {
    {
#line 1967
    COLS = tgetnum("co");
    }
#line 1967
    if (COLS <= 0) {
      {
#line 1968
      tmp___5 = gettext("Number of terminal columns unknown\n");
#line 1968
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
      }
#line 1969
      return (-1);
    }
  }
  {
#line 1973
  tmp___6 = tgetstr("me", & _tptr);
#line 1973
  ME = (char const   *)tmp___6;
#line 1974
  tmp___7 = tgetstr("se", & _tptr);
#line 1974
  SE = (char const   *)tmp___7;
#line 1975
  tmp___8 = tgetstr("ue", & _tptr);
#line 1975
  UE = (char const   *)tmp___8;
#line 1976
  tmp___9 = tgetstr("as", & _tptr);
#line 1976
  AS = (char const   *)tmp___9;
#line 1977
  tmp___10 = tgetstr("ae", & _tptr);
#line 1977
  AE = (char const   *)tmp___10;
#line 1978
  tmp___11 = tgetstr("mb", & _tptr);
#line 1978
  MB = (char const   *)tmp___11;
#line 1979
  tmp___12 = tgetstr("md", & _tptr);
#line 1979
  MD = (char const   *)tmp___12;
#line 1980
  tmp___13 = tgetstr("mr", & _tptr);
#line 1980
  MR = (char const   *)tmp___13;
#line 1981
  tmp___14 = tgetstr("so", & _tptr);
#line 1981
  SO = (char const   *)tmp___14;
#line 1982
  tmp___15 = tgetstr("us", & _tptr);
#line 1982
  US = (char const   *)tmp___15;
#line 1983
  tmp___16 = tgetstr("ce", & _tptr);
#line 1983
  CE = (char const   *)tmp___16;
#line 1984
  tmp___17 = tgetstr("al", & _tptr);
#line 1984
  Al = (char const   *)tmp___17;
#line 1985
  tmp___18 = tgetstr("dl", & _tptr);
#line 1985
  Dl = (char const   *)tmp___18;
#line 1986
  tmp___19 = tgetstr("AL", & _tptr);
#line 1986
  AL = (char const   *)tmp___19;
#line 1987
  tmp___20 = tgetstr("DL", & _tptr);
#line 1987
  DL = (char const   *)tmp___20;
#line 1988
  tmp___21 = tgetstr("cs", & _tptr);
#line 1988
  CS = (char const   *)tmp___21;
#line 1989
  tmp___22 = tgetstr("sf", & _tptr);
#line 1989
  SF = (char const   *)tmp___22;
#line 1990
  tmp___23 = tgetstr("sr", & _tptr);
#line 1990
  SR = (char const   *)tmp___23;
#line 1991
  tmp___24 = tgetstr("vb", & _tptr);
#line 1991
  VB = (char const   *)tmp___24;
#line 1992
  tmp___25 = tgetstr("bl", & _tptr);
#line 1992
  BL = (char const   *)tmp___25;
#line 1993
  tmp___26 = tgetstr("ve", & _tptr);
#line 1993
  VE = (char const   *)tmp___26;
#line 1994
  tmp___27 = tgetstr("vi", & _tptr);
#line 1994
  VI = (char const   *)tmp___27;
#line 1995
  tmp___28 = tgetstr("is", & _tptr);
#line 1995
  IS = (char const   *)tmp___28;
#line 1996
  tmp___29 = tgetstr("rs", & _tptr);
#line 1996
  RS = (char const   *)tmp___29;
#line 1997
  tmp___30 = tgetstr("ks", & _tptr);
#line 1997
  KS = (char const   *)tmp___30;
#line 1998
  tmp___31 = tgetstr("ke", & _tptr);
#line 1998
  KE = (char const   *)tmp___31;
#line 1999
  tmp___32 = tgetstr("cd", & _tptr);
#line 1999
  CD = (char const   *)tmp___32;
#line 2000
  tmp___33 = tgetstr("cl", & _tptr);
#line 2000
  CL = (char const   *)tmp___33;
#line 2001
  tmp___34 = tgetstr("ic", & _tptr);
#line 2001
  IC = (char const   *)tmp___34;
#line 2002
  tmp___35 = tgetstr("dc", & _tptr);
#line 2002
  DC = (char const   *)tmp___35;
#line 2003
  BC = tgetstr("bc", & _tptr);
#line 2004
  tmp___36 = tgetstr("cr", & _tptr);
#line 2004
  CR = (char const   *)tmp___36;
#line 2005
  tmp___37 = tgetstr("nl", & _tptr);
#line 2005
  NL = (char const   *)tmp___37;
#line 2006
  tmp___38 = tgetstr("ac", & _tptr);
#line 2006
  AC = (char const   *)tmp___38;
#line 2007
  tmp___39 = tgetstr("eA", & _tptr);
#line 2007
  EA = (char const   *)tmp___39;
#line 2009
  tmp___40 = tgetstr("ts", & _tptr);
#line 2009
  TS = (char const   *)tmp___40;
#line 2010
  tmp___41 = tgetstr("fs", & _tptr);
#line 2010
  FS = (char const   *)tmp___41;
#line 2011
  tmp___42 = tgetstr("ds", & _tptr);
#line 2011
  DS = (char const   *)tmp___42;
  }
#line 2014
  if ((unsigned long )MR == (unsigned long )((void *)0)) {
#line 2015
    MR = SO;
  }
#line 2016
  if ((unsigned long )MR == (unsigned long )((void *)0)) {
#line 2017
    MR = US;
  }
#line 2018
  if ((unsigned long )MR == (unsigned long )((void *)0)) {
#line 2019
    MR = MD;
  }
#line 2020
  if ((unsigned long )SF == (unsigned long )((void *)0)) {
#line 2021
    SF = "\n";
  }
#line 2022
  if ((unsigned long )AC == (unsigned long )((void *)0)) {
#line 2023
    AC = def_ac;
  } else
#line 2022
  if ((int const   )*AC == 0) {
#line 2023
    AC = def_ac;
  }
#line 2029
  if ((unsigned long )CR == (unsigned long )((void *)0)) {
#line 2030
    CR = "\r";
  }
#line 2031
  if ((unsigned long )NL == (unsigned long )((void *)0)) {
#line 2032
    NL = "\n";
  }
  {
#line 2036
  tmp___43 = tgetflag("hs");
  }
#line 2036
  if (tmp___43) {
    {
#line 2036
    tmp___44 = tgetflag("es");
    }
#line 2036
    if (tmp___44) {
#line 2036
      if (! TS) {
#line 2037
        use_status = 0;
      } else
#line 2036
      if (! FS) {
#line 2037
        use_status = 0;
      }
    } else {
#line 2037
      use_status = 0;
    }
  } else {
#line 2037
    use_status = 0;
  }
#line 2042
  if ((unsigned long )IS != (unsigned long )((void *)0)) {
    {
#line 2043
    outstr(IS);
    }
  }
  {
#line 2046
  olduseattr = useattr;
#line 2047
  useattr = 1;
#line 2048
  _setattr((char)0, (char )(7 << 4));
#line 2049
  useattr = olduseattr;
  }
#line 2052
  if ((unsigned long )MR == (unsigned long )((void *)0)) {
#line 2053
    useattr = 0;
  }
  {
#line 2056
  tmp___45 = tgetnum("ug");
  }
#line 2056
  if (tmp___45 > 0) {
#line 2057
    useattr = 0;
  }
  {
#line 2059
  _has_am = tgetflag("am");
#line 2060
  _mv_standout = tgetflag("ms");
#line 2061
  tmp___46 = tgetflag("bs");
  }
#line 2061
  if (tmp___46) {
#line 2062
    if ((unsigned long )BC == (unsigned long )((void *)0)) {
#line 2063
      BC = (char *)"\b";
    }
  } else {
#line 2066
    BC = (char *)((void *)0);
  }
#line 2069
  D_UL = (char)-55;
#line 2070
  D_HOR = (char)-51;
#line 2071
  D_UR = (char)-69;
#line 2072
  D_LL = (char)-56;
#line 2073
  D_VER = (char)-70;
#line 2074
  D_LR = (char)-68;
#line 2076
  S_UL = (char)-38;
#line 2077
  S_HOR = (char)-16;
#line 2078
  S_UR = (char)-65;
#line 2079
  S_LL = (char)-64;
#line 2080
  S_VER = (char)-77;
#line 2081
  S_LR = (char)-39;
#line 2083
  if ((unsigned long )AS != (unsigned long )((void *)0)) {
#line 2083
    if (! screen_ibmpc) {
      {
#line 2085
      tmp___47 = acmap('l');
#line 2085
      S_UL = (char )tmp___47;
#line 2085
      D_UL = S_UL;
#line 2086
      tmp___48 = acmap('q');
#line 2086
      S_HOR = (char )tmp___48;
#line 2086
      D_HOR = S_HOR;
#line 2087
      tmp___49 = acmap('k');
#line 2087
      S_UR = (char )tmp___49;
#line 2087
      D_UR = S_UR;
#line 2088
      tmp___50 = acmap('m');
#line 2088
      S_LL = (char )tmp___50;
#line 2088
      D_LL = S_LL;
#line 2089
      tmp___51 = acmap('x');
#line 2089
      S_VER = (char )tmp___51;
#line 2089
      D_VER = S_VER;
#line 2090
      tmp___52 = acmap('j');
#line 2090
      S_LR = (char )tmp___52;
#line 2090
      D_LR = S_LR;
      }
    }
  }
#line 2093
  if (screen_iso) {
#line 2095
    S_UL = (char )'+';
#line 2095
    D_UL = S_UL;
#line 2096
    S_HOR = (char )'-';
#line 2096
    D_HOR = S_HOR;
#line 2097
    S_UR = (char )'+';
#line 2097
    D_UR = S_UR;
#line 2098
    S_LL = (char )'+';
#line 2098
    D_LL = S_LL;
#line 2099
    S_VER = (char )'|';
#line 2099
    D_VER = S_VER;
#line 2100
    S_LR = (char )'+';
#line 2100
    D_LR = S_LR;
  }
  {
#line 2105
  tmp___53 = malloc((sizeof(ELM ) * (unsigned long )(LINES + 1)) * (unsigned long )COLS);
#line 2105
  gmap = (ELM *)tmp___53;
  }
#line 2105
  if ((unsigned long )gmap == (unsigned long )((void *)0)) {
    {
#line 2106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory\n");
    }
#line 2107
    return (-1);
  }
#line 2109
  _buffend = _bufstart + 2048;
#line 2112
  stdwin = & _stdwin;
#line 2114
  stdwin->wrap = (char)1;
#line 2115
  stdwin->cursor = (char)1;
#line 2116
  stdwin->autocr = (char)1;
#line 2117
  stdwin->doscroll = (char)1;
#line 2118
  stdwin->x1 = 0;
#line 2119
  tmp___54 = 0;
#line 2119
  stdwin->y1 = tmp___54;
#line 2119
  stdwin->sy1 = tmp___54;
#line 2120
  stdwin->x2 = COLS - 1;
#line 2121
  tmp___55 = LINES - 1;
#line 2121
  stdwin->y2 = tmp___55;
#line 2121
  stdwin->sy2 = tmp___55;
#line 2122
  stdwin->xs = COLS;
#line 2123
  stdwin->ys = LINES;
#line 2124
  stdwin->attr = (char )attr;
#line 2125
  stdwin->color = (char )((fg << 4) + bg);
#line 2126
  stdwin->direct = (char)1;
#line 2127
  stdwin->histbuf = (ELM *)((void *)0);
#line 2129
  if ((unsigned long )EA != (unsigned long )((void *)0)) {
    {
#line 2130
    outstr(EA);
    }
  }
#line 2131
  if ((unsigned long )KS != (unsigned long )((void *)0)) {
    {
#line 2132
    outstr(KS);
    }
  }
  {
#line 2134
  setcbreak(1);
#line 2136
  mc_winclr(stdwin);
#line 2137
  w_init = 1;
  }
#line 2138
  return (0);
}
}
#line 2141 "/home/wheatley/newnew/temp/minicom-2.7/src/window.c"
void win_end(void) 
{ 


  {
#line 2143
  if ((unsigned long )gmap == (unsigned long )((void *)0)) {
#line 2144
    return;
  } else
#line 2143
  if (w_init == 0) {
#line 2144
    return;
  }
  {
#line 2145
  setcbreak(0);
#line 2146
  stdwin->attr = (char)0;
#line 2147
  stdwin->color = (char )(7 << 4);
#line 2148
  _setattr(stdwin->attr, stdwin->color);
#line 2149
  mc_winclr(stdwin);
  }
#line 2151
  if (DS) {
    {
#line 2152
    outstr(DS);
    }
  }
  {
#line 2154
  mc_wcursor(stdwin, 1);
  }
#line 2155
  if ((unsigned long )KE != (unsigned long )((void *)0)) {
    {
#line 2156
    outstr(KE);
    }
  }
#line 2157
  if ((unsigned long )RS != (unsigned long )((void *)0)) {
    {
#line 2158
    outstr(RS);
    }
  } else
#line 2159
  if ((unsigned long )IS != (unsigned long )((void *)0)) {
    {
#line 2160
    outstr(IS);
    }
  }
  {
#line 2162
  mc_wflush();
#line 2163
  free((void *)gmap);
#line 2164
  gmap = (ELM *)((void *)0);
#line 2165
  stdwin = (WIN *)((void *)0);
#line 2166
  w_init = 0;
  }
#line 2167
  return;
}
}
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 80 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsendbreak)(int __fd ,
                                                                                  int __duration ) ;
#line 224 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
void term_socket_connect(void) ;
#line 258
void m_sethwf(int fd , int on ) ;
#line 263
void m_savestate(int fd ) ;
#line 265
void m_nohang(int fd ) ;
#line 269
unsigned int m_getmaxspd(void) ;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_sethwf(int fd , int on ) 
{ 
  struct termios tty ;

  {
#line 47
  if (portfd_is_socket) {
#line 48
    return;
  }
  {
#line 52
  tcgetattr(fd, & tty);
  }
#line 53
  if (on) {
#line 54
    tty.c_cflag |= 2147483648U;
  } else {
#line 56
    tty.c_cflag &= 2147483647U;
  }
  {
#line 57
  tcsetattr(fd, 0, (struct termios  const  *)(& tty));
  }
#line 59
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
static void m_setrts(int fd ) 
{ 
  int mcs ;

  {
#line 65
  if (portfd_is_socket) {
#line 66
    return;
  }
  {
#line 70
  mcs = 0;
#line 72
  ioctl(fd, 21525UL, & mcs);
#line 73
  mcs |= 4;
#line 74
  ioctl(fd, 21528UL, & mcs);
  }
#line 77
  return;
}
}
#line 82 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_dtrtoggle(int fd , int sec ) 
{ 
  struct termios tty ;
  struct termios old ;

  {
#line 85
  if (portfd_is_socket) {
#line 86
    return;
  }
  {
#line 103
  tcgetattr(fd, & tty);
#line 104
  tcgetattr(fd, & old);
#line 106
  tty.c_cflag &= 4294963184U;
#line 107
  tcsetattr(fd, 0, (struct termios  const  *)(& tty));
  }
#line 108
  if (sec > 0) {
    {
#line 109
    sleep((unsigned int )sec);
#line 110
    tcsetattr(fd, 0, (struct termios  const  *)(& old));
    }
  }
#line 133
  return;
}
}
#line 138 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_break(int fd ) 
{ 


  {
#line 141
  if (portfd_is_socket) {
#line 142
    return;
  }
  {
#line 145
  tcsendbreak(fd, 0);
  }
#line 167
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
int m_getdcd(int fd ) 
{ 
  int mcs ;
  int tmp ;
  int tmp___0 ;

  {
#line 175
  if (portfd_is_socket) {
#line 176
    if (portfd_is_connected) {
#line 177
      return (1);
    }
    {
#line 179
    term_socket_connect();
    }
#line 180
    return (portfd_is_connected);
  }
  {
#line 185
  mcs = 0;
#line 187
  tmp = ioctl(fd, 21525UL, & mcs);
  }
#line 187
  if (tmp < 0) {
#line 188
    return (-1);
  }
#line 189
  if (mcs & 64) {
#line 189
    tmp___0 = 1;
  } else {
#line 189
    tmp___0 = 0;
  }
#line 189
  return (tmp___0);
}
}
#line 199 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
static struct termios savetty___0  ;
#line 200 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
static int m_word  ;
#line 213 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_savestate(int fd ) 
{ 


  {
#line 216
  if (portfd_is_socket) {
#line 217
    return;
  }
  {
#line 220
  tcgetattr(fd, & savetty___0);
#line 231
  ioctl(fd, 21525UL, & m_word);
  }
#line 233
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_restorestate(int fd ) 
{ 


  {
#line 241
  if (portfd_is_socket) {
#line 242
    return;
  }
  {
#line 245
  tcsetattr(fd, 0, (struct termios  const  *)(& savetty___0));
#line 256
  ioctl(fd, 21528UL, & m_word);
  }
#line 258
  return;
}
}
#line 265 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_nohang(int fd ) 
{ 
  struct termios sgg ;

  {
#line 268
  if (portfd_is_socket) {
#line 269
    return;
  }
  {
#line 275
  tcgetattr(fd, & sgg);
#line 276
  sgg.c_cflag |= 2048U;
#line 277
  tcsetattr(fd, 0, (struct termios  const  *)(& sgg));
  }
#line 288
  return;
}
}
#line 293 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_hupcl(int fd , int on ) 
{ 
  struct termios sgg ;

  {
#line 296
  if (portfd_is_socket) {
#line 297
    return;
  }
  {
#line 304
  tcgetattr(fd, & sgg);
  }
#line 305
  if (on) {
#line 306
    sgg.c_cflag |= 1024U;
  } else {
#line 308
    sgg.c_cflag &= 4294966271U;
  }
  {
#line 309
  tcsetattr(fd, 0, (struct termios  const  *)(& sgg));
  }
#line 312
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
int m_readchk(int fd ) 
{ 
  long i ;

  {
  {
#line 321
  i = -1L;
#line 323
  ioctl(fd, 21531UL, & i);
  }
#line 324
  return ((int )i);
}
}
#line 346 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
unsigned int m_getmaxspd(void) 
{ 


  {
#line 349
  return (4000000U);
}
}
#line 394 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
void m_setparms(int fd , char *baudr , char *par , char *bits , char *stopb , int hwf ,
                int swf ) 
{ 
  int spd ;
  int newbaud ;
  int bit ;
  struct termios tty ;
  long tmp ;

  {
#line 397
  spd = -1;
#line 399
  bit = (int )*(bits + 0);
#line 408
  if (portfd_is_socket) {
#line 409
    return;
  }
  {
#line 413
  tcgetattr(fd, & tty);
  }
#line 420
  if (bit == 55) {
#line 420
    if ((int )*(par + 0) == 77) {
#line 421
      bit = '8';
    } else
#line 420
    if ((int )*(par + 0) == 83) {
#line 421
      bit = '8';
    }
  }
  {
#line 424
  tmp = atol((char const   *)baudr);
#line 424
  newbaud = (int )(tmp / 100L);
  }
#line 424
  if (newbaud == 0) {
#line 424
    if ((int )*(baudr + 0) != 48) {
#line 425
      newbaud = -1;
    }
  }
  {
#line 428
  if (newbaud == 0) {
#line 428
    goto case_0;
  }
#line 435
  if (newbaud == 3) {
#line 435
    goto case_3;
  }
#line 436
  if (newbaud == 6) {
#line 436
    goto case_6;
  }
#line 437
  if (newbaud == 12) {
#line 437
    goto case_12;
  }
#line 438
  if (newbaud == 24) {
#line 438
    goto case_24;
  }
#line 439
  if (newbaud == 48) {
#line 439
    goto case_48;
  }
#line 440
  if (newbaud == 96) {
#line 440
    goto case_96;
  }
#line 442
  if (newbaud == 192) {
#line 442
    goto case_192;
  }
#line 451
  if (newbaud == 384) {
#line 451
    goto case_384;
  }
#line 460
  if (newbaud == 576) {
#line 460
    goto case_576;
  }
#line 463
  if (newbaud == 1152) {
#line 463
    goto case_1152;
  }
#line 466
  if (newbaud == 2304) {
#line 466
    goto case_2304;
  }
#line 469
  if (newbaud == 4608) {
#line 469
    goto case_4608;
  }
#line 472
  if (newbaud == 5000) {
#line 472
    goto case_5000;
  }
#line 475
  if (newbaud == 5760) {
#line 475
    goto case_5760;
  }
#line 478
  if (newbaud == 9216) {
#line 478
    goto case_9216;
  }
#line 481
  if (newbaud == 10000) {
#line 481
    goto case_10000;
  }
#line 484
  if (newbaud == 11520) {
#line 484
    goto case_11520;
  }
#line 487
  if (newbaud == 15000) {
#line 487
    goto case_15000;
  }
#line 490
  if (newbaud == 20000) {
#line 490
    goto case_20000;
  }
#line 493
  if (newbaud == 25000) {
#line 493
    goto case_25000;
  }
#line 496
  if (newbaud == 30000) {
#line 496
    goto case_30000;
  }
#line 499
  if (newbaud == 35000) {
#line 499
    goto case_35000;
  }
#line 502
  if (newbaud == 40000) {
#line 502
    goto case_40000;
  }
#line 427
  goto switch_break;
  case_0: /* CIL Label */ 
#line 430
  spd = 0;
#line 434
  goto switch_break;
  case_3: /* CIL Label */ 
#line 435
  spd = 7;
#line 435
  goto switch_break;
  case_6: /* CIL Label */ 
#line 436
  spd = 8;
#line 436
  goto switch_break;
  case_12: /* CIL Label */ 
#line 437
  spd = 9;
#line 437
  goto switch_break;
  case_24: /* CIL Label */ 
#line 438
  spd = 11;
#line 438
  goto switch_break;
  case_48: /* CIL Label */ 
#line 439
  spd = 12;
#line 439
  goto switch_break;
  case_96: /* CIL Label */ 
#line 440
  spd = 13;
#line 440
  goto switch_break;
  case_192: /* CIL Label */ 
#line 442
  spd = 14;
#line 442
  goto switch_break;
  case_384: /* CIL Label */ 
#line 451
  spd = 15;
#line 451
  goto switch_break;
  case_576: /* CIL Label */ 
#line 460
  spd = 4097;
#line 460
  goto switch_break;
  case_1152: /* CIL Label */ 
#line 463
  spd = 4098;
#line 463
  goto switch_break;
  case_2304: /* CIL Label */ 
#line 466
  spd = 4099;
#line 466
  goto switch_break;
  case_4608: /* CIL Label */ 
#line 469
  spd = 4100;
#line 469
  goto switch_break;
  case_5000: /* CIL Label */ 
#line 472
  spd = 4101;
#line 472
  goto switch_break;
  case_5760: /* CIL Label */ 
#line 475
  spd = 4102;
#line 475
  goto switch_break;
  case_9216: /* CIL Label */ 
#line 478
  spd = 4103;
#line 478
  goto switch_break;
  case_10000: /* CIL Label */ 
#line 481
  spd = 4104;
#line 481
  goto switch_break;
  case_11520: /* CIL Label */ 
#line 484
  spd = 4105;
#line 484
  goto switch_break;
  case_15000: /* CIL Label */ 
#line 487
  spd = 4106;
#line 487
  goto switch_break;
  case_20000: /* CIL Label */ 
#line 490
  spd = 4107;
#line 490
  goto switch_break;
  case_25000: /* CIL Label */ 
#line 493
  spd = 4108;
#line 493
  goto switch_break;
  case_30000: /* CIL Label */ 
#line 496
  spd = 4109;
#line 496
  goto switch_break;
  case_35000: /* CIL Label */ 
#line 499
  spd = 4110;
#line 499
  goto switch_break;
  case_40000: /* CIL Label */ 
#line 502
  spd = 4111;
#line 502
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 541
  if (spd != -1) {
#line 543
    tty.c_cflag = (tty.c_cflag & 4294963184U) | (speed_t )spd;
  }
  {
#line 547
  if (bit == 53) {
#line 547
    goto case_53;
  }
#line 550
  if (bit == 54) {
#line 550
    goto case_54;
  }
#line 553
  if (bit == 55) {
#line 553
    goto case_55;
  }
#line 557
  goto switch_default;
  case_53: /* CIL Label */ 
#line 548
  tty.c_cflag &= 4294967247U;
#line 549
  goto switch_break___0;
  case_54: /* CIL Label */ 
#line 551
  tty.c_cflag = (tty.c_cflag & 4294967247U) | 16U;
#line 552
  goto switch_break___0;
  case_55: /* CIL Label */ 
#line 554
  tty.c_cflag = (tty.c_cflag & 4294967247U) | 32U;
#line 555
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 558
  tty.c_cflag = (tty.c_cflag & 4294967247U) | 48U;
#line 559
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 562
  tty.c_iflag = (tcflag_t )1;
#line 563
  tty.c_lflag = (tcflag_t )0;
#line 564
  tty.c_oflag = (tcflag_t )0;
#line 565
  tty.c_cflag |= 2176U;
#line 569
  tty.c_cc[6] = (cc_t )1;
#line 570
  tty.c_cc[5] = (cc_t )5;
#line 572
  if (swf) {
#line 573
    tty.c_iflag |= 5120U;
  } else {
#line 575
    tty.c_iflag &= 4294960127U;
  }
#line 577
  tty.c_cflag &= 4294966527U;
#line 578
  if ((int )*(par + 0) == 69) {
#line 579
    tty.c_cflag |= 256U;
  } else
#line 580
  if ((int )*(par + 0) == 79) {
#line 581
    tty.c_cflag |= 768U;
  }
#line 583
  if ((int )*(stopb + 0) == 50) {
#line 584
    tty.c_cflag |= 64U;
  } else {
#line 586
    tty.c_cflag &= 4294967231U;
  }
  {
#line 588
  tcsetattr(fd, 0, (struct termios  const  *)(& tty));
#line 590
  m_setrts(fd);
#line 594
  m_sethwf(fd, hwf);
  }
#line 596
  return;
}
}
#line 601 "/home/wheatley/newnew/temp/minicom-2.7/src/sysdep1.c"
int m_wait(int *stt ) 
{ 
  int pid ;
  int st1 ;
  union __anonunion_60 __constr_expr_4 ;
  union __anonunion_61 __constr_expr_5 ;

  {
  {
#line 614
  pid = wait((union wait *)(& st1));
#line 615
  __constr_expr_4.__in = st1;
#line 615
  __constr_expr_5.__in = st1;
#line 615
  *stt = (int )((unsigned int )((__constr_expr_4.__i & 65280) >> 8) + 256U * (unsigned int )(__constr_expr_5.__i & 127));
  }
#line 616
  return (pid);
}
}
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 83 "/home/wheatley/newnew/temp/minicom-2.7/src/window.h"
char const   *J_col[8] ;
#line 151 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
int Jcolor(char *s___0 ) ;
#line 165
int waccess(char *s___0 ) ;
#line 173
void vdodflsave(void) ;
#line 174
int domacsave(void) ;
#line 176
int saveconv(char *buf___6 ) ;
#line 299
void domacros(void) ;
#line 43 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void doconv(void) ;
#line 46 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void read_parms(void) 
{ 
  FILE *fp ;
  int f ;
  char buf___6[64] ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 54
  fp = fopen((char const   */* __restrict  */)(parfile), (char const   */* __restrict  */)"r");
  }
#line 54
  if (fp) {
    {
#line 55
    readpars(fp, (enum config_type )0);
#line 56
    fclose(fp);
    }
  }
  {
#line 60
  fp = fopen((char const   */* __restrict  */)(pparfile), (char const   */* __restrict  */)"r");
  }
#line 60
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 61
    readpars(fp, (enum config_type )1);
#line 62
    fclose(fp);
    }
  }
  {
#line 66
  mfcolor = Jcolor(mpars[68].value);
#line 66
  mbcolor = Jcolor(mpars[69].value);
#line 67
  tfcolor = Jcolor(mpars[70].value);
#line 67
  tbcolor = Jcolor(mpars[71].value);
#line 68
  sfcolor = Jcolor(mpars[72].value);
#line 68
  sbcolor = Jcolor(mpars[73].value);
  }
#line 71
  if ((int )mpars[74].value[0] != 0) {
    {
#line 72
    tmp___2 = pfix_home(mpars[74].value);
#line 72
    fp = fopen((char const   */* __restrict  */)tmp___2, (char const   */* __restrict  */)"r");
    }
#line 72
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 73
      tmp___1 = __errno_location();
      }
#line 73
      if (*tmp___1 != 2) {
        {
#line 74
        tmp = pfix_home(mpars[74].value);
#line 74
        tmp___0 = gettext("minicom: cannot open macro file %s\n");
#line 74
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
                tmp);
#line 76
        sleep(1U);
        }
      }
    } else {
      {
#line 79
      readmacs(fp, 0);
#line 80
      fclose(fp);
      }
    }
  }
#line 83
  if ((int )mpars[79].value[0] != 0) {
    {
#line 84
    loadconv(mpars[79].value);
    }
  }
#line 88
  f = 0;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (f < 12)) {
#line 88
      goto while_break;
    }
#line 89
    if (*(& mpars[f].value[5] + 0)) {
#line 89
      if ((int )mpars[f].value[3] != 89) {
#line 89
        if ((int )mpars[f].value[3] != 78) {
          {
#line 90
          strncpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)(& mpars[f].value[5] - 2),
                  sizeof(buf___6));
#line 91
          strcpy((char */* __restrict  */)(& mpars[f].value[5]), (char const   */* __restrict  */)(buf___6));
#line 92
          mpars[f].value[3] = (char )'Y';
#line 93
          mpars[f].value[2] = (char )'N';
          }
        }
      }
    }
#line 88
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  p = strrchr((char const   *)(mpars[27].value), '/');
  }
#line 96
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 96
    tmp___3 = strncmp((char const   *)p, "/LCK", (size_t )4);
    }
#line 96
    if (tmp___3 == 0) {
#line 97
      *p = (char)0;
    }
  }
#line 98
  return;
}
}
#line 103 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int Jcolor(char *s___0 ) 
{ 
  char c1___0 ;
  char c3___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 107
  tmp = toupper((int )*(s___0 + 0));
#line 107
  c1___0 = (char )tmp;
#line 108
  tmp___0 = toupper((int )*(s___0 + 2));
#line 108
  c3___0 = (char )tmp___0;
  }
  {
#line 112
  if ((int )c1___0 == 71) {
#line 112
    goto case_71;
  }
#line 113
  if ((int )c1___0 == 89) {
#line 113
    goto case_89;
  }
#line 114
  if ((int )c1___0 == 87) {
#line 114
    goto case_87;
  }
#line 115
  if ((int )c1___0 == 82) {
#line 115
    goto case_82;
  }
#line 116
  if ((int )c1___0 == 77) {
#line 116
    goto case_77;
  }
#line 117
  if ((int )c1___0 == 67) {
#line 117
    goto case_67;
  }
#line 118
  if ((int )c1___0 == 66) {
#line 118
    goto case_66;
  }
#line 110
  goto switch_break;
  case_71: /* CIL Label */ 
#line 112
  return (2);
  case_89: /* CIL Label */ 
#line 113
  return (3);
  case_87: /* CIL Label */ 
#line 114
  return (7);
  case_82: /* CIL Label */ 
#line 115
  return (1);
  case_77: /* CIL Label */ 
#line 116
  return (5);
  case_67: /* CIL Label */ 
#line 117
  return (6);
  case_66: /* CIL Label */ 
#line 118
  if ((int )c3___0 == 65) {
#line 119
    return (0);
  }
#line 120
  if ((int )c3___0 == 85) {
#line 121
    return (4);
  }
  switch_break: /* CIL Label */ ;
  }
#line 125
  return (-1);
}
}
#line 132 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int waccess(char *s___0 ) 
{ 
  char *p ;
  char buf___6[128] ;
  struct stat stt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 141
  tmp___0 = stat((char const   */* __restrict  */)s___0, (struct stat */* __restrict  */)(& stt));
  }
#line 141
  if (tmp___0 == 0) {
    {
#line 142
    tmp = access((char const   *)s___0, 2);
    }
#line 142
    if (tmp == 0) {
#line 143
      return (1);
    }
#line 144
    return (-1);
  }
  {
#line 146
  strncpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)s___0,
          sizeof(buf___6) - 1UL);
#line 147
  buf___6[sizeof(buf___6) - 1UL] = (char)0;
#line 148
  p = strrchr((char const   *)(buf___6), '/');
  }
#line 148
  if ((unsigned long )p == (unsigned long )((char *)((void *)0))) {
    {
#line 149
    strcpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)".");
    }
  } else {
#line 151
    *p = (char )'\000';
  }
  {
#line 152
  tmp___1 = access((char const   *)(buf___6), 2);
  }
#line 152
  if (tmp___1 == 0) {
#line 153
    return (2);
  }
#line 154
  return (-1);
}
}
#line 165 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void mgets(WIN *w , int x , int y , char *s___0 , int len , int maxl ) 
{ 
  struct macs *m ;

  {
  {
#line 167
  m = (struct macs *)s___0;
#line 169
  mc_wlocate(w, x, y);
#line 170
  mc_wgets(w, s___0, len, maxl);
#line 171
  m->flags |= 3;
  }
#line 172
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void pgets(WIN *w , int x , int y , char *s___0 , int len , unsigned int maxl ,
                  int extend_tilde ) 
{ 
  struct pars *p ;
  char *home ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  wchar_t wc ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 181
  p = (struct pars *)s___0;
#line 182
  home = (char *)((void *)0);
#line 184
  mc_wlocate(w, x, y);
#line 185
  mc_wgets(w, s___0, len, (int )maxl);
  }
#line 186
  if (extend_tilde) {
#line 186
    if ((int )*(s___0 + 0) == 126) {
#line 186
      if ((int )*(s___0 + 1) == 47) {
#line 186
        goto _L;
      } else
#line 186
      if ((int )*(s___0 + 1) == 0) {
        _L: /* CIL Label */ 
        {
#line 186
        home = getenv("HOME");
        }
#line 186
        if (home) {
          {
#line 186
          tmp___4 = strlen((char const   *)s___0);
#line 186
          tmp___5 = strlen((char const   *)home);
          }
#line 186
          if (tmp___4 + tmp___5 <= (size_t )maxl) {
            {
#line 189
            i = 0;
#line 190
            tmp = strlen((char const   *)s___0);
#line 190
            tmp___0 = strlen((char const   *)home);
#line 190
            memmove((void *)(s___0 + tmp___0), (void const   *)(s___0 + 1), tmp);
#line 191
            tmp___1 = strlen((char const   *)home);
#line 191
            memcpy((void */* __restrict  */)s___0, (void const   */* __restrict  */)home,
                   tmp___1);
#line 192
            mc_wlocate(w, x, y);
#line 193
            i = 0;
            }
            {
#line 193
            while (1) {
              while_continue: /* CIL Label */ ;
#line 193
              if (len >= w->xs - x) {
#line 193
                tmp___3 = (w->xs - x) - 1;
              } else {
#line 193
                tmp___3 = len;
              }
#line 193
              if (i < tmp___3) {
#line 193
                if (! *s___0) {
#line 193
                  goto while_break;
                }
              } else {
#line 193
                goto while_break;
              }
              {
#line 196
              tmp___2 = one_mbtowc(& wc, (char const   *)s___0, (size_t )16);
#line 196
              s___0 += tmp___2;
#line 197
              mc_wputc(w, wc);
#line 193
              i ++;
              }
            }
            while_break: /* CIL Label */ ;
            }
            {
#line 199
            mc_wflush();
            }
          }
        }
      }
    }
  }
#line 201
  p->flags |= 3;
#line 202
  return;
}
}
#line 207 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void markch(char *s___0 ) 
{ 
  struct pars *p ;

  {
#line 209
  p = (struct pars *)s___0;
#line 211
  p->flags |= 3;
#line 212
  return;
}
}
#line 217 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void psets(char *s___0 , char const   *w ) 
{ 
  struct pars *p ;

  {
  {
#line 219
  p = (struct pars *)s___0;
#line 221
  strcpy((char */* __restrict  */)s___0, (char const   */* __restrict  */)w);
#line 222
  p->flags |= 3;
  }
#line 223
  return;
}
}
#line 229 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static int rwxgetch(void) 
{ 
  int c___0 ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 231
  tmp = wxgetch();
#line 231
  c___0 = tmp;
#line 233
  tmp___0 = __ctype_b_loc();
  }
#line 233
  if ((int const   )*(*tmp___0 + c___0) & 512) {
    {
#line 234
    c___0 = toupper(c___0);
    }
  }
#line 235
  if (c___0 == 10) {
#line 236
    return ('\n');
  } else
#line 235
  if (c___0 == 13) {
#line 236
    return ('\n');
  } else
#line 235
  if (c___0 == 27) {
#line 236
    return ('\n');
  }
#line 237
  return (c___0);
}
}
#line 241 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void dologopt(void) 
{ 
  WIN *w ;
  int c___0 ;
  char *logfnstr ;
  char *tmp ;
  char *logconn ;
  char *tmp___0 ;
  char *logxfer ;
  char *tmp___1 ;
  char *question ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 245
  tmp = gettext(" A - File name (empty=disable) :");
#line 245
  logfnstr = tmp;
#line 246
  tmp___0 = gettext(" B - Log connects and hangups  :");
#line 246
  logconn = tmp___0;
#line 247
  tmp___1 = gettext(" C - Log file transfers        :");
#line 247
  logxfer = tmp___1;
#line 248
  tmp___2 = gettext("Change which setting?");
#line 248
  question = tmp___2;
#line 250
  w = mc_wopen(5, 4, 75, 8, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 252
  tmp___3 = gettext("Logging options");
#line 252
  mc_wtitle(w, 1, (char const   *)tmp___3);
#line 253
  mc_wprintf(w, "%s %s\n", logfnstr, mpars[83].value);
#line 254
  tmp___4 = gettext((char const   *)(mpars[84].value));
#line 254
  mc_wprintf(w, "%s %s\n", logconn, tmp___4);
#line 255
  tmp___5 = gettext((char const   *)(mpars[85].value));
#line 255
  mc_wprintf(w, "%s %s\n", logxfer, tmp___5);
#line 256
  mc_wlocate(w, 4, 4);
#line 257
  mc_wputs(w, (char const   *)question);
#line 258
  mc_wredraw(w, 1);
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 260
    tmp___6 = mbslen((char const   *)question);
#line 260
    mc_wlocate(w, (int )(tmp___6 + 5UL), 5);
#line 261
    c___0 = rwxgetch();
    }
    {
#line 263
    if (c___0 == 10) {
#line 263
      goto case_10;
    }
#line 266
    if (c___0 == 65) {
#line 266
      goto case_65;
    }
#line 271
    if (c___0 == 66) {
#line 271
      goto case_66;
    }
#line 277
    if (c___0 == 67) {
#line 277
      goto case_67;
    }
#line 283
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 264
    mc_wclose(w, 1);
    }
#line 265
    return;
    case_65: /* CIL Label */ 
    {
#line 267
    tmp___7 = mbslen((char const   *)logfnstr);
#line 267
    pgets(w, (int )(tmp___7 + 1UL), 0, mpars[83].value, 128, 128U, 1);
#line 269
    strcpy((char */* __restrict  */)(logfname), (char const   */* __restrict  */)(mpars[83].value));
    }
#line 270
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 272
    tmp___8 = yesno((int )mpars[84].value[0] == 78);
#line 272
    strcpy((char */* __restrict  */)(mpars[84].value), (char const   */* __restrict  */)tmp___8);
#line 273
    tmp___9 = mbslen((char const   *)logconn);
#line 273
    mc_wlocate(w, (int )(tmp___9 + 1UL), 1);
#line 274
    tmp___10 = gettext((char const   *)(mpars[84].value));
#line 274
    mc_wprintf(w, "%s  ", tmp___10);
#line 275
    markch(mpars[84].value);
    }
#line 276
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 278
    tmp___11 = yesno((int )mpars[85].value[0] == 78);
#line 278
    strcpy((char */* __restrict  */)(mpars[85].value), (char const   */* __restrict  */)tmp___11);
#line 279
    tmp___12 = mbslen((char const   *)logxfer);
#line 279
    mc_wlocate(w, (int )(tmp___12 + 1UL), 2);
#line 280
    tmp___13 = gettext((char const   *)(mpars[85].value));
#line 280
    mc_wprintf(w, "%s  ", tmp___13);
#line 281
    markch(mpars[85].value);
    }
#line 282
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 284
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 290 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void dopath(void) 
{ 
  WIN *w ;
  int c___0 ;
  char *download_directory ;
  char *tmp ;
  char *upload_directory ;
  char *tmp___0 ;
  char *script_directory ;
  char *tmp___1 ;
  char *script_program ;
  char *tmp___2 ;
  char *kermit_program ;
  char *tmp___3 ;
  char *log_settings ;
  char *tmp___4 ;
  char *question ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 294
  tmp = gettext(" A - Download directory :");
#line 294
  download_directory = tmp;
#line 295
  tmp___0 = gettext(" B - Upload directory   :");
#line 295
  upload_directory = tmp___0;
#line 296
  tmp___1 = gettext(" C - Script directory   :");
#line 296
  script_directory = tmp___1;
#line 297
  tmp___2 = gettext(" D - Script program     :");
#line 297
  script_program = tmp___2;
#line 298
  tmp___3 = gettext(" E - Kermit program     :");
#line 298
  kermit_program = tmp___3;
#line 300
  tmp___4 = gettext(" F - Logging options");
#line 300
  log_settings = tmp___4;
#line 302
  tmp___5 = gettext("Change which setting?");
#line 302
  question = tmp___5;
#line 304
  w = mc_wopen(5, 5, 75, 12, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 305
  mc_wprintf(w, "%s %.44s\n", download_directory, mpars[59].value);
#line 306
  mc_wprintf(w, "%s %.44s\n", upload_directory, mpars[58].value);
#line 307
  mc_wprintf(w, "%s %.44s\n", script_directory, mpars[60].value);
#line 308
  mc_wprintf(w, "%s %.44s\n", script_program, mpars[36].value);
#line 309
  mc_wprintf(w, "%s %.44s\n", kermit_program, mpars[32].value);
#line 311
  mc_wprintf(w, "%s\n", log_settings);
#line 313
  mc_wlocate(w, 4, 8);
#line 314
  mc_wputs(w, (char const   *)question);
#line 316
  mc_wredraw(w, 1);
  }
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 319
    tmp___6 = mbslen((char const   *)question);
#line 319
    mc_wlocate(w, (int )(tmp___6 + 5UL), 8);
#line 320
    c___0 = rwxgetch();
    }
    {
#line 322
    if (c___0 == 10) {
#line 322
      goto case_10;
    }
#line 325
    if (c___0 == 65) {
#line 325
      goto case_65;
    }
#line 329
    if (c___0 == 66) {
#line 329
      goto case_66;
    }
#line 333
    if (c___0 == 67) {
#line 333
      goto case_67;
    }
#line 336
    if (c___0 == 68) {
#line 336
      goto case_68;
    }
#line 339
    if (c___0 == 69) {
#line 339
      goto case_69;
    }
#line 343
    if (c___0 == 70) {
#line 343
      goto case_70;
    }
#line 347
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 323
    mc_wclose(w, 1);
    }
#line 324
    return;
    case_65: /* CIL Label */ 
    {
#line 326
    tmp___7 = mbslen((char const   *)download_directory);
#line 326
    pgets(w, (int )(tmp___7 + 1UL), 0, mpars[59].value, 64, 64U, 1);
#line 327
    init_dir((char )'d');
    }
#line 328
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 330
    tmp___8 = mbslen((char const   *)upload_directory);
#line 330
    pgets(w, (int )(tmp___8 + 1UL), 1, mpars[58].value, 64, 64U, 1);
#line 331
    init_dir((char )'u');
    }
#line 332
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 334
    tmp___9 = mbslen((char const   *)script_directory);
#line 334
    pgets(w, (int )(tmp___9 + 1UL), 2, mpars[60].value, 64, 64U, 1);
    }
#line 335
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 337
    tmp___10 = mbslen((char const   *)script_program);
#line 337
    pgets(w, (int )(tmp___10 + 1UL), 3, mpars[36].value, 64, 64U, 1);
    }
#line 338
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 340
    tmp___11 = mbslen((char const   *)kermit_program);
#line 340
    pgets(w, (int )(tmp___11 + 1UL), 4, mpars[32].value, 64, 64U, 1);
    }
#line 341
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 344
    dologopt();
    }
#line 345
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 348
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 353 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
char const   *yesno(int k ) 
{ 
  char const   *tmp ;

  {
#line 355
  if (k) {
#line 355
    tmp = "Yes";
  } else {
#line 355
    tmp = "No ";
  }
#line 355
  return (tmp);
}
}
#line 361 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void inputproto(WIN *w , int n ) 
{ 
  int c___0 ;

  {
#line 363
  c___0 = 0;
#line 365
  mpars[n].flags |= 3;
#line 367
  if ((int )*(& mpars[n].value[5] + 0) == 0) {
    {
#line 368
    mpars[n].value[0] = (char )'Y';
#line 369
    mpars[n].value[1] = (char )'U';
#line 370
    mpars[n].value[2] = (char )'N';
#line 371
    mpars[12 + n].value[0] = (char)0;
#line 372
    mpars[n].value[3] = (char )'Y';
#line 373
    mc_wlocate(w, 4, n + 1);
#line 374
    mc_wputs(w, "       ");
    }
  }
  {
#line 376
  mc_wlocate(w, 4, n + 1);
#line 377
  mc_wgets(w, & mpars[n].value[5], 10, 64);
#line 378
  pgets(w, 15, n + 1, mpars[12 + n].value, 31, 64U, 0);
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    mc_wlocate(w, 47, n + 1);
#line 381
    mc_wprintf(w, "%c", (int )mpars[n].value[0]);
#line 382
    c___0 = rwxgetch();
    }
#line 383
    if (c___0 == 89) {
#line 384
      mpars[n].value[0] = (char )'Y';
    }
#line 385
    if (c___0 == 78) {
#line 386
      mpars[n].value[0] = (char )'N';
    }
#line 379
    if (c___0 != 13) {
#line 379
      if (! (c___0 != 10)) {
#line 379
        goto while_break;
      }
    } else {
#line 379
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 388
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 389
    mc_wlocate(w, 52, n + 1);
#line 390
    mc_wprintf(w, "%c", (int )mpars[n].value[1]);
#line 391
    c___0 = rwxgetch();
    }
#line 392
    if (c___0 == 85) {
#line 393
      mpars[n].value[1] = (char )'U';
    }
#line 394
    if (c___0 == 68) {
#line 395
      mpars[n].value[1] = (char )'D';
    }
#line 388
    if (c___0 != 13) {
#line 388
      if (! (c___0 != 10)) {
#line 388
        goto while_break___0;
      }
    } else {
#line 388
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 397
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 398
    mc_wlocate(w, 57, n + 1);
#line 399
    mc_wprintf(w, "%c", (int )mpars[n].value[2]);
#line 400
    c___0 = rwxgetch();
    }
#line 401
    if (c___0 == 89) {
#line 402
      mpars[n].value[2] = (char )'Y';
    }
#line 403
    if (c___0 == 78) {
#line 404
      mpars[n].value[2] = (char )'N';
    }
#line 397
    if (c___0 != 13) {
#line 397
      if (! (c___0 != 10)) {
#line 397
        goto while_break___1;
      }
    } else {
#line 397
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 406
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 407
    mc_wlocate(w, 65, n + 1);
#line 408
    mc_wprintf(w, "%c", (int )mpars[n].value[3]);
#line 409
    c___0 = rwxgetch();
    }
#line 410
    if (c___0 == 89) {
#line 411
      mpars[n].value[3] = (char )'Y';
    }
#line 412
    if (c___0 == 78) {
#line 413
      mpars[n].value[3] = (char )'N';
    }
#line 406
    if (c___0 != 13) {
#line 406
      if (! (c___0 != 10)) {
#line 406
        goto while_break___2;
      }
    } else {
#line 406
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 415
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 416
    mc_wlocate(w, 73, n + 1);
#line 417
    mc_wprintf(w, "%c", (int )mpars[n].value[4]);
#line 418
    c___0 = rwxgetch();
    }
#line 419
    if (c___0 == 89) {
#line 420
      mpars[n].value[4] = (char )'Y';
    }
#line 421
    if (c___0 == 78) {
#line 422
      mpars[n].value[4] = (char )'N';
    }
#line 415
    if (c___0 != 13) {
#line 415
      if (! (c___0 != 10)) {
#line 415
        goto while_break___3;
      }
    } else {
#line 415
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 426 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void doproto(void) 
{ 
  WIN *w ;
  int f ;
  int c___0 ;
  char *zmodem_download ;
  char *tmp ;
  char *use_filename_selection ;
  char *tmp___0 ;
  char *prompt_downdir ;
  char *tmp___1 ;
  char *question ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 430
  tmp = gettext("M  Zmodem download string activates...");
#line 430
  zmodem_download = tmp;
#line 431
  tmp___0 = gettext("N  Use filename selection window......");
#line 431
  use_filename_selection = tmp___0;
#line 432
  tmp___1 = gettext("O  Prompt for download directory......");
#line 432
  prompt_downdir = tmp___1;
#line 433
  tmp___2 = gettext("Change which setting? (SPACE to delete)");
#line 433
  question = tmp___2;
#line 435
  w = mc_wopen(1, 3, 78, 20, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 436
  tmp___3 = gettext("     Name             Program");
#line 436
  mc_wputs(w, (char const   *)tmp___3);
#line 437
  mc_wlocate(w, 46, 0);
#line 438
  tmp___4 = gettext("Name U/D FullScr IO-Red. Multi");
#line 438
  mc_wputs(w, (char const   *)tmp___4);
#line 446
  f = 0;
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (f < 12)) {
#line 446
      goto while_break;
    }
    {
#line 447
    mc_wlocate(w, 1, f + 1);
    }
#line 448
    if (*(& mpars[f].value[5] + 0)) {
      {
#line 449
      mc_wprintf(w, "%c  %-10.10s %-31.31s %c    %c    %c       %c       %c", 65 + f,
                 & mpars[f].value[5], mpars[12 + f].value, (int )mpars[f].value[0],
                 (int )mpars[f].value[1], (int )mpars[f].value[2], (int )mpars[f].value[3],
                 (int )mpars[f].value[4]);
      }
    } else {
      {
#line 456
      mc_wprintf(w, "%c    -", 65 + f);
      }
    }
#line 446
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  mc_wlocate(w, 1, 13);
#line 459
  mc_wprintf(w, "%s %c", zmodem_download, (int )mpars[67].value[0]);
#line 460
  mc_wlocate(w, 1, 14);
#line 461
  tmp___5 = gettext((char const   *)(mpars[81].value));
#line 461
  mc_wprintf(w, "%s %s", use_filename_selection, tmp___5);
#line 462
  mc_wlocate(w, 1, 15);
#line 463
  tmp___6 = gettext((char const   *)(mpars[82].value));
#line 463
  mc_wprintf(w, "%s %s", prompt_downdir, tmp___6);
#line 465
  mc_wlocate(w, 3, 17);
#line 466
  mc_wputs(w, (char const   *)question);
#line 467
  mc_wredraw(w, 1);
  }
  {
#line 469
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 470
    tmp___7 = mbslen((char const   *)question);
#line 470
    mc_wlocate(w, (int )(tmp___7 + 4UL), 17);
#line 471
    c___0 = rwxgetch();
    }
#line 472
    if (c___0 >= 65) {
#line 472
      if (c___0 <= 76) {
        {
#line 473
        inputproto(w, c___0 - 65);
        }
      }
    }
#line 474
    if (c___0 == 32) {
      {
#line 475
      mc_wlocate(w, 3, 17);
#line 476
      tmp___8 = gettext("Delete which protocol? ");
#line 476
      mc_wputs(w, (char const   *)tmp___8);
#line 477
      mc_wclreol(w);
#line 478
      c___0 = rwxgetch();
      }
#line 479
      if (c___0 >= 65) {
#line 479
        if (c___0 <= 76) {
          {
#line 480
          *(& mpars[c___0 - 65].value[5] + 0) = (char )'\000';
#line 481
          mpars[c___0 - 65].flags |= 3;
#line 482
          mc_wlocate(w, 3, (c___0 - 65) + 1);
#line 483
          mc_wclreol(w);
#line 484
          mc_wputs(w, "   -");
          }
        }
      }
      {
#line 486
      mc_wlocate(w, 3, 17);
#line 487
      mc_wputs(w, (char const   *)question);
#line 488
      c___0 = ' ';
      }
    } else
#line 490
    if (c___0 == 77) {
      {
#line 491
      tmp___9 = mbslen((char const   *)zmodem_download);
#line 491
      mc_wlocate(w, (int )(tmp___9 + 2UL), 13);
#line 492
      mc_wprintf(w, " \b");
#line 493
      c___0 = rwxgetch();
      }
#line 494
      if (c___0 >= 65) {
#line 494
        if (c___0 <= 76) {
          {
#line 495
          mpars[67].value[0] = (char )c___0;
#line 496
          markch(mpars[67].value);
#line 497
          mc_wprintf(w, "%c", c___0);
          }
        } else {
#line 494
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 498
      if (c___0 == 10) {
        {
#line 499
        mpars[67].value[0] = (char )' ';
#line 500
        markch(mpars[67].value);
        }
      } else
#line 498
      if (c___0 == 32) {
        {
#line 499
        mpars[67].value[0] = (char )' ';
#line 500
        markch(mpars[67].value);
        }
      } else {
        {
#line 502
        mc_wprintf(w, "%c", (int )mpars[67].value[0]);
        }
      }
#line 504
      c___0 = 0;
    } else
#line 506
    if (c___0 == 78) {
      {
#line 507
      tmp___10 = yesno((int )mpars[81].value[0] == 78);
#line 507
      strcpy((char */* __restrict  */)(mpars[81].value), (char const   */* __restrict  */)tmp___10);
      }
#line 508
      if ((int )mpars[81].value[0] == 78) {
        {
#line 509
        strcpy((char */* __restrict  */)(mpars[82].value), (char const   */* __restrict  */)"No ");
#line 510
        tmp___11 = mbslen((char const   *)prompt_downdir);
#line 510
        mc_wlocate(w, (int )(tmp___11 + 2UL), 15);
#line 511
        tmp___12 = gettext((char const   *)(mpars[82].value));
#line 511
        mc_wprintf(w, "%s ", tmp___12);
#line 512
        markch(mpars[82].value);
        }
      }
      {
#line 514
      tmp___13 = mbslen((char const   *)use_filename_selection);
#line 514
      mc_wlocate(w, (int )(tmp___13 + 2UL), 14);
#line 515
      tmp___14 = gettext((char const   *)(mpars[81].value));
#line 515
      mc_wprintf(w, "%s ", tmp___14);
#line 516
      markch(mpars[81].value);
      }
    } else
#line 518
    if (c___0 == 79) {
      {
#line 519
      tmp___15 = yesno((int )mpars[82].value[0] == 78);
#line 519
      strcpy((char */* __restrict  */)(mpars[82].value), (char const   */* __restrict  */)tmp___15);
      }
#line 520
      if ((int )mpars[82].value[0] == 89) {
        {
#line 521
        strcpy((char */* __restrict  */)(mpars[81].value), (char const   */* __restrict  */)"Yes");
#line 522
        tmp___16 = mbslen((char const   *)use_filename_selection);
#line 522
        mc_wlocate(w, (int )(tmp___16 + 2UL), 14);
#line 523
        tmp___17 = gettext((char const   *)(mpars[81].value));
#line 523
        mc_wprintf(w, "%s ", tmp___17);
#line 524
        markch(mpars[81].value);
        }
      }
      {
#line 526
      tmp___18 = mbslen((char const   *)prompt_downdir);
#line 526
      mc_wlocate(w, (int )(tmp___18 + 2UL), 15);
#line 527
      tmp___19 = gettext((char const   *)(mpars[82].value));
#line 527
      mc_wprintf(w, "%s ", tmp___19);
#line 528
      markch(mpars[82].value);
      }
    }
#line 469
    if (! (c___0 != 10)) {
#line 469
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 531
  mc_wclose(w, 1);
  }
#line 532
  return;
}
}
#line 534 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void doserial(void) 
{ 
  WIN *w ;
  char *serial_device ;
  char *tmp ;
  char *lockfile_location ;
  char *tmp___0 ;
  char *callin_program ;
  char *tmp___1 ;
  char *callout_program ;
  char *tmp___2 ;
  char *bps_par_bits ;
  char *tmp___3 ;
  char *hardware_flow_control ;
  char *tmp___4 ;
  char *software_flow_control ;
  char *tmp___5 ;
  char *question ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char const   *tmp___16 ;
  size_t tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;

  {
  {
#line 537
  tmp = gettext(" A -    Serial Device      :");
#line 537
  serial_device = tmp;
#line 538
  tmp___0 = gettext(" B - Lockfile Location     :");
#line 538
  lockfile_location = tmp___0;
#line 539
  tmp___1 = gettext(" C -   Callin Program      :");
#line 539
  callin_program = tmp___1;
#line 540
  tmp___2 = gettext(" D -  Callout Program      :");
#line 540
  callout_program = tmp___2;
#line 541
  tmp___3 = gettext(" E -    Bps/Par/Bits       :");
#line 541
  bps_par_bits = tmp___3;
#line 542
  tmp___4 = gettext(" F - Hardware Flow Control :");
#line 542
  hardware_flow_control = tmp___4;
#line 543
  tmp___5 = gettext(" G - Software Flow Control :");
#line 543
  software_flow_control = tmp___5;
#line 544
  tmp___6 = gettext("Change which setting?");
#line 544
  question = tmp___6;
#line 546
  w = mc_wopen(5, 4, 75, 12, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 547
  mc_wprintf(w, "%s %.41s\n", serial_device, mpars[24].value);
#line 549
  mc_wprintf(w, "%s %.41s\n", lockfile_location, mpars[27].value);
#line 553
  mc_wprintf(w, "%s %.41s\n", callin_program, mpars[25].value);
#line 554
  mc_wprintf(w, "%s %.41s\n", callout_program, mpars[26].value);
#line 555
  mc_wprintf(w, "%s %s %s%s%s\n", bps_par_bits, mpars[28].value, mpars[29].value,
             mpars[30].value, mpars[31].value);
#line 557
  tmp___7 = gettext((char const   *)(mpars[65].value));
#line 557
  mc_wprintf(w, "%s %s\n", hardware_flow_control, tmp___7);
#line 558
  tmp___8 = gettext((char const   *)(mpars[66].value));
#line 558
  mc_wprintf(w, "%s %s\n", software_flow_control, tmp___8);
#line 559
  mc_wlocate(w, 4, 8);
#line 560
  mc_wputs(w, (char const   *)question);
#line 561
  mc_wredraw(w, 1);
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 564
    tmp___9 = mbslen((char const   *)question);
#line 564
    mc_wlocate(w, (int )(tmp___9 + 5UL), 8);
#line 565
    tmp___10 = rwxgetch();
    }
    {
#line 566
    if (tmp___10 == 10) {
#line 566
      goto case_10;
    }
#line 569
    if (tmp___10 == 65) {
#line 569
      goto case_65;
    }
#line 573
    if (tmp___10 == 66) {
#line 573
      goto case_66;
    }
#line 577
    if (tmp___10 == 67) {
#line 577
      goto case_67;
    }
#line 580
    if (tmp___10 == 68) {
#line 580
      goto case_68;
    }
#line 583
    if (tmp___10 == 69) {
#line 583
      goto case_69;
    }
#line 595
    if (tmp___10 == 70) {
#line 595
      goto case_70;
    }
#line 603
    if (tmp___10 == 71) {
#line 603
      goto case_71;
    }
#line 611
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 567
    mc_wclose(w, 1);
    }
#line 568
    return;
    case_65: /* CIL Label */ 
    {
#line 570
    tmp___11 = mbslen((char const   *)serial_device);
#line 570
    pgets(w, (int )(tmp___11 + 1UL), 0, mpars[24].value, 64, 64U, 1);
    }
#line 571
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 574
    tmp___12 = mbslen((char const   *)lockfile_location);
#line 574
    pgets(w, (int )(tmp___12 + 1UL), 1, mpars[27].value, 64, 64U, 1);
    }
#line 575
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 578
    tmp___13 = mbslen((char const   *)callin_program);
#line 578
    pgets(w, (int )(tmp___13 + 1UL), 2, mpars[25].value, 64, 64U, 1);
    }
#line 579
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 581
    tmp___14 = mbslen((char const   *)callout_program);
#line 581
    pgets(w, (int )(tmp___14 + 1UL), 3, mpars[26].value, 64, 64U, 1);
    }
#line 582
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 584
    get_bbp(mpars[28].value, mpars[29].value, mpars[30].value, mpars[31].value, 0);
    }
#line 585
    if ((int )portfd >= 0) {
      {
#line 586
      port_init();
      }
    }
    {
#line 587
    tmp___15 = mbslen((char const   *)bps_par_bits);
#line 587
    mc_wlocate(w, (int )(tmp___15 + 1UL), 4);
#line 588
    mc_wprintf(w, "%s %s%s%s  \n", mpars[28].value, mpars[29].value, mpars[30].value,
               mpars[31].value);
#line 589
    show_status();
#line 590
    markch(mpars[28].value);
#line 591
    markch(mpars[29].value);
#line 592
    markch(mpars[30].value);
#line 593
    markch(mpars[31].value);
    }
#line 594
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 596
    tmp___16 = yesno((int )mpars[65].value[0] == 78);
#line 596
    strcpy((char */* __restrict  */)(mpars[65].value), (char const   */* __restrict  */)tmp___16);
#line 597
    tmp___17 = mbslen((char const   *)hardware_flow_control);
#line 597
    mc_wlocate(w, (int )(tmp___17 + 1UL), 5);
#line 598
    tmp___18 = gettext((char const   *)(mpars[65].value));
#line 598
    mc_wprintf(w, "%s ", tmp___18);
    }
#line 599
    if ((int )portfd >= 0) {
      {
#line 600
      port_init();
      }
    }
    {
#line 601
    markch(mpars[65].value);
    }
#line 602
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 604
    tmp___19 = yesno((int )mpars[66].value[0] == 78);
#line 604
    strcpy((char */* __restrict  */)(mpars[66].value), (char const   */* __restrict  */)tmp___19);
#line 605
    tmp___20 = mbslen((char const   *)software_flow_control);
#line 605
    mc_wlocate(w, (int )(tmp___20 + 1UL), 6);
#line 606
    tmp___21 = gettext((char const   *)(mpars[66].value));
#line 606
    mc_wprintf(w, "%s ", tmp___21);
    }
#line 607
    if ((int )portfd >= 0) {
      {
#line 608
      port_init();
      }
    }
    {
#line 609
    markch(mpars[66].value);
    }
#line 610
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 612
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 617 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
char *sspd(char *sptyp ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 619
  if ((int )*(sptyp + 0) == 100) {
    {
#line 620
    tmp = gettext("DTE speed ");
    }
#line 620
    return (tmp);
  } else {
    {
#line 622
    tmp___0 = gettext("line speed");
    }
#line 622
    return (tmp___0);
  }
}
}
#line 625 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void domodem(void) 
{ 
  WIN *w ;
  char *str ;
  int c___0 ;
  int x ;
  int y ;
  int ypos ;
  int maxl ;
  int string_size ;
  char const   *init_string ;
  char *tmp ;
  char const   *reset_string ;
  char *tmp___0 ;
  char const   *dialing_prefix_1 ;
  char *tmp___1 ;
  char const   *dialing_suffix_1 ;
  char *tmp___2 ;
  char const   *dialing_prefix_2 ;
  char *tmp___3 ;
  char const   *dialing_suffix_2 ;
  char *tmp___4 ;
  char const   *dialing_prefix_3 ;
  char *tmp___5 ;
  char const   *dialing_suffix_3 ;
  char *tmp___6 ;
  char const   *connect_string ;
  char *tmp___7 ;
  char const   *no_connect_strings ;
  char *tmp___8 ;
  char const   *hangup_string ;
  char *tmp___9 ;
  char const   *dial_cancel_string ;
  char *tmp___10 ;
  char const   *dial_time ;
  char *tmp___11 ;
  char const   *delay_before_redial ;
  char *tmp___12 ;
  char const   *number_of_tries ;
  char *tmp___13 ;
  char const   *dtr_drop_time ;
  char *tmp___14 ;
  char const   *auto_bps_detect ;
  char *tmp___15 ;
  char const   *modem_has_dcd_line ;
  char *tmp___16 ;
  char const   *shown_speed ;
  char *tmp___17 ;
  char const   *multi_node ;
  char *tmp___18 ;
  char const   *question ;
  char *tmp___19 ;
  char const   *defaults[2] ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  int loc ;
  size_t tmp___42 ;
  char const   *tmp___43 ;
  size_t tmp___44 ;
  char *tmp___45 ;
  char const   *tmp___46 ;
  size_t tmp___47 ;
  char *tmp___48 ;
  char const   *tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  char const   *tmp___52 ;
  size_t tmp___53 ;
  char *tmp___54 ;

  {
  {
#line 630
  tmp = gettext(" A - Init string .........");
#line 630
  init_string = (char const   *)tmp;
#line 631
  tmp___0 = gettext(" B - Reset string ........");
#line 631
  reset_string = (char const   *)tmp___0;
#line 632
  tmp___1 = gettext(" C - Dialing prefix #1....");
#line 632
  dialing_prefix_1 = (char const   *)tmp___1;
#line 633
  tmp___2 = gettext(" D - Dialing suffix #1....");
#line 633
  dialing_suffix_1 = (char const   *)tmp___2;
#line 634
  tmp___3 = gettext(" E - Dialing prefix #2....");
#line 634
  dialing_prefix_2 = (char const   *)tmp___3;
#line 635
  tmp___4 = gettext(" F - Dialing suffix #2....");
#line 635
  dialing_suffix_2 = (char const   *)tmp___4;
#line 636
  tmp___5 = gettext(" G - Dialing prefix #3....");
#line 636
  dialing_prefix_3 = (char const   *)tmp___5;
#line 637
  tmp___6 = gettext(" H - Dialing suffix #3....");
#line 637
  dialing_suffix_3 = (char const   *)tmp___6;
#line 638
  tmp___7 = gettext(" I - Connect string ......");
#line 638
  connect_string = (char const   *)tmp___7;
#line 639
  tmp___8 = gettext(" J - No connect strings ..");
#line 639
  no_connect_strings = (char const   *)tmp___8;
#line 640
  tmp___9 = gettext(" K - Hang-up string ......");
#line 640
  hangup_string = (char const   *)tmp___9;
#line 641
  tmp___10 = gettext(" L - Dial cancel string ..");
#line 641
  dial_cancel_string = (char const   *)tmp___10;
#line 642
  tmp___11 = gettext(" M - Dial time ...........");
#line 642
  dial_time = (char const   *)tmp___11;
#line 643
  tmp___12 = gettext(" N - Delay before redial .");
#line 643
  delay_before_redial = (char const   *)tmp___12;
#line 644
  tmp___13 = gettext(" O - Number of tries .....");
#line 644
  number_of_tries = (char const   *)tmp___13;
#line 645
  tmp___14 = gettext(" P - DTR drop time (0=no).");
#line 645
  dtr_drop_time = (char const   *)tmp___14;
#line 646
  tmp___15 = gettext(" Q - Auto bps detect .....");
#line 646
  auto_bps_detect = (char const   *)tmp___15;
#line 647
  tmp___16 = gettext(" R - Modem has DCD line ..");
#line 647
  modem_has_dcd_line = (char const   *)tmp___16;
#line 648
  tmp___17 = gettext(" S - Status line shows ...");
#line 648
  shown_speed = (char const   *)tmp___17;
#line 649
  tmp___18 = gettext(" T - Multi-line untag ....");
#line 649
  multi_node = (char const   *)tmp___18;
#line 650
  tmp___19 = gettext("Change which setting?");
#line 650
  question = (char const   *)tmp___19;
#line 652
  defaults[0] = "~^M~AT S7=45 S0=0 L1 V1 X4 &c1 E1 Q0^M";
#line 652
  defaults[1] = "^M~ATZ^M~";
#line 658
  w = mc_wopen(2, 2, 77, 22, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 660
  dirflush = 0;
#line 661
  tmp___20 = gettext("Modem and dialing parameter setup");
#line 661
  mc_wtitle(w, 1, (char const   *)tmp___20);
#line 662
  mc_wprintf(w, "\n");
#line 663
  mc_wprintf(w, "%s %.48s\n", init_string, mpars[37].value);
#line 664
  mc_wprintf(w, "%s %.48s\n", reset_string, mpars[38].value);
#line 665
  mc_wprintf(w, "%s %.48s\n", dialing_prefix_1, mpars[39].value);
#line 666
  mc_wprintf(w, "%s %.48s\n", dialing_suffix_1, mpars[40].value);
#line 667
  mc_wprintf(w, "%s %.48s\n", dialing_prefix_2, mpars[41].value);
#line 668
  mc_wprintf(w, "%s %.48s\n", dialing_suffix_2, mpars[42].value);
#line 669
  mc_wprintf(w, "%s %.48s\n", dialing_prefix_3, mpars[43].value);
#line 670
  mc_wprintf(w, "%s %.48s\n", dialing_suffix_3, mpars[44].value);
#line 671
  mc_wprintf(w, "%s %.48s\n", connect_string, mpars[45].value);
#line 672
  mc_wprintf(w, "%s %-20.20s  %.20s\n", no_connect_strings, mpars[46].value, mpars[47].value);
#line 673
  tmp___21 = mbslen(no_connect_strings);
#line 673
  mc_wlocate(w, (int )(tmp___21 + 1UL), 11);
#line 674
  mc_wprintf(w, "%-20.20s  %.20s\n", mpars[48].value, mpars[49].value);
#line 675
  mc_wprintf(w, "%s %.48s\n", hangup_string, mpars[50].value);
#line 676
  mc_wprintf(w, "%s %.48s\n", dial_cancel_string, mpars[51].value);
#line 677
  mc_wprintf(w, "\n");
#line 678
  mc_wprintf(w, "%s %.3s\n", dial_time, mpars[52].value);
#line 679
  mc_wprintf(w, "%s %.3s\n", delay_before_redial, mpars[53].value);
#line 680
  mc_wprintf(w, "%s %.3s\n", number_of_tries, mpars[54].value);
#line 681
  mc_wprintf(w, "%s %.3s\n", dtr_drop_time, mpars[55].value);
#line 682
  mc_wlocate(w, 34, 15);
#line 683
  tmp___22 = gettext((char const   *)(mpars[56].value));
#line 683
  mc_wprintf(w, "%s %s\n", auto_bps_detect, tmp___22);
#line 684
  mc_wlocate(w, 34, 16);
#line 685
  tmp___23 = gettext((char const   *)(mpars[64].value));
#line 685
  mc_wprintf(w, "%s %s\n", modem_has_dcd_line, tmp___23);
#line 686
  mc_wlocate(w, 34, 17);
#line 687
  tmp___24 = sspd(mpars[57].value);
#line 687
  mc_wprintf(w, "%s %s\n", shown_speed, tmp___24);
#line 688
  mc_wlocate(w, 34, 18);
#line 689
  tmp___25 = gettext((char const   *)(mpars[86].value));
#line 689
  mc_wprintf(w, "%s %s\n", multi_node, tmp___25);
#line 691
  mc_wlocate(w, 1, 20);
#line 692
  mc_wprintf(w, "%s ", question);
#line 693
  x = (int )w->curx;
#line 693
  y = (int )w->cury;
#line 694
  tmp___26 = gettext("    Return or Esc to exit. Edit A+B to get defaults.");
#line 694
  mc_wprintf(w, (char const   *)tmp___26);
#line 695
  mc_wredraw(w, 1);
  }
  {
#line 697
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    mc_wlocate(w, x, y);
#line 699
    mc_wflush();
#line 700
    c___0 = rwxgetch();
#line 701
    ypos = 1;
#line 702
    maxl = 64;
#line 703
    string_size = 0;
    }
    {
#line 705
    if (c___0 == 77) {
#line 705
      goto case_77;
    }
#line 708
    if (c___0 == 78) {
#line 708
      goto case_78;
    }
#line 711
    if (c___0 == 79) {
#line 711
      goto case_79;
    }
#line 714
    if (c___0 == 80) {
#line 714
      goto case_80;
    }
#line 719
    if (c___0 == 75) {
#line 719
      goto case_75;
    }
#line 722
    if (c___0 == 76) {
#line 722
      goto case_76;
    }
#line 727
    if (c___0 == 65) {
#line 727
      goto case_65;
    }
#line 730
    if (c___0 == 66) {
#line 730
      goto case_66;
    }
#line 733
    if (c___0 == 67) {
#line 733
      goto case_67;
    }
#line 736
    if (c___0 == 68) {
#line 736
      goto case_68;
    }
#line 739
    if (c___0 == 69) {
#line 739
      goto case_69;
    }
#line 742
    if (c___0 == 70) {
#line 742
      goto case_70;
    }
#line 745
    if (c___0 == 71) {
#line 745
      goto case_71;
    }
#line 748
    if (c___0 == 72) {
#line 748
      goto case_72;
    }
#line 751
    if (c___0 == 73) {
#line 751
      goto case_73;
    }
#line 777
    if (c___0 == 74) {
#line 777
      goto case_74;
    }
#line 785
    if (c___0 == 81) {
#line 785
      goto case_81;
    }
#line 790
    if (c___0 == 82) {
#line 790
      goto case_82;
    }
#line 795
    if (c___0 == 83) {
#line 795
      goto case_83;
    }
#line 801
    if (c___0 == 84) {
#line 801
      goto case_84;
    }
#line 807
    if (c___0 == 10) {
#line 807
      goto case_10;
    }
#line 811
    goto switch_default;
    case_77: /* CIL Label */ 
#line 706
    if (string_size == 0) {
      {
#line 707
      tmp___27 = mbslen(dial_time);
#line 707
      string_size = (int )tmp___27;
      }
    }
    case_78: /* CIL Label */ 
#line 709
    if (string_size == 0) {
      {
#line 710
      tmp___28 = mbslen(delay_before_redial);
#line 710
      string_size = (int )tmp___28;
      }
    }
    case_79: /* CIL Label */ 
#line 712
    if (string_size == 0) {
      {
#line 713
      tmp___29 = mbslen(number_of_tries);
#line 713
      string_size = (int )tmp___29;
      }
    }
    case_80: /* CIL Label */ 
#line 715
    if (string_size == 0) {
      {
#line 716
      tmp___30 = mbslen(dtr_drop_time);
#line 716
      string_size = (int )tmp___30;
      }
    }
#line 717
    ypos ++;
#line 718
    maxl = 4;
    case_75: /* CIL Label */ 
#line 720
    if (string_size == 0) {
      {
#line 721
      tmp___31 = mbslen(hangup_string);
#line 721
      string_size = (int )tmp___31;
      }
    }
    case_76: /* CIL Label */ 
#line 723
    if (string_size == 0) {
      {
#line 724
      tmp___32 = mbslen(dial_cancel_string);
#line 724
      string_size = (int )tmp___32;
      }
    }
#line 725
    ypos -= 2;
#line 726
    c___0 += 3;
    case_65: /* CIL Label */ 
#line 728
    if (string_size == 0) {
      {
#line 729
      tmp___33 = mbslen(init_string);
#line 729
      string_size = (int )tmp___33;
      }
    }
    case_66: /* CIL Label */ 
#line 731
    if (string_size == 0) {
      {
#line 732
      tmp___34 = mbslen(reset_string);
#line 732
      string_size = (int )tmp___34;
      }
    }
    case_67: /* CIL Label */ 
#line 734
    if (string_size == 0) {
      {
#line 735
      tmp___35 = mbslen(dialing_prefix_1);
#line 735
      string_size = (int )tmp___35;
      }
    }
    case_68: /* CIL Label */ 
#line 737
    if (string_size == 0) {
      {
#line 738
      tmp___36 = mbslen(dialing_suffix_1);
#line 738
      string_size = (int )tmp___36;
      }
    }
    case_69: /* CIL Label */ 
#line 740
    if (string_size == 0) {
      {
#line 741
      tmp___37 = mbslen(dialing_prefix_2);
#line 741
      string_size = (int )tmp___37;
      }
    }
    case_70: /* CIL Label */ 
#line 743
    if (string_size == 0) {
      {
#line 744
      tmp___38 = mbslen(dialing_suffix_2);
#line 744
      string_size = (int )tmp___38;
      }
    }
    case_71: /* CIL Label */ 
#line 746
    if (string_size == 0) {
      {
#line 747
      tmp___39 = mbslen(dialing_prefix_3);
#line 747
      string_size = (int )tmp___39;
      }
    }
    case_72: /* CIL Label */ 
#line 749
    if (string_size == 0) {
      {
#line 750
      tmp___40 = mbslen(dialing_suffix_3);
#line 750
      string_size = (int )tmp___40;
      }
    }
    case_73: /* CIL Label */ 
#line 752
    if (string_size == 0) {
      {
#line 753
      tmp___41 = mbslen(connect_string);
#line 753
      string_size = (int )tmp___41;
      }
    }
#line 756
    loc = c___0 - 65;
#line 759
    str = mpars[37].value + (unsigned long )loc * sizeof(struct pars );
#line 765
    if (loc == 0) {
#line 765
      goto _L;
    } else
#line 765
    if (loc == 1) {
      _L: /* CIL Label */ 
#line 765
      if (! *str) {
        {
#line 767
        strncpy((char */* __restrict  */)str, (char const   */* __restrict  */)defaults[loc],
                (size_t )128);
#line 768
        *(str + 127) = (char)0;
#line 770
        mc_wlocate(w, string_size + 1, 1 + loc);
#line 771
        mc_wprintf(w, "%.48s\n", str);
        }
      }
    }
    {
#line 774
    pgets(w, string_size + 1, ypos + loc, str, maxl, (unsigned int )maxl, 0);
    }
#line 776
    goto switch_break;
    case_74: /* CIL Label */ 
    {
#line 778
    tmp___42 = mbslen(no_connect_strings);
#line 778
    string_size = (int )tmp___42;
#line 780
    pgets(w, string_size + 1, 10, mpars[46].value, 20, 64U, 0);
#line 781
    pgets(w, (string_size + 1) + 22, 10, mpars[47].value, 20, 64U, 0);
#line 782
    pgets(w, string_size + 1, 11, mpars[48].value, 20, 64U, 0);
#line 783
    pgets(w, (string_size + 1) + 22, 11, mpars[49].value, 20, 64U, 0);
    }
#line 784
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 786
    tmp___43 = yesno((int )mpars[56].value[0] == 78);
#line 786
    psets(mpars[56].value, tmp___43);
#line 787
    tmp___44 = mbslen(auto_bps_detect);
#line 787
    mc_wlocate(w, (int )(35UL + tmp___44), 15);
#line 788
    tmp___45 = gettext((char const   *)(mpars[56].value));
#line 788
    mc_wputs(w, (char const   *)tmp___45);
    }
#line 789
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 791
    tmp___46 = yesno((int )mpars[64].value[0] == 78);
#line 791
    psets(mpars[64].value, tmp___46);
#line 792
    tmp___47 = mbslen(modem_has_dcd_line);
#line 792
    mc_wlocate(w, (int )(35UL + tmp___47), 16);
#line 793
    tmp___48 = gettext((char const   *)(mpars[64].value));
#line 793
    mc_wputs(w, (char const   *)tmp___48);
    }
#line 794
    goto switch_break;
    case_83: /* CIL Label */ 
#line 796
    if ((int )mpars[57].value[0] == 100) {
#line 796
      tmp___49 = "l";
    } else {
#line 796
      tmp___49 = "d";
    }
    {
#line 796
    psets(mpars[57].value, tmp___49);
#line 797
    tmp___50 = mbslen(shown_speed);
#line 797
    mc_wlocate(w, (int )(35UL + tmp___50), 17);
#line 798
    tmp___51 = sspd(mpars[57].value);
#line 798
    mc_wputs(w, (char const   *)tmp___51);
#line 799
    show_status();
    }
#line 800
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 802
    tmp___52 = yesno((int )mpars[86].value[0] == 78);
#line 802
    psets(mpars[86].value, tmp___52);
#line 803
    tmp___53 = mbslen(multi_node);
#line 803
    mc_wlocate(w, (int )(35UL + tmp___53), 18);
#line 804
    tmp___54 = gettext((char const   *)(mpars[86].value));
#line 804
    mc_wputs(w, (char const   *)tmp___54);
    }
#line 805
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 808
    dirflush = 1;
#line 809
    mc_wclose(w, 1);
    }
#line 810
    return;
    switch_default: /* CIL Label */ 
#line 812
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 821 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void doscrkeyb(void) 
{ 
  WIN *w ;
  WIN *w1 ;
  int c___0 ;
  int once ;
  int clr ;
  int tmp_c ;
  char buf___6[16] ;
  int miny ;
  int maxy ;
  int old_stat ;
  FILE *fp ;
  char *command_key ;
  char *tmp ;
  char *backspace_key ;
  char *tmp___0 ;
  char *status_line ;
  char *tmp___1 ;
  char *alarm_sound ;
  char *tmp___2 ;
  char *foreground_color_menu ;
  char *tmp___3 ;
  char *background_color_menu ;
  char *tmp___4 ;
  char *foreground_color_term ;
  char *tmp___5 ;
  char *background_color_term ;
  char *tmp___6 ;
  char *foreground_color_stat ;
  char *tmp___7 ;
  char *background_color_stat ;
  char *tmp___8 ;
  char *history_buffer_size ;
  char *tmp___9 ;
  char *macros_file ;
  char *tmp___10 ;
  char *macros_enabled ;
  char *tmp___11 ;
  char *character_conversion ;
  char *tmp___12 ;
  char *add_linefeed ;
  char *tmp___13 ;
  char *local_echo_str ;
  char *tmp___14 ;
  char *line_wrap ;
  char *tmp___15 ;
  char *display_hex_str ;
  char *tmp___16 ;
  char *add_carriagereturn ;
  char *tmp___17 ;
  char *question ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  size_t tmp___43 ;
  char *tmp___44 ;
  size_t tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  char *tmp___48 ;
  char const   *tmp___49 ;
  size_t tmp___50 ;
  char *tmp___51 ;
  size_t tmp___52 ;
  char *tmp___53 ;
  size_t tmp___54 ;
  char *tmp___55 ;
  size_t tmp___56 ;
  char *tmp___57 ;
  size_t tmp___58 ;
  char *tmp___59 ;
  size_t tmp___60 ;
  char *tmp___61 ;
  size_t tmp___62 ;
  char *tmp___63 ;
  size_t tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  size_t tmp___67 ;
  size_t tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  int *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  int *tmp___74 ;
  char *tmp___75 ;
  char const   *tmp___76 ;
  size_t tmp___77 ;
  char *tmp___78 ;
  size_t tmp___79 ;
  char *tmp___80 ;
  char const   *tmp___81 ;
  size_t tmp___82 ;
  char *tmp___83 ;
  char const   *tmp___84 ;
  size_t tmp___85 ;
  char *tmp___86 ;
  char const   *tmp___87 ;
  size_t tmp___88 ;
  char *tmp___89 ;
  char const   *tmp___90 ;
  size_t tmp___91 ;
  char *tmp___92 ;
  int tmp___93 ;
  char const   *tmp___94 ;
  size_t tmp___95 ;
  char *tmp___96 ;

  {
  {
#line 825
  once = 0;
#line 826
  clr = 1;
#line 829
  miny = 2;
#line 829
  maxy = 22;
#line 830
  old_stat = (int )mpars[63].value[0];
#line 832
  tmp = gettext(" A - Command key is         :");
#line 832
  command_key = tmp;
#line 833
  tmp___0 = gettext(" B - Backspace key sends    :");
#line 833
  backspace_key = tmp___0;
#line 834
  tmp___1 = gettext(" C - Status line is         :");
#line 834
  status_line = tmp___1;
#line 835
  tmp___2 = gettext(" D - Alarm sound            :");
#line 835
  alarm_sound = tmp___2;
#line 836
  tmp___3 = gettext(" E - Foreground Color (menu):");
#line 836
  foreground_color_menu = tmp___3;
#line 837
  tmp___4 = gettext(" F - Background Color (menu):");
#line 837
  background_color_menu = tmp___4;
#line 838
  tmp___5 = gettext(" G - Foreground Color (term):");
#line 838
  foreground_color_term = tmp___5;
#line 839
  tmp___6 = gettext(" H - Background Color (term):");
#line 839
  background_color_term = tmp___6;
#line 840
  tmp___7 = gettext(" I - Foreground Color (stat):");
#line 840
  foreground_color_stat = tmp___7;
#line 841
  tmp___8 = gettext(" J - Background Color (stat):");
#line 841
  background_color_stat = tmp___8;
#line 842
  tmp___9 = gettext(" K - History Buffer Size    :");
#line 842
  history_buffer_size = tmp___9;
#line 843
  tmp___10 = gettext(" L - Macros file            :");
#line 843
  macros_file = tmp___10;
#line 844
  tmp___11 = gettext(" N - Macros enabled         :");
#line 844
  macros_enabled = tmp___11;
#line 845
  tmp___12 = gettext(" O - Character conversion   :");
#line 845
  character_conversion = tmp___12;
#line 846
  tmp___13 = gettext(" P - Add linefeed           :");
#line 846
  add_linefeed = tmp___13;
#line 847
  tmp___14 = gettext(" Q - Local echo             :");
#line 847
  local_echo_str = tmp___14;
#line 848
  tmp___15 = gettext(" R - Line Wrap              :");
#line 848
  line_wrap = tmp___15;
#line 849
  tmp___16 = gettext(" S - Hex Display            :");
#line 849
  display_hex_str = tmp___16;
#line 850
  tmp___17 = gettext(" T - Add carriage return    :");
#line 850
  add_carriagereturn = tmp___17;
#line 851
  tmp___18 = gettext("Change which setting?  (Esc to exit)");
#line 851
  question = tmp___18;
#line 853
  w = mc_wopen(15, miny, 69, maxy, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 855
  tmp___19 = gettext("Screen and keyboard");
#line 855
  mc_wtitle(w, 1, (char const   *)tmp___19);
#line 857
  mc_wprintf(w, "%s %s\n", command_key, mpars[61].value);
#line 858
  mc_wprintf(w, "%s %s\n", backspace_key, mpars[62].value);
#line 859
  tmp___20 = gettext((char const   *)(mpars[63].value));
#line 859
  mc_wprintf(w, "%s %s\n", status_line, tmp___20);
#line 860
  tmp___21 = gettext((char const   *)(mpars[77].value));
#line 860
  mc_wprintf(w, "%s %s\n", alarm_sound, tmp___21);
#line 862
  tmp___22 = gettext(J_col[mfcolor]);
#line 862
  mc_wprintf(w, "%s %s\n", foreground_color_menu, tmp___22);
#line 863
  tmp___23 = gettext(J_col[mbcolor]);
#line 863
  mc_wprintf(w, "%s %s\n", background_color_menu, tmp___23);
#line 864
  tmp___24 = gettext(J_col[tfcolor]);
#line 864
  mc_wprintf(w, "%s %s\n", foreground_color_term, tmp___24);
#line 865
  tmp___25 = gettext(J_col[tbcolor]);
#line 865
  mc_wprintf(w, "%s %s\n", background_color_term, tmp___25);
#line 866
  tmp___26 = gettext(J_col[sfcolor]);
#line 866
  mc_wprintf(w, "%s %s\n", foreground_color_stat, tmp___26);
#line 867
  tmp___27 = gettext(J_col[sbcolor]);
#line 867
  mc_wprintf(w, "%s %s\n", background_color_stat, tmp___27);
#line 870
  mc_wprintf(w, "%s %s\n", history_buffer_size, mpars[78].value);
#line 873
  mc_wprintf(w, "%s %s\n", macros_file, mpars[74].value);
#line 874
  tmp___28 = gettext(" M - Edit Macros\n");
#line 874
  mc_wprintf(w, (char const   *)tmp___28);
#line 875
  tmp___29 = gettext((char const   *)(mpars[76].value));
#line 875
  mc_wprintf(w, "%s %s\n", macros_enabled, tmp___29);
#line 876
  mc_wprintf(w, "%s %s\n", character_conversion, mpars[79].value);
#line 878
  tmp___30 = gettext((char const   *)(mpars[88].value));
#line 878
  mc_wprintf(w, "%s %s\n", add_linefeed, tmp___30);
#line 879
  tmp___31 = gettext((char const   *)(mpars[87].value));
#line 879
  mc_wprintf(w, "%s %s\n", local_echo_str, tmp___31);
#line 880
  tmp___32 = gettext((char const   *)(mpars[89].value));
#line 880
  mc_wprintf(w, "%s %s\n", line_wrap, tmp___32);
#line 881
  tmp___33 = gettext((char const   *)(mpars[90].value));
#line 881
  mc_wprintf(w, "%s %s\n", display_hex_str, tmp___33);
#line 882
  tmp___34 = gettext((char const   *)(mpars[91].value));
#line 882
  mc_wprintf(w, "%s %s\n", add_carriagereturn, tmp___34);
#line 884
  mc_wredraw(w, 1);
  }
  {
#line 886
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if (clr) {
      {
#line 888
      mc_wlocate(w, 2, maxy - miny);
#line 889
      mc_wprintf(w, "%s ", question);
#line 890
      mc_wclreol(w);
#line 891
      clr = 0;
      }
    } else {
      {
#line 893
      tmp___35 = mbslen((char const   *)question);
#line 893
      mc_wlocate(w, (int )(tmp___35 + 3UL), maxy - miny);
      }
    }
#line 895
    if (once) {
#line 896
      c___0 = once;
#line 897
      once = 0;
    } else {
      {
#line 899
      c___0 = rwxgetch();
      }
    }
    {
#line 907
    if (c___0 == 10) {
#line 907
      goto case_10;
    }
#line 951
    if (c___0 == 65) {
#line 951
      goto case_65;
    }
#line 988
    if (c___0 == 66) {
#line 988
      goto case_66;
    }
#line 997
    if (c___0 == 67) {
#line 997
      goto case_67;
    }
#line 1010
    if (c___0 == 68) {
#line 1010
      goto case_68;
    }
#line 1015
    if (c___0 == 69) {
#line 1015
      goto case_69___0;
    }
#line 1024
    if (c___0 == 70) {
#line 1024
      goto case_70;
    }
#line 1033
    if (c___0 == 71) {
#line 1033
      goto case_71;
    }
#line 1044
    if (c___0 == 72) {
#line 1044
      goto case_72;
    }
#line 1055
    if (c___0 == 73) {
#line 1055
      goto case_73;
    }
#line 1074
    if (c___0 == 74) {
#line 1074
      goto case_74;
    }
#line 1093
    if (c___0 == 75) {
#line 1093
      goto case_75;
    }
#line 1109
    if (c___0 == 76) {
#line 1109
      goto case_76;
    }
#line 1133
    if (c___0 == 77) {
#line 1133
      goto case_77;
    }
#line 1136
    if (c___0 == 78) {
#line 1136
      goto case_78;
    }
#line 1141
    if (c___0 == 79) {
#line 1141
      goto case_79;
    }
#line 1146
    if (c___0 == 80) {
#line 1146
      goto case_80;
    }
#line 1151
    if (c___0 == 81) {
#line 1151
      goto case_81;
    }
#line 1156
    if (c___0 == 82) {
#line 1156
      goto case_82;
    }
#line 1161
    if (c___0 == 83) {
#line 1161
      goto case_83;
    }
#line 1167
    if (c___0 == 84) {
#line 1167
      goto case_84;
    }
#line 906
    goto switch_break;
    case_10: /* CIL Label */ 
#line 910
    if (mfcolor == mbcolor) {
      {
#line 911
      tmp_c = mfcolor;
#line 912
      mfcolor = 7;
#line 913
      mbcolor = 0;
#line 914
      tmp___36 = gettext("Menu foreground == background color, change!");
#line 914
      werror((char const   *)tmp___36);
#line 915
      mfcolor = tmp_c;
#line 916
      mbcolor = tmp_c;
      }
#line 917
      goto switch_break;
    }
#line 919
    if (tfcolor == tbcolor) {
      {
#line 920
      tmp_c = mfcolor;
#line 921
      mfcolor = 7;
#line 922
      mbcolor = 0;
#line 923
      tmp___37 = gettext("Terminal foreground == background color, change!");
#line 923
      werror((char const   *)tmp___37);
#line 924
      mfcolor = tmp_c;
#line 925
      mbcolor = tmp_c;
      }
#line 926
      goto switch_break;
    }
    {
#line 933
    tmp___40 = atoi((char const   *)(mpars[78].value));
    }
#line 933
    if (tmp___40 != num_hist_lines) {
      {
#line 934
      w1 = mc_wopen(14, 9, 70, 15, 1, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 935
      tmp___38 = gettext("History Buffer Size");
#line 935
      mc_wtitle(w1, 1, (char const   *)tmp___38);
#line 936
      tmp___39 = gettext("\n You have changed the history buffer size.\n You will need to save the configuration file and\n restart minicom for the change to take effect.\n\n Hit a key to Continue... ");
#line 936
      mc_wputs(w1, (char const   *)tmp___39);
#line 941
      mc_wredraw(w1, 1);
#line 942
      c___0 = wxgetch();
#line 943
      mc_wclose(w1, 1);
      }
    }
    {
#line 946
    mc_wclose(w, 1);
    }
#line 948
    if ((int )mpars[63].value[0] != old_stat) {
      {
#line 949
      init_emul((int )terminal, 0);
      }
    }
#line 950
    return;
    case_65: /* CIL Label */ 
    {
#line 952
    w1 = mc_wopen(11, 8, 73, 17, 1, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 953
    tmp___41 = gettext("Program new command key");
#line 953
    mc_wtitle(w1, 1, (char const   *)tmp___41);
#line 954
    tmp___42 = gettext("\n Press the new command key. If you want to use\n the META or ALT key enter:\n\n  o SPACE if your meta key sets the 8th bit high\n  o ESC   if your meta key sends the ESCAPE prefix (standard)\n\n\n Press new command key: ");
#line 954
    mc_wputs(w1, (char const   *)tmp___42);
#line 960
    mc_wredraw(w1, 1);
#line 961
    c___0 = wxgetch();
#line 962
    mc_wclose(w1, 1);
    }
#line 963
    if (c___0 == 32) {
      {
#line 964
      strcpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"Meta-8th bit ");
      }
    } else
#line 965
    if (c___0 == 27) {
      {
#line 966
      strcpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"Escape (Meta)");
      }
    } else {
      {
#line 968
      sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"^%c           ",
              ((c___0 & 31) + 65) - 1);
      }
    }
    {
#line 969
    psets(mpars[61].value, (char const   *)(buf___6));
#line 970
    tmp___43 = mbslen((char const   *)command_key);
#line 970
    mc_wlocate(w, (int )(tmp___43 + 1UL), 0);
#line 971
    tmp___44 = gettext((char const   *)(buf___6));
#line 971
    mc_wputs(w, (char const   *)tmp___44);
#line 972
    clr = 1;
#line 973
    alt_override = 0;
    }
    {
#line 975
    if ((int )mpars[61].value[0] == 94) {
#line 975
      goto case_94;
    }
#line 978
    if ((int )mpars[61].value[0] == 69) {
#line 978
      goto case_69;
    }
#line 981
    goto switch_default;
    case_94: /* CIL Label */ 
#line 976
    c___0 = (int )mpars[61].value[1] & 31;
#line 977
    goto switch_break___0;
    case_69: /* CIL Label */ 
#line 979
    c___0 = 27;
#line 980
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 982
    c___0 = 128;
#line 983
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 985
    keyboard(11, c___0);
#line 986
    show_status();
    }
#line 987
    goto switch_break;
    case_66: /* CIL Label */ 
#line 989
    if ((int )mpars[62].value[0] == 68) {
      {
#line 990
      psets(mpars[62].value, "BS");
      }
    } else {
      {
#line 992
      psets(mpars[62].value, "DEL");
      }
    }
    {
#line 993
    tmp___45 = mbslen((char const   *)backspace_key);
#line 993
    mc_wlocate(w, (int )(tmp___45 + 1UL), 1);
#line 994
    mc_wprintf(w, "%s ", mpars[62].value);
    }
#line 995
    if ((int )mpars[62].value[0] == 66) {
#line 995
      tmp___46 = 8;
    } else {
#line 995
      tmp___46 = 127;
    }
    {
#line 995
    keyboard(12, tmp___46);
    }
#line 996
    goto switch_break;
    case_67: /* CIL Label */ 
#line 998
    if ((int )mpars[63].value[0] == 101) {
      {
#line 999
      psets(mpars[63].value, "disabled");
#line 1000
      tempst = 1;
      }
    } else {
      {
#line 1002
      psets(mpars[63].value, "enabled");
      }
#line 1004
      if (LINES > 24) {
#line 1005
        tempst = 0;
      }
    }
    {
#line 1007
    tmp___47 = mbslen((char const   *)status_line);
#line 1007
    mc_wlocate(w, (int )(tmp___47 + 1UL), 2);
#line 1008
    tmp___48 = gettext((char const   *)(mpars[63].value));
#line 1008
    mc_wprintf(w, "%s ", tmp___48);
    }
#line 1009
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 1011
    tmp___49 = yesno((int )mpars[77].value[0] == 78);
#line 1011
    psets(mpars[77].value, tmp___49);
#line 1012
    tmp___50 = mbslen((char const   *)alarm_sound);
#line 1012
    mc_wlocate(w, (int )(tmp___50 + 1UL), 3);
#line 1013
    tmp___51 = gettext((char const   *)(mpars[77].value));
#line 1013
    mc_wprintf(w, "%s", tmp___51);
    }
#line 1014
    goto switch_break;
    case_69___0: /* CIL Label */ 
#line 1016
    if (mfcolor == 7) {
#line 1017
      mfcolor = 0;
    } else {
#line 1019
      mfcolor ++;
    }
    {
#line 1020
    psets(mpars[68].value, J_col[mfcolor]);
#line 1021
    tmp___52 = mbslen((char const   *)foreground_color_menu);
#line 1021
    mc_wlocate(w, (int )(tmp___52 + 1UL), 4);
#line 1022
    tmp___53 = gettext(J_col[mfcolor]);
#line 1022
    mc_wprintf(w, "%s   ", tmp___53);
    }
#line 1023
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1025
    if (mbcolor == 7) {
#line 1026
      mbcolor = 0;
    } else {
#line 1028
      mbcolor ++;
    }
    {
#line 1029
    psets(mpars[69].value, J_col[mbcolor]);
#line 1030
    tmp___54 = mbslen((char const   *)background_color_menu);
#line 1030
    mc_wlocate(w, (int )(tmp___54 + 1UL), 5);
#line 1031
    tmp___55 = gettext(J_col[mbcolor]);
#line 1031
    mc_wprintf(w, "%s   ", tmp___55);
    }
#line 1032
    goto switch_break;
    case_71: /* CIL Label */ 
#line 1034
    if (tfcolor == 7) {
#line 1035
      tfcolor = 0;
    } else {
#line 1037
      tfcolor ++;
    }
    {
#line 1038
    psets(mpars[70].value, J_col[tfcolor]);
#line 1039
    tmp___56 = mbslen((char const   *)foreground_color_term);
#line 1039
    mc_wlocate(w, (int )(tmp___56 + 1UL), 6);
#line 1040
    tmp___57 = gettext(J_col[tfcolor]);
#line 1040
    mc_wprintf(w, "%s   ", tmp___57);
    }
#line 1041
    if (us) {
      {
#line 1042
      vt_pinit(us, tfcolor, tbcolor);
      }
    }
#line 1043
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1045
    if (tbcolor == 7) {
#line 1046
      tbcolor = 0;
    } else {
#line 1048
      tbcolor ++;
    }
    {
#line 1049
    psets(mpars[71].value, J_col[tbcolor]);
#line 1050
    tmp___58 = mbslen((char const   *)background_color_term);
#line 1050
    mc_wlocate(w, (int )(tmp___58 + 1UL), 7);
#line 1051
    tmp___59 = gettext(J_col[tbcolor]);
#line 1051
    mc_wprintf(w, "%s   ", tmp___59);
    }
#line 1052
    if (us) {
      {
#line 1053
      vt_pinit(us, tfcolor, tbcolor);
      }
    }
#line 1054
    goto switch_break;
    case_73: /* CIL Label */ 
#line 1056
    if (sfcolor == 7) {
#line 1057
      sfcolor = 0;
    } else {
#line 1059
      sfcolor ++;
    }
#line 1064
    if (st) {
      {
#line 1065
      mc_wclose(st, 0);
#line 1066
      st = mc_wopen(0, LINES - 1, COLS - 1, LINES - 1, 0, 0, sfcolor, sbcolor, 1,
                    0, 1);
#line 1068
      show_status();
      }
    }
    {
#line 1070
    psets(mpars[72].value, J_col[sfcolor]);
#line 1071
    tmp___60 = mbslen((char const   *)foreground_color_stat);
#line 1071
    mc_wlocate(w, (int )(tmp___60 + 1UL), 8);
#line 1072
    tmp___61 = gettext(J_col[sfcolor]);
#line 1072
    mc_wprintf(w, "%s   ", tmp___61);
    }
#line 1073
    goto switch_break;
    case_74: /* CIL Label */ 
#line 1075
    if (sbcolor == 7) {
#line 1076
      sbcolor = 0;
    } else {
#line 1078
      sbcolor ++;
    }
#line 1083
    if (st) {
      {
#line 1084
      mc_wclose(st, 0);
#line 1085
      st = mc_wopen(0, LINES - 1, COLS - 1, LINES - 1, 0, 0, sfcolor, sbcolor, 1,
                    0, 0);
#line 1087
      show_status();
      }
    }
    {
#line 1089
    psets(mpars[73].value, J_col[sbcolor]);
#line 1090
    tmp___62 = mbslen((char const   *)background_color_stat);
#line 1090
    mc_wlocate(w, (int )(tmp___62 + 1UL), 9);
#line 1091
    tmp___63 = gettext(J_col[sbcolor]);
#line 1091
    mc_wprintf(w, "%s   ", tmp___63);
    }
#line 1092
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1094
    tmp___64 = mbslen((char const   *)history_buffer_size);
#line 1094
    pgets(w, (int )(tmp___64 + 1UL), 10, mpars[78].value, 6, 6U, 0);
#line 1101
    tmp___66 = atoi((char const   *)(mpars[78].value));
    }
#line 1101
    if (tmp___66 <= 0) {
      {
#line 1102
      strcpy((char */* __restrict  */)(mpars[78].value), (char const   */* __restrict  */)"0");
      }
    } else {
      {
#line 1103
      tmp___65 = atoi((char const   *)(mpars[78].value));
      }
#line 1103
      if (tmp___65 >= 5000) {
        {
#line 1104
        strcpy((char */* __restrict  */)(mpars[78].value), (char const   */* __restrict  */)"5000");
        }
      }
    }
    {
#line 1106
    tmp___67 = mbslen((char const   *)history_buffer_size);
#line 1106
    mc_wlocate(w, (int )(tmp___67 + 1UL), 10);
#line 1107
    mc_wprintf(w, "%s     ", mpars[78].value);
    }
#line 1108
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1110
    tmp___68 = mbslen((char const   *)macros_file);
#line 1110
    pgets(w, (int )(tmp___68 + 1UL), 11, mpars[74].value, 64, 64U, 1);
#line 1113
    tmp___69 = pfix_home(mpars[74].value);
#line 1113
    fp = fopen((char const   */* __restrict  */)tmp___69, (char const   */* __restrict  */)"r+");
    }
#line 1114
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
      {
#line 1115
      tmp___71 = __errno_location();
      }
#line 1115
      if (*tmp___71 == 1) {
        {
#line 1117
        tmp___70 = gettext("ERROR: you do not have permission to create a file there!");
#line 1117
        werror((char const   *)tmp___70);
#line 1118
        once = 'J';
        }
#line 1119
        goto while_continue;
      }
      {
#line 1121
      tmp___74 = __errno_location();
      }
#line 1121
      if (*tmp___74 != 2) {
        {
#line 1123
        tmp___72 = pfix_home(mpars[74].value);
#line 1123
        tmp___73 = gettext("ERROR: cannot open macro file %s");
#line 1123
        werror((char const   *)tmp___73, tmp___72);
        }
      }
#line 1126
      goto while_continue;
    }
    {
#line 1129
    tmp___75 = gettext("Reading macros");
#line 1129
    werror((char const   *)tmp___75);
#line 1130
    readmacs(fp, 0);
#line 1131
    fclose(fp);
    }
#line 1132
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 1134
    domacros();
    }
#line 1135
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 1137
    tmp___76 = yesno((int )mpars[76].value[0] == 78);
#line 1137
    psets(mpars[76].value, tmp___76);
#line 1138
    tmp___77 = mbslen((char const   *)macros_enabled);
#line 1138
    mc_wlocate(w, (int )(tmp___77 + 1UL), 13);
#line 1139
    tmp___78 = gettext((char const   *)(mpars[76].value));
#line 1139
    mc_wprintf(w, "%s", tmp___78);
    }
#line 1140
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 1142
    doconv();
#line 1143
    tmp___79 = mbslen((char const   *)character_conversion);
#line 1143
    mc_wlocate(w, (int )(tmp___79 + 1UL), 14);
#line 1144
    tmp___80 = gettext((char const   *)(mpars[79].value));
#line 1144
    mc_wprintf(w, "%-16.16s", tmp___80);
    }
#line 1145
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 1147
    tmp___81 = yesno((int )mpars[88].value[0] == 78);
#line 1147
    psets(mpars[88].value, tmp___81);
#line 1148
    tmp___82 = mbslen((char const   *)add_linefeed);
#line 1148
    mc_wlocate(w, (int )(tmp___82 + 1UL), 15);
#line 1149
    tmp___83 = gettext((char const   *)(mpars[88].value));
#line 1149
    mc_wprintf(w, "%s", tmp___83);
    }
#line 1150
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 1152
    tmp___84 = yesno((int )mpars[87].value[0] == 78);
#line 1152
    psets(mpars[87].value, tmp___84);
#line 1153
    tmp___85 = mbslen((char const   *)local_echo_str);
#line 1153
    mc_wlocate(w, (int )(tmp___85 + 1UL), 16);
#line 1154
    tmp___86 = gettext((char const   *)(mpars[87].value));
#line 1154
    mc_wprintf(w, "%s", tmp___86);
    }
#line 1155
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 1157
    tmp___87 = yesno((int )mpars[89].value[0] == 78);
#line 1157
    psets(mpars[89].value, tmp___87);
#line 1158
    tmp___88 = mbslen((char const   *)line_wrap);
#line 1158
    mc_wlocate(w, (int )(tmp___88 + 1UL), 17);
#line 1159
    tmp___89 = gettext((char const   *)(mpars[89].value));
#line 1159
    mc_wprintf(w, "%s", tmp___89);
    }
#line 1160
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 1162
    tmp___90 = yesno((int )mpars[90].value[0] == 78);
#line 1162
    psets(mpars[90].value, tmp___90);
#line 1163
    tmp___91 = mbslen((char const   *)display_hex_str);
#line 1163
    mc_wlocate(w, (int )(tmp___91 + 1UL), 18);
#line 1164
    tmp___92 = gettext((char const   *)(mpars[90].value));
#line 1164
    mc_wprintf(w, "%s", tmp___92);
#line 1165
    tmp___93 = strcasecmp((char const   *)(mpars[90].value), "yes");
#line 1165
    display_hex = tmp___93 == 0;
    }
#line 1166
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1168
    tmp___94 = yesno((int )mpars[91].value[0] == 78);
#line 1168
    psets(mpars[91].value, tmp___94);
#line 1169
    tmp___95 = mbslen((char const   *)add_carriagereturn);
#line 1169
    mc_wlocate(w, (int )(tmp___95 + 1UL), 19);
#line 1170
    tmp___96 = gettext((char const   *)(mpars[91].value));
#line 1170
    mc_wprintf(w, "%s", tmp___96);
    }
#line 1171
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1181 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int dotermmenu(void) 
{ 
  WIN *w ;
  int c___0 ;
  int new_term ;
  int old_stat ;
  char buf___6[8] ;
  char *terminal_emulation ;
  char *tmp ;
  char *backspace_key_sends ;
  char *tmp___0 ;
  char *status_line ;
  char *tmp___1 ;
  char *msg_nl_delay ;
  char *tmp___2 ;
  char *msg_answerback ;
  char *tmp___3 ;
  char *msg_ch_delay ;
  char *tmp___4 ;
  char *question ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;

  {
  {
#line 1185
  new_term = -1;
#line 1186
  old_stat = (int )mpars[63].value[0];
#line 1188
  tmp = gettext(" A -      Terminal emulation :");
#line 1188
  terminal_emulation = tmp;
#line 1189
  tmp___0 = gettext(" B -     Backspace key sends :");
#line 1189
  backspace_key_sends = tmp___0;
#line 1190
  tmp___1 = gettext(" C -          Status line is :");
#line 1190
  status_line = tmp___1;
#line 1191
  tmp___2 = gettext(" D -   Newline tx delay (ms) :");
#line 1191
  msg_nl_delay = tmp___2;
#line 1192
  tmp___3 = gettext(" E -          ENQ answerback :");
#line 1192
  msg_answerback = tmp___3;
#line 1193
  tmp___4 = gettext(" F - Character tx delay (ms) :");
#line 1193
  msg_ch_delay = tmp___4;
#line 1194
  tmp___5 = gettext("Change which setting?");
#line 1194
  question = tmp___5;
#line 1196
  w = mc_wopen(15, 7, 64, 15, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1197
  tmp___6 = gettext("Terminal settings");
#line 1197
  mc_wtitle(w, 1, (char const   *)tmp___6);
#line 1198
  mc_wprintf(w, "\n");
  }
#line 1199
  if ((int )terminal == 1) {
#line 1199
    tmp___7 = "VT102";
  } else {
#line 1199
    tmp___7 = "ANSI";
  }
  {
#line 1199
  mc_wprintf(w, "%s %s\n", terminal_emulation, tmp___7);
#line 1200
  mc_wprintf(w, "%s %s\n", backspace_key_sends, mpars[62].value);
#line 1201
  tmp___8 = gettext((char const   *)(mpars[63].value));
#line 1201
  mc_wprintf(w, "%s %s\n", status_line, tmp___8);
#line 1202
  mc_wprintf(w, "%s %d\n", msg_nl_delay, vt_nl_delay);
#line 1203
  mc_wprintf(w, "%s %s\n", msg_answerback, mpars[92].value);
#line 1204
  mc_wprintf(w, "%s %d\n", msg_ch_delay, vt_ch_delay);
#line 1205
  mc_wlocate(w, 4, 7);
#line 1206
  mc_wputs(w, (char const   *)question);
#line 1208
  mc_wredraw(w, 1);
  }
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1211
    tmp___9 = mbslen((char const   *)question);
#line 1211
    mc_wlocate(w, (int )(tmp___9 + 5UL), 7);
#line 1212
    c___0 = rwxgetch();
    }
    {
#line 1214
    if (c___0 == 10) {
#line 1214
      goto case_10;
    }
#line 1220
    if (c___0 == 65) {
#line 1220
      goto case_65;
    }
#line 1236
    if (c___0 == 66) {
#line 1236
      goto case_66;
    }
#line 1245
    if (c___0 == 67) {
#line 1245
      goto case_67;
    }
#line 1258
    if (c___0 == 68) {
#line 1258
      goto case_68;
    }
#line 1266
    if (c___0 == 69) {
#line 1266
      goto case_69;
    }
#line 1269
    if (c___0 == 70) {
#line 1269
      goto case_70;
    }
#line 1277
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1215
    mc_wclose(w, 1);
    }
#line 1217
    if ((int )mpars[63].value[0] != old_stat) {
#line 1217
      if (new_term < 0) {
        {
#line 1218
        init_emul((int )terminal, 0);
        }
      }
    }
#line 1219
    return (new_term);
    case_65: /* CIL Label */ 
#line 1221
    if (new_term < 0) {
#line 1222
      new_term = (int )terminal;
    }
#line 1223
    if (new_term == 1) {
      {
#line 1224
      new_term = 3;
#line 1225
      psets(mpars[62].value, "BS");
      }
    } else {
      {
#line 1227
      new_term = 1;
#line 1228
      psets(mpars[62].value, "DEL");
      }
    }
    {
#line 1230
    tmp___10 = mbslen((char const   *)terminal_emulation);
#line 1230
    mc_wlocate(w, (int )(tmp___10 + 1UL), 1);
    }
#line 1231
    if (new_term == 1) {
#line 1231
      tmp___11 = "VT102";
    } else {
#line 1231
      tmp___11 = "ANSI";
    }
    {
#line 1231
    mc_wprintf(w, "%s ", tmp___11);
#line 1232
    tmp___12 = mbslen((char const   *)backspace_key_sends);
#line 1232
    mc_wlocate(w, (int )(tmp___12 + 1UL), 2);
#line 1233
    mc_wprintf(w, "%s ", mpars[62].value);
    }
#line 1234
    if ((int )mpars[62].value[0] == 66) {
#line 1234
      tmp___13 = 8;
    } else {
#line 1234
      tmp___13 = 127;
    }
    {
#line 1234
    keyboard(12, tmp___13);
    }
#line 1235
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1237
    if ((int )mpars[62].value[0] == 68) {
      {
#line 1238
      psets(mpars[62].value, "BS");
      }
    } else {
      {
#line 1240
      psets(mpars[62].value, "DEL");
      }
    }
    {
#line 1241
    tmp___14 = mbslen((char const   *)backspace_key_sends);
#line 1241
    mc_wlocate(w, (int )(tmp___14 + 1UL), 2);
#line 1242
    mc_wprintf(w, "%s ", mpars[62].value);
    }
#line 1243
    if ((int )mpars[62].value[0] == 66) {
#line 1243
      tmp___15 = 8;
    } else {
#line 1243
      tmp___15 = 127;
    }
    {
#line 1243
    keyboard(12, tmp___15);
    }
#line 1244
    goto switch_break;
    case_67: /* CIL Label */ 
#line 1246
    if ((int )mpars[63].value[0] == 101) {
      {
#line 1247
      psets(mpars[63].value, "disabled");
#line 1248
      tempst = 1;
      }
    } else {
      {
#line 1250
      psets(mpars[63].value, "enabled");
      }
#line 1252
      if (LINES > 24) {
#line 1253
        tempst = 0;
      } else
#line 1252
      if (use_status) {
#line 1253
        tempst = 0;
      }
    }
    {
#line 1255
    tmp___16 = mbslen((char const   *)status_line);
#line 1255
    mc_wlocate(w, (int )(tmp___16 + 1UL), 3);
#line 1256
    tmp___17 = gettext((char const   *)(mpars[63].value));
#line 1256
    mc_wprintf(w, "%s ", tmp___17);
    }
#line 1257
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 1259
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
            vt_nl_delay);
#line 1260
    tmp___18 = mbslen((char const   *)msg_nl_delay);
#line 1260
    mc_wlocate(w, (int )(tmp___18 + 1UL), 4);
#line 1261
    mc_wgets(w, buf___6, 5, 5);
#line 1262
    vt_nl_delay = atoi((char const   *)(buf___6));
#line 1263
    tmp___19 = mbslen((char const   *)msg_nl_delay);
#line 1263
    mc_wlocate(w, (int )(tmp___19 + 1UL), 4);
#line 1264
    mc_wprintf(w, "%-4d", vt_nl_delay);
    }
#line 1265
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 1267
    tmp___20 = strlen((char const   *)msg_answerback);
#line 1267
    pgets(w, (int )(tmp___20 + 1UL), 5, mpars[92].value, 50, 50U, 0);
    }
#line 1268
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1270
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
            vt_ch_delay);
#line 1271
    tmp___21 = mbslen((char const   *)msg_ch_delay);
#line 1271
    mc_wlocate(w, (int )(tmp___21 + 1UL), 6);
#line 1272
    mc_wgets(w, buf___6, 5, 5);
#line 1273
    vt_ch_delay = atoi((char const   *)(buf___6));
#line 1274
    tmp___22 = mbslen((char const   *)msg_ch_delay);
#line 1274
    mc_wlocate(w, (int )(tmp___22 + 1UL), 6);
#line 1275
    mc_wprintf(w, "%-4d", vt_ch_delay);
    }
#line 1276
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1278
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1287 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void vdodflsave(void) 
{ 


  {
  {
#line 1289
  dodflsave();
  }
#line 1290
  return;
}
}
#line 1295 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int dodflsave(void) 
{ 
  FILE *fp ;
  char *fname ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1298
  if (dosetup) {
#line 1298
    tmp = parfile;
  } else {
#line 1298
    tmp = pparfile;
  }
  {
#line 1298
  fname = tmp;
#line 1300
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 1300
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 1301
    tmp___0 = gettext("Cannot write to %s");
#line 1301
    werror((char const   *)tmp___0, fname);
    }
#line 1302
    return (-1);
  }
  {
#line 1304
  writepars(fp, dosetup);
#line 1305
  fclose(fp);
  }
#line 1306
  if (dosetup) {
    {
#line 1307
    chmod((char const   *)fname, (mode_t )420);
    }
  }
  {
#line 1308
  tmp___1 = gettext("Configuration saved");
#line 1308
  werror((char const   *)tmp___1);
#line 1310
  tmp___4 = domacsave();
  }
#line 1310
  if (tmp___4 < 0) {
#line 1310
    tmp___3 = -1;
  } else {
#line 1310
    tmp___3 = 0;
  }
#line 1310
  return (tmp___3);
}
}
#line 1316 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int domacsave(void) 
{ 
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1321
  tmp___5 = strcmp((char const   *)(mpars[75].value), "CHANGED");
  }
#line 1321
  if (! tmp___5) {
    {
#line 1322
    tmp___4 = strlen((char const   *)(mpars[74].value));
    }
#line 1322
    if (tmp___4 == 0UL) {
      {
#line 1323
      tmp = gettext("ERROR: Macros have changed but no filename is set!");
#line 1323
      werror((char const   *)tmp);
      }
#line 1324
      return (-1);
    } else {
      {
#line 1326
      tmp___2 = pfix_home(mpars[74].value);
#line 1326
      fp = fopen((char const   */* __restrict  */)tmp___2, (char const   */* __restrict  */)"w");
      }
#line 1326
      if ((unsigned long )fp == (unsigned long )((FILE *)((void *)0))) {
        {
#line 1327
        tmp___0 = pfix_home(mpars[74].value);
#line 1327
        tmp___1 = gettext("Cannot write macros file %s");
#line 1327
        werror((char const   *)tmp___1, tmp___0);
        }
#line 1329
        return (-1);
      }
      {
#line 1331
      writemacs(fp);
#line 1332
      fclose(fp);
#line 1333
      tmp___3 = gettext("Macros saved");
#line 1333
      werror((char const   *)tmp___3);
#line 1334
      strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"SAVED");
      }
#line 1335
      return (0);
    }
  }
#line 1338
  return (0);
}
}
#line 1344 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void donamsave(void) 
{ 
  char ifile[128] ;
  char *s___0 ;
  char *tmp ;

  {
  {
#line 1349
  ifile[0] = (char)0;
#line 1350
  tmp = gettext("Give name to save this configuration?");
#line 1350
  s___0 = input(tmp, ifile);
  }
#line 1351
  if ((unsigned long )s___0 != (unsigned long )((char *)0)) {
#line 1351
    if ((int )*s___0 != 0) {
      {
#line 1352
      snprintf((char */* __restrict  */)(parfile), sizeof(parfile), (char const   */* __restrict  */)"%s/minirc.%s",
               "/usr/local/etc", s___0);
#line 1353
      dodflsave();
      }
    }
  }
#line 1355
  return;
}
}
#line 1357 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void (*funcs1[9])(void)  = 
#line 1357
  {      & dopath,      & doproto,      & doserial,      & domodem, 
        & doscrkeyb,      & vdodflsave,      & donamsave,      (void (*)(void))((void *)0), 
        (void (*)(void))((void *)0)};
#line 1369 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
char some_string[64]  ;
#line 1371 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static char const   *menu1[10]  = 
#line 1371
  {      "Filenames and paths",      "File transfer protocols",      "Serial port setup",      "Modem and dialing", 
        "Screen and keyboard",      (char const   *)(some_string),      "Save setup as..",      "Exit", 
        "Exit from Minicom",      (char const   *)((void *)0)};
#line 1385 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int config(int setup ) 
{ 
  int c___0 ;
  char *s___0 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1391
  tmp = strlen("/usr/local/etc");
#line 1391
  s___0 = (parfile + tmp) + 8;
#line 1392
  tmp___0 = gettext("Save setup as %s");
#line 1392
  snprintf((char */* __restrict  */)(some_string), sizeof(some_string), (char const   */* __restrict  */)tmp___0,
           s___0);
#line 1393
  some_string[sizeof(some_string) - 1UL] = (char)0;
  }
#line 1395
  if (! setup) {
#line 1396
    menu1[8] = (char const   *)((void *)0);
  }
  {
#line 1398
  tmp___1 = gettext("configuration");
#line 1398
  c___0 = mc_wselect(13, 10, (char const   * const  *)(menu1), (void (* const  *)(void))(funcs1),
                     (char const   *)tmp___1, (int )stdattr, mfcolor, mbcolor);
  }
#line 1399
  if (c___0 == 9) {
#line 1400
    return (1);
  }
#line 1401
  return (0);
}
}
#line 1406 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
char const   *J_col[8]  = 
#line 1406
  {      "BLACK",      "RED",      "GREEN",      "YELLOW", 
        "BLUE",      "MAGENTA",      "CYAN",      "WHITE"};
#line 1410 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static unsigned int const   speeds[22]  = 
#line 1410
  {      (unsigned int const   )300,      (unsigned int const   )1200,      (unsigned int const   )2400,      (unsigned int const   )4800, 
        (unsigned int const   )9600,      (unsigned int const   )19200,      (unsigned int const   )38400,      (unsigned int const   )57600, 
        (unsigned int const   )115200,      (unsigned int const   )230400,      (unsigned int const   )460800,      (unsigned int const   )500000, 
        (unsigned int const   )576000,      (unsigned int const   )921600,      (unsigned int const   )1000000,      (unsigned int const   )1152000, 
        (unsigned int const   )1500000,      (unsigned int const   )2000000,      (unsigned int const   )2500000,      (unsigned int const   )3000000, 
        (unsigned int const   )3500000,      (unsigned int const   )4000000};
#line 1419 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int speed_valid(unsigned int speed ) 
{ 
  unsigned int i ;

  {
#line 1422
  i = 0U;
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1422
    if (! ((unsigned long )i < sizeof(speeds) / sizeof(speeds[0]))) {
#line 1422
      goto while_break;
    }
#line 1423
    if (speed == (unsigned int )speeds[i]) {
#line 1424
      return (1);
    }
#line 1422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1425
  return (0);
}
}
#line 1431 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void get_bbp(char *ba , char *bi , char *pa , char *stopb , int curr_ok ) 
{ 
  int c___0 ;
  WIN *w ;
  int x ;
  int y ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 1437
  w = mc_wopen(23, 4, 58, 18, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1438
  tmp = gettext("Comm Parameters");
#line 1438
  mc_wtitle(w, 1, (char const   *)tmp);
#line 1440
  dirflush = 0;
#line 1442
  mc_wlocate(w, 0, 3);
#line 1443
  tmp___0 = gettext(" Speed            Parity      Data\n");
#line 1443
  mc_wputs(w, (char const   *)tmp___0);
#line 1444
  tmp___1 = gettext(" A: <next>        L: None     S: 5\n");
#line 1444
  mc_wputs(w, (char const   *)tmp___1);
#line 1445
  tmp___2 = gettext(" B: <prev>        M: Even     T: 6\n");
#line 1445
  mc_wputs(w, (char const   *)tmp___2);
#line 1446
  tmp___3 = gettext(" C:   9600        N: Odd      U: 7\n");
#line 1446
  mc_wputs(w, (char const   *)tmp___3);
#line 1447
  tmp___4 = gettext(" D:  38400        O: Mark     V: 8\n");
#line 1447
  mc_wputs(w, (char const   *)tmp___4);
#line 1448
  tmp___5 = gettext(" E: 115200        P: Space\n");
#line 1448
  mc_wputs(w, (char const   *)tmp___5);
#line 1449
  mc_wputs(w, "\n");
#line 1450
  tmp___6 = gettext(" Stopbits\n");
#line 1450
  mc_wputs(w, (char const   *)tmp___6);
#line 1451
  tmp___7 = gettext(" W: 1             Q: 8-N-1\n");
#line 1451
  mc_wputs(w, (char const   *)tmp___7);
#line 1452
  tmp___8 = gettext(" X: 2             R: 7-E-1\n");
#line 1452
  mc_wputs(w, (char const   *)tmp___8);
  }
#line 1453
  if (curr_ok) {
    {
#line 1454
    tmp___9 = gettext(" K: Current\n");
#line 1454
    mc_wputs(w, (char const   *)tmp___9);
    }
  } else {
    {
#line 1456
    mc_wputs(w, "\n");
    }
  }
  {
#line 1457
  tmp___10 = gettext("\n Choice, or <Enter> to exit? ");
#line 1457
  mc_wputs(w, (char const   *)tmp___10);
#line 1458
  x = (int )w->curx;
#line 1459
  y = (int )w->cury;
#line 1461
  mc_wredraw(w, 1);
  }
  {
#line 1463
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1464
    mc_wlocate(w, 5, 1);
#line 1465
    tmp___11 = gettext("Current: %5s %s%s%s  ");
#line 1465
    mc_wprintf(w, (char const   *)tmp___11, ba, bi, pa, stopb);
#line 1466
    mc_wlocate(w, x, y);
#line 1467
    mc_wflush();
#line 1468
    c___0 = wxgetch();
    }
    {
#line 1472
    if (c___0 == 13) {
#line 1472
      goto case_13;
    }
#line 1472
    if (c___0 == 10) {
#line 1472
      goto case_13;
    }
#line 1472
    if (c___0 == 27) {
#line 1472
      goto case_13;
    }
#line 1476
    goto switch_default;
    case_13: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_27: /* CIL Label */ 
    {
#line 1473
    dirflush = 1;
#line 1474
    mc_wclose(w, 1);
    }
#line 1475
    return;
    switch_default: /* CIL Label */ 
    {
#line 1477
    update_bbp_from_char((char )c___0, ba, bi, pa, stopb, curr_ok);
    }
#line 1478
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1487 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int update_bbp_from_char(char c___0 , char *ba , char *bi , char *pa , char *stopb ,
                         int curr_ok ) 
{ 
  int characterRecognised ;
  unsigned int i ;
  int speed_idx ;
  int delta ;
  unsigned int max_speed ;
  unsigned int tmp ;
  char tmps[15] ;
  int update_ba ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1490
  characterRecognised = 1;
#line 1492
  speed_idx = 0;
#line 1493
  delta = -1;
#line 1494
  tmp = m_getmaxspd();
#line 1494
  max_speed = tmp;
#line 1496
  update_ba = 0;
#line 1499
  i = 0U;
  }
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! speed_idx) {
#line 1499
      if (! ((unsigned long )i < sizeof(speeds) / sizeof(speeds[0]))) {
#line 1499
        goto while_break;
      }
    } else {
#line 1499
      goto while_break;
    }
    {
#line 1500
    snprintf((char */* __restrict  */)(tmps), sizeof(tmps), (char const   */* __restrict  */)"%d",
             speeds[i]);
#line 1501
    tmps[sizeof(tmps) - 1UL] = (char)0;
#line 1502
    tmp___0 = strcmp((char const   *)(tmps), (char const   *)ba);
    }
#line 1502
    if (! tmp___0) {
#line 1503
      speed_idx = (int )i;
    }
#line 1499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  *(bi + 1) = (char)0;
#line 1507
  *(pa + 1) = (char)0;
#line 1509
  tmp___1 = toupper((int )c___0);
#line 1509
  c___0 = (char )tmp___1;
  }
  {
#line 1510
  if ((int )c___0 == 65) {
#line 1510
    goto case_65;
  }
#line 1512
  if ((int )c___0 == 66) {
#line 1512
    goto case_66;
  }
#line 1521
  if ((int )c___0 == 69) {
#line 1521
    goto case_69;
  }
#line 1521
  if ((int )c___0 == 68) {
#line 1521
    goto case_69;
  }
#line 1521
  if ((int )c___0 == 67) {
#line 1521
    goto case_69;
  }
#line 1528
  if ((int )c___0 == 75) {
#line 1528
    goto case_75;
  }
#line 1534
  if ((int )c___0 == 76) {
#line 1534
    goto case_76;
  }
#line 1537
  if ((int )c___0 == 77) {
#line 1537
    goto case_77;
  }
#line 1540
  if ((int )c___0 == 78) {
#line 1540
    goto case_78;
  }
#line 1543
  if ((int )c___0 == 79) {
#line 1543
    goto case_79;
  }
#line 1546
  if ((int )c___0 == 80) {
#line 1546
    goto case_80;
  }
#line 1549
  if ((int )c___0 == 81) {
#line 1549
    goto case_81;
  }
#line 1554
  if ((int )c___0 == 82) {
#line 1554
    goto case_82;
  }
#line 1559
  if ((int )c___0 == 83) {
#line 1559
    goto case_83;
  }
#line 1562
  if ((int )c___0 == 84) {
#line 1562
    goto case_84;
  }
#line 1565
  if ((int )c___0 == 85) {
#line 1565
    goto case_85;
  }
#line 1568
  if ((int )c___0 == 86) {
#line 1568
    goto case_86;
  }
#line 1571
  if ((int )c___0 == 87) {
#line 1571
    goto case_87;
  }
#line 1574
  if ((int )c___0 == 88) {
#line 1574
    goto case_88;
  }
#line 1577
  goto switch_default;
  case_65: /* CIL Label */ 
#line 1511
  delta = 1;
  case_66: /* CIL Label */ 
#line 1513
  speed_idx += delta;
#line 1514
  if (speed_idx < 0) {
#line 1515
    speed_idx = (int )(sizeof(speeds) / sizeof(speeds[0]) - 1UL);
  } else
#line 1516
  if (speed_idx > (int )(sizeof(speeds) / sizeof(speeds[0])) - 1) {
#line 1518
    speed_idx = 0;
  } else
#line 1516
  if (max_speed < (unsigned int )speeds[speed_idx]) {
#line 1518
    speed_idx = 0;
  }
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 1522
  if ((int )c___0 == 67) {
#line 1523
    speed_idx = 4;
  } else
#line 1524
  if ((int )c___0 == 68) {
#line 1525
    speed_idx = 6;
  } else
#line 1526
  if ((int )c___0 == 69) {
#line 1527
    speed_idx = 8;
  }
  case_75: /* CIL Label */ 
#line 1529
  if ((int )c___0 == 75) {
#line 1529
    if (! curr_ok) {
#line 1530
      goto switch_break;
    }
  }
#line 1531
  update_ba = 1;
#line 1532
  goto switch_break;
  case_76: /* CIL Label */ 
#line 1535
  *(pa + 0) = (char )'N';
#line 1536
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1538
  *(pa + 0) = (char )'E';
#line 1539
  goto switch_break;
  case_78: /* CIL Label */ 
#line 1541
  *(pa + 0) = (char )'O';
#line 1542
  goto switch_break;
  case_79: /* CIL Label */ 
#line 1544
  *(pa + 0) = (char )'M';
#line 1545
  goto switch_break;
  case_80: /* CIL Label */ 
#line 1547
  *(pa + 0) = (char )'S';
#line 1548
  goto switch_break;
  case_81: /* CIL Label */ 
#line 1550
  *(pa + 0) = (char )'N';
#line 1551
  *(bi + 0) = (char )'8';
#line 1552
  *(stopb + 0) = (char )'1';
#line 1553
  goto switch_break;
  case_82: /* CIL Label */ 
#line 1555
  *(pa + 0) = (char )'E';
#line 1556
  *(bi + 0) = (char )'7';
#line 1557
  *(stopb + 0) = (char )'1';
#line 1558
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1560
  *(bi + 0) = (char )'5';
#line 1561
  goto switch_break;
  case_84: /* CIL Label */ 
#line 1563
  *(bi + 0) = (char )'6';
#line 1564
  goto switch_break;
  case_85: /* CIL Label */ 
#line 1566
  *(bi + 0) = (char )'7';
#line 1567
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1569
  *(bi + 0) = (char )'8';
#line 1570
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1572
  *(stopb + 0) = (char )'1';
#line 1573
  goto switch_break;
  case_88: /* CIL Label */ 
#line 1575
  *(stopb + 0) = (char )'2';
#line 1576
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1578
  characterRecognised = 0;
#line 1579
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1582
  if (update_ba) {
    {
#line 1583
    sprintf((char */* __restrict  */)ba, (char const   */* __restrict  */)"%d", speeds[speed_idx]);
    }
  }
#line 1585
  return (characterRecognised);
}
}
#line 1591 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
static void out_mac(WIN *w , char *s___0 , char n ) 
{ 
  char const   *tmp ;

  {
#line 1593
  if (s___0) {
#line 1593
    tmp = (char const   *)s___0;
  } else {
#line 1593
    tmp = "[none]";
  }
  {
#line 1593
  mc_wprintf(w, " %c : %.67s\n", (int )n, tmp);
  }
#line 1594
  return;
}
}
#line 1599 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void domacros(void) 
{ 
  WIN *w ;
  int clr ;
  int Jch ;
  int Jm ;
  char *question ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 1602
  clr = 1;
#line 1603
  Jch = '1';
#line 1603
  Jm = 0;
#line 1604
  tmp = gettext("Change which setting?  (Esc to exit)");
#line 1604
  question = tmp;
#line 1606
  w = mc_wopen(3, 6, 75, 24, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1607
  tmp___0 = gettext("F1 to F10 Macros");
#line 1607
  mc_wtitle(w, 1, (char const   *)tmp___0);
#line 1609
  mc_wprintf(w, "\n");
#line 1610
  tmp___1 = Jch;
#line 1610
  Jch ++;
#line 1610
  tmp___2 = Jm;
#line 1610
  Jm ++;
#line 1610
  out_mac(w, mmacs[tmp___2].value, (char )tmp___1);
#line 1611
  tmp___3 = Jch;
#line 1611
  Jch ++;
#line 1611
  tmp___4 = Jm;
#line 1611
  Jm ++;
#line 1611
  out_mac(w, mmacs[tmp___4].value, (char )tmp___3);
#line 1612
  tmp___5 = Jch;
#line 1612
  Jch ++;
#line 1612
  tmp___6 = Jm;
#line 1612
  Jm ++;
#line 1612
  out_mac(w, mmacs[tmp___6].value, (char )tmp___5);
#line 1613
  tmp___7 = Jch;
#line 1613
  Jch ++;
#line 1613
  tmp___8 = Jm;
#line 1613
  Jm ++;
#line 1613
  out_mac(w, mmacs[tmp___8].value, (char )tmp___7);
#line 1614
  tmp___9 = Jch;
#line 1614
  Jch ++;
#line 1614
  tmp___10 = Jm;
#line 1614
  Jm ++;
#line 1614
  out_mac(w, mmacs[tmp___10].value, (char )tmp___9);
#line 1615
  tmp___11 = Jch;
#line 1615
  Jch ++;
#line 1615
  tmp___12 = Jm;
#line 1615
  Jm ++;
#line 1615
  out_mac(w, mmacs[tmp___12].value, (char )tmp___11);
#line 1616
  tmp___13 = Jch;
#line 1616
  Jch ++;
#line 1616
  tmp___14 = Jm;
#line 1616
  Jm ++;
#line 1616
  out_mac(w, mmacs[tmp___14].value, (char )tmp___13);
#line 1617
  tmp___15 = Jch;
#line 1617
  Jch ++;
#line 1617
  tmp___16 = Jm;
#line 1617
  Jm ++;
#line 1617
  out_mac(w, mmacs[tmp___16].value, (char )tmp___15);
#line 1618
  tmp___17 = Jch;
#line 1618
  Jch ++;
#line 1618
  tmp___18 = Jm;
#line 1618
  Jm ++;
#line 1618
  out_mac(w, mmacs[tmp___18].value, (char )tmp___17);
#line 1619
  Jch = 'A';
#line 1620
  tmp___19 = Jch;
#line 1620
  Jch ++;
#line 1620
  tmp___20 = Jm;
#line 1620
  Jm ++;
#line 1620
  out_mac(w, mmacs[tmp___20].value, (char )tmp___19);
#line 1622
  mc_wredraw(w, 1);
  }
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1625
    mc_wlocate(w, 1, 14);
#line 1626
    tmp___21 = gettext(" (LEGEND: ^M = C-M, ^L = C-L, ^G = C-G, ^R = C-R, ^~ = pause 1 second,");
#line 1626
    mc_wputs(w, (char const   *)tmp___21);
#line 1627
    mc_wlocate(w, 1, 15);
#line 1628
    tmp___22 = gettext("  \\u = username, \\p = password, \\\\ = \\, \\e = toggle echo, ");
#line 1628
    mc_wputs(w, (char const   *)tmp___22);
#line 1629
    mc_wlocate(w, 1, 16);
#line 1630
    tmp___23 = gettext("  \\l = toggle LF, \\bX1..Xn<sp> = change baud rate. Example: \"\\beq \"");
#line 1630
    mc_wputs(w, (char const   *)tmp___23);
#line 1631
    mc_wlocate(w, 1, 17);
#line 1632
    tmp___24 = gettext("  = 115200 8N1. (See the \"Comm Parameters\" menu for valid values of X.))");
#line 1632
    mc_wputs(w, (char const   *)tmp___24);
    }
#line 1633
    if (clr) {
      {
#line 1634
      mc_wlocate(w, 1, 12);
#line 1635
      mc_wprintf(w, "%s ", question);
#line 1636
      mc_wclreol(w);
#line 1637
      clr = 0;
      }
    } else {
      {
#line 1639
      tmp___25 = mbslen((char const   *)question);
#line 1639
      mc_wlocate(w, (int )(tmp___25 + 2UL), 12);
      }
    }
    {
#line 1641
    tmp___26 = rwxgetch();
    }
    {
#line 1642
    if (tmp___26 == 10) {
#line 1642
      goto case_10;
    }
#line 1645
    if (tmp___26 == 49) {
#line 1645
      goto case_49;
    }
#line 1651
    if (tmp___26 == 50) {
#line 1651
      goto case_50;
    }
#line 1657
    if (tmp___26 == 51) {
#line 1657
      goto case_51;
    }
#line 1663
    if (tmp___26 == 52) {
#line 1663
      goto case_52;
    }
#line 1669
    if (tmp___26 == 53) {
#line 1669
      goto case_53;
    }
#line 1675
    if (tmp___26 == 54) {
#line 1675
      goto case_54;
    }
#line 1681
    if (tmp___26 == 55) {
#line 1681
      goto case_55;
    }
#line 1687
    if (tmp___26 == 56) {
#line 1687
      goto case_56;
    }
#line 1693
    if (tmp___26 == 57) {
#line 1693
      goto case_57;
    }
#line 1699
    if (tmp___26 == 65) {
#line 1699
      goto case_65;
    }
#line 1641
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1643
    mc_wclose(w, 1);
    }
#line 1644
    return;
    case_49: /* CIL Label */ 
    {
#line 1646
    mgets(w, 5, 1, mmacs[0].value, 72, 257);
#line 1647
    tmp___27 = gettext("CHANGED");
#line 1647
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)tmp___27);
#line 1648
    mc_wlocate(w, 0, 1);
#line 1649
    out_mac(w, mmacs[0].value, (char )'1');
    }
#line 1650
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 1652
    mgets(w, 5, 2, mmacs[1].value, 72, 257);
#line 1653
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1654
    mc_wlocate(w, 0, 2);
#line 1655
    out_mac(w, mmacs[1].value, (char )'2');
    }
#line 1656
    goto switch_break;
    case_51: /* CIL Label */ 
    {
#line 1658
    mgets(w, 5, 3, mmacs[2].value, 72, 257);
#line 1659
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1660
    mc_wlocate(w, 0, 3);
#line 1661
    out_mac(w, mmacs[2].value, (char )'3');
    }
#line 1662
    goto switch_break;
    case_52: /* CIL Label */ 
    {
#line 1664
    mgets(w, 5, 4, mmacs[3].value, 72, 257);
#line 1665
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1666
    mc_wlocate(w, 0, 4);
#line 1667
    out_mac(w, mmacs[3].value, (char )'4');
    }
#line 1668
    goto switch_break;
    case_53: /* CIL Label */ 
    {
#line 1670
    mgets(w, 5, 5, mmacs[4].value, 72, 257);
#line 1671
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1672
    mc_wlocate(w, 0, 5);
#line 1673
    out_mac(w, mmacs[4].value, (char )'5');
    }
#line 1674
    goto switch_break;
    case_54: /* CIL Label */ 
    {
#line 1676
    mgets(w, 5, 6, mmacs[5].value, 72, 257);
#line 1677
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1678
    mc_wlocate(w, 0, 6);
#line 1679
    out_mac(w, mmacs[5].value, (char )'6');
    }
#line 1680
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 1682
    mgets(w, 5, 7, mmacs[6].value, 72, 257);
#line 1683
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1684
    mc_wlocate(w, 0, 7);
#line 1685
    out_mac(w, mmacs[6].value, (char )'7');
    }
#line 1686
    goto switch_break;
    case_56: /* CIL Label */ 
    {
#line 1688
    mgets(w, 5, 8, mmacs[7].value, 72, 257);
#line 1689
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1690
    mc_wlocate(w, 0, 8);
#line 1691
    out_mac(w, mmacs[7].value, (char )'8');
    }
#line 1692
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 1694
    mgets(w, 5, 9, mmacs[8].value, 72, 257);
#line 1695
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1696
    mc_wlocate(w, 0, 9);
#line 1697
    out_mac(w, mmacs[8].value, (char )'9');
    }
#line 1698
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 1700
    mgets(w, 5, 10, mmacs[9].value, 72, 257);
#line 1701
    strcpy((char */* __restrict  */)(mpars[75].value), (char const   */* __restrict  */)"CHANGED");
#line 1702
    mc_wlocate(w, 0, 10);
#line 1703
    out_mac(w, mmacs[9].value, (char )'A');
    }
#line 1704
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1713 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int prch(int c___0 ) 
{ 


  {
#line 1715
  if (c___0 < 32) {
#line 1716
    return (' ');
  } else
#line 1715
  if (c___0 == 127) {
#line 1716
    return (' ');
  } else
#line 1715
  if (c___0 == 155) {
#line 1716
    return (' ');
  } else {
#line 1718
    return (c___0);
  }
}
}
#line 1722 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
void doconv(void) 
{ 
  WIN *w ;
  int i ;
  int j ;
  int k ;
  int l ;
  int h ;
  int offs ;
  int ymax ;
  int redraw ;
  char buf___6[64] ;
  char *prompt ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;

  {
  {
#line 1725
  offs = 32;
#line 1725
  ymax = 22;
#line 1725
  redraw = 1;
#line 1732
  h = 16;
#line 1733
  w = mc_wopen(1, 1, 77, ymax, 2, (int )stdattr, mfcolor, mbcolor, 0, 0, 1);
#line 1734
  tmp = gettext("Character conversion");
#line 1734
  mc_wtitle(w, 1, (char const   *)tmp);
  }
  {
#line 1735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1736
    if (redraw) {
      {
#line 1737
      mc_winclr(w);
#line 1738
      tmp___0 = gettext(" char    in out    char    in out    char    in out    char    in out\n");
#line 1738
      mc_wprintf(w, (char const   *)tmp___0);
#line 1740
      i = offs;
#line 1740
      j = i + h;
#line 1740
      k = j + h;
#line 1740
      l = k + h;
      }
      {
#line 1740
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1740
        if (i < offs + h) {
#line 1740
          if (! (i < 256)) {
#line 1740
            goto while_break___0;
          }
        } else {
#line 1740
          goto while_break___0;
        }
        {
#line 1743
        tmp___1 = prch(i);
#line 1743
        mc_wprintf(w, "%3d (%c) %3d %3d   ", i, tmp___1, (int )vt_inmap[i], (int )vt_outmap[i]);
        }
#line 1745
        if (j < 256) {
          {
#line 1746
          tmp___2 = prch(j);
#line 1746
          mc_wprintf(w, "%3d (%c) %3d %3d   ", j, tmp___2, (int )vt_inmap[j], (int )vt_outmap[j]);
          }
        } else {
          {
#line 1749
          mc_wprintf(w, "                  ");
          }
        }
#line 1750
        if (k < 256) {
          {
#line 1751
          tmp___3 = prch(k);
#line 1751
          mc_wprintf(w, "%3d (%c) %3d %3d   ", k, tmp___3, (int )vt_inmap[k], (int )vt_outmap[k]);
          }
        } else {
          {
#line 1754
          mc_wprintf(w, "                  ");
          }
        }
#line 1755
        if (l < 256) {
          {
#line 1756
          tmp___4 = prch(l);
#line 1756
          mc_wprintf(w, "%3d (%c) %3d %3d\n", l, tmp___4, (int )vt_inmap[l], (int )vt_outmap[l]);
          }
        } else {
          {
#line 1759
          mc_wprintf(w, "               \n");
          }
        }
#line 1740
        i ++;
#line 1740
        j ++;
#line 1740
        k ++;
#line 1740
        l ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1761
      tmp___5 = gettext("\n A - load table\tB - save table");
#line 1761
      mc_wprintf(w, (char const   *)tmp___5);
      }
#line 1762
      if (mpars[79].value[0]) {
        {
#line 1763
        tmp___6 = gettext("\tfile:%s");
#line 1763
        mc_wprintf(w, (char const   *)tmp___6, mpars[79].value);
        }
      }
      {
#line 1764
      tmp___7 = gettext("\n C - edit char\tD - next screen\tE - prev screen\n");
#line 1764
      mc_wprintf(w, (char const   *)tmp___7);
#line 1765
      tmp___8 = gettext((char const   *)(mpars[80].value));
#line 1765
      tmp___9 = gettext(" F - convert capture: %s\n");
#line 1765
      mc_wprintf(w, (char const   *)tmp___9, tmp___8);
#line 1767
      mc_wredraw(w, 1);
#line 1768
      redraw = 0;
      }
    }
    {
#line 1771
    mc_wlocate(w, 1, ymax - 1);
#line 1772
    mc_wclreol(w);
#line 1773
    mc_wflush();
#line 1774
    tmp___10 = rwxgetch();
#line 1774
    tmp___11 = toupper(tmp___10);
    }
    {
#line 1775
    if (tmp___11 == 10) {
#line 1775
      goto case_10;
    }
#line 1778
    if (tmp___11 == 65) {
#line 1778
      goto case_65;
    }
#line 1790
    if (tmp___11 == 66) {
#line 1790
      goto case_66;
    }
#line 1802
    if (tmp___11 == 67) {
#line 1802
      goto case_67;
    }
#line 1841
    if (tmp___11 == 68) {
#line 1841
      goto case_68;
    }
#line 1847
    if (tmp___11 == 69) {
#line 1847
      goto case_69;
    }
#line 1853
    if (tmp___11 == 70) {
#line 1853
      goto case_70;
    }
#line 1774
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1776
    mc_wclose(w, 1);
    }
#line 1776
    return;
#line 1777
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 1779
    strcpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)(mpars[79].value));
#line 1780
    prompt = gettext("Load file: %s");
#line 1781
    mc_wprintf(w, (char const   *)prompt, buf___6);
#line 1782
    tmp___12 = mbslen((char const   *)prompt);
#line 1782
    pgets(w, (int )(tmp___12 - 1UL), ymax - 1, mpars[79].value, 64, 64U, 1);
#line 1783
    tmp___14 = loadconv(mpars[79].value);
    }
#line 1783
    if (tmp___14 == 0) {
      {
#line 1784
      tmp___13 = strcmp((char const   *)(mpars[79].value), (char const   *)(buf___6));
      }
#line 1784
      if (tmp___13) {
        {
#line 1785
        markch(mpars[79].value);
        }
      }
#line 1786
      redraw = 1;
    } else {
      {
#line 1788
      strcpy((char */* __restrict  */)(mpars[79].value), (char const   */* __restrict  */)(buf___6));
      }
    }
#line 1789
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1791
    strcpy((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)(mpars[79].value));
#line 1792
    prompt = gettext("Save as file: %s");
#line 1793
    mc_wprintf(w, (char const   *)prompt, buf___6);
#line 1794
    tmp___15 = mbslen((char const   *)prompt);
#line 1794
    pgets(w, (int )(tmp___15 - 1UL), ymax - 1, mpars[79].value, 64, 64U, 1);
#line 1795
    tmp___17 = saveconv(mpars[79].value);
    }
#line 1795
    if (tmp___17 == 0) {
      {
#line 1796
      tmp___16 = strcmp((char const   *)(mpars[79].value), (char const   *)(buf___6));
      }
#line 1796
      if (tmp___16) {
        {
#line 1797
        markch(mpars[79].value);
        }
      }
#line 1798
      redraw = 1;
    } else {
      {
#line 1800
      strcpy((char */* __restrict  */)(mpars[79].value), (char const   */* __restrict  */)(buf___6));
      }
    }
#line 1801
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 1803
    prompt = gettext("Character to be edited: ");
#line 1804
    mc_wprintf(w, "%s", prompt);
#line 1805
    buf___6[0] = (char)0;
#line 1806
    i = -1;
#line 1807
    tmp___18 = mbslen((char const   *)prompt);
#line 1807
    mc_wlocate(w, (int )tmp___18, ymax - 1);
#line 1808
    mc_wgets(w, buf___6, 7, 7);
#line 1809
    sscanf((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
           & i);
    }
#line 1810
    if (i > 255) {
      {
#line 1811
      tmp___19 = gettext("Input character ascii value 0-255");
#line 1811
      werror((char const   *)tmp___19);
      }
#line 1812
      goto switch_break;
    } else
#line 1810
    if (i < 0) {
      {
#line 1811
      tmp___19 = gettext("Input character ascii value 0-255");
#line 1811
      werror((char const   *)tmp___19);
      }
#line 1812
      goto switch_break;
    }
    {
#line 1815
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%u",
            (unsigned int )vt_inmap[i]);
#line 1816
    mc_wlocate(w, 30, ymax - 1);
#line 1817
    prompt = gettext("Change input to: %s");
#line 1818
    mc_wprintf(w, (char const   *)prompt, buf___6);
#line 1819
    tmp___20 = mbslen((char const   *)prompt);
#line 1819
    mc_wlocate(w, (int )(tmp___20 + 28UL), ymax - 1);
#line 1820
    mc_wgets(w, buf___6, 7, 7);
#line 1821
    sscanf((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
           & j);
    }
#line 1822
    if (j > 255) {
      {
#line 1823
      tmp___21 = gettext("Input character ascii value 0-255");
#line 1823
      werror((char const   *)tmp___21);
      }
#line 1824
      goto switch_break;
    } else
#line 1822
    if (j < 0) {
      {
#line 1823
      tmp___21 = gettext("Input character ascii value 0-255");
#line 1823
      werror((char const   *)tmp___21);
      }
#line 1824
      goto switch_break;
    } else {
#line 1826
      vt_inmap[i] = (unsigned char )j;
    }
    {
#line 1827
    sprintf((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%u",
            (unsigned int )vt_outmap[i]);
#line 1828
    mc_wlocate(w, 54, ymax - 1);
#line 1829
    prompt = gettext("Change output to: %s");
#line 1830
    mc_wprintf(w, (char const   *)prompt, buf___6);
#line 1831
    tmp___22 = mbslen((char const   *)prompt);
#line 1831
    mc_wlocate(w, (int )(tmp___22 + 52UL), ymax - 1);
#line 1832
    mc_wgets(w, buf___6, 7, 7);
#line 1833
    sscanf((char const   */* __restrict  */)(buf___6), (char const   */* __restrict  */)"%d",
           & j);
    }
#line 1834
    if (j > 255) {
      {
#line 1835
      tmp___23 = gettext("Input character ascii value 0-255");
#line 1835
      werror((char const   *)tmp___23);
      }
#line 1836
      goto switch_break;
    } else
#line 1834
    if (j < 0) {
      {
#line 1835
      tmp___23 = gettext("Input character ascii value 0-255");
#line 1835
      werror((char const   *)tmp___23);
      }
#line 1836
      goto switch_break;
    } else {
#line 1838
      vt_outmap[i] = (unsigned char )j;
    }
#line 1839
    redraw = 1;
#line 1840
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1842
    offs += 4 * h;
#line 1843
    if (offs > 255) {
#line 1844
      offs = 0;
    }
#line 1845
    redraw = 1;
#line 1846
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1848
    offs -= 4 * h;
#line 1849
    if (offs < 0) {
#line 1850
      offs = 0;
    }
#line 1851
    redraw = 1;
#line 1852
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 1854
    tmp___24 = yesno((int )mpars[80].value[0] == 78);
#line 1854
    strcpy((char */* __restrict  */)(mpars[80].value), (char const   */* __restrict  */)tmp___24);
#line 1855
    markch(mpars[80].value);
#line 1856
    redraw = 1;
    }
#line 1857
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1862 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int loadconv(char *buf___6 ) 
{ 
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 1866
  tmp___1 = pfix_home(buf___6);
#line 1866
  fp = fopen((char const   */* __restrict  */)tmp___1, (char const   */* __restrict  */)"rb");
  }
#line 1866
  if ((unsigned long )fp == (unsigned long )((FILE *)((void *)0))) {
    {
#line 1867
    tmp = pfix_home(buf___6);
#line 1867
    tmp___0 = gettext("Cannot open conversion table %s");
#line 1867
    werror((char const   *)tmp___0, tmp);
    }
#line 1868
    return (1);
  }
  {
#line 1870
  tmp___4 = fread((void */* __restrict  */)(vt_inmap), sizeof(vt_inmap), (size_t )1,
                  (FILE */* __restrict  */)fp);
  }
#line 1870
  if (tmp___4 != 1UL) {
    {
#line 1873
    tmp___2 = pfix_home(buf___6);
#line 1873
    tmp___3 = gettext("Cannot read conversion table %s");
#line 1873
    werror((char const   *)tmp___3, tmp___2);
    }
#line 1874
    return (1);
  } else {
    {
#line 1870
    tmp___5 = fread((void */* __restrict  */)(vt_outmap), sizeof(vt_outmap), (size_t )1,
                    (FILE */* __restrict  */)fp);
    }
#line 1870
    if (tmp___5 != 1UL) {
      {
#line 1873
      tmp___2 = pfix_home(buf___6);
#line 1873
      tmp___3 = gettext("Cannot read conversion table %s");
#line 1873
      werror((char const   *)tmp___3, tmp___2);
      }
#line 1874
      return (1);
    }
  }
  {
#line 1876
  fclose(fp);
  }
#line 1877
  return (0);
}
}
#line 1880 "/home/wheatley/newnew/temp/minicom-2.7/src/config.c"
int saveconv(char *buf___6 ) 
{ 
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1884
  tmp___1 = pfix_home(buf___6);
#line 1884
  fp = fopen((char const   */* __restrict  */)tmp___1, (char const   */* __restrict  */)"wb");
  }
#line 1884
  if ((unsigned long )fp == (unsigned long )((FILE *)((void *)0))) {
    {
#line 1885
    tmp = pfix_home(buf___6);
#line 1885
    tmp___0 = gettext("Cannot write conversion table %s");
#line 1885
    werror((char const   *)tmp___0, tmp);
    }
#line 1886
    return (1);
  }
  {
#line 1888
  fwrite((void const   */* __restrict  */)(vt_inmap), sizeof(vt_inmap), (size_t )1,
         (FILE */* __restrict  */)fp);
#line 1889
  fwrite((void const   */* __restrict  */)(vt_outmap), sizeof(vt_outmap), (size_t )1,
         (FILE */* __restrict  */)fp);
#line 1890
  fclose(fp);
  }
#line 1891
  return (0);
}
}
#line 578 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 30 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
static int getargs(char *s___0 , char **arps , int maxargs ) 
{ 
  register int i ;
  register char *sp___0 ;
  register char qchar ;
  int literal ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 35
  literal = 0;
#line 37
  i = 0;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! (i < maxargs)) {
#line 38
      goto while_break;
    }
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 39
      if (! ((int )*s___0 == 32)) {
#line 39
        if (! ((int )*s___0 == 9)) {
#line 39
          goto while_break___0;
        }
      }
#line 40
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 41
    if ((int )*s___0 == 10) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )*s___0 == 0) {
#line 42
      goto while_break;
    }
#line 43
    tmp = i;
#line 43
    i ++;
#line 43
    sp___0 = s___0;
#line 43
    *(arps + tmp) = sp___0;
#line 44
    qchar = (char)0;
    {
#line 45
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 45
      if ((int )*s___0 != 0) {
#line 45
        if (! ((int )*s___0 != 10)) {
#line 45
          goto while_break___1;
        }
      } else {
#line 45
        goto while_break___1;
      }
#line 46
      if (literal) {
#line 47
        literal = 0;
#line 48
        tmp___0 = sp___0;
#line 48
        sp___0 ++;
#line 48
        tmp___1 = s___0;
#line 48
        s___0 ++;
#line 48
        *tmp___0 = *tmp___1;
#line 49
        goto while_continue___1;
      }
#line 51
      literal = 0;
#line 52
      if ((int )qchar == 0) {
#line 52
        if ((int )*s___0 == 32) {
#line 53
          s___0 ++;
#line 54
          goto while_break___1;
        } else
#line 52
        if ((int )*s___0 == 9) {
#line 53
          s___0 ++;
#line 54
          goto while_break___1;
        }
      }
      {
#line 60
      if ((int )*s___0 == 92) {
#line 60
        goto case_92;
      }
#line 65
      if ((int )*s___0 == 39) {
#line 65
        goto case_39;
      }
#line 65
      if ((int )*s___0 == 34) {
#line 65
        goto case_39;
      }
#line 57
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 58
      tmp___2 = sp___0;
#line 58
      sp___0 ++;
#line 58
      tmp___3 = s___0;
#line 58
      s___0 ++;
#line 58
      *tmp___2 = *tmp___3;
#line 59
      goto switch_break;
      case_92: /* CIL Label */ 
#line 61
      literal = 1;
#line 62
      s___0 ++;
#line 63
      goto switch_break;
      case_39: /* CIL Label */ 
      case_34: /* CIL Label */ 
#line 66
      if ((int )qchar == (int )*s___0) {
#line 67
        qchar = (char)0;
#line 68
        s___0 ++;
#line 69
        goto switch_break;
      }
#line 71
      if (qchar) {
#line 72
        tmp___4 = sp___0;
#line 72
        sp___0 ++;
#line 72
        tmp___5 = s___0;
#line 72
        s___0 ++;
#line 72
        *tmp___4 = *tmp___5;
      } else {
#line 74
        tmp___6 = s___0;
#line 74
        s___0 ++;
#line 74
        qchar = *tmp___6;
      }
#line 75
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 78
    tmp___7 = sp___0;
#line 78
    sp___0 ++;
#line 78
    *tmp___7 = (char)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if (i >= maxargs) {
#line 81
    return (-1);
  }
#line 82
  *(arps + i) = (char *)((void *)0);
#line 83
  return (i);
}
}
#line 103 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
int fastexec(char *cmd ) 
{ 
  char *words[128] ;
  char *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 117
  p = cmd;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    p = strchr((char const   *)p, '\\');
    }
#line 118
    if (p) {
#line 118
      if (! ((int )*(p + 1) != 32)) {
#line 118
        goto while_break;
      }
    } else {
#line 118
      goto while_break;
    }
    {
#line 119
    tmp = strlen((char const   *)(p + 1));
#line 119
    memmove((void *)p, (void const   *)(p + 1), tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp___0 = getargs(cmd, words, 127);
  }
#line 122
  if (tmp___0 < 0) {
#line 123
    return (-1);
  }
  {
#line 124
  tmp___1 = execvp((char const   *)words[0], (char * const  *)(words));
  }
#line 124
  return (tmp___1);
}
}
#line 134 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
int fastsystem(char *cmd , char *in , char *out , char *err ) 
{ 
  int pid ;
  int st___0 ;
  int async ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 138
  async = 0;
#line 142
  p = strrchr((char const   *)cmd, '&');
  }
#line 143
  if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 143
    if (! *(p + 1)) {
#line 144
      *p = (char)0;
#line 145
      async = 1;
    }
  }
  {
#line 149
  pid = fork();
  }
#line 149
  if (pid == 0) {
#line 150
    if (in) {
      {
#line 151
      close(0);
#line 152
      tmp = open((char const   *)in, 0);
      }
#line 152
      if (tmp < 0) {
        {
#line 153
        exit(-1);
        }
      }
    }
#line 155
    if (out) {
      {
#line 156
      close(1);
#line 157
      tmp___0 = open((char const   *)out, 1);
      }
#line 157
      if (tmp___0 < 0) {
        {
#line 158
        exit(-1);
        }
      }
    }
#line 160
    if (err) {
      {
#line 161
      close(2);
#line 162
      tmp___1 = open((char const   *)err, 2);
      }
#line 162
      if (tmp___1 < 0) {
        {
#line 163
        exit(-1);
        }
      }
    }
    {
#line 165
    tmp___2 = fastexec(cmd);
#line 165
    exit(tmp___2);
    }
  } else
#line 166
  if (pid > 0) {
#line 167
    if (async) {
#line 168
      return (0);
    }
    {
#line 169
    pid = m_wait(& st___0);
    }
#line 170
    if (pid < 0) {
#line 171
      return (-1);
    }
#line 172
    return (st___0);
  }
#line 174
  return (-1);
}
}
#line 190 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
static char next_port[128]  ;
#line 191 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
static char loc_port_list[128]  ;
#line 192 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
static char *sp  =    (char *)((void *)0);
#line 193 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
static char *ep  ;
#line 188 "/home/wheatley/newnew/temp/minicom-2.7/src/util.c"
char *get_port(char *port_list ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 196
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    {
#line 197
    strncpy((char */* __restrict  */)(loc_port_list), (char const   */* __restrict  */)port_list,
            (size_t )128);
#line 198
    loc_port_list[127] = (char)0;
#line 199
    tmp = strlen((char const   *)(loc_port_list));
#line 199
    ep = & loc_port_list[tmp];
#line 200
    sp = strtok((char */* __restrict  */)(loc_port_list), (char const   */* __restrict  */)";, ");
    }
  } else
#line 202
  if ((int )*sp != 0) {
    {
#line 203
    sp = strtok((char */* __restrict  */)sp, (char const   */* __restrict  */)";, ");
    }
  } else {
#line 205
    sp = (char *)((void *)0);
  }
#line 207
  if ((unsigned long )sp != (unsigned long )((void *)0)) {
    {
#line 208
    strncpy((char */* __restrict  */)(next_port), (char const   */* __restrict  */)sp,
            (size_t )128);
#line 209
    next_port[127] = (char)0;
#line 211
    tmp___0 = strlen((char const   *)(next_port));
#line 211
    sp += tmp___0;
    }
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if ((unsigned long )sp != (unsigned long )ep) {
#line 211
        if (! ((int )*sp != 47)) {
#line 211
          goto while_break;
        }
      } else {
#line 211
        goto while_break;
      }
#line 211
      sp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 213
    return (next_port);
  } else {
#line 216
    return ((char *)((void *)0));
  }
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 154 "/home/wheatley/newnew/temp/minicom-2.7/src/minicom.h"
char const   *Version ;
#line 42 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static jmp_buf albuf  ;
#line 45 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
char const   *Version  =    "2.7";
#line 50 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char *mdevlockname(char *s___0 , char *res , int reslen ) 
{ 
  char *p ;
  int tmp ;

  {
  {
#line 54
  tmp = strncmp((char const   *)s___0, "/dev/", (size_t )5);
  }
#line 54
  if (tmp == 0) {
    {
#line 56
    strncpy((char */* __restrict  */)res, (char const   */* __restrict  */)(s___0 + 5),
            (size_t )(reslen - 1));
#line 57
    *(res + (reslen - 1)) = (char)0;
#line 58
    p = res;
    }
    {
#line 58
    while (1) {
      while_continue: /* CIL Label */ ;
#line 58
      if (! *p) {
#line 58
        goto while_break;
      }
#line 59
      if ((int )*p == 47) {
#line 60
        *p = (char )'_';
      }
#line 58
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 63
    p = strrchr((char const   *)s___0, '/');
    }
#line 63
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 64
      p = s___0;
    } else {
#line 66
      p ++;
    }
    {
#line 67
    strncpy((char */* __restrict  */)res, (char const   */* __restrict  */)p, (size_t )(reslen - 1));
#line 68
    *(res + (reslen - 1)) = (char)0;
    }
  }
#line 71
  return (res);
}
}
#line 74 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char *shortened_devpath(char *buf___6 , int buflen , char *devpath ) 
{ 
  char *cutoff[4] ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int l ;
  size_t tmp___2 ;

  {
#line 76
  cutoff[0] = (char *)"/dev/serial/by-id/";
#line 76
  cutoff[1] = (char *)"/dev/serial/by-path/";
#line 76
  cutoff[2] = (char *)"/dev/serial/";
#line 76
  cutoff[3] = (char *)"/dev/";
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 4)) {
#line 84
      goto while_break;
    }
    {
#line 85
    tmp___0 = strlen((char const   *)cutoff[i]);
#line 85
    tmp___1 = strncmp((char const   *)devpath, (char const   *)cutoff[i], tmp___0);
    }
#line 85
    if (! tmp___1) {
      {
#line 87
      tmp = strlen((char const   *)cutoff[i]);
#line 87
      devpath += tmp;
      }
#line 88
      goto while_break;
    }
#line 84
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  tmp___2 = strlen((char const   *)devpath);
#line 91
  l = (int )tmp___2;
  }
#line 93
  if (l > buflen - 1) {
#line 94
    devpath += (l - buflen) + 1;
  }
  {
#line 96
  strncpy((char */* __restrict  */)buf___6, (char const   */* __restrict  */)devpath,
          (size_t )buflen);
#line 97
  *(buf___6 + (buflen - 1)) = (char)0;
  }
#line 99
  return (buf___6);
}
}
#line 105
 __attribute__((__noreturn__)) void leave(char const   *s___0 ) ;
#line 105 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void leave(char const   *s___0 ) 
{ 


  {
#line 107
  if (stdwin) {
    {
#line 108
    mc_wclose(stdwin, 1);
    }
  }
#line 109
  if ((int )portfd > 0) {
    {
#line 110
    m_restorestate((int )portfd);
#line 111
    close((int )portfd);
    }
  }
  {
#line 113
  lockfile_remove();
  }
#line 114
  if (mpars[25].value[0]) {
    {
#line 115
    fastsystem(mpars[25].value, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0));
    }
  }
  {
#line 116
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          s___0);
#line 117
  exit(1);
  }
}
}
#line 125 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char buf___5[16]  ;
#line 123 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
char *esc_key(void) 
{ 


  {
#line 127
  if (! alt_override) {
#line 127
    if ((int )mpars[61].value[0] == 94) {
#line 127
      if ((int )mpars[61].value[1] != 91) {
        {
#line 128
        sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"CTRL-%c ",
                (int )mpars[61].value[1]);
        }
#line 129
        return (buf___5);
      }
    }
  }
  {
#line 134
  sprintf((char */* __restrict  */)(buf___5), (char const   */* __restrict  */)"Meta-");
  }
#line 136
  return (buf___5);
}
}
#line 139 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void get_alrm(int dummy ) 
{ 
  int *tmp ;

  {
  {
#line 142
  tmp = __errno_location();
#line 142
  *tmp = 110;
#line 143
  longjmp((struct __jmp_buf_tag *)(albuf), 1);
  }
}
}
#line 150 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void term_socket_connect(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 153
  if (! portfd_is_socket) {
#line 154
    return;
  } else
#line 153
  if (portfd_is_connected) {
#line 154
    return;
  }
  {
#line 156
  tmp = socket(1, 1, 0);
#line 156
  portfd = (short )tmp;
  }
#line 156
  if ((int )portfd == -1) {
#line 157
    return;
  }
  {
#line 159
  tmp___0 = connect((int )portfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& portfd_sock_addr)),
                    (socklen_t )sizeof(portfd_sock_addr));
  }
#line 159
  if (tmp___0 == -1) {
    {
#line 161
    term_socket_close();
    }
  } else {
#line 163
    portfd_is_connected = 1;
  }
#line 164
  return;
}
}
#line 169 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void term_socket_close(void) 
{ 


  {
  {
#line 171
  close((int )portfd);
#line 172
  portfd_is_connected = 0;
#line 173
  portfd = (short)-1;
  }
#line 174
  return;
}
}
#line 182 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
int open_term(int doinit , int show_win_on_error , int no_msgs ) 
{ 
  struct stat stt ;
  union __anonunion_buf_62 buf___6 ;
  int fd ;
  int n ;
  int pid ;
  int s_errno ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 189
  n = 0;
#line 197
  portfd_is_connected = 0;
#line 197
  portfd_is_socket = portfd_is_connected;
#line 198
  tmp = strlen("unix#");
#line 198
  tmp___0 = strncmp((char const   *)dial_tty, "unix#", tmp);
  }
#line 198
  if (tmp___0 == 0) {
#line 199
    portfd_is_socket = 1;
  }
#line 203
  if (portfd_is_socket) {
#line 204
    goto nolock;
  }
#line 208
  if (mpars[27].value[0]) {
    {
#line 208
    tmp___2 = stat((char const   */* __restrict  */)(mpars[27].value), (struct stat */* __restrict  */)(& stt));
    }
#line 208
    if (tmp___2 == 0) {
      {
#line 217
      tmp___1 = mdevlockname(dial_tty, buf___6.bytes, (int )sizeof(buf___6.bytes));
#line 217
      snprintf((char */* __restrict  */)(lockfile), sizeof(lockfile), (char const   */* __restrict  */)"%s/LCK..%s",
               mpars[27].value, tmp___1);
      }
    } else {
#line 224
      lockfile[0] = (char)0;
    }
  } else {
#line 224
    lockfile[0] = (char)0;
  }
#line 226
  if (doinit > 0) {
#line 226
    if (lockfile[0]) {
      {
#line 226
      fd = open((char const   *)(lockfile), 0);
      }
#line 226
      if (fd >= 0) {
        {
#line 227
        tmp___3 = read(fd, (void *)(buf___6.bytes), (size_t )127);
#line 227
        n = (int )tmp___3;
#line 228
        close(fd);
        }
#line 229
        if (n > 0) {
#line 230
          pid = -1;
#line 231
          if (n == 4) {
#line 233
            pid = buf___6.kermit;
          } else {
            {
#line 236
            buf___6.bytes[n] = (char)0;
#line 237
            sscanf((char const   */* __restrict  */)(buf___6.bytes), (char const   */* __restrict  */)"%d",
                   & pid);
            }
          }
#line 239
          if (pid > 0) {
            {
#line 239
            tmp___5 = kill(pid, 0);
            }
#line 239
            if (tmp___5 < 0) {
              {
#line 239
              tmp___6 = __errno_location();
              }
#line 239
              if (*tmp___6 == 3) {
                {
#line 241
                tmp___4 = gettext("Lockfile is stale. Overriding it..\n");
#line 241
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
#line 242
                sleep(1U);
#line 243
                unlink((char const   *)(lockfile));
                }
              } else {
#line 245
                n = 0;
              }
            } else {
#line 245
              n = 0;
            }
          } else {
#line 245
            n = 0;
          }
        }
#line 247
        if (n == 0) {
#line 248
          if (stdwin) {
            {
#line 249
            mc_wclose(stdwin, 1);
            }
          }
          {
#line 250
          tmp___7 = gettext("Device %s is locked.\n");
#line 250
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___7,
                  dial_tty);
          }
#line 251
          return (-1);
        }
      }
    }
  }
#line 256
  if (doinit > 0) {
    {
#line 256
    tmp___8 = lockfile_create(no_msgs);
    }
#line 256
    if (tmp___8 != 0) {
#line 257
      return (-1);
    }
  }
  nolock: 
#line 261
  if (doinit > 0) {
#line 261
    if (mpars[26].value[0]) {
      {
#line 262
      tmp___10 = fastsystem(mpars[26].value, (char *)((void *)0), (char *)((void *)0),
                            (char *)((void *)0));
      }
#line 262
      if (tmp___10 < 0) {
#line 263
        if (stdwin) {
          {
#line 264
          mc_wclose(stdwin, 1);
          }
        }
        {
#line 265
        tmp___9 = gettext("Could not setup for dial out.\n");
#line 265
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9);
#line 266
        lockfile_remove();
        }
#line 267
        return (-1);
      }
    }
  }
  {
#line 272
  tmp___13 = _setjmp((struct __jmp_buf_tag *)(albuf));
  }
#line 272
  if (tmp___13 == 0) {
    {
#line 273
    portfd = (short)-1;
#line 274
    signal(14, & get_alrm);
#line 275
    alarm(20U);
    }
#line 277
    if (portfd_is_socket) {
      {
#line 278
      portfd_sock_addr.sun_family = (sa_family_t )1;
#line 279
      tmp___11 = strlen("unix#");
#line 279
      strncpy((char */* __restrict  */)(portfd_sock_addr.sun_path), (char const   */* __restrict  */)(dial_tty + tmp___11),
              sizeof(portfd_sock_addr.sun_path) - 1UL);
#line 282
      portfd_sock_addr.sun_path[sizeof(portfd_sock_addr.sun_path) - 1UL] = (char)0;
#line 283
      term_socket_connect();
      }
    }
#line 286
    if (! portfd_is_socket) {
      {
#line 288
      tmp___12 = open((char const   *)dial_tty, 2306);
#line 288
      portfd = (short )tmp___12;
      }
#line 289
      if ((int )portfd >= 0) {
        {
#line 291
        n = fcntl((int )portfd, 3, 0);
#line 292
        fcntl((int )portfd, 4, n & -2049);
        }
      }
    }
#line 299
    if ((int )portfd >= 0) {
#line 300
      if (doinit > 0) {
        {
#line 301
        m_savestate((int )portfd);
        }
      }
      {
#line 302
      port_init();
      }
    }
  }
  {
#line 306
  tmp___14 = __errno_location();
#line 306
  s_errno = *tmp___14;
#line 308
  alarm(0U);
#line 309
  signal(14, (void (*)(int  ))1);
  }
#line 310
  if ((int )portfd < 0) {
#line 310
    if (! portfd_is_socket) {
#line 311
      if (! no_msgs) {
#line 312
        if (doinit > 0) {
#line 313
          if (stdwin) {
            {
#line 314
            mc_wclose(stdwin, 1);
            }
          }
          {
#line 316
          tmp___15 = strerror(s_errno);
#line 316
          tmp___16 = gettext("minicom: cannot open %s: %s\n");
#line 316
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                  dial_tty, tmp___15);
#line 321
          lockfile_remove();
          }
#line 322
          return (-1);
        }
#line 325
        if (show_win_on_error) {
          {
#line 326
          tmp___17 = gettext("Cannot open %s!");
#line 326
          werror((char const   *)tmp___17, dial_tty);
          }
        }
      }
      {
#line 329
      lockfile_remove();
      }
#line 330
      return (-1);
    }
  }
  {
#line 334
  m_nohang((int )portfd);
#line 337
  m_hupcl((int )portfd, 1);
  }
#line 338
  if (doinit > 0) {
    {
#line 339
    m_flush((int )portfd);
    }
  }
#line 340
  return (0);
}
}
#line 345 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void do_output(char const   *s___0 , int len ) 
{ 
  char buf___6[256] ;
  size_t tmp ;
  int f ;
  char const   *tmp___0 ;
  int r ;
  int b ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 349
  if (len == 0) {
    {
#line 350
    tmp = strlen(s___0);
#line 350
    len = (int )tmp;
    }
  }
#line 352
  if ((int )mpars[30].value[0] == 77) {
#line 354
    f = 0;
    {
#line 354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 354
      if (f < len) {
#line 354
        if (! (f < (int )sizeof(buf___6))) {
#line 354
          goto while_break;
        }
      } else {
#line 354
        goto while_break;
      }
#line 355
      tmp___0 = s___0;
#line 355
      s___0 ++;
#line 355
      buf___6[f] = (char )((int const   )*tmp___0 | 128);
#line 354
      f ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 356
    len = f;
#line 357
    s___0 = (char const   *)(buf___6);
  }
#line 361
  if (vt_ch_delay) {
#line 361
    tmp___1 = 1;
  } else {
#line 361
    tmp___1 = len;
  }
#line 361
  b = tmp___1;
  {
#line 362
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 362
    if (len) {
      {
#line 362
      tmp___2 = write((int )portfd, (void const   *)s___0, (size_t )b);
#line 362
      r = (int )tmp___2;
      }
#line 362
      if (! (r >= 0)) {
#line 362
        goto while_break___0;
      }
    } else {
#line 362
      goto while_break___0;
    }
#line 364
    s___0 += r;
#line 365
    len -= r;
#line 366
    if (vt_ch_delay) {
      {
#line 367
      usleep((__useconds_t )(vt_ch_delay * 1000));
      }
    } else {
#line 369
      b = len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 374 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void kb_handler(int a , int b ) 
{ 


  {
  {
#line 376
  cursormode = b;
#line 377
  keypadmode = a;
#line 378
  show_status();
  }
#line 379
  return;
}
}
#line 384 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void init_emul(int type , int do_init ) 
{ 
  int x ;
  int y ;
  char attr ;
  int maxy ;
  int ypos ;

  {
#line 386
  x = -1;
#line 386
  y = -1;
#line 387
  attr = (char)0;
#line 391
  if (st) {
    {
#line 392
    mc_wclose(st, 1);
#line 393
    tempst = 0;
#line 394
    st = (WIN *)((void *)0);
    }
  }
#line 397
  if (us) {
    {
#line 398
    x = (int )us->curx;
#line 399
    y = (int )us->cury;
#line 400
    attr = us->attr;
#line 401
    mc_wclose(us, 0);
    }
  }
#line 405
  maxy = LINES - 1;
#line 406
  if (use_status) {
#line 406
    goto _L;
  } else
#line 406
  if (LINES > 24) {
    _L: /* CIL Label */ 
#line 406
    if ((int )mpars[63].value[0] == 101) {
#line 408
      if (use_status) {
#line 409
        ypos = LINES;
#line 410
        maxy = LINES - 1;
      } else {
#line 412
        ypos = LINES - 1;
#line 413
        maxy = LINES - 2;
      }
      {
#line 415
      st = mc_wopen(0, ypos, COLS - 1, ypos, 0, st_attr, sfcolor, sbcolor, 1, 0, 1);
#line 417
      mc_wredraw(st, 1);
      }
    }
  }
  {
#line 421
  num_hist_lines = atoi((char const   *)(mpars[78].value));
  }
#line 422
  if (num_hist_lines < 0) {
#line 423
    num_hist_lines = 0;
  }
#line 424
  if (num_hist_lines > 5000) {
#line 425
    num_hist_lines = 5000;
  }
  {
#line 428
  us = mc_wopen(0, 0, COLS - 1, maxy, 0, 0, tfcolor, tbcolor, 1, num_hist_lines, 0);
  }
#line 431
  if (x >= 0) {
    {
#line 432
    mc_wlocate(us, x, y);
#line 433
    us->attr = attr;
    }
  }
#line 436
  us->autocr = (char)0;
#line 437
  us->wrap = (char )wrapln;
#line 439
  terminal = (short )type;
#line 440
  lines = (short )(LINES - ((unsigned long )st != (unsigned long )((void *)0)));
#line 441
  cols = (short )COLS;
#line 444
  if (do_init) {
    {
#line 445
    vt_install(& do_output, & kb_handler, us);
#line 446
    vt_init(type, tfcolor, tbcolor, (int )us->wrap, addlf, addcr);
    }
  } else {
    {
#line 448
    vt_pinit(us, -1, -1);
    }
  }
  {
#line 450
  show_status();
  }
#line 451
  return;
}
}
#line 457 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void ret_csr(void) 
{ 


  {
  {
#line 459
  mc_wlocate(us, (int )us->curx, (int )us->cury);
#line 460
  mc_wflush();
  }
#line 461
  return;
}
}
#line 470 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static int get_device_status(int fd ) 
{ 
  struct termios t ;
  int tmp ;
  int tmp___0 ;

  {
#line 473
  if (fd < 0) {
#line 474
    return (0);
  }
#line 475
  if (portfd_is_socket) {
#line 475
    if (portfd_is_connected) {
#line 476
      return (1);
    }
  }
  {
#line 477
  tmp = tcgetattr(fd, & t);
  }
#line 477
  if (tmp) {
#line 477
    tmp___0 = 0;
  } else {
#line 477
    tmp___0 = 1;
  }
#line 477
  return (tmp___0);
}
}
#line 481 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char status_message[80]  ;
#line 482 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static int status_display_msg_until  ;
#line 483 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static int status_message_showing  ;
#line 485 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char const   default_statusline_format[50]  = 
#line 485
  {      (char const   )'%',      (char const   )'H',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'l',      (char const   )'p',      (char const   )' ', 
        (char const   )'|',      (char const   )' ',      (char const   )'%',      (char const   )'b', 
        (char const   )' ',      (char const   )'|',      (char const   )' ',      (char const   )'%', 
        (char const   )'C',      (char const   )' ',      (char const   )'|',      (char const   )' ', 
        (char const   )'M',      (char const   )'i',      (char const   )'n',      (char const   )'i', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )' ', 
        (char const   )'%',      (char const   )'V',      (char const   )' ',      (char const   )'|', 
        (char const   )' ',      (char const   )'%',      (char const   )'T',      (char const   )' ', 
        (char const   )'|',      (char const   )' ',      (char const   )'%',      (char const   )'t', 
        (char const   )' ',      (char const   )'|',      (char const   )' ',      (char const   )'%', 
        (char const   )'D',      (char const   )'\000'};
#line 487 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char const   *statusline_format  =    default_statusline_format;
#line 489 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void set_status_line_format(char const   *s___0 ) 
{ 


  {
#line 491
  statusline_format = s___0;
#line 492
  return;
}
}
#line 497 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void show_status_fmt(char const   *fmt___0 ) 
{ 
  char *buf___6 ;
  unsigned long __lengthofbuf___0 ;
  void *tmp ;
  int bufi ;
  int l ;
  size_t tmp___0 ;
  int i ;
  char func ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *b ;
  unsigned long __lengthofb ;
  void *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 499
  if (! st) {
#line 500
    return;
  }
  {
#line 502
  __lengthofbuf___0 = (unsigned long )COLS;
#line 502
  tmp = __builtin_alloca(sizeof(*buf___6) * __lengthofbuf___0);
#line 502
  buf___6 = (char *)tmp;
#line 503
  bufi = 0;
#line 504
  tmp___0 = strlen(fmt___0);
#line 504
  l = (int )tmp___0;
#line 505
  i = 0;
  }
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (i < l) {
#line 505
      if (! (bufi < COLS)) {
#line 505
        goto while_break;
      }
    } else {
#line 505
      goto while_break;
    }
#line 507
    if ((int const   )*(fmt___0 + i) == 37) {
#line 507
      if (i + 1 < l) {
#line 509
        func = (char )*(fmt___0 + (i + 1));
#line 510
        i ++;
        {
#line 514
        if ((int )func == 37) {
#line 514
          goto case_37;
        }
#line 517
        if ((int )func == 72) {
#line 517
          goto case_72;
        }
#line 520
        if ((int )func == 86) {
#line 520
          goto case_86;
        }
#line 523
        if ((int )func == 98) {
#line 523
          goto case_98;
        }
#line 535
        if ((int )func == 84) {
#line 535
          goto case_84;
        }
#line 547
        if ((int )func == 67) {
#line 547
          goto case_67;
        }
#line 551
        if ((int )func == 116) {
#line 551
          goto case_116;
        }
#line 561
        if ((int )func == 68) {
#line 561
          goto case_68;
        }
#line 569
        if ((int )func == 36) {
#line 569
          goto case_36;
        }
#line 573
        goto switch_default;
        case_37: /* CIL Label */ 
        {
#line 515
        tmp___1 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                           (char const   */* __restrict  */)"%%");
#line 515
        bufi += tmp___1;
        }
#line 516
        goto switch_break;
        case_72: /* CIL Label */ 
        {
#line 518
        tmp___2 = esc_key();
#line 518
        tmp___3 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                           (char const   */* __restrict  */)"%sZ", tmp___2);
#line 518
        bufi += tmp___3;
        }
#line 519
        goto switch_break;
        case_86: /* CIL Label */ 
        {
#line 521
        tmp___4 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                           (char const   */* __restrict  */)"%s", "2.7");
#line 521
        bufi += tmp___4;
        }
#line 522
        goto switch_break;
        case_98: /* CIL Label */ 
#line 524
        if (portfd_is_socket) {
          {
#line 525
          tmp___5 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                             (char const   */* __restrict  */)"unix-socket");
#line 525
          bufi += tmp___5;
          }
        } else {
#line 528
          if ((int )mpars[57].value[0] == 108) {
            {
#line 529
            tmp___6 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                               (char const   */* __restrict  */)"%6ld", linespd);
#line 529
            bufi += tmp___6;
            }
          } else {
            {
#line 531
            tmp___7 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                               (char const   */* __restrict  */)"%s", mpars[28].value);
#line 531
            bufi += tmp___7;
            }
          }
          {
#line 532
          tmp___8 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                             (char const   */* __restrict  */)" %s%s%s", mpars[29].value,
                             mpars[30].value, mpars[31].value);
#line 532
          bufi += tmp___8;
          }
        }
#line 534
        goto switch_break;
        case_84: /* CIL Label */ 
        {
#line 538
        if ((int )terminal == 1) {
#line 538
          goto case_1;
        }
#line 541
        if ((int )terminal == 3) {
#line 541
          goto case_3;
        }
#line 536
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 539
        tmp___9 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                           (char const   */* __restrict  */)"VT102");
#line 539
        bufi += tmp___9;
        }
#line 540
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 542
        tmp___10 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                            (char const   */* __restrict  */)"ANSI");
#line 542
        bufi += tmp___10;
        }
#line 543
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 546
        goto switch_break;
        case_67: /* CIL Label */ 
#line 548
        if (cursormode == 1) {
#line 548
          tmp___11 = "NOR";
        } else {
#line 548
          tmp___11 = "APP";
        }
        {
#line 548
        tmp___12 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                            (char const   */* __restrict  */)tmp___11);
#line 548
        bufi += tmp___12;
        }
#line 549
        goto switch_break;
        case_116: /* CIL Label */ 
#line 552
        if (online < 0L) {
#line 553
          if ((int )mpars[64].value[0] == 89) {
            {
#line 553
            tmp___13 = gettext("Offline");
#line 553
            tmp___15 = tmp___13;
            }
          } else {
            {
#line 553
            tmp___14 = gettext("OFFLINE");
#line 553
            tmp___15 = tmp___14;
            }
          }
          {
#line 553
          tmp___16 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                              (char const   */* __restrict  */)"%s", tmp___15);
#line 553
          bufi += tmp___16;
          }
        } else {
#line 556
          if ((int )mpars[64].value[0] == 89) {
            {
#line 556
            tmp___17 = gettext("Online");
#line 556
            tmp___19 = tmp___17;
            }
          } else {
            {
#line 556
            tmp___18 = gettext("ONLINE");
#line 556
            tmp___19 = tmp___18;
            }
          }
          {
#line 556
          tmp___20 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                              (char const   */* __restrict  */)"%s %ld:%ld", tmp___19,
                              online / 3600L, (online / 60L) % 60L);
#line 556
          bufi += tmp___20;
          }
        }
#line 559
        goto switch_break;
        case_68: /* CIL Label */ 
        {
#line 563
        __lengthofb = (unsigned long )(COLS - bufi);
#line 563
        tmp___21 = __builtin_alloca(sizeof(*b) * __lengthofb);
#line 563
        b = (char *)tmp___21;
#line 564
        tmp___22 = shortened_devpath(b, (int )(sizeof(*b) * __lengthofb), mpars[24].value);
#line 564
        tmp___23 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                            (char const   */* __restrict  */)"%s", tmp___22);
#line 564
        bufi += tmp___23;
        }
#line 567
        goto switch_break;
        case_36: /* CIL Label */ 
        {
#line 570
        tmp___24 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                            (char const   */* __restrict  */)"%s", status_message);
#line 570
        bufi += tmp___24;
        }
#line 571
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 574
        tmp___25 = snprintf((char */* __restrict  */)(buf___6 + bufi), (size_t )(COLS - bufi),
                            (char const   */* __restrict  */)"?%c", (int )func);
#line 574
        bufi += tmp___25;
        }
#line 575
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 580
        *(buf___6 + bufi) = (char )*(fmt___0 + i);
#line 581
        bufi ++;
      }
    } else {
#line 580
      *(buf___6 + bufi) = (char )*(fmt___0 + i);
#line 581
      bufi ++;
    }
#line 505
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  if (bufi < COLS - 1) {
    {
#line 586
    memset((void *)(buf___6 + bufi), ' ', (size_t )(COLS - bufi));
    }
  }
  {
#line 587
  *(buf___6 + (COLS - 1)) = (char)0;
#line 589
  st->direct = (char)0;
#line 590
  mc_wlocate(st, 0, 0);
#line 591
  mc_wprintf(st, "%s", buf___6);
#line 592
  mc_wredraw(st, 1);
#line 593
  ret_csr();
  }
#line 594
  return;
}
}
#line 596 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void show_status(void) 
{ 


  {
  {
#line 598
  show_status_fmt(statusline_format);
  }
#line 599
  return;
}
}
#line 601 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
time_t old_online  =    (time_t )-2;
#line 606 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void update_status_time(void) 
{ 
  time_t now ;
  char *tmp ;

  {
  {
#line 609
  time(& now);
  }
#line 611
  if (status_message_showing) {
#line 613
    if (now > (time_t )status_display_msg_until) {
      {
#line 616
      status_message_showing = 0;
#line 617
      show_status();
      }
    } else {
      {
#line 620
      show_status_fmt("%$");
      }
    }
  }
#line 623
  if (old_online == online) {
#line 624
    return;
  } else
#line 623
  if (online <= old_online + 59L) {
#line 624
    return;
  }
#line 626
  if ((int )mpars[84].value[0] == 89) {
#line 626
    if (old_online >= 0L) {
#line 626
      if (online < 0L) {
        {
#line 627
        tmp = gettext("Gone offline (%ld:%02ld:%02ld)");
#line 627
        do_log((char const   *)tmp, old_online / 3600L, (old_online / 60L) % 60L,
               old_online % 60L);
        }
      }
    }
  }
#line 630
  old_online = online;
#line 632
  if (! status_message_showing) {
    {
#line 633
    show_status();
    }
  }
  {
#line 634
  mc_wflush();
  }
#line 635
  return;
}
}
#line 637 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void status_set_display(char const   *text , int duration_s ) 
{ 
  time_t t ;
  unsigned int l ;
  size_t tmp ;

  {
  {
#line 641
  strncpy((char */* __restrict  */)(status_message), (char const   */* __restrict  */)text,
          sizeof(status_message));
#line 642
  status_message[sizeof(status_message) - 1UL] = (char)0;
#line 643
  tmp = strlen((char const   *)(status_message));
#line 643
  l = (unsigned int )tmp;
  }
  {
#line 644
  while (1) {
    while_continue: /* CIL Label */ ;
#line 644
    if (! ((unsigned long )l < sizeof(status_message) - 1UL)) {
#line 644
      goto while_break;
    }
#line 645
    status_message[l] = (char )' ';
#line 644
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  if (duration_s == 0) {
#line 648
    duration_s = 2;
  }
  {
#line 650
  time(& t);
#line 651
  status_display_msg_until = (int )((time_t )duration_s + t);
#line 652
  status_message_showing = 1;
  }
#line 653
  return;
}
}
#line 658 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static time_t t1  ;
#line 658 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static time_t start___0  ;
#line 656 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void timer_update(void) 
{ 
  int dcd_support ;
  int tmp ;

  {
#line 659
  dcd_support = (int )mpars[64].value[0] == 89;
#line 662
  if (! dcd_support) {
#line 662
    if (bogus_dcd) {
#line 662
      goto _L;
    } else {
#line 662
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 662
  if (dcd_support) {
    {
#line 662
    tmp = m_getdcd((int )portfd);
    }
#line 662
    if (tmp == 1) {
      _L: /* CIL Label */ 
#line 665
      if (online < 0L) {
        {
#line 667
        time(& start___0);
#line 668
        t1 = start___0;
#line 669
        online = (time_t )0;
        }
      }
    } else {
#line 662
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 684
    if (online >= 0L) {
#line 684
      if (old_online >= 0L) {
        {
#line 686
        time(& t1);
#line 687
        online = t1 - start___0;
        }
      }
    }
#line 690
    online = (time_t )-1;
  }
#line 694
  if (online >= 0L) {
    {
#line 695
    time(& t1);
#line 696
    online = t1 - start___0;
    }
  }
  {
#line 699
  update_status_time();
  }
#line 700
  return;
}
}
#line 706 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
void scriptname(char const   *s___0 ) 
{ 


  {
#line 708
  if ((unsigned long )st == (unsigned long )((void *)0)) {
#line 709
    return;
  }
  {
#line 710
  mc_wlocate(st, 39, 0);
  }
#line 711
  if ((int const   )*s___0 == 0) {
    {
#line 712
    mc_wprintf(st, "Minicom %-6.6s", "2.7");
    }
  } else {
    {
#line 714
    mc_wprintf(st, "script %-7.7s", s___0);
    }
  }
  {
#line 715
  ret_csr();
  }
#line 716
  return;
}
}
#line 721 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static void showtemp(void) 
{ 


  {
#line 723
  if (st) {
#line 724
    return;
  }
  {
#line 726
  st = mc_wopen(0, LINES - 1, COLS - 1, LINES - 1, 0, st_attr, sfcolor, sbcolor, 1,
                0, 1);
#line 728
  show_status();
#line 729
  tempst = 1;
  }
#line 730
  return;
}
}
#line 745 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
static char const   zsig[7]  = {      (char const   )'*',      (char const   )'*',      (char const   )'\030',      (char const   )'B', 
        (char const   )'0',      (char const   )'0',      (char const   )'\000'};
#line 737 "/home/wheatley/newnew/temp/minicom-2.7/src/main.c"
int do_terminal(void) 
{ 
  char buf___6[128] ;
  int buf_offset ;
  int c___0 ;
  int x ;
  int blen ;
  int zauto ;
  int zpos ;
  char const   *s___0 ;
  WIN *error_on_open_window ;
  char *tmp ;
  int tmp___0 ;
  int reopen ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char obuf[sizeof(buf___6)] ;
  char *ptr___1 ;
  char *otmp ;
  size_t output_len ;
  size_t input_len ;
  int tmp___6 ;
  unsigned char c___1 ;
  char *tmp___7 ;
  unsigned char u ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 740
  buf_offset = 0;
#line 744
  zauto = 0;
#line 746
  zpos = 0;
#line 748
  dirflush = 0;
#line 749
  error_on_open_window = (WIN *)((void *)0);
  dirty_goto: 
  {
#line 753
  update_status_time();
  }
#line 756
  if (tempst) {
    {
#line 757
    tempst = 0;
#line 758
    mc_wclose(st, 1);
#line 759
    st = (WIN *)((void *)0);
    }
  }
#line 764
  if ((int )mpars[67].value[0] >= 65) {
#line 764
    if ((int )mpars[67].value[0] <= 90) {
#line 765
      zauto = (int )mpars[67].value[0];
    }
  }
  {
#line 767
  setcbreak(2);
#line 769
  keyboard(6, 0);
  }
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (size_changed) {
      {
#line 775
      size_changed = 0;
#line 776
      wrapln = (int )us->wrap;
#line 778
      mc_wclose(us, 0);
#line 779
      us = (WIN *)((void *)0);
      }
#line 780
      if (st) {
        {
#line 781
        mc_wclose(st, 0);
        }
      }
      {
#line 782
      st = (WIN *)((void *)0);
#line 783
      mc_wclose(stdwin, 0);
#line 784
      tmp___0 = win_init(tfcolor, tbcolor, 0);
      }
#line 784
      if (tmp___0 < 0) {
        {
#line 785
        tmp = gettext("Could not re-initialize window system.");
#line 785
        leave((char const   *)tmp);
        }
      }
      {
#line 787
      setcbreak(2);
#line 788
      init_emul((int )terminal, 0);
      }
    }
    {
#line 791
    timer_update();
    }
#line 794
    if (portfd_is_socket) {
#line 794
      if (! portfd_is_connected) {
#line 794
        tmp___3 = -1;
      } else {
#line 794
        tmp___3 = (int )portfd;
      }
    } else {
#line 794
      tmp___3 = (int )portfd;
    }
    {
#line 794
    tmp___4 = get_device_status(tmp___3);
    }
#line 794
    if (! tmp___4) {
      {
#line 798
      reopen = (int )portfd == -1;
#line 799
      close((int )portfd);
#line 800
      lockfile_remove();
#line 801
      portfd = (short)-1;
#line 802
      tmp___2 = open_term(reopen, reopen, 1);
      }
#line 802
      if (tmp___2 < 0) {
#line 803
        if (! error_on_open_window) {
          {
#line 804
          tmp___1 = gettext("Cannot open %s!");
#line 804
          error_on_open_window = mc_tell((char const   *)tmp___1, dial_tty);
          }
        }
      } else
#line 806
      if (error_on_open_window) {
        {
#line 807
        mc_wclose(error_on_open_window, 1);
#line 808
        error_on_open_window = (WIN *)((void *)0);
        }
      }
    }
#line 814
    if (portfd_is_socket) {
#line 814
      if (! portfd_is_connected) {
#line 814
        tmp___5 = -1;
      } else {
#line 814
        tmp___5 = (int )portfd;
      }
    } else {
#line 814
      tmp___5 = (int )portfd;
    }
    {
#line 814
    x = check_io(tmp___5, 0, 1000, buf___6 + buf_offset, (int )(sizeof(buf___6) - (unsigned long )buf_offset),
                 & blen);
#line 816
    blen += buf_offset;
#line 817
    buf_offset = 0;
    }
#line 820
    if ((x & 1) == 1) {
      {
#line 824
      tmp___6 = using_iconv();
      }
#line 824
      if (tmp___6) {
        {
#line 825
        otmp = obuf;
#line 826
        output_len = sizeof(obuf);
#line 827
        input_len = (size_t )blen;
#line 829
        ptr___1 = buf___6;
#line 830
        do_iconv(& ptr___1, & input_len, & otmp, & output_len);
        }
#line 833
        if (output_len < sizeof(obuf)) {
#line 835
          if (input_len) {
            {
#line 837
            memmove((void *)(buf___6), (void const   *)ptr___1, input_len);
#line 838
            buf_offset = (int )input_len;
            }
          }
#line 841
          blen = (int )(sizeof(obuf) - output_len);
#line 842
          ptr___1 = obuf;
        } else {
#line 845
          ptr___1 = buf___6;
        }
      } else {
#line 847
        ptr___1 = buf___6;
      }
      {
#line 850
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 850
        tmp___11 = blen;
#line 850
        blen --;
#line 850
        if (! (tmp___11 > 0)) {
#line 850
          goto while_break___0;
        }
#line 852
        if (zauto) {
#line 853
          if ((int const   )zsig[zpos] == (int const   )*ptr___1) {
#line 854
            zpos ++;
          } else {
#line 856
            zpos = 0;
          }
        }
#line 858
        if ((int )mpars[30].value[0] == 77) {
#line 859
          *ptr___1 = (char )((int )*ptr___1 & 127);
        } else
#line 858
        if ((int )mpars[30].value[0] == 83) {
#line 859
          *ptr___1 = (char )((int )*ptr___1 & 127);
        }
#line 860
        if (display_hex) {
#line 861
          tmp___7 = ptr___1;
#line 861
          ptr___1 ++;
#line 861
          c___1 = (unsigned char )*tmp___7;
#line 862
          u = (unsigned char )((int )c___1 >> 4);
#line 863
          c___1 = (unsigned char )((int )c___1 & 15);
#line 864
          if ((int )u > 9) {
#line 864
            tmp___8 = 97 + ((int )u - 10);
          } else {
#line 864
            tmp___8 = 48 + (int )u;
          }
          {
#line 864
          vt_out(tmp___8);
          }
#line 865
          if ((int )c___1 > 9) {
#line 865
            tmp___9 = 97 + ((int )c___1 - 10);
          } else {
#line 865
            tmp___9 = 48 + (int )c___1;
          }
          {
#line 865
          vt_out(tmp___9);
#line 866
          vt_out(' ');
          }
        } else {
          {
#line 868
          tmp___10 = ptr___1;
#line 868
          ptr___1 ++;
#line 868
          vt_out((int )*tmp___10);
          }
        }
#line 869
        if (zauto) {
#line 869
          if ((int const   )zsig[zpos] == 0) {
            {
#line 870
            dirflush = 1;
#line 871
            keyboard(1, 0);
#line 872
            updown('D', zauto - 65);
#line 873
            dirflush = 0;
#line 874
            zpos = 0;
#line 875
            blen = 0;
            }
#line 876
            goto dirty_goto;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 879
      mc_wflush();
      }
    }
#line 883
    if ((x & 2) == 2) {
      {
#line 885
      c___0 = keyboard(13, 0);
      }
#line 886
      if (c___0 == -1) {
#line 887
        return (-1);
      }
#line 889
      if (c___0 < 0) {
#line 890
        c___0 += 256;
      }
#line 893
      if (escape == 128) {
#line 893
        if (c___0 > 224) {
#line 893
          if (c___0 < 252) {
#line 893
            goto _L;
          } else {
#line 893
            goto _L___2;
          }
        } else {
#line 893
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 893
      if (escape != 27) {
#line 893
        if (c___0 == escape) {
#line 893
          goto _L;
        } else {
#line 893
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 893
      if (c___0 > 512) {
        _L: /* CIL Label */ 
        {
#line 898
        keyboard(1, 0);
#line 901
        showtemp();
        }
#line 902
        if (c___0 == escape) {
          {
#line 903
          c___0 = keyboard(13, 0);
          }
        }
        {
#line 906
        setcbreak(1);
        }
#line 908
        if (c___0 > 512) {
#line 909
          c___0 -= 512;
        }
#line 910
        if (c___0 > 128) {
#line 911
          c___0 -= 128;
        }
#line 912
        if (c___0 > 32) {
          {
#line 913
          dirflush = 1;
#line 914
          m_flush(0);
          }
#line 915
          return (c___0);
        }
        {
#line 921
        vt_send(c___0);
        }
#line 923
        goto dirty_goto;
      }
#line 927
      if (c___0 >= 257) {
#line 927
        if (c___0 <= 266) {
#line 927
          if ((int )mpars[76].value[0] == 89) {
#line 928
            s___0 = "";
            {
#line 930
            if (c___0 == 257) {
#line 930
              goto case_257;
            }
#line 931
            if (c___0 == 258) {
#line 931
              goto case_258;
            }
#line 932
            if (c___0 == 259) {
#line 932
              goto case_259;
            }
#line 933
            if (c___0 == 260) {
#line 933
              goto case_260;
            }
#line 934
            if (c___0 == 261) {
#line 934
              goto case_261;
            }
#line 935
            if (c___0 == 262) {
#line 935
              goto case_262;
            }
#line 936
            if (c___0 == 263) {
#line 936
              goto case_263;
            }
#line 937
            if (c___0 == 264) {
#line 937
              goto case_264;
            }
#line 938
            if (c___0 == 265) {
#line 938
              goto case_265;
            }
#line 939
            if (c___0 == 266) {
#line 939
              goto case_266;
            }
#line 929
            goto switch_break;
            case_257: /* CIL Label */ 
#line 930
            s___0 = (char const   *)(mmacs[0].value);
#line 930
            goto switch_break;
            case_258: /* CIL Label */ 
#line 931
            s___0 = (char const   *)(mmacs[1].value);
#line 931
            goto switch_break;
            case_259: /* CIL Label */ 
#line 932
            s___0 = (char const   *)(mmacs[2].value);
#line 932
            goto switch_break;
            case_260: /* CIL Label */ 
#line 933
            s___0 = (char const   *)(mmacs[3].value);
#line 933
            goto switch_break;
            case_261: /* CIL Label */ 
#line 934
            s___0 = (char const   *)(mmacs[4].value);
#line 934
            goto switch_break;
            case_262: /* CIL Label */ 
#line 935
            s___0 = (char const   *)(mmacs[5].value);
#line 935
            goto switch_break;
            case_263: /* CIL Label */ 
#line 936
            s___0 = (char const   *)(mmacs[6].value);
#line 936
            goto switch_break;
            case_264: /* CIL Label */ 
#line 937
            s___0 = (char const   *)(mmacs[7].value);
#line 937
            goto switch_break;
            case_265: /* CIL Label */ 
#line 938
            s___0 = (char const   *)(mmacs[8].value);
#line 938
            goto switch_break;
            case_266: /* CIL Label */ 
#line 939
            s___0 = (char const   *)(mmacs[9].value);
#line 939
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
#line 941
            if (*s___0) {
              {
#line 942
              mputs(s___0, 1);
              }
            } else {
              {
#line 944
              vt_send(c___0);
              }
            }
          } else {
            {
#line 946
            vt_send(c___0);
            }
          }
        } else {
          {
#line 946
          vt_send(c___0);
          }
        }
      } else {
        {
#line 946
        vt_send(c___0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 106 "../lib/getopt.h"
extern int getopt(int argc , char * const  *argv , char const   *shortopts ) ;
#line 86 "/usr/include/termios.h"
extern int tcdrain(int __fd ) ;
#line 40 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int cdelay  =    0;
#line 41 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int ldelay  =    0;
#line 42 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int dotrans  =    1;
#line 43 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int eofchar  =    26;
#line 44 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int useeof  =    0;
#line 45 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int verbose  =    0;
#line 46 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
time_t start  ;
#line 46 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
time_t last  ;
#line 47 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
unsigned long bdone  =    0UL;
#line 52 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
void ms_delay(int ms ) 
{ 


  {
  {
#line 55
  usleep((__useconds_t )(1000 * ms));
  }
#line 57
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
static void lineout(char const   *line , int len ) 
{ 
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 66
  if (! cdelay) {
    {
#line 67
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 68
      tmp = write(1, (void const   *)line, (size_t )len);
#line 68
      ret = (int )tmp;
      }
#line 69
      if (ret < 0) {
        {
#line 70
        tmp___0 = __errno_location();
#line 70
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error while writing (errno = %d)\n",
                *tmp___0);
        }
#line 71
        return;
      }
#line 73
      len -= ret;
#line 74
      line += ret;
#line 67
      if (! len) {
#line 67
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! *line) {
#line 78
        goto while_break___0;
      }
      {
#line 79
      tmp___1 = write(1, (void const   *)line, (size_t )1);
#line 79
      ret = (int )tmp___1;
      }
#line 80
      if (ret < 0) {
        {
#line 81
        tmp___2 = __errno_location();
#line 81
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error while writing (errno = %d)\n",
                *tmp___2);
        }
#line 82
        return;
      }
#line 84
      if (ret == 1) {
#line 85
        line ++;
      }
      {
#line 86
      ms_delay(cdelay);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 89
  return;
}
}
#line 94 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
void stats(int force ) 
{ 
  time_t now ;
  time_t dif ;

  {
#line 99
  if (! verbose) {
#line 100
    return;
  }
  {
#line 102
  time(& now);
#line 103
  dif = now - start;
  }
#line 105
  if (! force) {
#line 105
    if (dif < 2L) {
#line 106
      return;
    }
  }
#line 107
  if (dif < 1L) {
#line 108
    dif = (time_t )1;
  }
  {
#line 109
  last = now;
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r%.1f Kbytes transferred at %d CPS",
          (double )((float )bdone / (float )1024), (int )(bdone / (unsigned long )dif));
#line 113
  fflush(stderr);
  }
#line 114
  return;
}
}
#line 116 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
void check_answer(void) 
{ 
  char line[1024] ;
  int n ;
  fd_set rfds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___1 ;

  {
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.fds_bits[0]): "memory");
#line 123
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  rfds.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 125
  tv.tv_sec = (__time_t )0;
#line 126
  tv.tv_usec = (__suseconds_t )0;
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 127
    tmp___1 = select(1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
#line 127
    if (! (tmp___1 > 0)) {
#line 127
      goto while_break___0;
    }
    {
#line 128
    tmp = read(0, (void *)(line), sizeof(line));
#line 128
    n = (int )tmp;
#line 129
    tmp___0 = write(2, (void const   *)(line), (size_t )n);
    }
#line 129
    if (tmp___0 == -1L) {
#line 130
      goto while_break___0;
    }
    {
#line 131
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 131
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.fds_bits[0]): "memory");
#line 131
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 132
    rfds.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 133
    tv.tv_sec = (__time_t )0;
#line 134
    tv.tv_usec = (__suseconds_t )0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 141 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int asend(char *file ) 
{ 
  FILE *fp ;
  char line[1024] ;
  char *s___0 ;
  int first___0 ;
  long cur___1 ;
  long len ;
  long c___0 ;
  long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 146
  first___0 = 1;
#line 149
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 149
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 150
    perror((char const   *)file);
    }
#line 151
    return (-1);
  }
#line 154
  cur___1 = 0L;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___2 = fgets((char */* __restrict  */)(line), (int )(sizeof(line) - 2UL), (FILE */* __restrict  */)fp);
    }
#line 156
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 156
      goto while_break;
    }
    {
#line 157
    tmp = ftell(fp);
#line 157
    c___0 = tmp;
#line 158
    len = c___0 - cur___1;
#line 159
    cur___1 = c___0;
    }
#line 160
    if (dotrans) {
      {
#line 160
      s___0 = strrchr((char const   *)(line), '\n');
      }
#line 160
      if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
#line 163
        if ((unsigned long )s___0 > (unsigned long )(line)) {
#line 163
          if ((int )*(s___0 - 1) == 13) {
#line 165
            s___0 --;
#line 166
            len --;
          }
        }
#line 169
        tmp___0 = s___0;
#line 169
        s___0 ++;
#line 169
        *tmp___0 = (char )'\r';
#line 170
        tmp___1 = s___0;
#line 170
        s___0 ++;
#line 170
        *tmp___1 = (char )'\n';
#line 172
        *s___0 = (char)0;
#line 173
        len ++;
      }
    }
    {
#line 175
    lineout((char const   *)(line), (int )len);
#line 176
    bdone += (unsigned long )len;
    }
#line 177
    if (ldelay) {
      {
#line 178
      ms_delay(ldelay);
      }
    }
    {
#line 179
    stats(first___0);
#line 180
    first___0 = 0;
#line 181
    check_answer();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (useeof) {
    {
#line 184
    putchar(eofchar);
    }
  }
  {
#line 185
  fflush(stdout);
#line 186
  tmp___3 = isatty(1);
  }
#line 186
  if (tmp___3) {
    {
#line 187
    tcdrain(1);
    }
  }
  {
#line 188
  fclose(fp);
  }
#line 190
  return (0);
}
}
#line 196 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
int arecv(char *file ) 
{ 
  FILE *fp ;
  char line[1024] ;
  char *s___0 ;
  int n ;
  int first___0 ;
  int tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 202
  first___0 = 1;
#line 204
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 204
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 205
    perror((char const   *)file);
    }
#line 206
    return (-1);
  }
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 209
    tmp___0 = read(0, (void *)(line), sizeof(line));
#line 209
    n = (int )tmp___0;
    }
#line 209
    if (! (n > 0)) {
#line 209
      goto while_break;
    }
#line 210
    s___0 = line;
    {
#line 210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 210
      tmp = n;
#line 210
      n --;
#line 210
      if (! (tmp > 0)) {
#line 210
        goto while_break___0;
      }
#line 211
      if ((int )*s___0 == eofchar) {
#line 212
        goto while_break___0;
      }
#line 213
      if (dotrans) {
#line 213
        if ((int )*s___0 == 13) {
#line 214
          goto __Cont;
        }
      }
      {
#line 215
      bdone ++;
#line 216
      fputc((int )*s___0, fp);
      }
      __Cont: /* CIL Label */ 
#line 210
      s___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 218
    stats(first___0);
#line 219
    first___0 = 0;
    }
#line 220
    if ((int )*s___0 == eofchar) {
#line 221
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  fclose(fp);
  }
#line 225
  return (0);
}
}
#line 228 "/home/wheatley/newnew/temp/minicom-2.7/src/ascii-xfr.c"
void usage(void) 
{ 


  {
  {
#line 230
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: ascii-xfr -s|-r [-dvn] [-l linedelay] [-c character delay] filename\n       -s:  send\n       -r:  receive\n       -e:  send the End Of File character (default is not to)\n       -d:  set End Of File character to Control-D (instead of Control-Z)\n       -v:  verbose (statistics on stderr output)\n       -n:  do not translate CRLF <--> LF\n       Delays are in milliseconds.\n");
#line 239
  exit(1);
  }
}
}
