/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 26 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
struct __anonstruct_Header_51 {
   short Unknown ;
   short NumItems ;
   short NumActions ;
   short NumWords ;
   short NumRooms ;
   short MaxCarry ;
   short PlayerRoom ;
   short Treasures ;
   short WordLength ;
   short LightTime ;
   short NumMessages ;
   short TreasureRoom ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
typedef struct __anonstruct_Header_51 Header;
#line 42 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
struct __anonstruct_Action_52 {
   unsigned short Vocab ;
   unsigned short Condition[5] ;
   unsigned short Action[2] ;
};
#line 42 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
typedef struct __anonstruct_Action_52 Action;
#line 49 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
struct __anonstruct_Room_53 {
   char *Text ;
   short Exits[6] ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
typedef struct __anonstruct_Room_53 Room;
#line 55 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
struct __anonstruct_Item_54 {
   char *Text ;
   unsigned char Location ;
   unsigned char InitialLoc ;
   char *AutoGet ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
typedef struct __anonstruct_Item_54 Item;
#line 64 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
struct __anonstruct_Tail_55 {
   short Version ;
   short AdventureNumber ;
   short Unknown ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/Scott.h"
typedef struct __anonstruct_Tail_55 Tail;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 627
extern int idlok(WINDOW * , _Bool  ) ;
#line 632
extern WINDOW *initscr(void) ;
#line 649
extern int leaveok(WINDOW * , _Bool  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 832
extern int wscrl(WINDOW * , int  ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
Header GameHeader  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
Tail GameTail  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
Item *Items  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
Room *Rooms  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char **Verbs  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char **Nouns  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char **Messages  ;
#line 82 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
Action *Actions  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int LightRefill  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char NounText[16]  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int Counters[16]  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int CurrentCounter  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int SavedRoom  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int RoomSaved[16]  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int DisplayUp  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
WINDOW *Top  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
WINDOW *Bottom  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int Redraw  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int Options  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int Width  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int TopHeight  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int BottomHeight  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
long BitFlags  =    0L;
#line 103 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void Fatal(char *x ) 
{ 


  {
#line 105
  if (DisplayUp) {
    {
#line 106
    endwin();
    }
  }
  {
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.\n",
          x);
#line 108
  exit(1);
  }
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void Aborted(void) 
{ 


  {
  {
#line 113
  Fatal((char *)"User exit");
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void ClearScreen(void) 
{ 


  {
  {
#line 118
  werase(Bottom);
#line 119
  wrefresh(Bottom);
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void *MemAlloc(int size ) 
{ 
  void *t ;
  void *tmp ;

  {
  {
#line 124
  tmp = malloc((size_t )size);
#line 124
  t = tmp;
  }
#line 125
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
#line 126
    Fatal((char *)"Out of memory");
    }
  }
#line 127
  return (t);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int RandomPercent(int n ) 
{ 
  unsigned int rv ;
  int tmp ;

  {
  {
#line 132
  tmp = rand();
#line 132
  rv = (unsigned int )(tmp << 6);
#line 133
  rv %= 100U;
  }
#line 134
  if (rv < (unsigned int )n) {
#line 135
    return (1);
  }
#line 136
  return (0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int CountCarried(void) 
{ 
  int ct ;
  int n ;

  {
#line 141
  ct = 0;
#line 142
  n = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (ct <= (int )GameHeader.NumItems)) {
#line 143
      goto while_break;
    }
#line 145
    if ((int )(Items + ct)->Location == 255) {
#line 146
      n ++;
    }
#line 147
    ct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (n);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
static char lastword[16]  ;
#line 152 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char *MapSynonym(char *word ) 
{ 
  int n ;
  char *tp ;
  int tmp ;

  {
#line 154
  n = 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (n <= (int )GameHeader.NumWords)) {
#line 157
      goto while_break;
    }
#line 159
    tp = *(Nouns + n);
#line 160
    if ((int )*tp == 42) {
#line 161
      tp ++;
    } else {
      {
#line 163
      strcpy((char */* __restrict  */)(lastword), (char const   */* __restrict  */)tp);
      }
    }
    {
#line 164
    tmp = strncasecmp((char const   *)word, (char const   *)tp, (size_t )GameHeader.WordLength);
    }
#line 164
    if (tmp == 0) {
#line 165
      return (lastword);
    }
#line 166
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((char *)((void *)0));
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int MatchUpItem(char *text , int loc ) 
{ 
  char *word ;
  char *tmp ;
  int ct ;
  int tmp___0 ;

  {
  {
#line 173
  tmp = MapSynonym(text);
#line 173
  word = tmp;
#line 174
  ct = 0;
  }
#line 176
  if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 177
    word = text;
  }
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (ct <= (int )GameHeader.NumItems)) {
#line 179
      goto while_break;
    }
#line 181
    if ((Items + ct)->AutoGet) {
#line 181
      if ((int )(Items + ct)->Location == loc) {
        {
#line 181
        tmp___0 = strncasecmp((char const   *)(Items + ct)->AutoGet, (char const   *)word,
                              (size_t )GameHeader.WordLength);
        }
#line 181
        if (tmp___0 == 0) {
#line 183
          return (ct);
        }
      }
    }
#line 184
    ct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (-1);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
char *ReadString(FILE *f ) 
{ 
  char tmp[1024] ;
  char *t ;
  int c ;
  int nc ;
  int ct ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 194
  ct = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 197
    c = fgetc(f);
    }
#line 195
    if (c != -1) {
      {
#line 195
      tmp___0 = __ctype_b_loc();
      }
#line 195
      if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 195
        goto while_break;
      }
    } else {
#line 195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if (c != 34) {
    {
#line 202
    Fatal((char *)"Initial quote expected");
    }
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 206
    c = fgetc(f);
    }
#line 207
    if (c == -1) {
      {
#line 208
      Fatal((char *)"EOF in string");
      }
    }
#line 209
    if (c == 34) {
      {
#line 211
      nc = fgetc(f);
      }
#line 212
      if (nc != 34) {
        {
#line 214
        ungetc(nc, f);
        }
#line 215
        goto while_break___0;
      }
    }
#line 218
    if (c == 96) {
#line 219
      c = '\"';
    }
#line 220
    tmp___1 = ct;
#line 220
    ct ++;
#line 220
    tmp[tmp___1] = (char )c;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 223
  tmp[ct] = (char)0;
#line 224
  tmp___2 = MemAlloc(ct + 1);
#line 224
  t = (char *)tmp___2;
#line 225
  memcpy((void */* __restrict  */)t, (void const   */* __restrict  */)(tmp), (size_t )(ct + 1));
  }
#line 226
  return (t);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void LoadDatabase(FILE *f , int loud ) 
{ 
  int ni ;
  int na ;
  int nw ;
  int nr ;
  int mc ;
  int pr ;
  int tr ;
  int wl ;
  int lt ;
  int mn ;
  int trm ;
  int ct ;
  short lo ;
  Action *ap ;
  Room *rp ;
  Item *ip ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *t ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 239
  tmp = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%*d %d %d %d %d %d %d %d %d %d %d %d",
               & ni, & na, & nw, & nr, & mc, & pr, & tr, & wl, & lt, & mn, & trm,
               & ct);
  }
#line 239
  if (tmp < 10) {
    {
#line 241
    Fatal((char *)"Invalid database(bad header)");
    }
  }
  {
#line 242
  GameHeader.NumItems = (short )ni;
#line 243
  tmp___0 = MemAlloc((int )(sizeof(Item ) * (unsigned long )(ni + 1)));
#line 243
  Items = (Item *)tmp___0;
#line 244
  GameHeader.NumActions = (short )na;
#line 245
  tmp___1 = MemAlloc((int )(sizeof(Action ) * (unsigned long )(na + 1)));
#line 245
  Actions = (Action *)tmp___1;
#line 246
  GameHeader.NumWords = (short )nw;
#line 247
  GameHeader.WordLength = (short )wl;
#line 248
  tmp___2 = MemAlloc((int )(sizeof(char *) * (unsigned long )(nw + 1)));
#line 248
  Verbs = (char **)tmp___2;
#line 249
  tmp___3 = MemAlloc((int )(sizeof(char *) * (unsigned long )(nw + 1)));
#line 249
  Nouns = (char **)tmp___3;
#line 250
  GameHeader.NumRooms = (short )nr;
#line 251
  tmp___4 = MemAlloc((int )(sizeof(Room ) * (unsigned long )(nr + 1)));
#line 251
  Rooms = (Room *)tmp___4;
#line 252
  GameHeader.MaxCarry = (short )mc;
#line 253
  GameHeader.PlayerRoom = (short )pr;
#line 254
  GameHeader.Treasures = (short )tr;
#line 255
  GameHeader.LightTime = (short )lt;
#line 256
  LightRefill = lt;
#line 257
  GameHeader.NumMessages = (short )mn;
#line 258
  tmp___5 = MemAlloc((int )(sizeof(char *) * (unsigned long )(mn + 1)));
#line 258
  Messages = (char **)tmp___5;
#line 259
  GameHeader.TreasureRoom = (short )trm;
#line 263
  ct = 0;
#line 264
  ap = Actions;
  }
#line 265
  if (loud) {
    {
#line 266
    printf((char const   */* __restrict  */)"Reading %d actions.\n", na);
    }
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (ct < na + 1)) {
#line 267
      goto while_break;
    }
    {
#line 269
    tmp___6 = fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%hd %hd %hd %hd %hd %hd %hd %hd",
                     & ap->Vocab, & ap->Condition[0], & ap->Condition[1], & ap->Condition[2],
                     & ap->Condition[3], & ap->Condition[4], & ap->Action[0], & ap->Action[1]);
    }
#line 269
    if (tmp___6 != 8) {
      {
#line 279
      printf((char const   */* __restrict  */)"Bad action line (%d)\n", ct);
#line 280
      exit(1);
      }
    }
#line 282
    ap ++;
#line 283
    ct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  ct = 0;
#line 286
  if (loud) {
    {
#line 287
    printf((char const   */* __restrict  */)"Reading %d word pairs.\n", nw);
    }
  }
  {
#line 288
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 288
    if (! (ct < nw + 1)) {
#line 288
      goto while_break___0;
    }
    {
#line 290
    *(Verbs + ct) = ReadString(f);
#line 291
    *(Nouns + ct) = ReadString(f);
#line 292
    ct ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 294
  ct = 0;
#line 295
  rp = Rooms;
#line 296
  if (loud) {
    {
#line 297
    printf((char const   */* __restrict  */)"Reading %d rooms.\n", nr);
    }
  }
  {
#line 298
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 298
    if (! (ct < nr + 1)) {
#line 298
      goto while_break___1;
    }
    {
#line 300
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%hd %hd %hd %hd %hd %hd",
           & rp->Exits[0], & rp->Exits[1], & rp->Exits[2], & rp->Exits[3], & rp->Exits[4],
           & rp->Exits[5]);
#line 303
    rp->Text = ReadString(f);
#line 304
    ct ++;
#line 305
    rp ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 307
  ct = 0;
#line 308
  if (loud) {
    {
#line 309
    printf((char const   */* __restrict  */)"Reading %d messages.\n", mn);
    }
  }
  {
#line 310
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 310
    if (! (ct < mn + 1)) {
#line 310
      goto while_break___2;
    }
    {
#line 312
    *(Messages + ct) = ReadString(f);
#line 313
    ct ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 315
  ct = 0;
#line 316
  if (loud) {
    {
#line 317
    printf((char const   */* __restrict  */)"Reading %d items.\n", ni);
    }
  }
#line 318
  ip = Items;
  {
#line 319
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 319
    if (! (ct < ni + 1)) {
#line 319
      goto while_break___3;
    }
    {
#line 321
    ip->Text = ReadString(f);
#line 322
    ip->AutoGet = strchr((char const   *)ip->Text, '/');
    }
#line 324
    if (ip->AutoGet) {
      {
#line 324
      tmp___8 = strcmp((char const   *)ip->AutoGet, "//");
      }
#line 324
      if (tmp___8) {
        {
#line 324
        tmp___9 = strcmp((char const   *)ip->AutoGet, "/*");
        }
#line 324
        if (tmp___9) {
          {
#line 327
          tmp___7 = ip->AutoGet;
#line 327
          (ip->AutoGet) ++;
#line 327
          *tmp___7 = (char)0;
#line 328
          t = strchr((char const   *)ip->AutoGet, '/');
          }
#line 329
          if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 330
            *t = (char)0;
          }
        }
      }
    }
    {
#line 332
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%hd", & lo);
#line 333
    ip->Location = (unsigned char )lo;
#line 334
    ip->InitialLoc = ip->Location;
#line 335
    ip ++;
#line 336
    ct ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 338
  ct = 0;
  {
#line 340
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 340
    if (! (ct < na + 1)) {
#line 340
      goto while_break___4;
    }
    {
#line 342
    tmp___10 = ReadString(f);
#line 342
    free((void *)tmp___10);
#line 343
    ct ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 345
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d", & ct);
  }
#line 346
  if (loud) {
    {
#line 347
    printf((char const   */* __restrict  */)"Version %d.%02d of Adventure ", ct / 100,
           ct % 100);
    }
  }
  {
#line 349
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d", & ct);
  }
#line 350
  if (loud) {
    {
#line 351
    printf((char const   */* __restrict  */)"%d.\nLoad Complete.\n\n", ct);
    }
  }
#line 352
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int OutputPos  =    0;
#line 356 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void OutReset(void) 
{ 


  {
  {
#line 358
  OutputPos = 0;
#line 359
  wmove(Bottom, BottomHeight - 1, 0);
#line 360
  wclrtoeol(Bottom);
  }
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void OutBuf(char *buffer ) 
{ 
  char word[80] ;
  int wp ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! *buffer) {
#line 367
      goto while_break;
    }
#line 369
    if (OutputPos == 0) {
      {
#line 371
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 371
        if (*buffer) {
          {
#line 371
          tmp = __ctype_b_loc();
          }
#line 371
          if (! ((int const   )*(*tmp + (int )*buffer) & 8192)) {
#line 371
            goto while_break___0;
          }
        } else {
#line 371
          goto while_break___0;
        }
#line 373
        if ((int )*buffer == 10) {
          {
#line 375
          wscrl(Bottom, 1);
#line 376
          wmove(Bottom, BottomHeight - 1, 0);
#line 377
          wclrtoeol(Bottom);
#line 378
          OutputPos = 0;
          }
        }
#line 380
        buffer ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 383
    if ((int )*buffer == 0) {
#line 384
      return;
    }
#line 385
    wp = 0;
    {
#line 386
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 386
      if (*buffer) {
        {
#line 386
        tmp___2 = __ctype_b_loc();
        }
#line 386
        if ((int const   )*(*tmp___2 + (int )*buffer) & 8192) {
#line 386
          goto while_break___1;
        }
      } else {
#line 386
        goto while_break___1;
      }
#line 388
      tmp___0 = wp;
#line 388
      wp ++;
#line 388
      tmp___1 = buffer;
#line 388
      buffer ++;
#line 388
      word[tmp___0] = *tmp___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 390
    word[wp] = (char)0;
#line 392
    tmp___3 = strlen((char const   *)(word));
    }
#line 392
    if ((size_t )OutputPos + tmp___3 > (size_t )(Width - 2)) {
      {
#line 394
      wscrl(Bottom, 1);
#line 395
      wmove(Bottom, BottomHeight - 1, 0);
#line 396
      wclrtoeol(Bottom);
#line 397
      OutputPos = 0;
      }
    }
    {
#line 399
    wprintw(Bottom, (char const   *)(word));
#line 400
    tmp___4 = strlen((char const   *)(word));
#line 400
    OutputPos = (int )((size_t )OutputPos + tmp___4);
    }
#line 402
    if ((int )*buffer == 0) {
#line 403
      return;
    }
#line 405
    if ((int )*buffer == 10) {
      {
#line 407
      wscrl(Bottom, 1);
#line 408
      wmove(Bottom, BottomHeight - 1, 0);
#line 409
      wclrtoeol(Bottom);
#line 410
      OutputPos = 0;
      }
    } else {
#line 414
      OutputPos ++;
#line 415
      if (OutputPos < Width - 1) {
        {
#line 416
        wprintw(Bottom, " ");
        }
      }
    }
#line 418
    buffer ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void Output(char *a ) 
{ 
  char block[512] ;

  {
  {
#line 425
  strcpy((char */* __restrict  */)(block), (char const   */* __restrict  */)a);
#line 426
  OutBuf(block);
  }
#line 427
  return;
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void OutputNumber(int a ) 
{ 
  char buf[16] ;

  {
  {
#line 432
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d ",
          a);
#line 433
  OutBuf(buf);
  }
#line 434
  return;
}
}
#line 438
void Look(void) ;
#line 438 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
static char *ExitNames[6]  = {      (char *)"North",      (char *)"South",      (char *)"East",      (char *)"West", 
        (char *)"Up",      (char *)"Down"};
#line 436 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void Look(void) 
{ 
  Room *r ;
  int ct ;
  int f ;
  int pos ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 446
  werase(Top);
#line 447
  wmove(Top, 0, 0);
  }
#line 448
  if (BitFlags & (long )(1 << 15)) {
#line 448
    if ((int )(Items + 9)->Location != 255) {
#line 448
      if ((int )(Items + 9)->Location != (int )GameHeader.PlayerRoom) {
#line 451
        if (Options & 1) {
          {
#line 452
          wprintw(Top, "You can\'t see. It is too dark!\n");
          }
        } else {
          {
#line 454
          wprintw(Top, "I can\'t see. It is too dark!\n");
          }
        }
#line 455
        if (Options & 8) {
          {
#line 456
          wprintw(Top, "\n<------------------------------------------------------------>\n");
          }
        }
        {
#line 457
        wrefresh(Top);
        }
#line 458
        return;
      }
    }
  }
#line 460
  r = Rooms + GameHeader.PlayerRoom;
#line 461
  if ((int )*(r->Text) == 42) {
    {
#line 462
    wprintw(Top, "%s\n", r->Text + 1);
    }
  } else
#line 465
  if (Options & 1) {
    {
#line 466
    wprintw(Top, "You are %s\n", r->Text);
    }
  } else {
    {
#line 468
    wprintw(Top, "I\'m in a %s\n", r->Text);
    }
  }
  {
#line 470
  ct = 0;
#line 471
  f = 0;
#line 472
  wprintw(Top, "\nObvious exits: ");
  }
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! (ct < 6)) {
#line 473
      goto while_break;
    }
#line 475
    if ((int )r->Exits[ct] != 0) {
#line 477
      if (f == 0) {
#line 478
        f = 1;
      } else {
        {
#line 480
        wprintw(Top, ", ");
        }
      }
      {
#line 481
      wprintw(Top, "%s", ExitNames[ct]);
      }
    }
#line 483
    ct ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  if (f == 0) {
    {
#line 486
    wprintw(Top, "none");
    }
  }
  {
#line 487
  wprintw(Top, ".\n");
#line 488
  ct = 0;
#line 489
  f = 0;
#line 490
  pos = 0;
  }
  {
#line 491
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 491
    if (! (ct <= (int )GameHeader.NumItems)) {
#line 491
      goto while_break___0;
    }
#line 493
    if ((int )(Items + ct)->Location == (int )GameHeader.PlayerRoom) {
#line 495
      if (f == 0) {
#line 497
        if (Options & 1) {
          {
#line 498
          wprintw(Top, "\nYou can also see: ");
          }
        } else {
          {
#line 500
          wprintw(Top, "\nI can also see: ");
          }
        }
#line 501
        pos = 16;
#line 502
        f ++;
      } else
#line 504
      if (! (Options & 8)) {
        {
#line 506
        wprintw(Top, " - ");
#line 507
        pos += 3;
        }
      }
      {
#line 509
      tmp = strlen((char const   *)(Items + ct)->Text);
      }
#line 509
      if ((size_t )pos + tmp > (size_t )(Width - 10)) {
        {
#line 511
        pos = 0;
#line 512
        wprintw(Top, "\n");
        }
      }
      {
#line 514
      wprintw(Top, "%s", (Items + ct)->Text);
#line 515
      tmp___0 = strlen((char const   *)(Items + ct)->Text);
#line 515
      pos = (int )((size_t )pos + tmp___0);
      }
#line 516
      if (Options & 8) {
        {
#line 518
        wprintw(Top, ". ");
#line 519
        pos += 2;
        }
      }
    }
#line 522
    ct ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 524
  wprintw(Top, "\n");
  }
#line 525
  if (Options & 8) {
    {
#line 526
    wprintw(Top, "\n<------------------------------------------------------------>\n");
    }
  }
  {
#line 527
  wrefresh(Top);
  }
#line 528
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int WhichWord(char *word , char **list ) 
{ 
  int n ;
  int ne ;
  char *tp ;
  int tmp ;

  {
#line 532
  n = 1;
#line 533
  ne = 1;
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if (! (ne <= (int )GameHeader.NumWords)) {
#line 535
      goto while_break;
    }
#line 537
    tp = *(list + ne);
#line 538
    if ((int )*tp == 42) {
#line 539
      tp ++;
    } else {
#line 541
      n = ne;
    }
    {
#line 542
    tmp = strncasecmp((char const   *)word, (char const   *)tp, (size_t )GameHeader.WordLength);
    }
#line 542
    if (tmp == 0) {
#line 543
      return (n);
    }
#line 544
    ne ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 546
  return (-1);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void LineInput(char *buf ) 
{ 
  int pos ;
  int ch ;
  int y ;
  int x ;
  int tmp ;
  int tmp___0 ;

  {
#line 553
  pos = 0;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    wrefresh(Bottom);
#line 558
    ch = wgetch(Bottom);
    }
    {
#line 561
    if (ch == 10) {
#line 561
      goto case_10;
    }
#line 562
    if (ch == 13) {
#line 562
      goto case_13;
    }
#line 567
    if (ch == 8) {
#line 567
      goto case_8;
    }
#line 568
    if (ch == 127) {
#line 568
      goto case_127;
    }
#line 585
    goto switch_default;
    case_10: /* CIL Label */ ;
    case_13: /* CIL Label */ 
    {
#line 563
    *(buf + pos) = (char)0;
#line 564
    wscrl(Bottom, 1);
#line 565
    wmove(Bottom, BottomHeight, 0);
    }
#line 566
    return;
    case_8: /* CIL Label */ ;
    case_127: /* CIL Label */ ;
#line 569
    if (pos > 0) {
#line 572
      if (Bottom) {
#line 572
        y = (int )Bottom->_cury;
      } else {
#line 572
        y = -1;
      }
#line 572
      if (Bottom) {
#line 572
        x = (int )Bottom->_curx;
      } else {
#line 572
        x = -1;
      }
#line 573
      x --;
#line 574
      if (x == -1) {
#line 576
        x = Width - 1;
#line 577
        y --;
      }
      {
#line 579
      tmp = wmove(Bottom, y, x);
      }
#line 579
      if (! (tmp == -1)) {
        {
#line 579
        waddch(Bottom, (chtype const   )' ');
        }
      }
      {
#line 580
      wmove(Bottom, y, x);
#line 581
      wrefresh(Bottom);
#line 582
      pos --;
      }
    }
#line 584
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 586
    if (ch >= 32) {
#line 586
      if (ch <= 126) {
        {
#line 588
        tmp___0 = pos;
#line 588
        pos ++;
#line 588
        *(buf + tmp___0) = (char )ch;
#line 589
        waddch(Bottom, (chtype const   )((char )ch));
#line 590
        wrefresh(Bottom);
        }
      }
    }
#line 592
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void GetInput(int *vb , int *no ) 
{ 
  char buf[256] ;
  char verb[10] ;
  char noun[10] ;
  int vc ;
  int nc ;
  int num ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 606
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 608
      Output((char *)"\nTell me what to do ? ");
#line 609
      wrefresh(Bottom);
#line 610
      LineInput(buf);
#line 611
      OutReset();
#line 612
      num = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%9s %9s",
                   verb, noun);
      }
#line 606
      if (! (num == 0)) {
#line 606
        if (! ((int )buf[0] == 10)) {
#line 606
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 615
    if (num == 1) {
#line 616
      noun[0] = (char)0;
    }
#line 617
    if ((int )noun[0] == 0) {
      {
#line 617
      tmp___3 = strlen((char const   *)(verb));
      }
#line 617
      if (tmp___3 == 1UL) {
        {
#line 619
        tmp___2 = __ctype_b_loc();
        }
#line 619
        if ((int const   )*(*tmp___2 + (int )verb[0]) & 256) {
          {
#line 619
          tmp___0 = tolower((int )verb[0]);
#line 619
          tmp___1 = tmp___0;
          }
        } else {
#line 619
          tmp___1 = (int )verb[0];
        }
        {
#line 621
        if (tmp___1 == 110) {
#line 621
          goto case_110;
        }
#line 622
        if (tmp___1 == 101) {
#line 622
          goto case_101;
        }
#line 623
        if (tmp___1 == 115) {
#line 623
          goto case_115;
        }
#line 624
        if (tmp___1 == 119) {
#line 624
          goto case_119;
        }
#line 625
        if (tmp___1 == 117) {
#line 625
          goto case_117;
        }
#line 626
        if (tmp___1 == 100) {
#line 626
          goto case_100;
        }
#line 628
        if (tmp___1 == 105) {
#line 628
          goto case_105;
        }
#line 619
        goto switch_break;
        case_110: /* CIL Label */ 
        {
#line 621
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"NORTH");
        }
#line 621
        goto switch_break;
        case_101: /* CIL Label */ 
        {
#line 622
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"EAST");
        }
#line 622
        goto switch_break;
        case_115: /* CIL Label */ 
        {
#line 623
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"SOUTH");
        }
#line 623
        goto switch_break;
        case_119: /* CIL Label */ 
        {
#line 624
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"WEST");
        }
#line 624
        goto switch_break;
        case_117: /* CIL Label */ 
        {
#line 625
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"UP");
        }
#line 625
        goto switch_break;
        case_100: /* CIL Label */ 
        {
#line 626
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"DOWN");
        }
#line 626
        goto switch_break;
        case_105: /* CIL Label */ 
        {
#line 628
        strcpy((char */* __restrict  */)(verb), (char const   */* __restrict  */)"INVENTORY");
        }
#line 628
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 631
    nc = WhichWord(verb, Nouns);
    }
#line 633
    if (nc >= 1) {
#line 633
      if (nc <= 6) {
#line 635
        vc = 1;
      } else {
        {
#line 639
        vc = WhichWord(verb, Verbs);
#line 640
        nc = WhichWord(noun, Nouns);
        }
      }
    } else {
      {
#line 639
      vc = WhichWord(verb, Verbs);
#line 640
      nc = WhichWord(noun, Nouns);
      }
    }
#line 642
    *vb = vc;
#line 643
    *no = nc;
#line 644
    if (vc == -1) {
      {
#line 646
      Output((char *)"You use word(s) I don\'t know! ");
      }
    }
#line 604
    if (! (vc == -1)) {
#line 604
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  strcpy((char */* __restrict  */)(NounText), (char const   */* __restrict  */)(noun));
  }
#line 651
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void SaveGame(void) 
{ 
  char buf[256] ;
  int ct ;
  FILE *f ;
  int tmp ;

  {
  {
#line 658
  Output((char *)"Filename: ");
#line 659
  LineInput(buf);
#line 660
  Output((char *)"\n");
#line 661
  f = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"w");
  }
#line 662
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 664
    Output((char *)"Unable to create save file.\n");
    }
#line 665
    return;
  }
#line 667
  ct = 0;
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (ct < 16)) {
#line 667
      goto while_break;
    }
    {
#line 669
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %d\n",
            Counters[ct], RoomSaved[ct]);
#line 667
    ct ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  if (BitFlags & (long )(1 << 15)) {
#line 671
    tmp = 1;
  } else {
#line 671
    tmp = 0;
  }
  {
#line 671
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld %d %hd %d %d %hd\n",
          BitFlags, tmp, (int )GameHeader.PlayerRoom, CurrentCounter, SavedRoom, (int )GameHeader.LightTime);
#line 673
  ct = 0;
  }
  {
#line 673
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 673
    if (! (ct <= (int )GameHeader.NumItems)) {
#line 673
      goto while_break___0;
    }
    {
#line 674
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%hd\n",
            (int )((short )(Items + ct)->Location));
#line 673
    ct ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 675
  fclose(f);
#line 676
  Output((char *)"Saved.\n");
  }
#line 677
  return;
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void LoadGame(char *name ) 
{ 
  FILE *f ;
  FILE *tmp ;
  int ct ;
  short lo ;
  short DarkFlag ;

  {
  {
#line 681
  tmp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
#line 681
  f = tmp;
#line 682
  ct = 0;
  }
#line 685
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 687
    Output((char *)"Unable to restore game.");
    }
#line 688
    return;
  }
#line 690
  ct = 0;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! (ct < 16)) {
#line 690
      goto while_break;
    }
    {
#line 692
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%d %d\n",
           & Counters[ct], & RoomSaved[ct]);
#line 690
    ct ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 694
  fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%ld %d %hd %d %d %hd\n",
         & BitFlags, & DarkFlag, & GameHeader.PlayerRoom, & CurrentCounter, & SavedRoom,
         & GameHeader.LightTime);
  }
#line 698
  if (DarkFlag) {
#line 699
    BitFlags |= (long )(1 << 15);
  }
#line 700
  ct = 0;
  {
#line 700
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 700
    if (! (ct <= (int )GameHeader.NumItems)) {
#line 700
      goto while_break___0;
    }
    {
#line 702
    fscanf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%hd\n", & lo);
#line 703
    (Items + ct)->Location = (unsigned char )lo;
#line 700
    ct ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 705
  fclose(f);
  }
#line 706
  return;
}
}
#line 893
extern int ( /* missing proto */  sleep)() ;
#line 708 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int PerformLine(int ct ) 
{ 
  int continuation ;
  int param[5] ;
  int pptr ;
  int act[4] ;
  int cc ;
  int cv ;
  int dv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int i ;
  int tmp___10 ;
  int tmp___11 ;
  int ct___0 ;
  int n ;
  int ct___1 ;
  int f ;
  int i1 ;
  int tmp___12 ;
  int i2 ;
  int tmp___13 ;
  int t ;
  int tmp___14 ;
  int i1___0 ;
  int i2___0 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int t___0 ;
  int t___1 ;
  int tmp___18 ;
  int c1 ;
  int tmp___19 ;
  int tmp___20 ;
  int p ;
  int tmp___21 ;
  int sr ;

  {
#line 710
  continuation = 0;
#line 711
  pptr = 0;
#line 713
  cc = 0;
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
#line 714
    if (! (cc < 5)) {
#line 714
      goto while_break;
    }
#line 717
    cv = (int )(Actions + ct)->Condition[cc];
#line 718
    dv = cv / 20;
#line 719
    cv %= 20;
    {
#line 722
    if (cv == 0) {
#line 722
      goto case_0;
    }
#line 725
    if (cv == 1) {
#line 725
      goto case_1;
    }
#line 729
    if (cv == 2) {
#line 729
      goto case_2;
    }
#line 733
    if (cv == 3) {
#line 733
      goto case_3;
    }
#line 738
    if (cv == 4) {
#line 738
      goto case_4;
    }
#line 742
    if (cv == 5) {
#line 742
      goto case_5;
    }
#line 746
    if (cv == 6) {
#line 746
      goto case_6;
    }
#line 750
    if (cv == 7) {
#line 750
      goto case_7;
    }
#line 754
    if (cv == 8) {
#line 754
      goto case_8;
    }
#line 758
    if (cv == 9) {
#line 758
      goto case_9;
    }
#line 762
    if (cv == 10) {
#line 762
      goto case_10;
    }
#line 766
    if (cv == 11) {
#line 766
      goto case_11;
    }
#line 770
    if (cv == 12) {
#line 770
      goto case_12;
    }
#line 774
    if (cv == 13) {
#line 774
      goto case_13;
    }
#line 778
    if (cv == 14) {
#line 778
      goto case_14;
    }
#line 782
    if (cv == 15) {
#line 782
      goto case_15;
    }
#line 786
    if (cv == 16) {
#line 786
      goto case_16;
    }
#line 790
    if (cv == 17) {
#line 790
      goto case_17;
    }
#line 794
    if (cv == 18) {
#line 794
      goto case_18;
    }
#line 798
    if (cv == 19) {
#line 798
      goto case_19;
    }
#line 720
    goto switch_break;
    case_0: /* CIL Label */ 
#line 723
    tmp = pptr;
#line 723
    pptr ++;
#line 723
    param[tmp] = dv;
#line 724
    goto switch_break;
    case_1: /* CIL Label */ 
#line 726
    if ((int )(Items + dv)->Location != 255) {
#line 727
      return (0);
    }
#line 728
    goto switch_break;
    case_2: /* CIL Label */ 
#line 730
    if ((int )(Items + dv)->Location != (int )GameHeader.PlayerRoom) {
#line 731
      return (0);
    }
#line 732
    goto switch_break;
    case_3: /* CIL Label */ 
#line 734
    if ((int )(Items + dv)->Location != 255) {
#line 734
      if ((int )(Items + dv)->Location != (int )GameHeader.PlayerRoom) {
#line 736
        return (0);
      }
    }
#line 737
    goto switch_break;
    case_4: /* CIL Label */ 
#line 739
    if ((int )GameHeader.PlayerRoom != dv) {
#line 740
      return (0);
    }
#line 741
    goto switch_break;
    case_5: /* CIL Label */ 
#line 743
    if ((int )(Items + dv)->Location == (int )GameHeader.PlayerRoom) {
#line 744
      return (0);
    }
#line 745
    goto switch_break;
    case_6: /* CIL Label */ 
#line 747
    if ((int )(Items + dv)->Location == 255) {
#line 748
      return (0);
    }
#line 749
    goto switch_break;
    case_7: /* CIL Label */ 
#line 751
    if ((int )GameHeader.PlayerRoom == dv) {
#line 752
      return (0);
    }
#line 753
    goto switch_break;
    case_8: /* CIL Label */ 
#line 755
    if ((BitFlags & (long )(1 << dv)) == 0L) {
#line 756
      return (0);
    }
#line 757
    goto switch_break;
    case_9: /* CIL Label */ 
#line 759
    if (BitFlags & (long )(1 << dv)) {
#line 760
      return (0);
    }
#line 761
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 763
    tmp___0 = CountCarried();
    }
#line 763
    if (tmp___0 == 0) {
#line 764
      return (0);
    }
#line 765
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 767
    tmp___1 = CountCarried();
    }
#line 767
    if (tmp___1) {
#line 768
      return (0);
    }
#line 769
    goto switch_break;
    case_12: /* CIL Label */ 
#line 771
    if ((int )(Items + dv)->Location == 255) {
#line 772
      return (0);
    } else
#line 771
    if ((int )(Items + dv)->Location == (int )GameHeader.PlayerRoom) {
#line 772
      return (0);
    }
#line 773
    goto switch_break;
    case_13: /* CIL Label */ 
#line 775
    if ((int )(Items + dv)->Location == 0) {
#line 776
      return (0);
    }
#line 777
    goto switch_break;
    case_14: /* CIL Label */ 
#line 779
    if ((Items + dv)->Location) {
#line 780
      return (0);
    }
#line 781
    goto switch_break;
    case_15: /* CIL Label */ 
#line 783
    if (CurrentCounter > dv) {
#line 784
      return (0);
    }
#line 785
    goto switch_break;
    case_16: /* CIL Label */ 
#line 787
    if (CurrentCounter <= dv) {
#line 788
      return (0);
    }
#line 789
    goto switch_break;
    case_17: /* CIL Label */ 
#line 791
    if ((int )(Items + dv)->Location != (int )(Items + dv)->InitialLoc) {
#line 792
      return (0);
    }
#line 793
    goto switch_break;
    case_18: /* CIL Label */ 
#line 795
    if ((int )(Items + dv)->Location == (int )(Items + dv)->InitialLoc) {
#line 796
      return (0);
    }
#line 797
    goto switch_break;
    case_19: /* CIL Label */ 
#line 799
    if (CurrentCounter != dv) {
#line 800
      return (0);
    }
#line 801
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 803
    cc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  act[0] = (int )(Actions + ct)->Action[0];
#line 807
  act[2] = (int )(Actions + ct)->Action[1];
#line 808
  act[1] = act[0] % 150;
#line 809
  act[3] = act[2] % 150;
#line 810
  act[0] /= 150;
#line 811
  act[2] /= 150;
#line 812
  cc = 0;
#line 813
  pptr = 0;
  {
#line 814
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 814
    if (! (cc < 4)) {
#line 814
      goto while_break___0;
    }
#line 816
    if (act[cc] >= 1) {
#line 816
      if (act[cc] < 52) {
        {
#line 818
        Output(*(Messages + act[cc]));
#line 819
        Output((char *)"\n");
        }
      } else {
#line 816
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 821
    if (act[cc] > 101) {
      {
#line 823
      Output(*(Messages + (act[cc] - 50)));
#line 824
      Output((char *)"\n");
      }
    } else {
      {
#line 828
      if (act[cc] == 0) {
#line 828
        goto case_0___0;
      }
#line 830
      if (act[cc] == 52) {
#line 830
        goto case_52;
      }
#line 843
      if (act[cc] == 53) {
#line 843
        goto case_53;
      }
#line 847
      if (act[cc] == 54) {
#line 847
        goto case_54;
      }
#line 851
      if (act[cc] == 55) {
#line 851
        goto case_55;
      }
#line 856
      if (act[cc] == 56) {
#line 856
        goto case_56;
      }
#line 859
      if (act[cc] == 57) {
#line 859
        goto case_57;
      }
#line 862
      if (act[cc] == 58) {
#line 862
        goto case_58;
      }
#line 865
      if (act[cc] == 59) {
#line 865
        goto case_59;
      }
#line 870
      if (act[cc] == 60) {
#line 870
        goto case_60;
      }
#line 873
      if (act[cc] == 61) {
#line 873
        goto case_61;
      }
#line 882
      if (act[cc] == 62) {
#line 882
        goto case_62;
      }
#line 890
      if (act[cc] == 63) {
#line 890
        goto doneit;
      }
#line 896
      if (act[cc] == 64) {
#line 896
        goto case_64;
      }
#line 899
      if (act[cc] == 65) {
#line 899
        goto case_65;
      }
#line 925
      if (act[cc] == 66) {
#line 925
        goto case_66;
      }
#line 954
      if (act[cc] == 67) {
#line 954
        goto case_67;
      }
#line 957
      if (act[cc] == 68) {
#line 957
        goto case_68;
      }
#line 960
      if (act[cc] == 69) {
#line 960
        goto case_69;
      }
#line 967
      if (act[cc] == 70) {
#line 967
        goto case_70;
      }
#line 971
      if (act[cc] == 71) {
#line 971
        goto case_71;
      }
#line 974
      if (act[cc] == 72) {
#line 974
        goto case_72;
      }
#line 985
      if (act[cc] == 73) {
#line 985
        goto case_73;
      }
#line 988
      if (act[cc] == 74) {
#line 988
        goto case_74;
      }
#line 993
      if (act[cc] == 75) {
#line 993
        goto case_75;
      }
#line 1005
      if (act[cc] == 76) {
#line 1005
        goto case_76;
      }
#line 1008
      if (act[cc] == 77) {
#line 1008
        goto case_77;
      }
#line 1012
      if (act[cc] == 78) {
#line 1012
        goto case_78;
      }
#line 1015
      if (act[cc] == 79) {
#line 1015
        goto case_79;
      }
#line 1018
      if (act[cc] == 80) {
#line 1018
        goto case_80;
      }
#line 1026
      if (act[cc] == 81) {
#line 1026
        goto case_81;
      }
#line 1038
      if (act[cc] == 82) {
#line 1038
        goto case_82;
      }
#line 1041
      if (act[cc] == 83) {
#line 1041
        goto case_83;
      }
#line 1048
      if (act[cc] == 84) {
#line 1048
        goto case_84;
      }
#line 1051
      if (act[cc] == 85) {
#line 1051
        goto case_85;
      }
#line 1055
      if (act[cc] == 86) {
#line 1055
        goto case_86;
      }
#line 1058
      if (act[cc] == 87) {
#line 1058
        goto case_87;
      }
#line 1069
      if (act[cc] == 88) {
#line 1069
        goto case_88;
      }
#line 1074
      if (act[cc] == 89) {
#line 1074
        goto case_89;
      }
#line 1080
      goto switch_default;
      case_0___0: /* CIL Label */ 
#line 829
      goto switch_break___0;
      case_52: /* CIL Label */ 
      {
#line 831
      tmp___2 = CountCarried();
      }
#line 831
      if (tmp___2 == (int )GameHeader.MaxCarry) {
#line 833
        if (Options & 1) {
          {
#line 834
          Output((char *)"You are carrying too much. ");
          }
        } else {
          {
#line 836
          Output((char *)"I\'ve too much to carry! ");
          }
        }
#line 837
        goto switch_break___0;
      }
#line 839
      if ((int )(Items + param[pptr])->Location == (int )GameHeader.PlayerRoom) {
#line 840
        Redraw = 1;
      }
#line 841
      tmp___3 = pptr;
#line 841
      pptr ++;
#line 841
      (Items + param[tmp___3])->Location = (unsigned char)255;
#line 842
      goto switch_break___0;
      case_53: /* CIL Label */ 
#line 844
      Redraw = 1;
#line 845
      tmp___4 = pptr;
#line 845
      pptr ++;
#line 845
      (Items + param[tmp___4])->Location = (unsigned char )GameHeader.PlayerRoom;
#line 846
      goto switch_break___0;
      case_54: /* CIL Label */ 
#line 848
      Redraw = 1;
#line 849
      tmp___5 = pptr;
#line 849
      pptr ++;
#line 849
      GameHeader.PlayerRoom = (short )param[tmp___5];
#line 850
      goto switch_break___0;
      case_55: /* CIL Label */ 
#line 852
      if ((int )(Items + param[pptr])->Location == (int )GameHeader.PlayerRoom) {
#line 853
        Redraw = 1;
      }
#line 854
      tmp___6 = pptr;
#line 854
      pptr ++;
#line 854
      (Items + param[tmp___6])->Location = (unsigned char)0;
#line 855
      goto switch_break___0;
      case_56: /* CIL Label */ 
#line 857
      BitFlags |= (long )(1 << 15);
#line 858
      goto switch_break___0;
      case_57: /* CIL Label */ 
#line 860
      BitFlags &= (long )(~ (1 << 15));
#line 861
      goto switch_break___0;
      case_58: /* CIL Label */ 
#line 863
      tmp___7 = pptr;
#line 863
      pptr ++;
#line 863
      BitFlags |= (long )(1 << param[tmp___7]);
#line 864
      goto switch_break___0;
      case_59: /* CIL Label */ 
#line 866
      if ((int )(Items + param[pptr])->Location == (int )GameHeader.PlayerRoom) {
#line 867
        Redraw = 1;
      }
#line 868
      tmp___8 = pptr;
#line 868
      pptr ++;
#line 868
      (Items + param[tmp___8])->Location = (unsigned char)0;
#line 869
      goto switch_break___0;
      case_60: /* CIL Label */ 
#line 871
      tmp___9 = pptr;
#line 871
      pptr ++;
#line 871
      BitFlags &= (long )(~ (1 << param[tmp___9]));
#line 872
      goto switch_break___0;
      case_61: /* CIL Label */ 
#line 874
      if (Options & 1) {
        {
#line 875
        Output((char *)"You are dead.\n");
        }
      } else {
        {
#line 877
        Output((char *)"I am dead.\n");
        }
      }
      {
#line 878
      BitFlags &= (long )(~ (1 << 15));
#line 879
      GameHeader.PlayerRoom = GameHeader.NumRooms;
#line 880
      Look();
      }
#line 881
      goto switch_break___0;
      case_62: /* CIL Label */ 
#line 885
      tmp___10 = pptr;
#line 885
      pptr ++;
#line 885
      i = param[tmp___10];
#line 886
      tmp___11 = pptr;
#line 886
      pptr ++;
#line 886
      (Items + i)->Location = (unsigned char )param[tmp___11];
#line 887
      Redraw = 1;
#line 888
      goto switch_break___0;
      doneit: 
      case_63: /* CIL Label */ 
      {
#line 891
      Output((char *)"The game is now over.\n");
#line 892
      wrefresh(Bottom);
#line 893
      sleep(5);
#line 894
      endwin();
#line 895
      exit(0);
      }
      case_64: /* CIL Label */ 
      {
#line 897
      Look();
      }
#line 898
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 901
      ct___0 = 0;
#line 902
      n = 0;
      {
#line 903
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 903
        if (! (ct___0 <= (int )GameHeader.NumItems)) {
#line 903
          goto while_break___1;
        }
#line 905
        if ((int )(Items + ct___0)->Location == (int )GameHeader.TreasureRoom) {
#line 905
          if ((int )*((Items + ct___0)->Text) == 42) {
#line 907
            n ++;
          }
        }
#line 908
        ct___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 910
      if (Options & 1) {
        {
#line 911
        Output((char *)"You have stored ");
        }
      } else {
        {
#line 913
        Output((char *)"I\'ve stored ");
        }
      }
      {
#line 914
      OutputNumber(n);
#line 915
      Output((char *)" treasures.  On a scale of 0 to 100, that rates ");
#line 916
      OutputNumber((n * 100) / (int )GameHeader.Treasures);
#line 917
      Output((char *)".\n");
      }
#line 918
      if (n == (int )GameHeader.Treasures) {
        {
#line 920
        Output((char *)"Well done.\n");
        }
#line 921
        goto doneit;
      }
#line 923
      goto switch_break___0;
      case_66: /* CIL Label */ 
#line 927
      ct___1 = 0;
#line 928
      f = 0;
#line 929
      if (Options & 1) {
        {
#line 930
        Output((char *)"You are carrying:\n");
        }
      } else {
        {
#line 932
        Output((char *)"I\'m carrying:\n");
        }
      }
      {
#line 933
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 933
        if (! (ct___1 <= (int )GameHeader.NumItems)) {
#line 933
          goto while_break___2;
        }
#line 935
        if ((int )(Items + ct___1)->Location == 255) {
#line 937
          if (f == 1) {
#line 939
            if (Options & 8) {
              {
#line 940
              Output((char *)". ");
              }
            } else {
              {
#line 942
              Output((char *)" - ");
              }
            }
          }
          {
#line 944
          f = 1;
#line 945
          Output((Items + ct___1)->Text);
          }
        }
#line 947
        ct___1 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 949
      if (f == 0) {
        {
#line 950
        Output((char *)"Nothing");
        }
      }
      {
#line 951
      Output((char *)".\n");
      }
#line 952
      goto switch_break___0;
      case_67: /* CIL Label */ 
#line 955
      BitFlags |= 1L;
#line 956
      goto switch_break___0;
      case_68: /* CIL Label */ 
#line 958
      BitFlags &= -2L;
#line 959
      goto switch_break___0;
      case_69: /* CIL Label */ 
#line 961
      GameHeader.LightTime = (short )LightRefill;
#line 962
      if ((int )(Items + 9)->Location == (int )GameHeader.PlayerRoom) {
#line 963
        Redraw = 1;
      }
#line 964
      (Items + 9)->Location = (unsigned char)255;
#line 965
      BitFlags &= (long )(~ (1 << 16));
#line 966
      goto switch_break___0;
      case_70: /* CIL Label */ 
      {
#line 968
      ClearScreen();
#line 969
      OutReset();
      }
#line 970
      goto switch_break___0;
      case_71: /* CIL Label */ 
      {
#line 972
      SaveGame();
      }
#line 973
      goto switch_break___0;
      case_72: /* CIL Label */ 
#line 976
      tmp___12 = pptr;
#line 976
      pptr ++;
#line 976
      i1 = param[tmp___12];
#line 977
      tmp___13 = pptr;
#line 977
      pptr ++;
#line 977
      i2 = param[tmp___13];
#line 978
      t = (int )(Items + i1)->Location;
#line 979
      if (t == (int )GameHeader.PlayerRoom) {
#line 980
        Redraw = 1;
      } else
#line 979
      if ((int )(Items + i2)->Location == (int )GameHeader.PlayerRoom) {
#line 980
        Redraw = 1;
      }
#line 981
      (Items + i1)->Location = (Items + i2)->Location;
#line 982
      (Items + i2)->Location = (unsigned char )t;
#line 983
      goto switch_break___0;
      case_73: /* CIL Label */ 
#line 986
      continuation = 1;
#line 987
      goto switch_break___0;
      case_74: /* CIL Label */ 
#line 989
      if ((int )(Items + param[pptr])->Location == (int )GameHeader.PlayerRoom) {
#line 990
        Redraw = 1;
      }
#line 991
      tmp___14 = pptr;
#line 991
      pptr ++;
#line 991
      (Items + param[tmp___14])->Location = (unsigned char)255;
#line 992
      goto switch_break___0;
      case_75: /* CIL Label */ 
#line 996
      tmp___15 = pptr;
#line 996
      pptr ++;
#line 996
      i1___0 = param[tmp___15];
#line 997
      tmp___16 = pptr;
#line 997
      pptr ++;
#line 997
      i2___0 = param[tmp___16];
#line 998
      if ((int )(Items + i1___0)->Location == (int )GameHeader.PlayerRoom) {
#line 999
        Redraw = 1;
      }
#line 1000
      (Items + i1___0)->Location = (Items + i2___0)->Location;
#line 1001
      if ((int )(Items + i2___0)->Location == (int )GameHeader.PlayerRoom) {
#line 1002
        Redraw = 1;
      }
#line 1003
      goto switch_break___0;
      case_76: /* CIL Label */ 
      {
#line 1006
      Look();
      }
#line 1007
      goto switch_break___0;
      case_77: /* CIL Label */ 
#line 1009
      if (CurrentCounter >= 0) {
#line 1010
        CurrentCounter --;
      }
#line 1011
      goto switch_break___0;
      case_78: /* CIL Label */ 
      {
#line 1013
      OutputNumber(CurrentCounter);
      }
#line 1014
      goto switch_break___0;
      case_79: /* CIL Label */ 
#line 1016
      tmp___17 = pptr;
#line 1016
      pptr ++;
#line 1016
      CurrentCounter = param[tmp___17];
#line 1017
      goto switch_break___0;
      case_80: /* CIL Label */ 
#line 1020
      t___0 = (int )GameHeader.PlayerRoom;
#line 1021
      GameHeader.PlayerRoom = (short )SavedRoom;
#line 1022
      SavedRoom = t___0;
#line 1023
      Redraw = 1;
#line 1024
      goto switch_break___0;
      case_81: /* CIL Label */ 
#line 1032
      tmp___18 = pptr;
#line 1032
      pptr ++;
#line 1032
      t___1 = param[tmp___18];
#line 1033
      c1 = CurrentCounter;
#line 1034
      CurrentCounter = Counters[t___1];
#line 1035
      Counters[t___1] = c1;
#line 1036
      goto switch_break___0;
      case_82: /* CIL Label */ 
#line 1039
      tmp___19 = pptr;
#line 1039
      pptr ++;
#line 1039
      CurrentCounter += param[tmp___19];
#line 1040
      goto switch_break___0;
      case_83: /* CIL Label */ 
#line 1042
      tmp___20 = pptr;
#line 1042
      pptr ++;
#line 1042
      CurrentCounter -= param[tmp___20];
#line 1043
      if (CurrentCounter < -1) {
#line 1044
        CurrentCounter = -1;
      }
#line 1047
      goto switch_break___0;
      case_84: /* CIL Label */ 
      {
#line 1049
      Output(NounText);
      }
#line 1050
      goto switch_break___0;
      case_85: /* CIL Label */ 
      {
#line 1052
      Output(NounText);
#line 1053
      Output((char *)"\n");
      }
#line 1054
      goto switch_break___0;
      case_86: /* CIL Label */ 
      {
#line 1056
      Output((char *)"\n");
      }
#line 1057
      goto switch_break___0;
      case_87: /* CIL Label */ 
#line 1062
      tmp___21 = pptr;
#line 1062
      pptr ++;
#line 1062
      p = param[tmp___21];
#line 1063
      sr = (int )GameHeader.PlayerRoom;
#line 1064
      GameHeader.PlayerRoom = (short )RoomSaved[p];
#line 1065
      RoomSaved[p] = sr;
#line 1066
      Redraw = 1;
#line 1067
      goto switch_break___0;
      case_88: /* CIL Label */ 
      {
#line 1070
      wrefresh(Top);
#line 1071
      wrefresh(Bottom);
#line 1072
      sleep(2);
      }
#line 1073
      goto switch_break___0;
      case_89: /* CIL Label */ 
#line 1075
      pptr ++;
#line 1079
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 1081
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown action %d [Param begins %d %d]\n",
              act[cc], param[pptr], param[pptr + 1]);
      }
#line 1083
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1085
    cc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1087
  return (1 + continuation);
}
}
#line 1093
int PerformActions(int vb , int no ) ;
#line 1093 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
static int disable_sysfunc  =    0;
#line 1091 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
int PerformActions(int vb , int no ) 
{ 
  int d ;
  int ct ;
  int fl ;
  int doagain ;
  int nl___0 ;
  int vv ;
  int nv ;
  int f2 ;
  int tmp ;
  int i ;
  int ct___0 ;
  int f ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int ct___1 ;
  int f___0 ;
  int tmp___3 ;

  {
#line 1094
  d = (int )(BitFlags & (long )(1 << 15));
#line 1096
  ct = 0;
#line 1098
  doagain = 0;
#line 1099
  if (vb == 1) {
#line 1099
    if (no == -1) {
      {
#line 1101
      Output((char *)"Give me a direction too.");
      }
#line 1102
      return (0);
    }
  }
#line 1104
  if (vb == 1) {
#line 1104
    if (no >= 1) {
#line 1104
      if (no <= 6) {
#line 1107
        if ((int )(Items + 9)->Location == (int )GameHeader.PlayerRoom) {
#line 1109
          d = 0;
        } else
#line 1107
        if ((int )(Items + 9)->Location == 255) {
#line 1109
          d = 0;
        }
#line 1110
        if (d) {
          {
#line 1111
          Output((char *)"Dangerous to move in the dark! ");
          }
        }
#line 1112
        nl___0 = (int )(Rooms + GameHeader.PlayerRoom)->Exits[no - 1];
#line 1113
        if (nl___0 != 0) {
          {
#line 1115
          GameHeader.PlayerRoom = (short )nl___0;
#line 1116
          Look();
          }
#line 1117
          return (0);
        }
#line 1119
        if (d) {
#line 1121
          if (Options & 1) {
            {
#line 1122
            Output((char *)"You fell down and broke your neck. ");
            }
          } else {
            {
#line 1124
            Output((char *)"I fell down and broke my neck. ");
            }
          }
          {
#line 1125
          wrefresh(Bottom);
#line 1126
          sleep(5);
#line 1127
          endwin();
#line 1128
          exit(0);
          }
        }
#line 1130
        if (Options & 1) {
          {
#line 1131
          Output((char *)"You can\'t go in that direction. ");
          }
        } else {
          {
#line 1133
          Output((char *)"I can\'t go in that direction. ");
          }
        }
#line 1134
        return (0);
      }
    }
  }
#line 1136
  fl = -1;
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! (ct <= (int )GameHeader.NumActions)) {
#line 1137
      goto while_break;
    }
#line 1140
    vv = (int )(Actions + ct)->Vocab;
#line 1143
    if (vb != 0) {
#line 1143
      if (doagain) {
#line 1143
        if (vv != 0) {
#line 1144
          goto while_break;
        }
      }
    }
#line 1146
    if (vb != 0) {
#line 1146
      if (! doagain) {
#line 1146
        if (fl == 0) {
#line 1147
          goto while_break;
        }
      }
    }
#line 1148
    nv = vv % 150;
#line 1149
    vv /= 150;
#line 1150
    if (vv == vb) {
#line 1150
      goto _L___2;
    } else
#line 1150
    if (doagain) {
#line 1150
      if ((int )(Actions + ct)->Vocab == 0) {
        _L___2: /* CIL Label */ 
#line 1152
        if (vv == 0) {
          {
#line 1152
          tmp = RandomPercent(nv);
          }
#line 1152
          if (tmp) {
#line 1152
            goto _L___0;
          } else {
#line 1152
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1152
        if (doagain) {
#line 1152
          goto _L___0;
        } else
#line 1152
        if (vv != 0) {
#line 1152
          if (nv == no) {
#line 1152
            goto _L___0;
          } else
#line 1152
          if (nv == 0) {
            _L___0: /* CIL Label */ 
#line 1156
            if (fl == -1) {
#line 1157
              fl = -2;
            }
            {
#line 1158
            f2 = PerformLine(ct);
            }
#line 1158
            if (f2 > 0) {
#line 1161
              fl = 0;
#line 1162
              if (f2 == 2) {
#line 1163
                doagain = 1;
              }
#line 1164
              if (vb != 0) {
#line 1164
                if (doagain == 0) {
#line 1165
                  return;
                }
              }
            }
          }
        }
      }
    }
#line 1169
    ct ++;
#line 1170
    if ((int )(Actions + ct)->Vocab != 0) {
#line 1171
      doagain = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1173
  if (fl != 0) {
#line 1173
    if (disable_sysfunc == 0) {
#line 1176
      if ((int )(Items + 9)->Location == (int )GameHeader.PlayerRoom) {
#line 1178
        d = 0;
      } else
#line 1176
      if ((int )(Items + 9)->Location == 255) {
#line 1178
        d = 0;
      }
#line 1179
      if (vb == 10) {
#line 1179
        goto _L___3;
      } else
#line 1179
      if (vb == 18) {
        _L___3: /* CIL Label */ 
#line 1182
        if (vb == 10) {
          {
#line 1184
          tmp___1 = strcasecmp((char const   *)(NounText), "ALL");
          }
#line 1184
          if (tmp___1 == 0) {
#line 1186
            ct___0 = 0;
#line 1187
            f = 0;
#line 1189
            if (d) {
              {
#line 1191
              Output((char *)"It is dark.\n");
              }
#line 1192
              return (0);
            }
            {
#line 1194
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1194
              if (! (ct___0 <= (int )GameHeader.NumItems)) {
#line 1194
                goto while_break___0;
              }
#line 1196
              if ((int )(Items + ct___0)->Location == (int )GameHeader.PlayerRoom) {
#line 1196
                if ((unsigned long )(Items + ct___0)->AutoGet != (unsigned long )((void *)0)) {
#line 1196
                  if ((int )*((Items + ct___0)->AutoGet + 0) != 42) {
                    {
#line 1198
                    no = WhichWord((Items + ct___0)->AutoGet, Nouns);
#line 1199
                    disable_sysfunc = 1;
#line 1200
                    PerformActions(vb, no);
#line 1201
                    disable_sysfunc = 0;
#line 1202
                    tmp___0 = CountCarried();
                    }
#line 1202
                    if (tmp___0 == (int )GameHeader.MaxCarry) {
#line 1204
                      if (Options & 1) {
                        {
#line 1205
                        Output((char *)"You are carrying too much. ");
                        }
                      } else {
                        {
#line 1207
                        Output((char *)"I\'ve too much to carry. ");
                        }
                      }
#line 1208
                      return (0);
                    }
                    {
#line 1210
                    (Items + ct___0)->Location = (unsigned char)255;
#line 1211
                    Redraw = 1;
#line 1212
                    OutBuf((Items + ct___0)->Text);
#line 1213
                    Output((char *)": O.K.\n");
#line 1214
                    f = 1;
                    }
                  }
                }
              }
#line 1216
              ct___0 ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1218
            if (f == 0) {
              {
#line 1219
              Output((char *)"Nothing taken.");
              }
            }
#line 1220
            return (0);
          }
#line 1222
          if (no == -1) {
            {
#line 1224
            Output((char *)"What ? ");
            }
#line 1225
            return (0);
          }
          {
#line 1227
          tmp___2 = CountCarried();
          }
#line 1227
          if (tmp___2 == (int )GameHeader.MaxCarry) {
#line 1229
            if (Options & 1) {
              {
#line 1230
              Output((char *)"You are carrying too much. ");
              }
            } else {
              {
#line 1232
              Output((char *)"I\'ve too much to carry. ");
              }
            }
#line 1233
            return (0);
          }
          {
#line 1235
          i = MatchUpItem(NounText, (int )GameHeader.PlayerRoom);
          }
#line 1236
          if (i == -1) {
#line 1238
            if (Options & 1) {
              {
#line 1239
              Output((char *)"It is beyond your power to do that. ");
              }
            } else {
              {
#line 1241
              Output((char *)"It\'s beyond my power to do that. ");
              }
            }
#line 1242
            return (0);
          }
          {
#line 1244
          (Items + i)->Location = (unsigned char)255;
#line 1245
          Output((char *)"O.K. ");
#line 1246
          Redraw = 1;
          }
#line 1247
          return (0);
        }
#line 1249
        if (vb == 18) {
          {
#line 1251
          tmp___3 = strcasecmp((char const   *)(NounText), "ALL");
          }
#line 1251
          if (tmp___3 == 0) {
#line 1253
            ct___1 = 0;
#line 1254
            f___0 = 0;
            {
#line 1255
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1255
              if (! (ct___1 <= (int )GameHeader.NumItems)) {
#line 1255
                goto while_break___1;
              }
#line 1257
              if ((int )(Items + ct___1)->Location == 255) {
#line 1257
                if ((Items + ct___1)->AutoGet) {
#line 1257
                  if ((int )*((Items + ct___1)->AutoGet + 0) != 42) {
                    {
#line 1259
                    no = WhichWord((Items + ct___1)->AutoGet, Nouns);
#line 1260
                    disable_sysfunc = 1;
#line 1261
                    PerformActions(vb, no);
#line 1262
                    disable_sysfunc = 0;
#line 1263
                    (Items + ct___1)->Location = (unsigned char )GameHeader.PlayerRoom;
#line 1264
                    OutBuf((Items + ct___1)->Text);
#line 1265
                    Output((char *)": O.K.\n");
#line 1266
                    Redraw = 1;
#line 1267
                    f___0 = 1;
                    }
                  }
                }
              }
#line 1269
              ct___1 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1271
            if (f___0 == 0) {
              {
#line 1272
              Output((char *)"Nothing dropped.\n");
              }
            }
#line 1273
            return (0);
          }
#line 1275
          if (no == -1) {
            {
#line 1277
            Output((char *)"What ? ");
            }
#line 1278
            return (0);
          }
          {
#line 1280
          i = MatchUpItem(NounText, 255);
          }
#line 1281
          if (i == -1) {
#line 1283
            if (Options & 1) {
              {
#line 1284
              Output((char *)"It\'s beyond your power to do that.\n");
              }
            } else {
              {
#line 1286
              Output((char *)"It\'s beyond my power to do that.\n");
              }
            }
#line 1287
            return (0);
          }
          {
#line 1289
          (Items + i)->Location = (unsigned char )GameHeader.PlayerRoom;
#line 1290
          Output((char *)"O.K. ");
#line 1291
          Redraw = 1;
          }
#line 1292
          return (0);
        }
      }
    }
  }
#line 1296
  return (fl);
}
}
#line 1392
extern int ( /* missing proto */  time)() ;
#line 1392
extern int ( /* missing proto */  getpid)() ;
#line 1392
extern int ( /* missing proto */  getuid)() ;
#line 1299 "/home/june/repo/benchmarks/collector/temp/scottfree-1.14/ScottCurses.c"
void main(int argc , char **argv ) 
{ 
  FILE *f ;
  int vb ;
  int no ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1304
    if (! *(argv + 1)) {
#line 1304
      goto while_break;
    }
#line 1306
    if ((int )*(*(argv + 1)) != 45) {
#line 1307
      goto while_break;
    }
    {
#line 1310
    if ((int )*(*(argv + 1) + 1) == 121) {
#line 1310
      goto case_121;
    }
#line 1313
    if ((int )*(*(argv + 1) + 1) == 105) {
#line 1313
      goto case_105;
    }
#line 1316
    if ((int )*(*(argv + 1) + 1) == 100) {
#line 1316
      goto case_100;
    }
#line 1319
    if ((int )*(*(argv + 1) + 1) == 115) {
#line 1319
      goto case_115;
    }
#line 1322
    if ((int )*(*(argv + 1) + 1) == 116) {
#line 1322
      goto case_116;
    }
#line 1325
    if ((int )*(*(argv + 1) + 1) == 112) {
#line 1325
      goto case_112;
    }
#line 1329
    goto switch_default;
    case_121: /* CIL Label */ 
#line 1311
    Options |= 1;
#line 1312
    goto switch_break;
    case_105: /* CIL Label */ 
#line 1314
    Options &= -2;
#line 1315
    goto switch_break;
    case_100: /* CIL Label */ 
#line 1317
    Options |= 4;
#line 1318
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1320
    Options |= 2;
#line 1321
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1323
    Options |= 8;
#line 1324
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1326
    Options |= 16;
#line 1327
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: [-h] [-y] [-s] [-i] [-t] [-d] [-p] <gamename> [savedgame].\n",
            *(argv + 0));
#line 1332
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 1334
    if ((int )*(*(argv + 1) + 2) != 0) {
      {
#line 1336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option -%c does not take a parameter.\n",
              *(argv + 0), (int )*(*(argv + 1) + 1));
#line 1338
      exit(1);
      }
    }
#line 1340
    argv ++;
#line 1341
    argc --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1344
  if (argc != 2) {
#line 1344
    if (argc != 3) {
      {
#line 1346
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s <database> <savefile>.\n",
              *(argv + 0));
#line 1347
      exit(1);
      }
    }
  }
  {
#line 1349
  f = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 1350
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1352
    perror((char const   *)*(argv + 1));
#line 1353
    exit(1);
    }
  }
  {
#line 1355
  signal(2, (void (*)(int  ))(& Aborted));
#line 1356
  signal(3, (void (*)(int  ))1);
#line 1357
  signal(20, (void (*)(int  ))1);
  }
#line 1359
  if (Options & 8) {
#line 1361
    Width = 64;
#line 1362
    TopHeight = 11;
#line 1363
    BottomHeight = 13;
  } else {
#line 1367
    Width = 80;
#line 1368
    TopHeight = 10;
#line 1369
    BottomHeight = 14;
  }
  {
#line 1372
  DisplayUp = 1;
#line 1373
  initscr();
#line 1374
  Top = newwin(TopHeight, Width, 0, 0);
#line 1375
  Bottom = newwin(BottomHeight, Width, TopHeight, 0);
#line 1376
  scrollok(Bottom, (_Bool)1);
#line 1377
  leaveok(Top, (_Bool)1);
#line 1378
  leaveok(Bottom, (_Bool)0);
#line 1379
  idlok(Bottom, (_Bool)1);
#line 1380
  noecho();
#line 1381
  cbreak();
#line 1382
  wmove(Bottom, BottomHeight - 1, 0);
#line 1383
  OutReset();
#line 1384
  OutBuf((char *)"Scott Free, A Scott Adams game driver in C.\nRelease 1.14, (c) 1993,1994,1995 Swansea University Computer Society.\nDistributed under the GNU software license\n\n");
  }
#line 1388
  if (Options & 4) {
#line 1388
    tmp = 1;
  } else {
#line 1388
    tmp = 0;
  }
  {
#line 1388
  LoadDatabase(f, tmp);
#line 1389
  fclose(f);
  }
#line 1390
  if (argc == 3) {
    {
#line 1391
    LoadGame(*(argv + 2));
    }
  }
  {
#line 1392
  tmp___0 = time((void *)0);
#line 1392
  tmp___1 = getpid();
#line 1392
  tmp___2 = getuid();
#line 1392
  srand((unsigned int )((tmp___0 ^ tmp___1) ^ tmp___2));
#line 1393
  Look();
  }
  {
#line 1394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1396
    if (Redraw != 0) {
      {
#line 1398
      Look();
#line 1399
      Redraw = 0;
      }
    }
    {
#line 1401
    PerformActions(0, 0);
    }
#line 1402
    if (Redraw != 0) {
      {
#line 1404
      Look();
#line 1405
      Redraw = 0;
      }
    }
    {
#line 1407
    GetInput(& vb, & no);
#line 1408
    tmp___3 = PerformActions(vb, no);
    }
    {
#line 1410
    if (tmp___3 == -1) {
#line 1410
      goto case_neg_1;
    }
#line 1412
    if (tmp___3 == -2) {
#line 1412
      goto case_neg_2;
    }
#line 1408
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1410
    Output((char *)"I don\'t understand your command. ");
    }
#line 1411
    goto switch_break___0;
    case_neg_2: /* CIL Label */ 
    {
#line 1412
    Output((char *)"I can\'t do that yet. ");
    }
#line 1413
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1416
    if ((int )(Items + 9)->Location != 0) {
#line 1416
      if ((int )GameHeader.LightTime != -1) {
#line 1418
        GameHeader.LightTime = (short )((int )GameHeader.LightTime - 1);
#line 1419
        if ((int )GameHeader.LightTime < 1) {
#line 1421
          BitFlags |= (long )(1 << 16);
#line 1422
          if ((int )(Items + 9)->Location == 255) {
#line 1422
            goto _L;
          } else
#line 1422
          if ((int )(Items + 9)->Location == (int )GameHeader.PlayerRoom) {
            _L: /* CIL Label */ 
#line 1425
            if (Options & 2) {
              {
#line 1426
              Output((char *)"Light has run out! ");
              }
            } else {
              {
#line 1428
              Output((char *)"Your light has run out. ");
              }
            }
          }
#line 1430
          if (Options & 16) {
#line 1431
            (Items + 9)->Location = (unsigned char)0;
          }
        } else
#line 1433
        if ((int )GameHeader.LightTime < 25) {
#line 1435
          if ((int )(Items + 9)->Location == 255) {
#line 1435
            goto _L___0;
          } else
#line 1435
          if ((int )(Items + 9)->Location == (int )GameHeader.PlayerRoom) {
            _L___0: /* CIL Label */ 
#line 1439
            if (Options & 2) {
              {
#line 1441
              Output((char *)"Light runs out in ");
#line 1442
              OutputNumber((int )GameHeader.LightTime);
#line 1443
              Output((char *)" turns. ");
              }
            } else
#line 1447
            if ((int )GameHeader.LightTime % 5 == 0) {
              {
#line 1448
              Output((char *)"Your light is growing dim. ");
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
