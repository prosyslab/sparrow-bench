/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 32 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
enum __anonenum_proxy_type_47 {
    HTTP_TYPE = 0,
    SOCKS4_TYPE = 1,
    SOCKS5_TYPE = 2
} ;
#line 32 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
typedef enum __anonenum_proxy_type_47 proxy_type;
#line 33
enum __anonenum_chain_type_48 {
    DYNAMIC_TYPE = 0,
    STRICT_TYPE = 1,
    RANDOM_TYPE = 2
} ;
#line 33 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
typedef enum __anonenum_chain_type_48 chain_type;
#line 34
enum __anonenum_proxy_state_49 {
    PLAY_STATE = 0,
    DOWN_STATE = 1,
    BLOCKED_STATE = 2,
    BUSY_STATE = 3
} ;
#line 34 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
typedef enum __anonenum_proxy_state_49 proxy_state;
#line 37 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
struct __anonstruct_proxy_data_51 {
   unsigned int ip ;
   unsigned short port ;
   proxy_type pt ;
   proxy_state ps ;
   char user[256] ;
   char pass[256] ;
};
#line 37 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
typedef struct __anonstruct_proxy_data_51 proxy_data;
#line 59 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
struct __anonstruct_my_network_53 {
   int valid ;
   unsigned int subnetwork ;
   unsigned int subnetmask ;
};
#line 59 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
typedef struct __anonstruct_my_network_53 my_network;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 35 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
enum __anonenum_select_type_63 {
    RANDOMLY = 0,
    FIFOLY = 1
} ;
#line 35 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
typedef enum __anonenum_select_type_63 select_type;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/x86_64-linux-gnu/sys/socket.h"
int connect(int sock , struct sockaddr  const  * __restrict  addr , unsigned int len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) ;
#line 144
struct hostent *gethostbyname(char const   *name ) ;
#line 662
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) ;
#line 668
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *res ) ;
#line 677
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 64 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 57 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int connect_proxy_chain(int sock , unsigned int target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        int max_chain ) ;
#line 67
struct hostent *proxy_gethostbyname(char const   *name ) ;
#line 71 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int (*true_connect)(int  , struct sockaddr  const  * , socklen_t  )  ;
#line 74 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
struct hostent *(*true_gethostbyname)(char const   * )  ;
#line 79 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int (*true_getaddrinfo)(char const   * , char const   * , struct addrinfo  const  * ,
                        struct addrinfo ** )  ;
#line 82 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int (*true_freeaddrinfo)(struct addrinfo * )  ;
#line 88 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int (*true_getnameinfo)(struct sockaddr  const  * , socklen_t  , char * , socklen_t  ,
                        char * , socklen_t  , unsigned int  )  ;
#line 91 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
struct hostent *(*true_gethostbyaddr)(void const   * , socklen_t  , int  )  ;
#line 93
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) ;
#line 66 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
my_network localnet[20]  ;
#line 69 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int tcp_read_time_out  ;
#line 70 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int tcp_connect_time_out  ;
#line 71 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
chain_type proxychains_ct  ;
#line 72 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
proxy_data proxychains_pd[30720]  ;
#line 73 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int proxychains_proxy_count  =    0;
#line 74 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int proxychains_got_chain_data  =    0;
#line 75 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int proxychains_max_chain  =    1;
#line 76 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int proxychains_quiet_mode  =    0;
#line 77 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int proxychains_resolver  =    0;
#line 78 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
static int init_l  =    0;
#line 79
__inline static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ,
                                    my_network *subnets ) ;
#line 85 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
static void init_lib(void) 
{ 
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 89
  get_chain_data(proxychains_pd, (unsigned int *)(& proxychains_proxy_count), & proxychains_ct,
                 localnet);
#line 91
  tmp = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"connect");
#line 91
  true_connect = (int (*)(int  , struct sockaddr  const  * , socklen_t  ))tmp;
  }
#line 93
  if (! true_connect) {
    {
#line 94
    tmp___0 = dlerror();
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'connect\' %s\n",
            tmp___0);
#line 95
    exit(1);
    }
  }
  {
#line 101
  tmp___1 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"gethostbyname");
#line 101
  true_gethostbyname = (struct hostent *(*)(char const   * ))tmp___1;
  }
#line 104
  if (! true_gethostbyname) {
    {
#line 105
    tmp___2 = dlerror();
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'gethostbyname\' %s\n",
            tmp___2);
#line 107
    exit(1);
    }
  }
  {
#line 113
  tmp___3 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"getaddrinfo");
#line 113
  true_getaddrinfo = (int (*)(char const   * , char const   * , struct addrinfo  const  * ,
                              struct addrinfo ** ))tmp___3;
  }
#line 116
  if (! true_getaddrinfo) {
    {
#line 117
    tmp___4 = dlerror();
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'getaddrinfo\' %s\n",
            tmp___4);
#line 119
    exit(1);
    }
  }
  {
#line 125
  tmp___5 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"freeaddrinfo");
#line 125
  true_freeaddrinfo = (int (*)(struct addrinfo * ))tmp___5;
  }
#line 128
  if (! true_freeaddrinfo) {
    {
#line 129
    tmp___6 = dlerror();
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'freeaddrinfo\' %s\n",
            tmp___6);
#line 131
    exit(1);
    }
  }
  {
#line 137
  tmp___7 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"gethostbyaddr");
#line 137
  true_gethostbyaddr = (struct hostent *(*)(void const   * , socklen_t  , int  ))tmp___7;
  }
#line 140
  if (! true_gethostbyaddr) {
    {
#line 141
    tmp___8 = dlerror();
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'gethostbyaddr\' %s\n",
            tmp___8);
#line 143
    exit(1);
    }
  }
  {
#line 149
  tmp___9 = dlsym((void */* __restrict  */)((void *)-1L), (char const   */* __restrict  */)"getnameinfo");
#line 149
  true_getnameinfo = (int (*)(struct sockaddr  const  * , socklen_t  , char * , socklen_t  ,
                              char * , socklen_t  , unsigned int  ))tmp___9;
  }
#line 152
  if (! true_getnameinfo) {
    {
#line 153
    tmp___10 = dlerror();
#line 153
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load symbol \'getnameinfo\' %s\n",
            tmp___10);
#line 155
    exit(1);
    }
  }
#line 161
  init_l = 1;
#line 162
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
__inline static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ,
                                    my_network *subnets ) 
{ 
  int count ;
  int port_n ;
  int list ;
  int subcount ;
  char buff[1024] ;
  char type[1024] ;
  char host[1024] ;
  char user[1024] ;
  FILE *file ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *pc ;
  int len ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;

  {
#line 173
  count = 0;
#line 173
  port_n = 0;
#line 173
  list = 0;
#line 173
  subcount = 0;
#line 177
  if (proxychains_got_chain_data) {
#line 178
    return;
  }
  {
#line 181
  tcp_read_time_out = 4000;
#line 182
  tcp_connect_time_out = 10000;
#line 183
  *ct = (chain_type )0;
#line 185
  tmp = getenv("HOME");
#line 185
  snprintf((char */* __restrict  */)(buff), (size_t )256, (char const   */* __restrict  */)"%s/.proxychains/proxychains.conf",
           tmp);
#line 187
  file = fopen((char const   */* __restrict  */)"./proxychains.conf", (char const   */* __restrict  */)"r");
  }
#line 187
  if (! file) {
    {
#line 188
    file = fopen((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"r");
    }
#line 188
    if (! file) {
      {
#line 189
      file = fopen((char const   */* __restrict  */)"/etc/proxychains.conf", (char const   */* __restrict  */)"r");
      }
#line 189
      if (! file) {
        {
#line 191
        perror("Can\'t locate proxychains.conf");
#line 192
        exit(1);
        }
      }
    }
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp___14 = fgets((char */* __restrict  */)(buff), (int )sizeof(buff), (FILE */* __restrict  */)file);
    }
#line 195
    if (! tmp___14) {
#line 195
      goto while_break;
    }
    {
#line 196
    tmp___13 = strspn((char const   *)(buff), " ");
    }
#line 196
    if ((int )buff[tmp___13] != 35) {
#line 197
      if (list) {
        {
#line 198
        bzero((void *)(pd + count), sizeof(proxy_data ));
#line 200
        bzero((void *)(subnets + subcount), sizeof(my_network ));
#line 202
        (pd + count)->ps = (proxy_state )0;
#line 204
        port_n = 0;
#line 205
        sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%s %s %d %s %s",
               type, host, & port_n, (pd + count)->user, (pd + count)->pass);
#line 207
        (pd + count)->ip = inet_addr((char const   *)(host));
#line 208
        (pd + count)->port = htons((unsigned short )port_n);
#line 209
        tmp___3 = strcmp((char const   *)(type), "http");
        }
#line 209
        if (tmp___3) {
          {
#line 211
          tmp___2 = strcmp((char const   *)(type), "socks4");
          }
#line 211
          if (tmp___2) {
            {
#line 213
            tmp___1 = strcmp((char const   *)(type), "socks5");
            }
#line 213
            if (tmp___1) {
              {
#line 215
              tmp___0 = strcmp((char const   *)(type), "localnet");
              }
#line 215
              if (tmp___0) {
#line 221
                goto while_continue;
              } else {
                {
#line 216
                (subnets + subcount)->subnetwork = inet_addr((char const   *)(host));
#line 217
                (subnets + subcount)->subnetmask = inet_addr((char const   *)((pd + count)->user));
#line 218
                (subnets + subcount)->valid = 1;
#line 219
                (subnets + (subcount + 1))->valid = 0;
#line 220
                subcount ++;
                }
              }
            } else {
#line 214
              (pd + count)->pt = (proxy_type )2;
            }
          } else {
#line 212
            (pd + count)->pt = (proxy_type )1;
          }
        } else {
#line 210
          (pd + count)->pt = (proxy_type )0;
        }
#line 223
        if ((pd + count)->ip) {
#line 223
          if ((pd + count)->ip != 4294967295U) {
#line 223
            if (port_n) {
#line 224
              count ++;
#line 224
              if (count == 30720) {
#line 225
                goto while_break;
              }
            }
          }
        }
      } else {
        {
#line 227
        tmp___12 = strstr((char const   *)(buff), "[ProxyList]");
        }
#line 227
        if (tmp___12) {
#line 228
          list = 1;
        } else {
          {
#line 229
          tmp___11 = strstr((char const   *)(buff), "random_chain");
          }
#line 229
          if (tmp___11) {
#line 230
            *ct = (chain_type )2;
          } else {
            {
#line 231
            tmp___10 = strstr((char const   *)(buff), "strict_chain");
            }
#line 231
            if (tmp___10) {
#line 232
              *ct = (chain_type )1;
            } else {
              {
#line 233
              tmp___9 = strstr((char const   *)(buff), "dynamic_chain");
              }
#line 233
              if (tmp___9) {
#line 234
                *ct = (chain_type )0;
              } else {
                {
#line 235
                tmp___8 = strstr((char const   *)(buff), "tcp_read_time_out");
                }
#line 235
                if (tmp___8) {
                  {
#line 236
                  sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%s %d",
                         user, & tcp_read_time_out);
                  }
                } else {
                  {
#line 237
                  tmp___7 = strstr((char const   *)(buff), "tcp_connect_time_out");
                  }
#line 237
                  if (tmp___7) {
                    {
#line 238
                    sscanf((char const   */* __restrict  */)(buff), (char const   */* __restrict  */)"%s %d",
                           user, & tcp_connect_time_out);
                    }
                  } else {
                    {
#line 239
                    tmp___6 = strstr((char const   *)(buff), "chain_len");
                    }
#line 239
                    if (tmp___6) {
                      {
#line 241
                      pc = strchr((char const   *)(buff), '=');
#line 242
                      pc ++;
#line 242
                      len = atoi((char const   *)pc);
                      }
#line 243
                      if (len) {
#line 243
                        proxychains_max_chain = len;
                      } else {
#line 243
                        proxychains_max_chain = 1;
                      }
                    } else {
                      {
#line 244
                      tmp___5 = strstr((char const   *)(buff), "quiet_mode");
                      }
#line 244
                      if (tmp___5) {
#line 245
                        proxychains_quiet_mode = 1;
                      } else {
                        {
#line 246
                        tmp___4 = strstr((char const   *)(buff), "proxy_dns");
                        }
#line 246
                        if (tmp___4) {
#line 247
                          proxychains_resolver = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 252
  fclose(file);
#line 253
  *proxy_count = (unsigned int )count;
#line 254
  proxychains_got_chain_data = 1;
  }
#line 255
  return;
}
}
#line 259 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int connect(int sock , struct sockaddr  const  * __restrict  addr , unsigned int len ) 
{ 
  int socktype ;
  int optlen ;
  int flags ;
  int ret ;
  int lnnum ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 261
  socktype = 0;
#line 261
  optlen = 0;
#line 261
  flags = 0;
#line 261
  ret = 0;
#line 262
  lnnum = 0;
#line 263
  if (! init_l) {
    {
#line 264
    init_lib();
    }
  }
  {
#line 265
  optlen = (int )sizeof(socktype);
#line 266
  getsockopt(sock, 1, 3, (void */* __restrict  */)(& socktype), (socklen_t */* __restrict  */)(& optlen));
  }
#line 267
  if ((int )((struct sockaddr_in *)addr)->sin_family == 2) {
#line 267
    if (! (socktype == 1)) {
      {
#line 268
      tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
      }
#line 268
      return (tmp);
    }
  } else {
    {
#line 268
    tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
    }
#line 268
    return (tmp);
  }
  {
#line 270
  get_chain_data(proxychains_pd, (unsigned int *)(& proxychains_proxy_count), & proxychains_ct,
                 localnet);
#line 271
  lnnum = 0;
  }
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! (localnet[lnnum].valid == 1)) {
#line 271
      goto while_break;
    }
#line 273
    if ((((struct sockaddr_in *)addr)->sin_addr.s_addr & localnet[lnnum].subnetmask) == localnet[lnnum].subnetwork) {
      {
#line 275
      tmp___0 = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
      }
#line 275
      return (tmp___0);
    }
#line 271
    lnnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  flags = fcntl(sock, 3, 0);
  }
#line 280
  if (flags & 2048) {
    {
#line 281
    fcntl(sock, 4, 0);
    }
  }
  {
#line 282
  ret = connect_proxy_chain(sock, ((struct sockaddr_in *)addr)->sin_addr.s_addr, ((struct sockaddr_in *)addr)->sin_port,
                            proxychains_pd, (unsigned int )proxychains_proxy_count,
                            proxychains_ct, proxychains_max_chain);
#line 290
  fcntl(sock, 4, flags);
  }
#line 291
  if (ret != 0) {
    {
#line 292
    tmp___1 = __errno_location();
#line 292
    *tmp___1 = 111;
    }
  }
#line 293
  return (ret);
}
}
#line 296 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
struct hostent *gethostbyname(char const   *name ) 
{ 
  struct hostent *tmp ;
  struct hostent *tmp___0 ;

  {
#line 299
  if (! init_l) {
    {
#line 300
    init_lib();
    }
  }
#line 301
  if (proxychains_resolver) {
    {
#line 302
    tmp = proxy_gethostbyname(name);
    }
#line 302
    return (tmp);
  } else {
    {
#line 304
    tmp___0 = (*true_gethostbyname)(name);
    }
#line 304
    return (tmp___0);
  }
#line 306
  return ((struct hostent *)((void *)0));
}
}
#line 308 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) 
{ 
  int ret ;

  {
#line 312
  ret = 0;
#line 314
  if (! init_l) {
    {
#line 315
    init_lib();
    }
  }
#line 316
  if (proxychains_resolver) {
    {
#line 317
    ret = proxy_getaddrinfo((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                            (struct addrinfo **)res);
    }
  } else {
    {
#line 319
    ret = (*true_getaddrinfo)((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                              (struct addrinfo **)res);
    }
  }
#line 321
  return (ret);
}
}
#line 323
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *res ) ;
#line 323 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *res ) 
{ 


  {
#line 326
  if (! init_l) {
    {
#line 327
    init_lib();
    }
  }
#line 328
  if (! proxychains_resolver) {
    {
#line 329
    (*true_freeaddrinfo)(res);
    }
  } else {
    {
#line 331
    free((void *)res->ai_addr);
#line 332
    free((void *)res);
    }
  }
#line 334
  return;
}
}
#line 337 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) 
{ 
  int ret ;
  char *tmp ;
  uint16_t tmp___0 ;

  {
#line 342
  ret = 0;
#line 343
  if (! init_l) {
    {
#line 344
    init_lib();
    }
  }
#line 345
  if (! proxychains_resolver) {
    {
#line 346
    ret = (*true_getnameinfo)((struct sockaddr  const  *)sa, salen, (char *)host,
                              hostlen, (char *)serv, servlen, (unsigned int )flags);
    }
  } else {
#line 349
    if (hostlen) {
      {
#line 350
      tmp = inet_ntoa(((struct sockaddr_in *)sa)->sin_addr);
#line 350
      strncpy(host, (char const   */* __restrict  */)tmp, (size_t )hostlen);
      }
    }
#line 351
    if (servlen) {
      {
#line 352
      tmp___0 = ntohs(((struct sockaddr_in *)sa)->sin_port);
#line 352
      snprintf(serv, (size_t )servlen, (char const   */* __restrict  */)"%d", (int )tmp___0);
      }
    }
  }
#line 355
  return (ret);
}
}
#line 357 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/libproxychains.c"
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) 
{ 
  struct hostent *tmp ;

  {
#line 361
  if (! init_l) {
    {
#line 362
    init_lib();
    }
  }
#line 363
  if (! proxychains_resolver) {
    {
#line 364
    tmp = (*true_gethostbyaddr)(addr, len, type);
    }
#line 364
    return (tmp);
  }
#line 365
  return ((struct hostent *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 130 "/usr/include/netdb.h"
extern struct hostent *gethostent(void) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 66 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.h"
int proxychains_write_log(char *str  , ...) ;
#line 44 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static char const   base64[65]  = 
#line 44 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
#line 46 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static void encode_base_64(char *src , char *dest , int max_len ) 
{ 
  int n ;
  int l ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 49
  tmp = strlen((char const   *)src);
#line 49
  l = (int )tmp;
#line 50
  max_len = (max_len - 1) / 4;
#line 51
  i = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < max_len)) {
#line 51
      goto while_break;
    }
    {
#line 54
    if (l == 0) {
#line 54
      goto case_0;
    }
#line 56
    if (l == 1) {
#line 56
      goto case_1;
    }
#line 63
    if (l == 2) {
#line 63
      goto case_2;
    }
#line 70
    goto switch_default;
    case_0: /* CIL Label */ 
#line 55
    goto switch_break;
    case_1: /* CIL Label */ 
#line 57
    n = (int )*(src + 0) << 16;
#line 58
    tmp___0 = dest;
#line 58
    dest ++;
#line 58
    *tmp___0 = (char )base64[(n >> 18) & 63];
#line 59
    tmp___1 = dest;
#line 59
    dest ++;
#line 59
    *tmp___1 = (char )base64[(n >> 12) & 63];
#line 60
    tmp___2 = dest;
#line 60
    dest ++;
#line 60
    *tmp___2 = (char )'=';
#line 61
    tmp___3 = dest;
#line 61
    dest ++;
#line 61
    *tmp___3 = (char )'=';
#line 62
    goto switch_break;
    case_2: /* CIL Label */ 
#line 64
    n = ((int )*(src + 0) << 16) | ((int )*(src + 1) << 8);
#line 65
    tmp___4 = dest;
#line 65
    dest ++;
#line 65
    *tmp___4 = (char )base64[(n >> 18) & 63];
#line 66
    tmp___5 = dest;
#line 66
    dest ++;
#line 66
    *tmp___5 = (char )base64[(n >> 12) & 63];
#line 67
    tmp___6 = dest;
#line 67
    dest ++;
#line 67
    *tmp___6 = (char )base64[(n >> 6) & 63];
#line 68
    tmp___7 = dest;
#line 68
    dest ++;
#line 68
    *tmp___7 = (char )'=';
#line 69
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 71
    n = (((int )*(src + 0) << 16) | ((int )*(src + 1) << 8)) | (int )*(src + 2);
#line 72
    tmp___8 = dest;
#line 72
    dest ++;
#line 72
    *tmp___8 = (char )base64[(n >> 18) & 63];
#line 73
    tmp___9 = dest;
#line 73
    dest ++;
#line 73
    *tmp___9 = (char )base64[(n >> 12) & 63];
#line 74
    tmp___10 = dest;
#line 74
    dest ++;
#line 74
    *tmp___10 = (char )base64[(n >> 6) & 63];
#line 75
    tmp___11 = dest;
#line 75
    dest ++;
#line 75
    *tmp___11 = (char )base64[n & 63];
    switch_break: /* CIL Label */ ;
    }
#line 77
    if (l < 3) {
#line 77
      goto while_break;
    }
#line 51
    i ++;
#line 51
    src += 3;
#line 51
    l -= 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  tmp___12 = dest;
#line 79
  dest ++;
#line 79
  *tmp___12 = (char)0;
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
int proxychains_write_log(char *str  , ...) 
{ 
  char buff[20480] ;
  va_list arglist ;
  FILE *log_file ;

  {
#line 89
  log_file = stderr;
#line 90
  if (! proxychains_quiet_mode) {
    {
#line 92
    __builtin_va_start(arglist, str);
#line 93
    vsprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)str,
             arglist);
#line 94
    __builtin_va_end(arglist);
#line 95
    fprintf((FILE */* __restrict  */)log_file, (char const   */* __restrict  */)"%s",
            buff);
#line 96
    fflush(log_file);
    }
  }
#line 99
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int write_n_bytes(int fd , char *buff , size_t size ) 
{ 
  int i ;
  int wrote ;
  ssize_t tmp ;

  {
#line 104
  i = 0;
#line 104
  wrote = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 107
    tmp = write(fd, (void const   *)(buff + wrote), size - (size_t )wrote);
#line 107
    i = (int )tmp;
    }
#line 108
    if (i <= 0) {
#line 109
      return (i);
    }
#line 110
    wrote += i;
#line 111
    if ((size_t )wrote == size) {
#line 112
      return (wrote);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 138 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int read_n_bytes(int fd , char *buff , size_t size ) 
{ 
  int i ;
  int ready ;
  struct pollfd pfd[1] ;
  ssize_t tmp ;

  {
#line 143
  pfd[0].fd = fd;
#line 144
  pfd[0].events = (short)1;
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((size_t )i < size)) {
#line 145
      goto while_break;
    }
    {
#line 147
    pfd[0].revents = (short)0;
#line 148
    ready = poll(pfd, (nfds_t )1, tcp_read_time_out);
    }
#line 149
    if (ready != 1) {
#line 150
      return (-1);
    } else
#line 149
    if (! ((int )pfd[0].revents & 1)) {
#line 150
      return (-1);
    } else {
      {
#line 149
      tmp = read(fd, (void *)(buff + i), (size_t )1);
      }
#line 149
      if (1L != tmp) {
#line 150
        return (-1);
      }
    }
#line 145
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return ((int )size);
}
}
#line 155 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int timed_connect(int sock , struct sockaddr  const  *addr , unsigned int len ) 
{ 
  int ret ;
  int value ;
  int value_len ;
  struct pollfd pfd[1] ;
  int *tmp ;

  {
  {
#line 160
  pfd[0].fd = sock;
#line 161
  pfd[0].events = (short)4;
#line 162
  fcntl(sock, 4, 2048);
#line 163
  ret = (*true_connect)(sock, addr, len);
  }
#line 165
  if (ret == -1) {
    {
#line 165
    tmp = __errno_location();
    }
#line 165
    if (*tmp == 115) {
      {
#line 167
      ret = poll(pfd, (nfds_t )1, tcp_connect_time_out);
      }
#line 169
      if (ret == 1) {
        {
#line 171
        value_len = (int )sizeof(int );
#line 172
        getsockopt(sock, 1, 4, (void */* __restrict  */)(& value), (socklen_t */* __restrict  */)(& value_len));
        }
#line 174
        if (! value) {
#line 175
          ret = 0;
        } else {
#line 177
          ret = -1;
        }
      } else {
#line 180
        ret = -1;
      }
    } else {
#line 165
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 182
  if (! (ret == 0)) {
#line 185
    ret = -1;
  }
  {
#line 188
  fcntl(sock, 4, 0);
  }
#line 189
  return (ret);
}
}
#line 192 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int tunnel_to(int sock , unsigned int ip , unsigned short port , proxy_type pt ,
                     char *user , char *pass ) 
{ 
  int len ;
  char buff[8192] ;
  uint16_t tmp ;
  char *tmp___0 ;
  char src[256] ;
  char dst[512] ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char in[2] ;
  char out[515] ;
  char *cur ;
  int c ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 196
  bzero((void *)(buff), sizeof(buff));
  }
  {
#line 199
  if ((unsigned int )pt == 0U) {
#line 199
    goto case_0;
  }
#line 250
  if ((unsigned int )pt == 1U) {
#line 250
    goto case_1;
  }
#line 272
  if ((unsigned int )pt == 2U) {
#line 272
    goto case_2;
  }
#line 197
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 201
  tmp = ntohs(port);
#line 201
  tmp___0 = inet_ntoa(*((struct in_addr *)(& ip)));
#line 201
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CONNECT %s:%d HTTP/1.0\r\n",
          tmp___0, (int )tmp);
  }
#line 204
  if (*(user + 0)) {
    {
#line 208
    strcpy((char */* __restrict  */)(src), (char const   */* __restrict  */)user);
#line 209
    strcat((char */* __restrict  */)(src), (char const   */* __restrict  */)":");
#line 210
    strcat((char */* __restrict  */)(src), (char const   */* __restrict  */)pass);
#line 211
    encode_base_64(src, dst, 512);
#line 212
    strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"Proxy-Authorization: Basic ");
#line 213
    strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dst));
#line 214
    strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"\r\n\r\n");
    }
  } else {
    {
#line 217
    strcat((char */* __restrict  */)(buff), (char const   */* __restrict  */)"\r\n");
    }
  }
  {
#line 219
  tmp___1 = strlen((char const   *)(buff));
#line 219
  len = (int )tmp___1;
#line 221
  tmp___2 = send(sock, (void const   *)(buff), (size_t )len, 0);
  }
#line 221
  if ((ssize_t )len != tmp___2) {
#line 222
    return (2);
  }
  {
#line 224
  bzero((void *)(buff), sizeof(buff));
#line 225
  len = 0;
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (len < 8192)) {
#line 227
      goto while_break;
    }
    {
#line 229
    tmp___3 = read_n_bytes(sock, buff + len, (size_t )1);
    }
#line 229
    if (1 == tmp___3) {
#line 230
      len ++;
    } else {
#line 232
      return (2);
    }
#line 233
    if (len > 4) {
#line 233
      if ((int )buff[len - 1] == 10) {
#line 233
        if ((int )buff[len - 2] == 13) {
#line 233
          if ((int )buff[len - 3] == 10) {
#line 233
            if ((int )buff[len - 4] == 13) {
#line 238
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  if (len == 8192) {
#line 246
    return (5);
  } else
#line 242
  if ((int )buff[9] == 50) {
#line 242
    if ((int )buff[10] == 48) {
#line 242
      if (! ((int )buff[11] == 48)) {
#line 246
        return (5);
      }
    } else {
#line 246
      return (5);
    }
  } else {
#line 246
    return (5);
  }
#line 247
  return (0);
#line 249
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 252
  memset((void *)(buff), 0, sizeof(buff));
#line 253
  buff[0] = (char)4;
#line 254
  buff[1] = (char)1;
#line 255
  memcpy((void */* __restrict  */)(& buff[2]), (void const   */* __restrict  */)(& port),
         (size_t )2);
#line 256
  memcpy((void */* __restrict  */)(& buff[4]), (void const   */* __restrict  */)(& ip),
         (size_t )4);
#line 257
  tmp___4 = strlen((char const   *)user);
#line 257
  len = (int )(tmp___4 + 1UL);
  }
#line 258
  if (len > 1) {
    {
#line 259
    strcpy((char */* __restrict  */)(& buff[8]), (char const   */* __restrict  */)user);
    }
  }
  {
#line 260
  tmp___5 = write_n_bytes(sock, buff, (size_t )(8 + len));
  }
#line 260
  if (len + 8 != tmp___5) {
#line 261
    return (2);
  }
  {
#line 263
  tmp___6 = read_n_bytes(sock, buff, (size_t )8);
  }
#line 263
  if (8 != tmp___6) {
#line 264
    return (2);
  }
#line 266
  if ((int )buff[0] != 0) {
#line 267
    return (5);
  } else
#line 266
  if ((int )buff[1] != 90) {
#line 267
    return (5);
  }
#line 269
  return (0);
#line 271
  goto switch_break;
  case_2: /* CIL Label */ 
#line 274
  if (user) {
    {
#line 276
    buff[0] = (char)5;
#line 277
    buff[1] = (char)2;
#line 278
    buff[2] = (char)0;
#line 279
    buff[3] = (char)2;
#line 280
    tmp___7 = write_n_bytes(sock, buff, (size_t )4);
    }
#line 280
    if (4 != tmp___7) {
#line 281
      return (2);
    }
  } else {
    {
#line 285
    buff[0] = (char)5;
#line 286
    buff[1] = (char)1;
#line 287
    buff[2] = (char)0;
#line 288
    tmp___8 = write_n_bytes(sock, buff, (size_t )3);
    }
#line 288
    if (3 != tmp___8) {
#line 289
      return (2);
    }
  }
  {
#line 292
  memset((void *)(buff), 0, sizeof(buff));
#line 294
  tmp___9 = read_n_bytes(sock, buff, (size_t )2);
  }
#line 294
  if (2 != tmp___9) {
#line 295
    return (2);
  }
#line 297
  if ((int )buff[0] != 5) {
#line 297
    goto _L;
  } else
#line 297
  if ((int )buff[1] != 0) {
#line 297
    if ((int )buff[1] != 2) {
      _L: /* CIL Label */ 
#line 299
      if ((int )buff[0] == 5) {
#line 299
        if ((int )buff[1] == -1) {
#line 300
          return (5);
        } else {
#line 302
          return (2);
        }
      } else {
#line 302
        return (2);
      }
    }
  }
#line 305
  if ((int )buff[1] == 2) {
    {
#line 309
    cur = out;
#line 311
    tmp___10 = cur;
#line 311
    cur ++;
#line 311
    *tmp___10 = (char)1;
#line 312
    tmp___11 = strlen((char const   *)user);
#line 312
    c = (int )tmp___11;
#line 313
    tmp___12 = cur;
#line 313
    cur ++;
#line 313
    *tmp___12 = (char )c;
#line 314
    strncpy((char */* __restrict  */)cur, (char const   */* __restrict  */)user, (size_t )c);
#line 315
    cur += c;
#line 316
    tmp___13 = strlen((char const   *)pass);
#line 316
    c = (int )tmp___13;
#line 317
    tmp___14 = cur;
#line 317
    cur ++;
#line 317
    *tmp___14 = (char )c;
#line 318
    strncpy((char */* __restrict  */)cur, (char const   */* __restrict  */)pass, (size_t )c);
#line 319
    cur += c;
#line 321
    tmp___15 = write_n_bytes(sock, out, (size_t )(cur - out));
    }
#line 321
    if (cur - out != (long )tmp___15) {
#line 322
      return (2);
    }
    {
#line 325
    tmp___16 = read_n_bytes(sock, in, (size_t )2);
    }
#line 325
    if (2 != tmp___16) {
#line 326
      return (2);
    }
#line 327
    if ((int )in[0] != 1) {
#line 327
      goto _L___0;
    } else
#line 327
    if ((int )in[1] != 0) {
      _L___0: /* CIL Label */ 
#line 329
      if ((int )in[0] != 1) {
#line 330
        return (2);
      } else {
#line 332
        return (5);
      }
    }
  }
  {
#line 336
  buff[0] = (char)5;
#line 337
  buff[1] = (char)1;
#line 338
  buff[2] = (char)0;
#line 339
  buff[3] = (char)1;
#line 341
  memcpy((void */* __restrict  */)(& buff[4]), (void const   */* __restrict  */)(& ip),
         (size_t )4);
#line 342
  memcpy((void */* __restrict  */)(& buff[8]), (void const   */* __restrict  */)(& port),
         (size_t )2);
#line 345
  tmp___17 = write_n_bytes(sock, buff, (size_t )10);
  }
#line 345
  if (10 != tmp___17) {
#line 346
    return (2);
  }
  {
#line 348
  tmp___18 = read_n_bytes(sock, buff, (size_t )4);
  }
#line 348
  if (4 != tmp___18) {
#line 349
    return (2);
  }
#line 351
  if ((int )buff[0] != 5) {
#line 352
    return (2);
  } else
#line 351
  if ((int )buff[1] != 0) {
#line 352
    return (2);
  }
  {
#line 356
  if ((int )buff[3] == 1) {
#line 356
    goto case_1___0;
  }
#line 357
  if ((int )buff[3] == 4) {
#line 357
    goto case_4;
  }
#line 358
  if ((int )buff[3] == 3) {
#line 358
    goto case_3;
  }
#line 362
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 356
  len = 4;
#line 356
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 357
  len = 16;
#line 357
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 358
  len = 0;
#line 359
  tmp___19 = read_n_bytes(sock, (char *)(& len), (size_t )1);
  }
#line 359
  if (1 != tmp___19) {
#line 360
    return (2);
  }
#line 361
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 363
  return (2);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 366
  tmp___20 = read_n_bytes(sock, buff, (size_t )(len + 2));
  }
#line 366
  if (len + 2 != tmp___20) {
#line 367
    return (2);
  }
#line 369
  return (0);
#line 371
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 375
  return (2);
}
}
#line 378 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int start_chain(int *fd , proxy_data *pd , char *begin_mark ) 
{ 
  struct sockaddr_in addr ;
  uint16_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 382
  *fd = socket(2, 1, 0);
  }
#line 383
  if (*fd == -1) {
#line 384
    goto error;
  }
  {
#line 386
  tmp = htons(pd->port);
#line 386
  tmp___0 = inet_ntoa(*((struct in_addr *)(& pd->ip)));
#line 386
  proxychains_write_log((char *)"%s-<>-%s:%d-", begin_mark, tmp___0, (int )tmp);
#line 390
  pd->ps = (proxy_state )0;
#line 391
  bzero((void *)(& addr), sizeof(addr));
#line 392
  addr.sin_family = (sa_family_t )2;
#line 393
  addr.sin_addr.s_addr = pd->ip;
#line 394
  addr.sin_port = pd->port;
#line 395
  tmp___1 = timed_connect(*fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                          (unsigned int )sizeof(addr));
  }
#line 395
  if (tmp___1) {
#line 396
    pd->ps = (proxy_state )1;
#line 397
    goto error1;
  }
#line 399
  pd->ps = (proxy_state )3;
#line 400
  return (0);
  error1: 
  {
#line 402
  proxychains_write_log((char *)"<--timeout\n");
  }
  error: 
#line 404
  if (*fd != -1) {
    {
#line 405
    close(*fd);
    }
  }
#line 406
  return (2);
}
}
#line 409 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static proxy_data *select_proxy(select_type how , proxy_data *pd , int proxy_count ,
                                int *offset ) 
{ 
  int i ;
  int k ;
  time_t tmp ;
  int tmp___0 ;
  proxy_data *tmp___1 ;

  {
#line 412
  i = 0;
#line 412
  k = 0;
#line 413
  if (*offset >= proxy_count) {
#line 414
    return ((proxy_data *)((void *)0));
  }
  {
#line 416
  if ((unsigned int )how == 0U) {
#line 416
    goto case_0;
  }
#line 424
  if ((unsigned int )how == 1U) {
#line 424
    goto case_1;
  }
#line 431
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 417
  tmp = time((time_t *)((void *)0));
#line 417
  srand((unsigned int )tmp);
  }
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 419
    k ++;
#line 420
    tmp___0 = rand();
#line 420
    i = (int )((((double )proxy_count * 1.0) * (double )tmp___0) / ((double )2147483647 + 1.0));
    }
#line 418
    if ((unsigned int )(pd + i)->ps != 0U) {
#line 418
      if (! (k < proxy_count * 100)) {
#line 418
        goto while_break;
      }
    } else {
#line 418
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  goto switch_break;
  case_1: /* CIL Label */ 
#line 425
  i = *offset;
  {
#line 425
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 425
    if (! (i < proxy_count)) {
#line 425
      goto while_break___0;
    }
#line 426
    if ((unsigned int )(pd + i)->ps == 0U) {
#line 427
      *offset = i;
#line 428
      goto while_break___0;
    }
#line 425
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
#line 432
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 434
  if (i >= proxy_count) {
#line 435
    i = 0;
  }
#line 436
  if ((unsigned int )(pd + i)->ps == 0U) {
#line 436
    tmp___1 = pd + i;
  } else {
#line 436
    tmp___1 = (proxy_data *)((void *)0);
  }
#line 436
  return (tmp___1);
}
}
#line 440 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static void release_all(proxy_data *pd , int proxy_count ) 
{ 
  int i ;

  {
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i < proxy_count)) {
#line 443
      goto while_break;
    }
#line 444
    (pd + i)->ps = (proxy_state )0;
#line 443
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return;
}
}
#line 448 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static void release_busy(proxy_data *pd , int proxy_count ) 
{ 
  int i ;

  {
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! (i < proxy_count)) {
#line 451
      goto while_break;
    }
#line 452
    if ((unsigned int )(pd + i)->ps == 3U) {
#line 453
      (pd + i)->ps = (proxy_state )0;
    }
#line 451
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  return;
}
}
#line 457 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int calc_alive(proxy_data *pd , int proxy_count ) 
{ 
  int i ;
  int alive_count ;

  {
  {
#line 460
  alive_count = 0;
#line 461
  release_busy(pd, proxy_count);
#line 462
  i = 0;
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i < proxy_count)) {
#line 462
      goto while_break;
    }
#line 463
    if ((unsigned int )(pd + i)->ps == 0U) {
#line 464
      alive_count ++;
    }
#line 462
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (alive_count);
}
}
#line 469 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static int chain_step(int ns , proxy_data *pfrom , proxy_data *pto ) 
{ 
  int retcode ;
  uint16_t tmp ;
  char *tmp___0 ;

  {
  {
#line 471
  retcode = -1;
#line 473
  tmp = htons(pto->port);
#line 473
  tmp___0 = inet_ntoa(*((struct in_addr *)(& pto->ip)));
#line 473
  proxychains_write_log((char *)"<>-%s:%d-", tmp___0, (int )tmp);
#line 476
  retcode = tunnel_to(ns, pto->ip, pto->port, pfrom->pt, pfrom->user, pfrom->pass);
  }
  {
#line 480
  if (retcode == 0) {
#line 480
    goto case_0;
  }
#line 483
  if (retcode == 5) {
#line 483
    goto case_5;
  }
#line 488
  if (retcode == 2) {
#line 488
    goto case_2;
  }
#line 479
  goto switch_break;
  case_0: /* CIL Label */ 
#line 481
  pto->ps = (proxy_state )3;
#line 482
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 484
  pto->ps = (proxy_state )2;
#line 485
  proxychains_write_log((char *)"<--denied\n");
#line 486
  close(ns);
  }
#line 487
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 489
  pto->ps = (proxy_state )1;
#line 490
  proxychains_write_log((char *)"<--timeout\n");
#line 491
  close(ns);
  }
#line 492
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 494
  return (retcode);
}
}
#line 497 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
int connect_proxy_chain(int sock , unsigned int target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        int max_chain ) 
{ 
  proxy_data p4 ;
  proxy_data *p1 ;
  proxy_data *p2 ;
  proxy_data *p3 ;
  int ns ;
  int offset ;
  int alive_count ;
  int curr_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
#line 503
  ns = -1;
#line 504
  offset = 0;
#line 505
  alive_count = 0;
#line 506
  curr_len = 0;
#line 513
  p3 = & p4;
  again: 
  {
#line 517
  if ((unsigned int )ct == 0U) {
#line 517
    goto case_0;
  }
#line 539
  if ((unsigned int )ct == 1U) {
#line 539
    goto case_1;
  }
#line 560
  if ((unsigned int )ct == 2U) {
#line 560
    goto case_2;
  }
#line 516
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 518
  alive_count = calc_alive(pd, (int )proxy_count);
#line 519
  offset = 0;
  }
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    p1 = select_proxy((select_type )1, pd, (int )proxy_count, & offset);
    }
#line 521
    if (! p1) {
#line 522
      goto error_more;
    }
    {
#line 520
    tmp = start_chain(& ns, p1, (char *)"|D-chain|");
    }
#line 520
    if (0 != tmp) {
#line 520
      if (! ((unsigned int )offset < proxy_count)) {
#line 520
        goto while_break;
      }
    } else {
#line 520
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 524
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 525
    p2 = select_proxy((select_type )1, pd, (int )proxy_count, & offset);
    }
#line 526
    if (! p2) {
#line 527
      goto while_break___0;
    }
    {
#line 528
    tmp___0 = chain_step(ns, p1, p2);
    }
#line 528
    if (0 != tmp___0) {
#line 529
      goto again;
    }
#line 530
    p1 = p2;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 532
  proxychains_write_log((char *)"<>");
#line 533
  p3->ip = target_ip;
#line 534
  p3->port = target_port;
#line 535
  tmp___1 = chain_step(ns, p1, p3);
  }
#line 535
  if (0 != tmp___1) {
#line 536
    goto error;
  }
#line 537
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 540
  alive_count = calc_alive(pd, (int )proxy_count);
#line 541
  offset = 0;
#line 542
  p1 = select_proxy((select_type )1, pd, (int )proxy_count, & offset);
  }
#line 542
  if (! p1) {
#line 543
    goto error_strict;
  }
  {
#line 544
  tmp___2 = start_chain(& ns, p1, (char *)"|S-chain|");
  }
#line 544
  if (0 != tmp___2) {
#line 545
    goto error_strict;
  }
  {
#line 546
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 546
    if (! ((unsigned int )offset < proxy_count)) {
#line 546
      goto while_break___1;
    }
    {
#line 547
    p2 = select_proxy((select_type )1, pd, (int )proxy_count, & offset);
    }
#line 547
    if (! p2) {
#line 548
      goto while_break___1;
    }
    {
#line 549
    tmp___3 = chain_step(ns, p1, p2);
    }
#line 549
    if (0 != tmp___3) {
#line 550
      goto error_strict;
    }
#line 551
    p1 = p2;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 553
  proxychains_write_log((char *)"<>");
#line 554
  p3->ip = target_ip;
#line 555
  p3->port = target_port;
#line 556
  tmp___4 = chain_step(ns, p1, p3);
  }
#line 556
  if (0 != tmp___4) {
#line 557
    goto error;
  }
#line 558
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 561
  alive_count = calc_alive(pd, (int )proxy_count);
  }
#line 562
  if (alive_count < max_chain) {
#line 563
    goto error_more;
  }
#line 564
  offset = 0;
#line 564
  curr_len = offset;
  {
#line 565
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 566
    p1 = select_proxy((select_type )0, pd, (int )proxy_count, & offset);
    }
#line 566
    if (! p1) {
#line 567
      goto error_more;
    }
    {
#line 565
    tmp___5 = start_chain(& ns, p1, (char *)"|R-chain|");
    }
#line 565
    if (0 != tmp___5) {
#line 565
      if (! (offset < max_chain)) {
#line 565
        goto while_break___2;
      }
    } else {
#line 565
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 569
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 569
    curr_len ++;
#line 569
    if (! (curr_len < max_chain)) {
#line 569
      goto while_break___3;
    }
    {
#line 570
    p2 = select_proxy((select_type )0, pd, (int )proxy_count, & offset);
    }
#line 570
    if (! p2) {
#line 571
      goto error_more;
    }
    {
#line 572
    tmp___6 = chain_step(ns, p1, p2);
    }
#line 572
    if (0 != tmp___6) {
#line 573
      goto again;
    }
#line 574
    p1 = p2;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 576
  proxychains_write_log((char *)"<>");
#line 577
  p3->ip = target_ip;
#line 578
  p3->port = target_port;
#line 579
  tmp___7 = chain_step(ns, p1, p3);
  }
#line 579
  if (0 != tmp___7) {
#line 580
    goto error;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 585
  proxychains_write_log((char *)"<><>-OK\n");
#line 586
  dup2(ns, sock);
#line 587
  close(ns);
  }
#line 588
  return (0);
  error: 
#line 590
  if (ns != -1) {
    {
#line 591
    close(ns);
    }
  }
  {
#line 592
  tmp___8 = __errno_location();
#line 592
  *tmp___8 = 111;
  }
#line 593
  return (-1);
  error_more: 
  {
#line 596
  proxychains_write_log((char *)"\n!!!need more proxies!!!\n");
  }
  error_strict: 
  {
#line 598
  release_all(pd, (int )proxy_count);
  }
#line 599
  if (ns != -1) {
    {
#line 600
    close(ns);
    }
  }
  {
#line 601
  tmp___9 = __errno_location();
#line 601
  *tmp___9 = 110;
  }
#line 602
  return (-1);
}
}
#line 605 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static struct hostent hostent_space  ;
#line 606 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static in_addr_t resolved_addr  ;
#line 607 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static char *resolved_addr_p  ;
#line 608 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
static char addr_name[8192]  ;
#line 609 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
struct hostent *proxy_gethostbyname(char const   *name ) 
{ 
  int pipe_fd[2] ;
  char buff[256] ;
  in_addr_t addr ;
  pid_t pid ;
  int status ;
  struct hostent *hp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 618
  hostent_space.h_addr_list = & resolved_addr_p;
#line 619
  *(hostent_space.h_addr_list) = (char *)(& resolved_addr);
#line 620
  resolved_addr = (in_addr_t )0;
#line 622
  gethostname(buff, sizeof(buff));
#line 623
  tmp = strcmp((char const   *)(buff), name);
  }
#line 623
  if (! tmp) {
#line 624
    goto got_buff;
  }
  {
#line 626
  bzero((void *)(buff), sizeof(buff));
  }
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 630
    hp = gethostent();
    }
#line 630
    if (! hp) {
#line 630
      goto while_break;
    }
    {
#line 631
    tmp___0 = strcmp((char const   *)hp->h_name, name);
    }
#line 631
    if (! tmp___0) {
#line 632
      return (hp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  tmp___1 = pipe((int *)(pipe_fd));
  }
#line 634
  if (tmp___1) {
#line 635
    goto err;
  }
  {
#line 636
  pid = fork();
  }
  {
#line 639
  if (pid == 0) {
#line 639
    goto case_0;
  }
#line 648
  if (pid == -1) {
#line 648
    goto case_neg_1;
  }
#line 654
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 640
  proxychains_write_log((char *)"|DNS-request| %s \n", name);
#line 641
  dup2(pipe_fd[1], 1);
#line 644
  execl("/usr/lib/proxychains3/proxyresolv", "proxyresolv", name, (void *)0);
#line 645
  perror("can\'t exec proxyresolv");
#line 646
  exit(2);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 649
  close(pipe_fd[0]);
#line 650
  close(pipe_fd[1]);
#line 651
  perror("can\'t fork");
  }
#line 652
  goto err;
  switch_default: /* CIL Label */ 
  {
#line 655
  close(pipe_fd[1]);
#line 656
  waitpid(pid, & status, 0);
#line 657
  read(pipe_fd[0], (void *)(& buff), sizeof(buff));
#line 658
  close(pipe_fd[0]);
  }
  got_buff: 
  {
#line 660
  addr = inet_addr((char const   *)(buff));
  }
#line 661
  if (addr == 4294967295U) {
#line 662
    goto err_dns;
  }
  {
#line 663
  memcpy((void */* __restrict  */)*(hostent_space.h_addr_list), (void const   */* __restrict  */)(& addr),
         sizeof(struct in_addr ));
#line 665
  hostent_space.h_name = addr_name;
#line 666
  hostent_space.h_length = (int )sizeof(in_addr_t );
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 668
  tmp___2 = inet_ntoa(*((struct in_addr *)(& addr)));
#line 668
  proxychains_write_log((char *)"|DNS-response| %s is %s\n", name, tmp___2);
  }
#line 670
  return (& hostent_space);
  err_dns: 
  {
#line 672
  proxychains_write_log((char *)"|DNS-response|: %s does not exist\n", name);
  }
  err: 
#line 674
  return ((struct hostent *)((void *)0));
}
}
#line 676 "/home/wheatley/newnew/temp/proxychains-3.1/proxychains/core.c"
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) 
{ 
  struct servent *se ;
  struct hostent *hp ;
  struct sockaddr *sockaddr_space ;
  struct addrinfo *addrinfo_space ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  sa_family_t tmp___4 ;

  {
  {
#line 680
  se = (struct servent *)((void *)0);
#line 681
  hp = (struct hostent *)((void *)0);
#line 682
  sockaddr_space = (struct sockaddr *)((void *)0);
#line 683
  addrinfo_space = (struct addrinfo *)((void *)0);
#line 686
  tmp = malloc(sizeof(struct addrinfo ));
#line 686
  addrinfo_space = (struct addrinfo *)tmp;
  }
#line 687
  if (! addrinfo_space) {
#line 688
    goto err1;
  }
  {
#line 689
  tmp___0 = malloc(sizeof(struct sockaddr ));
#line 689
  sockaddr_space = (struct sockaddr *)tmp___0;
  }
#line 690
  if (! sockaddr_space) {
#line 691
    goto err2;
  }
  {
#line 692
  bzero((void *)sockaddr_space, sizeof(*sockaddr_space));
#line 693
  bzero((void *)addrinfo_space, sizeof(*addrinfo_space));
  }
#line 694
  if (node) {
    {
#line 694
    tmp___1 = inet_aton(node, & ((struct sockaddr_in *)sockaddr_space)->sin_addr);
    }
#line 694
    if (! tmp___1) {
      {
#line 696
      hp = proxy_gethostbyname(node);
      }
#line 697
      if (hp) {
        {
#line 698
        memcpy((void */* __restrict  */)(& ((struct sockaddr_in *)sockaddr_space)->sin_addr),
               (void const   */* __restrict  */)*(hp->h_addr_list), sizeof(in_addr_t ));
        }
      } else {
#line 702
        goto err3;
      }
    }
  }
#line 704
  if (service) {
    {
#line 705
    se = getservbyname(service, (char const   *)((void *)0));
    }
  }
#line 707
  if (! se) {
#line 708
    tmp___2 = service;
#line 708
    if (! tmp___2) {
#line 708
      tmp___2 = "0";
    }
    {
#line 708
    tmp___3 = atoi(tmp___2);
#line 708
    ((struct sockaddr_in *)sockaddr_space)->sin_port = htons((uint16_t )tmp___3);
    }
  } else {
#line 711
    ((struct sockaddr_in *)sockaddr_space)->sin_port = (in_port_t )se->s_port;
  }
#line 713
  *res = addrinfo_space;
#line 714
  (*res)->ai_addr = sockaddr_space;
#line 715
  if (node) {
    {
#line 716
    strcpy((char */* __restrict  */)(addr_name), (char const   */* __restrict  */)node);
    }
  }
#line 717
  (*res)->ai_canonname = addr_name;
#line 718
  (*res)->ai_next = (struct addrinfo *)((void *)0);
#line 719
  tmp___4 = (sa_family_t )2;
#line 719
  sockaddr_space->sa_family = tmp___4;
#line 719
  (*res)->ai_family = (int )tmp___4;
#line 720
  (*res)->ai_socktype = (int )hints->ai_socktype;
#line 721
  (*res)->ai_flags = (int )hints->ai_flags;
#line 722
  (*res)->ai_protocol = (int )hints->ai_protocol;
#line 723
  (*res)->ai_addrlen = (socklen_t )sizeof(*sockaddr_space);
#line 724
  goto out;
  err3: 
  {
#line 726
  free((void *)sockaddr_space);
  }
  err2: 
  {
#line 728
  free((void *)addrinfo_space);
  }
  err1: 
#line 730
  return (1);
  out: 
#line 732
  return (0);
}
}
