/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 32 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.h"
struct regexp {
   char *startp[10] ;
   char *endp[10] ;
   char regstart ;
   char reganch ;
   char *regmust ;
   int regmlen ;
   char program[1] ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.h"
typedef struct regexp regexp;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 214 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/defs.h"
struct LIST {
   char *str ;
   struct LIST *next ;
};
#line 214 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/defs.h"
typedef struct LIST LIST;
#line 7 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/nl_types.h"
typedef void *nl_catd;
#line 259 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
struct condition_rec {
   int matchwhat ;
   int relation ;
   char argument1[256] ;
   regexp *regex ;
   struct condition_rec *next ;
};
#line 267 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
struct ruleset_record {
   int line ;
   struct condition_rec *condition ;
   int action ;
   char argument2[256] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 280 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
struct __anonstruct_regmessage_29 {
   int id ;
   char *str ;
};
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 228 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char username[256] ;
#line 247
FILE *outfptr ;
#line 253
char user_mailbox[256] ;
#line 13 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.h"
char *safemalloc(int bsize ) ;
#line 14
void stringcopy(char *dest , char *src , int len ) ;
#line 2 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.h"
int lockfolder(char *foldername ) ;
#line 3
void unlockfolder(char *foldername ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.h"
char *date_n_user(void) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
static int we_locked_it  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
static char *lockfile  =    (char *)0;
#line 77
char *mk_lockname(char *file_to_lock ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
static char dotlock_name[256]  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
int Grab_the_file(int file_fd ) 
{ 
  int retcode ;
  int *tmp ;

  {
  {
#line 113
  retcode = 0;
#line 115
  tmp = __errno_location();
#line 115
  *tmp = 0;
  }
#line 154
  return (retcode);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
int Release_the_file(int file_fd ) 
{ 
  int fcntlret ;
  int flockret ;
  int fcntlerr ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 161
  fcntlret = 0;
#line 161
  flockret = 0;
#line 161
  fcntlerr = 0;
#line 183
  if (fcntlret) {
    {
#line 184
    tmp = __errno_location();
#line 184
    *tmp = fcntlerr;
    }
#line 185
    return (fcntlret);
  } else
#line 187
  if (flockret) {
    {
#line 188
    tmp___0 = __errno_location();
#line 188
    *tmp___0 = flockret;
    }
#line 189
    return (flockret);
  }
#line 191
  return (0);
}
}
#line 222
extern int ( /* missing proto */  kill)() ;
#line 200 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
int clearoldlock(char *fname ) 
{ 
  int lockfd ;
  char pid_buffer[10] ;
  int lockpid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 208
  tmp = access((char const   *)fname, 0);
  }
#line 208
  if (tmp != 0) {
#line 209
    return (0);
  }
  {
#line 216
  lockfd = open((char const   *)lockfile, 0);
  }
#line 216
  if (lockfd == -1) {
#line 217
    return (1);
  }
  {
#line 219
  tmp___2 = read(lockfd, (void *)(pid_buffer), (size_t )10);
  }
#line 219
  if (tmp___2 > 0L) {
    {
#line 220
    lockpid = atoi((char const   *)(pid_buffer));
    }
#line 221
    if (lockpid) {
      {
#line 222
      tmp___1 = kill(lockpid, 0);
      }
#line 222
      if (tmp___1) {
        {
#line 223
        close(lockfd);
#line 224
        tmp___0 = unlink((char const   *)lockfile);
        }
#line 224
        if (tmp___0 == 0) {
#line 225
          return (0);
        }
      }
    }
  }
#line 231
  return (1);
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
int lockfolder(char *foldername ) 
{ 
  char *lockfilename ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 303
  tmp = strlen((char const   *)foldername);
#line 303
  len = (int )tmp;
#line 304
  tmp___0 = safemalloc(len + 6);
#line 304
  lockfilename = tmp___0;
#line 305
  sprintf((char */* __restrict  */)lockfilename, (char const   */* __restrict  */)"%s.lock",
          foldername);
#line 306
  tmp___1 = clearoldlock(lockfilename);
  }
#line 306
  if (tmp___1 != 0) {
#line 308
    return (0);
  }
#line 322
  if ((unsigned long )lockfilename != (unsigned long )((void *)0)) {
    {
#line 323
    free((void *)lockfilename);
    }
  }
#line 325
  return (1);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
void unlockfolder(char *foldername ) 
{ 
  char *lockfilename ;
  int len ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 335
  tmp = strlen((char const   *)foldername);
#line 335
  len = (int )tmp;
#line 336
  tmp___0 = safemalloc(len + 6);
#line 336
  lockfilename = tmp___0;
#line 337
  sprintf((char */* __restrict  */)lockfilename, (char const   */* __restrict  */)"%s.lock",
          foldername);
#line 338
  unlink((char const   *)lockfilename);
#line 339
  free((void *)lockfilename);
  }
#line 346
  return;
}
}
#line 351 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
int lock(void) 
{ 
  int attempts ;
  int lockfd ;
  int ret ;
  char maildir[256] ;
  char *slash ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 354
  attempts = 0;
#line 355
  ret = 1;
#line 357
  tmp = strrchr((char const   *)(user_mailbox), '/');
#line 357
  slash = tmp;
  }
#line 358
  if ((unsigned long )slash == (unsigned long )((void *)0)) {
    {
#line 359
    strcpy((char */* __restrict  */)(maildir), (char const   */* __restrict  */)"/var/spool/mail/%u");
    }
  } else {
    {
#line 361
    stringcopy(maildir, user_mailbox, (int )((slash - user_mailbox) + 2L));
    }
  }
  {
#line 365
  stringcopy(dotlock_name, maildir, 256);
#line 366
  strncat((char */* __restrict  */)(dotlock_name), (char const   */* __restrict  */)(username),
          (size_t )256);
#line 367
  lockfile = mk_lockname(dotlock_name);
#line 369
  tmp___1 = clearoldlock(lockfile);
  }
#line 369
  if (tmp___1 != 0) {
#line 370
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 371
      tmp___0 = date_n_user();
#line 371
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): clearoldlock failed for %s!!\n",
              tmp___0, lockfile);
      }
    }
#line 377
    return (0);
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    lockfd = open((char const   *)lockfile, 193, 292);
    }
#line 380
    if (lockfd < 0) {
#line 380
      tmp___2 = attempts;
#line 380
      attempts ++;
#line 380
      if (! (tmp___2 < 10)) {
#line 380
        goto while_break;
      }
    } else {
#line 380
      goto while_break;
    }
    {
#line 382
    sleep(3U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (lockfd >= 0) {
    {
#line 386
    we_locked_it ++;
#line 387
    close(lockfd);
    }
  } else {
#line 389
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 390
      tmp___3 = date_n_user();
#line 390
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): open lock file failed for %s!!\n",
              tmp___3, lockfile);
      }
    }
#line 396
    ret = 0;
  }
#line 416
  return (ret);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/lock.c"
void unlock(void) 
{ 


  {
#line 425
  if (we_locked_it) {
#line 425
    if (*(lockfile + 0)) {
      {
#line 426
      unlink((char const   *)lockfile);
#line 427
      *(lockfile + 0) = (char)0;
      }
    }
  }
#line 443
  we_locked_it = 0;
#line 444
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/mk_lockname.c"
static char lock_name[256]  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/mk_lockname.c"
char *mk_lockname(char *file_to_lock ) 
{ 


  {
  {
#line 49
  sprintf((char */* __restrict  */)(lock_name), (char const   */* __restrict  */)"%s.lock",
          file_to_lock);
  }
#line 51
  return (lock_name);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.h"
regexp *regcomp(char *exp ) ;
#line 43
int regexec(regexp *prog , char *string ) ;
#line 45
void regerror(char *s ) ;
#line 204 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regparse  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static int regnpar  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char regdummy  ;
#line 207 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regcode  ;
#line 208 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static long regsize  ;
#line 216
static char *reg(int paren , int *flagp ) ;
#line 217
static char *regbranch(int *flagp ) ;
#line 218
static char *regpiece(int *flagp ) ;
#line 219
static char *regatom(int *flagp ) ;
#line 220
static char *regnode(char op ) ;
#line 221
static char *regnext(char *p ) ;
#line 222
static void regc(char b ) ;
#line 223
static void reginsert(char op , char *opnd ) ;
#line 224
static void regtail(char *p , char *val ) ;
#line 225
static void regoptail(char *p , char *val ) ;
#line 242 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
regexp *regcomp(char *exp ) 
{ 
  register regexp *r ;
  register char *scan ;
  register char *longest ;
  register int len ;
  int flags ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 252
  if ((unsigned long )exp == (unsigned long )((void *)0)) {
    {
#line 253
    regerror("NULL argument");
    }
#line 253
    return ((regexp *)((void *)0));
  }
  {
#line 256
  regparse = exp;
#line 257
  regnpar = 1;
#line 258
  regsize = 0L;
#line 259
  regcode = & regdummy;
#line 260
  regc(156);
#line 261
  tmp = reg(0, & flags);
  }
#line 261
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 262
    return ((regexp *)((void *)0));
  }
#line 265
  if (regsize >= 32767L) {
    {
#line 266
    regerror("regexp too big");
    }
#line 266
    return ((regexp *)((void *)0));
  }
  {
#line 269
  tmp___0 = malloc(sizeof(regexp ) + (unsigned long )((unsigned int )regsize));
#line 269
  r = (regexp *)tmp___0;
  }
#line 270
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 271
    regerror("out of space");
    }
#line 271
    return ((regexp *)((void *)0));
  }
  {
#line 274
  regparse = exp;
#line 275
  regnpar = 1;
#line 276
  regcode = r->program;
#line 277
  regc(156);
#line 278
  tmp___1 = reg(0, & flags);
  }
#line 278
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 279
    return ((regexp *)((void *)0));
  }
  {
#line 282
  r->regstart = (char )'\000';
#line 283
  r->reganch = (char)0;
#line 284
  r->regmust = (char *)((void *)0);
#line 285
  r->regmlen = 0;
#line 286
  scan = r->program + 1;
#line 287
  tmp___4 = regnext(scan);
  }
#line 287
  if ((int )*tmp___4 == 0) {
#line 288
    scan += 3;
#line 291
    if ((int )*scan == 8) {
#line 292
      r->regstart = *(scan + 3);
    } else
#line 293
    if ((int )*scan == 1) {
#line 294
      r->reganch = (char )((int )r->reganch + 1);
    }
#line 304
    if (flags & 4) {
#line 305
      longest = (char *)((void *)0);
#line 306
      len = 0;
      {
#line 307
      while (1) {
        while_continue: /* CIL Label */ ;
#line 307
        if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 307
          goto while_break;
        }
#line 308
        if ((int )*scan == 8) {
          {
#line 308
          tmp___3 = strlen((char const   *)(scan + 3));
          }
#line 308
          if (tmp___3 >= (size_t )len) {
            {
#line 309
            longest = scan + 3;
#line 310
            tmp___2 = strlen((char const   *)(scan + 3));
#line 310
            len = (int )tmp___2;
            }
          }
        }
        {
#line 307
        scan = regnext(scan);
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 312
      r->regmust = longest;
#line 313
      r->regmlen = len;
    }
  }
#line 317
  return (r);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *reg(int paren , int *flagp ) 
{ 
  register char *ret ;
  register char *br ;
  register char *ender ;
  register int parno ;
  int flags ;
  int tmp ;
  char *tmp___0 ;

  {
#line 337
  parno = 0;
#line 340
  *flagp = 1;
#line 343
  if (paren) {
#line 344
    if (regnpar >= 10) {
      {
#line 345
      regerror("too many ()");
      }
#line 345
      return ((char *)((void *)0));
    }
    {
#line 346
    parno = regnpar;
#line 347
    regnpar ++;
#line 348
    ret = regnode(20 + parno);
    }
  } else {
#line 350
    ret = (char *)((void *)0);
  }
  {
#line 353
  br = regbranch(& flags);
  }
#line 354
  if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 355
    return ((char *)((void *)0));
  }
#line 356
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 357
    regtail(ret, br);
    }
  } else {
#line 359
    ret = br;
  }
#line 360
  if (! (flags & 1)) {
#line 361
    *flagp &= -2;
  }
#line 362
  *flagp |= flags & 4;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! ((int )*regparse == 124)) {
#line 363
      goto while_break;
    }
    {
#line 364
    regparse ++;
#line 365
    br = regbranch(& flags);
    }
#line 366
    if ((unsigned long )br == (unsigned long )((void *)0)) {
#line 367
      return ((char *)((void *)0));
    }
    {
#line 368
    regtail(ret, br);
    }
#line 369
    if (! (flags & 1)) {
#line 370
      *flagp &= -2;
    }
#line 371
    *flagp |= flags & 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 375
  if (paren) {
#line 375
    tmp = 30 + parno;
  } else {
#line 375
    tmp = 0;
  }
  {
#line 375
  ender = regnode(tmp);
#line 376
  regtail(ret, ender);
#line 379
  br = ret;
  }
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! ((unsigned long )br != (unsigned long )((void *)0))) {
#line 379
      goto while_break___0;
    }
    {
#line 380
    regoptail(br, ender);
#line 379
    br = regnext(br);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 383
  if (paren) {
#line 383
    tmp___0 = regparse;
#line 383
    regparse ++;
#line 383
    if ((int )*tmp___0 != 41) {
      {
#line 384
      regerror("unmatched ()");
      }
#line 384
      return ((char *)((void *)0));
    } else {
#line 383
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 385
  if (! paren) {
#line 385
    if ((int )*regparse != 0) {
#line 386
      if ((int )*regparse == 41) {
        {
#line 387
        regerror("unmatched ()");
        }
#line 387
        return ((char *)((void *)0));
      } else {
        {
#line 389
        regerror("junk on end");
        }
#line 389
        return ((char *)((void *)0));
      }
    }
  }
#line 393
  return (ret);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regbranch(int *flagp ) 
{ 
  register char *ret ;
  register char *chain ;
  register char *latest ;
  int flags ;

  {
  {
#line 410
  *flagp = 0;
#line 412
  ret = regnode(6);
#line 413
  chain = (char *)((void *)0);
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if ((int )*regparse != 0) {
#line 414
      if ((int )*regparse != 124) {
#line 414
        if (! ((int )*regparse != 41)) {
#line 414
          goto while_break;
        }
      } else {
#line 414
        goto while_break;
      }
    } else {
#line 414
      goto while_break;
    }
    {
#line 415
    latest = regpiece(& flags);
    }
#line 416
    if ((unsigned long )latest == (unsigned long )((void *)0)) {
#line 417
      return ((char *)((void *)0));
    }
#line 418
    *flagp |= flags & 1;
#line 419
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 420
      *flagp |= flags & 4;
    } else {
      {
#line 422
      regtail(chain, latest);
      }
    }
#line 423
    chain = latest;
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 426
    regnode(9);
    }
  }
#line 428
  return (ret);
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regpiece(int *flagp ) 
{ 
  register char *ret ;
  register char op ;
  register char *next ;
  int flags ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 449
  ret = regatom(& flags);
  }
#line 450
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 451
    return ((char *)((void *)0));
  }
#line 453
  op = *regparse;
#line 454
  if (! ((int )op == 42)) {
#line 454
    if (! ((int )op == 43)) {
#line 454
      if (! ((int )op == 63)) {
#line 455
        *flagp = flags;
#line 456
        return (ret);
      }
    }
  }
#line 459
  if (! (flags & 1)) {
#line 459
    if ((int )op != 63) {
      {
#line 460
      regerror("*+ operand could be empty");
      }
#line 460
      return ((char *)((void *)0));
    }
  }
#line 461
  if ((int )op != 43) {
#line 461
    *flagp = 4;
  } else {
#line 461
    *flagp = 1;
  }
#line 463
  if ((int )op == 42) {
#line 463
    if (flags & 2) {
      {
#line 464
      reginsert(10, ret);
      }
    } else {
#line 463
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 465
  if ((int )op == 42) {
    {
#line 467
    reginsert(6, ret);
#line 468
    tmp = regnode(7);
#line 468
    regoptail(ret, tmp);
#line 469
    regoptail(ret, ret);
#line 470
    tmp___0 = regnode(6);
#line 470
    regtail(ret, tmp___0);
#line 471
    tmp___1 = regnode(9);
#line 471
    regtail(ret, tmp___1);
    }
  } else
#line 472
  if ((int )op == 43) {
#line 472
    if (flags & 2) {
      {
#line 473
      reginsert(11, ret);
      }
    } else {
#line 472
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 474
  if ((int )op == 43) {
    {
#line 476
    next = regnode(6);
#line 477
    regtail(ret, next);
#line 478
    tmp___2 = regnode(7);
#line 478
    regtail(tmp___2, ret);
#line 479
    tmp___3 = regnode(6);
#line 479
    regtail(next, tmp___3);
#line 480
    tmp___4 = regnode(9);
#line 480
    regtail(ret, tmp___4);
    }
  } else
#line 481
  if ((int )op == 63) {
    {
#line 483
    reginsert(6, ret);
#line 484
    tmp___5 = regnode(6);
#line 484
    regtail(ret, tmp___5);
#line 485
    next = regnode(9);
#line 486
    regtail(ret, next);
#line 487
    regoptail(ret, next);
    }
  }
#line 489
  regparse ++;
#line 490
  if ((int )*regparse == 42) {
    {
#line 491
    regerror("nested *?+");
    }
#line 491
    return ((char *)((void *)0));
  } else
#line 490
  if ((int )*regparse == 43) {
    {
#line 491
    regerror("nested *?+");
    }
#line 491
    return ((char *)((void *)0));
  } else
#line 490
  if ((int )*regparse == 63) {
    {
#line 491
    regerror("nested *?+");
    }
#line 491
    return ((char *)((void *)0));
  }
#line 493
  return (ret);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regatom(int *flagp ) 
{ 
  register char *ret ;
  int flags ;
  char *tmp ;
  register int class ;
  register int classend ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register int len ;
  register char ender ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
#line 511
  *flagp = 0;
#line 513
  tmp = regparse;
#line 513
  regparse ++;
  {
#line 514
  if ((int )*tmp == 94) {
#line 514
    goto case_94;
  }
#line 517
  if ((int )*tmp == 36) {
#line 517
    goto case_36;
  }
#line 520
  if ((int )*tmp == 46) {
#line 520
    goto case_46;
  }
#line 524
  if ((int )*tmp == 91) {
#line 524
    goto case_91;
  }
#line 559
  if ((int )*tmp == 40) {
#line 559
    goto case_40;
  }
#line 567
  if ((int )*tmp == 41) {
#line 567
    goto case_41;
  }
#line 567
  if ((int )*tmp == 124) {
#line 567
    goto case_41;
  }
#line 567
  if ((int )*tmp == 0) {
#line 567
    goto case_41;
  }
#line 571
  if ((int )*tmp == 42) {
#line 571
    goto case_42;
  }
#line 571
  if ((int )*tmp == 43) {
#line 571
    goto case_42;
  }
#line 571
  if ((int )*tmp == 63) {
#line 571
    goto case_42;
  }
#line 573
  if ((int )*tmp == 92) {
#line 573
    goto case_92;
  }
#line 581
  goto switch_default;
  case_94: /* CIL Label */ 
  {
#line 515
  ret = regnode(1);
  }
#line 516
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 518
  ret = regnode(2);
  }
#line 519
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 521
  ret = regnode(3);
#line 522
  *flagp |= 3;
  }
#line 523
  goto switch_break;
  case_91: /* CIL Label */ 
#line 528
  if ((int )*regparse == 94) {
    {
#line 529
    ret = regnode(5);
#line 530
    regparse ++;
    }
  } else {
    {
#line 532
    ret = regnode(4);
    }
  }
#line 533
  if ((int )*regparse == 93) {
    {
#line 534
    tmp___0 = regparse;
#line 534
    regparse ++;
#line 534
    regc((int )*tmp___0);
    }
  } else
#line 533
  if ((int )*regparse == 45) {
    {
#line 534
    tmp___0 = regparse;
#line 534
    regparse ++;
#line 534
    regc((int )*tmp___0);
    }
  }
  {
#line 535
  while (1) {
    while_continue: /* CIL Label */ ;
#line 535
    if ((int )*regparse != 0) {
#line 535
      if (! ((int )*regparse != 93)) {
#line 535
        goto while_break;
      }
    } else {
#line 535
      goto while_break;
    }
#line 536
    if ((int )*regparse == 45) {
#line 537
      regparse ++;
#line 538
      if ((int )*regparse == 93) {
        {
#line 539
        regc('-');
        }
      } else
#line 538
      if ((int )*regparse == 0) {
        {
#line 539
        regc('-');
        }
      } else {
#line 541
        class = (int )*((unsigned char *)(regparse - 2)) + 1;
#line 542
        classend = (int )*((unsigned char *)regparse);
#line 543
        if (class > classend + 1) {
          {
#line 544
          regerror("invalid [] range");
          }
#line 544
          return ((char *)((void *)0));
        }
        {
#line 545
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 545
          if (! (class <= classend)) {
#line 545
            goto while_break___0;
          }
          {
#line 546
          regc(class);
#line 545
          class ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 547
        regparse ++;
      }
    } else {
      {
#line 550
      tmp___1 = regparse;
#line 550
      regparse ++;
#line 550
      regc((int )*tmp___1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 552
  regc('\000');
  }
#line 553
  if ((int )*regparse != 93) {
    {
#line 554
    regerror("unmatched []");
    }
#line 554
    return ((char *)((void *)0));
  }
#line 555
  regparse ++;
#line 556
  *flagp |= 3;
#line 558
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 560
  ret = reg(1, & flags);
  }
#line 561
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 562
    return ((char *)((void *)0));
  }
#line 563
  *flagp |= flags & 5;
#line 564
  goto switch_break;
  case_41: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 568
  regerror("internal urp");
  }
#line 568
  return ((char *)((void *)0));
  case_42: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_63: /* CIL Label */ 
  {
#line 572
  regerror("?+* follows nothing");
  }
#line 572
  return ((char *)((void *)0));
  case_92: /* CIL Label */ 
#line 574
  if ((int )*regparse == 0) {
    {
#line 575
    regerror("trailing \\");
    }
#line 575
    return ((char *)((void *)0));
  }
  {
#line 576
  ret = regnode(8);
#line 577
  tmp___2 = regparse;
#line 577
  regparse ++;
#line 577
  regc((int )*tmp___2);
#line 578
  regc('\000');
#line 579
  *flagp |= 3;
  }
#line 580
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 585
  regparse --;
#line 586
  tmp___3 = strcspn((char const   *)regparse, "^$.[()|?+*\\");
#line 586
  len = (int )tmp___3;
  }
#line 587
  if (len <= 0) {
    {
#line 588
    regerror("internal disaster");
    }
#line 588
    return ((char *)((void *)0));
  }
#line 589
  ender = *(regparse + len);
#line 590
  if (len > 1) {
#line 590
    if ((int )ender == 42) {
#line 591
      len --;
    } else
#line 590
    if ((int )ender == 43) {
#line 591
      len --;
    } else
#line 590
    if ((int )ender == 63) {
#line 591
      len --;
    }
  }
#line 592
  *flagp |= 1;
#line 593
  if (len == 1) {
#line 594
    *flagp |= 2;
  }
  {
#line 595
  ret = regnode(8);
  }
  {
#line 596
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 596
    if (! (len > 0)) {
#line 596
      goto while_break___1;
    }
    {
#line 597
    tmp___4 = regparse;
#line 597
    regparse ++;
#line 597
    regc((int )*tmp___4);
#line 598
    len --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 600
  regc('\000');
  }
#line 602
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 605
  return (ret);
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regnode(char op ) 
{ 
  register char *ret ;
  register char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 618
  ret = regcode;
#line 619
  if ((unsigned long )ret == (unsigned long )(& regdummy)) {
#line 620
    regsize += 3L;
#line 621
    return (ret);
  }
#line 624
  ptr = ret;
#line 625
  tmp = ptr;
#line 625
  ptr ++;
#line 625
  *tmp = op;
#line 626
  tmp___0 = ptr;
#line 626
  ptr ++;
#line 626
  *tmp___0 = (char )'\000';
#line 627
  tmp___1 = ptr;
#line 627
  ptr ++;
#line 627
  *tmp___1 = (char )'\000';
#line 628
  regcode = ptr;
#line 630
  return (ret);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static void regc(char b ) 
{ 
  char *tmp ;

  {
#line 640
  if ((unsigned long )regcode != (unsigned long )(& regdummy)) {
#line 641
    tmp = regcode;
#line 641
    regcode ++;
#line 641
    *tmp = b;
  } else {
#line 643
    regsize ++;
  }
#line 644
  return;
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static void reginsert(char op , char *opnd ) 
{ 
  register char *src ;
  register char *dst ;
  register char *place ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 660
  if ((unsigned long )regcode == (unsigned long )(& regdummy)) {
#line 661
    regsize += 3L;
#line 662
    return;
  }
#line 665
  src = regcode;
#line 666
  regcode += 3;
#line 667
  dst = regcode;
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! ((unsigned long )src > (unsigned long )opnd)) {
#line 668
      goto while_break;
    }
#line 669
    dst --;
#line 669
    src --;
#line 669
    *dst = *src;
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  place = opnd;
#line 672
  tmp = place;
#line 672
  place ++;
#line 672
  *tmp = op;
#line 673
  tmp___0 = place;
#line 673
  place ++;
#line 673
  *tmp___0 = (char )'\000';
#line 674
  tmp___1 = place;
#line 674
  place ++;
#line 674
  *tmp___1 = (char )'\000';
#line 675
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static void regtail(char *p , char *val ) 
{ 
  register char *scan ;
  register char *temp ;
  register int offset ;

  {
#line 689
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 690
    return;
  }
#line 693
  scan = p;
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 695
    temp = regnext(scan);
    }
#line 696
    if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 697
      goto while_break;
    }
#line 698
    scan = temp;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  if ((int )*scan == 7) {
#line 702
    offset = (int )(scan - val);
  } else {
#line 704
    offset = (int )(val - scan);
  }
#line 705
  *(scan + 1) = (char )((offset >> 8) & 255);
#line 706
  *(scan + 2) = (char )(offset & 255);
#line 707
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static void regoptail(char *p , char *val ) 
{ 


  {
#line 718
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 719
    return;
  } else
#line 718
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 719
    return;
  } else
#line 718
  if ((int )*p != 6) {
#line 719
    return;
  }
  {
#line 720
  regtail(p + 3, val);
  }
#line 721
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *reginput  ;
#line 731 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regbol  ;
#line 732 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char **regstartp  ;
#line 733 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char **regendp  ;
#line 738
static int regtry(regexp *prog , char *string ) ;
#line 739
static int regmatch(char *prog ) ;
#line 740
static int regrepeat(char *p ) ;
#line 751 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
int regexec(regexp *prog , char *string ) 
{ 
  register char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 759
  if ((unsigned long )prog == (unsigned long )((void *)0)) {
    {
#line 760
    regerror("NULL parameter");
    }
#line 761
    return (0);
  } else
#line 759
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 760
    regerror("NULL parameter");
    }
#line 761
    return (0);
  }
#line 765
  if ((int )*((unsigned char *)(prog->program)) != 156) {
    {
#line 766
    regerror("corrupted program");
    }
#line 767
    return (0);
  }
#line 771
  if ((unsigned long )prog->regmust != (unsigned long )((void *)0)) {
#line 772
    s = string;
    {
#line 773
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 773
      s = strchr((char const   *)s, (int )*(prog->regmust + 0));
      }
#line 773
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 773
        goto while_break;
      }
      {
#line 774
      tmp = strncmp((char const   *)s, (char const   *)prog->regmust, (size_t )prog->regmlen);
      }
#line 774
      if (tmp == 0) {
#line 775
        goto while_break;
      }
#line 776
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 778
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 779
      return (0);
    }
  }
#line 783
  regbol = string;
#line 786
  if (prog->reganch) {
    {
#line 787
    tmp___0 = regtry(prog, string);
    }
#line 787
    return (tmp___0);
  }
#line 790
  s = string;
#line 791
  if ((int )prog->regstart != 0) {
    {
#line 793
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 793
      s = strchr((char const   *)s, (int )prog->regstart);
      }
#line 793
      if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 793
        goto while_break___0;
      }
      {
#line 794
      tmp___1 = regtry(prog, s);
      }
#line 794
      if (tmp___1) {
#line 795
        return (1);
      }
#line 796
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 800
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 801
      tmp___2 = regtry(prog, s);
      }
#line 801
      if (tmp___2) {
#line 802
        return (1);
      }
#line 800
      tmp___3 = s;
#line 800
      s ++;
#line 800
      if (! ((int )*tmp___3 != 0)) {
#line 800
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 806
  return (0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static int regtry(regexp *prog , char *string ) 
{ 
  register int i ;
  register char **sp ;
  register char **ep ;
  char **tmp ;
  char **tmp___0 ;
  int tmp___1 ;

  {
#line 821
  reginput = string;
#line 822
  regstartp = prog->startp;
#line 823
  regendp = prog->endp;
#line 825
  sp = prog->startp;
#line 826
  ep = prog->endp;
#line 827
  i = 10;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (i > 0)) {
#line 827
      goto while_break;
    }
#line 828
    tmp = sp;
#line 828
    sp ++;
#line 828
    *tmp = (char *)((void *)0);
#line 829
    tmp___0 = ep;
#line 829
    ep ++;
#line 829
    *tmp___0 = (char *)((void *)0);
#line 827
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 831
  tmp___1 = regmatch(prog->program + 1);
  }
#line 831
  if (tmp___1) {
#line 832
    prog->startp[0] = string;
#line 833
    prog->endp[0] = reginput;
#line 834
    return (1);
  } else {
#line 836
    return (0);
  }
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static int regmatch(char *prog ) 
{ 
  register char *scan ;
  char *next ;
  register int len ;
  register char *opnd ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  register int no ;
  register char *save ;
  int tmp___3 ;
  register int no___0 ;
  register char *save___0 ;
  int tmp___4 ;
  register char *save___1 ;
  int tmp___5 ;
  register char nextch ;
  register int no___1 ;
  register char *save___2 ;
  register int mmin ;
  int tmp___6 ;

  {
#line 856
  scan = prog;
  {
#line 861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 861
    if (! ((unsigned long )scan != (unsigned long )((void *)0))) {
#line 861
      goto while_break;
    }
    {
#line 866
    next = regnext(scan);
    }
    {
#line 869
    if ((int )*scan == 1) {
#line 869
      goto case_1;
    }
#line 873
    if ((int )*scan == 2) {
#line 873
      goto case_2;
    }
#line 877
    if ((int )*scan == 3) {
#line 877
      goto case_3;
    }
#line 882
    if ((int )*scan == 8) {
#line 882
      goto case_8;
    }
#line 896
    if ((int )*scan == 4) {
#line 896
      goto case_4;
    }
#line 901
    if ((int )*scan == 5) {
#line 901
      goto case_5;
    }
#line 906
    if ((int )*scan == 9) {
#line 906
      goto case_9;
    }
#line 908
    if ((int )*scan == 7) {
#line 908
      goto case_7;
    }
#line 918
    if ((int )*scan == 29) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 28) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 27) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 26) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 25) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 24) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 23) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 22) {
#line 918
      goto case_29;
    }
#line 918
    if ((int )*scan == 21) {
#line 918
      goto case_29;
    }
#line 946
    if ((int )*scan == 39) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 38) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 37) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 36) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 35) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 34) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 33) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 32) {
#line 946
      goto case_39;
    }
#line 946
    if ((int )*scan == 31) {
#line 946
      goto case_39;
    }
#line 966
    if ((int )*scan == 6) {
#line 966
      goto case_6;
    }
#line 985
    if ((int )*scan == 11) {
#line 985
      goto case_11;
    }
#line 985
    if ((int )*scan == 10) {
#line 985
      goto case_11;
    }
#line 1012
    if ((int )*scan == 0) {
#line 1012
      goto case_0;
    }
#line 1014
    goto switch_default;
    case_1: /* CIL Label */ 
#line 870
    if ((unsigned long )reginput != (unsigned long )regbol) {
#line 871
      return (0);
    }
#line 872
    goto switch_break;
    case_2: /* CIL Label */ 
#line 874
    if ((int )*reginput != 0) {
#line 875
      return (0);
    }
#line 876
    goto switch_break;
    case_3: /* CIL Label */ 
#line 878
    if ((int )*reginput == 0) {
#line 879
      return (0);
    }
#line 880
    reginput ++;
#line 881
    goto switch_break;
    case_8: /* CIL Label */ 
#line 886
    opnd = scan + 3;
#line 888
    if ((int )*opnd != (int )*reginput) {
#line 889
      return (0);
    }
    {
#line 890
    tmp = strlen((char const   *)opnd);
#line 890
    len = (int )tmp;
    }
#line 891
    if (len > 1) {
      {
#line 891
      tmp___0 = strncmp((char const   *)opnd, (char const   *)reginput, (size_t )len);
      }
#line 891
      if (tmp___0 != 0) {
#line 892
        return (0);
      }
    }
#line 893
    reginput += len;
#line 895
    goto switch_break;
    case_4: /* CIL Label */ 
#line 897
    if ((int )*reginput == 0) {
#line 898
      return (0);
    } else {
      {
#line 897
      tmp___1 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 897
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 898
        return (0);
      }
    }
#line 899
    reginput ++;
#line 900
    goto switch_break;
    case_5: /* CIL Label */ 
#line 902
    if ((int )*reginput == 0) {
#line 903
      return (0);
    } else {
      {
#line 902
      tmp___2 = strchr((char const   *)(scan + 3), (int )*reginput);
      }
#line 902
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 903
        return (0);
      }
    }
#line 904
    reginput ++;
#line 905
    goto switch_break;
    case_9: /* CIL Label */ 
#line 907
    goto switch_break;
    case_7: /* CIL Label */ 
#line 909
    goto switch_break;
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    {
#line 922
    no = (int )*scan - 20;
#line 923
    save = reginput;
#line 925
    tmp___3 = regmatch(next);
    }
#line 925
    if (tmp___3) {
#line 931
      if ((unsigned long )*(regstartp + no) == (unsigned long )((void *)0)) {
#line 932
        *(regstartp + no) = save;
      }
#line 933
      return (1);
    } else {
#line 935
      return (0);
    }
#line 937
    goto switch_break;
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_37: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    {
#line 950
    no___0 = (int )*scan - 30;
#line 951
    save___0 = reginput;
#line 953
    tmp___4 = regmatch(next);
    }
#line 953
    if (tmp___4) {
#line 959
      if ((unsigned long )*(regendp + no___0) == (unsigned long )((void *)0)) {
#line 960
        *(regendp + no___0) = save___0;
      }
#line 961
      return (1);
    } else {
#line 963
      return (0);
    }
#line 965
    goto switch_break;
    case_6: /* CIL Label */ 
#line 969
    if ((int )*next != 6) {
#line 970
      next = scan + 3;
    } else {
      {
#line 972
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 973
        save___1 = reginput;
#line 974
        tmp___5 = regmatch(scan + 3);
        }
#line 974
        if (tmp___5) {
#line 975
          return (1);
        }
        {
#line 976
        reginput = save___1;
#line 977
        scan = regnext(scan);
        }
#line 972
        if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 972
          if (! ((int )*scan == 6)) {
#line 972
            goto while_break___0;
          }
        } else {
#line 972
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 979
      return (0);
    }
#line 983
    goto switch_break;
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 995
    nextch = (char )'\000';
#line 996
    if ((int )*next == 8) {
#line 997
      nextch = *(next + 3);
    }
#line 998
    if ((int )*scan == 10) {
#line 998
      mmin = 0;
    } else {
#line 998
      mmin = 1;
    }
    {
#line 999
    save___2 = reginput;
#line 1000
    no___1 = regrepeat(scan + 3);
    }
    {
#line 1001
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1001
      if (! (no___1 >= mmin)) {
#line 1001
        goto while_break___1;
      }
#line 1003
      if ((int )nextch == 0) {
#line 1003
        goto _L;
      } else
#line 1003
      if ((int )*reginput == (int )nextch) {
        _L: /* CIL Label */ 
        {
#line 1004
        tmp___6 = regmatch(next);
        }
#line 1004
        if (tmp___6) {
#line 1005
          return (1);
        }
      }
#line 1007
      no___1 --;
#line 1008
      reginput = save___2 + no___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1010
    return (0);
    case_0: /* CIL Label */ 
#line 1013
    return (1);
    switch_default: /* CIL Label */ 
    {
#line 1015
    regerror("memory corruption");
    }
#line 1016
    return (0);
    switch_break: /* CIL Label */ ;
    }
#line 1019
    scan = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1026
  regerror("corrupted pointers");
  }
#line 1027
  return (0);
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static int regrepeat(char *p ) 
{ 
  register int count ;
  register char *scan ;
  register char *opnd ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 1037
  count = 0;
#line 1041
  scan = reginput;
#line 1042
  opnd = p + 3;
  {
#line 1044
  if ((int )*p == 3) {
#line 1044
    goto case_3;
  }
#line 1048
  if ((int )*p == 8) {
#line 1048
    goto case_8;
  }
#line 1054
  if ((int )*p == 4) {
#line 1054
    goto case_4;
  }
#line 1060
  if ((int )*p == 5) {
#line 1060
    goto case_5;
  }
#line 1066
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 1045
  tmp = strlen((char const   *)scan);
#line 1045
  count = (int )tmp;
#line 1046
  scan += count;
  }
#line 1047
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1049
    if (! ((int )*opnd == (int )*scan)) {
#line 1049
      goto while_break;
    }
#line 1050
    count ++;
#line 1051
    scan ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1053
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1055
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1055
    if ((int )*scan != 0) {
      {
#line 1055
      tmp___0 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1055
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1055
        goto while_break___0;
      }
    } else {
#line 1055
      goto while_break___0;
    }
#line 1056
    count ++;
#line 1057
    scan ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1059
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1061
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1061
    if ((int )*scan != 0) {
      {
#line 1061
      tmp___1 = strchr((char const   *)opnd, (int )*scan);
      }
#line 1061
      if (! ((unsigned long )tmp___1 == (unsigned long )((void *)0))) {
#line 1061
        goto while_break___1;
      }
    } else {
#line 1061
      goto while_break___1;
    }
#line 1062
    count ++;
#line 1063
    scan ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1065
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1067
  regerror("internal foulup");
#line 1068
  count = 0;
  }
#line 1069
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1071
  reginput = scan;
#line 1073
  return (count);
}
}
#line 1079 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/regexp.c"
static char *regnext(char *p ) 
{ 
  register int offset ;

  {
#line 1085
  if ((unsigned long )p == (unsigned long )(& regdummy)) {
#line 1086
    return ((char *)((void *)0));
  }
#line 1088
  offset = (((int )*(p + 1) & 255) << 8) + ((int )*(p + 2) & 255);
#line 1089
  if (offset == 0) {
#line 1090
    return ((char *)((void *)0));
  }
#line 1092
  if ((int )*p == 7) {
#line 1093
    return (p - offset);
  } else {
#line 1095
    return (p + offset);
  }
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/sysdefs.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int total_rules  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int sizeof_rules  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int show_only  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int long_summary  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int verbose  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int lines  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int clear_logs  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int already_been_forwarded  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int log_actions_only  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int logging  =    1;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int printing_rules  =    0;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int rule_choosen  ;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int user_uid  =    -1;
#line 193 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
int user_gid  =    -1;
#line 228 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char home[256]  ;
#line 228 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char hostname[256]  ;
#line 228 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char username[256]  ;
#line 232 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
LIST *tolist  ;
#line 233 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
LIST *mail_lists  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char rcpt_to[512]  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char subject[512]  ;
#line 235 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char alphasubject[512]  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char Efrom[512]  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char Hfrom[512]  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char sender[512]  ;
#line 242 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char replyto[512]  ;
#line 247 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
FILE *outfptr  ;
#line 248 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char outfname[256]  ;
#line 249 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char filterfile[256]  ;
#line 250 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char filterlog[256]  ;
#line 251 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char filtersum[256]  ;
#line 252 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char tmpfilename[256]  ;
#line 253 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char user_mailbox[256]  ;
#line 254 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
nl_catd elm_msg_cat  ;
#line 274 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
struct ruleset_record *rules  ;
#line 294
void save_from(char *buffer___0 ) ;
#line 295
void save_subject(char *buffer___0 ) ;
#line 296
void save_sender(char *buffer___0 ) ;
#line 297
void save_to(char *buffer___0 ) ;
#line 298
void save_mlist(char *buffer___0 ) ;
#line 299
void save_embedded_address(char *buffer___0 , char *fieldname ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/version.h"
static char *versionstring  =    (char *)"filter 2.6.3";
#line 115 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void usage(void) 
{ 


  {
  {
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          versionstring);
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"     http://www.bolthole.com/filter/\n");
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This is a program you can install as an email filter.\n");
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (to sort, delete, or forward incoming email)\n");
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: | filter [-nrvlq] [-f rules] [-o file] [-m mailbox]\n\tor: filter [-c] -[s|S]\n");
#line 125
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"See the manual page for details. (\"man filter\")\n");
  }
#line 126
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
int checksetgid(void) 
{ 
  __gid_t tmp ;
  __gid_t tmp___0 ;

  {
  {
#line 134
  tmp = getegid();
#line 134
  tmp___0 = getgid();
  }
#line 134
  return (tmp != tmp___0);
}
}
#line 187
void leave(char *reason ) ;
#line 341
int get_filter_rules(void) ;
#line 346
void show_summary(void) ;
#line 356
void print_rules(void) ;
#line 363
FILE *make_tempfile(void) ;
#line 430
int mail_message(char *address , FILE *fptr , int resendflag ) ;
#line 432
int action_from_ruleset(void) ;
#line 435
void expand_macros(char *word , char *buffer___0 , int line , int display ) ;
#line 444
void log_msg(int what ) ;
#line 445
void remove_tempfile(void) ;
#line 456
int save_message(char *foldername , FILE *tmpfptr ) ;
#line 490
void execute(char *command , FILE *tmpfptr ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
int main(int argc , char **argv ) 
{ 
  FILE *tmpfptr ;
  struct passwd *passwd_entry ;
  char action_argument[256] ;
  char buffer___0[5120] ;
  char overridemailbox[5120] ;
  int in_header ;
  int in_to ;
  int summary ;
  int c ;
  int amsetgid ;
  int exit_stat ;
  __uid_t tmp ;
  char *tmpstr ;
  char firstletter[2] ;
  int tmplen ;
  size_t tmp___0 ;
  int tmplen___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int action ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;

  {
  {
#line 166
  in_header = 1;
#line 166
  in_to = 0;
#line 166
  summary = 0;
#line 170
  amsetgid = 0;
#line 171
  exit_stat = 0;
#line 173
  amsetgid = checksetgid();
#line 175
  tolist = (LIST *)((void *)0);
#line 178
  setlocale(6, "");
#line 181
  elm_msg_cat = (void *)0;
#line 186
  tmp = getuid();
#line 186
  passwd_entry = getpwuid(tmp);
  }
#line 186
  if ((unsigned long )passwd_entry == (unsigned long )((void *)0)) {
    {
#line 187
    leave("Cannot get password entry for this uid!");
    }
  }
  {
#line 190
  stringcopy(home, passwd_entry->pw_dir, 256);
#line 191
  stringcopy(username, passwd_entry->pw_name, 256);
#line 193
  user_uid = (int )passwd_entry->pw_uid;
#line 194
  user_gid = (int )passwd_entry->pw_gid;
#line 197
  filterfile[0] = (char )'\000';
#line 197
  outfname[0] = filterfile[0];
#line 201
  stringcopy(hostname, "vore", sizeof(hostname));
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 208
    c = getopt(argc, (char * const  *)argv, "chlm:no:qrSsvf:");
    }
#line 208
    if (! (c != -1)) {
#line 208
      goto while_break;
    }
    {
#line 211
    if (c == 99) {
#line 211
      goto case_99;
    }
#line 214
    if (c == 102) {
#line 214
      goto case_102;
    }
#line 217
    if (c == 104) {
#line 217
      goto case_104;
    }
#line 224
    if (c == 108) {
#line 224
      goto case_108;
    }
#line 227
    if (c == 109) {
#line 227
      goto case_109;
    }
#line 233
    if (c == 110) {
#line 233
      goto case_110;
    }
#line 236
    if (c == 111) {
#line 236
      goto case_111;
    }
#line 239
    if (c == 113) {
#line 239
      goto case_113;
    }
#line 242
    if (c == 114) {
#line 242
      goto case_114;
    }
#line 245
    if (c == 115) {
#line 245
      goto case_115;
    }
#line 248
    if (c == 83) {
#line 248
      goto case_83;
    }
#line 251
    if (c == 118) {
#line 251
      goto case_118;
    }
#line 255
    goto switch_default;
    case_99: /* CIL Label */ 
#line 212
    clear_logs = 1;
#line 213
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 215
    stringcopy(filterfile, optarg, 256);
    }
#line 216
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 218
    usage();
#line 219
    exit(1);
    }
#line 222
    goto switch_break;
    case_108: /* CIL Label */ 
#line 225
    log_actions_only = 1;
#line 226
    goto switch_break;
    case_109: /* CIL Label */ 
#line 228
    if (amsetgid) {
#line 229
      goto switch_break;
    }
    {
#line 231
    stringcopy(overridemailbox, optarg, 256);
    }
#line 232
    goto switch_break;
    case_110: /* CIL Label */ 
#line 234
    show_only = 1;
#line 235
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 237
    stringcopy(outfname, optarg, 256);
    }
#line 238
    goto switch_break;
    case_113: /* CIL Label */ 
#line 240
    logging = 0;
#line 241
    goto switch_break;
    case_114: /* CIL Label */ 
#line 243
    printing_rules = 1;
#line 244
    goto switch_break;
    case_115: /* CIL Label */ 
#line 246
    summary = 1;
#line 247
    goto switch_break;
    case_83: /* CIL Label */ 
#line 249
    long_summary = 1;
#line 250
    goto switch_break;
    case_118: /* CIL Label */ 
#line 252
    verbose = 1;
#line 253
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 256
    usage();
#line 257
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  tmpstr = (char *)((void *)0);
#line 264
  sprintf((char */* __restrict  */)(user_mailbox), (char const   */* __restrict  */)"%s",
          "/var/spool/mail/%u");
  }
#line 265
  if (amsetgid == 0) {
    {
#line 266
    tmpstr = getenv("MAIL");
    }
  }
#line 267
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
    {
#line 268
    strcpy((char */* __restrict  */)(user_mailbox), (char const   */* __restrict  */)tmpstr);
    }
  }
#line 270
  if ((int )overridemailbox[0] != 0) {
    {
#line 271
    strcpy((char */* __restrict  */)(user_mailbox), (char const   */* __restrict  */)(overridemailbox));
    }
  }
  {
#line 279
  tmpstr = strchr((char const   *)(user_mailbox), '%');
  }
#line 280
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
#line 281
    if ((int )*(tmpstr + 1) != 102) {
#line 282
      tmpstr = (char *)((void *)0);
    }
  }
#line 285
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
    {
#line 287
    tmplen = (int )(tmpstr - user_mailbox);
#line 288
    firstletter[1] = (char )'\000';
#line 289
    firstletter[0] = username[0];
#line 290
    stringcopy(buffer___0, user_mailbox, tmplen + 1);
#line 292
    strcat((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(firstletter));
#line 293
    strcat((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(tmpstr + 2));
#line 294
    tmp___0 = strlen((char const   *)(buffer___0));
#line 294
    stringcopy(user_mailbox, buffer___0, tmp___0 + 1UL);
    }
  }
  {
#line 301
  tmpstr = strrchr((char const   *)(user_mailbox), '%');
  }
#line 302
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
#line 303
    if ((int )*(tmpstr + 1) != 117) {
#line 304
      tmpstr = (char *)((void *)0);
    }
  }
#line 307
  if ((unsigned long )tmpstr != (unsigned long )((void *)0)) {
    {
#line 308
    tmplen___0 = (int )(tmpstr - user_mailbox);
#line 309
    stringcopy(buffer___0, user_mailbox, tmplen___0 + 1);
#line 310
    strcat((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(username));
#line 311
    strcat((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(tmpstr + 2));
#line 312
    tmp___1 = strlen((char const   *)(buffer___0));
#line 312
    stringcopy(user_mailbox, buffer___0, tmp___1 + 1UL);
    }
  }
  {
#line 317
  sprintf((char */* __restrict  */)(filterlog), (char const   */* __restrict  */)"%s/.filter/%s",
          home, "filterlog");
#line 318
  sprintf((char */* __restrict  */)(filtersum), (char const   */* __restrict  */)"%s/.filter/%s",
          home, "filtersum");
  }
#line 321
  if (! filterfile[0]) {
    {
#line 322
    sprintf((char */* __restrict  */)(filterfile), (char const   */* __restrict  */)"%s/.filter/%s",
            home, "filter-rules");
    }
  }
#line 328
  if ((int )outfname[0] == 0) {
#line 329
    outfptr = stdout;
  } else {
    {
#line 331
    outfptr = fopen((char const   */* __restrict  */)(outfname), (char const   */* __restrict  */)"a");
    }
#line 331
    if ((unsigned long )outfptr == (unsigned long )((void *)0)) {
      {
#line 332
      tmp___2 = fileno(stderr);
#line 332
      tmp___3 = isatty(tmp___2);
      }
#line 332
      if (tmp___3) {
        {
#line 333
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filter (%s): couldn\'t open output file %s\n",
                username, outfname);
        }
      }
    }
  }
#line 340
  if (summary) {
#line 340
    goto _L;
  } else
#line 340
  if (long_summary) {
    _L: /* CIL Label */ 
    {
#line 341
    tmp___4 = get_filter_rules();
    }
#line 341
    if (tmp___4 == -1) {
#line 342
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 342
        fclose(outfptr);
        }
      }
      {
#line 343
      exit(1);
      }
    }
    {
#line 345
    printing_rules = 1;
#line 346
    show_summary();
    }
#line 347
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 347
      fclose(outfptr);
      }
    }
    {
#line 348
    exit(0);
    }
  }
#line 351
  if (printing_rules) {
    {
#line 352
    tmp___6 = get_filter_rules();
    }
#line 352
    if (tmp___6 == -1) {
      {
#line 353
      tmp___5 = date_n_user();
#line 353
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t get rules!\n",
              tmp___5);
      }
    } else {
      {
#line 356
      print_rules();
      }
    }
#line 357
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 357
      fclose(outfptr);
      }
    }
    {
#line 358
    exit(0);
    }
  }
  {
#line 363
  tmp___7 = (int )make_tempfile();
#line 363
  tmpfptr = (FILE *)tmp___7;
  }
#line 363
  if ((unsigned long )tmpfptr == (unsigned long )((void *)0)) {
    {
#line 365
    sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"Cannot open temporary file");
#line 369
    leave(buffer___0);
    }
  }
  {
#line 373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 373
    tmp___31 = fgets((char */* __restrict  */)(buffer___0), 5120, (FILE */* __restrict  */)stdin);
    }
#line 373
    if (! ((unsigned long )tmp___31 != (unsigned long )((void *)0))) {
#line 373
      goto while_break___0;
    }
    {
#line 375
    tmp___9 = strlen((char const   *)(buffer___0));
    }
#line 375
    if ((int )buffer___0[tmp___9 - 1UL] == 10) {
      {
#line 375
      tmp___8 = strlen((char const   *)(buffer___0));
#line 375
      buffer___0[tmp___8 - 1UL] = (char )'\000';
      }
    }
#line 377
    if (in_header) {
#line 379
      if (! ((int )buffer___0[0] == 32)) {
#line 379
        if (! ((int )buffer___0[0] == 9)) {
#line 380
          in_to = 0;
        }
      }
      {
#line 384
      tmp___29 = strlen("From ");
#line 384
      tmp___30 = strncmp((char const   *)(buffer___0), "From ", tmp___29);
      }
#line 384
      if (tmp___30 == 0) {
        {
#line 385
        save_from(buffer___0);
        }
      } else {
        {
#line 390
        tmp___27 = strlen("Subject:");
#line 390
        tmp___28 = strncasecmp((char const   *)(buffer___0), "Subject:", tmp___27);
        }
#line 390
        if (tmp___28 == 0) {
          {
#line 391
          save_subject(buffer___0);
          }
        } else {
          {
#line 392
          tmp___25 = strlen("Sender:");
#line 392
          tmp___26 = strncasecmp((char const   *)(buffer___0), "Sender:", tmp___25);
          }
#line 392
          if (tmp___26 == 0) {
            {
#line 393
            save_sender(buffer___0);
            }
          } else {
            {
#line 394
            tmp___23 = strlen("x-mailing-list:");
#line 394
            tmp___24 = strncasecmp((char const   *)(buffer___0), "x-mailing-list:",
                                   tmp___23);
            }
#line 394
            if (tmp___24 == 0) {
              {
#line 395
              save_mlist(buffer___0);
              }
            } else {
              {
#line 396
              tmp___17 = strlen("To:");
#line 396
              tmp___18 = strncasecmp((char const   *)(buffer___0), "To:", tmp___17);
              }
#line 396
              if (tmp___18 == 0) {
                {
#line 399
                in_to ++;
#line 400
                save_to(buffer___0);
                }
              } else {
                {
#line 396
                tmp___19 = strlen("Cc:");
#line 396
                tmp___20 = strncasecmp((char const   *)(buffer___0), "Cc:", tmp___19);
                }
#line 396
                if (tmp___20 == 0) {
                  {
#line 399
                  in_to ++;
#line 400
                  save_to(buffer___0);
                  }
                } else {
                  {
#line 396
                  tmp___21 = strlen("Apparently-To:");
#line 396
                  tmp___22 = strncasecmp((char const   *)(buffer___0), "Apparently-To:",
                                         tmp___21);
                  }
#line 396
                  if (tmp___22 == 0) {
                    {
#line 399
                    in_to ++;
#line 400
                    save_to(buffer___0);
                    }
                  } else {
                    {
#line 402
                    tmp___15 = strlen("X-Filtered-By:");
#line 402
                    tmp___16 = strncmp((char const   *)(buffer___0), "X-Filtered-By:",
                                       tmp___15);
                    }
#line 402
                    if (tmp___16 == 0) {
#line 403
                      already_been_forwarded ++;
                    } else {
                      {
#line 405
                      tmp___13 = strlen("From:");
#line 405
                      tmp___14 = strncasecmp((char const   *)(buffer___0), "From:",
                                             tmp___13);
                      }
#line 405
                      if (tmp___14 == 0) {
                        {
#line 406
                        save_embedded_address(buffer___0, (char *)"From:");
                        }
                      } else {
                        {
#line 407
                        tmp___11 = strlen("Reply-To:");
#line 407
                        tmp___12 = strncasecmp((char const   *)(buffer___0), "Reply-To:",
                                               tmp___11);
                        }
#line 407
                        if (tmp___12 == 0) {
                          {
#line 408
                          save_embedded_address(buffer___0, (char *)"Reply-To:");
                          }
                        } else {
                          {
#line 410
                          tmp___10 = strlen((char const   *)(buffer___0));
                          }
#line 410
                          if (tmp___10 < 2UL) {
#line 411
                            in_header = 0;
                          } else
#line 413
                          if ((int )buffer___0[0] == 32) {
#line 413
                            goto _L___0;
                          } else
#line 413
                          if ((int )buffer___0[0] == 9) {
                            _L___0: /* CIL Label */ 
#line 413
                            if (in_to) {
                              {
#line 415
                              save_to(buffer___0);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 418
    fprintf((FILE */* __restrict  */)tmpfptr, (char const   */* __restrict  */)"%s\n",
            buffer___0);
#line 419
    lines ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 422
  fflush(tmpfptr);
#line 424
  rewind(tmpfptr);
#line 429
  tmp___34 = get_filter_rules();
  }
#line 429
  if (tmp___34 == -1) {
    {
#line 430
    mail_message(username, tmpfptr);
    }
  } else {
    {
#line 432
    tmp___32 = action_from_ruleset();
#line 432
    action = tmp___32;
    }
#line 434
    if (rule_choosen >= 0) {
      {
#line 435
      expand_macros((rules + rule_choosen)->argument2, action_argument, (rules + rule_choosen)->line,
                    printing_rules);
#line 438
      stringcopy((rules + rule_choosen)->argument2, action_argument, 256);
      }
    }
    {
#line 444
    if (action == 16) {
#line 444
      goto case_16;
    }
#line 448
    if (action == 17) {
#line 448
      goto case_17;
    }
#line 456
    if (action == 18) {
#line 456
      goto case_18;
    }
#line 468
    if (action == 19) {
#line 468
      goto case_19;
    }
#line 477
    if (action == 13) {
#line 477
      goto case_13;
    }
#line 481
    if (action == 10) {
#line 481
      goto case_10;
    }
#line 485
    if (action == 21) {
#line 485
      goto case_21;
    }
#line 489
    if (action == 15) {
#line 489
      goto case_15;
    }
#line 494
    if (action == 12) {
#line 494
      goto case_12;
    }
#line 498
    if (action == 11) {
#line 498
      goto case_11;
    }
#line 442
    goto switch_break___0;
    case_16: /* CIL Label */ 
    {
#line 444
    log_msg(16);
#line 445
    remove_tempfile();
#line 446
    exit(67);
    }
    case_17: /* CIL Label */ 
#line 448
    if (verbose) {
#line 448
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 449
        tmp___33 = date_n_user();
#line 449
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Message deleted\n",
                tmp___33);
        }
      }
    }
    {
#line 454
    log_msg(17);
    }
#line 454
    goto switch_break___0;
    case_18: /* CIL Label */ 
    {
#line 456
    exit_stat = save_message((rules + rule_choosen)->argument2, tmpfptr);
    }
#line 458
    if (exit_stat != 0) {
      {
#line 461
      mail_message(username, tmpfptr);
#line 462
      log_msg(30);
      }
    } else {
      {
#line 465
      log_msg(18);
      }
    }
#line 466
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 468
    exit_stat = save_message((rules + rule_choosen)->argument2, tmpfptr);
    }
#line 470
    if (exit_stat != 0) {
      {
#line 471
      log_msg(30);
      }
    } else {
      {
#line 473
      log_msg(19);
      }
    }
    {
#line 474
    mail_message(username, tmpfptr);
    }
#line 475
    goto switch_break___0;
    case_13: /* CIL Label */ 
    {
#line 477
    mail_message(username, tmpfptr);
#line 478
    mail_message((rules + rule_choosen)->argument2, tmpfptr);
#line 479
    log_msg(13);
    }
#line 480
    goto switch_break___0;
    case_10: /* CIL Label */ 
    {
#line 481
    mail_message((rules + rule_choosen)->argument2, tmpfptr);
#line 482
    log_msg(10);
    }
#line 483
    goto switch_break___0;
    case_21: /* CIL Label */ 
    {
#line 485
    mail_message((rules + rule_choosen)->argument2, tmpfptr, 1);
#line 486
    log_msg(21);
    }
#line 487
    goto switch_break___0;
    case_15: /* CIL Label */ 
    {
#line 489
    mail_message(username, tmpfptr);
#line 490
    execute((rules + rule_choosen)->argument2, tmpfptr);
#line 491
    log_msg(15);
    }
#line 492
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 494
    execute((rules + rule_choosen)->argument2, tmpfptr);
#line 495
    log_msg(12);
    }
#line 496
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 498
    mail_message(username, tmpfptr);
#line 499
    log_msg(11);
    }
#line 500
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 504
  fclose(tmpfptr);
#line 505
  remove_tempfile();
  }
#line 506
  if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
    {
#line 507
    fclose(outfptr);
    }
  }
  {
#line 508
  exit(exit_stat);
  }
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_from(char *buffer___0 ) 
{ 
  register char *f ;

  {
#line 517
  f = Efrom;
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 519
    if ((int )*buffer___0 == 32) {
#line 519
      goto while_break;
    } else
#line 519
    if ((int )*buffer___0 == 9) {
#line 519
      goto while_break;
    }
#line 520
    buffer___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 522
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 522
    if (! ((int )*buffer___0 == 32)) {
#line 522
      if (! ((int )*buffer___0 == 9)) {
#line 522
        goto while_break___0;
      }
    }
#line 523
    buffer___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 525
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 525
    if ((int )*buffer___0 == 32) {
#line 525
      goto while_break___1;
    } else
#line 525
    if ((int )*buffer___0 == 9) {
#line 525
      goto while_break___1;
    } else
#line 525
    if (! *buffer___0) {
#line 525
      goto while_break___1;
    }
#line 526
    *f = *buffer___0;
#line 525
    buffer___0 ++;
#line 525
    f ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 528
  *f = (char )'\000';
#line 529
  return;
}
}
#line 540
void iso_convert_sub(char *subject___0 ) ;
#line 540 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
static char *base  =    (char *)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
#line 538 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void iso_convert_sub(char *subject___0 ) 
{ 
  unsigned char b1 ;
  unsigned char b2 ;
  unsigned char b3 ;
  unsigned char b4 ;
  char *ptr ;
  char *src ;
  char *dest ;
  char *end ;
  char *start ;
  char *tmp ;
  char tmpsubj[512] ;
  int chunklen ;
  int enc_type ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 545
  tmp = strstr((char const   *)subject___0, "=?");
#line 545
  start = tmp;
#line 547
  chunklen = 0;
#line 548
  enc_type = 0;
  }
#line 557
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 557
    return;
  }
  {
#line 558
  ptr = strchr((char const   *)(start + 2), '?');
  }
  {
#line 562
  if ((int )*(ptr + 1) == 113) {
#line 562
    goto case_113;
  }
#line 562
  if ((int )*(ptr + 1) == 81) {
#line 562
    goto case_113;
  }
#line 567
  if ((int )*(ptr + 1) == 98) {
#line 567
    goto case_98;
  }
#line 567
  if ((int )*(ptr + 1) == 66) {
#line 567
    goto case_98;
  }
#line 571
  goto switch_default;
  case_113: /* CIL Label */ 
  case_81: /* CIL Label */ 
#line 563
  enc_type = 1;
#line 564
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 568
  enc_type = 2;
#line 569
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 572
  return;
  switch_break: /* CIL Label */ ;
  }
#line 575
  ptr += 2;
#line 576
  if ((int )*ptr != 63) {
    {
#line 577
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: fractured encoded subj found in iso_convert_sub\n");
    }
#line 579
    return;
  }
  {
#line 581
  tmp___0 = strchr((char const   *)(ptr + 1), '?');
  }
#line 581
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: truncated encoded subj found in iso_convert_sub\n");
    }
#line 584
    return;
  }
#line 586
  ptr ++;
#line 589
  if (enc_type == 1) {
#line 590
    src = ptr;
#line 591
    dest = tmpsubj;
    {
#line 593
    while (1) {
      while_continue: /* CIL Label */ ;
#line 593
      if (! ((int )*src != 63)) {
#line 593
        goto while_break;
      }
#line 594
      if ((int )*src == 61) {
#line 595
        src ++;
        {
#line 597
        if ((int )*src == 69) {
#line 597
          goto case_69;
        }
#line 600
        if ((int )*src == 70) {
#line 600
          goto case_70;
        }
#line 603
        goto switch_default___0;
        case_69: /* CIL Label */ 
#line 598
        *dest = (char )'e';
#line 599
        goto switch_break___0;
        case_70: /* CIL Label */ 
#line 601
        *dest = (char )'n';
#line 602
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 604
        *dest = (char )'X';
        switch_break___0: /* CIL Label */ ;
        }
      } else {
#line 607
        *dest = *src;
      }
#line 610
      dest ++;
#line 610
      src ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 612
    *dest = (char )'\000';
#line 613
    stringcopy(subject___0, tmpsubj, (dest + 1) - tmpsubj);
    }
#line 614
    return;
  }
  {
#line 619
  end = strstr((char const   *)ptr, "?=");
#line 620
  dest = tmpsubj;
  }
#line 622
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    {
#line 623
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DEBUG: truncated encoded subj found in iso_convert_sub\n");
    }
#line 625
    return;
  }
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if (! ((unsigned long )ptr < (unsigned long )end)) {
#line 627
      goto while_break___0;
    }
    {
#line 628
    tmp___1 = strchr((char const   *)base, (int )*(ptr + 0));
#line 628
    b1 = (unsigned char )(tmp___1 - base);
#line 629
    tmp___2 = strchr((char const   *)base, (int )*(ptr + 1));
#line 629
    b2 = (unsigned char )(tmp___2 - base);
#line 630
    tmp___3 = strchr((char const   *)base, (int )*(ptr + 2));
#line 630
    b3 = (unsigned char )(tmp___3 - base);
#line 631
    tmp___4 = strchr((char const   *)base, (int )*(ptr + 3));
#line 631
    b4 = (unsigned char )(tmp___4 - base);
#line 632
    ptr += 4;
#line 633
    *(dest + 0) = (char )(((int )b1 << 2) | (((int )b2 >> 4) & 255));
#line 634
    *(dest + 1) = (char )(((int )b2 << 4) | (((int )b3 >> 2) & 255));
#line 635
    *(dest + 2) = (char )((((int )b3 << 6) & 255) | ((int )b4 & 255));
#line 636
    dest += 3;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 638
  end += 2;
#line 639
  tmp___5 = strlen((char const   *)end);
#line 639
  stringcopy(dest, end, tmp___5 + 1UL);
#line 640
  tmp___6 = strlen((char const   *)(tmpsubj));
#line 640
  stringcopy(start, tmpsubj, tmp___6 + 1UL);
  }
#line 642
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_subject(char *buffer___0 ) 
{ 
  register int skip ;
  register int frompos ;
  register int topos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 651
  skip = 8;
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (! ((int )*(buffer___0 + skip) == 32)) {
#line 654
      if (! ((int )*(buffer___0 + skip) == 9)) {
#line 654
        goto while_break;
      }
    }
#line 655
    skip ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  stringcopy(subject, buffer___0 + skip, 512);
#line 658
  tmp = strncmp((char const   *)(subject), "=?", (size_t )2);
  }
#line 658
  if (tmp == 0) {
    {
#line 659
    iso_convert_sub(subject);
    }
  }
#line 667
  topos = 0;
#line 668
  frompos = 0;
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 668
    if (! ((int )subject[frompos] != 0)) {
#line 668
      goto while_break___0;
    }
    {
#line 669
    tmp___2 = __ctype_b_loc();
    }
#line 669
    if ((int const   )*(*tmp___2 + (int )subject[frompos]) & 1024) {
      {
#line 670
      tmp___0 = topos;
#line 670
      topos ++;
#line 670
      tmp___1 = tolower((int )subject[frompos]);
#line 670
      alphasubject[tmp___0] = (char )tmp___1;
      }
    }
#line 668
    frompos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 673
  alphasubject[topos] = (char )'\000';
#line 675
  return;
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_sender(char *buffer___0 ) 
{ 
  register int skip ;

  {
#line 682
  skip = 7;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! ((int )*(buffer___0 + skip) == 32)) {
#line 684
      if (! ((int )*(buffer___0 + skip) == 9)) {
#line 684
        goto while_break;
      }
    }
#line 685
    skip ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 687
  stringcopy(sender, buffer___0 + skip, 512);
  }
#line 688
  return;
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_to(char *buffer___0 ) 
{ 
  register int skip ;
  register int to_len ;
  char *newstr ;
  char *strstart ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  LIST *listend ;
  int tmp___2 ;

  {
#line 696
  skip = 0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if ((int )*(buffer___0 + skip) == 32) {
#line 699
      goto while_break;
    } else
#line 699
    if ((int )*(buffer___0 + skip) == 9) {
#line 699
      goto while_break;
    }
#line 700
    skip ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 702
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 702
    if (! ((int )*(buffer___0 + skip) == 32)) {
#line 702
      if (! ((int )*(buffer___0 + skip) == 9)) {
#line 702
        goto while_break___0;
      }
    }
#line 703
    skip ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 705
  strstart = buffer___0 + skip;
#line 707
  tmp = strlen((char const   *)strstart);
#line 707
  to_len = (int )(tmp + 1UL);
#line 708
  tmp___0 = (int )safemalloc(to_len);
#line 708
  newstr = (char *)tmp___0;
#line 709
  stringcopy(newstr, strstart, to_len);
  }
#line 711
  if ((unsigned long )tolist == (unsigned long )((void *)0)) {
    {
#line 712
    tmp___1 = (int )safemalloc(sizeof(LIST ));
#line 712
    tolist = (LIST *)tmp___1;
#line 713
    tolist->next = (struct LIST *)((void *)0);
#line 714
    tolist->str = newstr;
    }
  } else {
#line 717
    listend = tolist;
    {
#line 718
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 718
      if (! ((unsigned long )listend->next != (unsigned long )((void *)0))) {
#line 718
        goto while_break___1;
      }
#line 719
      listend = listend->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 720
    tmp___2 = (int )safemalloc(sizeof(LIST ));
#line 720
    listend->next = (LIST *)tmp___2;
#line 721
    listend = listend->next;
#line 722
    listend->next = (struct LIST *)((void *)0);
#line 723
    listend->str = newstr;
    }
  }
#line 726
  return;
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_mlist(char *buffer___0 ) 
{ 
  register int field_len ;
  char *newstr ;
  char *strstart ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  LIST *listend ;
  int tmp___2 ;

  {
  {
#line 741
  strstart = strchr((char const   *)buffer___0, ':');
  }
#line 744
  if ((unsigned long )strstart == (unsigned long )((void *)0)) {
#line 745
    strstart = buffer___0;
  }
  {
#line 748
  tmp = strlen((char const   *)strstart);
#line 748
  field_len = (int )(tmp + 1UL);
#line 749
  tmp___0 = (int )safemalloc(field_len);
#line 749
  newstr = (char *)tmp___0;
#line 750
  stringcopy(newstr, strstart, field_len);
  }
#line 752
  if ((unsigned long )mail_lists == (unsigned long )((void *)0)) {
    {
#line 753
    tmp___1 = (int )safemalloc(sizeof(LIST ));
#line 753
    mail_lists = (LIST *)tmp___1;
#line 754
    mail_lists->next = (struct LIST *)((void *)0);
#line 755
    mail_lists->str = newstr;
    }
  } else {
#line 758
    listend = mail_lists;
    {
#line 759
    while (1) {
      while_continue: /* CIL Label */ ;
#line 759
      if (! ((unsigned long )listend->next != (unsigned long )((void *)0))) {
#line 759
        goto while_break;
      }
#line 760
      listend = listend->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 761
    tmp___2 = (int )safemalloc(sizeof(LIST ));
#line 761
    listend->next = (LIST *)tmp___2;
#line 762
    listend = listend->next;
#line 763
    listend->next = (struct LIST *)((void *)0);
#line 764
    listend->str = newstr;
    }
  }
#line 767
  return;
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
static int processed_a_reply_to  =    0;
#line 813
int istrcmp(char *s1 , char *s2 ) ;
#line 771 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.c"
void save_embedded_address(char *buffer___0 , char *fieldname ) 
{ 
  char address[512] ;
  register int i ;
  register int j ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  {
#line 785
  j = 0;
#line 790
  tmp___5 = strlen((char const   *)buffer___0);
  }
#line 790
  if ((int )*(buffer___0 + (tmp___5 - 1UL)) == 62) {
    {
#line 791
    tmp = strlen((char const   *)buffer___0);
#line 791
    i = (int )(tmp - 1UL);
    }
    {
#line 791
    while (1) {
      while_continue: /* CIL Label */ ;
#line 791
      if ((int )*(buffer___0 + i) != 60) {
#line 791
        if (! (i > 0)) {
#line 791
          goto while_break;
        }
      } else {
#line 791
        goto while_break;
      }
#line 791
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 793
    i ++;
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if ((int )*(buffer___0 + i) != 62) {
#line 794
        if (! (j < 511)) {
#line 794
          goto while_break___0;
        }
      } else {
#line 794
        goto while_break___0;
      }
#line 795
      tmp___0 = j;
#line 795
      j ++;
#line 795
      tmp___1 = i;
#line 795
      i ++;
#line 795
      address[tmp___0] = *(buffer___0 + tmp___1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 797
    address[j] = (char )'\000';
  } else {
    {
#line 800
    tmp___2 = strlen((char const   *)fieldname);
#line 800
    i = (int )tmp___2;
    }
    {
#line 800
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 800
      if (! ((int )*(buffer___0 + i) == 32)) {
#line 800
        if (! ((int )*(buffer___0 + i) == 9)) {
#line 800
          goto while_break___1;
        }
      }
#line 800
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 802
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 802
      if ((int )*(buffer___0 + i) != 40) {
#line 802
        if ((int )*(buffer___0 + i) == 32) {
#line 802
          goto while_break___2;
        } else
#line 802
        if ((int )*(buffer___0 + i) == 9) {
#line 802
          goto while_break___2;
        } else
#line 802
        if ((int )*(buffer___0 + i) != 0) {
#line 802
          if (! (j < 511)) {
#line 802
            goto while_break___2;
          }
        } else {
#line 802
          goto while_break___2;
        }
      } else {
#line 802
        goto while_break___2;
      }
#line 804
      tmp___3 = j;
#line 804
      j ++;
#line 804
      tmp___4 = i;
#line 804
      i ++;
#line 804
      address[tmp___3] = *(buffer___0 + tmp___4);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 805
    address[j] = (char )'\000';
  }
  {
#line 813
  tmp___6 = istrcmp(fieldname, "Reply-To:");
  }
#line 813
  if (tmp___6 == 0) {
#line 814
    if (processed_a_reply_to) {
#line 815
      return;
    }
    {
#line 816
    processed_a_reply_to ++;
#line 817
    stringcopy(replyto, address, 512);
    }
  } else {
    {
#line 820
    stringcopy(Hfrom, address, 512);
    }
  }
#line 822
  return;
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 278 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/filter.h"
char *itoa(int i , int two_digit ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
char *datestring(void) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void leave(char *reason ) 
{ 
  char *tmp ;

  {
#line 67
  if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
    {
#line 69
    tmp = date_n_user();
#line 69
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): LEAVE %s\n",
            tmp, reason);
#line 71
    fclose(outfptr);
    }
  }
  {
#line 74
  exit(1);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void printlist(FILE *fptr , LIST *listing ) 
{ 


  {
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((unsigned long )listing != (unsigned long )((void *)0))) {
#line 87
      goto while_break;
    }
    {
#line 89
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"%s ",
            listing->str);
#line 90
    listing = listing->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void log_msg(int what ) 
{ 
  FILE *fptr ;
  int subj_len ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
#line 102
  if (! logging) {
#line 103
    return;
  }
#line 105
  if (! show_only) {
    {
#line 106
    fptr = fopen((char const   */* __restrict  */)(filtersum), (char const   */* __restrict  */)"a");
    }
#line 106
    if ((unsigned long )fptr == (unsigned long )((void *)0)) {
#line 107
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 108
        tmp = date_n_user();
#line 108
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t open log file %s\n",
                tmp, filtersum);
        }
      }
#line 112
      fptr = stdout;
    }
    {
#line 114
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"%d\n",
            rule_choosen);
#line 115
    fclose(fptr);
    }
  }
#line 118
  if (show_only) {
#line 119
    fptr = stdout;
  } else {
    {
#line 120
    fptr = fopen((char const   */* __restrict  */)(filterlog), (char const   */* __restrict  */)"a");
    }
#line 120
    if ((unsigned long )fptr == (unsigned long )((void *)0)) {
#line 121
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 122
        tmp___0 = date_n_user();
#line 122
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t open log file %s\n",
                tmp___0, filterlog);
        }
      }
#line 126
      fptr = stdout;
    }
  }
  {
#line 130
  setvbuf((FILE */* __restrict  */)fptr, (char */* __restrict  */)((void *)0), 0,
          (size_t )8192);
#line 133
  tmp___1 = strlen((char const   *)(subject));
#line 133
  subj_len = (int )tmp___1;
#line 134
  tmp___2 = datestring();
#line 134
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\n%s: Mail from ",
          tmp___2);
#line 137
  tmp___3 = strlen((char const   *)(Hfrom));
  }
#line 137
  if (tmp___3 + (size_t )subj_len > 60UL) {
    {
#line 138
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"%s\n\t",
            Hfrom);
    }
  } else {
    {
#line 140
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"%s ",
            Hfrom);
    }
  }
#line 142
  if (subj_len > 0) {
    {
#line 143
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"about %s",
            subject);
    }
  }
  {
#line 145
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\n");
  }
#line 147
  if (rule_choosen != -1) {
#line 148
    if (((rules + rule_choosen)->condition)->matchwhat == 1) {
      {
#line 149
      fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\t(addressed to ");
      }
    }
  }
  {
#line 151
  printlist(fptr, tolist);
#line 152
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\n");
  }
  {
#line 155
  if (what == 17) {
#line 155
    goto case_17;
  }
#line 159
  if (what == 30) {
#line 159
    goto case_30;
  }
#line 164
  if (what == 18) {
#line 164
    goto case_18;
  }
#line 169
  if (what == 19) {
#line 169
    goto case_19;
  }
#line 174
  if (what == 10) {
#line 174
    goto case_10;
  }
#line 179
  if (what == 13) {
#line 179
    goto case_13;
  }
#line 185
  if (what == 21) {
#line 185
    goto case_21;
  }
#line 190
  if (what == 16) {
#line 190
    goto case_16;
  }
#line 195
  if (what == 12) {
#line 195
    goto case_12;
  }
#line 200
  if (what == 15) {
#line 200
    goto case_15;
  }
#line 205
  if (what == 11) {
#line 205
    goto case_11;
  }
#line 154
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 155
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tDELETED");
  }
#line 158
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 159
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tSAVE FAILED for file \"%s\"",
          (rules + rule_choosen)->argument2);
  }
#line 163
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 164
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tSAVED in file \"%s\"",
          (rules + rule_choosen)->argument2);
  }
#line 168
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 169
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tSAVED in file \"%s\" AND PUT in mailbox",
          (rules + rule_choosen)->argument2);
  }
#line 173
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 174
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tFORWARDED to \"%s\"",
          (rules + rule_choosen)->argument2);
  }
#line 178
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 179
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tFORWARDED to \"%s\" AND PUT in mailbox",
          (rules + rule_choosen)->argument2);
  }
#line 184
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 185
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tRESENT to \"%s\"",
          (rules + rule_choosen)->argument2);
  }
#line 189
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 190
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tBOUNCED");
  }
#line 193
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 195
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tEXECUTED \"%s\"",
          (rules + rule_choosen)->argument2);
  }
#line 199
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 200
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tEXECUTED \"%s\" AND PUT in mailbox",
          (rules + rule_choosen)->argument2);
  }
#line 204
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 205
  fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)"\tPUT in mailbox");
  }
#line 208
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 211
  if (rule_choosen != -1) {
    {
#line 212
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)" by rule #%d\n",
            rule_choosen + 1);
    }
  } else {
    {
#line 215
    fprintf((FILE */* __restrict  */)fptr, (char const   */* __restrict  */)": the default action\n");
    }
  }
  {
#line 218
  fflush(fptr);
#line 219
  fclose(fptr);
  }
#line 220
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
char *safemalloc(int bsize ) 
{ 
  char *retstr ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 225
  tmp = malloc((size_t )bsize);
#line 225
  retstr = (char *)tmp;
  }
#line 226
  if ((unsigned long )retstr == (unsigned long )((void *)0)) {
#line 228
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 229
      tmp___0 = date_n_user();
#line 229
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t alloc memory!\n",
              tmp___0);
      }
    }
#line 233
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 233
      fclose(outfptr);
      }
    }
    {
#line 234
    exit(1);
    }
  }
#line 236
  return (retstr);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
int contains(char *str , char *pat ) 
{ 
  register int i ;
  register int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 246
  i = 0;
#line 246
  j = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ((int )*(str + i) != 0)) {
#line 248
      goto while_break;
    }
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 249
      tmp = tolower((int )*(str + i));
#line 249
      tmp___0 = tolower((int )*(pat + j));
      }
#line 249
      if (! (tmp == tmp___0)) {
#line 249
        goto while_break___0;
      }
#line 250
      i ++;
#line 250
      j ++;
#line 251
      if ((int )*(pat + j) == 0) {
#line 252
        return (1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    i = (i - j) + 1;
#line 255
    j = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (0);
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
static char value[10]  ;
#line 261 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
char *itoa(int i , int two_digit ) 
{ 


  {
#line 269
  if (two_digit) {
    {
#line 270
    sprintf((char */* __restrict  */)(value), (char const   */* __restrict  */)"%02d",
            i);
    }
  } else {
    {
#line 272
    sprintf((char */* __restrict  */)(value), (char const   */* __restrict  */)"%d",
            i);
    }
  }
#line 274
  return (value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void lowercase(char *string ) 
{ 
  register int i ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 284
  tmp = strlen((char const   *)string);
#line 284
  i = (int )tmp;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    i --;
#line 284
    if (! (i >= 0)) {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp___1 = __ctype_b_loc();
    }
#line 285
    if ((int const   )*(*tmp___1 + (int )*(string + i)) & 256) {
      {
#line 286
      tmp___0 = tolower((int )*(string + i));
#line 286
      *(string + i) = (char )tmp___0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return;
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void stringcopy(char *dest , char *src , int len ) 
{ 


  {
  {
#line 298
  strncpy((char */* __restrict  */)dest, (char const   */* __restrict  */)src, (size_t )len);
#line 299
  *(dest + (len - 1)) = (char )'\000';
  }
#line 300
  return;
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
int expand_filename(char *filename ) 
{ 
  char temp_filename[256] ;
  char *ptr ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;

  {
#line 319
  ptr = filename;
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    if (! ((int )*ptr == 32)) {
#line 320
      goto while_break;
    }
#line 320
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  stringcopy(temp_filename, ptr, 256);
#line 324
  tmp = strlen((char const   *)(temp_filename));
#line 324
  ptr = (temp_filename + tmp) - 1;
  }
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! ((int )*ptr == 10)) {
#line 325
      if (! ((int )*ptr == 13)) {
#line 325
        goto while_break___0;
      }
    }
#line 326
    tmp___0 = ptr;
#line 326
    ptr --;
#line 326
    *tmp___0 = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 329
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 329
    if (! ((int )*ptr == 92)) {
#line 329
      if (! ((int )*ptr == 32)) {
#line 329
        goto while_break___1;
      }
    }
#line 330
    tmp___1 = ptr;
#line 330
    ptr --;
#line 330
    *tmp___1 = (char )'\000';
  }
  while_break___1: /* CIL Label */ ;
  }
#line 332
  if ((int )temp_filename[0] == 126) {
#line 332
    if ((int )temp_filename[1] == 47) {
      {
#line 334
      tmp___4 = strlen((char const   *)(home));
      }
#line 334
      if ((int )home[tmp___4 - 1UL] != 47) {
#line 334
        tmp___3 = "/";
      } else {
#line 334
        tmp___3 = "";
      }
      {
#line 334
      sprintf((char */* __restrict  */)filename, (char const   */* __restrict  */)"%s%s%s",
              home, tmp___3, & temp_filename[2]);
      }
    } else {
      {
#line 342
      stringcopy(filename, temp_filename, 256);
      }
    }
  } else {
    {
#line 342
    stringcopy(filename, temp_filename, 256);
    }
  }
#line 344
  return (1);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
static int tmpinuse  =    0;
#line 356 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
FILE *make_tempfile(void) 
{ 
  FILE *returnfp ;
  int fd ;
  int mypid ;

  {
  {
#line 360
  mypid = getpid();
  }
#line 362
  if (tmpinuse != 0) {
    {
#line 363
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tempfile already in use, but make_tempfile called?\n");
    }
#line 365
    return ((FILE *)((void *)0));
  }
  {
#line 367
  sprintf((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)"%s_%s.%d",
          "/tmp/filter", username, mypid);
#line 368
  fd = open((char const   *)(tmpfilename), 194, 384);
  }
#line 369
  if (fd == -1) {
    {
#line 370
    sprintf((char */* __restrict  */)(tmpfilename), (char const   */* __restrict  */)"%s_%s.%d.2",
            "/tmp/filter", username, mypid);
#line 371
    fd = open((char const   *)(tmpfilename), 194, 384);
    }
  }
#line 373
  if (fd == -1) {
#line 374
    return ((FILE *)((void *)0));
  }
  {
#line 377
  returnfp = fdopen(fd, "w+");
#line 378
  tmpinuse = 1;
  }
#line 379
  return (returnfp);
}
}
#line 384 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/utils.c"
void remove_tempfile(void) 
{ 


  {
  {
#line 385
  unlink((char const   *)(tmpfilename));
#line 386
  tmpinuse = 0;
  }
#line 387
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 443 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/defs.h"
char *strtokq(char *source , char *keys , int flag ) ;
#line 117 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/parse.c"
static int grow(struct ruleset_record **ptr , int oldsize , int incr ) 
{ 
  struct ruleset_record *newptr ;
  int newsize ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 125
  if ((unsigned long )ptr == (unsigned long )((struct ruleset_record **)0)) {
#line 125
    return (0);
  }
#line 127
  newsize = oldsize + incr;
#line 128
  if (oldsize == 0) {
    {
#line 129
    tmp = malloc(sizeof(struct ruleset_record ) * (unsigned long )newsize);
#line 129
    newptr = (struct ruleset_record *)tmp;
    }
  } else {
    {
#line 132
    tmp___0 = realloc((void *)((char *)*ptr), sizeof(struct ruleset_record ) * (unsigned long )newsize);
#line 132
    newptr = (struct ruleset_record *)tmp___0;
    }
  }
#line 135
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 136
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 137
      tmp___1 = date_n_user();
#line 137
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t alloc memory for %d rules!\n",
              tmp___1, newsize);
      }
    }
#line 141
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 141
      fclose(outfptr);
      }
    }
    {
#line 142
    exit(1);
    }
  }
#line 145
  *ptr = newptr;
#line 146
  return (newsize);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/parse.c"
int get_filter_rules(void) 
{ 
  FILE *fd ;
  char buffer___0[256] ;
  char *str ;
  char *word ;
  char filename[256] ;
  char action_argument[256] ;
  char cond_argument[256] ;
  int not_condition ;
  int type ;
  int lasttype ;
  int state ;
  int relop ;
  int action ;
  int buflen ;
  int line ;
  struct condition_rec *cond ;
  struct condition_rec *newcond ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  int tmp___47 ;
  size_t tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  int tmp___51 ;
  size_t tmp___52 ;
  int tmp___53 ;
  size_t tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;
  size_t tmp___59 ;
  int tmp___60 ;
  size_t tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  int tmp___64 ;
  size_t tmp___65 ;
  char *tmp___66 ;
  size_t tmp___67 ;
  int tmp___68 ;
  size_t tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  int tmp___72 ;
  size_t tmp___73 ;
  int tmp___74 ;
  size_t tmp___75 ;
  int tmp___76 ;
  size_t tmp___77 ;
  int tmp___78 ;
  size_t tmp___79 ;
  int tmp___80 ;
  size_t tmp___81 ;
  int tmp___82 ;
  size_t tmp___83 ;
  int tmp___84 ;
  size_t tmp___85 ;
  int tmp___86 ;
  char *tmp___87 ;
  void *tmp___88 ;
  char *tmp___89 ;
  void *tmp___90 ;
  char *tmp___91 ;

  {
  {
#line 166
  not_condition = 0;
#line 166
  type = 0;
#line 166
  lasttype = 0;
#line 166
  state = 0;
#line 166
  relop = 0;
#line 166
  line = 0;
#line 178
  stringcopy(filename, filterfile, 256);
#line 180
  fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 180
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 181
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 182
      tmp = date_n_user();
#line 182
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t read filter rules file \"%s\"!\n",
              tmp, filename);
      }
    }
#line 185
    return (-1);
  }
#line 188
  if (sizeof_rules == 0) {
    {
#line 189
    sizeof_rules = grow(& rules, sizeof_rules, 25);
    }
  }
  {
#line 191
  action_argument[0] = (char )'\000';
#line 191
  cond_argument[0] = action_argument[0];
#line 195
  tmp___1 = malloc(sizeof(struct condition_rec ));
#line 195
  cond = (struct condition_rec *)tmp___1;
  }
#line 195
  if ((unsigned long )cond == (unsigned long )((void *)0)) {
#line 197
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 198
      tmp___0 = date_n_user();
#line 198
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): couldn\'t malloc first condition rec!\n",
              tmp___0);
      }
    }
#line 202
    return (-1);
  }
#line 205
  (rules + total_rules)->condition = cond;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 207
    tmp___91 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)fd);
    }
#line 207
    if (! ((unsigned long )tmp___91 != (unsigned long )((void *)0))) {
#line 207
      goto while_break;
    }
    {
#line 208
    line ++;
#line 209
    tmp___2 = strlen((char const   *)(buffer___0));
#line 209
    buflen = (int )tmp___2;
    }
#line 210
    if ((int )buffer___0[0] == 35) {
#line 211
      goto while_continue;
    }
#line 212
    if (buflen < 2) {
#line 213
      goto while_continue;
    }
#line 215
    if (lasttype != 10) {
#line 215
      if (lasttype != 0) {
#line 216
        lasttype = type;
#line 217
        type = 0;
      }
    }
#line 219
    str = buffer___0;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 226
      word = strtokq(str, " ()[]:\t\n", 0);
      }
#line 226
      if (! ((unsigned long )word != (unsigned long )((void *)0))) {
#line 226
        goto while_break___0;
      }
      {
#line 228
      str = (char *)((void *)0);
#line 230
      lowercase(word);
#line 232
      tmp___3 = strcmp((char const   *)word, "if");
      }
#line 232
      if (tmp___3 == 0) {
        {
#line 233
        word = strtokq(str, " ()[]:\t\n", 0);
        }
#line 233
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 234
          goto while_continue___0;
        }
        {
#line 235
        lowercase(word);
        }
      }
#line 238
      if (state == 0) {
        {
#line 239
        lasttype = type;
#line 240
        type = 0;
#line 242
        tmp___4 = strlen("not");
#line 242
        tmp___5 = strncmp((char const   *)word, "not", tmp___4);
        }
#line 242
        if (tmp___5 == 0) {
#line 242
          goto _L;
        } else {
          {
#line 242
          tmp___6 = strlen("!");
#line 242
          tmp___7 = strncmp((char const   *)word, "!", tmp___6);
          }
#line 242
          if (tmp___7 == 0) {
            _L: /* CIL Label */ 
            {
#line 243
            not_condition = 1;
#line 244
            word = strtokq(str, " ()[]\t\n", 1);
            }
#line 244
            if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 245
              goto while_continue___0;
            }
          }
        }
        {
#line 248
        tmp___37 = strlen("from");
#line 248
        tmp___38 = strncmp((char const   *)word, "from", tmp___37);
        }
#line 248
        if (tmp___38 == 0) {
#line 249
          type = 2;
        } else {
          {
#line 250
          tmp___35 = strlen("rcpt-to");
#line 250
          tmp___36 = strncmp((char const   *)word, "rcpt-to", tmp___35);
          }
#line 250
          if (tmp___36 == 0) {
#line 251
            type = 5;
          } else {
            {
#line 252
            tmp___33 = strlen("to");
#line 252
            tmp___34 = strncmp((char const   *)word, "to", tmp___33);
            }
#line 252
            if (tmp___34 == 0) {
#line 253
              type = 1;
            } else {
              {
#line 254
              tmp___31 = strlen("mailinglist");
#line 254
              tmp___32 = strncmp((char const   *)word, "mailinglist", tmp___31);
              }
#line 254
              if (tmp___32 == 0) {
#line 255
                type = 20;
              } else {
                {
#line 256
                tmp___29 = strlen("subject");
#line 256
                tmp___30 = strncmp((char const   *)word, "subject", tmp___29);
                }
#line 256
                if (tmp___30 == 0) {
#line 257
                  type = 4;
                } else {
                  {
#line 258
                  tmp___27 = strlen("alphasubject");
#line 258
                  tmp___28 = strncmp((char const   *)word, "alphasubject", tmp___27);
                  }
#line 258
                  if (tmp___28 == 0) {
#line 259
                    type = 6;
                  } else {
                    {
#line 260
                    tmp___25 = strlen("sender");
#line 260
                    tmp___26 = strncmp((char const   *)word, "sender", tmp___25);
                    }
#line 260
                    if (tmp___26 == 0) {
#line 261
                      type = 14;
                    } else {
                      {
#line 262
                      tmp___23 = strlen("lines");
#line 262
                      tmp___24 = strncmp((char const   *)word, "lines", tmp___23);
                      }
#line 262
                      if (tmp___24 == 0) {
#line 263
                        type = 3;
                      } else {
                        {
#line 264
                        tmp___21 = strlen("contains");
#line 264
                        tmp___22 = strncmp((char const   *)word, "contains", tmp___21);
                        }
#line 264
                        if (tmp___22 == 0) {
#line 265
                          type = 7;
                        } else {
                          {
#line 266
                          tmp___17 = strlen("and");
#line 266
                          tmp___18 = strncmp((char const   *)word, "and", tmp___17);
                          }
#line 266
                          if (tmp___18 == 0) {
#line 268
                            type = 10;
                          } else {
                            {
#line 266
                            tmp___19 = strlen("&&");
#line 266
                            tmp___20 = strncmp((char const   *)word, "&&", tmp___19);
                            }
#line 266
                            if (tmp___20 == 0) {
#line 268
                              type = 10;
                            } else {
                              {
#line 269
                              tmp___11 = strlen("?");
#line 269
                              tmp___12 = strncmp((char const   *)word, "?", tmp___11);
                              }
#line 269
                              if (tmp___12 == 0) {
#line 269
                                goto _L___0;
                              } else {
                                {
#line 269
                                tmp___13 = strlen("then");
#line 269
                                tmp___14 = strncmp((char const   *)word, "then", tmp___13);
                                }
#line 269
                                if (tmp___14 == 0) {
#line 269
                                  goto _L___0;
                                } else {
                                  {
#line 269
                                  tmp___15 = strlen("always");
#line 269
                                  tmp___16 = strncmp((char const   *)word, "always",
                                                     tmp___15);
                                  }
#line 269
                                  if (tmp___16 == 0) {
                                    _L___0: /* CIL Label */ 
#line 275
                                    if (lasttype == 10) {
#line 276
                                      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
                                        {
#line 277
                                        tmp___8 = date_n_user();
#line 277
                                        fprintf((FILE */* __restrict  */)outfptr,
                                                (char const   */* __restrict  */)"filter (%s): Error reading line %d of rules - badly placed \"and\"\n",
                                                tmp___8, line);
                                        }
                                      }
#line 281
                                      return (-1);
                                    }
                                    {
#line 284
                                    tmp___9 = strlen("always");
#line 284
                                    tmp___10 = strncmp((char const   *)word, "always",
                                                       tmp___9);
                                    }
#line 284
                                    if (tmp___10 == 0) {
#line 285
                                      cond->matchwhat = 9;
                                    } else {
#line 287
                                      cond->matchwhat = lasttype;
                                    }
#line 289
                                    if (relop == 0) {
#line 289
                                      relop = 6;
                                    }
#line 290
                                    if (not_condition) {
#line 290
                                      cond->relation = - relop;
                                    } else {
#line 290
                                      cond->relation = relop;
                                    }
                                    {
#line 291
                                    cond->regex = (regexp *)((void *)0);
#line 293
                                    stringcopy(cond->argument1, cond_argument, 256);
#line 294
                                    cond->next = (struct condition_rec *)((void *)0);
#line 296
                                    state = 3;
#line 297
                                    word = strtokq(str, " ()[]\t\n", 1);
                                    }
#line 297
                                    if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 298
                                      goto while_continue___0;
                                    }
#line 299
                                    goto get_outta_loop;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 302
        if (type == 0) {
#line 303
          if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
            {
#line 304
            tmp___39 = date_n_user();
#line 304
            fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Error reading line %d of rules - field \"%s\" unknown!\n",
                    tmp___39, line, word);
            }
          }
#line 308
          return (-1);
        }
#line 311
        if (type == 10) {
#line 315
          cond->matchwhat = lasttype;
#line 316
          if (relop == 0) {
#line 316
            relop = 6;
          }
#line 317
          if (not_condition) {
#line 317
            cond->relation = - relop;
          } else {
#line 317
            cond->relation = relop;
          }
          {
#line 318
          cond->regex = (regexp *)((void *)0);
#line 319
          stringcopy(cond->argument1, cond_argument, 256);
#line 320
          tmp___41 = malloc(sizeof(struct condition_rec ));
#line 320
          newcond = (struct condition_rec *)tmp___41;
          }
#line 320
          if ((unsigned long )newcond == (unsigned long )((void *)0)) {
#line 322
            if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
              {
#line 323
              tmp___40 = date_n_user();
#line 323
              fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t malloc new cond rec!!\n",
                      tmp___40);
              }
            }
#line 327
            return (-1);
          }
#line 329
          cond->next = newcond;
#line 330
          cond = newcond;
#line 331
          cond->next = (struct condition_rec *)((void *)0);
#line 333
          not_condition = 0;
#line 334
          state = 0;
        } else {
#line 337
          state = 1;
        }
      }
      get_outta_loop: 
#line 343
      if (state == 1) {
        {
#line 345
        word = strtokq(str, " ()[]\t\n", 1);
        }
#line 345
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 346
          goto while_continue___0;
        }
        {
#line 348
        lowercase(word);
#line 350
        relop = 0;
#line 352
        tmp___59 = strlen("=");
#line 352
        tmp___60 = strncmp((char const   *)word, "=", tmp___59);
        }
#line 352
        if (tmp___60 == 0) {
#line 354
          state = 2;
#line 355
          relop = 6;
        } else {
          {
#line 352
          tmp___61 = strlen("in");
#line 352
          tmp___62 = strncmp((char const   *)word, "in", tmp___61);
          }
#line 352
          if (tmp___62 == 0) {
#line 354
            state = 2;
#line 355
            relop = 6;
          } else {
            {
#line 352
            tmp___63 = strlen("contains");
#line 352
            tmp___64 = strncmp((char const   *)word, "contains", tmp___63);
            }
#line 352
            if (tmp___64 == 0) {
#line 354
              state = 2;
#line 355
              relop = 6;
            } else {
              {
#line 358
              tmp___54 = strlen("<>");
#line 358
              tmp___55 = strncmp((char const   *)word, "<>", tmp___54);
              }
#line 358
              if (tmp___55 == 0) {
#line 359
                relop = 5;
              } else {
                {
#line 358
                tmp___56 = strlen("!=");
#line 358
                tmp___57 = strncmp((char const   *)word, "!=", tmp___56);
                }
#line 358
                if (tmp___57 == 0) {
#line 359
                  relop = 5;
                } else {
                  {
#line 360
                  tmp___50 = strlen("~");
#line 360
                  tmp___51 = strncmp((char const   *)word, "~", tmp___50);
                  }
#line 360
                  if (tmp___51 == 0) {
#line 361
                    relop = 7;
                  } else {
                    {
#line 360
                    tmp___52 = strlen("matches");
#line 360
                    tmp___53 = strncmp((char const   *)word, "matches", tmp___52);
                    }
#line 360
                    if (tmp___53 == 0) {
#line 361
                      relop = 7;
                    } else {
                      {
#line 365
                      tmp___48 = strlen("<=");
#line 365
                      tmp___49 = strncmp((char const   *)word, "<=", tmp___48);
                      }
#line 365
                      if (tmp___49 == 0) {
#line 365
                        relop = 1;
                      } else {
                        {
#line 366
                        tmp___46 = strlen(">=");
#line 366
                        tmp___47 = strncmp((char const   *)word, ">=", tmp___46);
                        }
#line 366
                        if (tmp___47 == 0) {
#line 366
                          relop = 3;
                        } else {
                          {
#line 367
                          tmp___44 = strlen(">");
#line 367
                          tmp___45 = strncmp((char const   *)word, ">", tmp___44);
                          }
#line 367
                          if (tmp___45 == 0) {
#line 367
                            relop = 4;
                          } else {
                            {
#line 368
                            tmp___42 = strlen("<");
#line 368
                            tmp___43 = strncmp((char const   *)word, "<", tmp___42);
                            }
#line 368
                            if (tmp___43 == 0) {
#line 368
                              relop = 2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              {
#line 371
              if (relop == 1) {
#line 371
                goto case_1;
              }
#line 371
              if (relop == 2) {
#line 371
                goto case_1;
              }
#line 371
              if (relop == 4) {
#line 371
                goto case_1;
              }
#line 371
              if (relop == 3) {
#line 371
                goto case_1;
              }
#line 370
              goto switch_break;
              case_1: /* CIL Label */ 
              case_2: /* CIL Label */ 
              case_4: /* CIL Label */ 
              case_3: /* CIL Label */ 
#line 372
              if (type != 3) {
#line 372
                if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
                  {
#line 373
                  tmp___58 = date_n_user();
#line 373
                  fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Bad comparison at line %d\n",
                          tmp___58, line);
                  }
#line 378
                  return (-1);
                }
              }
              switch_break: /* CIL Label */ ;
              }
#line 383
              state = 2;
            }
          }
        }
      }
#line 388
      if (state == 2) {
#line 389
        if (relop == 7) {
#line 391
          cond_argument[0] = (char )'\000';
          {
#line 392
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 393
            word = strtokq(str, "/", 0);
            }
#line 393
            if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 394
              goto while_break___1;
            }
            {
#line 395
            strncat((char */* __restrict  */)(cond_argument), (char const   */* __restrict  */)word,
                    (size_t )256);
#line 396
            tmp___65 = strlen((char const   *)word);
            }
#line 396
            if ((int )*(word + (tmp___65 - 1UL)) == 92) {
              {
#line 397
              strncat((char */* __restrict  */)(cond_argument), (char const   */* __restrict  */)"/",
                      (size_t )256);
              }
            } else {
#line 399
              goto while_break___1;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 401
          if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 402
            goto while_continue___0;
          }
        } else {
#line 405
          if (relop != 0) {
            {
#line 406
            word = strtokq(str, " ()[]\t\n", 1);
            }
#line 406
            if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 407
              goto while_continue___0;
            }
          }
          {
#line 409
          stringcopy(cond_argument, word, 256);
          }
        }
#line 411
        state = 0;
      }
#line 414
      if (state == 3) {
        {
#line 415
        action = 0;
#line 417
        not_condition = 0;
#line 419
        tmp___85 = strlen("delete");
#line 419
        tmp___86 = strncmp((char const   *)word, "delete", tmp___85);
        }
#line 419
        if (tmp___86 == 0) {
#line 419
          action = 17;
        } else {
          {
#line 420
          tmp___83 = strlen("savec");
#line 420
          tmp___84 = strncmp((char const   *)word, "savec", tmp___83);
          }
#line 420
          if (tmp___84 == 0) {
#line 420
            action = 19;
          } else {
            {
#line 421
            tmp___81 = strlen("save");
#line 421
            tmp___82 = strncmp((char const   *)word, "save", tmp___81);
            }
#line 421
            if (tmp___82 == 0) {
#line 421
              action = 18;
            } else {
              {
#line 422
              tmp___79 = strlen("forwardc");
#line 422
              tmp___80 = strncmp((char const   *)word, "forwardc", tmp___79);
              }
#line 422
              if (tmp___80 == 0) {
#line 422
                action = 13;
              } else {
                {
#line 423
                tmp___77 = strlen("forward");
#line 423
                tmp___78 = strncmp((char const   *)word, "forward", tmp___77);
                }
#line 423
                if (tmp___78 == 0) {
#line 423
                  action = 10;
                } else {
                  {
#line 424
                  tmp___75 = strlen("executec");
#line 424
                  tmp___76 = strncmp((char const   *)word, "executec", tmp___75);
                  }
#line 424
                  if (tmp___76 == 0) {
#line 424
                    action = 15;
                  } else {
                    {
#line 425
                    tmp___73 = strlen("exec");
#line 425
                    tmp___74 = strncmp((char const   *)word, "exec", tmp___73);
                    }
#line 425
                    if (tmp___74 == 0) {
#line 425
                      action = 12;
                    } else {
                      {
#line 426
                      tmp___71 = strlen("leave");
#line 426
                      tmp___72 = strncmp((char const   *)word, "leave", tmp___71);
                      }
#line 426
                      if (tmp___72 == 0) {
#line 426
                        action = 11;
                      } else {
                        {
#line 427
                        tmp___69 = strlen("bounce");
#line 427
                        tmp___70 = strncmp((char const   *)word, "bounce", tmp___69);
                        }
#line 427
                        if (tmp___70 == 0) {
#line 427
                          action = 16;
                        } else {
                          {
#line 428
                          tmp___67 = strlen("resend");
#line 428
                          tmp___68 = strncmp((char const   *)word, "resend", tmp___67);
                          }
#line 428
                          if (tmp___68 == 0) {
#line 428
                            action = 21;
                          } else
#line 430
                          if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
                            {
#line 431
                            tmp___66 = date_n_user();
#line 431
                            fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Error on line %d of rules - action \"%s\" unknown\n",
                                    tmp___66, line, word);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
#line 437
        if (action == 17) {
#line 437
          goto _L___1;
        } else
#line 437
        if (action == 11) {
#line 437
          goto _L___1;
        } else
#line 437
        if (action == 16) {
          _L___1: /* CIL Label */ 
#line 442
          (rules + total_rules)->action = action;
#line 443
          (rules + total_rules)->argument2[0] = (char )'\000';
#line 444
          total_rules ++;
#line 444
          if (total_rules >= sizeof_rules) {
            {
#line 445
            sizeof_rules = grow(& rules, sizeof_rules, 25);
            }
          }
          {
#line 447
          tmp___88 = malloc(sizeof(struct condition_rec ));
#line 447
          cond = (struct condition_rec *)tmp___88;
          }
#line 447
          if ((unsigned long )cond == (unsigned long )((void *)0)) {
#line 449
            if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
              {
#line 450
              tmp___87 = date_n_user();
#line 450
              fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): couldn\'t malloc first condition rec!\n",
                      tmp___87);
              }
            }
#line 454
            return (-1);
          }
#line 457
          (rules + total_rules)->condition = cond;
#line 458
          state = 0;
        } else {
#line 461
          state = 4;
        }
        {
#line 464
        word = strtokq(str, " ()[]\t\n", 1);
        }
#line 464
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 465
          goto while_continue___0;
        }
      }
#line 469
      if (state == 4) {
        {
#line 470
        stringcopy(action_argument, word, 256);
#line 474
        (rules + total_rules)->action = action;
#line 475
        (rules + total_rules)->line = line;
        }
#line 480
        if (printing_rules) {
          {
#line 481
          expand_macros(action_argument, (rules + total_rules)->argument2, line, printing_rules);
          }
        } else {
          {
#line 484
          stringcopy((rules + total_rules)->argument2, action_argument, 256);
          }
        }
#line 486
        total_rules ++;
#line 486
        if (total_rules >= sizeof_rules) {
          {
#line 487
          sizeof_rules = grow(& rules, sizeof_rules, 25);
          }
        }
        {
#line 489
        tmp___90 = malloc(sizeof(struct condition_rec ));
#line 489
        cond = (struct condition_rec *)tmp___90;
        }
#line 489
        if ((unsigned long )cond == (unsigned long )((void *)0)) {
#line 491
          if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
            {
#line 492
            tmp___89 = date_n_user();
#line 492
            fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): couldn\'t malloc first condition rec!\n",
                    tmp___89);
            }
          }
#line 496
          return (-1);
        }
        {
#line 499
        (rules + total_rules)->condition = cond;
#line 501
        state = 0;
#line 502
        word = strtokq(str, " ()[]\t\n", 1);
        }
#line 502
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 503
          goto while_continue___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return (0);
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/version.h"
static char *versionstring___0  =    (char *)"filter 2.6.3";
#line 88 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
FILE *emergency_local_delivery(void) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
int pipe_to_mailer(FILE *ftmp , int resendflag , char *address ) 
{ 
  FILE *pipefd ;
  char buffer___0[2560] ;
  int in_header ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 106
  in_header = 1;
#line 108
  tmp = strcmp("/usr/sbin/sendmail", "/usr/sbin/sendmail");
  }
#line 108
  if (tmp == 0) {
    {
#line 109
    sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%s %s %s",
            "/usr/sbin/sendmail", "-oi -oem", address);
    }
  } else {
    {
#line 111
    sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%s %s",
            "/usr/sbin/sendmail", address);
    }
  }
  {
#line 114
  pipefd = popen((char const   *)(buffer___0), "w");
  }
#line 114
  if ((unsigned long )pipefd == (unsigned long )((void *)0)) {
#line 115
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 117
      tmp___0 = date_n_user();
#line 117
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): popen %s failed!\n",
              tmp___0, buffer___0);
      }
    }
    {
#line 125
    sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"(%s %s %s < %s ) &",
            "/usr/sbin/sendmail", "-oi -oem", address, tmpfilename);
#line 127
    tmp___1 = system((char const   *)(buffer___0));
#line 127
    exit(tmp___1);
    }
  }
#line 131
  if (resendflag == 1) {
    {
#line 135
    tmp___3 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)ftmp);
    }
#line 135
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
#line 136
      tmp___2 = pclose(pipefd);
      }
#line 136
      return (tmp___2);
    }
    {
#line 142
    tmp___4 = strlen("From ");
#line 142
    tmp___5 = strncmp((char const   *)(buffer___0), "From ", tmp___4);
    }
#line 142
    if (! (tmp___5 == 0)) {
      {
#line 143
      fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"%s",
              buffer___0);
      }
    }
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 145
      tmp___6 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)ftmp);
      }
#line 145
      if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 145
        goto while_break;
      }
      {
#line 146
      fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"%s",
              buffer___0);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 148
    fflush(pipefd);
#line 149
    tmp___7 = pclose(pipefd);
    }
#line 149
    return (tmp___7);
  }
  {
#line 153
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"Subject: \"%s\"\n",
          subject);
#line 154
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"From: \"The Filter of %s@%s\" <%s>\n",
          username, hostname, username);
#line 159
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"To: %s\n",
          address);
#line 160
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"X-Filtered-By: %s\n\n",
          versionstring___0);
#line 166
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"-- Begin filtered message --\n\n");
  }
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 172
    tmp___10 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)ftmp);
    }
#line 172
    if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 172
      goto while_break___0;
    }
#line 173
    if (already_been_forwarded) {
#line 173
      if (in_header) {
        {
#line 174
        tmp___9 = strlen((char const   *)(buffer___0));
        }
#line 174
        if (tmp___9 == 1UL) {
#line 174
          in_header = 0;
        } else {
#line 174
          in_header = in_header;
        }
      } else {
        {
#line 177
        fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)" %s",
                buffer___0);
        }
      }
    } else {
      {
#line 177
      fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)" %s",
              buffer___0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 181
  fprintf((FILE */* __restrict  */)pipefd, (char const   */* __restrict  */)"\n-- End of filtered message --\n");
#line 186
  fflush(pipefd);
#line 187
  tmp___11 = pclose(pipefd);
  }
#line 187
  return (tmp___11);
}
}
#line 255
extern int ( /* missing proto */  wait)() ;
#line 200 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
int mail_message(char *address , FILE *fptr , int resendflag ) 
{ 
  FILE *mailfptr ;
  int line_count ;
  int mailunit ;
  int pid ;
  int statusp ;
  char buffer___0[2560] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 213
  line_count = 0;
#line 216
  rewind(fptr);
  }
#line 218
  if (show_only) {
#line 219
    return (0);
  }
  {
#line 222
  tmp___5 = strcmp((char const   *)address, (char const   *)(username));
  }
#line 222
  if (tmp___5 != 0) {
#line 224
    if (verbose) {
#line 224
      if (! log_actions_only) {
#line 224
        if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
          {
#line 225
          tmp = date_n_user();
#line 225
          fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Mailing to %s via %s\n",
                  tmp, address, "/usr/sbin/sendmail");
          }
        }
      }
    }
#line 232
    if (already_been_forwarded) {
      {
#line 233
      tmp___1 = contains(Hfrom, username);
      }
#line 233
      if (tmp___1) {
#line 234
        if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
          {
#line 235
          tmp___0 = date_n_user();
#line 235
          fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Filter loop detected!  Message left in tempfile %s\n",
                  tmp___0, tmpfilename);
          }
        }
#line 239
        if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
          {
#line 239
          fclose(outfptr);
          }
        }
        {
#line 244
        exit(0);
        }
      }
    }
    {
#line 253
    pid = fork();
    }
#line 253
    if (pid > 0) {
      {
#line 255
      wait(& statusp);
      }
#line 256
      if (statusp != 0) {
        {
#line 258
        tmp___2 = date_n_user();
#line 258
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Command \"%s\" exited with value %d\n",
                tmp___2, buffer___0, statusp);
        }
      }
    } else
#line 265
    if (pid == 0) {
      {
#line 269
      setuid((__uid_t )user_uid);
#line 270
      setgid((__gid_t )user_gid);
#line 272
      tmp___3 = pipe_to_mailer(fptr, resendflag, address);
#line 272
      _exit(tmp___3);
      }
    } else
#line 277
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 278
      tmp___4 = date_n_user();
#line 278
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): fork of command \"%s\" failed\n",
              tmp___4, buffer___0);
      }
    }
#line 285
    return (1);
  }
  {
#line 292
  tmp___9 = lock();
  }
#line 292
  if (tmp___9) {
#line 308
    if (verbose) {
#line 308
      if (! log_actions_only) {
#line 308
        if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
          {
#line 309
          tmp___8 = date_n_user();
#line 309
          fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): local delivery to %s\n",
                  tmp___8, address);
          }
        }
      }
    }
    {
#line 315
    mailunit = open((char const   *)(user_mailbox), 1089, 384);
    }
#line 315
    if (mailunit >= 0) {
      {
#line 317
      mailfptr = fdopen(mailunit, "a");
      }
    } else {
      {
#line 318
      mailfptr = emergency_local_delivery();
      }
#line 318
      if ((unsigned long )mailfptr == (unsigned long )((void *)0)) {
#line 319
        return (1);
      }
    }
  } else {
#line 294
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 295
      tmp___6 = date_n_user();
#line 295
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t create lock file\n",
              tmp___6);
#line 299
      tmp___7 = date_n_user();
#line 299
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open mailbox %s!\n",
              tmp___7, user_mailbox);
      }
    }
    {
#line 304
    mailfptr = emergency_local_delivery();
    }
#line 304
    if ((unsigned long )mailfptr == (unsigned long )((void *)0)) {
#line 305
      return (1);
    }
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    tmp___10 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                     (FILE */* __restrict  */)fptr);
    }
#line 322
    if (! ((unsigned long )tmp___10 != (unsigned long )((void *)0))) {
#line 322
      goto while_break;
    }
    {
#line 329
    fputs((char const   */* __restrict  */)(buffer___0), (FILE */* __restrict  */)mailfptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)mailfptr);
#line 335
  fclose(mailfptr);
#line 336
  unlock();
  }
#line 338
  return (0);
}
}
#line 393
int save_to_folder(char *foldername , FILE *tmpfptr ) ;
#line 353 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
int save_message(char *foldername , FILE *tmpfptr ) 
{ 
  int gid ;
  int pid ;
  int statusp ;
  int ret ;
  char *tmp ;
  __gid_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 363
  expand_filename(foldername);
  }
#line 365
  if (verbose) {
#line 365
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 366
      tmp = date_n_user();
#line 366
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Saving message in folder %s\n",
              tmp, foldername);
      }
    }
  }
#line 370
  if (show_only) {
#line 371
    return (0);
  }
  {
#line 373
  tmp___0 = getgid();
#line 373
  gid = (int )tmp___0;
  }
#line 376
  if (gid != user_gid) {
    {
#line 379
    pid = fork();
    }
#line 379
    if (pid > 0) {
      {
#line 381
      wait(& statusp);
      }
#line 382
      return (statusp);
    } else
#line 385
    if (pid == 0) {
      {
#line 392
      ret = setgid((__gid_t )user_gid);
#line 393
      ret = save_to_folder(foldername, tmpfptr);
#line 395
      _exit(ret);
      }
    } else {
      {
#line 400
      tmp___1 = date_n_user();
#line 400
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): fork-and-save message failed\n\tsaving with current group ID\n",
              tmp___1);
#line 409
      ret = save_to_folder(foldername, tmpfptr);
      }
#line 410
      return (ret);
    }
  } else {
    {
#line 419
    ret = save_to_folder(foldername, tmpfptr);
    }
#line 420
    return (ret);
  }
#line 423
  return (ret);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
int save_to_folder(char *foldername , FILE *tmpfptr ) 
{ 
  FILE *folderfptr ;
  char buffer___0[256] ;
  int fdunit ;
  int line_count ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 441
  line_count = 0;
#line 443
  rewind(tmpfptr);
#line 444
  fflush(tmpfptr);
#line 446
  tmp___1 = lockfolder(foldername);
  }
#line 446
  if (! tmp___1) {
    {
#line 448
    tmp = date_n_user();
#line 448
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Couldn\'t create lock file\n",
            tmp);
#line 452
    tmp___0 = date_n_user();
#line 452
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open mailfolder %s!\n",
            tmp___0, foldername);
    }
#line 457
    return (75);
  }
  {
#line 460
  fdunit = open((char const   *)foldername, 1089, 384);
  }
#line 460
  if (fdunit < 0) {
#line 462
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 463
      tmp___2 = date_n_user();
#line 463
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): can\'t save message to requested folder %s!\n",
              tmp___2, foldername);
      }
    }
#line 468
    return (75);
  }
  {
#line 470
  folderfptr = fdopen(fdunit, "a");
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 472
    tmp___3 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                    (FILE */* __restrict  */)tmpfptr);
    }
#line 472
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 472
      goto while_break;
    }
    {
#line 482
    fputs((char const   */* __restrict  */)(buffer___0), (FILE */* __restrict  */)folderfptr);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 491
  fprintf((FILE */* __restrict  */)folderfptr, (char const   */* __restrict  */)"\n\n");
#line 493
  fclose(folderfptr);
#line 495
  unlockfolder(foldername);
  }
#line 497
  return (0);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
void execute(char *command , FILE *tmpfptr ) 
{ 
  int pid ;
  int statusp ;
  char buffer___0[256] ;
  char *tmp ;
  char *tmp___0 ;
  int tmpfd ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 511
  rewind(tmpfptr);
#line 512
  fflush(tmpfptr);
  }
#line 514
  if (verbose) {
#line 514
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 515
      tmp = date_n_user();
#line 515
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Executing %s\n",
              tmp, command);
      }
    }
  }
#line 518
  if (show_only) {
#line 519
    return;
  }
  {
#line 522
  sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%s",
          command);
#line 524
  pid = fork();
  }
#line 524
  if (pid > 0) {
    {
#line 526
    wait(& statusp);
    }
#line 527
    if (statusp != 0) {
#line 529
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 530
        tmp___0 = date_n_user();
#line 530
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Command \"%s\" exited with value %d\n",
                tmp___0, command, statusp);
        }
      }
    }
  } else
#line 538
  if (pid == 0) {
    {
#line 544
    setgid((__gid_t )user_gid);
#line 545
    setuid((__uid_t )user_uid);
#line 547
    tmpfd = fileno(tmpfptr);
#line 548
    close(0);
#line 549
    dup(tmpfd);
#line 551
    tmp___1 = system((char const   *)(buffer___0));
#line 551
    exit(tmp___1);
    }
  } else {
    {
#line 555
    tmp___2 = date_n_user();
#line 555
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): fork of command \"%s\" failed\n",
            tmp___2, command);
    }
  }
#line 563
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/actions.c"
FILE *emergency_local_delivery(void) 
{ 
  FILE *fptr ;
  char mailbox[256] ;
  int mailunit ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 576
  sprintf((char */* __restrict  */)(mailbox), (char const   */* __restrict  */)"%s/%s",
          home, "EMERGENCY_MBOX");
#line 578
  mailunit = open((char const   *)(mailbox), 1089, 384);
  }
#line 578
  if (mailunit < 0) {
#line 579
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 580
      tmp = date_n_user();
#line 580
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open %s either!!\n",
              tmp, mailbox);
      }
    }
    {
#line 584
    sprintf((char */* __restrict  */)(mailbox), (char const   */* __restrict  */)"%s/%s",
            home, "MBOX.EMERGENCY");
#line 586
    mailunit = open((char const   *)(mailbox), 1089, 384);
    }
#line 586
    if (mailunit < 0) {
#line 588
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 589
        tmp___0 = date_n_user();
#line 589
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open %s either!!\n",
                tmp___0, mailbox);
#line 593
        tmp___1 = date_n_user();
#line 593
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): I can\'t open ANY mailboxes!  Augh!!\n",
                tmp___1);
        }
      }
      {
#line 599
      leave((char *)"Cannot open any mailbox");
      }
    } else
#line 603
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 604
      tmp___2 = date_n_user();
#line 604
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Using %s as emergency mailbox\n",
              tmp___2, mailbox);
      }
    }
  } else
#line 610
  if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
    {
#line 611
    tmp___3 = date_n_user();
#line 611
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Using %s as emergency mailbox\n",
            tmp___3, mailbox);
    }
  }
  {
#line 616
  fptr = fdopen(mailunit, "a");
  }
#line 617
  return (fptr);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
static struct regexp *last_regexp  =    (struct regexp *)((void *)0);
#line 110 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
static int matches(char *str , int relation , struct condition_rec *cond ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 117
  if (relation == 7) {
#line 117
    goto case_7;
  }
#line 127
  if (relation == 6) {
#line 127
    goto case_6;
  }
#line 129
  if (relation == 5) {
#line 129
    goto case_5;
  }
#line 131
  goto switch_default;
  case_7: /* CIL Label */ 
#line 118
  if ((unsigned long )cond->regex == (unsigned long )((void *)0)) {
    {
#line 119
    cond->regex = regcomp(cond->argument1);
    }
  }
  {
#line 120
  tmp = regexec(cond->regex, str);
  }
#line 120
  if (tmp) {
#line 121
    last_regexp = cond->regex;
#line 122
    return (1);
  } else {
#line 124
    return (0);
  }
  case_6: /* CIL Label */ 
  {
#line 128
  tmp___0 = contains(str, cond->argument1);
  }
#line 128
  return (tmp___0);
  case_5: /* CIL Label */ 
  {
#line 130
  tmp___1 = contains(str, cond->argument1);
  }
#line 130
  if (tmp___1) {
#line 130
    tmp___2 = 0;
  } else {
#line 130
    tmp___2 = 1;
  }
#line 130
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filter:matches(): CANNOTHAPPEN\n");
  }
#line 133
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
int multimatch(LIST *addrs , int relation , struct condition_rec *cond ) 
{ 
  int matchres ;

  {
#line 143
  matchres = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )addrs != (unsigned long )((void *)0))) {
#line 145
      goto while_break;
    }
    {
#line 147
    matchres = matches(addrs->str, relation, cond);
    }
#line 148
    if (matchres != 0) {
#line 149
      return (matchres);
    }
#line 150
    addrs = addrs->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (matchres);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
void regerror(char *s ) 
{ 


  {
#line 159
  if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
    {
#line 160
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Error: can\'t compile regexp: \"%s\"\n",
            username, s);
    }
  }
#line 165
  if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
    {
#line 165
    fclose(outfptr);
    }
  }
  {
#line 166
  exit(1);
  }
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
int compare(int line , int relop , struct condition_rec *cond ) 
{ 
  int rule_lines ;

  {
  {
#line 181
  rule_lines = atoi((char const   *)(cond->argument1));
  }
  {
#line 189
  if (relop == 1) {
#line 189
    goto case_1;
  }
#line 190
  if (relop == 2) {
#line 190
    goto case_2;
  }
#line 191
  if (relop == 3) {
#line 191
    goto case_3;
  }
#line 192
  if (relop == 4) {
#line 192
    goto case_4;
  }
#line 193
  if (relop == 5) {
#line 193
    goto case_5;
  }
#line 194
  if (relop == 6) {
#line 194
    goto case_6;
  }
#line 188
  goto switch_break;
  case_1: /* CIL Label */ 
#line 189
  return (line <= rule_lines);
  case_2: /* CIL Label */ 
#line 190
  return (line < rule_lines);
  case_3: /* CIL Label */ 
#line 191
  return (line >= rule_lines);
  case_4: /* CIL Label */ 
#line 192
  return (line > rule_lines);
  case_5: /* CIL Label */ 
#line 193
  return (line != rule_lines);
  case_6: /* CIL Label */ 
#line 194
  return (line == rule_lines);
  switch_break: /* CIL Label */ ;
  }
#line 196
  return (-1);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
int action_from_ruleset(void) 
{ 
  register int iindex ;
  register int not ;
  register int relation ;
  register int try_next_rule ;
  register int x ;
  struct condition_rec *cond ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 208
  iindex = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (iindex < total_rules)) {
#line 211
      goto while_break;
    }
#line 212
    cond = (rules + iindex)->condition;
#line 213
    try_next_rule = 0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if ((unsigned long )cond != (unsigned long )((void *)0)) {
#line 215
        if (! (! try_next_rule)) {
#line 215
          goto while_break___0;
        }
      } else {
#line 215
        goto while_break___0;
      }
      {
#line 217
      not = cond->relation < 0;
#line 218
      relation = abs(cond->relation);
      }
      {
#line 222
      if (cond->matchwhat == 5) {
#line 222
        goto case_5;
      }
#line 223
      if (cond->matchwhat == 1) {
#line 223
        goto case_1;
      }
#line 224
      if (cond->matchwhat == 20) {
#line 224
        goto case_20;
      }
#line 225
      if (cond->matchwhat == 14) {
#line 225
        goto case_14;
      }
#line 226
      if (cond->matchwhat == 4) {
#line 226
        goto case_4;
      }
#line 227
      if (cond->matchwhat == 6) {
#line 227
        goto case_6;
      }
#line 228
      if (cond->matchwhat == 3) {
#line 228
        goto case_3;
      }
#line 232
      if (cond->matchwhat == 2) {
#line 232
        goto case_2;
      }
#line 246
      if (cond->matchwhat == 7) {
#line 246
        goto case_7;
      }
#line 254
      if (cond->matchwhat == 9) {
#line 254
        goto case_9;
      }
#line 220
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 222
      x = matches(rcpt_to, relation, cond);
      }
#line 222
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 223
      x = multimatch(tolist, relation, cond);
      }
#line 223
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 224
      x = multimatch(mail_lists, relation, cond);
      }
#line 224
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 225
      x = matches(sender, relation, cond);
      }
#line 225
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 226
      x = matches(subject, relation, cond);
      }
#line 226
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 227
      x = matches(alphasubject, relation, cond);
      }
#line 227
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 228
      x = compare(lines, relation, cond);
      }
#line 228
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 234
      tmp = matches(Hfrom, relation, cond);
#line 234
      printf((char const   */* __restrict  */)"Hfrom: %d\n", tmp);
#line 235
      tmp___0 = matches(Efrom, relation, cond);
#line 235
      printf((char const   */* __restrict  */)"Efrom: %d\n", tmp___0);
#line 236
      tmp___1 = matches(sender, relation, cond);
#line 236
      printf((char const   */* __restrict  */)"sender: %d\n", tmp___1);
#line 237
      tmp___2 = matches(replyto, relation, cond);
#line 237
      printf((char const   */* __restrict  */)"replyto: %d\n", tmp___2);
#line 240
      tmp___3 = matches(Hfrom, relation, cond);
      }
#line 240
      if (tmp___3) {
#line 240
        tmp___7 = 1;
      } else {
        {
#line 240
        tmp___4 = matches(Efrom, relation, cond);
        }
#line 240
        if (tmp___4) {
#line 240
          tmp___7 = 1;
        } else {
          {
#line 240
          tmp___5 = matches(sender, relation, cond);
          }
#line 240
          if (tmp___5) {
#line 240
            tmp___7 = 1;
          } else {
            {
#line 240
            tmp___6 = matches(replyto, relation, cond);
            }
#line 240
            if (tmp___6) {
#line 240
              tmp___7 = 1;
            } else {
#line 240
              tmp___7 = 0;
            }
          }
        }
      }
#line 240
      x = tmp___7;
#line 244
      goto switch_break;
      case_7: /* CIL Label */ 
#line 246
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 246
        tmp___8 = date_n_user();
#line 246
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Error: rules based on \'contains\' are not implemented!\n",
                tmp___8);
        }
      }
#line 251
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 251
        fclose(outfptr);
        }
      }
      {
#line 252
      exit(0);
      }
      case_9: /* CIL Label */ 
#line 254
      not = 0;
#line 254
      x = 1;
#line 254
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 257
      if (not) {
#line 257
        if (x) {
#line 258
          try_next_rule ++;
        } else {
#line 257
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 257
      if (! not) {
#line 257
        if (! x) {
#line 258
          try_next_rule ++;
        } else {
#line 260
          cond = cond->next;
        }
      } else {
#line 260
        cond = cond->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 263
    if (! try_next_rule) {
#line 264
      rule_choosen = iindex;
#line 265
      return ((rules + rule_choosen)->action);
    }
#line 267
    iindex ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  rule_choosen = -1;
#line 271
  return (11);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
static struct __anonstruct_regmessage_29 regmessage[10]  = 
#line 280
  {      {98, (char *)"<match>"}, 
        {99, (char *)"<submatch-1>"}, 
        {100, (char *)"<submatch-2>"}, 
        {101, (char *)"<submatch-3>"}, 
        {102, (char *)"<submatch-4>"}, 
        {103, (char *)"<submatch-5>"}, 
        {104, (char *)"<submatch-6>"}, 
        {105, (char *)"<submatch-7>"}, 
        {106, (char *)"<submatch-8>"}, 
        {107, (char *)"<submatch-9>"}};
#line 296 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
void expand_macros(char *word , char *buffer___0 , int line , int display ) 
{ 
  struct tm *timerec ;
  time_t thetime ;
  register int i ;
  register int bufflen ;
  register int gotten_time ;
  register int reading_a_percent_sign ;
  register int len ;
  register int backslashed ;
  register int regsub___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  int fullyear ;
  char *tmp___13 ;
  size_t tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  char *sp ;
  char *ep ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 324
  bufflen = 0;
#line 324
  gotten_time = 0;
#line 324
  reading_a_percent_sign = 0;
#line 324
  backslashed = 0;
#line 327
  i = 0;
#line 327
  tmp = strlen((char const   *)word);
#line 327
  len = (int )tmp;
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! (i < len)) {
#line 327
      goto while_break;
    }
#line 328
    if (reading_a_percent_sign) {
#line 329
      reading_a_percent_sign = 0;
      {
#line 332
      if ((int )*(word + i) == 110) {
#line 332
        goto case_110;
      }
#line 348
      if ((int )*(word + i) == 114) {
#line 348
        goto case_114;
      }
#line 359
      if ((int )*(word + i) == 115) {
#line 359
        goto case_115;
      }
#line 372
      if ((int )*(word + i) == 83) {
#line 372
        goto case_83;
      }
#line 388
      if ((int )*(word + i) == 100) {
#line 388
        goto case_100;
      }
#line 398
      if ((int )*(word + i) == 68) {
#line 398
        goto case_68;
      }
#line 408
      if ((int )*(word + i) == 109) {
#line 408
        goto case_109;
      }
#line 418
      if ((int )*(word + i) == 121) {
#line 418
        goto case_121;
      }
#line 428
      if ((int )*(word + i) == 89) {
#line 428
        goto case_89;
      }
#line 440
      if ((int )*(word + i) == 104) {
#line 440
        goto case_104;
      }
#line 450
      if ((int )*(word + i) == 116) {
#line 450
        goto case_116;
      }
#line 464
      if ((int )*(word + i) == 57) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 56) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 55) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 54) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 53) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 52) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 51) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 50) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 49) {
#line 464
        goto case_57;
      }
#line 464
      if ((int )*(word + i) == 38) {
#line 464
        goto case_57;
      }
#line 489
      goto switch_default;
      case_110: /* CIL Label */ 
#line 332
      *(buffer___0 + bufflen) = (char )'\000';
#line 333
      if (display) {
        {
#line 334
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<sender>",
                (size_t )256);
        }
      } else {
        {
#line 341
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
#line 342
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(sender),
                (size_t )256);
#line 343
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
        }
      }
      {
#line 345
      tmp___0 = strlen((char const   *)buffer___0);
#line 345
      bufflen = (int )tmp___0;
      }
#line 346
      goto switch_break;
      case_114: /* CIL Label */ 
#line 348
      *(buffer___0 + bufflen) = (char )'\000';
#line 349
      if (display) {
        {
#line 350
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<return-address>",
                (size_t )256);
        }
      } else {
        {
#line 355
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(Hfrom),
                (size_t )256);
        }
      }
      {
#line 356
      tmp___1 = strlen((char const   *)buffer___0);
#line 356
      bufflen = (int )tmp___1;
      }
#line 357
      goto switch_break;
      case_115: /* CIL Label */ 
#line 359
      *(buffer___0 + bufflen) = (char )'\000';
#line 360
      if (display) {
        {
#line 361
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<subject>",
                (size_t )256);
        }
      } else {
        {
#line 365
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
#line 366
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(subject),
                (size_t )256);
#line 367
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
        }
      }
      {
#line 369
      tmp___2 = strlen((char const   *)buffer___0);
#line 369
      bufflen = (int )tmp___2;
      }
#line 370
      goto switch_break;
      case_83: /* CIL Label */ 
#line 372
      *(buffer___0 + bufflen) = (char )'\000';
#line 373
      if (display) {
        {
#line 374
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<Re: subject>",
                (size_t )256);
        }
      } else {
        {
#line 379
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
#line 380
        tmp___3 = strlen("Re:");
#line 380
        tmp___4 = strncmp((char const   *)(subject), "Re:", tmp___3);
        }
#line 380
        if (! (tmp___4 == 0)) {
          {
#line 381
          strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"Re: ",
                  (size_t )256);
          }
        }
        {
#line 382
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(subject),
                (size_t )256);
#line 383
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"\"",
                (size_t )256);
        }
      }
      {
#line 385
      tmp___5 = strlen((char const   *)buffer___0);
#line 385
      bufflen = (int )tmp___5;
      }
#line 386
      goto switch_break;
      case_100: /* CIL Label */ 
#line 388
      if (! gotten_time) {
        {
#line 388
        thetime = time((time_t *)0);
#line 388
        timerec = localtime((time_t const   *)(& thetime));
#line 388
        gotten_time ++;
        }
      }
#line 388
      *(buffer___0 + bufflen) = (char )'\000';
#line 389
      if (display) {
        {
#line 390
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<day-of-month>",
                (size_t )256);
        }
      } else {
        {
#line 394
        tmp___6 = itoa(timerec->tm_mday, 0);
#line 394
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___6,
                (size_t )256);
        }
      }
      {
#line 395
      tmp___7 = strlen((char const   *)buffer___0);
#line 395
      bufflen = (int )tmp___7;
      }
#line 396
      goto switch_break;
      case_68: /* CIL Label */ 
#line 398
      if (! gotten_time) {
        {
#line 398
        thetime = time((time_t *)0);
#line 398
        timerec = localtime((time_t const   *)(& thetime));
#line 398
        gotten_time ++;
        }
      }
#line 398
      *(buffer___0 + bufflen) = (char )'\000';
#line 399
      if (display) {
        {
#line 400
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<day-of-week>",
                (size_t )256);
        }
      } else {
        {
#line 404
        tmp___8 = itoa(timerec->tm_wday, 0);
#line 404
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___8,
                (size_t )256);
        }
      }
      {
#line 405
      tmp___9 = strlen((char const   *)buffer___0);
#line 405
      bufflen = (int )tmp___9;
      }
#line 406
      goto switch_break;
      case_109: /* CIL Label */ 
#line 408
      if (! gotten_time) {
        {
#line 408
        thetime = time((time_t *)0);
#line 408
        timerec = localtime((time_t const   *)(& thetime));
#line 408
        gotten_time ++;
        }
      }
#line 408
      *(buffer___0 + bufflen) = (char )'\000';
#line 409
      if (display) {
        {
#line 410
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<month>",
                (size_t )256);
        }
      } else {
        {
#line 414
        sprintf((char */* __restrict  */)(buffer___0 + bufflen), (char const   */* __restrict  */)"%2.2d",
                timerec->tm_mon + 1);
        }
      }
      {
#line 415
      tmp___10 = strlen((char const   *)buffer___0);
#line 415
      bufflen = (int )tmp___10;
      }
#line 416
      goto switch_break;
      case_121: /* CIL Label */ 
#line 418
      if (! gotten_time) {
        {
#line 418
        thetime = time((time_t *)0);
#line 418
        timerec = localtime((time_t const   *)(& thetime));
#line 418
        gotten_time ++;
        }
      }
#line 418
      *(buffer___0 + bufflen) = (char )'\000';
#line 419
      if (display) {
        {
#line 420
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<year>",
                (size_t )256);
        }
      } else {
        {
#line 424
        tmp___11 = itoa(timerec->tm_year, 1);
#line 424
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___11,
                (size_t )256);
        }
      }
      {
#line 425
      tmp___12 = strlen((char const   *)buffer___0);
#line 425
      bufflen = (int )tmp___12;
      }
#line 426
      goto switch_break;
      case_89: /* CIL Label */ 
#line 428
      if (! gotten_time) {
        {
#line 428
        thetime = time((time_t *)0);
#line 428
        timerec = localtime((time_t const   *)(& thetime));
#line 428
        gotten_time ++;
        }
      }
#line 428
      *(buffer___0 + bufflen) = (char )'\000';
#line 429
      if (display) {
        {
#line 430
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<year>",
                (size_t )256);
        }
      } else {
        {
#line 434
        fullyear = timerec->tm_year + 1900;
#line 435
        tmp___13 = itoa(fullyear, 0);
#line 435
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___13,
                (size_t )256);
        }
      }
      {
#line 437
      tmp___14 = strlen((char const   *)buffer___0);
#line 437
      bufflen = (int )tmp___14;
      }
#line 438
      goto switch_break;
      case_104: /* CIL Label */ 
#line 440
      if (! gotten_time) {
        {
#line 440
        thetime = time((time_t *)0);
#line 440
        timerec = localtime((time_t const   *)(& thetime));
#line 440
        gotten_time ++;
        }
      }
#line 440
      *(buffer___0 + bufflen) = (char )'\000';
#line 441
      if (display) {
        {
#line 442
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<hour>",
                (size_t )256);
        }
      } else {
        {
#line 446
        tmp___15 = itoa(timerec->tm_hour, 0);
#line 446
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___15,
                (size_t )256);
        }
      }
      {
#line 447
      tmp___16 = strlen((char const   *)buffer___0);
#line 447
      bufflen = (int )tmp___16;
      }
#line 448
      goto switch_break;
      case_116: /* CIL Label */ 
#line 450
      if (! gotten_time) {
        {
#line 450
        thetime = time((time_t *)0);
#line 450
        timerec = localtime((time_t const   *)(& thetime));
#line 450
        gotten_time ++;
        }
      }
#line 450
      *(buffer___0 + bufflen) = (char )'\000';
#line 451
      if (display) {
        {
#line 452
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)"<time>",
                (size_t )256);
        }
      } else {
        {
#line 456
        tmp___17 = itoa(timerec->tm_hour, 0);
#line 456
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___17,
                (size_t )256);
#line 457
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)":",
                (size_t )256);
#line 458
        tmp___18 = itoa(timerec->tm_min, 1);
#line 458
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)tmp___18,
                (size_t )256);
        }
      }
      {
#line 460
      tmp___19 = strlen((char const   *)buffer___0);
#line 460
      bufflen = (int )tmp___19;
      }
#line 461
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_38: /* CIL Label */ 
#line 466
      if ((int )*(word + i) == 38) {
#line 466
        regsub___0 = 0;
      } else {
#line 467
        regsub___0 = (int )*(word + i) - 48;
      }
#line 469
      if (display) {
        {
#line 470
        *(buffer___0 + bufflen) = (char )'\000';
#line 471
        strncat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)regmessage[regsub___0].str,
                (size_t )256);
#line 478
        tmp___20 = strlen((char const   *)buffer___0);
#line 478
        bufflen = (int )tmp___20;
        }
      } else
#line 480
      if ((unsigned long )last_regexp != (unsigned long )((void *)0)) {
#line 481
        sp = last_regexp->startp[regsub___0];
#line 482
        ep = last_regexp->endp[regsub___0];
#line 483
        if ((unsigned long )sp != (unsigned long )((void *)0)) {
#line 483
          if ((unsigned long )ep != (unsigned long )((void *)0)) {
#line 483
            if ((unsigned long )ep > (unsigned long )sp) {
              {
#line 484
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 484
                if (! ((unsigned long )sp < (unsigned long )ep)) {
#line 484
                  goto while_break___0;
                }
#line 484
                tmp___21 = bufflen;
#line 484
                bufflen ++;
#line 484
                tmp___22 = sp;
#line 484
                sp ++;
#line 484
                *(buffer___0 + tmp___21) = *tmp___22;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 487
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 489
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 489
        tmp___23 = date_n_user();
#line 489
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Error on line %d translating %%%c macro in word \"%s\"!\n",
                tmp___23, line, (int )*(word + i), word);
        }
      }
#line 494
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 494
        fclose(outfptr);
        }
      }
      {
#line 495
      exit(1);
      }
      switch_break: /* CIL Label */ ;
      }
    } else
#line 498
    if ((int )*(word + i) == 37) {
#line 499
      if (backslashed) {
#line 500
        tmp___24 = bufflen;
#line 500
        bufflen ++;
#line 500
        *(buffer___0 + tmp___24) = (char )'%';
#line 501
        backslashed = 0;
      } else {
#line 503
        reading_a_percent_sign ++;
      }
    } else
#line 505
    if ((int )*(word + i) == 92) {
#line 506
      if (backslashed) {
#line 507
        tmp___25 = bufflen;
#line 507
        bufflen ++;
#line 507
        *(buffer___0 + tmp___25) = (char )'\\';
#line 508
        backslashed = 0;
      } else {
#line 510
        backslashed ++;
      }
    } else {
#line 513
      tmp___26 = bufflen;
#line 513
      bufflen ++;
#line 513
      *(buffer___0 + tmp___26) = *(word + i);
#line 514
      backslashed = 0;
    }
#line 327
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  *(buffer___0 + bufflen) = (char )'\000';
#line 518
  return;
}
}
#line 525
char *whatname(int n ) ;
#line 525
char *actionname(int n ) ;
#line 520 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
void print_rules(void) 
{ 
  register int i ;
  struct condition_rec *cond ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;

  {
#line 524
  i = -1;
#line 528
  if ((unsigned long )outfptr == (unsigned long )((void *)0)) {
#line 528
    return;
  }
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    i ++;
#line 530
    if (! (i < total_rules)) {
#line 530
      goto while_break;
    }
#line 531
    if (((rules + i)->condition)->matchwhat == 9) {
      {
#line 532
      tmp = actionname((rules + i)->action);
#line 532
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\nRule %d:  ** always ** \n\t%s %s\n",
              i + 1, tmp, (rules + i)->argument2);
      }
#line 535
      goto while_continue;
    }
    {
#line 538
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\nRule %d:  if (",
            i + 1);
#line 541
    cond = (rules + i)->condition;
    }
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 543
      if (! ((unsigned long )cond != (unsigned long )((void *)0))) {
#line 543
        goto while_break___0;
      }
#line 544
      if (cond->relation < 0) {
#line 545
        if (cond->matchwhat == 3) {
#line 545
          tmp___1 = "";
        } else {
#line 545
          if (- cond->relation == 7) {
#line 545
            tmp___0 = "/";
          } else {
#line 545
            tmp___0 = "\"";
          }
#line 545
          tmp___1 = tmp___0;
        }
#line 545
        if (cond->matchwhat == 3) {
#line 545
          tmp___3 = "";
        } else {
#line 545
          if (- cond->relation == 7) {
#line 545
            tmp___2 = "/";
          } else {
#line 545
            tmp___2 = "\"";
          }
#line 545
          tmp___3 = tmp___2;
        }
#line 545
        if (- cond->relation == 1) {
#line 545
          tmp___9 = "<=";
        } else {
#line 545
          if (- cond->relation == 2) {
#line 545
            tmp___8 = "<";
          } else {
#line 545
            if (- cond->relation == 3) {
#line 545
              tmp___7 = ">=";
            } else {
#line 545
              if (- cond->relation == 4) {
#line 545
                tmp___6 = ">";
              } else {
#line 545
                if (- cond->relation == 5) {
#line 545
                  tmp___5 = "!=";
                } else {
#line 545
                  if (- cond->relation == 6) {
#line 545
                    tmp___4 = "=";
                  } else {
#line 545
                    tmp___4 = "~";
                  }
#line 545
                  tmp___5 = tmp___4;
                }
#line 545
                tmp___6 = tmp___5;
              }
#line 545
              tmp___7 = tmp___6;
            }
#line 545
            tmp___8 = tmp___7;
          }
#line 545
          tmp___9 = tmp___8;
        }
        {
#line 545
        tmp___10 = whatname(cond->matchwhat);
#line 545
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"not %s %s %s%s%s",
                tmp___10, tmp___9, tmp___3, cond->argument1, tmp___1);
        }
      } else {
#line 553
        if (cond->matchwhat == 3) {
#line 553
          tmp___12 = "";
        } else {
#line 553
          if (cond->relation == 7) {
#line 553
            tmp___11 = "/";
          } else {
#line 553
            tmp___11 = "\"";
          }
#line 553
          tmp___12 = tmp___11;
        }
#line 553
        if (cond->matchwhat == 3) {
#line 553
          tmp___14 = "";
        } else {
#line 553
          if (cond->relation == 7) {
#line 553
            tmp___13 = "/";
          } else {
#line 553
            tmp___13 = "\"";
          }
#line 553
          tmp___14 = tmp___13;
        }
#line 553
        if (cond->relation == 1) {
#line 553
          tmp___20 = "<=";
        } else {
#line 553
          if (cond->relation == 2) {
#line 553
            tmp___19 = "<";
          } else {
#line 553
            if (cond->relation == 3) {
#line 553
              tmp___18 = ">=";
            } else {
#line 553
              if (cond->relation == 4) {
#line 553
                tmp___17 = ">";
              } else {
#line 553
                if (cond->relation == 5) {
#line 553
                  tmp___16 = "!=";
                } else {
#line 553
                  if (cond->relation == 6) {
#line 553
                    tmp___15 = "=";
                  } else {
#line 553
                    tmp___15 = "~";
                  }
#line 553
                  tmp___16 = tmp___15;
                }
#line 553
                tmp___17 = tmp___16;
              }
#line 553
              tmp___18 = tmp___17;
            }
#line 553
            tmp___19 = tmp___18;
          }
#line 553
          tmp___20 = tmp___19;
        }
        {
#line 553
        tmp___21 = whatname(cond->matchwhat);
#line 553
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"%s %s %s%s%s",
                tmp___21, tmp___20, tmp___14, cond->argument1, tmp___12);
        }
      }
#line 560
      cond = cond->next;
#line 562
      if ((unsigned long )cond != (unsigned long )((void *)0)) {
        {
#line 563
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)" and ");
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 568
    tmp___22 = actionname((rules + i)->action);
#line 568
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)") then\n\t  %s %s\n",
            tmp___22, (rules + i)->argument2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 572
  fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\n");
  }
#line 573
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
static char buffer[10]  ;
#line 578 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
char *whatname(int n ) 
{ 


  {
  {
#line 584
  if (n == 5) {
#line 584
    goto case_5;
  }
#line 585
  if (n == 2) {
#line 585
    goto case_2;
  }
#line 586
  if (n == 1) {
#line 586
    goto case_1;
  }
#line 587
  if (n == 20) {
#line 587
    goto case_20;
  }
#line 588
  if (n == 14) {
#line 588
    goto case_14;
  }
#line 589
  if (n == 4) {
#line 589
    goto case_4;
  }
#line 590
  if (n == 6) {
#line 590
    goto case_6;
  }
#line 591
  if (n == 3) {
#line 591
    goto case_3;
  }
#line 592
  if (n == 7) {
#line 592
    goto case_7;
  }
#line 593
  goto switch_default;
  case_5: /* CIL Label */ 
#line 584
  return ((char *)"rcpt-to");
  case_2: /* CIL Label */ 
#line 585
  return ((char *)"from");
  case_1: /* CIL Label */ 
#line 586
  return ((char *)"to");
  case_20: /* CIL Label */ 
#line 587
  return ((char *)"mailinglist");
  case_14: /* CIL Label */ 
#line 588
  return ((char *)"sender");
  case_4: /* CIL Label */ 
#line 589
  return ((char *)"subject");
  case_6: /* CIL Label */ 
#line 590
  return ((char *)"alphasubject");
  case_3: /* CIL Label */ 
#line 591
  return ((char *)"lines");
  case_7: /* CIL Label */ 
#line 592
  return ((char *)"contains");
  switch_default: /* CIL Label */ 
  {
#line 593
  sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"?%d?",
          n);
  }
#line 593
  return (buffer);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/rules.c"
char *actionname(int n ) 
{ 


  {
  {
#line 601
  if (n == 17) {
#line 601
    goto case_17;
  }
#line 604
  if (n == 18) {
#line 604
    goto case_18;
  }
#line 607
  if (n == 19) {
#line 607
    goto case_19;
  }
#line 610
  if (n == 10) {
#line 610
    goto case_10;
  }
#line 613
  if (n == 13) {
#line 613
    goto case_13;
  }
#line 616
  if (n == 21) {
#line 616
    goto case_21;
  }
#line 619
  if (n == 16) {
#line 619
    goto case_16;
  }
#line 622
  if (n == 11) {
#line 622
    goto case_11;
  }
#line 625
  if (n == 12) {
#line 625
    goto case_12;
  }
#line 628
  if (n == 15) {
#line 628
    goto case_15;
  }
#line 631
  goto switch_default;
  case_17: /* CIL Label */ 
#line 601
  return ((char *)"Delete");
  case_18: /* CIL Label */ 
#line 604
  return ((char *)"Save");
  case_19: /* CIL Label */ 
#line 607
  return ((char *)"Copy and Save");
  case_10: /* CIL Label */ 
#line 610
  return ((char *)"Forward");
  case_13: /* CIL Label */ 
#line 613
  return ((char *)"Copy and Forward");
  case_21: /* CIL Label */ 
#line 616
  return ((char *)"Resend");
  case_16: /* CIL Label */ 
#line 619
  return ((char *)"Bounce");
  case_11: /* CIL Label */ 
#line 622
  return ((char *)"Leave");
  case_12: /* CIL Label */ 
#line 625
  return ((char *)"Execute");
  case_15: /* CIL Label */ 
#line 628
  return ((char *)"Execute and Save");
  switch_default: /* CIL Label */ 
#line 631
  return ((char *)"?action?");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/istrcmp.c"
int istrcmp(char *s1 , char *s2 ) 
{ 
  register int d ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 45
    tmp = tolower((int )*s1);
#line 45
    tmp___0 = tolower((int )*s2);
#line 45
    d = tmp - tmp___0;
    }
#line 46
    if (d != 0) {
#line 47
      return (d);
    } else
#line 46
    if ((int )*s1 == 0) {
#line 47
      return (d);
    } else
#line 46
    if ((int )*s2 == 0) {
#line 47
      return (d);
    }
#line 48
    s1 ++;
#line 49
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/summarize.c"
void show_summary(void) 
{ 
  FILE *fd ;
  char buffer___0[256] ;
  int erroneous_rules ;
  int default_rules ;
  int messages_filtered ;
  int rule ;
  int *applied ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 80
  erroneous_rules = 0;
#line 80
  default_rules = 0;
#line 80
  messages_filtered = 0;
#line 87
  fd = fopen((char const   */* __restrict  */)(filtersum), (char const   */* __restrict  */)"r");
  }
#line 87
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 88
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 89
      tmp = date_n_user();
#line 89
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open filtersum file %s!\n",
              tmp, filtersum);
      }
    }
#line 93
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 93
      fclose(outfptr);
      }
    }
    {
#line 94
    exit(1);
    }
  }
  {
#line 97
  tmp___0 = malloc(sizeof(int ) * (unsigned long )total_rules);
#line 97
  applied = (int *)tmp___0;
  }
#line 98
  if ((unsigned long )applied == (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 100
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Out of memory [malloc failed]\n",
              username);
      }
    }
#line 104
    if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
      {
#line 104
      fclose(outfptr);
      }
    }
    {
#line 105
    exit(1);
    }
  }
#line 108
  rule = 0;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (rule < total_rules)) {
#line 108
      goto while_break;
    }
#line 109
    *(applied + rule) = 0;
#line 108
    rule ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 117
    tmp___2 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)fd);
    }
#line 117
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 117
      goto while_break___0;
    }
    {
#line 118
    rule = atoi((char const   *)(buffer___0));
    }
#line 118
    if (rule > total_rules) {
#line 118
      goto _L;
    } else
#line 118
    if (rule < -1) {
      _L: /* CIL Label */ 
#line 119
      if ((unsigned long )outfptr != (unsigned long )((void *)0)) {
        {
#line 120
        tmp___1 = date_n_user();
#line 120
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Warning - rule #%d is invalid data for short summary!!\n",
                tmp___1, rule);
        }
      }
#line 124
      erroneous_rules ++;
    } else
#line 126
    if (rule == -1) {
#line 127
      default_rules ++;
    } else {
#line 129
      (*(applied + rule)) ++;
    }
#line 130
    messages_filtered ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 133
  fclose(fd);
  }
#line 137
  if ((unsigned long )outfptr == (unsigned long )((void *)0)) {
#line 137
    return;
  }
  {
#line 139
  fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\n\t\t\tA Summary of Filter Activity\n");
#line 141
  fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\t\t\t----------------------------\n\n");
  }
#line 144
  if (messages_filtered > 1) {
#line 144
    tmp___3 = "A total of %d messages were filtered:\n\n";
  } else {
#line 144
    tmp___3 = "A total of %d message was filtered:\n\n";
  }
  {
#line 144
  fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)tmp___3,
          messages_filtered);
  }
#line 154
  if (erroneous_rules) {
#line 156
    if (erroneous_rules > 1) {
#line 156
      tmp___4 = "[Warning: %d erroneous rules were logged and ignored!]";
    } else {
#line 156
      tmp___4 = "[Warning: %d erroneous rule was logged and ignored!]";
    }
    {
#line 156
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)tmp___4,
            erroneous_rules);
    }
  }
#line 169
  if (default_rules) {
    {
#line 170
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"The default rule of putting mail into your mailbox");
    }
#line 173
    if (default_rules > 1) {
#line 173
      tmp___5 = "\n\tapplied %d times (%d%%)\n\n";
    } else {
#line 173
      tmp___5 = "\n\tapplied %d time (%d%%)\n\n";
    }
    {
#line 173
    fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)tmp___5,
            default_rules, (default_rules * 100 + (messages_filtered >> 1)) / messages_filtered);
    }
  }
#line 186
  rule = 0;
  {
#line 186
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 186
    if (! (rule < total_rules)) {
#line 186
      goto while_break___1;
    }
#line 187
    if (*(applied + rule)) {
      {
#line 188
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"Rule #%d: ",
              rule + 1);
      }
      {
#line 191
      if ((rules + rule)->action == 16) {
#line 191
        goto case_16;
      }
#line 196
      if ((rules + rule)->action == 11) {
#line 196
        goto case_11;
      }
#line 201
      if ((rules + rule)->action == 17) {
#line 201
        goto case_17;
      }
#line 206
      if ((rules + rule)->action == 18) {
#line 206
        goto case_18;
      }
#line 212
      if ((rules + rule)->action == 19) {
#line 212
        goto case_19;
      }
#line 218
      if ((rules + rule)->action == 10) {
#line 218
        goto case_10;
      }
#line 224
      if ((rules + rule)->action == 21) {
#line 224
        goto case_21;
      }
#line 230
      if ((rules + rule)->action == 13) {
#line 230
        goto case_13;
      }
#line 236
      if ((rules + rule)->action == 12) {
#line 236
        goto case_12;
      }
#line 242
      if ((rules + rule)->action == 15) {
#line 242
        goto case_15;
      }
#line 190
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 191
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(bounce mail)");
      }
#line 195
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 196
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(leave mail in mailbox)");
      }
#line 200
      goto switch_break;
      case_17: /* CIL Label */ 
      {
#line 201
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(delete message)");
      }
#line 205
      goto switch_break;
      case_18: /* CIL Label */ 
      {
#line 206
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(save in \"%s\")",
              (rules + rule)->argument2);
      }
#line 211
      goto switch_break;
      case_19: /* CIL Label */ 
      {
#line 212
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(left in mailbox and saved in \"%s\")",
              (rules + rule)->argument2);
      }
#line 217
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 218
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(forwarded to \"%s\")",
              (rules + rule)->argument2);
      }
#line 223
      goto switch_break;
      case_21: /* CIL Label */ 
      {
#line 224
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(resent to \"%s\")",
              (rules + rule)->argument2);
      }
#line 229
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 230
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(left in mailbox and forwarded to \"%s\")",
              (rules + rule)->argument2);
      }
#line 235
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 236
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(given to command \"%s\")",
              (rules + rule)->argument2);
      }
#line 241
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 242
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"(left in mailbox and given to command \"%s\")",
              (rules + rule)->argument2);
      }
#line 247
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 249
      if (*(applied + rule) > 1) {
#line 249
        tmp___6 = "\n\tapplied %d times (%d%%)\n\n";
      } else {
#line 249
        tmp___6 = "\n\tapplied %d time (%d%%)\n\n";
      }
      {
#line 249
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)tmp___6,
              *(applied + rule), (*(applied + rule) * 100 + (messages_filtered >> 1)) / messages_filtered);
      }
    }
#line 186
    rule ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 261
  if (long_summary) {
    {
#line 265
    fd = fopen((char const   */* __restrict  */)(filterlog), (char const   */* __restrict  */)"r");
    }
#line 265
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
      {
#line 266
      tmp___7 = date_n_user();
#line 266
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"filter (%s): Can\'t open filterlog file %s!\n",
              tmp___7, filterlog);
      }
    } else {
      {
#line 272
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\n\n\n%c\n\nExplicit log of each action;\n\n",
              12);
      }
      {
#line 275
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 275
        tmp___8 = fgets((char */* __restrict  */)(buffer___0), 256, (FILE */* __restrict  */)fd);
        }
#line 275
        if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 275
          goto while_break___2;
        }
        {
#line 276
        fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"%s",
                buffer___0);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 277
      fprintf((FILE */* __restrict  */)outfptr, (char const   */* __restrict  */)"\n-----\n");
#line 278
      fclose(fd);
      }
    }
  }
#line 284
  if (clear_logs) {
    {
#line 285
    unlink((char const   *)(filterlog));
#line 286
    unlink((char const   *)(filtersum));
    }
  }
#line 289
  return;
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.c"
static char date[48]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.c"
static char *stuff  =    (char *)((void *)0);
#line 58
extern int ( /* missing proto */  strftime)() ;
#line 50 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.c"
char *date_n_user(void) 
{ 
  time_t now ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 57
  tmp = (int )time((void *)0);
#line 57
  now = (time_t )tmp;
#line 58
  tmp___0 = (int )localtime(& now);
#line 58
  tmp___1 = strftime(date, 48, "%c", tmp___0);
  }
#line 58
  if (! tmp___1) {
#line 59
    return (username);
  }
#line 60
  if (stuff) {
    {
#line 61
    free((void *)stuff);
    }
  }
  {
#line 62
  tmp___2 = strlen((char const   *)(username));
#line 62
  tmp___3 = strlen((char const   *)(date));
#line 62
  tmp___4 = malloc((tmp___2 + tmp___3) + 3UL);
#line 62
  stuff = (char *)tmp___4;
  }
#line 62
  if (! stuff) {
#line 63
    return (username);
  }
  {
#line 64
  sprintf((char */* __restrict  */)stuff, (char const   */* __restrict  */)"%s %s",
          date, username);
  }
#line 65
  return (stuff);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.c"
static char date___0[48]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/audit.c"
char *datestring(void) 
{ 
  time_t now ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 74
  tmp = (int )time((void *)0);
#line 74
  now = (time_t )tmp;
#line 75
  tmp___0 = (int )localtime(& now);
#line 75
  tmp___1 = strftime(date___0, 48, "%c", tmp___0);
  }
#line 75
  if (! tmp___1) {
#line 76
    return ((char *)"[strftime failed?]");
  }
#line 77
  return (date___0);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/strtokq.c"
static char *sourceptr  =    (char *)((void *)0);
#line 27
extern int ( /* missing proto */  strspn)() ;
#line 13 "/home/june/repo/benchmarks/collector/temp/filter-2.6.3/strtokq.c"
char *strtokq(char *source , char *keys , int flag ) 
{ 
  register int last_ch ;
  char *return_value ;
  int tmp ;
  register char *sp ;
  char quote ;
  char *tmp___0 ;

  {
#line 21
  if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 22
    sourceptr = source;
  }
#line 24
  if ((unsigned long )sourceptr == (unsigned long )((void *)0)) {
#line 25
    return ((char *)((void *)0));
  } else
#line 24
  if ((int )*sourceptr == 0) {
#line 25
    return ((char *)((void *)0));
  }
  {
#line 27
  tmp = strspn(sourceptr, keys);
#line 27
  sourceptr += tmp;
  }
#line 29
  if ((int )*sourceptr == 0) {
#line 30
    return ((char *)((void *)0));
  }
#line 32
  if (flag) {
#line 33
    if ((int )*sourceptr == 34) {
#line 33
      goto _L;
    } else
#line 33
    if ((int )*sourceptr == 39) {
      _L: /* CIL Label */ 
#line 35
      tmp___0 = sourceptr;
#line 35
      sourceptr ++;
#line 35
      quote = *tmp___0;
#line 37
      sp = sourceptr;
      {
#line 37
      while (1) {
        while_continue: /* CIL Label */ ;
#line 37
        if ((int )*sp != 0) {
#line 37
          if (! ((int )*sp != (int )quote)) {
#line 37
            goto while_break;
          }
        } else {
#line 37
          goto while_break;
        }
#line 38
        if ((int )*sp == 92) {
#line 38
          sp ++;
        }
#line 37
        sp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 41
      return_value = sourceptr;
#line 42
      sourceptr = sp;
#line 43
      if ((int )*sourceptr != 0) {
#line 43
        sourceptr ++;
      }
#line 44
      *sp = (char )'\000';
#line 46
      return (return_value);
    }
  }
  {
#line 49
  last_ch = (int )strcspn(sourceptr, keys);
#line 51
  return_value = sourceptr;
#line 53
  sourceptr += last_ch;
  }
#line 55
  if ((int )*sourceptr != 0) {
#line 56
    sourceptr ++;
  }
#line 58
  *(return_value + last_ch) = (char )'\000';
#line 60
  return (return_value);
}
}
