/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 50 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct WordData {
   int index ;
   uint16_t phone ;
   char word[7] ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct PhraseData {
   char phrase[149] ;
   int freq ;
   uint16_t phone[12] ;
};
#line 71 "../../include/internal/chewing-private.h"
struct __anonstruct_TreeType_33 {
   uint16_t phone_id ;
   int phrase_id ;
   int child_begin ;
   int child_end ;
};
#line 71 "../../include/internal/chewing-private.h"
typedef struct __anonstruct_TreeType_33 TreeType;
#line 47 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
typedef int int32;
#line 50
struct _tLISTNODE;
#line 52 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
struct _tNODE {
   struct _tLISTNODE *childList ;
   uint16_t key ;
   int32 phraseno ;
   int32 nodeno ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
typedef struct _tNODE NODE;
#line 58 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
struct _tLISTNODE {
   struct _tNODE *pNode ;
   struct _tLISTNODE *next ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
typedef struct _tLISTNODE LISTNODE;
#line 44 "../src/porting_layer/include/sys/plat_posix.h"
struct plat_mmap {
   int fd ;
   void *address ;
   size_t sizet ;
   int fAccessAttr ;
};
#line 44 "../src/porting_layer/include/sys/plat_posix.h"
typedef struct plat_mmap plat_mmap;
#line 70 "../include/global.h"
struct __anonstruct_ChewingConfigData_23 {
   int candPerPage ;
   int maxChiSymbolLen ;
   int selKey[10] ;
   int bAddPhraseForward ;
   int bSpaceAsSelection ;
   int bEscCleanAllBuf ;
   int bAutoShiftCur ;
   int bEasySymbolInput ;
   int bPhraseChoiceRearward ;
   int hsuSelKeyType ;
};
#line 70 "../include/global.h"
typedef struct __anonstruct_ChewingConfigData_23 ChewingConfigData;
#line 83 "../include/global.h"
struct __anonstruct_IntervalType_24 {
   int from ;
   int to ;
};
#line 83 "../include/global.h"
typedef struct __anonstruct_IntervalType_24 IntervalType;
#line 66 "../include/internal/chewing-private.h"
union __anonunion_wch_t_25 {
   unsigned char s[7] ;
   uint16_t wch ;
};
#line 66 "../include/internal/chewing-private.h"
typedef union __anonunion_wch_t_25 wch_t;
#line 77 "../include/internal/chewing-private.h"
struct __anonstruct_PhrasingOutput_27 {
   char chiBuf[301] ;
   IntervalType dispInterval[1275] ;
   int nDispInterval ;
   int nNumCut ;
};
#line 77 "../include/internal/chewing-private.h"
typedef struct __anonstruct_PhrasingOutput_27 PhrasingOutput;
#line 84 "../include/internal/chewing-private.h"
struct __anonstruct_PinYinData_28 {
   int type ;
   char keySeq[10] ;
};
#line 84 "../include/internal/chewing-private.h"
typedef struct __anonstruct_PinYinData_28 PinYinData;
#line 89 "../include/internal/chewing-private.h"
struct __anonstruct_ZuinData_29 {
   int kbtype ;
   int pho_inx[4] ;
   int pho_inx_alt[4] ;
   uint16_t phone ;
   uint16_t phoneAlt ;
   PinYinData pinYinData ;
};
#line 89 "../include/internal/chewing-private.h"
typedef struct __anonstruct_ZuinData_29 ZuinData;
#line 98 "../include/internal/chewing-private.h"
struct __anonstruct_avail_31 {
   int len ;
   int id ;
};
#line 98 "../include/internal/chewing-private.h"
struct __anonstruct_AvailInfo_30 {
   struct __anonstruct_avail_31 avail[11] ;
   int nAvail ;
   int currentAvail ;
};
#line 98 "../include/internal/chewing-private.h"
typedef struct __anonstruct_AvailInfo_30 AvailInfo;
#line 115 "../include/internal/chewing-private.h"
struct __anonstruct_ChoiceInfo_32 {
   int nPage ;
   int pageNo ;
   int nChoicePerPage ;
   char totalChoiceStr[567][67] ;
   int nTotalChoice ;
   int oldChiSymbolCursor ;
   int isSymbol ;
};
#line 115 "../include/internal/chewing-private.h"
typedef struct __anonstruct_ChoiceInfo_32 ChoiceInfo;
#line 131 "../include/internal/chewing-private.h"
struct _SymbolEntry {
   int nSymbols ;
   char category[67] ;
   char symbols[][7] ;
};
#line 131 "../include/internal/chewing-private.h"
typedef struct _SymbolEntry SymbolEntry;
#line 149
struct tag_HASH_ITEM;
#line 149
struct keymap;
#line 149 "../include/internal/chewing-private.h"
struct __anonstruct_ChewingStaticData_33 {
   TreeType *tree ;
   size_t tree_size ;
   plat_mmap tree_mmap ;
   uint16_t *arrPhone ;
   int *char_begin ;
   size_t phone_num ;
   void *char_ ;
   void *char_cur_pos ;
   int char_end_pos ;
   plat_mmap char_mmap ;
   plat_mmap char_begin_mmap ;
   plat_mmap char_phone_mmap ;
   int *dict_begin ;
   void *dict_cur_pos ;
   int dict_end_pos ;
   void *dict ;
   plat_mmap dict_mmap ;
   plat_mmap index_mmap ;
   int chewing_lifetime ;
   char hashfilename[200] ;
   struct tag_HASH_ITEM *hashtable[1 << 14] ;
   unsigned int n_symbol_entry ;
   SymbolEntry **symbol_table ;
   char *g_easy_symbol_value[36] ;
   int g_easy_symbol_num[36] ;
   struct keymap *hanyuInitialsMap ;
   struct keymap *hanyuFinalsMap ;
   int HANYU_INITIALS ;
   int HANYU_FINALS ;
};
#line 149 "../include/internal/chewing-private.h"
typedef struct __anonstruct_ChewingStaticData_33 ChewingStaticData;
#line 203 "../include/internal/chewing-private.h"
struct tag_ChewingData {
   AvailInfo availInfo ;
   ChoiceInfo choiceInfo ;
   PhrasingOutput phrOut ;
   ZuinData zuinData ;
   ChewingConfigData config ;
   wch_t chiSymbolBuf[50] ;
   int chiSymbolCursor ;
   int chiSymbolBufLen ;
   int PointStart ;
   int PointEnd ;
   wch_t showMsg[50] ;
   int showMsgLen ;
   uint16_t phoneSeq[50] ;
   uint16_t phoneSeqAlt[50] ;
   int nPhoneSeq ;
   char selectStr[50][301] ;
   IntervalType selectInterval[50] ;
   int nSelect ;
   IntervalType preferInterval[1275] ;
   int nPrefer ;
   int bUserArrCnnct[51] ;
   int bUserArrBrkpt[51] ;
   int bArrBrkpt[51] ;
   int bSymbolArrBrkpt[51] ;
   int bChiSym ;
   int bSelect ;
   int bFirstKey ;
   int bFullShape ;
   char symbolKeyBuf[50] ;
   struct tag_HASH_ITEM *prev_userphrase ;
   ChewingStaticData static_data ;
   void (*logger)(void *data , int level , char const   *fmt  , ...) ;
   void *loggerData ;
};
#line 203 "../include/internal/chewing-private.h"
typedef struct tag_ChewingData ChewingData;
#line 289 "../include/internal/chewing-private.h"
struct __anonstruct_Phrase_35 {
   char phrase[67] ;
   int freq ;
};
#line 289 "../include/internal/chewing-private.h"
typedef struct __anonstruct_Phrase_35 Phrase;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 38 "../include/internal/userphrase-private.h"
struct tag_UserPhraseData {
   uint16_t *phoneSeq ;
   char *wordSeq ;
   int userfreq ;
   int recentTime ;
   int origfreq ;
   int maxfreq ;
};
#line 38 "../include/internal/userphrase-private.h"
typedef struct tag_UserPhraseData UserPhraseData;
#line 27 "../include/internal/hash-private.h"
struct tag_HASH_ITEM {
   int item_index ;
   UserPhraseData data ;
   struct tag_HASH_ITEM *next ;
};
#line 27 "../include/internal/hash-private.h"
typedef struct tag_HASH_ITEM HASH_ITEM;
#line 241 "../include/internal/chewing-private.h"
struct __anonstruct_ChewingOutput_37 {
   wch_t chiSymbolBuf[50] ;
   int chiSymbolBufLen ;
   long chiSymbolCursor ;
   long PointStart ;
   long PointEnd ;
   wch_t zuinBuf[4] ;
   IntervalType dispInterval[1275] ;
   int nDispInterval ;
   int dispBrkpt[51] ;
   wch_t commitStr[50] ;
   int nCommitStr ;
   ChoiceInfo *pci ;
   int bChiSym ;
   int selKey[10] ;
   int keystrokeRtn ;
   int bShowMsg ;
   wch_t showMsg[50] ;
   int showMsgLen ;
};
#line 241 "../include/internal/chewing-private.h"
typedef struct __anonstruct_ChewingOutput_37 ChewingOutput;
#line 21 "../include/internal/char-private.h"
struct __anonstruct_Word_33 {
   char word[7] ;
};
#line 21 "../include/internal/char-private.h"
typedef struct __anonstruct_Word_33 Word;
#line 24 "../include/internal/pinyin-private.h"
struct keymap {
   char pinyin[7] ;
   char zuin[4] ;
};
#line 92 "../include/global.h"
struct _ChewingContext;
#line 92 "../include/global.h"
typedef struct _ChewingContext ChewingContext;
#line 277 "../include/internal/chewing-private.h"
struct _ChewingContext {
   ChewingData *data ;
   ChewingOutput *output ;
   int cand_no ;
   int it_no ;
   int kb_no ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
struct __anonstruct_PhraseIntervalType_44 {
   int from ;
   int to ;
   int pho_id ;
   int source ;
   Phrase *p_phr ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
typedef struct __anonstruct_PhraseIntervalType_44 PhraseIntervalType;
#line 43 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
struct tagRecordNode {
   int *arrIndex ;
   int nInter ;
   int score ;
   struct tagRecordNode *next ;
   int nMatchCnnct ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
typedef struct tagRecordNode RecordNode;
#line 50 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
struct __anonstruct_TreeDataType_45 {
   int leftmost[51] ;
   char graph[51][51] ;
   PhraseIntervalType interval[1275] ;
   int nInterval ;
   RecordNode *phList ;
   int nPhListLen ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
typedef struct __anonstruct_TreeDataType_45 TreeDataType;
#line 325
enum __anonenum_UsedPhraseMode_46 {
    USED_PHRASE_NONE = 0,
    USED_PHRASE_USER = 1,
    USED_PHRASE_DICT = 2
} ;
#line 325 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
typedef enum __anonenum_UsedPhraseMode_46 UsedPhraseMode;
#line 28 "../include/internal/pinyin-private.h"
typedef struct keymap keymap;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 17 "../../include/internal/chewing-utf8-util.h"
int ueStrLen(char const   *str ) ;
#line 35
int ueStrNCpy(char *dest , char const   *src , size_t n , int end ) ;
#line 38
char *ueStrSeek(char *src , size_t n ) ;
#line 24 "../../include/internal/key2pho-private.h"
uint16_t UintFromPhone(char const   *zhuin ) ;
#line 26
int PhoneFromKey(char *pho , char const   *inputkey , int kbtype , int searchTimes ) ;
#line 27
int PhoneFromUint(char *phone , size_t phone_len , uint16_t phone_num ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
char const   USAGE[339]  = 
#line 35 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
  {      (char const   )'u',      (char const   )'s',      (char const   )'a',      (char const   )'g', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'%', 
        (char const   )'s',      (char const   )' ',      (char const   )'<',      (char const   )'p', 
        (char const   )'h',      (char const   )'o',      (char const   )'n',      (char const   )'e', 
        (char const   )'.',      (char const   )'c',      (char const   )'i',      (char const   )'n', 
        (char const   )'>',      (char const   )' ',      (char const   )'<',      (char const   )'t', 
        (char const   )'s',      (char const   )'i',      (char const   )'.',      (char const   )'s', 
        (char const   )'r',      (char const   )'c',      (char const   )'>',      (char const   )'\n', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'m', 
        (char const   )' ',      (char const   )'c',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'t',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'l', 
        (char const   )'l',      (char const   )'o',      (char const   )'w',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'n', 
        (char const   )'e',      (char const   )'w',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )':',      (char const   )'\n',      (char const   )'*',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'_',      (char const   )'i', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'x', 
        (char const   )'_',      (char const   )'p',      (char const   )'h',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )'.',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'\n',      (char const   )'\t', 
        (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'x',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'w',      (char const   )'o',      (char const   )'r', 
        (char const   )'d',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'(', 
        (char const   )'p',      (char const   )'h',      (char const   )'o',      (char const   )'n', 
        (char const   )'e',      (char const   )' ',      (char const   )'-',      (char const   )'>', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )')',      (char const   )'\n', 
        (char const   )'*',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'_',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )'_',      (char const   )'b', 
        (char const   )'e',      (char const   )'g',      (char const   )'i',      (char const   )'n', 
        (char const   )'.',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'i',      (char const   )'n', 
        (char const   )'d',      (char const   )'e',      (char const   )'x',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'w', 
        (char const   )'o',      (char const   )'r',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'(',      (char const   )'i',      (char const   )'n', 
        (char const   )'d',      (char const   )'e',      (char const   )'x',      (char const   )' ', 
        (char const   )'-',      (char const   )'>',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )'f',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )')',      (char const   )'\n',      (char const   )'*', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'_', 
        (char const   )'f',      (char const   )'r',      (char const   )'e',      (char const   )'q', 
        (char const   )'.',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'m',      (char const   )'a', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'w', 
        (char const   )'o',      (char const   )'r',      (char const   )'d',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'\n',      (char const   )'*',      (char const   )' ',      (char const   )'p', 
        (char const   )'h',      (char const   )'_',      (char const   )'i',      (char const   )'n', 
        (char const   )'d',      (char const   )'e',      (char const   )'x',      (char const   )'.', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'\n', 
        (char const   )'\t',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'p',      (char const   )'h', 
        (char const   )'r',      (char const   )'a',      (char const   )'s',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'\n',      (char const   )'*',      (char const   )' ', 
        (char const   )'d',      (char const   )'i',      (char const   )'c',      (char const   )'t', 
        (char const   )'.',      (char const   )'d',      (char const   )'a',      (char const   )'t', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'m',      (char const   )'a', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'p', 
        (char const   )'h',      (char const   )'r',      (char const   )'a',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'l',      (char const   )'e',      (char const   )'\n',      (char const   )'*', 
        (char const   )' ',      (char const   )'p',      (char const   )'h',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )'i',      (char const   )'d', 
        (char const   )'.',      (char const   )'d',      (char const   )'i',      (char const   )'c', 
        (char const   )'\n',      (char const   )'\t',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'e',      (char const   )'d',      (char const   )'i',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'k',      (char const   )'e', 
        (char const   )'_',      (char const   )'t',      (char const   )'r',      (char const   )'e', 
        (char const   )'e',      (char const   )'\n',      (char const   )'\000'};
#line 62 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct WordData word_data[60000]  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int num_word_data  =    0;
#line 65 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct PhraseData phrase_data[420000]  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int num_phrase_data  =    0;
#line 68 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct PhraseData  const  EXCEPTION_PHRASE[9]  = 
#line 68
  {      {{(char )'\345', (char )'\245', (char )'\275', (char )'\350', (char )'\220',
       (char )'\212', (char )'\345', (char )'\241', (char )'\242', (char )'\000'},
      0, {(uint16_t )5691, (uint16_t )4138, (uint16_t )256}}, 
        {{(char )'\346', (char )'\210', (char )'\220', (char )'\346', (char )'\227',
       (char )'\245', (char )'\345', (char )'\256', (char )'\266', (char )'\000'},
      0, {(uint16_t )8290, (uint16_t )9220, (uint16_t )6281}}, 
        {{(char )'\344', (char )'\277', (char )'\276', (char )'\345', (char )'\200',
       (char )'\252', (char )'\000'}, 0, {(uint16_t )644, (uint16_t )3716}}, 
        {{(char )'\346', (char )'\217', (char )'\251', (char )'\346', (char )'\262',
       (char )'\271', (char )'\000'}, 0, {(uint16_t )5128, (uint16_t )194}}, 
        {{(char )'\346', (char )'\225', (char )'\201', (char )'\346', (char )'\225',
       (char )'\252', (char )'\000'}, 0, {(uint16_t )2760, (uint16_t )2833}}, 
        {{(char )'\344', (char )'\270', (char )'\200', (char )'\351', (char )'\252',
       (char )'\250', (char )'\347', (char )'\242', (char )'\214', (char )'\000'},
      0, {(uint16_t )128, (uint16_t )4866, (uint16_t )4353}}, 
        {{(char )'\351', (char )'\202', (char )'\213', (char )'\351', (char )'\201',
       (char )'\242', (char )'\000'}, 0, {(uint16_t )4106, (uint16_t )3081}}, 
        {{(char )'\346', (char )'\272', (char )'\234', (char )'\351', (char )'\201',
       (char )'\224', (char )'\000'}, 0, {(uint16_t )4292, (uint16_t )2569}}, 
        {{(char )'\351', (char )'\201', (char )'\233', (char )'\351', (char )'\201',
       (char )'\224', (char )'\000'}, 0, {(uint16_t )4292, (uint16_t )2569}}};
#line 86 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
struct WordData  const  EXCEPTION_WORD[3]  = {      {0, (uint16_t )11025, {(char )'\345', (char )'\227', (char )'\246', (char )'\000'}}, 
        {0,
      (uint16_t )521, {(char )'\345', (char )'\267', (char )'\264', (char )'\000'}}, 
        {0,
      (uint16_t )5905, {(char )'\344', (char )'\274', (char )'\231', (char )'\000'}}};
#line 92 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void strip(char *line ) 
{ 
  char *end ;
  size_t i ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 98
  i = (size_t )0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    tmp = strlen((char const   *)line);
    }
#line 98
    if (! (i < tmp)) {
#line 98
      goto while_break;
    }
#line 99
    if ((int )*(line + i) == 35) {
#line 100
      *(line + i) = (char)0;
#line 101
      goto while_break;
    }
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 106
  tmp___0 = strlen((char const   *)line);
#line 106
  end = (line + tmp___0) - 1;
  }
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if ((unsigned long )end >= (unsigned long )line) {
      {
#line 107
      tmp___1 = __ctype_b_loc();
      }
#line 107
      if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*end)) & 8192)) {
#line 107
        goto while_break___0;
      }
    } else {
#line 107
      goto while_break___0;
    }
#line 108
    *end = (char)0;
#line 109
    end --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void store_word(char const   *line , int const   line_num ) 
{ 
  char phone_buf[25] ;
  char key_buf[5] ;
  char buf[1024] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 119
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)line, sizeof(buf));
#line 121
  strip(buf);
#line 122
  tmp = strlen((char const   *)(buf));
  }
#line 122
  if (tmp == 0UL) {
#line 123
    return;
  }
#line 125
  if (num_word_data >= 60000) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Need to increase MAX_WORD_DATA to process\n");
#line 127
    exit(-1);
    }
  }
  {
#line 133
  sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%4[^ ] %6[^ ]",
         key_buf, word_data[num_word_data].word);
#line 136
  tmp___0 = strlen((char const   *)(key_buf));
  }
#line 136
  if (tmp___0 > 4UL) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading line %d, `%s\'\n",
            line_num, line);
#line 138
    exit(-1);
    }
  }
  {
#line 140
  PhoneFromKey(phone_buf, (char const   *)(key_buf), 0, 1);
#line 141
  word_data[num_word_data].phone = UintFromPhone((char const   *)(phone_buf));
#line 142
  word_data[num_word_data].index = num_word_data;
#line 143
  num_word_data ++;
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int compare_word_by_phone(void const   *x , void const   *y ) 
{ 
  struct WordData  const  *a ;
  struct WordData  const  *b ;

  {
#line 148
  a = (struct WordData  const  *)((struct WordData *)x);
#line 149
  b = (struct WordData  const  *)((struct WordData *)y);
#line 151
  if ((int const   )a->phone != (int const   )b->phone) {
#line 152
    return ((int )((int const   )a->phone - (int const   )b->phone));
  }
#line 155
  return ((int )(a->index - b->index));
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int compare_word(void const   *x , void const   *y ) 
{ 
  struct WordData  const  *a ;
  struct WordData  const  *b ;
  int ret ;

  {
  {
#line 160
  a = (struct WordData  const  *)x;
#line 161
  b = (struct WordData  const  *)y;
#line 164
  ret = strcmp((char const   *)(a->word), (char const   *)(b->word));
  }
#line 165
  if (ret != 0) {
#line 166
    return (ret);
  }
#line 168
  if ((int const   )a->phone != (int const   )b->phone) {
#line 169
    return ((int )((int const   )a->phone - (int const   )b->phone));
  }
#line 171
  return (0);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int compare_word_no_duplicated(void const   *x , void const   *y ) 
{ 
  int ret ;
  struct WordData  const  *a ;

  {
  {
#line 178
  ret = compare_word(x, y);
  }
#line 179
  if (! ret) {
    {
#line 180
    a = (struct WordData  const  *)x;
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Duplicated word found (`%s\', %d).\n",
            a->word, (int const   )a->phone);
#line 182
    exit(-1);
    }
  }
#line 185
  return (ret);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void read_phone_cin(char const   *filename ) 
{ 
  FILE *phone_cin ;
  char buf[1024] ;
  char *ret ;
  int line_num ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 193
  line_num = 0;
#line 195
  phone_cin = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 196
  if (! phone_cin) {
    {
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening the file %s\n",
            filename);
#line 198
    exit(-1);
    }
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    ret = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)phone_cin);
#line 204
    line_num ++;
    }
#line 205
    if (! ret) {
      {
#line 206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find %s\n",
              "%chardef  begin");
#line 207
      exit(-1);
      }
    }
    {
#line 210
    tmp = strlen("%chardef  begin");
#line 210
    tmp___0 = strncmp((char const   *)(buf), "%chardef  begin", tmp);
    }
#line 210
    if (tmp___0 == 0) {
#line 211
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 217
    ret = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)phone_cin);
#line 218
    line_num ++;
    }
#line 219
    if (! ret) {
#line 220
      goto while_break___0;
    } else
#line 219
    if ((int )buf[0] == 37) {
#line 220
      goto while_break___0;
    }
    {
#line 222
    store_word((char const   *)(buf), (int const   )line_num);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 224
  fclose(phone_cin);
#line 226
  qsort((void *)(word_data), (size_t )num_word_data, sizeof(word_data[0]), & compare_word_by_phone);
  }
#line 228
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void write_word_data(void) 
{ 
  FILE *chewing_file ;
  FILE *char_file ;
  FILE *index_begin_file ;
  FILE *index_phone_file ;
  unsigned char size ;
  int i ;
  uint16_t previous_phone ;
  int phone_num ;
  int pos ;
  long tmp ;
  size_t tmp___0 ;
  long tmp___1 ;

  {
  {
#line 248
  chewing_file = fopen((char const   */* __restrict  */)"chewing-definition.h", (char const   */* __restrict  */)"w");
#line 250
  index_begin_file = fopen((char const   */* __restrict  */)"ch_index_begin.dat",
                           (char const   */* __restrict  */)"wb");
#line 251
  index_phone_file = fopen((char const   */* __restrict  */)"ch_index_phone.dat",
                           (char const   */* __restrict  */)"wb");
#line 252
  char_file = fopen((char const   */* __restrict  */)"us_freq.dat", (char const   */* __restrict  */)"wb");
  }
#line 254
  if (chewing_file) {
#line 254
    if (index_begin_file) {
#line 254
      if (index_phone_file) {
#line 254
        if (! char_file) {
          {
#line 255
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 256
          exit(-1);
          }
        }
      } else {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 256
        exit(-1);
        }
      }
    } else {
      {
#line 255
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 256
      exit(-1);
      }
    }
  } else {
    {
#line 255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 256
    exit(-1);
    }
  }
#line 267
  previous_phone = (uint16_t )0;
#line 268
  phone_num = 0;
#line 269
  i = 0;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (i < num_word_data)) {
#line 269
      goto while_break;
    }
#line 270
    if ((int )word_data[i].phone != (int )previous_phone) {
      {
#line 271
      previous_phone = word_data[i].phone;
#line 272
      tmp = ftell(char_file);
#line 272
      pos = (int )tmp;
#line 274
      fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1, (FILE */* __restrict  */)index_begin_file);
#line 275
      fwrite((void const   */* __restrict  */)(& previous_phone), sizeof(previous_phone),
             (size_t )1, (FILE */* __restrict  */)index_phone_file);
#line 279
      phone_num ++;
      }
    }
    {
#line 283
    tmp___0 = strlen((char const   *)(word_data[i].word));
#line 283
    size = (unsigned char )tmp___0;
#line 284
    fwrite((void const   */* __restrict  */)(& size), sizeof(size), (size_t )1, (FILE */* __restrict  */)char_file);
#line 285
    fwrite((void const   */* __restrict  */)(word_data[i].word), (size_t )size, (size_t )1,
           (FILE */* __restrict  */)char_file);
#line 269
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 290
  tmp___1 = ftell(char_file);
#line 290
  pos = (int )tmp___1;
#line 292
  fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1, (FILE */* __restrict  */)index_begin_file);
#line 293
  previous_phone = (uint16_t )0;
#line 294
  fwrite((void const   */* __restrict  */)(& previous_phone), sizeof(previous_phone),
         (size_t )1, (FILE */* __restrict  */)index_phone_file);
#line 298
  fprintf((FILE */* __restrict  */)chewing_file, (char const   */* __restrict  */)"#define PHONE_NUM (%d)\n",
          phone_num);
#line 300
  fclose(char_file);
#line 302
  fclose(index_phone_file);
#line 303
  fclose(index_begin_file);
#line 307
  fclose(chewing_file);
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void sort_word_for_dictionary(void) 
{ 


  {
  {
#line 312
  qsort((void *)(word_data), (size_t )num_word_data, sizeof(word_data[0]), & compare_word_no_duplicated);
  }
#line 313
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int is_exception_phrase(struct PhraseData *phrase , int pos ) 
{ 
  size_t i ;
  char word[7] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char previous[7] ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 319
  tmp = ueStrSeek(phrase->phrase, (size_t )pos);
#line 319
  ueStrNCpy(word, (char const   *)tmp, (size_t )1, 1);
#line 324
  i = (size_t )0;
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < sizeof(EXCEPTION_PHRASE) / sizeof(EXCEPTION_PHRASE[0]))) {
#line 324
      goto while_break;
    }
    {
#line 325
    tmp___0 = strcmp((char const   *)(phrase->phrase), (char const   *)(EXCEPTION_PHRASE[i].phrase));
    }
#line 325
    if (tmp___0 == 0) {
      {
#line 325
      tmp___1 = memcmp((void const   *)(phrase->phone), (void const   *)(EXCEPTION_PHRASE[i].phone),
                       sizeof(phrase->phone));
      }
#line 325
      if (tmp___1 == 0) {
#line 327
        return (1);
      }
    }
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  i = (size_t )0;
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 334
    if (! (i < sizeof(EXCEPTION_WORD) / sizeof(EXCEPTION_WORD[0]))) {
#line 334
      goto while_break___0;
    }
    {
#line 335
    tmp___2 = strcmp((char const   *)(word), (char const   *)(EXCEPTION_WORD[i].word));
    }
#line 335
    if (tmp___2 == 0) {
#line 335
      if ((int )phrase->phone[pos] == (int )EXCEPTION_WORD[i].phone) {
#line 337
        return (1);
      }
    }
#line 334
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 347
  if (pos > 0) {
    {
#line 350
    tmp___3 = ueStrSeek(phrase->phrase, (size_t )(pos - 1));
#line 350
    ueStrNCpy(previous, (char const   *)tmp___3, (size_t )1, 1);
#line 352
    tmp___4 = strcmp((char const   *)(previous), (char const   *)(word));
    }
#line 352
    if (tmp___4 == 0) {
#line 353
      if ((((int )phrase->phone[pos - 1] & -8) | 1) == (int )phrase->phone[pos]) {
#line 354
        return (1);
      }
    }
  }
#line 359
  return (0);
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void store_phrase(char const   *line , int line_num ) 
{ 
  char DELIM[4] ;
  char buf[1024] ;
  char *phrase ;
  char *freq ;
  char *bopomofo ;
  size_t phrase_len ;
  size_t i ;
  size_t j ;
  struct WordData word ;
  char bopomofo_buf[25] ;
  size_t tmp ;
  int *tmp___0 ;
  long tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 364
  DELIM[0] = (char )' ';
#line 364
  DELIM[1] = (char )'\t';
#line 364
  DELIM[2] = (char )'\n';
#line 364
  DELIM[3] = (char )'\000';
#line 375
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)line, sizeof(buf));
#line 377
  strip(buf);
#line 378
  tmp = strlen((char const   *)(buf));
  }
#line 378
  if (tmp == 0UL) {
#line 379
    return;
  }
#line 381
  if (num_phrase_data >= 420000) {
    {
#line 382
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Need to increase MAX_PHRASE_DATA to process\n");
#line 383
    exit(-1);
    }
  }
  {
#line 387
  phrase = strtok((char */* __restrict  */)(buf), (char const   */* __restrict  */)(DELIM));
  }
#line 388
  if (! phrase) {
    {
#line 389
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading line %d, `%s\'\n",
            line_num, line);
#line 390
    exit(-1);
    }
  }
  {
#line 392
  strncpy((char */* __restrict  */)(phrase_data[num_phrase_data].phrase), (char const   */* __restrict  */)phrase,
          sizeof(phrase_data[0].phrase));
#line 395
  freq = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(DELIM));
  }
#line 396
  if (! freq) {
    {
#line 397
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading line %d, `%s\'\n",
            line_num, line);
#line 398
    exit(-1);
    }
  }
  {
#line 401
  tmp___0 = __errno_location();
#line 401
  *tmp___0 = 0;
#line 402
  tmp___1 = strtol((char const   */* __restrict  */)freq, (char **/* __restrict  */)0,
                   0);
#line 402
  phrase_data[num_phrase_data].freq = (int )tmp___1;
#line 403
  tmp___2 = __errno_location();
  }
#line 403
  if (*tmp___2) {
    {
#line 404
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading frequency `%s\' in line %d, `%s\'\n",
            freq, line_num, line);
#line 405
    exit(-1);
    }
  }
  {
#line 409
  bopomofo = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(DELIM));
#line 409
  phrase_len = (size_t )0;
  }
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (bopomofo) {
#line 409
      if (! (phrase_len < 11UL)) {
#line 409
        goto while_break;
      }
    } else {
#line 409
      goto while_break;
    }
    {
#line 413
    phrase_data[num_phrase_data].phone[phrase_len] = UintFromPhone((char const   *)bopomofo);
    }
#line 414
    if ((int )phrase_data[num_phrase_data].phone[phrase_len] == 0) {
      {
#line 415
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading bopomofo `%s\' in line %d, `%s\'\n",
              bopomofo, line_num, line);
#line 416
      exit(-1);
      }
    }
    {
#line 409
    bopomofo = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)(DELIM));
#line 409
    phrase_len ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  if (bopomofo) {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phrase `%s\' too long in line %d\n",
            phrase, line_num);
    }
  }
  {
#line 424
  tmp___3 = ueStrLen((char const   *)(phrase_data[num_phrase_data].phrase));
  }
#line 424
  if ((size_t )tmp___3 != phrase_len) {
    {
#line 425
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Phrase length and bopomofo length mismatch in line %d, `%s\'\n",
            line_num, line);
#line 426
    exit(-1);
    }
  }
#line 430
  i = (size_t )0;
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 430
    if (! (i < phrase_len)) {
#line 430
      goto while_break___0;
    }
    {
#line 431
    tmp___4 = ueStrSeek(phrase_data[num_phrase_data].phrase, i);
#line 431
    ueStrNCpy(word.word, (char const   *)tmp___4, (size_t )1, 1);
#line 432
    word.phone = phrase_data[num_phrase_data].phone[i];
#line 434
    tmp___6 = bsearch((void const   *)(& word), (void const   *)(word_data), (size_t )num_word_data,
                      sizeof(word), & compare_word);
    }
#line 434
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
      {
#line 434
      tmp___7 = is_exception_phrase(& phrase_data[num_phrase_data], (int )i);
      }
#line 434
      if (! tmp___7) {
        {
#line 437
        PhoneFromUint(bopomofo_buf, sizeof(bopomofo_buf), word.phone);
#line 439
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in phrase `%s\'. Word `%s\' has no phone %d (%s) in line %d\n",
                phrase_data[num_phrase_data].phrase, word.word, (int )word.phone,
                bopomofo_buf, line_num);
#line 440
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tAdd the following struct to EXCEPTION_PHRASE if this is good phrase\n\t{ \"");
#line 441
        j = (size_t )0;
        }
        {
#line 441
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 441
          tmp___5 = strlen((char const   *)(phrase_data[num_phrase_data].phrase));
          }
#line 441
          if (! (j < tmp___5)) {
#line 441
            goto while_break___1;
          }
          {
#line 442
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\\x%02X",
                  (int )((unsigned char )phrase_data[num_phrase_data].phrase[j]));
#line 441
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 444
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\" /* %s */ , 0, { %d",
                phrase_data[num_phrase_data].phrase, (int )phrase_data[num_phrase_data].phone[0]);
#line 445
        j = (size_t )1;
        }
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (j < phrase_len)) {
#line 445
            goto while_break___2;
          }
          {
#line 446
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %d",
                  (int )phrase_data[num_phrase_data].phone[j]);
#line 445
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 448
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" } /* ");
#line 449
        j = (size_t )0;
        }
        {
#line 449
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 449
          if (! (j < phrase_len)) {
#line 449
            goto while_break___3;
          }
          {
#line 450
          PhoneFromUint(bopomofo_buf, sizeof(bopomofo_buf), phrase_data[num_phrase_data].phone[j]);
#line 451
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                  bopomofo_buf);
#line 449
          j ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 453
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"*/ },\n");
#line 454
        exit(-1);
        }
      }
    }
#line 430
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  num_phrase_data ++;
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int compare_phrase(void const   *x , void const   *y ) 
{ 
  struct PhraseData  const  *a ;
  struct PhraseData  const  *b ;
  int cmp ;
  size_t i ;
  uint16_t __constr_expr_0[12] ;
  int tmp ;

  {
#line 463
  a = (struct PhraseData  const  *)x;
#line 464
  b = (struct PhraseData  const  *)y;
#line 468
  i = (size_t )0;
  {
#line 468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (! (i < sizeof(a->phone) / sizeof(__constr_expr_0[0]))) {
#line 468
      goto while_break;
    }
#line 469
    cmp = (int )a->phone[i] - (int )b->phone[i];
#line 470
    if (cmp) {
#line 471
      return (cmp);
    }
#line 468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  tmp = strcmp((char const   *)(a->phrase), (char const   *)(b->phrase));
  }
#line 474
  if (! tmp) {
    {
#line 475
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Duplicated phrase `%s\' found.\n",
            a->phrase);
#line 476
    exit(-1);
    }
  }
#line 485
  return ((int )(b->freq - a->freq));
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void read_tsi_src(char const   *filename ) 
{ 
  FILE *tsi_src ;
  char buf[1024] ;
  int line_num ;
  char *tmp ;

  {
  {
#line 492
  line_num = 0;
#line 494
  tsi_src = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 495
  if (! tsi_src) {
    {
#line 496
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening the file %s\n",
            filename);
#line 497
    exit(-1);
    }
  }
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 500
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)tsi_src);
    }
#line 500
    if (! tmp) {
#line 500
      goto while_break;
    }
    {
#line 501
    line_num ++;
#line 502
    store_phrase((char const   *)(buf), line_num);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  qsort((void *)(phrase_data), (size_t )num_phrase_data, sizeof(phrase_data[0]), & compare_phrase);
  }
#line 506
  return;
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int compare_phone_in_phrase(int x , int y ) 
{ 
  int tmp ;

  {
  {
#line 510
  tmp = memcmp((void const   *)(phrase_data[x].phone), (void const   *)(phrase_data[y].phone),
               sizeof(phrase_data[0].phone));
  }
#line 510
  return (tmp);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
void write_phrase_data(void) 
{ 
  FILE *dict_file ;
  FILE *ph_index_file ;
  FILE *phoneid_file ;
  int i ;
  int j ;
  int pos ;
  unsigned char size ;
  long tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
  {
#line 526
  dict_file = fopen((char const   */* __restrict  */)"dict.dat", (char const   */* __restrict  */)"wb");
#line 527
  ph_index_file = fopen((char const   */* __restrict  */)"ph_index.dat", (char const   */* __restrict  */)"wb");
#line 532
  phoneid_file = fopen((char const   */* __restrict  */)"phoneid.dic", (char const   */* __restrict  */)"w");
  }
#line 534
  if (dict_file) {
#line 534
    if (ph_index_file) {
#line 534
      if (! phoneid_file) {
        {
#line 535
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 536
        exit(-1);
        }
      }
    } else {
      {
#line 535
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 536
      exit(-1);
      }
    }
  } else {
    {
#line 535
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file.\n");
#line 536
    exit(-1);
    }
  }
#line 539
  i = 0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (i < num_phrase_data - 1)) {
#line 539
      goto while_break;
    }
#line 540
    if (i == 0) {
      {
#line 541
      tmp = ftell(dict_file);
#line 541
      pos = (int )tmp;
#line 543
      fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1, (FILE */* __restrict  */)ph_index_file);
      }
    } else {
      {
#line 540
      tmp___0 = compare_phone_in_phrase(i - 1, i);
      }
#line 540
      if (tmp___0) {
        {
#line 541
        tmp = ftell(dict_file);
#line 541
        pos = (int )tmp;
#line 543
        fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1,
               (FILE */* __restrict  */)ph_index_file);
        }
      }
    }
    {
#line 549
    tmp___1 = strlen((char const   *)(phrase_data[i].phrase));
#line 549
    size = (unsigned char )tmp___1;
#line 550
    fwrite((void const   */* __restrict  */)(& size), sizeof(size), (size_t )1, (FILE */* __restrict  */)dict_file);
#line 551
    fwrite((void const   */* __restrict  */)(phrase_data[i].phrase), (size_t )size,
           (size_t )1, (FILE */* __restrict  */)dict_file);
#line 552
    fwrite((void const   */* __restrict  */)(& phrase_data[i].freq), sizeof(phrase_data[0].freq),
           (size_t )1, (FILE */* __restrict  */)dict_file);
#line 539
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  tmp___2 = ftell(dict_file);
#line 558
  pos = (int )tmp___2;
#line 560
  fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1, (FILE */* __restrict  */)ph_index_file);
#line 561
  tmp___3 = strlen((char const   *)(phrase_data[i].phrase));
#line 561
  size = (unsigned char )tmp___3;
#line 562
  fwrite((void const   */* __restrict  */)(& size), sizeof(size), (size_t )1, (FILE */* __restrict  */)dict_file);
#line 563
  fwrite((void const   */* __restrict  */)(phrase_data[i].phrase), (size_t )size,
         (size_t )1, (FILE */* __restrict  */)dict_file);
#line 564
  fwrite((void const   */* __restrict  */)(& phrase_data[i].freq), sizeof(phrase_data[0].freq),
         (size_t )1, (FILE */* __restrict  */)dict_file);
#line 565
  tmp___4 = ftell(dict_file);
#line 565
  pos = (int )tmp___4;
#line 566
  fwrite((void const   */* __restrict  */)(& pos), sizeof(pos), (size_t )1, (FILE */* __restrict  */)ph_index_file);
#line 574
  i = 0;
  }
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 574
    if (! (i < num_phrase_data)) {
#line 574
      goto while_break___0;
    }
#line 575
    if (i > 0) {
      {
#line 575
      tmp___5 = compare_phone_in_phrase(i - 1, i);
      }
#line 575
      if (! tmp___5) {
#line 576
        goto __Cont;
      }
    }
#line 578
    j = 0;
    {
#line 578
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 578
      if (! phrase_data[i].phone[j]) {
#line 578
        goto while_break___1;
      }
      {
#line 579
      fprintf((FILE */* __restrict  */)phoneid_file, (char const   */* __restrict  */)"%hu ",
              (int )phrase_data[i].phone[j]);
#line 578
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 581
    fprintf((FILE */* __restrict  */)phoneid_file, (char const   */* __restrict  */)"0\n");
    }
    __Cont: /* CIL Label */ 
#line 574
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 585
  fclose(phoneid_file);
#line 586
  fclose(ph_index_file);
#line 587
  fclose(dict_file);
  }
#line 588
  return;
}
}
#line 590 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/sort.c"
int main(int argc , char **argv ) 
{ 


  {
#line 592
  if (argc != 3) {
    {
#line 593
    printf((char const   */* __restrict  */)(USAGE), *(argv + 0));
    }
#line 594
    return (-1);
  }
  {
#line 597
  read_phone_cin((char const   *)*(argv + 1));
#line 598
  write_word_data();
#line 600
  sort_word_for_dictionary();
#line 602
  read_tsi_src((char const   *)*(argv + 2));
#line 603
  write_phrase_data();
  }
#line 604
  return (0);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 20 "../../include/internal/chewing-utf8-util.h"
int ueBytesFromChar(unsigned char b ) ;
#line 23
int ueStrNBytes(char const   *str , int n ) ;
#line 41
char const   *ueConstStrSeek(char const   *src , size_t n ) ;
#line 50
char const   *ueStrStr(char const   *str , size_t lstr , char const   *substr , size_t lsub ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
static char const   utf8len_tab[256]  = 
#line 16 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
  {      (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )5,      (char const   )5,      (char const   )5,      (char const   )5, 
        (char const   )6,      (char const   )6,      (char const   )1,      (char const   )1};
#line 29 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
int ueStrLen(char const   *str ) 
{ 
  int length ;
  char const   *strptr ;
  int tmp ;

  {
#line 31
  length = 0;
#line 32
  strptr = str;
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;
#line 34
    if (! ((int const   )*(strptr + 0) != 0)) {
#line 34
      goto while_break;
    }
    {
#line 35
    tmp = ueBytesFromChar((unsigned char )*(strptr + 0));
#line 35
    strptr += tmp;
#line 36
    length ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return (length);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
int ueBytesFromChar(unsigned char b ) 
{ 


  {
#line 44
  return ((int )utf8len_tab[b]);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
int ueStrNBytes(char const   *str , int n ) 
{ 
  int i ;
  int len ;
  char const   *iter ;
  int tmp ;

  {
#line 50
  i = 0;
#line 50
  len = 0;
#line 51
  iter = str;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < n)) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp = ueBytesFromChar((unsigned char )*(iter + len));
#line 53
    len += tmp;
#line 52
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  return (len);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
int ueStrNCpy(char *dest , char const   *src , size_t n , int end ) 
{ 
  int len ;

  {
  {
#line 61
  len = 0;
#line 62
  len = ueStrNBytes(src, (int )n);
#line 63
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )len);
  }
#line 64
  if (end == 1) {
#line 65
    *(dest + len) = (char )'\000';
  }
#line 66
  return (len);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
char const   *ueConstStrSeek(char const   *src , size_t n ) 
{ 
  size_t i ;
  char const   *iter ;
  int tmp ;

  {
#line 71
  i = (size_t )0;
#line 72
  iter = src;
#line 73
  i = (size_t )0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < n)) {
#line 73
      goto while_break;
    }
    {
#line 74
    tmp = ueBytesFromChar((unsigned char )*(iter + 0));
#line 74
    iter += tmp;
#line 73
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (iter);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
char *ueStrSeek(char *src , size_t n ) 
{ 
  size_t i ;
  char *iter ;
  int tmp ;

  {
#line 81
  i = (size_t )0;
#line 82
  iter = src;
#line 83
  i = (size_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < n)) {
#line 83
      goto while_break;
    }
    {
#line 84
    tmp = ueBytesFromChar((unsigned char )*(iter + 0));
#line 84
    iter += tmp;
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (iter);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/chewing-utf8-util.c"
char const   *ueStrStr(char const   *str , size_t lstr , char const   *substr , size_t lsub ) 
{ 
  char const   *p ;
  size_t ub ;
  int tmp ;

  {
#line 93
  p = str;
#line 95
  if (lstr < lsub) {
#line 96
    return ((char const   *)((void *)0));
  }
#line 97
  ub = lstr - lsub;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! ((size_t )(p - str) <= ub)) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = strncmp(p, substr, lsub);
    }
#line 99
    if (! tmp) {
#line 100
      return (p);
    }
#line 98
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((char const   *)((void *)0));
}
}
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
char const   * const  zhuin_tab[4]  = {      (char const   */* const  */)"  \343\204\205\343\204\206\343\204\207\343\204\210\343\204\211\343\204\212\343\204\213\343\204\214\343\204\215\343\204\216\343\204\217\343\204\220\343\204\221\343\204\222\343\204\223\343\204\224\343\204\225\343\204\226\343\204\227\343\204\230\343\204\231",      (char const   */* const  */)"  \343\204\247\343\204\250\343\204\251",      (char const   */* const  */)"  \343\204\232\343\204\233\343\204\234\343\204\235\343\204\236\343\204\237\343\204\240\343\204\241\343\204\242\343\204\243\343\204\244\343\204\245\343\204\246",      (char const   */* const  */)"  \313\231\313\212\313\207\313\213"};
#line 49 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
static int const   zhuin_tab_num[4]  = {      (int const   )22,      (int const   )4,      (int const   )14,      (int const   )5};
#line 50 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
static int const   shift[4]  = {      (int const   )9,      (int const   )7,      (int const   )3,      (int const   )0};
#line 51 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
static int const   sb[4]  = {      (int const   )31,      (int const   )3,      (int const   )15,      (int const   )7};
#line 53 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
static char const   * const  ph_str  =    (char const   */* const  */)"\343\204\205\343\204\206\343\204\207\343\204\210\343\204\211\343\204\212\343\204\213\343\204\214\343\204\215\343\204\216\343\204\217\343\204\220\343\204\221\343\204\222\343\204\223\343\204\224\343\204\225\343\204\226\343\204\227\343\204\230\343\204\231\343\204\247\343\204\250\343\204\251\343\204\232\343\204\233\343\204\234\343\204\235\343\204\236\343\204\237\343\204\240\343\204\241\343\204\242\343\204\243\343\204\244\343\204\245\343\204\246\313\231\313\212\313\207\313\213";
#line 74 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
static char const   * const  key_str[13]  = 
#line 74
  {      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj",      (char const   */* const  */)"1234567890-qwertyuiopasdfghjkl;zxcvbn/m,.",      (char const   */* const  */)"2wsx3edcrfvtgb6yhnujm8ik,9ol.0p;/-[\'=1qaz", 
        (char const   */* const  */)"bpmfdtnlvkhg7c,./j;\'sexuaorwiqzy890-=1234",      (char const   */* const  */)"bpmfdtnlvkhgvcgycjqwsexuaorwiqzpmntlhdfjk",      (char const   */* const  */)"1\'a;2,oq.ejpuk5yixfdbghm8ctw9rnv0lsz[7634",      (char const   */* const  */)"bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj", 
        (char const   */* const  */)"qqazwwsxedcrfvttgbyhnujmuikbiolmoplnpyerd",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634"};
#line 95 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
uint16_t UintFromPhone(char const   *zhuin ) 
{ 
  char const   *iter ;
  char *pos ;
  char buf[7] ;
  int len ;
  int result ;
  int zhuin_index ;
  int tmp ;

  {
#line 100
  result = 0;
#line 101
  zhuin_index = 0;
#line 103
  iter = zhuin;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! *iter) {
#line 105
      goto while_break;
    }
    {
#line 106
    len = ueStrNCpy(buf, iter, (size_t )1, 1);
    }
    {
#line 108
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 108
      if (! (zhuin_index < 4)) {
#line 108
        goto while_break___0;
      }
      {
#line 109
      pos = strstr((char const   *)zhuin_tab[zhuin_index], (char const   *)(buf));
      }
#line 110
      if (pos) {
#line 111
        goto while_break___0;
      }
#line 108
      zhuin_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    if (zhuin_index >= 4) {
#line 116
      return ((uint16_t )0);
    }
    {
#line 119
    tmp = ueStrLen((char const   *)pos);
#line 119
    result |= (int )((zhuin_tab_num[zhuin_index] - (int const   )tmp) << shift[zhuin_index]);
#line 120
    zhuin_index ++;
#line 121
    iter += len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 123
  return ((uint16_t )result);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
int PhoneFromKey(char *pho , char const   *inputkey , int kbtype , int searchTimes ) 
{ 
  int len ;
  size_t tmp ;
  int i ;
  int s ;
  char const   *pTarget ;
  char *findptr ;
  int _index ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 128
  tmp = strlen(inputkey);
#line 128
  len = (int )tmp;
#line 131
  *(pho + 0) = (char )'\000';
#line 132
  i = 0;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (i < len)) {
#line 132
      goto while_break;
    }
#line 133
    findptr = (char *)((void *)0);
#line 136
    s = 0;
#line 136
    pTarget = (char const   *)key_str[kbtype];
    {
#line 136
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 136
      if (! (s < searchTimes)) {
#line 136
        goto while_break___0;
      }
      {
#line 140
      findptr = strchr(pTarget, (int )*(inputkey + i));
      }
#line 141
      if (! findptr) {
#line 142
        return (0);
      }
#line 136
      s ++;
#line 136
      pTarget = (char const   *)(findptr + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 145
    _index = (int )(findptr - (char *)key_str[kbtype]);
#line 146
    tmp___0 = ueConstStrSeek((char const   *)ph_str, (size_t )_index);
#line 146
    tmp___1 = ueStrSeek(pho, (size_t )i);
#line 146
    ueStrNCpy(tmp___1, tmp___0, (size_t )1, 0);
#line 132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  pho = ueStrSeek(pho, (size_t )len);
#line 151
  *(pho + 0) = (char )'\000';
  }
#line 152
  return (1);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
int PhoneFromUint(char *phone , size_t phone_len , uint16_t phone_num ) 
{ 
  int i ;
  int index___0 ;
  char const   *pos ;
  char tmp[7] ;
  char buffer[25] ;
  unsigned int tmp___0 ;

  {
#line 161
  buffer[0] = (char)0;
#line 161
  tmp___0 = 1U;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (tmp___0 >= 25U) {
#line 161
      goto while_break;
    }
#line 161
    buffer[tmp___0] = (char)0;
#line 161
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! (i < 4)) {
#line 163
      goto while_break___0;
    }
#line 166
    index___0 = (((int )phone_num >> shift[i]) & (int )sb[i]) + 1;
#line 167
    if (index___0 >= 2) {
      {
#line 168
      pos = ueConstStrSeek((char const   *)zhuin_tab[i], (size_t )index___0);
#line 169
      ueStrNCpy(tmp, pos, (size_t )1, 1);
#line 170
      strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(tmp));
      }
    }
#line 163
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  strncpy((char */* __restrict  */)phone, (char const   */* __restrict  */)(buffer),
          phone_len);
  }
#line 174
  return (0);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
int PhoneInxFromKey(int key , int type , int kbtype , int searchTimes ) 
{ 
  char keyStr[2] ;
  char rtStr[10] ;
  char *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 181
  keyStr[0] = (char )key;
#line 182
  keyStr[1] = (char )'\000';
#line 183
  tmp = PhoneFromKey(rtStr, (char const   *)(keyStr), kbtype, searchTimes);
  }
#line 183
  if (! tmp) {
#line 184
    return (0);
  }
  {
#line 185
  p = strstr((char const   *)zhuin_tab[type], (char const   *)(rtStr));
  }
#line 186
  if (! p) {
#line 187
    return (0);
  }
  {
#line 188
  tmp___0 = ueStrLen((char const   *)p);
  }
#line 188
  return ((int )(zhuin_tab_num[type] - (int const   )tmp___0));
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/../../src/common/key2pho.c"
uint16_t UintFromPhoneInx(int const   *ph_inx ) 
{ 
  int i ;
  uint16_t result ;

  {
#line 194
  result = (uint16_t )0;
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < 4)) {
#line 196
      goto while_break;
    }
#line 197
    result = (uint16_t )((int )result | (int )(*(ph_inx + i) << shift[i]));
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return (result);
}
}
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *root  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int32 ph_count  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *queue[6400000]  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int head  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int tail  ;
#line 72 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int node_count  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int tree_size  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
void QueuePut(NODE *pN ) 
{ 
  int tmp ;

  {
#line 77
  tmp = head;
#line 77
  head ++;
#line 77
  queue[tmp] = pN;
#line 78
  if (head == 6400000) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Queue size is not enough!\n");
#line 80
    exit(1);
    }
  }
#line 82
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *QueueGet(void) 
{ 
  int tmp ;

  {
#line 86
  if (! (head != tail)) {
    {
#line 86
    __assert_fail("head != tail", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c",
                  86U, "QueueGet");
    }
  }
#line 87
  tmp = tail;
#line 87
  tail ++;
#line 87
  return (queue[tmp]);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
int QueueEmpty(void) 
{ 


  {
#line 92
  return (head == tail);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *NewNode(uint16_t key ) 
{ 
  NODE *pnew ;
  void *tmp ;

  {
  {
#line 97
  tmp = malloc(sizeof(NODE ));
#line 97
  pnew = (NODE *)tmp;
#line 98
  pnew->key = key;
#line 99
  pnew->childList = (struct _tLISTNODE *)((void *)0);
#line 100
  pnew->phraseno = -1;
#line 101
  pnew->nodeno = -1;
  }
#line 102
  return (pnew);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
void InitConstruct(void) 
{ 


  {
  {
#line 108
  root = NewNode((uint16_t )0);
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *FindKey(NODE *pN , uint16_t key ) 
{ 
  LISTNODE *p ;

  {
#line 115
  p = pN->childList;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! p) {
#line 115
      goto while_break;
    }
#line 116
    if ((int )(p->pNode)->key == (int )key) {
#line 117
      return (p->pNode);
    }
#line 115
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((NODE *)((void *)0));
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
NODE *Insert(NODE *pN , uint16_t key ) 
{ 
  LISTNODE *prev ;
  LISTNODE *p ;
  LISTNODE *pnew ;
  void *tmp ;
  NODE *pnode ;
  NODE *tmp___0 ;

  {
  {
#line 125
  tmp = malloc(sizeof(LISTNODE ));
#line 125
  pnew = (LISTNODE *)tmp;
#line 126
  tmp___0 = NewNode(key);
#line 126
  pnode = tmp___0;
#line 128
  pnew->pNode = pnode;
#line 129
  pnew->next = (struct _tLISTNODE *)((void *)0);
#line 131
  prev = pN->childList;
  }
#line 132
  if (! prev) {
#line 133
    pN->childList = pnew;
  } else {
#line 136
    p = prev->next;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (p) {
#line 136
        if (! ((int )(p->pNode)->key < (int )key)) {
#line 136
          goto while_break;
        }
      } else {
#line 136
        goto while_break;
      }
#line 136
      prev = p;
#line 136
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 141
    prev->next = pnew;
#line 142
    pnew->next = p;
  }
#line 144
  return (pnode);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
void Construct(void) 
{ 
  FILE *input ;
  FILE *tmp ;
  NODE *pointer ;
  NODE *tp ;
  uint16_t key ;
  int ret ;
  int tmp___0 ;
  int32 tmp___1 ;

  {
  {
#line 149
  tmp = fopen((char const   */* __restrict  */)"phoneid.dic", (char const   */* __restrict  */)"r");
#line 149
  input = tmp;
  }
#line 154
  if (! input) {
    {
#line 155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening phoneid.dic\n");
#line 156
    exit(1);
    }
  }
  {
#line 158
  InitConstruct();
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 162
    ret = fscanf((FILE */* __restrict  */)input, (char const   */* __restrict  */)"%hu",
                 & key);
    }
#line 163
    if (ret != 1) {
#line 164
      goto while_break;
    } else {
      {
#line 163
      tmp___0 = feof(input);
      }
#line 163
      if (tmp___0) {
#line 164
        goto while_break;
      }
    }
#line 166
    pointer = root;
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! ((int )key != 0)) {
#line 168
        goto while_break___0;
      }
      {
#line 169
      tp = FindKey(pointer, key);
      }
#line 169
      if (tp) {
#line 170
        pointer = tp;
      } else {
        {
#line 173
        tp = Insert(pointer, key);
#line 174
        pointer = tp;
        }
      }
      {
#line 177
      ret = fscanf((FILE */* __restrict  */)input, (char const   */* __restrict  */)"%hu",
                   & key);
      }
#line 178
      if (ret != 1) {
        {
#line 179
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"phrase does not end with 0 in phoneid.dic");
#line 180
        exit(1);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    tmp___1 = ph_count;
#line 184
    ph_count ++;
#line 184
    pointer->phraseno = tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  fclose(input);
  }
#line 188
  return;
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
void BFS1(void) 
{ 
  NODE *pNode ;
  LISTNODE *pList ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 195
  QueuePut(root);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp___0 = QueueEmpty();
    }
#line 196
    if (tmp___0) {
#line 196
      goto while_break;
    }
    {
#line 197
    pNode = QueueGet();
#line 198
    tmp = node_count;
#line 198
    node_count ++;
#line 198
    pNode->nodeno = tmp;
#line 200
    pList = pNode->childList;
    }
    {
#line 200
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 200
      if (! pList) {
#line 200
        goto while_break___0;
      }
      {
#line 201
      QueuePut(pList->pNode);
#line 200
      pList = pList->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tools/maketree.c"
void BFS2(void) 
{ 
  NODE *pNode ;
  LISTNODE *pList ;
  TreeType tree ;
  FILE *output ;
  FILE *tmp ;
  FILE *config ;
  FILE *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 210
  tree.phone_id = (uint16_t )0;
#line 210
  tree.phrase_id = 0;
#line 210
  tree.child_begin = 0;
#line 210
  tree.child_end = 0;
#line 212
  tmp = fopen((char const   */* __restrict  */)"fonetree.dat", (char const   */* __restrict  */)"wb");
#line 212
  output = tmp;
#line 216
  tmp___0 = fopen((char const   */* __restrict  */)"chewing-definition.h", (char const   */* __restrict  */)"a");
#line 216
  config = tmp___0;
  }
#line 218
  if (! output) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening file fonetree.dat for output.\n");
#line 220
    exit(1);
    }
  }
#line 223
  if (! config) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening file chewing-definition.h for output.\n");
#line 225
    exit(1);
    }
  }
  {
#line 228
  QueuePut(root);
#line 229
  tree_size = 0;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    tmp___1 = QueueEmpty();
    }
#line 230
    if (tmp___1) {
#line 230
      goto while_break;
    }
    {
#line 231
    pNode = QueueGet();
#line 233
    tree.phone_id = pNode->key;
#line 234
    tree.phrase_id = pNode->phraseno;
#line 237
    pList = pNode->childList;
    }
#line 238
    if (pList) {
#line 239
      tree.child_begin = (pList->pNode)->nodeno;
      {
#line 241
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 241
        if (! pList->next) {
#line 241
          goto while_break___0;
        }
        {
#line 242
        QueuePut(pList->pNode);
#line 241
        pList = pList->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 244
      QueuePut(pList->pNode);
#line 245
      tree.child_end = (pList->pNode)->nodeno;
      }
    } else {
#line 248
      tree.child_begin = -1;
#line 249
      tree.child_end = -1;
    }
    {
#line 252
    fwrite((void const   */* __restrict  */)(& tree), sizeof(TreeType ), (size_t )1,
           (FILE */* __restrict  */)output);
#line 258
    tree_size ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  fprintf((FILE */* __restrict  */)config, (char const   */* __restrict  */)"#define TREE_SIZE (%d)\n",
          tree_size);
#line 261
  fclose(output);
#line 262
  fclose(config);
  }
#line 263
  return;
}
}
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 26 "../src/porting_layer/include/plat_mmap.h"
void plat_mmap_set_invalid(plat_mmap *handle ) ;
#line 32
size_t plat_mmap_create(plat_mmap *handle , char const   *file , int fileAccessAttr ) ;
#line 35
void *plat_mmap_set_view(plat_mmap *handle , size_t *offset , size_t *sizet ) ;
#line 38
void plat_mmap_close(plat_mmap *handle ) ;
#line 22 "../include/internal/dict-private.h"
int GetPhraseFirst(ChewingData *pgdata , Phrase *phr_ptr , int phone_phr_id ) ;
#line 23
int GetPhraseNext(ChewingData *pgdata , Phrase *phr_ptr ) ;
#line 24
int InitDict(ChewingData *pgdata , char const   *prefix ) ;
#line 25
void TerminateDict(ChewingData *pgdata ) ;
#line 53 "../include/internal/memory-private.h"
__inline static int GetInt32(void const   *ptr ) 
{ 
  int val ;
  unsigned char const   *uptr ;

  {
#line 56
  uptr = (unsigned char const   *)ptr;
#line 64
  val = (int )((((int const   )*(uptr + 0) | ((int const   )*(uptr + 1) << 8)) | ((int const   )*(uptr + 2) << 16)) | ((int const   )*(uptr + 3) << 24));
#line 70
  return (val);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c"
void TerminateDict(ChewingData *pgdata ) 
{ 


  {
  {
#line 57
  plat_mmap_close(& pgdata->static_data.index_mmap);
#line 58
  plat_mmap_close(& pgdata->static_data.dict_mmap);
  }
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c"
int InitDict(ChewingData *pgdata , char const   *prefix ) 
{ 
  char filename[4096] ;
  size_t len ;
  size_t offset ;
  size_t file_size ;
  size_t csize ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 78
  tmp = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                 prefix, "dict.dat");
#line 78
  len = (size_t )tmp;
  }
#line 79
  if (len + 1UL > sizeof(filename)) {
#line 80
    return (-1);
  }
  {
#line 82
  plat_mmap_set_invalid(& pgdata->static_data.dict_mmap);
#line 83
  file_size = plat_mmap_create(& pgdata->static_data.dict_mmap, (char const   *)(filename),
                               1);
  }
#line 84
  if (file_size <= 0UL) {
#line 85
    return (-1);
  }
  {
#line 87
  offset = (size_t )0;
#line 88
  csize = file_size;
#line 89
  pgdata->static_data.dict = plat_mmap_set_view(& pgdata->static_data.dict_mmap, & offset,
                                                & csize);
  }
#line 90
  if (! pgdata->static_data.dict) {
#line 91
    return (-1);
  }
  {
#line 93
  tmp___0 = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                     prefix, "ph_index.dat");
#line 93
  len = (size_t )tmp___0;
  }
#line 94
  if (len + 1UL > sizeof(filename)) {
#line 95
    return (-1);
  }
  {
#line 97
  plat_mmap_set_invalid(& pgdata->static_data.index_mmap);
#line 98
  file_size = plat_mmap_create(& pgdata->static_data.index_mmap, (char const   *)(filename),
                               1);
  }
#line 99
  if (file_size <= 0UL) {
#line 100
    return (-1);
  }
  {
#line 102
  offset = (size_t )0;
#line 103
  csize = file_size;
#line 104
  tmp___1 = plat_mmap_set_view(& pgdata->static_data.index_mmap, & offset, & csize);
#line 104
  pgdata->static_data.dict_begin = (int *)tmp___1;
  }
#line 105
  if (! pgdata->static_data.dict_begin) {
#line 106
    return (-1);
  }
#line 108
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c"
static void Str2Phrase(ChewingData *pgdata , Phrase *phr_ptr ) 
{ 
  unsigned char size ;

  {
  {
#line 154
  size = *((unsigned char *)pgdata->static_data.dict_cur_pos);
#line 155
  pgdata->static_data.dict_cur_pos = (void *)((unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(unsigned char ));
#line 156
  memcpy((void */* __restrict  */)(phr_ptr->phrase), (void const   */* __restrict  */)pgdata->static_data.dict_cur_pos,
         (size_t )size);
#line 157
  pgdata->static_data.dict_cur_pos = (void *)((unsigned char *)pgdata->static_data.dict_cur_pos + (int )size);
#line 158
  phr_ptr->freq = GetInt32((void const   *)pgdata->static_data.dict_cur_pos);
#line 159
  pgdata->static_data.dict_cur_pos = (void *)((unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(int ));
#line 160
  phr_ptr->phrase[size] = (char )'\000';
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c"
int GetPhraseFirst(ChewingData *pgdata , Phrase *phr_ptr , int phone_phr_id ) 
{ 


  {
#line 166
  if (0 <= phone_phr_id) {
#line 166
    if (! (phone_phr_id < 162244)) {
      {
#line 166
      __assert_fail("( 0 <= phone_phr_id ) && ( phone_phr_id < (162244) )", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c",
                    166U, "GetPhraseFirst");
      }
    }
  } else {
    {
#line 166
    __assert_fail("( 0 <= phone_phr_id ) && ( phone_phr_id < (162244) )", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c",
                  166U, "GetPhraseFirst");
    }
  }
  {
#line 171
  pgdata->static_data.dict_cur_pos = (void *)((unsigned char *)pgdata->static_data.dict + *(pgdata->static_data.dict_begin + phone_phr_id));
#line 173
  pgdata->static_data.dict_end_pos = *(pgdata->static_data.dict_begin + (phone_phr_id + 1));
#line 174
  Str2Phrase(pgdata, phr_ptr);
  }
#line 175
  return (1);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/dict.c"
int GetPhraseNext(ChewingData *pgdata , Phrase *phr_ptr ) 
{ 


  {
#line 184
  if ((unsigned long )((unsigned char *)pgdata->static_data.dict_cur_pos) >= (unsigned long )((unsigned char *)pgdata->static_data.dict + pgdata->static_data.dict_end_pos)) {
#line 185
    return (0);
  }
  {
#line 187
  Str2Phrase(pgdata, phr_ptr);
  }
#line 188
  return (1);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 34 "../include/internal/hash-private.h"
HASH_ITEM *HashFindEntry(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                         char const   *wordSeq ) ;
#line 35
HASH_ITEM *HashInsert(struct tag_ChewingData *pgdata , UserPhraseData *pData ) ;
#line 36
HASH_ITEM *HashFindPhonePhrase(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                               HASH_ITEM *pItemLast ) ;
#line 37
void HashModify(struct tag_ChewingData *pgdata , HASH_ITEM *pItem ) ;
#line 38
int AlcUserPhraseSeq(UserPhraseData *pData , int phonelen , int wordlen ) ;
#line 39
int InitHash(struct tag_ChewingData *pgdata ) ;
#line 40
void TerminateHash(struct tag_ChewingData *pgdata ) ;
#line 25 "../include/internal/memory-private.h"
__inline static uint16_t GetUint16(void const   *ptr ) 
{ 
  uint16_t val ;
  unsigned char const   *uptr ;

  {
#line 28
  uptr = (unsigned char const   *)ptr;
#line 34
  val = (uint16_t )((int const   )*(uptr + 0) | ((int const   )*(uptr + 1) << 8));
#line 38
  return (val);
}
}
#line 41 "../include/internal/memory-private.h"
__inline static void PutUint16(uint16_t val , void *ptr ) 
{ 
  unsigned char *uptr ;

  {
#line 43
  uptr = (unsigned char *)ptr;
#line 48
  *(uptr + 0) = (unsigned char )((int )val & 255);
#line 49
  *(uptr + 1) = (unsigned char )(((int )val >> 8) & 255);
#line 51
  return;
}
}
#line 73 "../include/internal/memory-private.h"
__inline static void PutInt32(int val , void *ptr ) 
{ 
  unsigned char *uptr ;

  {
#line 75
  uptr = (unsigned char *)ptr;
#line 82
  *(uptr + 0) = (unsigned char )(val & 255);
#line 83
  *(uptr + 1) = (unsigned char )((val >> 8) & 255);
#line 84
  *(uptr + 2) = (unsigned char )((val >> 16) & 255);
#line 85
  *(uptr + 3) = (unsigned char )((val >> 24) & 255);
#line 87
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
int AlcUserPhraseSeq(UserPhraseData *pData , int phonelen , int wordlen ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 30
  tmp = calloc((size_t )(phonelen + 1), sizeof(uint16_t ));
#line 30
  pData->phoneSeq = (uint16_t *)tmp;
  }
#line 31
  if (! pData->phoneSeq) {
#line 32
    goto error;
  }
  {
#line 33
  tmp___0 = calloc((size_t )(wordlen + 1), sizeof(char ));
#line 33
  pData->wordSeq = (char *)tmp___0;
  }
#line 34
  if (! pData->wordSeq) {
#line 35
    goto error;
  }
#line 37
  return (1);
  error: 
  {
#line 40
  free((void *)pData->phoneSeq);
#line 41
  free((void *)pData->wordSeq);
  }
#line 42
  return (0);
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static int PhoneSeqTheSame(uint16_t const   *p1 , uint16_t const   *p2 ) 
{ 
  int i ;

  {
#line 48
  if (! p1) {
#line 49
    return (0);
  } else
#line 48
  if (! p2) {
#line 49
    return (0);
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if ((int const   )*(p1 + i) != 0) {
#line 51
      if (! ((int const   )*(p2 + i) != 0)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 52
    if ((int const   )*(p1 + i) != (int const   )*(p2 + i)) {
#line 53
      return (0);
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if ((int const   )*(p1 + i) != (int const   )*(p2 + i)) {
#line 56
    return (0);
  }
#line 57
  return (1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static unsigned int HashFunc(uint16_t const   *phoneSeq ) 
{ 
  int i ;
  int value ;

  {
#line 62
  value = 0;
#line 64
  i = 0;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! ((int const   )*(phoneSeq + i) != 0)) {
#line 64
      goto while_break;
    }
#line 65
    value ^= (int )*(phoneSeq + i);
#line 64
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return ((unsigned int )(value & ((1 << 14) - 1)));
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
HASH_ITEM *HashFindPhonePhrase(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                               HASH_ITEM *pItemLast ) 
{ 
  HASH_ITEM *pNow ;
  unsigned int tmp ;
  struct tag_HASH_ITEM *tmp___0 ;
  int tmp___1 ;

  {
#line 71
  if (pItemLast) {
#line 71
    tmp___0 = pItemLast->next;
  } else {
    {
#line 71
    tmp = HashFunc(phoneSeq);
#line 71
    tmp___0 = pgdata->static_data.hashtable[tmp];
    }
  }
#line 71
  pNow = tmp___0;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! pNow) {
#line 75
      goto while_break;
    }
    {
#line 76
    tmp___1 = PhoneSeqTheSame((uint16_t const   *)pNow->data.phoneSeq, phoneSeq);
    }
#line 76
    if (tmp___1) {
#line 77
      return (pNow);
    }
#line 75
    pNow = pNow->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((HASH_ITEM *)((void *)0));
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
HASH_ITEM *HashFindEntry(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                         char const   *wordSeq ) 
{ 
  HASH_ITEM *pItem ;
  int hashvalue ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 86
  tmp = HashFunc(phoneSeq);
#line 86
  hashvalue = (int )tmp;
#line 88
  pItem = pgdata->static_data.hashtable[hashvalue];
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! pItem) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___0 = strcmp((char const   *)pItem->data.wordSeq, wordSeq);
    }
#line 89
    if (! tmp___0) {
      {
#line 89
      tmp___1 = PhoneSeqTheSame((uint16_t const   *)pItem->data.phoneSeq, phoneSeq);
      }
#line 89
      if (tmp___1) {
#line 92
        return (pItem);
      }
    }
#line 88
    pItem = pItem->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return ((HASH_ITEM *)((void *)0));
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
HASH_ITEM *HashInsert(struct tag_ChewingData *pgdata , UserPhraseData *pData ) 
{ 
  int hashvalue ;
  HASH_ITEM *pItem ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 103
  pItem = HashFindEntry(pgdata, (uint16_t const   *)pData->phoneSeq, (char const   *)pData->wordSeq);
  }
#line 104
  if ((unsigned long )pItem != (unsigned long )((void *)0)) {
#line 105
    return (pItem);
  }
  {
#line 107
  tmp = calloc((size_t )1, sizeof(HASH_ITEM ));
#line 107
  pItem = (HASH_ITEM *)tmp;
  }
#line 108
  if (! pItem) {
#line 109
    return ((HASH_ITEM *)((void *)0));
  }
  {
#line 111
  tmp___0 = HashFunc((uint16_t const   *)pData->phoneSeq);
#line 111
  hashvalue = (int )tmp___0;
#line 113
  pItem->next = pgdata->static_data.hashtable[hashvalue];
#line 115
  memcpy((void */* __restrict  */)(& pItem->data), (void const   */* __restrict  */)pData,
         sizeof(pItem->data));
#line 116
  pItem->item_index = -1;
#line 119
  pgdata->static_data.hashtable[hashvalue] = pItem;
  }
#line 121
  return (pItem);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static void HashItem2String(char *str , HASH_ITEM *pItem ) 
{ 
  int i ;
  int len ;
  char buf[125] ;

  {
  {
#line 129
  sprintf((char */* __restrict  */)str, (char const   */* __restrict  */)"%s ", pItem->data.wordSeq);
#line 130
  len = ueStrLen((char const   *)pItem->data.wordSeq);
#line 131
  i = 0;
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < len)) {
#line 131
      goto while_break;
    }
    {
#line 132
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%hu ",
            (int )*(pItem->data.phoneSeq + i));
#line 133
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)(buf));
#line 131
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 135
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d %d %d %d",
          pItem->data.userfreq, pItem->data.recentTime, pItem->data.maxfreq, pItem->data.origfreq);
#line 139
  strcat((char */* __restrict  */)str, (char const   */* __restrict  */)(buf));
  }
#line 140
  return;
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static void HashItem2Binary(char *str , HASH_ITEM *pItem ) 
{ 
  int i ;
  int phraselen ;
  char *pc ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 150
  memset((void *)str, 0, (size_t )125);
#line 151
  tmp = ueStrLen((char const   *)pItem->data.wordSeq);
#line 151
  tmp___0 = strlen((char const   *)pItem->data.wordSeq);
  }
#line 151
  if ((sizeof(int ) * 4UL + (unsigned long )(tmp * 2)) + tmp___0 >= 125UL) {
#line 154
    return;
  }
  {
#line 158
  PutInt32(pItem->data.userfreq, (void *)(str + 0));
#line 159
  PutInt32(pItem->data.recentTime, (void *)(str + 4));
#line 160
  PutInt32(pItem->data.maxfreq, (void *)(str + 8));
#line 161
  PutInt32(pItem->data.origfreq, (void *)(str + 12));
#line 164
  phraselen = ueStrLen((char const   *)pItem->data.wordSeq);
#line 165
  *(str + 16) = (char )phraselen;
#line 166
  pc = str + 17;
#line 167
  i = 0;
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < phraselen)) {
#line 167
      goto while_break;
    }
    {
#line 168
    PutUint16(*(pItem->data.phoneSeq + i), (void *)pc);
#line 169
    pc += 2;
#line 167
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  tmp___1 = strlen((char const   *)pItem->data.wordSeq);
#line 173
  *pc = (char )tmp___1;
#line 174
  strcpy((char */* __restrict  */)(pc + 1), (char const   */* __restrict  */)pItem->data.wordSeq);
#line 175
  *(pItem->data.wordSeq + (unsigned char )*pc) = (char )'\000';
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
void HashModify(struct tag_ChewingData *pgdata , HASH_ITEM *pItem ) 
{ 
  FILE *outfile ;
  char str[126] ;
  size_t tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 183
  outfile = fopen((char const   */* __restrict  */)(pgdata->static_data.hashfilename),
                  (char const   */* __restrict  */)"r+b");
  }
#line 184
  if (! outfile) {
#line 185
    return;
  }
  {
#line 188
  tmp = strlen("CBiH");
#line 188
  fseek(outfile, (long )tmp, 0);
#line 189
  fwrite((void const   */* __restrict  */)(& pgdata->static_data.chewing_lifetime),
         (size_t )1, (size_t )4, (FILE */* __restrict  */)outfile);
#line 190
  sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d", pgdata->static_data.chewing_lifetime);
  }
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 191
    (*(pgdata->logger))(pgdata->loggerData, 3, "HashModify-1: \'%-75s\'\n", str);
    }
#line 191
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  if (pItem->item_index < 0) {
    {
#line 195
    fseek(outfile, 0L, 2);
#line 196
    tmp___0 = ftell(outfile);
#line 196
    tmp___1 = strlen("CBiH");
#line 196
    pItem->item_index = (int )(((size_t )(tmp___0 - 4L) - tmp___1) / 125UL);
    }
  } else {
    {
#line 200
    tmp___2 = strlen("CBiH");
#line 200
    fseek(outfile, (long )((size_t )(pItem->item_index * 125 + 4) + tmp___2), 0);
    }
  }
  {
#line 205
  HashItem2String(str, pItem);
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 206
    (*(pgdata->logger))(pgdata->loggerData, 3, "HashModify-2: \'%-75s\'\n", str);
    }
#line 206
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 208
  HashItem2Binary(str, pItem);
#line 209
  fwrite((void const   */* __restrict  */)(str), (size_t )1, (size_t )125, (FILE */* __restrict  */)outfile);
#line 210
  fflush(outfile);
#line 211
  fclose(outfile);
  }
#line 212
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static int isValidChineseString(char *str ) 
{ 
  int len ;
  int tmp ;

  {
#line 216
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 217
    return (0);
  } else
#line 216
  if ((int )*str == 0) {
#line 217
    return (0);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((int )*str != 0)) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp = ueBytesFromChar((unsigned char )*str);
#line 220
    len = tmp;
    }
#line 221
    if (len <= 1) {
#line 222
      return (0);
    }
#line 224
    str += len;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return (1);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static int ReadHashItem_bin(char const   *srcbuf , HASH_ITEM *pItem , int item_index ) 
{ 
  int len ;
  int i ;
  char const   *pc ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 240
  memset((void *)pItem, 0, sizeof(HASH_ITEM ));
#line 243
  pItem->data.userfreq = GetInt32((void const   *)(srcbuf + 0));
#line 244
  pItem->data.recentTime = GetInt32((void const   *)(srcbuf + 4));
#line 245
  pItem->data.maxfreq = GetInt32((void const   *)(srcbuf + 8));
#line 246
  pItem->data.origfreq = GetInt32((void const   *)(srcbuf + 12));
#line 249
  len = (int )*(srcbuf + 16);
#line 250
  tmp = calloc((size_t )(len + 1), sizeof(uint16_t ));
#line 250
  pItem->data.phoneSeq = (uint16_t *)tmp;
#line 251
  pc = srcbuf + 17;
#line 252
  i = 0;
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < len)) {
#line 252
      goto while_break;
    }
    {
#line 253
    *(pItem->data.phoneSeq + i) = GetUint16((void const   *)pc);
#line 254
    pc += 2;
#line 252
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 256
  *(pItem->data.phoneSeq + i) = (uint16_t )0;
#line 259
  tmp___0 = calloc((size_t )((int const   )*pc + 1), sizeof(char ));
#line 259
  pItem->data.wordSeq = (char *)tmp___0;
#line 260
  strcpy((char */* __restrict  */)pItem->data.wordSeq, (char const   */* __restrict  */)((char *)(pc + 1)));
#line 261
  *(pItem->data.wordSeq + (unsigned int )*pc) = (char )'\000';
#line 264
  tmp___1 = isValidChineseString(pItem->data.wordSeq);
  }
#line 264
  if (! tmp___1) {
#line 265
    goto ignore_corrupted_record;
  }
#line 269
  pItem->item_index = item_index;
#line 271
  return (1);
  ignore_corrupted_record: 
#line 274
  if ((unsigned long )pItem->data.phoneSeq != (unsigned long )((void *)0)) {
    {
#line 275
    free((void *)pItem->data.phoneSeq);
#line 276
    pItem->data.phoneSeq = (uint16_t *)((void *)0);
    }
  }
#line 278
  if ((unsigned long )pItem->data.wordSeq != (unsigned long )((void *)0)) {
    {
#line 279
    free((void *)pItem->data.wordSeq);
#line 280
    pItem->data.wordSeq = (char *)((void *)0);
    }
  }
#line 282
  return (-1);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static int ReadHashItem_txt(FILE *infile , HASH_ITEM *pItem , int item_index ) 
{ 
  int len ;
  int i ;
  int word_len ;
  char wordbuf[64] ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 295
  tmp = fscanf((FILE */* __restrict  */)infile, (char const   */* __restrict  */)"%s",
               wordbuf);
  }
#line 295
  if (tmp != 1) {
#line 296
    return (0);
  }
  {
#line 299
  tmp___1 = isValidChineseString(wordbuf);
  }
#line 299
  if (! tmp___1) {
    {
#line 300
    tmp___0 = strlen((char const   *)(wordbuf));
#line 300
    fseek(infile, (long )((125UL - tmp___0) - 1UL), 1);
    }
#line 301
    return (-1);
  }
  {
#line 304
  tmp___2 = strlen((char const   *)(wordbuf));
#line 304
  word_len = (int )tmp___2;
#line 305
  tmp___3 = calloc((size_t )(word_len + 1), sizeof(char ));
#line 305
  pItem->data.wordSeq = (char *)tmp___3;
#line 306
  strcpy((char */* __restrict  */)pItem->data.wordSeq, (char const   */* __restrict  */)(wordbuf));
#line 309
  len = ueStrLen((char const   *)pItem->data.wordSeq);
#line 310
  tmp___4 = calloc((size_t )(len + 1), sizeof(uint16_t ));
#line 310
  pItem->data.phoneSeq = (uint16_t *)tmp___4;
#line 311
  i = 0;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (i < len)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___5 = fscanf((FILE */* __restrict  */)infile, (char const   */* __restrict  */)"%hu",
                     pItem->data.phoneSeq + i);
    }
#line 312
    if (tmp___5 != 1) {
#line 313
      return (0);
    }
#line 311
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  *(pItem->data.phoneSeq + len) = (uint16_t )0;
#line 317
  tmp___6 = fscanf((FILE */* __restrict  */)infile, (char const   */* __restrict  */)"%d %d %d %d",
                   & pItem->data.userfreq, & pItem->data.recentTime, & pItem->data.maxfreq,
                   & pItem->data.origfreq);
  }
#line 317
  if (tmp___6 != 4) {
#line 322
    return (0);
  }
#line 325
  pItem->item_index = item_index;
#line 327
  return (1);
}
}
#line 330 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static FILE *open_file_get_length(char const   *filename , char const   *otype , int *size ) 
{ 
  FILE *tf ;
  FILE *tmp ;
  long tmp___0 ;

  {
  {
#line 334
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)otype);
#line 334
  tf = tmp;
  }
#line 335
  if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 336
    return ((FILE *)((void *)0));
  }
#line 338
  if ((unsigned long )size != (unsigned long )((void *)0)) {
    {
#line 339
    fseek(tf, 0L, 2);
#line 340
    tmp___0 = ftell(tf);
#line 340
    *size = (int )tmp___0;
#line 341
    fseek(tf, 0L, 0);
    }
  }
#line 343
  return (tf);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static char *_load_hash_file(char const   *filename , int *size ) 
{ 
  int flen ;
  char *pd ;
  FILE *tf ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 349
  pd = (char *)((void *)0);
#line 352
  tf = open_file_get_length(filename, "rb", & flen);
  }
#line 353
  if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 354
    goto err_load_file;
  }
  {
#line 356
  tmp = calloc((size_t )flen, sizeof(char ));
#line 356
  pd = (char *)tmp;
  }
#line 357
  if ((unsigned long )pd == (unsigned long )((void *)0)) {
#line 358
    goto err_load_file;
  }
  {
#line 360
  tmp___0 = fread((void */* __restrict  */)pd, (size_t )flen, (size_t )1, (FILE */* __restrict  */)tf);
  }
#line 360
  if (tmp___0 != 1UL) {
#line 361
    goto err_load_file;
  }
  {
#line 363
  fclose(tf);
  }
#line 364
  if ((unsigned long )size != (unsigned long )((void *)0)) {
#line 365
    *size = flen;
  }
#line 366
  return (pd);
  err_load_file: 
#line 369
  if ((unsigned long )pd != (unsigned long )((void *)0)) {
    {
#line 370
    free((void *)pd);
    }
  }
#line 371
  if ((unsigned long )tf != (unsigned long )((void *)0)) {
    {
#line 372
    fclose(tf);
    }
  }
#line 373
  return ((char *)((void *)0));
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static int migrate_hash_to_bin(ChewingData *pgdata ) 
{ 
  FILE *txtfile ;
  char oldname[256] ;
  char *dump ;
  char *seekdump ;
  HASH_ITEM item ;
  int item_index ;
  int iret ;
  int tflen ;
  int ret ;
  char const   *ofilename ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 384
  ofilename = (char const   *)(pgdata->static_data.hashfilename);
#line 387
  txtfile = open_file_get_length(ofilename, "r", & tflen);
  }
#line 388
  if ((unsigned long )txtfile == (unsigned long )((void *)0)) {
#line 389
    return (0);
  }
  {
#line 391
  tmp = calloc((size_t )(tflen * 2), sizeof(char ));
#line 391
  dump = (char *)tmp;
  }
#line 392
  if ((unsigned long )dump == (unsigned long )((void *)0)) {
    {
#line 393
    fclose(txtfile);
    }
#line 394
    return (0);
  }
  {
#line 396
  ret = fscanf((FILE */* __restrict  */)txtfile, (char const   */* __restrict  */)"%d",
               & pgdata->static_data.chewing_lifetime);
  }
#line 397
  if (ret != 1) {
#line 398
    return (0);
  }
  {
#line 402
  seekdump = dump;
#line 403
  tmp___0 = strlen("CBiH");
#line 403
  memcpy((void */* __restrict  */)seekdump, (void const   */* __restrict  */)"CBiH",
         tmp___0);
#line 404
  tmp___1 = strlen("CBiH");
#line 404
  memcpy((void */* __restrict  */)(seekdump + tmp___1), (void const   */* __restrict  */)(& pgdata->static_data.chewing_lifetime),
         sizeof(pgdata->static_data.chewing_lifetime));
#line 407
  tmp___2 = strlen("CBiH");
#line 407
  seekdump += tmp___2 + sizeof(pgdata->static_data.chewing_lifetime);
#line 410
  item_index = 0;
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    item_index ++;
#line 412
    iret = ReadHashItem_txt(txtfile, & item, item_index);
    }
#line 414
    if (iret == -1) {
#line 415
      item_index --;
#line 416
      goto while_continue;
    } else
#line 418
    if (iret == 0) {
#line 419
      goto while_break;
    }
    {
#line 421
    HashItem2Binary(seekdump, & item);
#line 422
    seekdump += 125;
#line 423
    free((void *)item.data.phoneSeq);
#line 424
    free((void *)item.data.wordSeq);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  fclose(txtfile);
#line 429
  strncpy((char */* __restrict  */)(oldname), (char const   */* __restrict  */)ofilename,
          sizeof(oldname));
#line 430
  tmp___3 = strlen((char const   *)(oldname));
#line 430
  strncat((char */* __restrict  */)(oldname), (char const   */* __restrict  */)".old",
          (sizeof(oldname) - tmp___3) - 1UL);
#line 431
  oldname[sizeof(oldname) - 1UL] = (char )'\000';
#line 432
  unlink((char const   *)(oldname));
#line 433
  rename(ofilename, (char const   *)(oldname));
#line 436
  unlink(ofilename);
#line 437
  txtfile = fopen((char const   */* __restrict  */)ofilename, (char const   */* __restrict  */)"w+b");
#line 438
  fwrite((void const   */* __restrict  */)dump, (size_t )(seekdump - dump), (size_t )1,
         (FILE */* __restrict  */)txtfile);
#line 439
  fflush(txtfile);
#line 440
  fclose(txtfile);
#line 441
  free((void *)dump);
  }
#line 443
  return (1);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
static void FreeHashItem(HASH_ITEM *aItem ) 
{ 
  HASH_ITEM *pItem ;

  {
#line 448
  if (aItem) {
    {
#line 449
    pItem = aItem->next;
#line 450
    free((void *)aItem->data.phoneSeq);
#line 451
    free((void *)aItem->data.wordSeq);
#line 452
    free((void *)aItem);
    }
#line 453
    if (pItem) {
      {
#line 454
      FreeHashItem(pItem);
      }
    }
  }
#line 457
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
void TerminateHash(struct tag_ChewingData *pgdata ) 
{ 
  HASH_ITEM *pItem ;
  int i ;

  {
#line 463
  i = 0;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < 1 << 14)) {
#line 463
      goto while_break;
    }
#line 464
    pItem = pgdata->static_data.hashtable[i];
    {
#line 465
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 465
      (*(pgdata->logger))(pgdata->loggerData, 1, "[ File: %s  Func: %s  Line: %d ]\n",
                          "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c",
                          "TerminateHash", 465);
      }
#line 465
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 466
    FreeHashItem(pItem);
#line 463
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return;
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/hash.c"
int InitHash(struct tag_ChewingData *pgdata ) 
{ 
  HASH_ITEM item ;
  HASH_ITEM *pItem ;
  HASH_ITEM *pPool ;
  int item_index ;
  int hashvalue ;
  int iret ;
  int fsize ;
  int hdrlen ;
  int oldest ;
  char *dump ;
  char *seekdump ;
  char const   *path ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  FILE *outfile ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  unsigned int tmp___11 ;

  {
  {
#line 472
  pPool = (HASH_ITEM *)((void *)0);
#line 473
  oldest = 2147483647;
#line 476
  tmp = getenv("CHEWING_USER_PATH");
#line 476
  path = (char const   *)tmp;
  }
#line 479
  if (path) {
    {
#line 479
    tmp___2 = access(path, 2);
    }
#line 479
    if (tmp___2 == 0) {
      {
#line 480
      sprintf((char */* __restrict  */)(pgdata->static_data.hashfilename), (char const   */* __restrict  */)"%s/%s",
              path, "uhash.dat");
      }
    } else {
#line 479
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 482
    tmp___1 = getenv("HOME");
    }
#line 482
    if (tmp___1) {
      {
#line 483
      tmp___0 = getenv("HOME");
#line 483
      sprintf((char */* __restrict  */)(pgdata->static_data.hashfilename), (char const   */* __restrict  */)"%s%s",
              tmp___0, "/.chewing");
      }
    } else {
      {
#line 488
      sprintf((char */* __restrict  */)(pgdata->static_data.hashfilename), (char const   */* __restrict  */)"%s%s",
              "/tmp", "/.chewing");
      }
    }
    {
#line 492
    mkdir((char const   *)(pgdata->static_data.hashfilename), (__mode_t )448);
#line 493
    strcat((char */* __restrict  */)(pgdata->static_data.hashfilename), (char const   */* __restrict  */)"/");
#line 494
    strcat((char */* __restrict  */)(pgdata->static_data.hashfilename), (char const   */* __restrict  */)"uhash.dat");
    }
  }
  {
#line 496
  memset((void *)(pgdata->static_data.hashtable), 0, sizeof(pgdata->static_data.hashtable));
  }
  open_hash_file: 
  {
#line 499
  dump = _load_hash_file((char const   *)(pgdata->static_data.hashfilename), & fsize);
#line 500
  tmp___3 = strlen("CBiH");
#line 500
  hdrlen = (int )(tmp___3 + sizeof(pgdata->static_data.chewing_lifetime));
#line 501
  item_index = 0;
  }
#line 502
  if ((unsigned long )dump == (unsigned long )((void *)0)) {
#line 502
    goto _L___0;
  } else
#line 502
  if (fsize < hdrlen) {
    _L___0: /* CIL Label */ 
    {
#line 504
    outfile = fopen((char const   */* __restrict  */)(pgdata->static_data.hashfilename),
                    (char const   */* __restrict  */)"w+b");
    }
#line 505
    if (! outfile) {
#line 506
      if (dump) {
        {
#line 507
        free((void *)dump);
        }
      }
#line 509
      return (0);
    }
    {
#line 511
    pgdata->static_data.chewing_lifetime = 0;
#line 512
    tmp___4 = strlen("CBiH");
#line 512
    fwrite((void const   */* __restrict  */)"CBiH", (size_t )1, tmp___4, (FILE */* __restrict  */)outfile);
#line 513
    fwrite((void const   */* __restrict  */)(& pgdata->static_data.chewing_lifetime),
           (size_t )1, sizeof(pgdata->static_data.chewing_lifetime), (FILE */* __restrict  */)outfile);
#line 515
    fclose(outfile);
    }
  } else {
    {
#line 518
    tmp___6 = strlen("CBiH");
#line 518
    tmp___7 = memcmp((void const   *)dump, (void const   *)"CBiH", tmp___6);
    }
#line 518
    if (tmp___7 != 0) {
      {
#line 520
      free((void *)dump);
#line 521
      tmp___5 = migrate_hash_to_bin(pgdata);
      }
#line 521
      if (! tmp___5) {
#line 522
        return (0);
      }
#line 524
      goto open_hash_file;
    }
    {
#line 527
    tmp___8 = strlen("CBiH");
#line 527
    pgdata->static_data.chewing_lifetime = *((int *)(dump + tmp___8));
#line 528
    seekdump = dump + hdrlen;
#line 529
    fsize -= hdrlen;
    }
    {
#line 531
    while (1) {
      while_continue: /* CIL Label */ ;
#line 531
      if (! (fsize >= 125)) {
#line 531
        goto while_break;
      }
      {
#line 532
      tmp___9 = item_index;
#line 532
      item_index ++;
#line 532
      iret = ReadHashItem_bin((char const   *)seekdump, & item, tmp___9);
      }
#line 534
      if (iret == -1) {
#line 535
        seekdump += 125;
#line 536
        fsize -= 125;
#line 537
        item_index --;
#line 538
        goto while_continue;
      } else
#line 540
      if (iret == 0) {
#line 541
        goto while_break;
      }
      {
#line 543
      tmp___10 = calloc((size_t )1, sizeof(HASH_ITEM ));
#line 543
      pItem = (HASH_ITEM *)tmp___10;
#line 544
      memcpy((void */* __restrict  */)pItem, (void const   */* __restrict  */)(& item),
             sizeof(HASH_ITEM ));
#line 545
      pItem->next = pPool;
#line 546
      pPool = pItem;
      }
#line 548
      if (oldest > pItem->data.recentTime) {
#line 549
        oldest = pItem->data.recentTime;
      }
#line 552
      seekdump += 125;
#line 553
      fsize -= 125;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 555
    free((void *)dump);
    }
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (! pPool) {
#line 557
        goto while_break___0;
      }
      {
#line 558
      pItem = pPool;
#line 559
      pPool = pItem->next;
#line 561
      tmp___11 = HashFunc((uint16_t const   *)pItem->data.phoneSeq);
#line 561
      hashvalue = (int )tmp___11;
#line 562
      pItem->next = pgdata->static_data.hashtable[hashvalue];
#line 563
      pgdata->static_data.hashtable[hashvalue] = pItem;
#line 564
      pItem->data.recentTime -= oldest;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 566
    pgdata->static_data.chewing_lifetime -= oldest;
  }
#line 568
  return (1);
}
}
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 54 "../include/internal/chewing-private.h"
__inline static int max(int a , int b ) 
{ 
  int tmp ;

  {
#line 56
  if (a > b) {
#line 56
    tmp = a;
  } else {
#line 56
    tmp = b;
  }
#line 56
  return (tmp);
}
}
#line 60 "../include/internal/chewing-private.h"
__inline static int min(int a , int b ) 
{ 
  int tmp ;

  {
#line 62
  if (a < b) {
#line 62
    tmp = a;
  } else {
#line 62
    tmp = b;
  }
#line 62
  return (tmp);
}
}
#line 25 "../include/internal/chewingutil.h"
void AutoLearnPhrase(ChewingData *pgdata ) ;
#line 26
void SetUpdatePhraseMsg(ChewingData *pgdata , char const   *addWordSeq , int len ,
                        int state ) ;
#line 27
int NoSymbolBetween(ChewingData *pgdata , int begin , int end ) ;
#line 28
int ChewingIsEntering(ChewingData *pgdata ) ;
#line 29
void CleanAllBuf(ChewingData *pgdata ) ;
#line 30
int SpecialSymbolInput(int key , ChewingData *pgdata ) ;
#line 31
int FullShapeSymbolInput(int key , ChewingData *pgdata ) ;
#line 32
int EasySymbolInput(int key , ChewingData *pgdata ) ;
#line 33
int SymbolInput(int key , ChewingData *pgdata ) ;
#line 34
int SymbolChoice(ChewingData *pgdata , int sel_i ) ;
#line 35
int HaninSymbolInput(ChewingData *pgdata ) ;
#line 36
int WriteChiSymbolToBuf(wch_t *csBuf , int csBufLen , ChewingData *pgdata ) ;
#line 37
int ReleaseChiSymbolBuf(ChewingData *pgdata , ChewingOutput *pgo ) ;
#line 38
int AddChi(uint16_t phone , uint16_t phoneAlt , ChewingData *pgdata ) ;
#line 39
int CallPhrasing(ChewingData *pgdata ) ;
#line 40
int MakeOutputWithRtn(ChewingOutput *pgo , ChewingData *pgdata , int keystrokeRtn ) ;
#line 41
void MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo , ChewingData *pgdata ) ;
#line 42
int AddSelect(ChewingData *pgdata , int sel_i ) ;
#line 43
int CountSelKeyNum(int key , ChewingData *pgdata ) ;
#line 44
int CountSymbols(ChewingData *pgdata , int to ) ;
#line 45
int PhoneSeqCursor(ChewingData *pgdata ) ;
#line 46
int ChewingIsChiAt(int chiSymbolCursor , ChewingData *pgdata ) ;
#line 47
int ChewingKillChar(ChewingData *pgdata , int chiSymbolCursorToKill , int minus ) ;
#line 51
void RemoveSelectElement(int i , ChewingData *pgdata ) ;
#line 52
int IsPreferIntervalConnted(int cursor , ChewingData *pgdata ) ;
#line 53
int OpenSymbolChoice(ChewingData *pgdata ) ;
#line 55
int InitSymbolTable(ChewingData *pgdata , char const   *prefix ) ;
#line 56
void TerminateSymbolTable(ChewingData *pgdata ) ;
#line 58
int InitEasySymbolInput(ChewingData *pgdata , char const   *prefix ) ;
#line 59
void TerminateEasySymbolTable(ChewingData *pgdata ) ;
#line 44 "../include/internal/zuin-private.h"
int ZuinIsEntering(ZuinData *pZuin ) ;
#line 18 "../include/internal/choice-private.h"
int ChoiceEndChoice(ChewingData *pgdata ) ;
#line 20 "../include/internal/tree-private.h"
int Phrasing(ChewingData *pgdata ) ;
#line 58 "../include/internal/userphrase-private.h"
int UserUpdatePhrase(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                     char const   *wordSeq ) ;
#line 405 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void MakePreferInterval(ChewingData *pgdata ) ;
#line 47
static void ShiftInterval(ChewingOutput *pgo , ChewingData *pgdata ) ;
#line 48
static int ChewingKillSelectIntervalAcross(int cursor , ChewingData *pgdata ) ;
#line 50
static int FindSymbolKey(char const   *symbol ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   G_EASY_SYMBOL_KEY[36]  = 
#line 53
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z'};
#line 64 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int FindEasySymbolIndex(char ch ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 70
  tmp___0 = __ctype_b_loc();
  }
#line 70
  if ((int const   )*(*tmp___0 + (int )ch) & 2048) {
#line 71
    return ((int )ch - 48);
  } else {
    {
#line 73
    tmp = __ctype_b_loc();
    }
#line 73
    if ((int const   )*(*tmp + (int )ch) & 256) {
#line 74
      return (((int )ch - 65) + 10);
    } else {
#line 77
      return (-1);
    }
  }
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void SetUpdatePhraseMsg(ChewingData *pgdata , char const   *addWordSeq , int len ,
                        int state ) 
{ 
  char const   *insert ;
  char const   *modify ;
  int begin ;
  int i ;
  char const   *msg ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 85
  insert = "\345\212\240\345\205\245\357\274\232";
#line 87
  modify = "\345\267\262\346\234\211\357\274\232";
#line 89
  begin = 3;
#line 92
  pgdata->showMsgLen = begin + len;
#line 93
  if (state == 1) {
#line 94
    msg = insert;
  } else {
#line 97
    msg = modify;
  }
  {
#line 99
  ueStrNCpy((char *)(pgdata->showMsg[0].s), msg, (size_t )1, 1);
#line 100
  tmp = ueConstStrSeek(msg, (size_t )1);
#line 100
  ueStrNCpy((char *)(pgdata->showMsg[1].s), tmp, (size_t )1, 1);
#line 103
  tmp___0 = ueConstStrSeek(msg, (size_t )2);
#line 103
  ueStrNCpy((char *)(pgdata->showMsg[2].s), tmp___0, (size_t )1, 1);
#line 106
  i = 0;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < len)) {
#line 106
      goto while_break;
    }
    {
#line 107
    tmp___1 = ueConstStrSeek(addWordSeq, (size_t )i);
#line 107
    ueStrNCpy((char *)(pgdata->showMsg[begin + i].s), tmp___1, (size_t )1, 1);
#line 106
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int NoSymbolBetween(ChewingData *pgdata , int begin , int end ) 
{ 
  int i ;

  {
  {
#line 116
  end = min(end, pgdata->chiSymbolBufLen);
#line 118
  i = begin;
  }
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < end)) {
#line 118
      goto while_break;
    }
#line 119
    if ((int )pgdata->chiSymbolBuf[i].wch != 0) {
#line 120
      return (0);
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (1);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int ChewingIsEntering(ChewingData *pgdata ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if (pgdata->choiceInfo.isSymbol != 0) {
#line 127
    return (1);
  }
#line 128
  if (pgdata->chiSymbolBufLen != 0) {
#line 128
    tmp___0 = 1;
  } else {
    {
#line 128
    tmp = ZuinIsEntering(& pgdata->zuinData);
    }
#line 128
    if (tmp) {
#line 128
      tmp___0 = 1;
    } else {
#line 128
      tmp___0 = 0;
    }
  }
#line 128
  return (tmp___0);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int HaninSymbolInput(ChewingData *pgdata ) 
{ 
  unsigned int i ;
  ChoiceInfo *pci ;
  AvailInfo *pai ;

  {
#line 137
  pci = & pgdata->choiceInfo;
#line 138
  pai = & pgdata->availInfo;
#line 141
  if (! pgdata->static_data.symbol_table) {
#line 142
    return (1);
  }
#line 144
  pci->nTotalChoice = 0;
#line 145
  i = 0U;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < pgdata->static_data.n_symbol_entry)) {
#line 145
      goto while_break;
    }
    {
#line 146
    strcpy((char */* __restrict  */)(pci->totalChoiceStr[pci->nTotalChoice]), (char const   */* __restrict  */)((*(pgdata->static_data.symbol_table + i))->category));
#line 148
    (pci->nTotalChoice) ++;
#line 145
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  pai->avail[0].len = 1;
#line 151
  pai->avail[0].id = -1;
#line 152
  pai->nAvail = 1;
#line 153
  pai->currentAvail = 0;
#line 154
  pci->nChoicePerPage = pgdata->config.candPerPage;
#line 155
  if (! (pci->nTotalChoice > 0)) {
    {
#line 155
    __assert_fail("pci->nTotalChoice > 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  155U, "HaninSymbolInput");
    }
  }
#line 156
  pci->nPage = ((pci->nTotalChoice + pci->nChoicePerPage) - 1) / pci->nChoicePerPage;
#line 157
  pci->pageNo = 0;
#line 158
  pci->isSymbol = 1;
#line 159
  return (1);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int _Inner_InternalSpecialSymbol(int key , ChewingData *pgdata , char symkey ,
                                        char const   * const  chibuf___1 ) 
{ 
  int kbtype ;
  int tmp ;

  {
#line 168
  if (key == (int )symkey) {
#line 168
    if ((unsigned long )((void *)0) != (unsigned long )chibuf___1) {
#line 169
      if (! (pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor)) {
        {
#line 169
        __assert_fail("pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                      169U, "_Inner_InternalSpecialSymbol");
        }
      }
      {
#line 170
      memmove((void *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor]),
              sizeof(wch_t ) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
#line 175
      pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].wch = (uint16_t )0;
#line 176
      ueStrNCpy((char *)(pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].s), (char const   *)chibuf___1,
                (size_t )1, 1);
#line 179
      memmove((void *)(& pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),
              sizeof(pgdata->symbolKeyBuf[0]) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
#line 184
      pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = (char )key;
#line 185
      tmp = PhoneSeqCursor(pgdata);
#line 185
      pgdata->bUserArrCnnct[tmp] = 0;
#line 186
      (pgdata->chiSymbolCursor) ++;
#line 187
      (pgdata->chiSymbolBufLen) ++;
#line 190
      kbtype = pgdata->zuinData.kbtype;
#line 191
      memset((void *)(& pgdata->zuinData), 0, sizeof(ZuinData ));
#line 192
      pgdata->zuinData.kbtype = kbtype;
      }
#line 193
      return (1);
    }
  }
#line 195
  return (0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int InternalSpecialSymbol(int key , ChewingData *pgdata , int nSpecial , char const   *keybuf___1 ,
                                 char const   * const  *chibuf___1 ) 
{ 
  int i ;
  int rtn ;
  int tmp ;

  {
#line 202
  rtn = 0;
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < nSpecial)) {
#line 204
      goto while_break;
    }
    {
#line 205
    tmp = _Inner_InternalSpecialSymbol(key, pgdata, (char )*(keybuf___1 + i), *(chibuf___1 + i));
    }
#line 205
    if (1 == tmp) {
#line 206
      rtn = 1;
#line 207
      goto while_break;
    }
#line 204
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (rtn);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   keybuf[29]  = 
#line 215
  {      (char const   )'[',      (char const   )']',      (char const   )'{',      (char const   )'}', 
        (char const   )'\'',      (char const   )'<',      (char const   )':',      (char const   )'\"', 
        (char const   )'>',      (char const   )'~',      (char const   )'!',      (char const   )'@', 
        (char const   )'#',      (char const   )'$',      (char const   )'%',      (char const   )'^', 
        (char const   )'&',      (char const   )'*',      (char const   )'(',      (char const   )')', 
        (char const   )'_',      (char const   )'+',      (char const   )'=',      (char const   )'\\', 
        (char const   )'|',      (char const   )'?',      (char const   )',',      (char const   )'.', 
        (char const   )';'};
#line 222 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   * const  chibuf[29]  = 
#line 222
  {      (char const   */* const  */)"\343\200\214",      (char const   */* const  */)"\343\200\215",      (char const   */* const  */)"\343\200\216",      (char const   */* const  */)"\343\200\217", 
        (char const   */* const  */)"\343\200\201",      (char const   */* const  */)"\357\274\214",      (char const   */* const  */)"\357\274\232",      (char const   */* const  */)"\357\274\233", 
        (char const   */* const  */)"\343\200\202",      (char const   */* const  */)"\357\275\236",      (char const   */* const  */)"\357\274\201",      (char const   */* const  */)"\357\274\240", 
        (char const   */* const  */)"\357\274\203",      (char const   */* const  */)"\357\274\204",      (char const   */* const  */)"\357\274\205",      (char const   */* const  */)"\357\270\277", 
        (char const   */* const  */)"\357\274\206",      (char const   */* const  */)"\357\274\212",      (char const   */* const  */)"\357\274\210",      (char const   */* const  */)"\357\274\211", 
        (char const   */* const  */)"\357\271\215",      (char const   */* const  */)"\357\274\213",      (char const   */* const  */)"\357\274\235",      (char const   */* const  */)"\357\274\274", 
        (char const   */* const  */)"\357\275\234",      (char const   */* const  */)"\357\274\237",      (char const   */* const  */)"\357\274\214",      (char const   */* const  */)"\343\200\202", 
        (char const   */* const  */)"\357\274\233"};
#line 213 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int SpecialSymbolInput(int key , ChewingData *pgdata ) 
{ 
  char __constr_expr_3[29] ;
  int tmp ;

  {
  {
#line 242
  tmp = InternalSpecialSymbol(key, pgdata, (int )(sizeof(keybuf) / sizeof(__constr_expr_3[0])),
                              keybuf, chibuf);
  }
#line 242
  return (tmp);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char keybuf___0[75]  = 
#line 248
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )' ',      (char )'\"', 
        (char )'\'',      (char )'/',      (char )'<',      (char )'>', 
        (char )'`',      (char )'[',      (char )']',      (char )'{', 
        (char )'}',      (char )'+',      (char )'-'};
#line 258 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   *chibuf___0[75]  = 
#line 258
  {      "\357\274\220",      "\357\274\221",      "\357\274\222",      "\357\274\223", 
        "\357\274\224",      "\357\274\225",      "\357\274\226",      "\357\274\227", 
        "\357\274\230",      "\357\274\231",      "\357\275\201",      "\357\275\202", 
        "\357\275\203",      "\357\275\204",      "\357\275\205",      "\357\275\206", 
        "\357\275\207",      "\357\275\210",      "\357\275\211",      "\357\275\212", 
        "\357\275\213",      "\357\275\214",      "\357\275\215",      "\357\275\216", 
        "\357\275\217",      "\357\275\220",      "\357\275\221",      "\357\275\222", 
        "\357\275\223",      "\357\275\224",      "\357\275\225",      "\357\275\226", 
        "\357\275\227",      "\357\275\230",      "\357\275\231",      "\357\275\232", 
        "\357\274\241",      "\357\274\242",      "\357\274\243",      "\357\274\244", 
        "\357\274\245",      "\357\274\246",      "\357\274\247",      "\357\274\250", 
        "\357\274\251",      "\357\274\252",      "\357\274\253",      "\357\274\254", 
        "\357\274\255",      "\357\274\256",      "\357\274\257",      "\357\274\260", 
        "\357\274\261",      "\357\274\262",      "\357\274\263",      "\357\274\264", 
        "\357\274\265",      "\357\274\266",      "\357\274\267",      "\357\274\270", 
        "\357\274\271",      "\357\274\272",      "\343\200\200",      "\342\200\235", 
        "\342\200\231",      "\357\274\217",      "\357\274\234",      "\357\274\236", 
        "\342\200\265",      "\343\200\224",      "\343\200\225",      "\357\275\233", 
        "\357\275\235",      "\357\274\213",      "\357\274\215"};
#line 245 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int FullShapeSymbolInput(int key , ChewingData *pgdata ) 
{ 
  int rtn ;
  char __constr_expr_6[75] ;
  int tmp ;

  {
  {
#line 300
  rtn = InternalSpecialSymbol(key, pgdata, (int )(sizeof(keybuf___0) / sizeof(__constr_expr_6[0])),
                              (char const   *)(keybuf___0), (char const   * const  *)(chibuf___0));
  }
#line 301
  if (rtn == 0) {
    {
#line 302
    rtn = SpecialSymbolInput(key, pgdata);
    }
  }
#line 303
  if (rtn == 0) {
#line 303
    tmp = 1;
  } else {
#line 303
    tmp = 0;
  }
#line 303
  return (tmp);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int EasySymbolInput(int key , ChewingData *pgdata ) 
{ 
  int rtn ;
  int loop ;
  int _index ;
  char wordbuf[8] ;
  int nSpecial ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 311
  nSpecial = 36;
#line 313
  _index = FindEasySymbolIndex((char )key);
  }
#line 314
  if (-1 != _index) {
#line 315
    loop = 0;
    {
#line 315
    while (1) {
      while_continue: /* CIL Label */ ;
#line 315
      if (! (loop < pgdata->static_data.g_easy_symbol_num[_index])) {
#line 315
        goto while_break;
      }
      {
#line 316
      tmp = ueStrSeek(pgdata->static_data.g_easy_symbol_value[_index], (size_t )loop);
#line 316
      ueStrNCpy(wordbuf, (char const   *)tmp, (size_t )1, 1);
#line 320
      rtn = _Inner_InternalSpecialSymbol(key, pgdata, (char )key, (char const   */* const  */)(wordbuf));
#line 315
      loop ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 323
    return (0);
  }
  {
#line 326
  rtn = InternalSpecialSymbol(key, pgdata, nSpecial, G_EASY_SYMBOL_KEY, (char const   * const  *)((char const   **)(pgdata->static_data.g_easy_symbol_value)));
  }
#line 329
  if (rtn == 0) {
    {
#line 330
    rtn = SpecialSymbolInput(key, pgdata);
    }
  }
#line 331
  if (rtn == 0) {
#line 331
    tmp___0 = 1;
  } else {
#line 331
    tmp___0 = 0;
  }
#line 331
  return (tmp___0);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int SymbolChoice(ChewingData *pgdata , int sel_i ) 
{ 
  int kbtype ;
  int i ;
  int symbol_type ;
  int key ;
  ChoiceInfo *pci ;
  AvailInfo *pai ;
  int tmp ;

  {
#line 341
  if (! pgdata->static_data.symbol_table) {
#line 341
    if (pgdata->choiceInfo.isSymbol != 3) {
#line 342
      return (1);
    }
  }
#line 344
  if (pgdata->choiceInfo.isSymbol == 1) {
#line 344
    if (0 == (*(pgdata->static_data.symbol_table + sel_i))->nSymbols) {
#line 346
      symbol_type = 2;
    } else {
#line 348
      symbol_type = pgdata->choiceInfo.isSymbol;
    }
  } else {
#line 348
    symbol_type = pgdata->choiceInfo.isSymbol;
  }
#line 351
  if (symbol_type == 1) {
#line 352
    pci = & pgdata->choiceInfo;
#line 353
    pai = & pgdata->availInfo;
#line 356
    pci->nTotalChoice = 0;
#line 357
    i = 0;
    {
#line 357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 357
      if (! (i < (*(pgdata->static_data.symbol_table + sel_i))->nSymbols)) {
#line 357
        goto while_break;
      }
      {
#line 358
      ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], (char const   *)((*(pgdata->static_data.symbol_table + sel_i))->symbols[i]),
                (size_t )1, 1);
#line 360
      (pci->nTotalChoice) ++;
#line 357
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 362
    pai->avail[0].len = 1;
#line 363
    pai->avail[0].id = -1;
#line 364
    pai->nAvail = 1;
#line 365
    pai->currentAvail = 0;
#line 366
    pci->nChoicePerPage = pgdata->config.candPerPage;
#line 367
    if (! (pci->nTotalChoice > 0)) {
      {
#line 367
      __assert_fail("pci->nTotalChoice > 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                    367U, "SymbolChoice");
      }
    }
#line 368
    pci->nPage = ((pci->nTotalChoice + pci->nChoicePerPage) - 1) / pci->nChoicePerPage;
#line 369
    pci->pageNo = 0;
#line 370
    pci->isSymbol = 2;
  } else {
#line 374
    if (symbol_type == 2) {
#line 375
      if (! (pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen)) {
        {
#line 375
        __assert_fail("pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                      375U, "SymbolChoice");
        }
      }
      {
#line 376
      memmove((void *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor]),
              sizeof(wch_t ) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
      }
    }
    {
#line 381
    pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].wch = (uint16_t )0;
#line 382
    ueStrNCpy((char *)(pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].s), (char const   *)(pgdata->choiceInfo.totalChoiceStr[sel_i]),
              (size_t )1, 1);
#line 386
    key = FindSymbolKey((char const   *)(pgdata->choiceInfo.totalChoiceStr[sel_i]));
    }
#line 387
    if (key) {
#line 387
      pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = (char )key;
    } else {
#line 387
      pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = (char )'0';
    }
    {
#line 389
    tmp = PhoneSeqCursor(pgdata);
#line 389
    pgdata->bUserArrCnnct[tmp] = 0;
#line 390
    ChoiceEndChoice(pgdata);
#line 392
    kbtype = pgdata->zuinData.kbtype;
#line 393
    memset((void *)(& pgdata->zuinData), 0, sizeof(ZuinData ));
#line 394
    pgdata->zuinData.kbtype = kbtype;
    }
#line 396
    if (symbol_type == 2) {
#line 397
      (pgdata->chiSymbolBufLen) ++;
#line 398
      (pgdata->chiSymbolCursor) ++;
    }
#line 401
    pgdata->choiceInfo.isSymbol = 0;
  }
#line 403
  return (1);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int SymbolInput(int key , ChewingData *pgdata ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 408
  tmp___1 = __ctype_b_loc();
  }
#line 408
  if ((int const   )*(*tmp___1 + (int )((char )key)) & 16384) {
#line 408
    if (pgdata->chiSymbolBufLen < 50) {
#line 410
      if (! (pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen)) {
        {
#line 410
        __assert_fail("pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                      410U, "SymbolInput");
        }
      }
      {
#line 411
      memmove((void *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor]),
              sizeof(wch_t ) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
#line 416
      pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].wch = (uint16_t )0;
#line 417
      pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].s[0] = (unsigned char )((char )key);
#line 420
      memmove((void *)(& pgdata->symbolKeyBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]),
              sizeof(pgdata->symbolKeyBuf[0]) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
#line 424
      tmp = toupper(key);
#line 424
      pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] = (char )tmp;
#line 426
      tmp___0 = PhoneSeqCursor(pgdata);
#line 426
      pgdata->bUserArrCnnct[tmp___0] = 0;
#line 427
      (pgdata->chiSymbolCursor) ++;
#line 428
      (pgdata->chiSymbolBufLen) ++;
      }
#line 429
      return (0);
    }
  }
#line 431
  return (1);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int CompInterval(IntervalType const   *a , IntervalType const   *b ) 
{ 
  int cmp ;

  {
#line 436
  cmp = (int )(a->from - b->from);
#line 437
  if (cmp) {
#line 438
    return (cmp);
  }
#line 439
  return ((int )(a->to - b->to));
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int FindIntervalFrom(int from , IntervalType *inte , int nInte ) 
{ 
  int i ;

  {
#line 446
  i = 0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < nInte)) {
#line 446
      goto while_break;
    }
#line 447
    if ((inte + i)->from == from) {
#line 448
      return (i);
    }
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return (-1);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int WriteChiSymbolToBuf(wch_t *csBuf , int csBufLen , ChewingData *pgdata ) 
{ 
  int i ;
  int phoneseq_i ;
  int tmp ;
  int tmp___0 ;

  {
#line 454
  phoneseq_i = 0;
#line 456
  i = 0;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! (i < csBufLen)) {
#line 456
      goto while_break;
    }
    {
#line 457
    tmp___0 = ChewingIsChiAt(i, pgdata);
    }
#line 457
    if (tmp___0) {
      {
#line 462
      memset((void *)(& (csBuf + i)->s), 0, (size_t )7);
#line 463
      ueStrNCpy((char *)((csBuf + i)->s), (char const   *)(& pgdata->phrOut.chiBuf[phoneseq_i]),
                (size_t )1, 1);
#line 466
      tmp = ueBytesFromChar((unsigned char )pgdata->phrOut.chiBuf[phoneseq_i]);
#line 466
      phoneseq_i += tmp;
      }
    } else {
#line 469
      *(csBuf + i) = pgdata->chiSymbolBuf[i];
    }
#line 456
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  return (0);
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int CountReleaseNum(ChewingData *pgdata ) 
{ 
  int remain ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 478
  remain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;
#line 479
  if (remain >= 0) {
#line 480
    return (0);
  }
  {
#line 482
  qsort((void *)(pgdata->preferInterval), (size_t )pgdata->nPrefer, sizeof(IntervalType ),
        (int (*)(void const   * , void const   * ))(& CompInterval));
#line 488
  tmp___0 = ChewingIsChiAt(0, pgdata);
  }
#line 488
  if (! tmp___0) {
#line 489
    i = 0;
    {
#line 489
    while (1) {
      while_continue: /* CIL Label */ ;
#line 489
      if (! (i < pgdata->chiSymbolCursor)) {
#line 489
        goto while_break;
      }
      {
#line 490
      tmp = ChewingIsChiAt(i, pgdata);
      }
#line 490
      if (tmp) {
#line 491
        goto while_break;
      }
#line 489
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 494
    return (i);
  }
  {
#line 497
  i = FindIntervalFrom(0, pgdata->preferInterval, pgdata->nPrefer);
  }
#line 498
  if (i >= 0) {
#line 499
    return (pgdata->preferInterval[i].to - pgdata->preferInterval[i].from);
  }
#line 502
  return (1);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void KillFromLeft(ChewingData *pgdata , int nKill ) 
{ 
  int i ;

  {
#line 509
  i = 0;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! (i < nKill)) {
#line 509
      goto while_break;
    }
    {
#line 510
    ChewingKillChar(pgdata, 0, 1);
#line 509
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 511
  return;
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void CleanAllBuf(ChewingData *pgdata ) 
{ 


  {
  {
#line 516
  pgdata->nPhoneSeq = 0;
#line 517
  memset((void *)(pgdata->phoneSeq), 0, sizeof(pgdata->phoneSeq));
#line 519
  pgdata->chiSymbolBufLen = 0;
#line 520
  memset((void *)(pgdata->chiSymbolBuf), 0, sizeof(pgdata->chiSymbolBuf));
#line 522
  memset((void *)(pgdata->bUserArrBrkpt), 0, sizeof(pgdata->bUserArrBrkpt));
#line 524
  pgdata->nSelect = 0;
#line 526
  pgdata->chiSymbolCursor = 0;
#line 528
  memset((void *)(pgdata->bUserArrCnnct), 0, sizeof(pgdata->bUserArrCnnct));
#line 530
  pgdata->phrOut.nNumCut = 0;
#line 532
  memset((void *)(pgdata->symbolKeyBuf), 0, sizeof(pgdata->symbolKeyBuf));
#line 534
  pgdata->nPrefer = 0;
  }
#line 535
  return;
}
}
#line 537 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int ReleaseChiSymbolBuf(ChewingData *pgdata , ChewingOutput *pgo ) 
{ 
  int throwEnd ;
  uint16_t bufPhoneSeq[51] ;
  char bufWordSeq[301] ;

  {
  {
#line 543
  throwEnd = CountReleaseNum(pgdata);
#line 545
  pgo->nCommitStr = throwEnd;
  }
#line 546
  if (throwEnd) {
    {
#line 551
    WriteChiSymbolToBuf(pgo->commitStr, throwEnd, pgdata);
#line 554
    memcpy((void */* __restrict  */)(bufPhoneSeq), (void const   */* __restrict  */)(pgdata->phoneSeq),
           sizeof(uint16_t ) * (unsigned long )throwEnd);
#line 555
    bufPhoneSeq[throwEnd] = (uint16_t )0;
#line 556
    ueStrNCpy(bufWordSeq, (char const   *)(pgdata->phrOut.chiBuf), (size_t )throwEnd,
              1);
#line 557
    UserUpdatePhrase(pgdata, (uint16_t const   *)(bufPhoneSeq), (char const   *)(bufWordSeq));
#line 559
    KillFromLeft(pgdata, throwEnd);
    }
  }
#line 561
  return (throwEnd);
}
}
#line 566
static int ChewingIsBreakPoint(int cursor , ChewingData *pgdata ) ;
#line 566 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   * const  break_word[39]  = 
#line 566
  {      (char const   */* const  */)"\346\230\257",      (char const   */* const  */)"\347\232\204",      (char const   */* const  */)"\344\272\206",      (char const   */* const  */)"\344\270\215", 
        (char const   */* const  */)"\344\271\237",      (char const   */* const  */)"\350\200\214",      (char const   */* const  */)"\344\275\240",      (char const   */* const  */)"\346\210\221", 
        (char const   */* const  */)"\344\273\226",      (char const   */* const  */)"\350\210\207",      (char const   */* const  */)"\345\256\203",      (char const   */* const  */)"\345\245\271", 
        (char const   */* const  */)"\345\205\266",      (char const   */* const  */)"\345\260\261",      (char const   */* const  */)"\345\222\214",      (char const   */* const  */)"\346\210\226", 
        (char const   */* const  */)"\345\200\221",      (char const   */* const  */)"\346\200\247",      (char const   */* const  */)"\345\223\241",      (char const   */* const  */)"\345\255\220", 
        (char const   */* const  */)"\344\270\212",      (char const   */* const  */)"\344\270\213",      (char const   */* const  */)"\344\270\255",      (char const   */* const  */)"\345\205\247", 
        (char const   */* const  */)"\345\244\226",      (char const   */* const  */)"\345\214\226",      (char const   */* const  */)"\350\200\205",      (char const   */* const  */)"\345\256\266", 
        (char const   */* const  */)"\345\205\222",      (char const   */* const  */)"\345\271\264",      (char const   */* const  */)"\346\234\210",      (char const   */* const  */)"\346\227\245", 
        (char const   */* const  */)"\346\231\202",      (char const   */* const  */)"\345\210\206",      (char const   */* const  */)"\347\247\222",      (char const   */* const  */)"\350\241\227", 
        (char const   */* const  */)"\350\267\257",      (char const   */* const  */)"\346\235\221",      (char const   */* const  */)"\345\234\250"};
#line 564 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int ChewingIsBreakPoint(int cursor , ChewingData *pgdata ) 
{ 
  char buf[7] ;
  int i ;
  int symbols ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *__constr_expr_7[39] ;
  int tmp___2 ;

  {
#line 591
  i = 0;
#line 591
  symbols = 0;
#line 592
  i = 0;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! (i < cursor)) {
#line 592
      goto while_break;
    }
    {
#line 593
    tmp = ChewingIsChiAt(i + symbols, pgdata);
    }
#line 593
    if (! tmp) {
#line 594
      symbols ++;
    }
#line 592
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 595
  tmp___2 = ChewingIsChiAt(i + symbols, pgdata);
  }
#line 595
  if (tmp___2) {
    {
#line 598
    tmp___0 = ueStrSeek((char *)(& pgdata->phrOut.chiBuf), (size_t )cursor);
#line 598
    ueStrNCpy(buf, (char const   *)tmp___0, (size_t )1, 1);
#line 601
    i = 0;
    }
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      if (! ((size_t )i < sizeof(break_word) / sizeof(__constr_expr_7[0]))) {
#line 601
        goto while_break___0;
      }
      {
#line 602
      tmp___1 = strcmp((char const   *)(buf), (char const   *)break_word[i]);
      }
#line 602
      if (! tmp___1) {
#line 603
        return (1);
      }
#line 601
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 596
    return (1);
  }
#line 606
  return (0);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void AutoLearnPhrase(ChewingData *pgdata ) 
{ 
  uint16_t bufPhoneSeq[51] ;
  char bufWordSeq[301] ;
  int i ;
  int from ;
  int len ;
  int prev_pos ;
  int pending ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 614
  prev_pos = 0;
#line 615
  pending = 0;
#line 617
  i = 0;
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! (i < pgdata->nPrefer)) {
#line 617
      goto while_break;
    }
#line 618
    from = pgdata->preferInterval[i].from;
#line 619
    len = pgdata->preferInterval[i].to - from;
#line 620
    if (len == 1) {
      {
#line 620
      tmp___2 = ChewingIsBreakPoint(from, pgdata);
      }
#line 620
      if (tmp___2) {
#line 620
        goto _L;
      } else {
        {
#line 621
        memcpy((void */* __restrict  */)(bufPhoneSeq + prev_pos), (void const   */* __restrict  */)(& pgdata->phoneSeq[from]),
               sizeof(uint16_t ) * (unsigned long )len);
#line 622
        bufPhoneSeq[prev_pos + len] = (uint16_t )0;
#line 623
        tmp = ueStrSeek((char *)(& pgdata->phrOut.chiBuf), (size_t )from);
#line 623
        tmp___0 = ueStrSeek(bufWordSeq, (size_t )prev_pos);
#line 623
        ueStrNCpy(tmp___0, (char const   *)tmp, (size_t )len, 1);
#line 626
        prev_pos += len;
#line 627
        pending = 1;
        }
      }
    } else {
      _L: /* CIL Label */ 
#line 630
      if (pending) {
        {
#line 631
        UserUpdatePhrase(pgdata, (uint16_t const   *)(bufPhoneSeq), (char const   *)(bufWordSeq));
#line 632
        prev_pos = 0;
#line 633
        pending = 0;
        }
      }
      {
#line 635
      memcpy((void */* __restrict  */)(bufPhoneSeq), (void const   */* __restrict  */)(& pgdata->phoneSeq[from]),
             sizeof(uint16_t ) * (unsigned long )len);
#line 636
      bufPhoneSeq[len] = (uint16_t )0;
#line 637
      tmp___1 = ueStrSeek((char *)(& pgdata->phrOut.chiBuf), (size_t )from);
#line 637
      ueStrNCpy(bufWordSeq, (char const   *)tmp___1, (size_t )len, 1);
#line 640
      UserUpdatePhrase(pgdata, (uint16_t const   *)(bufPhoneSeq), (char const   *)(bufWordSeq));
      }
    }
#line 617
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  if (pending) {
    {
#line 644
    UserUpdatePhrase(pgdata, (uint16_t const   *)(bufPhoneSeq), (char const   *)(bufWordSeq));
#line 645
    prev_pos = 0;
#line 646
    pending = 0;
    }
  }
#line 648
  return;
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int AddChi(uint16_t phone , uint16_t phoneAlt , ChewingData *pgdata ) 
{ 
  int i ;
  int cursor ;
  int tmp ;

  {
  {
#line 653
  tmp = PhoneSeqCursor(pgdata);
#line 653
  cursor = tmp;
#line 656
  i = 0;
  }
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
#line 656
    if (! (i < pgdata->nSelect)) {
#line 656
      goto while_break;
    }
#line 657
    if (pgdata->selectInterval[i].from >= cursor) {
#line 658
      (pgdata->selectInterval[i].from) ++;
#line 659
      (pgdata->selectInterval[i].to) ++;
    }
#line 656
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  if (! (pgdata->nPhoneSeq >= cursor)) {
    {
#line 664
    __assert_fail("pgdata->nPhoneSeq >= cursor", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  664U, "AddChi");
    }
  }
  {
#line 665
  memmove((void *)(& pgdata->bUserArrBrkpt[cursor + 2]), (void const   *)(& pgdata->bUserArrBrkpt[cursor + 1]),
          sizeof(int ) * (unsigned long )(pgdata->nPhoneSeq - cursor));
#line 669
  memmove((void *)(& pgdata->bUserArrCnnct[cursor + 2]), (void const   *)(& pgdata->bUserArrCnnct[cursor + 1]),
          sizeof(int ) * (unsigned long )(pgdata->nPhoneSeq - cursor));
#line 675
  memmove((void *)(& pgdata->phoneSeq[cursor + 1]), (void const   *)(& pgdata->phoneSeq[cursor]),
          sizeof(uint16_t ) * (unsigned long )(pgdata->nPhoneSeq - cursor));
#line 679
  pgdata->phoneSeq[cursor] = phone;
#line 680
  memmove((void *)(& pgdata->phoneSeqAlt[cursor + 1]), (void const   *)(& pgdata->phoneSeqAlt[cursor]),
          sizeof(uint16_t ) * (unsigned long )(pgdata->nPhoneSeq - cursor));
#line 684
  pgdata->phoneSeqAlt[cursor] = phoneAlt;
#line 685
  (pgdata->nPhoneSeq) ++;
  }
#line 688
  if (! (pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor)) {
    {
#line 688
    __assert_fail("pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  688U, "AddChi");
    }
  }
  {
#line 689
  memmove((void *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor + 1]), (void const   *)(& pgdata->chiSymbolBuf[pgdata->chiSymbolCursor]),
          sizeof(wch_t ) * (unsigned long )(pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor));
#line 694
  pgdata->chiSymbolBuf[pgdata->chiSymbolCursor].wch = (uint16_t )0;
#line 695
  (pgdata->chiSymbolBufLen) ++;
#line 696
  (pgdata->chiSymbolCursor) ++;
  }
#line 698
  return (0);
}
}
#line 701 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void ShowChewingData(ChewingData *pgdata ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 705
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 705
    (*(pgdata->logger))(pgdata->loggerData, 3, "nPhoneSeq : %d\nphoneSeq  : ", pgdata->nPhoneSeq);
    }
#line 705
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  i = 0;
  {
#line 709
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 709
    if (! (i < pgdata->nPhoneSeq)) {
#line 709
      goto while_break___0;
    }
    {
#line 710
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 710
      (*(pgdata->logger))(pgdata->loggerData, 3, "%hu ", (int )pgdata->phoneSeq[i]);
      }
#line 710
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 709
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 711
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 711
    tmp = PhoneSeqCursor(pgdata);
#line 711
    (*(pgdata->logger))(pgdata->loggerData, 3, "[cursor : %d]\nnSelect : %d\nselectStr       selectInterval\n",
                        tmp, pgdata->nSelect);
    }
#line 711
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 717
  i = 0;
  {
#line 717
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 717
    if (! (i < pgdata->nSelect)) {
#line 717
      goto while_break___3;
    }
    {
#line 718
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 718
      (*(pgdata->logger))(pgdata->loggerData, 3, "  %14s%4d%4d\n", pgdata->selectStr[i],
                          pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);
      }
#line 718
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 717
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 725
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 725
    (*(pgdata->logger))(pgdata->loggerData, 3, "bUserArrCnnct : ");
    }
#line 725
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 726
  i = 0;
  {
#line 726
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 726
    if (! (i <= pgdata->nPhoneSeq)) {
#line 726
      goto while_break___6;
    }
    {
#line 727
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 727
      (*(pgdata->logger))(pgdata->loggerData, 3, "%d ", pgdata->bUserArrCnnct[i]);
      }
#line 727
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 726
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 728
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 728
    (*(pgdata->logger))(pgdata->loggerData, 3, "\n");
    }
#line 728
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 730
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 730
    (*(pgdata->logger))(pgdata->loggerData, 3, "bUserArrBrkpt : ");
    }
#line 730
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 731
  i = 0;
  {
#line 731
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 731
    if (! (i <= pgdata->nPhoneSeq)) {
#line 731
      goto while_break___10;
    }
    {
#line 732
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 732
      (*(pgdata->logger))(pgdata->loggerData, 3, "%d ", pgdata->bUserArrBrkpt[i]);
      }
#line 732
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 731
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 733
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 733
    (*(pgdata->logger))(pgdata->loggerData, 3, "\n");
    }
#line 733
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 735
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 735
    (*(pgdata->logger))(pgdata->loggerData, 3, "bArrBrkpt     : ");
    }
#line 735
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 736
  i = 0;
  {
#line 736
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 736
    if (! (i <= pgdata->nPhoneSeq)) {
#line 736
      goto while_break___14;
    }
    {
#line 737
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 737
      (*(pgdata->logger))(pgdata->loggerData, 3, "%d ", pgdata->bArrBrkpt[i]);
      }
#line 737
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 736
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 738
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 738
    (*(pgdata->logger))(pgdata->loggerData, 3, "\n");
    }
#line 738
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 740
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 740
    (*(pgdata->logger))(pgdata->loggerData, 3, "bChiSym : %d , bSelect : %d\n", pgdata->bChiSym,
                        pgdata->bSelect);
    }
#line 740
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int CallPhrasing(ChewingData *pgdata ) 
{ 
  int i ;
  int ch_count ;
  int tmp ;

  {
  {
#line 749
  ch_count = 0;
#line 751
  memcpy((void */* __restrict  */)(pgdata->bArrBrkpt), (void const   */* __restrict  */)(pgdata->bUserArrBrkpt),
         51UL * sizeof(int ));
#line 755
  memset((void *)(pgdata->bSymbolArrBrkpt), 0, 51UL * sizeof(int ));
#line 759
  i = 0;
  }
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (i < pgdata->chiSymbolBufLen)) {
#line 759
      goto while_break;
    }
    {
#line 760
    tmp = ChewingIsChiAt(i, pgdata);
    }
#line 760
    if (tmp) {
#line 761
      ch_count ++;
    } else {
#line 763
      pgdata->bArrBrkpt[ch_count] = 1;
#line 764
      pgdata->bSymbolArrBrkpt[ch_count] = 1;
    }
#line 759
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 769
  i = 0;
  {
#line 769
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 769
    if (! (i < pgdata->nPhoneSeq)) {
#line 769
      goto while_break___0;
    }
#line 770
    if (pgdata->bArrBrkpt[i]) {
      {
#line 771
      ChewingKillSelectIntervalAcross(i, pgdata);
      }
    }
#line 769
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 775
  ShowChewingData(pgdata);
#line 778
  Phrasing(pgdata);
#line 781
  MakePreferInterval(pgdata);
  }
#line 783
  return (0);
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void Union(int set1 , int set2 , int *parent ) 
{ 
  int tmp ;

  {
#line 789
  if (set1 != set2) {
    {
#line 790
    tmp = max(set1, set2);
#line 790
    *(parent + tmp) = min(set1, set2);
    }
  }
#line 791
  return;
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int SameSet(int set1 , int set2 , int *parent ) 
{ 


  {
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (! (*(parent + set1) != 0)) {
#line 795
      goto while_break;
    }
#line 796
    set1 = *(parent + set1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 798
    if (! (*(parent + set2) != 0)) {
#line 798
      goto while_break___0;
    }
#line 799
    set2 = *(parent + set2);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 801
  return (set1 == set2);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void MakePreferInterval(ChewingData *pgdata ) 
{ 
  int i ;
  int j ;
  int set_no ;
  int belong_set[51] ;
  int parent[51] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 811
  memset((void *)(belong_set), 0, sizeof(int ) * 51UL);
#line 812
  memset((void *)(parent), 0, sizeof(int ) * 51UL);
#line 815
  i = 0;
  }
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (i < pgdata->phrOut.nDispInterval)) {
#line 815
      goto while_break;
    }
#line 816
    j = pgdata->phrOut.dispInterval[i].from;
    {
#line 816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 816
      if (! (j < pgdata->phrOut.dispInterval[i].to)) {
#line 816
        goto while_break___0;
      }
#line 820
      belong_set[j] = i + 1;
#line 816
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 823
  set_no = i + 1;
#line 824
  i = 0;
  {
#line 824
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 824
    if (! (i < pgdata->nPhoneSeq)) {
#line 824
      goto while_break___1;
    }
#line 825
    if (belong_set[i] == 0) {
#line 826
      tmp = set_no;
#line 826
      set_no ++;
#line 826
      belong_set[i] = tmp;
    }
#line 824
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 829
  i = 1;
  {
#line 829
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 829
    if (! (i < pgdata->nPhoneSeq)) {
#line 829
      goto while_break___2;
    }
#line 830
    if (pgdata->bUserArrCnnct[i]) {
      {
#line 831
      Union(belong_set[i - 1], belong_set[i], parent);
      }
    }
#line 829
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 836
  pgdata->nPrefer = 0;
#line 837
  i = 0;
  {
#line 838
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 838
    if (! (i < pgdata->nPhoneSeq)) {
#line 838
      goto while_break___3;
    }
#line 839
    j = i + 1;
    {
#line 839
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 839
      if (! (j < pgdata->nPhoneSeq)) {
#line 839
        goto while_break___4;
      }
      {
#line 840
      tmp___0 = SameSet(belong_set[i], belong_set[j], parent);
      }
#line 840
      if (! tmp___0) {
#line 841
        goto while_break___4;
      }
#line 839
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 843
    pgdata->preferInterval[pgdata->nPrefer].from = i;
#line 844
    pgdata->preferInterval[pgdata->nPrefer].to = j;
#line 845
    (pgdata->nPrefer) ++;
#line 846
    i = j;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 848
  return;
}
}
#line 851 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static void ShiftInterval(ChewingOutput *pgo , ChewingData *pgdata ) 
{ 
  int i ;
  int arrPos[50] ;
  int k ;
  int from ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 853
  k = 0;
#line 855
  i = 0;
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;
#line 855
    if (! (i < pgdata->chiSymbolBufLen)) {
#line 855
      goto while_break;
    }
    {
#line 856
    tmp___0 = ChewingIsChiAt(i, pgdata);
    }
#line 856
    if (tmp___0) {
#line 857
      tmp = k;
#line 857
      k ++;
#line 857
      arrPos[tmp] = i;
    }
#line 855
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  arrPos[k] = i;
#line 862
  pgo->nDispInterval = pgdata->nPrefer;
#line 863
  i = 0;
  {
#line 863
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 863
    if (! (i < pgdata->nPrefer)) {
#line 863
      goto while_break___0;
    }
#line 864
    from = pgdata->preferInterval[i].from;
#line 865
    len = pgdata->preferInterval[i].to - from;
#line 866
    pgo->dispInterval[i].from = arrPos[from];
#line 867
    pgo->dispInterval[i].to = arrPos[from] + len;
#line 863
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 869
  return;
}
}
#line 871 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int MakeOutput(ChewingOutput *pgo , ChewingData *pgdata ) 
{ 
  int chi_i ;
  int chiSymbol_i ;
  int i ;
  int tmp ;
  char const   *p ;
  int j ;
  char const   *tmp___0 ;

  {
  {
#line 876
  memset((void *)(pgo->chiSymbolBuf), 0, sizeof(wch_t ) * 50UL);
#line 879
  chiSymbol_i = 0;
#line 879
  chi_i = chiSymbol_i;
  }
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
#line 879
    if (! (chiSymbol_i < pgdata->chiSymbolBufLen)) {
#line 879
      goto while_break;
    }
#line 883
    if ((int )pgdata->chiSymbolBuf[chiSymbol_i].wch == 0) {
      {
#line 885
      pgo->chiSymbolBuf[chiSymbol_i].wch = (uint16_t )0;
#line 886
      ueStrNCpy((char *)(pgo->chiSymbolBuf[chiSymbol_i].s), (char const   *)(& pgdata->phrOut.chiBuf[chi_i]),
                (size_t )1, 1);
#line 889
      tmp = ueBytesFromChar(pgo->chiSymbolBuf[chiSymbol_i].s[0]);
#line 889
      chi_i += tmp;
      }
    } else {
#line 893
      pgo->chiSymbolBuf[chiSymbol_i] = pgdata->chiSymbolBuf[chiSymbol_i];
    }
#line 879
    chiSymbol_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 898
  pgo->PointStart = (long )pgdata->PointStart;
#line 899
  pgo->PointEnd = (long )pgdata->PointEnd;
#line 902
  pgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;
#line 903
  pgo->chiSymbolCursor = (long )pgdata->chiSymbolCursor;
#line 906
  if (pgdata->zuinData.kbtype >= 9) {
#line 907
    p = (char const   *)(pgdata->zuinData.pinYinData.keySeq);
#line 912
    i = 0;
    {
#line 912
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 912
      if (! (i < 4)) {
#line 912
        goto while_break___0;
      }
#line 914
      j = 0;
      {
#line 914
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 914
        if (! (j < 2)) {
#line 914
          goto while_break___1;
        }
#line 915
        if (*(p + 0)) {
#line 916
          pgo->zuinBuf[i].s[j] = (unsigned char )*(p + 0);
#line 917
          p ++;
        } else {
#line 920
          pgo->zuinBuf[i].s[j] = (unsigned char )'\000';
        }
#line 914
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 923
      pgo->zuinBuf[i].s[2] = (unsigned char )'\000';
#line 912
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 926
    i = 0;
    {
#line 926
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 926
      if (! (i < 4)) {
#line 926
        goto while_break___2;
      }
#line 927
      if (pgdata->zuinData.pho_inx[i] != 0) {
        {
#line 931
        tmp___0 = ueConstStrSeek((char const   *)(zhuin_tab[i] + 2), (size_t )(pgdata->zuinData.pho_inx[i] - 1));
#line 931
        ueStrNCpy((char *)(pgo->zuinBuf[i].s), tmp___0, (size_t )1, 1);
        }
      } else {
#line 937
        pgo->zuinBuf[i].wch = (uint16_t )0;
      }
#line 926
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 941
  ShiftInterval(pgo, pgdata);
#line 942
  memcpy((void */* __restrict  */)(pgo->dispBrkpt), (void const   */* __restrict  */)(pgdata->bUserArrBrkpt),
         sizeof(pgo->dispBrkpt[0]) * 51UL);
#line 945
  pgo->pci = & pgdata->choiceInfo;
#line 946
  pgo->bChiSym = pgdata->bChiSym;
#line 947
  memcpy((void */* __restrict  */)(pgo->selKey), (void const   */* __restrict  */)(pgdata->config.selKey),
         sizeof(pgdata->config.selKey));
#line 948
  pgo->bShowMsg = 0;
  }
#line 949
  return (0);
}
}
#line 952 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int MakeOutputWithRtn(ChewingOutput *pgo , ChewingData *pgdata , int keystrokeRtn ) 
{ 
  int tmp ;

  {
  {
#line 954
  pgo->keystrokeRtn = keystrokeRtn;
#line 955
  tmp = MakeOutput(pgo, pgdata);
  }
#line 955
  return (tmp);
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void MakeOutputAddMsgAndCleanInterval(ChewingOutput *pgo , ChewingData *pgdata ) 
{ 


  {
  {
#line 960
  pgo->bShowMsg = 1;
#line 961
  memcpy((void */* __restrict  */)(pgo->showMsg), (void const   */* __restrict  */)(pgdata->showMsg),
         sizeof(wch_t ) * (unsigned long )pgdata->showMsgLen);
#line 962
  pgo->showMsgLen = pgdata->showMsgLen;
#line 963
  pgo->nDispInterval = 0;
  }
#line 964
  return;
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int AddSelect(ChewingData *pgdata , int sel_i ) 
{ 
  int length ;
  int nSelect ;
  int cursor ;

  {
  {
#line 971
  length = pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;
#line 972
  nSelect = pgdata->nSelect;
#line 975
  ueStrNCpy(pgdata->selectStr[nSelect], (char const   *)(pgdata->choiceInfo.totalChoiceStr[sel_i]),
            (size_t )length, 1);
#line 978
  cursor = PhoneSeqCursor(pgdata);
#line 979
  pgdata->selectInterval[nSelect].from = cursor;
#line 980
  pgdata->selectInterval[nSelect].to = cursor + length;
#line 981
  (pgdata->nSelect) ++;
  }
#line 982
  return (0);
}
}
#line 985 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int CountSelKeyNum(int key , ChewingData *pgdata ) 
{ 
  int i ;

  {
#line 990
  i = 0;
  {
#line 990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 990
    if (! (i < 10)) {
#line 990
      goto while_break;
    }
#line 991
    if (pgdata->config.selKey[i] == key) {
#line 992
      return (i);
    }
#line 990
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 993
  return (-1);
}
}
#line 996 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int CountSymbols(ChewingData *pgdata , int to ) 
{ 
  int chi ;
  int i ;
  int tmp ;

  {
#line 1000
  i = 0;
#line 1000
  chi = i;
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! (i < to)) {
#line 1000
      goto while_break;
    }
    {
#line 1001
    tmp = ChewingIsChiAt(i, pgdata);
    }
#line 1001
    if (tmp) {
#line 1002
      chi ++;
    }
#line 1000
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  return (to - chi);
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int PhoneSeqCursor(ChewingData *pgdata ) 
{ 
  int cursor ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1009
  tmp = CountSymbols(pgdata, pgdata->chiSymbolCursor);
#line 1009
  cursor = pgdata->chiSymbolCursor - tmp;
  }
#line 1010
  if (cursor > 0) {
#line 1010
    tmp___0 = cursor;
  } else {
#line 1010
    tmp___0 = 0;
  }
#line 1010
  return (tmp___0);
}
}
#line 1013 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int ChewingIsChiAt(int chiSymbolCursor , ChewingData *pgdata ) 
{ 
  int tmp ;

  {
#line 1016
  if (chiSymbolCursor < pgdata->chiSymbolBufLen) {
#line 1016
    if (0 <= chiSymbolCursor) {
#line 1016
      if ((int )pgdata->chiSymbolBuf[chiSymbolCursor].wch == 0) {
#line 1016
        tmp = 1;
      } else {
#line 1016
        tmp = 0;
      }
    } else {
#line 1016
      tmp = 0;
    }
  } else {
#line 1016
    tmp = 0;
  }
#line 1016
  return (tmp);
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void RemoveSelectElement(int i , ChewingData *pgdata ) 
{ 


  {
#line 1024
  (pgdata->nSelect) --;
#line 1024
  if (pgdata->nSelect == i) {
#line 1025
    return;
  }
  {
#line 1026
  pgdata->selectInterval[i] = pgdata->selectInterval[pgdata->nSelect];
#line 1027
  strcpy((char */* __restrict  */)(pgdata->selectStr[i]), (char const   */* __restrict  */)(pgdata->selectStr[pgdata->nSelect]));
  }
#line 1028
  return;
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int ChewingKillSelectIntervalAcross(int cursor , ChewingData *pgdata ) 
{ 
  int i ;

  {
#line 1033
  i = 0;
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    if (! (i < pgdata->nSelect)) {
#line 1033
      goto while_break;
    }
#line 1034
    if (pgdata->selectInterval[i].from < cursor) {
#line 1034
      if (pgdata->selectInterval[i].to > cursor) {
        {
#line 1036
        RemoveSelectElement(i, pgdata);
#line 1037
        i --;
        }
      }
    }
#line 1033
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1040
  return (0);
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int KillCharInSelectIntervalAndBrkpt(ChewingData *pgdata , int cursorToKill ) 
{ 
  int i ;

  {
#line 1047
  i = 0;
  {
#line 1047
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1047
    if (! (i < pgdata->nSelect)) {
#line 1047
      goto while_break;
    }
#line 1048
    if (pgdata->selectInterval[i].from <= cursorToKill) {
#line 1048
      if (pgdata->selectInterval[i].to > cursorToKill) {
        {
#line 1050
        RemoveSelectElement(i, pgdata);
#line 1051
        i --;
        }
      } else {
#line 1048
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1053
    if (pgdata->selectInterval[i].from > cursorToKill) {
#line 1054
      (pgdata->selectInterval[i].from) --;
#line 1055
      (pgdata->selectInterval[i].to) --;
    }
#line 1047
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1058
  if (! (pgdata->nPhoneSeq >= cursorToKill)) {
    {
#line 1058
    __assert_fail("pgdata->nPhoneSeq >= cursorToKill", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  1058U, "KillCharInSelectIntervalAndBrkpt");
    }
  }
  {
#line 1059
  memmove((void *)(& pgdata->bUserArrBrkpt[cursorToKill]), (void const   *)(& pgdata->bUserArrBrkpt[cursorToKill + 1]),
          sizeof(int ) * (unsigned long )(pgdata->nPhoneSeq - cursorToKill));
#line 1063
  memmove((void *)(& pgdata->bUserArrCnnct[cursorToKill]), (void const   *)(& pgdata->bUserArrCnnct[cursorToKill + 1]),
          sizeof(int ) * (unsigned long )(pgdata->nPhoneSeq - cursorToKill));
  }
#line 1068
  return (0);
}
}
#line 1071 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int ChewingKillChar(ChewingData *pgdata , int chiSymbolCursorToKill , int minus ) 
{ 
  int tmp ;
  int cursorToKill ;
  int tmp___0 ;

  {
  {
#line 1077
  tmp = pgdata->chiSymbolCursor;
#line 1078
  pgdata->chiSymbolCursor = chiSymbolCursorToKill;
#line 1079
  cursorToKill = PhoneSeqCursor(pgdata);
#line 1080
  pgdata->chiSymbolCursor = tmp;
#line 1081
  tmp___0 = ChewingIsChiAt(chiSymbolCursorToKill, pgdata);
  }
#line 1081
  if (tmp___0) {
    {
#line 1082
    KillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);
    }
#line 1083
    if (! ((pgdata->nPhoneSeq - cursorToKill) - 1 >= 0)) {
      {
#line 1083
      __assert_fail("pgdata->nPhoneSeq - cursorToKill - 1 >= 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                    1083U, "ChewingKillChar");
      }
    }
    {
#line 1084
    memmove((void *)(& pgdata->phoneSeq[cursorToKill]), (void const   *)(& pgdata->phoneSeq[cursorToKill + 1]),
            (unsigned long )((pgdata->nPhoneSeq - cursorToKill) - 1) * sizeof(uint16_t ));
#line 1088
    (pgdata->nPhoneSeq) --;
    }
  }
#line 1090
  pgdata->symbolKeyBuf[chiSymbolCursorToKill] = (char)0;
#line 1091
  if (! (pgdata->chiSymbolBufLen - chiSymbolCursorToKill)) {
    {
#line 1091
    __assert_fail("pgdata->chiSymbolBufLen - chiSymbolCursorToKill", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  1091U, "ChewingKillChar");
    }
  }
  {
#line 1092
  memmove((void *)(& pgdata->chiSymbolBuf[chiSymbolCursorToKill]), (void const   *)(& pgdata->chiSymbolBuf[chiSymbolCursorToKill + 1]),
          (unsigned long )(pgdata->chiSymbolBufLen - chiSymbolCursorToKill) * sizeof(wch_t ));
#line 1096
  (pgdata->chiSymbolBufLen) --;
#line 1097
  pgdata->chiSymbolCursor -= minus;
  }
#line 1098
  if (pgdata->chiSymbolCursor < 0) {
#line 1099
    pgdata->chiSymbolCursor = 0;
  }
#line 1100
  return (0);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int IsPreferIntervalConnted(int cursor , ChewingData *pgdata ) 
{ 
  int i ;

  {
#line 1107
  i = 0;
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! (i < pgdata->nPrefer)) {
#line 1107
      goto while_break;
    }
#line 1108
    if (pgdata->preferInterval[i].from < cursor) {
#line 1108
      if (pgdata->preferInterval[i].to > cursor) {
#line 1111
        return (1);
      }
    }
#line 1107
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1113
  return (0);
}
}
#line 1116 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static char const   * const  symbol_buf[56][50]  = 
#line 1116
  { {        (char const   */* const  */)"0",        (char const   */* const  */)"\303\270",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"[",        (char const   */* const  */)"\343\200\214",        (char const   */* const  */)"\343\200\216",        (char const   */* const  */)"\343\200\212", 
            (char const   */* const  */)"\343\200\210",        (char const   */* const  */)"\343\200\220",        (char const   */* const  */)"\343\200\224",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"]",        (char const   */* const  */)"\343\200\215",        (char const   */* const  */)"\343\200\217",        (char const   */* const  */)"\343\200\213", 
            (char const   */* const  */)"\343\200\211",        (char const   */* const  */)"\343\200\221",        (char const   */* const  */)"\343\200\225",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"{",        (char const   */* const  */)"\357\275\233",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"}",        (char const   */* const  */)"\357\275\235",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"<",        (char const   */* const  */)"\357\274\214",        (char const   */* const  */)"\342\206\220",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)">",        (char const   */* const  */)"\343\200\202",        (char const   */* const  */)"\342\206\222",        (char const   */* const  */)"\357\274\216", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"?",        (char const   */* const  */)"\357\274\237",        (char const   */* const  */)"\302\277",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"!",        (char const   */* const  */)"\357\274\201",        (char const   */* const  */)"\342\205\240",        (char const   */* const  */)"\302\241", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"@",        (char const   */* const  */)"\357\274\240",        (char const   */* const  */)"\342\205\241",        (char const   */* const  */)"\342\212\225", 
            (char const   */* const  */)"\342\212\231",        (char const   */* const  */)"\343\212\243",        (char const   */* const  */)"\357\271\253",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"#",        (char const   */* const  */)"\357\274\203",        (char const   */* const  */)"\342\205\242",        (char const   */* const  */)"\357\271\237", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"$",        (char const   */* const  */)"\357\274\204",        (char const   */* const  */)"\342\205\243",        (char const   */* const  */)"\342\202\254", 
            (char const   */* const  */)"\357\271\251",        (char const   */* const  */)"\357\277\240",        (char const   */* const  */)"\342\210\256",        (char const   */* const  */)"\357\277\241", 
            (char const   */* const  */)"\357\277\245",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"%",        (char const   */* const  */)"\357\274\205",        (char const   */* const  */)"\342\205\244",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"^",        (char const   */* const  */)"\357\270\277",        (char const   */* const  */)"\342\205\245",        (char const   */* const  */)"\357\271\200", 
            (char const   */* const  */)"\357\270\275",        (char const   */* const  */)"\357\270\276",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"&",        (char const   */* const  */)"\357\274\206",        (char const   */* const  */)"\342\205\246",        (char const   */* const  */)"\357\271\240", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"*",        (char const   */* const  */)"\357\274\212",        (char const   */* const  */)"\342\205\247",        (char const   */* const  */)"\303\227", 
            (char const   */* const  */)"\342\200\273",        (char const   */* const  */)"\342\225\263",        (char const   */* const  */)"\357\271\241",        (char const   */* const  */)"\342\230\257", 
            (char const   */* const  */)"\342\230\206",        (char const   */* const  */)"\342\230\205",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"(",        (char const   */* const  */)"\357\274\210",        (char const   */* const  */)"\342\205\250",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)")",        (char const   */* const  */)"\357\274\211",        (char const   */* const  */)"\342\205\251",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"_",        (char const   */* const  */)"\357\274\277",        (char const   */* const  */)"\342\200\246",        (char const   */* const  */)"\342\200\245", 
            (char const   */* const  */)"\342\206\220",        (char const   */* const  */)"\342\206\222",        (char const   */* const  */)"\357\271\215",        (char const   */* const  */)"\357\271\211", 
            (char const   */* const  */)"\313\215",        (char const   */* const  */)"\357\277\243",        (char const   */* const  */)"\342\200\223",        (char const   */* const  */)"\342\200\224", 
            (char const   */* const  */)"\302\257",        (char const   */* const  */)"\357\271\212",        (char const   */* const  */)"\357\271\216",        (char const   */* const  */)"\357\271\217", 
            (char const   */* const  */)"\357\271\243",        (char const   */* const  */)"\357\274\215",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"+",        (char const   */* const  */)"\357\274\213",        (char const   */* const  */)"\302\261",        (char const   */* const  */)"\357\271\242", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"=",        (char const   */* const  */)"\357\274\235",        (char const   */* const  */)"\342\211\222",        (char const   */* const  */)"\342\211\240", 
            (char const   */* const  */)"\342\211\241",        (char const   */* const  */)"\342\211\246",        (char const   */* const  */)"\342\211\247",        (char const   */* const  */)"\357\271\246", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"`",        (char const   */* const  */)"\343\200\217",        (char const   */* const  */)"\343\200\216",        (char const   */* const  */)"\342\200\262", 
            (char const   */* const  */)"\342\200\265",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"~",        (char const   */* const  */)"\357\275\236",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)":",        (char const   */* const  */)"\357\274\232",        (char const   */* const  */)"\357\274\233",        (char const   */* const  */)"\357\270\260", 
            (char const   */* const  */)"\357\271\225",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"\"",        (char const   */* const  */)"\357\274\233",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"\'",        (char const   */* const  */)"\343\200\201",        (char const   */* const  */)"\342\200\246",        (char const   */* const  */)"\342\200\245", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"\\",        (char const   */* const  */)"\357\274\274",        (char const   */* const  */)"\342\206\226",        (char const   */* const  */)"\342\206\230", 
            (char const   */* const  */)"\357\271\250",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"-",        (char const   */* const  */)"\357\274\215",        (char const   */* const  */)"\357\274\277",        (char const   */* const  */)"\357\277\243", 
            (char const   */* const  */)"\302\257",        (char const   */* const  */)"\313\215",        (char const   */* const  */)"\342\200\223",        (char const   */* const  */)"\342\200\224", 
            (char const   */* const  */)"\342\200\245",        (char const   */* const  */)"\342\200\246",        (char const   */* const  */)"\342\206\220",        (char const   */* const  */)"\342\206\222", 
            (char const   */* const  */)"\342\225\264",        (char const   */* const  */)"\357\271\211",        (char const   */* const  */)"\357\271\212",        (char const   */* const  */)"\357\271\215", 
            (char const   */* const  */)"\357\271\216",        (char const   */* const  */)"\357\271\217",        (char const   */* const  */)"\357\271\243",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"/",        (char const   */* const  */)"\357\274\217",        (char const   */* const  */)"\303\267",        (char const   */* const  */)"\342\206\227", 
            (char const   */* const  */)"\342\206\231",        (char const   */* const  */)"\342\210\225",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"|",        (char const   */* const  */)"\342\206\221",        (char const   */* const  */)"\342\206\223",        (char const   */* const  */)"\342\210\243", 
            (char const   */* const  */)"\342\210\245",        (char const   */* const  */)"\357\270\261",        (char const   */* const  */)"\357\270\263",        (char const   */* const  */)"\357\270\264", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"A",        (char const   */* const  */)"\303\205",        (char const   */* const  */)"\316\221",        (char const   */* const  */)"\316\261", 
            (char const   */* const  */)"\342\224\234",        (char const   */* const  */)"\342\225\240",        (char const   */* const  */)"\342\225\237",        (char const   */* const  */)"\342\225\236", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"B",        (char const   */* const  */)"\316\222",        (char const   */* const  */)"\316\262",        (char const   */* const  */)"\342\210\265", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"C",        (char const   */* const  */)"\316\247",        (char const   */* const  */)"\317\207",        (char const   */* const  */)"\342\224\230", 
            (char const   */* const  */)"\342\225\257",        (char const   */* const  */)"\342\225\235",        (char const   */* const  */)"\342\225\234",        (char const   */* const  */)"\342\225\233", 
            (char const   */* const  */)"\343\217\204",        (char const   */* const  */)"\342\204\203",        (char const   */* const  */)"\343\216\235",        (char const   */* const  */)"\342\231\243", 
            (char const   */* const  */)"\302\251",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"D",        (char const   */* const  */)"\316\224",        (char const   */* const  */)"\316\264",        (char const   */* const  */)"\342\227\207", 
            (char const   */* const  */)"\342\227\206",        (char const   */* const  */)"\342\224\244",        (char const   */* const  */)"\342\225\243",        (char const   */* const  */)"\342\225\242", 
            (char const   */* const  */)"\342\225\241",        (char const   */* const  */)"\342\231\246",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"E",        (char const   */* const  */)"\316\225",        (char const   */* const  */)"\316\265",        (char const   */* const  */)"\342\224\220", 
            (char const   */* const  */)"\342\225\256",        (char const   */* const  */)"\342\225\227",        (char const   */* const  */)"\342\225\223",        (char const   */* const  */)"\342\225\225", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"F",        (char const   */* const  */)"\316\246",        (char const   */* const  */)"\317\210",        (char const   */* const  */)"\342\224\202", 
            (char const   */* const  */)"\342\225\221",        (char const   */* const  */)"\342\231\200",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"G",        (char const   */* const  */)"\316\223",        (char const   */* const  */)"\316\263",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"H",        (char const   */* const  */)"\316\227",        (char const   */* const  */)"\316\267",        (char const   */* const  */)"\342\231\245", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"I",        (char const   */* const  */)"\316\231",        (char const   */* const  */)"\316\271",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"J",        (char const   */* const  */)"\317\206",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"K",        (char const   */* const  */)"\316\232",        (char const   */* const  */)"\316\272",        (char const   */* const  */)"\343\216\236", 
            (char const   */* const  */)"\343\217\216",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"L",        (char const   */* const  */)"\316\233",        (char const   */* const  */)"\316\273",        (char const   */* const  */)"\343\217\222", 
            (char const   */* const  */)"\343\217\221",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"M",        (char const   */* const  */)"\316\234",        (char const   */* const  */)"\316\274",        (char const   */* const  */)"\342\231\202", 
            (char const   */* const  */)"\342\204\223",        (char const   */* const  */)"\343\216\216",        (char const   */* const  */)"\343\217\225",        (char const   */* const  */)"\343\216\234", 
            (char const   */* const  */)"\343\216\241",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"N",        (char const   */* const  */)"\316\235",        (char const   */* const  */)"\316\275",        (char const   */* const  */)"\342\204\226", 
            (char const   */* const  */)0}, 
   {        (char const   */* const  */)"O",        (char const   */* const  */)"\316\237",        (char const   */* const  */)"\316\277",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"P",        (char const   */* const  */)"\316\240",        (char const   */* const  */)"\317\200",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"Q",        (char const   */* const  */)"\316\230",        (char const   */* const  */)"\316\270",        (char const   */* const  */)"\320\224", 
            (char const   */* const  */)"\342\224\214",        (char const   */* const  */)"\342\225\255",        (char const   */* const  */)"\342\225\224",        (char const   */* const  */)"\342\225\223", 
            (char const   */* const  */)"\342\225\222",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"R",        (char const   */* const  */)"\316\241",        (char const   */* const  */)"\317\201",        (char const   */* const  */)"\342\224\200", 
            (char const   */* const  */)"\342\225\220",        (char const   */* const  */)"\302\256",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"S",        (char const   */* const  */)"\316\243",        (char const   */* const  */)"\317\203",        (char const   */* const  */)"\342\210\264", 
            (char const   */* const  */)"\342\226\241",        (char const   */* const  */)"\342\226\240",        (char const   */* const  */)"\342\224\274",        (char const   */* const  */)"\342\225\254", 
            (char const   */* const  */)"\342\225\252",        (char const   */* const  */)"\342\225\253",        (char const   */* const  */)"\342\210\253",        (char const   */* const  */)"\302\247", 
            (char const   */* const  */)"\342\231\240",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"T",        (char const   */* const  */)"\316\244",        (char const   */* const  */)"\317\204",        (char const   */* const  */)"\316\270", 
            (char const   */* const  */)"\342\226\263",        (char const   */* const  */)"\342\226\262",        (char const   */* const  */)"\342\226\275",        (char const   */* const  */)"\342\226\274", 
            (char const   */* const  */)"\342\204\242",        (char const   */* const  */)"\342\212\277",        (char const   */* const  */)"\342\204\242",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"U",        (char const   */* const  */)"\316\245",        (char const   */* const  */)"\317\205",        (char const   */* const  */)"\316\274", 
            (char const   */* const  */)"\342\210\252",        (char const   */* const  */)"\342\210\251",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"V",        (char const   */* const  */)"\316\275",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"W",        (char const   */* const  */)"\342\204\246",        (char const   */* const  */)"\317\211",        (char const   */* const  */)"\342\224\254", 
            (char const   */* const  */)"\342\225\246",        (char const   */* const  */)"\342\225\244",        (char const   */* const  */)"\342\225\245",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"X",        (char const   */* const  */)"\316\236",        (char const   */* const  */)"\316\276",        (char const   */* const  */)"\342\224\264", 
            (char const   */* const  */)"\342\225\251",        (char const   */* const  */)"\342\225\247",        (char const   */* const  */)"\342\225\250",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"Y",        (char const   */* const  */)"\316\250",        (char const   */* const  */)0}, 
   {        (char const   */* const  */)"Z",        (char const   */* const  */)"\316\226",        (char const   */* const  */)"\316\266",        (char const   */* const  */)"\342\224\224", 
            (char const   */* const  */)"\342\225\260",        (char const   */* const  */)"\342\225\232",        (char const   */* const  */)"\342\225\231",        (char const   */* const  */)"\342\225\230", 
            (char const   */* const  */)0}};
#line 1268 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static int FindSymbolKey(char const   *symbol ) 
{ 
  unsigned int i ;
  char const   * const  *buf ;
  int tmp ;
  char const   *__constr_expr_8[56][50] ;

  {
#line 1272
  i = 0U;
  {
#line 1272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1272
    if (! ((unsigned long )i < sizeof(symbol_buf) / sizeof(__constr_expr_8[0]))) {
#line 1272
      goto while_break;
    }
#line 1273
    buf = symbol_buf[i];
    {
#line 1273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1273
      if (! *buf) {
#line 1273
        goto while_break___0;
      }
      {
#line 1274
      tmp = strcmp((char const   *)*buf, symbol);
      }
#line 1274
      if (0 == tmp) {
#line 1275
        return ((int )*(symbol_buf[i][0]));
      }
#line 1273
      buf ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1278
  return (0);
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int OpenSymbolChoice(ChewingData *pgdata ) 
{ 
  int i ;
  int symbol_buf_len ;
  char const   *__constr_expr_9[56][50] ;
  char const   * const  *pBuf ;
  ChoiceInfo *pci ;
  int tmp ;

  {
#line 1283
  symbol_buf_len = (int )(sizeof(symbol_buf) / sizeof(__constr_expr_9[0]));
#line 1285
  pci = & pgdata->choiceInfo;
#line 1286
  pci->oldChiSymbolCursor = pgdata->chiSymbolCursor;
#line 1289
  if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {
#line 1290
    (pgdata->chiSymbolCursor) --;
  }
#line 1291
  if ((int )pgdata->symbolKeyBuf[pgdata->chiSymbolCursor] == 49) {
    {
#line 1292
    pgdata->bSelect = 1;
#line 1293
    HaninSymbolInput(pgdata);
    }
#line 1294
    return (0);
  }
#line 1296
  i = 0;
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1296
    if (! (i < symbol_buf_len)) {
#line 1296
      goto while_break;
    }
#line 1297
    if ((int const   )*(symbol_buf[i][0] + 0) == (int const   )pgdata->symbolKeyBuf[pgdata->chiSymbolCursor]) {
#line 1299
      pBuf = symbol_buf[i];
#line 1300
      goto while_break;
    }
#line 1296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  if (i == symbol_buf_len) {
    {
#line 1304
    ChoiceEndChoice(pgdata);
    }
#line 1305
    return (0);
  }
#line 1307
  pci->nTotalChoice = 0;
#line 1308
  i = 1;
  {
#line 1308
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1308
    if (! *(pBuf + i)) {
#line 1308
      goto while_break___0;
    }
    {
#line 1309
    tmp = ueStrLen((char const   *)*(pBuf + i));
#line 1309
    ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], (char const   *)*(pBuf + i),
              (size_t )tmp, 1);
#line 1311
    (pci->nTotalChoice) ++;
#line 1308
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1314
  pci->nChoicePerPage = pgdata->config.candPerPage;
#line 1315
  if (! (pci->nTotalChoice > 0)) {
    {
#line 1315
    __assert_fail("pci->nTotalChoice > 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c",
                  1315U, "OpenSymbolChoice");
    }
  }
#line 1316
  pci->nPage = ((pci->nTotalChoice + pci->nChoicePerPage) - 1) / pci->nChoicePerPage;
#line 1317
  pci->pageNo = 0;
#line 1318
  pci->isSymbol = 3;
#line 1320
  pgdata->bSelect = 1;
#line 1321
  pgdata->availInfo.nAvail = 1;
#line 1322
  pgdata->availInfo.currentAvail = 0;
#line 1323
  pgdata->availInfo.avail[0].id = -1;
#line 1324
  pgdata->availInfo.avail[0].len = 1;
#line 1325
  return (0);
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static unsigned int const   MAX_SYMBOL_ENTRY  =    (unsigned int const   )100;
#line 1331 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static unsigned long const   LINE_LEN  =    (size_t const   )512;
#line 1328 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int InitSymbolTable(ChewingData *pgdata , char const   *prefix ) 
{ 
  char *filename ;
  FILE *file ;
  char *line ;
  SymbolEntry **entry ;
  char *category_end ;
  char const   *symbols ;
  char const   *symbols_end ;
  char const   *symbol ;
  size_t i ;
  size_t len ;
  size_t size ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 1333
  filename = (char *)((void *)0);
#line 1334
  file = (FILE *)((void *)0);
#line 1335
  line = (char *)((void *)0);
#line 1336
  entry = (SymbolEntry **)((void *)0);
#line 1344
  ret = -1;
#line 1346
  pgdata->static_data.n_symbol_entry = 0U;
#line 1347
  pgdata->static_data.symbol_table = (SymbolEntry **)((void *)0);
#line 1349
  ret = asprintf((char **/* __restrict  */)(& filename), (char const   */* __restrict  */)"%s/%s",
                 prefix, "symbols.dat");
  }
#line 1351
  if (ret == -1) {
#line 1352
    goto error;
  }
  {
#line 1354
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 1355
  if (! file) {
#line 1356
    goto error;
  }
  {
#line 1358
  tmp = calloc((size_t )LINE_LEN, sizeof(char ));
#line 1358
  line = (char *)tmp;
  }
#line 1359
  if (! line) {
#line 1360
    goto error;
  }
  {
#line 1362
  tmp___0 = calloc((size_t )MAX_SYMBOL_ENTRY, sizeof(SymbolEntry *));
#line 1362
  entry = (SymbolEntry **)tmp___0;
  }
#line 1363
  if (! entry) {
#line 1364
    goto error;
  }
  {
#line 1366
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1366
    tmp___6 = fgets((char */* __restrict  */)line, (int )LINE_LEN, (FILE */* __restrict  */)file);
    }
#line 1366
    if (tmp___6) {
#line 1366
      if (! (pgdata->static_data.n_symbol_entry < (unsigned int )MAX_SYMBOL_ENTRY)) {
#line 1366
        goto while_break;
      }
    } else {
#line 1366
      goto while_break;
    }
    {
#line 1369
    category_end = strpbrk((char const   *)line, "=\r\n");
    }
#line 1370
    if (! category_end) {
#line 1371
      goto error;
    }
    {
#line 1373
    symbols = (char const   *)(category_end + 1);
#line 1374
    tmp___1 = strpbrk(symbols, "\r\n");
#line 1374
    symbols_end = (char const   *)tmp___1;
    }
#line 1375
    if (symbols_end) {
      {
#line 1376
      tmp___2 = ueStrLen(symbols);
#line 1376
      len = (size_t )tmp___2;
#line 1378
      tmp___3 = malloc(sizeof(*(*(entry + 0) + 0)) + sizeof((*(entry + 0) + 0)->symbols[0]) * len);
#line 1378
      *(entry + pgdata->static_data.n_symbol_entry) = (SymbolEntry *)tmp___3;
      }
#line 1381
      if (! *(entry + pgdata->static_data.n_symbol_entry)) {
#line 1382
        goto error;
      }
#line 1383
      (*(entry + pgdata->static_data.n_symbol_entry))->nSymbols = (int )len;
#line 1386
      symbol = symbols;
#line 1388
      i = (size_t )0;
      {
#line 1388
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1388
        if (! (i < len)) {
#line 1388
          goto while_break___0;
        }
        {
#line 1389
        ueStrNCpy((*(entry + pgdata->static_data.n_symbol_entry))->symbols[i], symbol,
                  (size_t )1, 1);
#line 1393
        tmp___4 = ueBytesFromChar((unsigned char )*(symbol + 0));
#line 1393
        symbol += tmp___4;
#line 1388
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 1398
      tmp___5 = malloc(sizeof(*(*(entry + 0) + 0)));
#line 1398
      *(entry + pgdata->static_data.n_symbol_entry) = (SymbolEntry *)tmp___5;
      }
#line 1400
      if (! *(entry + pgdata->static_data.n_symbol_entry)) {
#line 1401
        goto error;
      }
#line 1403
      (*(entry + pgdata->static_data.n_symbol_entry))->nSymbols = 0;
    }
    {
#line 1407
    *category_end = (char)0;
#line 1408
    ueStrNCpy((*(entry + pgdata->static_data.n_symbol_entry))->category, (char const   *)line,
              (size_t )11, 1);
#line 1412
    (pgdata->static_data.n_symbol_entry) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1415
  size = sizeof(*(pgdata->static_data.symbol_table)) * (unsigned long )pgdata->static_data.n_symbol_entry;
#line 1417
  tmp___7 = malloc(size);
#line 1417
  pgdata->static_data.symbol_table = (SymbolEntry **)tmp___7;
  }
#line 1418
  if (! pgdata->static_data.symbol_table) {
#line 1419
    goto error;
  }
  {
#line 1420
  memcpy((void */* __restrict  */)pgdata->static_data.symbol_table, (void const   */* __restrict  */)entry,
         size);
#line 1422
  ret = 0;
  }
  end: 
  {
#line 1424
  free((void *)entry);
#line 1425
  free((void *)line);
#line 1426
  fclose(file);
#line 1427
  free((void *)filename);
  }
#line 1428
  return (ret);
  error: 
#line 1431
  i = (size_t )0;
  {
#line 1431
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1431
    if (! (i < (size_t )pgdata->static_data.n_symbol_entry)) {
#line 1431
      goto while_break___1;
    }
    {
#line 1432
    free((void *)*(entry + i));
#line 1431
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1434
  goto end;
}
}
#line 1437 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void TerminateSymbolTable(ChewingData *pgdata ) 
{ 
  unsigned int i ;

  {
#line 1440
  if (pgdata->static_data.symbol_table) {
#line 1441
    i = 0U;
    {
#line 1441
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1441
      if (! (i < pgdata->static_data.n_symbol_entry)) {
#line 1441
        goto while_break;
      }
      {
#line 1442
      free((void *)*(pgdata->static_data.symbol_table + i));
#line 1441
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1443
    free((void *)pgdata->static_data.symbol_table);
#line 1444
    pgdata->static_data.n_symbol_entry = 0U;
#line 1445
    pgdata->static_data.symbol_table = (SymbolEntry **)((void *)0);
    }
  }
#line 1447
  return;
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
static unsigned long const   LINE_LEN___0  =    (size_t const   )512;
#line 1449 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
int InitEasySymbolInput(ChewingData *pgdata , char const   *prefix ) 
{ 
  FILE *file ;
  char *filename ;
  char *line ;
  int len ;
  int _index ;
  char *symbol ;
  int ret ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1453
  file = (FILE *)((void *)0);
#line 1454
  filename = (char *)((void *)0);
#line 1455
  line = (char *)((void *)0);
#line 1459
  ret = -1;
#line 1461
  ret = asprintf((char **/* __restrict  */)(& filename), (char const   */* __restrict  */)"%s/%s",
                 prefix, "swkb.dat");
  }
#line 1463
  if (ret == -1) {
#line 1464
    goto end;
  }
  {
#line 1466
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 1467
  if (! file) {
#line 1468
    goto end;
  }
  {
#line 1470
  tmp = calloc((size_t )LINE_LEN___0, sizeof(char ));
#line 1470
  line = (char *)tmp;
  }
#line 1471
  if (! line) {
#line 1472
    goto end;
  }
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1474
    tmp___3 = fgets((char */* __restrict  */)line, (int )LINE_LEN___0, (FILE */* __restrict  */)file);
    }
#line 1474
    if (! tmp___3) {
#line 1474
      goto while_break;
    }
#line 1475
    if (32 != (int )*(line + 1)) {
#line 1476
      goto while_continue;
    }
    {
#line 1479
    tmp___0 = strcspn((char const   *)line, "\r\n");
#line 1479
    len = (int )tmp___0;
#line 1481
    *(line + len) = (char )'\000';
#line 1483
    _index = FindEasySymbolIndex(*(line + 0));
    }
#line 1484
    if (-1 == _index) {
#line 1485
      goto while_continue;
    }
    {
#line 1487
    len = ueStrLen((char const   *)(line + 2));
    }
#line 1488
    if (0 == len) {
#line 1489
      goto while_continue;
    } else
#line 1488
    if (len > 11) {
#line 1489
      goto while_continue;
    }
    {
#line 1491
    tmp___1 = strlen((char const   *)(line + 2));
#line 1491
    tmp___2 = calloc(tmp___1 + 1UL, sizeof(char ));
#line 1491
    symbol = (char *)tmp___2;
    }
#line 1492
    if (! symbol) {
#line 1493
      goto end;
    }
    {
#line 1495
    ueStrNCpy(symbol, (char const   *)(line + 2), (size_t )len, 1);
#line 1497
    free((void *)pgdata->static_data.g_easy_symbol_value[_index]);
#line 1498
    pgdata->static_data.g_easy_symbol_value[_index] = symbol;
#line 1499
    pgdata->static_data.g_easy_symbol_num[_index] = len;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1501
  ret = 0;
  end: 
  {
#line 1503
  free((void *)line);
#line 1504
  fclose(file);
#line 1505
  free((void *)filename);
  }
#line 1506
  return (ret);
}
}
#line 1509 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingutil.c"
void TerminateEasySymbolTable(ChewingData *pgdata ) 
{ 
  unsigned int i ;

  {
#line 1512
  i = 0U;
  {
#line 1512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1512
    if (! (i < 36U)) {
#line 1512
      goto while_break;
    }
#line 1513
    if ((unsigned long )((void *)0) != (unsigned long )pgdata->static_data.g_easy_symbol_value[i]) {
      {
#line 1514
      free((void *)pgdata->static_data.g_easy_symbol_value[i]);
#line 1515
      pgdata->static_data.g_easy_symbol_value[i] = (char *)((void *)0);
      }
    }
#line 1517
    pgdata->static_data.g_easy_symbol_num[i] = 0;
#line 1512
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1519
  return;
}
}
#line 41 "../include/internal/zuin-private.h"
int ZuinPhoInput(ChewingData *pgdata , int key ) ;
#line 42
int ZuinRemoveLast(ZuinData *pZuin ) ;
#line 43
int ZuinRemoveAll(ZuinData *pZuin ) ;
#line 25 "../include/internal/char-private.h"
int GetCharFirst(ChewingData *pgdata , Word *wrd_ptr , uint16_t phoneid ) ;
#line 30 "../include/internal/pinyin-private.h"
int PinyinToZuin(ChewingData *pgdata , char const   *pinyinKeySeq , char *zuinKeySeq ,
                 char *zuinKeySeqAlt ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsHsuPhoEndKey(int const   *pho_inx , int key ) 
{ 
  int tmp ;

  {
  {
#line 46
  if (key == 32) {
#line 46
    goto case_32;
  }
#line 46
  if (key == 106) {
#line 46
    goto case_32;
  }
#line 46
  if (key == 102) {
#line 46
    goto case_32;
  }
#line 46
  if (key == 100) {
#line 46
    goto case_32;
  }
#line 46
  if (key == 115) {
#line 46
    goto case_32;
  }
#line 48
  goto switch_default;
  case_32: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_115: /* CIL Label */ 
#line 47
  if (*(pho_inx + 0)) {
#line 47
    tmp = 1;
  } else
#line 47
  if (*(pho_inx + 1)) {
#line 47
    tmp = 1;
  } else
#line 47
  if (*(pho_inx + 2)) {
#line 47
    tmp = 1;
  } else {
#line 47
    tmp = 0;
  }
#line 47
  return (tmp);
  switch_default: /* CIL Label */ 
#line 49
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsET26PhoEndKey(int const   *pho_inx , int key ) 
{ 
  int tmp ;

  {
  {
#line 61
  if (key == 32) {
#line 61
    goto case_32;
  }
#line 61
  if (key == 107) {
#line 61
    goto case_32;
  }
#line 61
  if (key == 106) {
#line 61
    goto case_32;
  }
#line 61
  if (key == 102) {
#line 61
    goto case_32;
  }
#line 61
  if (key == 100) {
#line 61
    goto case_32;
  }
#line 63
  goto switch_default;
  case_32: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_100: /* CIL Label */ 
#line 62
  if (*(pho_inx + 0)) {
#line 62
    tmp = 1;
  } else
#line 62
  if (*(pho_inx + 1)) {
#line 62
    tmp = 1;
  } else
#line 62
  if (*(pho_inx + 2)) {
#line 62
    tmp = 1;
  } else {
#line 62
    tmp = 0;
  }
#line 62
  return (tmp);
  switch_default: /* CIL Label */ 
#line 64
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsDACHENCP26PhoEndKey(int const   *pho_inx , int key ) 
{ 
  int tmp ;

  {
  {
#line 76
  if (key == 32) {
#line 76
    goto case_32;
  }
#line 76
  if (key == 121) {
#line 76
    goto case_32;
  }
#line 76
  if (key == 100) {
#line 76
    goto case_32;
  }
#line 76
  if (key == 114) {
#line 76
    goto case_32;
  }
#line 76
  if (key == 101) {
#line 76
    goto case_32;
  }
#line 78
  goto switch_default;
  case_32: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_101: /* CIL Label */ 
#line 77
  if (*(pho_inx + 0)) {
#line 77
    tmp = 1;
  } else
#line 77
  if (*(pho_inx + 1)) {
#line 77
    tmp = 1;
  } else
#line 77
  if (*(pho_inx + 2)) {
#line 77
    tmp = 1;
  } else {
#line 77
    tmp = 0;
  }
#line 77
  return (tmp);
  switch_default: /* CIL Label */ 
#line 79
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsDefPhoEndKey(int key , int kbtype ) 
{ 
  int tmp ;

  {
  {
#line 85
  tmp = PhoneInxFromKey(key, 3, kbtype, 1);
  }
#line 85
  if (tmp) {
#line 86
    return (1);
  }
#line 88
  if (key == 32) {
#line 89
    return (1);
  }
#line 90
  return (0);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int EndKeyProcess(ChewingData *pgdata , int key , int searchTimes ) 
{ 
  ZuinData *pZuin ;
  uint16_t u16Pho ;
  uint16_t u16PhoAlt ;
  Word tempword ;
  int pho_inx ;
  int tmp ;
  int tmp___0 ;

  {
#line 95
  pZuin = & pgdata->zuinData;
#line 100
  if (pZuin->pho_inx[0] == 0) {
#line 100
    if (pZuin->pho_inx[1] == 0) {
#line 100
      if (pZuin->pho_inx[2] == 0) {
#line 100
        if (pZuin->pho_inx[3] == 0) {
#line 111
          if (key == 32) {
#line 111
            tmp = 4;
          } else {
#line 111
            tmp = 16;
          }
#line 111
          return (tmp);
        }
      }
    }
  }
  {
#line 114
  pho_inx = PhoneInxFromKey(key, 3, pZuin->kbtype, searchTimes);
  }
#line 115
  if (pZuin->pho_inx[3] == 0) {
#line 116
    pZuin->pho_inx[3] = pho_inx;
#line 117
    pZuin->pho_inx_alt[3] = pho_inx;
  } else
#line 119
  if (key != 32) {
#line 120
    pZuin->pho_inx[3] = pho_inx;
#line 121
    pZuin->pho_inx_alt[3] = pho_inx;
#line 122
    return (16);
  }
  {
#line 125
  u16Pho = UintFromPhoneInx((int const   *)(pZuin->pho_inx));
#line 126
  tmp___0 = GetCharFirst(pgdata, & tempword, u16Pho);
  }
#line 126
  if (tmp___0 == 0) {
    {
#line 127
    ZuinRemoveAll(pZuin);
    }
#line 128
    return (16);
  }
#line 131
  pZuin->phone = u16Pho;
#line 133
  if (pZuin->pho_inx_alt[0] == 0) {
#line 133
    if (pZuin->pho_inx_alt[1] == 0) {
#line 133
      if (pZuin->pho_inx_alt[2] == 0) {
#line 137
        pZuin->phoneAlt = u16Pho;
      } else {
        {
#line 140
        u16PhoAlt = UintFromPhoneInx((int const   *)(pZuin->pho_inx_alt));
#line 141
        pZuin->phoneAlt = u16PhoAlt;
        }
      }
    } else {
      {
#line 140
      u16PhoAlt = UintFromPhoneInx((int const   *)(pZuin->pho_inx_alt));
#line 141
      pZuin->phoneAlt = u16PhoAlt;
      }
    }
  } else {
    {
#line 140
    u16PhoAlt = UintFromPhoneInx((int const   *)(pZuin->pho_inx_alt));
#line 141
    pZuin->phoneAlt = u16PhoAlt;
    }
  }
  {
#line 144
  memset((void *)(pZuin->pho_inx), 0, sizeof(pZuin->pho_inx));
#line 145
  memset((void *)(pZuin->pho_inx_alt), 0, sizeof(pZuin->pho_inx_alt));
  }
#line 146
  return (2);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int DefPhoInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int type ;
  int inx ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 151
  pZuin = & pgdata->zuinData;
#line 152
  type = 0;
#line 152
  inx = 0;
#line 155
  tmp___0 = IsDefPhoEndKey(key, pZuin->kbtype);
  }
#line 155
  if (tmp___0) {
#line 156
    i = 0;
    {
#line 156
    while (1) {
      while_continue: /* CIL Label */ ;
#line 156
      if (! (i < 4)) {
#line 156
        goto while_break;
      }
#line 157
      if (pZuin->pho_inx[i] != 0) {
#line 158
        goto while_break;
      }
#line 156
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 159
    if (i < 4) {
      {
#line 160
      tmp = EndKeyProcess(pgdata, key, 1);
      }
#line 160
      return (tmp);
    }
  } else {
#line 163
    pZuin->pho_inx[3] = 0;
  }
#line 167
  type = 0;
  {
#line 167
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! (type <= 3)) {
#line 167
      goto while_break___0;
    }
    {
#line 168
    inx = PhoneInxFromKey(key, type, pZuin->kbtype, 1);
    }
#line 169
    if (inx) {
#line 170
      goto while_break___0;
    }
#line 167
    type ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  if (type > 3) {
#line 175
    return (4);
  }
#line 179
  pZuin->pho_inx[type] = inx;
#line 180
  return (1);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int HsuPhoInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int type ;
  int searchTimes ;
  int inx ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 185
  pZuin = & pgdata->zuinData;
#line 186
  type = 0;
#line 186
  searchTimes = 0;
#line 186
  inx = 0;
#line 189
  tmp___1 = IsHsuPhoEndKey((int const   *)(pZuin->pho_inx), key);
  }
#line 189
  if (tmp___1) {
#line 190
    if (pZuin->pho_inx[1] == 0) {
#line 190
      if (pZuin->pho_inx[2] == 0) {
#line 192
        if (12 <= pZuin->pho_inx[0]) {
#line 192
          if (pZuin->pho_inx[0] <= 14) {
#line 193
            pZuin->pho_inx[0] += 3;
          } else {
#line 192
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 196
        if (pZuin->pho_inx[0] == 11) {
#line 197
          pZuin->pho_inx[0] = 0;
#line 198
          pZuin->pho_inx[2] = 2;
        } else
#line 201
        if (pZuin->pho_inx[0] == 9) {
#line 202
          pZuin->pho_inx[0] = 0;
#line 203
          pZuin->pho_inx[2] = 3;
        } else
#line 206
        if (pZuin->pho_inx[0] == 3) {
#line 207
          pZuin->pho_inx[0] = 0;
#line 208
          pZuin->pho_inx[2] = 9;
        } else
#line 211
        if (pZuin->pho_inx[0] == 7) {
#line 212
          pZuin->pho_inx[0] = 0;
#line 213
          pZuin->pho_inx[2] = 10;
        } else
#line 216
        if (pZuin->pho_inx[0] == 10) {
#line 217
          pZuin->pho_inx[0] = 0;
#line 218
          pZuin->pho_inx[2] = 11;
        } else
#line 221
        if (pZuin->pho_inx[0] == 8) {
#line 222
          pZuin->pho_inx[0] = 0;
#line 223
          pZuin->pho_inx[2] = 13;
        }
      }
    }
#line 227
    if (pZuin->pho_inx[0] == 9) {
#line 227
      if (pZuin->pho_inx[1] == 1) {
#line 231
        pZuin->pho_inx[0] = 12;
      } else
#line 227
      if (pZuin->pho_inx[1] == 3) {
#line 231
        pZuin->pho_inx[0] = 12;
      }
    }
#line 234
    if (key == 106) {
#line 234
      searchTimes = 3;
    } else {
#line 234
      searchTimes = 2;
    }
    {
#line 236
    tmp = EndKeyProcess(pgdata, key, searchTimes);
    }
#line 236
    return (tmp);
  } else {
#line 240
    type = 0;
#line 240
    searchTimes = 1;
    {
#line 240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 240
      if (! (type < 3)) {
#line 240
        goto while_break;
      }
      {
#line 241
      inx = PhoneInxFromKey(key, type, pZuin->kbtype, searchTimes);
      }
#line 242
      if (! (! inx)) {
#line 244
        if (type == 0) {
#line 245
          if (pZuin->pho_inx[0]) {
#line 247
            searchTimes = 2;
          } else
#line 245
          if (pZuin->pho_inx[1]) {
#line 247
            searchTimes = 2;
          } else {
#line 250
            goto while_break;
          }
        } else
#line 252
        if (type == 1) {
#line 252
          if (inx == 1) {
#line 253
            if (pZuin->pho_inx[1]) {
#line 254
              searchTimes = 2;
            } else {
#line 257
              goto while_break;
            }
          } else {
#line 260
            goto while_break;
          }
        } else {
#line 260
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 240
      type ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 263
    if (type == 1) {
#line 263
      if (inx == 2) {
#line 263
        if (12 <= pZuin->pho_inx[0]) {
#line 263
          if (pZuin->pho_inx[0] <= 14) {
#line 268
            pZuin->pho_inx[0] += 3;
          }
        }
      }
    }
#line 272
    if (pZuin->pho_inx[0] == 9) {
#line 272
      if (pZuin->pho_inx[1] == 1) {
#line 275
        pZuin->pho_inx[0] = 12;
      } else
#line 272
      if (pZuin->pho_inx[1] == 3) {
#line 275
        pZuin->pho_inx[0] = 12;
      }
    }
#line 279
    if (type == 2) {
#line 279
      if (pZuin->pho_inx[1] == 0) {
#line 279
        if (12 <= pZuin->pho_inx[0]) {
#line 279
          if (pZuin->pho_inx[0] <= 14) {
#line 284
            pZuin->pho_inx[0] += 3;
          }
        }
      }
    }
#line 287
    if (type == 3) {
      {
#line 288
      tmp___0 = __ctype_b_loc();
      }
#line 288
      if ((int const   )*(*tmp___0 + key) & 1024) {
#line 289
        return (16);
      }
#line 290
      return (4);
    }
#line 293
    pZuin->pho_inx[type] = inx;
#line 294
    return (1);
  }
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int ET26PhoInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int type ;
  int searchTimes ;
  int inx ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 301
  pZuin = & pgdata->zuinData;
#line 302
  type = 0;
#line 302
  searchTimes = 0;
#line 302
  inx = 0;
#line 304
  tmp___1 = IsET26PhoEndKey((int const   *)(pZuin->pho_inx), key);
  }
#line 304
  if (tmp___1) {
#line 305
    if (pZuin->pho_inx[1] == 0) {
#line 305
      if (pZuin->pho_inx[2] == 0) {
#line 307
        if (pZuin->pho_inx[0] == 12) {
#line 308
          pZuin->pho_inx[0] += 3;
        } else
#line 307
        if (pZuin->pho_inx[0] == 14) {
#line 308
          pZuin->pho_inx[0] += 3;
        } else
#line 311
        if (pZuin->pho_inx[0] == 2) {
#line 312
          pZuin->pho_inx[0] = 0;
#line 313
          pZuin->pho_inx[2] = 8;
        } else
#line 316
        if (pZuin->pho_inx[0] == 3) {
#line 317
          pZuin->pho_inx[0] = 0;
#line 318
          pZuin->pho_inx[2] = 9;
        } else
#line 321
        if (pZuin->pho_inx[0] == 7) {
#line 322
          pZuin->pho_inx[0] = 0;
#line 323
          pZuin->pho_inx[2] = 10;
        } else
#line 326
        if (pZuin->pho_inx[0] == 6) {
#line 327
          pZuin->pho_inx[0] = 0;
#line 328
          pZuin->pho_inx[2] = 11;
        } else
#line 331
        if (pZuin->pho_inx[0] == 8) {
#line 332
          pZuin->pho_inx[0] = 0;
#line 333
          pZuin->pho_inx[2] = 12;
        } else
#line 336
        if (pZuin->pho_inx[0] == 11) {
#line 337
          pZuin->pho_inx[0] = 0;
#line 338
          pZuin->pho_inx[2] = 13;
        }
      }
    }
    {
#line 341
    searchTimes = 2;
#line 342
    tmp = EndKeyProcess(pgdata, key, searchTimes);
    }
#line 342
    return (tmp);
  } else {
#line 346
    type = 0;
#line 346
    searchTimes = 1;
    {
#line 346
    while (1) {
      while_continue: /* CIL Label */ ;
#line 346
      if (! (type < 3)) {
#line 346
        goto while_break;
      }
      {
#line 347
      inx = PhoneInxFromKey(key, type, pZuin->kbtype, searchTimes);
      }
#line 348
      if (! (! inx)) {
#line 350
        if (type == 0) {
#line 351
          if (pZuin->pho_inx[0]) {
#line 353
            searchTimes = 2;
          } else
#line 351
          if (pZuin->pho_inx[1]) {
#line 353
            searchTimes = 2;
          } else {
#line 356
            goto while_break;
          }
        } else {
#line 359
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 346
      type ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 362
    if (type == 1) {
#line 363
      if (inx == 2) {
#line 364
        if (pZuin->pho_inx[0] == 12) {
#line 367
          pZuin->pho_inx[0] += 3;
        } else
#line 364
        if (pZuin->pho_inx[0] == 14) {
#line 367
          pZuin->pho_inx[0] += 3;
        }
      } else
#line 372
      if (pZuin->pho_inx[0] == 9) {
#line 373
        pZuin->pho_inx[0] = 13;
      }
    }
#line 378
    if (type == 2) {
#line 378
      if (pZuin->pho_inx[1] == 0) {
#line 378
        if (pZuin->pho_inx[0] == 12) {
#line 382
          pZuin->pho_inx[0] += 3;
        } else
#line 378
        if (pZuin->pho_inx[0] == 14) {
#line 382
          pZuin->pho_inx[0] += 3;
        }
      }
    }
#line 385
    if (type == 3) {
      {
#line 386
      tmp___0 = __ctype_b_loc();
      }
#line 386
      if ((int const   )*(*tmp___0 + key) & 1024) {
#line 387
        return (16);
      }
#line 388
      return (4);
    }
#line 391
    pZuin->pho_inx[type] = inx;
#line 392
    return (1);
  }
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int SwitchingBetween(int *pho_idx , int a , int b ) 
{ 


  {
#line 397
  if (*pho_idx == a) {
#line 398
    *pho_idx = b;
#line 399
    return (1);
  } else
#line 400
  if (*pho_idx == b) {
#line 401
    *pho_idx = a;
#line 402
    return (1);
  }
#line 404
  return (0);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int DACHENCP26PhoInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int type ;
  int searchTimes ;
  int inx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;

  {
  {
#line 409
  pZuin = & pgdata->zuinData;
#line 410
  type = 0;
#line 410
  searchTimes = 0;
#line 410
  inx = 0;
#line 412
  tmp___8 = IsDACHENCP26PhoEndKey((int const   *)(pZuin->pho_inx), key);
  }
#line 412
  if (tmp___8) {
    {
#line 413
    searchTimes = 2;
#line 414
    tmp = EndKeyProcess(pgdata, key, searchTimes);
    }
#line 414
    return (tmp);
  } else {
#line 418
    type = 0;
#line 418
    searchTimes = 1;
    {
#line 418
    while (1) {
      while_continue: /* CIL Label */ ;
#line 418
      if (! (type < 3)) {
#line 418
        goto while_break;
      }
      {
#line 419
      inx = PhoneInxFromKey(key, type, pZuin->kbtype, searchTimes);
      }
#line 420
      if (! (! inx)) {
#line 422
        if (type == 0) {
#line 423
          goto while_break;
#line 424
          if (pZuin->pho_inx[0]) {
#line 426
            searchTimes = 2;
          } else
#line 424
          if (pZuin->pho_inx[1]) {
#line 426
            searchTimes = 2;
          } else {
#line 429
            goto while_break;
          }
        } else {
#line 432
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 418
      type ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 435
    if (key == 113) {
      {
#line 436
      tmp___0 = SwitchingBetween(& pZuin->pho_inx[0], 1, 2);
      }
#line 436
      if (tmp___0) {
#line 437
        return (1);
      }
    } else
#line 441
    if (key == 119) {
      {
#line 442
      tmp___1 = SwitchingBetween(& pZuin->pho_inx[0], 5, 6);
      }
#line 442
      if (tmp___1) {
#line 443
        return (1);
      }
    } else
#line 447
    if (key == 116) {
      {
#line 448
      tmp___2 = SwitchingBetween(& pZuin->pho_inx[0], 15, 16);
      }
#line 448
      if (tmp___2) {
#line 449
        return (1);
      }
    } else
#line 453
    if (key == 98) {
#line 454
      if (pZuin->pho_inx[0] != 0) {
#line 455
        pZuin->pho_inx[2] = 4;
#line 456
        return (1);
      } else
#line 454
      if (pZuin->pho_inx[1] != 0) {
#line 455
        pZuin->pho_inx[2] = 4;
#line 456
        return (1);
      }
    } else
#line 460
    if (key == 110) {
#line 461
      if (pZuin->pho_inx[0] != 0) {
#line 462
        pZuin->pho_inx[2] = 12;
#line 463
        return (1);
      } else
#line 461
      if (pZuin->pho_inx[1] != 0) {
#line 462
        pZuin->pho_inx[2] = 12;
#line 463
        return (1);
      }
    } else
#line 467
    if (key == 117) {
#line 468
      if (pZuin->pho_inx[1] == 1) {
#line 468
        if (pZuin->pho_inx[2] != 1) {
#line 469
          pZuin->pho_inx[1] = 0;
#line 470
          pZuin->pho_inx[2] = 1;
#line 471
          return (1);
        } else {
#line 468
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 473
      if (pZuin->pho_inx[1] != 1) {
#line 473
        if (pZuin->pho_inx[2] == 1) {
#line 474
          pZuin->pho_inx[1] = 1;
#line 475
          return (1);
        } else {
#line 473
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 477
      if (pZuin->pho_inx[1] == 1) {
#line 477
        if (pZuin->pho_inx[2] == 1) {
#line 478
          pZuin->pho_inx[1] = 0;
#line 479
          pZuin->pho_inx[2] = 0;
#line 480
          return (1);
        } else {
#line 477
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 482
      if (pZuin->pho_inx[1] != 0) {
#line 483
        pZuin->pho_inx[2] = 1;
#line 484
        return (1);
      }
    } else
#line 488
    if (key == 109) {
#line 489
      if (pZuin->pho_inx[1] == 3) {
#line 489
        if (pZuin->pho_inx[2] != 8) {
#line 490
          pZuin->pho_inx[1] = 0;
#line 491
          pZuin->pho_inx[2] = 8;
#line 492
          return (1);
        } else {
#line 489
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 494
      if (pZuin->pho_inx[1] != 3) {
#line 494
        if (pZuin->pho_inx[2] == 8) {
#line 495
          pZuin->pho_inx[1] = 3;
#line 496
          pZuin->pho_inx[2] = 0;
#line 497
          return (1);
        } else {
#line 494
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 499
      if (pZuin->pho_inx[1] != 0) {
#line 500
        pZuin->pho_inx[2] = 8;
#line 501
        return (1);
      }
    } else
#line 505
    if (key == 105) {
      {
#line 506
      tmp___3 = SwitchingBetween(& pZuin->pho_inx[2], 2, 5);
      }
#line 506
      if (tmp___3) {
#line 507
        return (1);
      }
    } else
#line 511
    if (key == 111) {
      {
#line 512
      tmp___4 = SwitchingBetween(& pZuin->pho_inx[2], 6, 9);
      }
#line 512
      if (tmp___4) {
#line 513
        return (1);
      }
    } else
#line 517
    if (key == 108) {
      {
#line 518
      tmp___5 = SwitchingBetween(& pZuin->pho_inx[2], 7, 11);
      }
#line 518
      if (tmp___5) {
#line 519
        return (1);
      }
    } else
#line 523
    if (key == 112) {
      {
#line 524
      tmp___6 = SwitchingBetween(& pZuin->pho_inx[2], 10, 13);
      }
#line 524
      if (tmp___6) {
#line 525
        return (1);
      }
    }
#line 528
    if (type == 3) {
      {
#line 529
      tmp___7 = __ctype_b_loc();
      }
#line 529
      if ((int const   )*(*tmp___7 + key) & 1024) {
#line 530
        return (16);
      }
#line 531
      return (4);
    }
#line 534
    pZuin->pho_inx[type] = inx;
#line 535
    return (1);
  }
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsPinYinEndKey(int key ) 
{ 


  {
#line 541
  if (key == 32) {
#line 543
    return (1);
  } else
#line 541
  if (key == 49) {
#line 543
    return (1);
  } else
#line 541
  if (key == 50) {
#line 543
    return (1);
  } else
#line 541
  if (key == 51) {
#line 543
    return (1);
  } else
#line 541
  if (key == 52) {
#line 543
    return (1);
  } else
#line 541
  if (key == 53) {
#line 543
    return (1);
  }
#line 545
  return (0);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int IsSymbolKey(int key ) 
{ 


  {
#line 550
  if (key < 97) {
#line 551
    return (1);
  } else
#line 550
  if (key > 122) {
#line 551
    return (1);
  }
#line 554
  return (0);
}
}
#line 557 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
static int PinYinInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int err ;
  unsigned int i ;
  char zuinKeySeq[5] ;
  char zuinKeySeqAlt[5] ;
  char buf[2] ;
  size_t len ;
  int tmp ;
  int type ;
  int inx ;
  int type___0 ;
  int inx___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 559
  pZuin = & pgdata->zuinData;
#line 560
  err = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 565
    (*(pgdata->logger))(pgdata->loggerData, 1, "[ File: %s  Func: %s  Line: %d ]\n",
                        "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c",
                        "PinYinInput", 565);
    }
#line 565
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  if ((int )pZuin->pinYinData.keySeq[0] == 0) {
    {
#line 567
    tmp = IsSymbolKey(key);
    }
#line 567
    if (tmp) {
#line 568
      return (4);
    }
  }
  {
#line 571
  tmp___1 = IsPinYinEndKey(key);
  }
#line 571
  if (tmp___1) {
    {
#line 572
    err = PinyinToZuin(pgdata, (char const   *)(pZuin->pinYinData.keySeq), zuinKeySeq,
                       zuinKeySeqAlt);
    }
#line 574
    if (err) {
#line 575
      pZuin->pinYinData.keySeq[0] = (char )'\000';
#line 576
      return (1);
    }
    {
#line 579
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 579
      (*(pgdata->logger))(pgdata->loggerData, 3, "zuinKeySeq: %s\n", zuinKeySeq);
      }
#line 579
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 580
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 580
      (*(pgdata->logger))(pgdata->loggerData, 3, "zuinKeySeqAlt: %s\n", zuinKeySeqAlt);
      }
#line 580
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 582
    len = strlen((char const   *)(zuinKeySeq));
#line 583
    i = 0U;
    }
    {
#line 583
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 583
      if (! ((size_t )i < len)) {
#line 583
        goto while_break___2;
      }
#line 584
      type = 0;
#line 584
      inx = 0;
#line 585
      type = 0;
      {
#line 585
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 585
        if (! (type <= 3)) {
#line 585
          goto while_break___3;
        }
        {
#line 586
        inx = PhoneInxFromKey((int )zuinKeySeq[i], type, pZuin->kbtype, 1);
        }
#line 588
        if (inx) {
#line 589
          goto while_break___3;
        }
#line 585
        type ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 593
      if (type > 3) {
#line 594
        return (4);
      }
#line 597
      pZuin->pho_inx[type] = inx;
#line 583
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 601
    len = strlen((char const   *)(zuinKeySeqAlt));
#line 602
    i = 0U;
    }
    {
#line 602
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 602
      if (! ((size_t )i < len)) {
#line 602
        goto while_break___4;
      }
#line 603
      type___0 = 0;
#line 603
      inx___0 = 0;
#line 604
      type___0 = 0;
      {
#line 604
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 604
        if (! (type___0 <= 3)) {
#line 604
          goto while_break___5;
        }
        {
#line 605
        inx___0 = PhoneInxFromKey((int )zuinKeySeqAlt[i], type___0, pZuin->kbtype,
                                  1);
        }
#line 607
        if (inx___0) {
#line 608
          goto while_break___5;
        }
#line 604
        type___0 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 612
      if (type___0 > 3) {
#line 613
        return (4);
      }
#line 616
      pZuin->pho_inx_alt[type___0] = inx___0;
#line 602
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 621
    if (key == 49) {
#line 621
      goto case_49;
    }
#line 624
    if (key == 50) {
#line 624
      goto case_50;
    }
#line 627
    if (key == 53) {
#line 627
      goto case_53;
    }
#line 620
    goto switch_break;
    case_49: /* CIL Label */ 
#line 622
    key = ' ';
#line 623
    goto switch_break;
    case_50: /* CIL Label */ 
#line 625
    key = '6';
#line 626
    goto switch_break;
    case_53: /* CIL Label */ 
#line 628
    key = '7';
    switch_break: /* CIL Label */ ;
    }
    {
#line 630
    pZuin->pinYinData.keySeq[0] = (char )'\000';
#line 631
    tmp___0 = EndKeyProcess(pgdata, key, 1);
    }
#line 631
    return (tmp___0);
  }
  {
#line 633
  buf[0] = (char )key;
#line 633
  buf[1] = (char )'\000';
#line 634
  strcat((char */* __restrict  */)(pZuin->pinYinData.keySeq), (char const   */* __restrict  */)(buf));
  }
  {
#line 636
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 636
    (*(pgdata->logger))(pgdata->loggerData, 3, "PinYin Seq: %s\n", pZuin->pinYinData.keySeq);
    }
#line 636
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 638
  return (1);
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
int ZuinPhoInput(ChewingData *pgdata , int key ) 
{ 
  ZuinData *pZuin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 644
  pZuin = & pgdata->zuinData;
  {
#line 647
  if (pZuin->kbtype == 7) {
#line 647
    goto case_7;
  }
#line 647
  if (pZuin->kbtype == 1) {
#line 647
    goto case_7;
  }
#line 650
  if (pZuin->kbtype == 5) {
#line 650
    goto case_5;
  }
#line 653
  if (pZuin->kbtype == 8) {
#line 653
    goto case_8;
  }
#line 658
  if (pZuin->kbtype == 11) {
#line 658
    goto case_11;
  }
#line 658
  if (pZuin->kbtype == 10) {
#line 658
    goto case_11;
  }
#line 658
  if (pZuin->kbtype == 9) {
#line 658
    goto case_11;
  }
#line 661
  goto switch_default;
  case_7: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 648
  tmp = HsuPhoInput(pgdata, key);
  }
#line 648
  return (tmp);
#line 649
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 651
  tmp___0 = ET26PhoInput(pgdata, key);
  }
#line 651
  return (tmp___0);
#line 652
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 654
  tmp___1 = DACHENCP26PhoInput(pgdata, key);
  }
#line 654
  return (tmp___1);
#line 655
  goto switch_break;
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
#line 659
  tmp___2 = PinYinInput(pgdata, key);
  }
#line 659
  return (tmp___2);
#line 660
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 662
  tmp___3 = DefPhoInput(pgdata, key);
  }
#line 662
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
#line 664
  return (8);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
int ZuinRemoveLast(ZuinData *pZuin ) 
{ 
  int i ;
  size_t tmp ;

  {
#line 671
  if (pZuin->kbtype >= 9) {
    {
#line 672
    tmp = strlen((char const   *)(pZuin->pinYinData.keySeq));
#line 672
    i = (int )tmp;
#line 673
    pZuin->pinYinData.keySeq[i - 1] = (char )'\000';
    }
  } else {
#line 675
    i = 3;
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 675
      if (! (i >= 0)) {
#line 675
        goto while_break;
      }
#line 676
      if (pZuin->pho_inx[i]) {
#line 677
        pZuin->pho_inx[i] = 0;
#line 678
        return (0);
      }
#line 675
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 682
  return (0);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
int ZuinRemoveAll(ZuinData *pZuin ) 
{ 


  {
  {
#line 688
  memset((void *)(pZuin->pho_inx), 0, sizeof(pZuin->pho_inx));
#line 689
  memset((void *)(pZuin->pinYinData.keySeq), 0, sizeof(pZuin->pinYinData.keySeq));
  }
#line 690
  return (0);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/zuin.c"
int ZuinIsEntering(ZuinData *pZuin ) 
{ 
  int i ;

  {
#line 696
  if (pZuin->kbtype >= 9) {
#line 697
    if (pZuin->pinYinData.keySeq[0]) {
#line 698
      return (1);
    }
  } else {
#line 700
    i = 0;
    {
#line 700
    while (1) {
      while_continue: /* CIL Label */ ;
#line 700
      if (! (i < 4)) {
#line 700
        goto while_break;
      }
#line 701
      if (pZuin->pho_inx[i]) {
#line 702
        return (1);
      }
#line 700
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 704
  return (0);
}
}
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 978
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 29 "../../../src/porting_layer/include/plat_mmap.h"
int plat_mmap_is_valid(plat_mmap *handle ) ;
#line 41
unsigned int plat_mmap_get_page_size(void) ;
#line 44
unsigned int plat_mmap_get_alloc_granularity(void) ;
#line 47
void plat_mmap_unmap(plat_mmap *handle ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
void plat_mmap_set_invalid(plat_mmap *handle ) 
{ 


  {
#line 28
  if (! handle) {
#line 29
    return;
  }
#line 31
  handle->fd = -1;
#line 32
  handle->address = (void *)0;
#line 33
  handle->fAccessAttr = 0;
#line 34
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
int plat_mmap_is_valid(plat_mmap *handle ) 
{ 


  {
#line 40
  if (! handle) {
#line 41
    return (0);
  }
#line 43
  return (handle->fd != -1);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
size_t plat_mmap_create(plat_mmap *handle , char const   *file , int fileAccessAttr ) 
{ 
  size_t sizet ;
  __off_t tmp ;

  {
#line 52
  if (! handle) {
#line 53
    return ((size_t )0);
  }
#line 55
  handle->address = (void *)0;
#line 56
  handle->sizet = (size_t )0;
#line 58
  if (1 & fileAccessAttr) {
    {
#line 59
    handle->fd = open(file, 0);
    }
  } else {
    {
#line 61
    handle->fd = open(file, 2);
    }
  }
#line 63
  if (handle->fd == -1) {
#line 64
    return ((size_t )0);
  }
  {
#line 66
  tmp = lseek(handle->fd, (__off_t )0, 2);
#line 66
  sizet = (size_t )tmp;
#line 67
  lseek(handle->fd, (__off_t )0, 0);
  }
#line 69
  return (sizet);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
void *plat_mmap_set_view(plat_mmap *handle , size_t *offset , size_t *sizet ) 
{ 
  size_t pagesize ;
  int tmp ;
  size_t edge ;
  size_t tmp___0 ;

  {
  {
#line 75
  tmp = getpagesize();
#line 75
  pagesize = (size_t )tmp;
  }
#line 79
  if (! handle) {
#line 80
    return ((void *)0);
  }
#line 82
  if (handle->address) {
    {
#line 83
    munmap(handle->address, handle->sizet);
    }
  }
  {
#line 85
  edge = *sizet + *offset;
#line 86
  *offset = (*offset / pagesize) * pagesize;
#line 87
  tmp___0 = edge - *offset;
#line 87
  *sizet = tmp___0;
#line 87
  handle->sizet = tmp___0;
#line 88
  handle->address = mmap((void *)0, *sizet, 1, 1, handle->fd, (__off_t )*offset);
  }
#line 96
  return (handle->address);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
void plat_mmap_close(plat_mmap *handle ) 
{ 


  {
#line 103
  if (! handle) {
#line 104
    return;
  }
#line 106
  if (handle->address) {
    {
#line 107
    munmap(handle->address, handle->sizet);
#line 108
    handle->address = (void *)0;
    }
  }
#line 111
  if (handle->fd != -1) {
    {
#line 112
    close(handle->fd);
#line 113
    handle->fd = -1;
    }
  }
#line 115
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
unsigned int plat_mmap_get_page_size(void) 
{ 
  int tmp ;

  {
  {
#line 120
  tmp = getpagesize();
  }
#line 120
  return ((unsigned int )tmp);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
unsigned int plat_mmap_get_alloc_granularity(void) 
{ 
  int tmp ;

  {
  {
#line 126
  tmp = getpagesize();
  }
#line 126
  return ((unsigned int )(16 * tmp));
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_mmap_posix.c"
void plat_mmap_unmap(plat_mmap *handle ) 
{ 


  {
#line 132
  if (! handle) {
#line 133
    return;
  }
#line 135
  if (handle->address) {
    {
#line 136
    munmap(handle->address, handle->sizet);
#line 137
    handle->address = (void *)0;
    }
  }
#line 139
  return;
}
}
#line 67 "../include/internal/userphrase-private.h"
UserPhraseData *UserGetPhraseFirst(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ) ;
#line 76
UserPhraseData *UserGetPhraseNext(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ) ;
#line 23 "../include/internal/tree-private.h"
int TreeFindPhrase(ChewingData *pgdata , int begin , int end , uint16_t const   *phoneSeq ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
static int LoadOriginalFreq(ChewingData *pgdata , uint16_t const   *phoneSeq , char const   *wordSeq ,
                            int len ) 
{ 
  int pho_id ;
  int retval ;
  Phrase *phrase ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 30
  tmp = calloc((size_t )1, sizeof(Phrase ));
#line 30
  phrase = (Phrase *)tmp;
#line 32
  pho_id = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);
  }
#line 33
  if (pho_id != -1) {
    {
#line 34
    GetPhraseFirst(pgdata, phrase, pho_id);
    }
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 37
      tmp___0 = strcmp((char const   *)(phrase->phrase), wordSeq);
      }
#line 37
      if (! tmp___0) {
        {
#line 40
        retval = phrase->freq;
#line 41
        free((void *)phrase);
        }
#line 42
        return (retval);
      }
      {
#line 35
      tmp___1 = GetPhraseNext(pgdata, phrase);
      }
#line 35
      if (! tmp___1) {
#line 35
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 47
  free((void *)phrase);
  }
#line 48
  return (1);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
static int LoadMaxFreq(ChewingData *pgdata , uint16_t const   *phoneSeq , int len ) 
{ 
  int pho_id ;
  Phrase *phrase ;
  void *tmp ;
  int maxFreq ;
  UserPhraseData *uphrase ;
  int tmp___0 ;

  {
  {
#line 55
  tmp = calloc((size_t )1, sizeof(Phrase ));
#line 55
  phrase = (Phrase *)tmp;
#line 56
  maxFreq = 1;
#line 59
  pho_id = TreeFindPhrase(pgdata, 0, len - 1, phoneSeq);
  }
#line 60
  if (pho_id != -1) {
    {
#line 61
    GetPhraseFirst(pgdata, phrase, pho_id);
    }
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      if (phrase->freq > maxFreq) {
#line 64
        maxFreq = phrase->freq;
      }
      {
#line 62
      tmp___0 = GetPhraseNext(pgdata, phrase);
      }
#line 62
      if (! tmp___0) {
#line 62
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 67
  free((void *)phrase);
#line 69
  uphrase = UserGetPhraseFirst(pgdata, phoneSeq);
  }
  {
#line 70
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 70
    if (! uphrase) {
#line 70
      goto while_break___0;
    }
#line 71
    if (uphrase->userfreq > maxFreq) {
#line 72
      maxFreq = uphrase->userfreq;
    }
    {
#line 73
    uphrase = UserGetPhraseNext(pgdata, phoneSeq);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 76
  return (maxFreq);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
static int UpdateFreq(int freq , int maxfreq , int origfreq , int deltatime ) 
{ 
  int delta ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 85
  if (deltatime < 4000) {
#line 86
    if (freq >= maxfreq) {
      {
#line 86
      tmp = min((maxfreq - origfreq) / 5 + 1, 10);
#line 86
      delta = tmp;
      }
    } else {
      {
#line 86
      tmp___0 = max((maxfreq - origfreq) / 5 + 1, 10);
#line 86
      delta = tmp___0;
      }
    }
    {
#line 93
    tmp___1 = min(freq + delta, 99999999);
    }
#line 93
    return (tmp___1);
  } else
#line 96
  if (deltatime < 50000) {
#line 97
    if (freq >= maxfreq) {
      {
#line 97
      tmp___2 = min((maxfreq - origfreq) / 10 + 1, 5);
#line 97
      delta = tmp___2;
      }
    } else {
      {
#line 97
      tmp___3 = max((maxfreq - origfreq) / 10 + 1, 5);
#line 97
      delta = tmp___3;
      }
    }
    {
#line 104
    tmp___4 = min(freq + delta, 99999999);
    }
#line 104
    return (tmp___4);
  } else {
    {
#line 108
    delta = max((freq - origfreq) / 5, 10);
#line 109
    tmp___5 = max(freq - delta, origfreq);
    }
#line 109
    return (tmp___5);
  }
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
int UserUpdatePhrase(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ,
                     char const   *wordSeq ) 
{ 
  HASH_ITEM *pItem ;
  UserPhraseData data ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 119
  len = ueStrLen(wordSeq);
#line 120
  pItem = HashFindEntry(pgdata, phoneSeq, wordSeq);
  }
#line 121
  if (! pItem) {
    {
#line 122
    tmp = strlen(wordSeq);
#line 122
    tmp___0 = AlcUserPhraseSeq(& data, len, (int )tmp);
    }
#line 122
    if (! tmp___0) {
#line 123
      return (4);
    }
    {
#line 126
    memcpy((void */* __restrict  */)data.phoneSeq, (void const   */* __restrict  */)phoneSeq,
           (unsigned long )len * sizeof(*(phoneSeq + 0)));
#line 127
    *(data.phoneSeq + len) = (uint16_t )0;
#line 128
    strcpy((char */* __restrict  */)data.wordSeq, (char const   */* __restrict  */)wordSeq);
#line 131
    data.origfreq = LoadOriginalFreq(pgdata, phoneSeq, wordSeq, len);
#line 132
    data.maxfreq = LoadMaxFreq(pgdata, phoneSeq, len);
#line 134
    data.userfreq = data.origfreq;
#line 135
    data.recentTime = pgdata->static_data.chewing_lifetime;
#line 136
    pItem = HashInsert(pgdata, & data);
#line 137
    HashModify(pgdata, pItem);
    }
#line 138
    return (1);
  } else {
    {
#line 141
    pItem->data.maxfreq = LoadMaxFreq(pgdata, phoneSeq, len);
#line 142
    pItem->data.userfreq = UpdateFreq(pItem->data.userfreq, pItem->data.maxfreq, pItem->data.origfreq,
                                      pgdata->static_data.chewing_lifetime - pItem->data.recentTime);
#line 147
    pItem->data.recentTime = pgdata->static_data.chewing_lifetime;
#line 148
    HashModify(pgdata, pItem);
    }
#line 149
    return (2);
  }
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
UserPhraseData *UserGetPhraseFirst(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ) 
{ 


  {
  {
#line 155
  pgdata->prev_userphrase = HashFindPhonePhrase(pgdata, phoneSeq, (HASH_ITEM *)((void *)0));
  }
#line 156
  if (! pgdata->prev_userphrase) {
#line 157
    return ((UserPhraseData *)((void *)0));
  }
#line 158
  return (& (pgdata->prev_userphrase)->data);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/userphrase.c"
UserPhraseData *UserGetPhraseNext(struct tag_ChewingData *pgdata , uint16_t const   *phoneSeq ) 
{ 


  {
  {
#line 163
  pgdata->prev_userphrase = HashFindPhonePhrase(pgdata, phoneSeq, pgdata->prev_userphrase);
  }
#line 164
  if (! pgdata->prev_userphrase) {
#line 165
    return ((UserPhraseData *)((void *)0));
  }
#line 166
  return (& (pgdata->prev_userphrase)->data);
}
}
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_commit_Check(ChewingContext *ctx ) 
{ 


  {
#line 30
  return ((int __attribute__((__visibility__("default")))  )(! (! ((ctx->output)->keystrokeRtn & 2))));
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_commit_String(ChewingContext *ctx ) 
{ 
  int i ;
  char *s ;
  void *tmp ;

  {
  {
#line 42
  tmp = calloc((size_t )(1 + (ctx->output)->nCommitStr), (size_t )6);
#line 42
  s = (char *)tmp;
  }
#line 45
  if (s) {
#line 46
    i = 0;
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      if (! (i < (ctx->output)->nCommitStr)) {
#line 46
        goto while_break;
      }
      {
#line 47
      strcat((char */* __restrict  */)s, (char const   */* __restrict  */)((char *)((ctx->output)->commitStr[i].s)));
#line 46
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 50
  return ((char __attribute__((__visibility__("default")))  *)s);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_buffer_Check(ChewingContext *ctx ) 
{ 


  {
#line 55
  return ((int __attribute__((__visibility__("default")))  )((ctx->output)->chiSymbolBufLen != 0));
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_buffer_Len(ChewingContext *ctx ) 
{ 


  {
#line 60
  return ((int __attribute__((__visibility__("default")))  )(ctx->output)->chiSymbolBufLen);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_buffer_String(ChewingContext *ctx ) 
{ 
  int i ;
  char *s ;
  void *tmp ;

  {
  {
#line 66
  tmp = calloc((size_t )(1 + (ctx->output)->chiSymbolBufLen), (size_t )6);
#line 66
  s = (char *)tmp;
  }
#line 69
  if (s) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < (ctx->output)->chiSymbolBufLen)) {
#line 70
        goto while_break;
      }
      {
#line 71
      strcat((char */* __restrict  */)s, (char const   */* __restrict  */)((char *)((ctx->output)->chiSymbolBuf[i].s)));
#line 70
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 74
  return ((char __attribute__((__visibility__("default")))  *)s);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_zuin_String(ChewingContext *ctx ,
                                                                      int *zuin_count ) 
{ 
  char *s ;
  int i ;
  void *tmp ;

  {
#line 87
  if (zuin_count) {
#line 88
    *zuin_count = 0;
  }
  {
#line 89
  tmp = calloc((size_t )5, sizeof((ctx->output)->zuinBuf[0].s));
#line 89
  s = (char *)tmp;
  }
#line 92
  if (s) {
#line 93
    i = 0;
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
#line 93
      if (! (i < 4)) {
#line 93
        goto while_break;
      }
#line 94
      if ((int )(ctx->output)->zuinBuf[i].s[0] != 0) {
        {
#line 95
        strcat((char */* __restrict  */)s, (char const   */* __restrict  */)((char *)((ctx->output)->zuinBuf[i].s)));
        }
#line 96
        if (zuin_count) {
#line 97
          (*zuin_count) ++;
        }
      }
#line 93
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 101
  return ((char __attribute__((__visibility__("default")))  *)s);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_zuin_Check(ChewingContext *ctx ) 
{ 
  int ret ;

  {
#line 106
  ret = 0;
#line 107
  if ((int )(ctx->output)->zuinBuf[0].s[0] == 0) {
#line 108
    ret = 1;
  }
#line 110
  return ((int __attribute__((__visibility__("default")))  )ret);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cursor_Current(ChewingContext *ctx ) 
{ 


  {
#line 115
  return ((int __attribute__((__visibility__("default")))  )(ctx->output)->chiSymbolCursor);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_CheckDone(ChewingContext *ctx ) 
{ 


  {
#line 120
  return ((int __attribute__((__visibility__("default")))  )(! (ctx->output)->pci));
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_TotalPage(ChewingContext *ctx ) 
{ 
  int tmp ;

  {
#line 125
  if ((ctx->output)->pci) {
#line 125
    tmp = ((ctx->output)->pci)->nPage;
  } else {
#line 125
    tmp = 0;
  }
#line 125
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_ChoicePerPage(ChewingContext *ctx ) 
{ 
  int tmp ;

  {
#line 130
  if ((ctx->output)->pci) {
#line 130
    tmp = ((ctx->output)->pci)->nChoicePerPage;
  } else {
#line 130
    tmp = 0;
  }
#line 130
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_TotalChoice(ChewingContext *ctx ) 
{ 
  int tmp ;

  {
#line 135
  if ((ctx->output)->pci) {
#line 135
    tmp = ((ctx->output)->pci)->nTotalChoice;
  } else {
#line 135
    tmp = 0;
  }
#line 135
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_CurrentPage(ChewingContext *ctx ) 
{ 
  int tmp ;

  {
#line 140
  if ((ctx->output)->pci) {
#line 140
    tmp = ((ctx->output)->pci)->pageNo;
  } else {
#line 140
    tmp = -1;
  }
#line 140
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
void __attribute__((__visibility__("default")))  chewing_cand_Enumerate(ChewingContext *ctx ) 
{ 


  {
#line 145
  ctx->cand_no = ((ctx->output)->pci)->pageNo * ((ctx->output)->pci)->nChoicePerPage;
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_cand_hasNext(ChewingContext *ctx ) 
{ 


  {
#line 150
  return ((int __attribute__((__visibility__("default")))  )(ctx->cand_no < ((ctx->output)->pci)->nTotalChoice));
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_cand_String(ChewingContext *ctx ) 
{ 
  char *s ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  {
#line 156
  tmp = chewing_cand_hasNext(ctx);
  }
#line 156
  if (tmp) {
    {
#line 157
    s = strdup((char const   *)(((ctx->output)->pci)->totalChoiceStr[ctx->cand_no]));
#line 158
    (ctx->cand_no) ++;
    }
  } else {
    {
#line 160
    s = strdup("");
    }
  }
#line 162
  return ((char __attribute__((__visibility__("default")))  *)s);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
void __attribute__((__visibility__("default")))  chewing_interval_Enumerate(ChewingContext *ctx ) 
{ 


  {
#line 167
  ctx->it_no = 0;
#line 168
  return;
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_interval_hasNext(ChewingContext *ctx ) 
{ 


  {
#line 172
  return ((int __attribute__((__visibility__("default")))  )(ctx->it_no < (ctx->output)->nDispInterval));
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
void __attribute__((__visibility__("default")))  chewing_interval_Get(ChewingContext *ctx ,
                                                                      IntervalType *it ) 
{ 
  int __attribute__((__visibility__("default")))  tmp ;

  {
  {
#line 177
  tmp = chewing_interval_hasNext(ctx);
  }
#line 177
  if (tmp) {
#line 178
    if (it) {
#line 179
      it->from = (ctx->output)->dispInterval[ctx->it_no].from;
#line 180
      it->to = (ctx->output)->dispInterval[ctx->it_no].to;
    }
#line 182
    (ctx->it_no) ++;
  }
#line 184
  return;
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_aux_Check(ChewingContext *ctx ) 
{ 


  {
#line 188
  return ((int __attribute__((__visibility__("default")))  )(ctx->output)->bShowMsg);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_aux_Length(ChewingContext *ctx ) 
{ 
  int tmp ;

  {
#line 193
  if ((ctx->output)->bShowMsg) {
#line 193
    tmp = (ctx->output)->showMsgLen;
  } else {
#line 193
    tmp = 0;
  }
#line 193
  return ((int __attribute__((__visibility__("default")))  )tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_aux_String(ChewingContext *ctx ) 
{ 
  int i ;
  char *msg ;
  void *tmp ;

  {
  {
#line 199
  tmp = calloc((size_t )(1 + (ctx->output)->showMsgLen), (size_t )6);
#line 199
  msg = (char *)tmp;
  }
#line 202
  if (msg) {
#line 203
    i = 0;
    {
#line 203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 203
      if (! (i < (ctx->output)->showMsgLen)) {
#line 203
        goto while_break;
      }
      {
#line 204
      strcat((char */* __restrict  */)msg, (char const   */* __restrict  */)((char *)((ctx->output)->showMsg[i].s)));
#line 203
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 206
  return ((char __attribute__((__visibility__("default")))  *)msg);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_keystroke_CheckIgnore(ChewingContext *ctx ) 
{ 


  {
#line 212
  return ((int __attribute__((__visibility__("default")))  )(! (! ((ctx->output)->keystrokeRtn & 1))));
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_keystroke_CheckAbsorb(ChewingContext *ctx ) 
{ 


  {
#line 217
  return ((int __attribute__((__visibility__("default")))  )(! (! ((ctx->output)->keystrokeRtn & 8))));
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_kbtype_Total(ChewingContext *ctx  __attribute__((__unused__)) ) 
{ 


  {
#line 222
  return ((int __attribute__((__visibility__("default")))  )12);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
void __attribute__((__visibility__("default")))  chewing_kbtype_Enumerate(ChewingContext *ctx ) 
{ 


  {
#line 227
  ctx->kb_no = 0;
#line 228
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
int __attribute__((__visibility__("default")))  chewing_kbtype_hasNext(ChewingContext *ctx ) 
{ 


  {
#line 232
  return ((int __attribute__((__visibility__("default")))  )(ctx->kb_no < 12));
}
}
#line 235
char const   * const  kb_type_str[12] ;
#line 237 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/mod_aux.c"
char __attribute__((__visibility__("default")))  *chewing_kbtype_String(ChewingContext *ctx ) 
{ 
  char *s ;
  int __attribute__((__visibility__("default")))  tmp ;

  {
  {
#line 240
  tmp = chewing_kbtype_hasNext(ctx);
  }
#line 240
  if (tmp) {
    {
#line 241
    s = strdup((char const   *)kb_type_str[ctx->kb_no]);
#line 242
    (ctx->kb_no) ++;
    }
  } else {
    {
#line 245
    s = strdup("");
    }
  }
#line 247
  return ((char __attribute__((__visibility__("default")))  *)s);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/key2pho.c"
static int const   zhuin_tab_num___0[4]  = {      (int const   )22,      (int const   )4,      (int const   )14,      (int const   )5};
#line 50 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/key2pho.c"
static int const   shift___0[4]  = {      (int const   )9,      (int const   )7,      (int const   )3,      (int const   )0};
#line 51 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/key2pho.c"
static int const   sb___0[4]  = {      (int const   )31,      (int const   )3,      (int const   )15,      (int const   )7};
#line 53 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/key2pho.c"
static char const   * const  ph_str___0  =    (char const   */* const  */)"\343\204\205\343\204\206\343\204\207\343\204\210\343\204\211\343\204\212\343\204\213\343\204\214\343\204\215\343\204\216\343\204\217\343\204\220\343\204\221\343\204\222\343\204\223\343\204\224\343\204\225\343\204\226\343\204\227\343\204\230\343\204\231\343\204\247\343\204\250\343\204\251\343\204\232\343\204\233\343\204\234\343\204\235\343\204\236\343\204\237\343\204\240\343\204\241\343\204\242\343\204\243\343\204\244\343\204\245\343\204\246\313\231\313\212\313\207\313\213";
#line 74 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/key2pho.c"
static char const   * const  key_str___0[13]  = 
#line 74
  {      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj",      (char const   */* const  */)"1234567890-qwertyuiopasdfghjkl;zxcvbn/m,.",      (char const   */* const  */)"2wsx3edcrfvtgb6yhnujm8ik,9ol.0p;/-[\'=1qaz", 
        (char const   */* const  */)"bpmfdtnlvkhg7c,./j;\'sexuaorwiqzy890-=1234",      (char const   */* const  */)"bpmfdtnlvkhgvcgycjqwsexuaorwiqzpmntlhdfjk",      (char const   */* const  */)"1\'a;2,oq.ejpuk5yixfdbghm8ctw9rnv0lsz[7634",      (char const   */* const  */)"bpmfdtnlgkhjvcjvcrzasexuyhgeiawomnkllsdfj", 
        (char const   */* const  */)"qqazwwsxedcrfvttgbyhnujmuikbiolmoplnpyerd",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634",      (char const   */* const  */)"1qaz2wsxedcrfv5tgbyhnujm8ik,9ol.0p;/-7634"};
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 17 "../include/internal/tree-private.h"
int InitTree(ChewingData *pgdata , char const   *prefix ) ;
#line 18
void TerminateTree(ChewingData *pgdata ) ;
#line 21
int IsIntersect(IntervalType in1 , IntervalType in2 ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int IsContain(IntervalType in1 , IntervalType in2 ) 
{ 
  int tmp ;

  {
#line 61
  if (in1.from <= in2.from) {
#line 61
    if (in1.to >= in2.to) {
#line 61
      tmp = 1;
    } else {
#line 61
      tmp = 0;
    }
  } else {
#line 61
    tmp = 0;
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
int IsIntersect(IntervalType in1 , IntervalType in2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 66
  tmp = max(in1.from, in2.from);
#line 66
  tmp___0 = min(in1.to, in2.to);
  }
#line 66
  return (tmp < tmp___0);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int PhraseIntervalContain(PhraseIntervalType in1 , PhraseIntervalType in2 ) 
{ 
  int tmp ;

  {
#line 71
  if (in1.from <= in2.from) {
#line 71
    if (in1.to >= in2.to) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  return (tmp);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int PhraseIntervalIntersect(PhraseIntervalType in1 , PhraseIntervalType in2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 76
  tmp = max(in1.from, in2.from);
#line 76
  tmp___0 = min(in1.to, in2.to);
  }
#line 76
  return (tmp < tmp___0);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
void TerminateTree(ChewingData *pgdata ) 
{ 


  {
  {
#line 82
  pgdata->static_data.tree = (TreeType *)((void *)0);
#line 83
  plat_mmap_close(& pgdata->static_data.tree_mmap);
  }
#line 88
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
int InitTree(ChewingData *pgdata , char const   *prefix ) 
{ 
  char filename[4096] ;
  size_t len ;
  size_t offset ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 98
  tmp = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                 prefix, "fonetree.dat");
#line 98
  len = (size_t )tmp;
  }
#line 99
  if (len + 1UL > sizeof(filename)) {
#line 100
    return (-1);
  }
  {
#line 102
  plat_mmap_set_invalid(& pgdata->static_data.tree_mmap);
#line 103
  pgdata->static_data.tree_size = plat_mmap_create(& pgdata->static_data.tree_mmap,
                                                   (char const   *)(filename), 1);
  }
#line 104
  if (pgdata->static_data.tree_size <= 0UL) {
#line 105
    return (-1);
  }
  {
#line 107
  offset = (size_t )0;
#line 108
  tmp___0 = plat_mmap_set_view(& pgdata->static_data.tree_mmap, & offset, & pgdata->static_data.tree_size);
#line 108
  pgdata->static_data.tree = (TreeType *)tmp___0;
  }
#line 109
  if (! pgdata->static_data.tree) {
#line 110
    return (-1);
  }
#line 112
  return (0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int CheckBreakpoint(int from , int to , int *bArrBrkpt ) 
{ 
  int i ;

  {
#line 151
  i = from + 1;
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! (i < to)) {
#line 151
      goto while_break;
    }
#line 152
    if (*(bArrBrkpt + i)) {
#line 153
      return (0);
    }
#line 151
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return (1);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int CheckUserChoose(ChewingData *pgdata , uint16_t *new_phoneSeq , int from ,
                           int to , Phrase **pp_phr , char (*selectStr)[301] , IntervalType *selectInterval ,
                           int nSelect ) 
{ 
  IntervalType inte ;
  IntervalType c ;
  int chno ;
  int len ;
  int user_alloc ;
  UserPhraseData *pUserPhraseData ;
  Phrase *p_phr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 168
  tmp = calloc((size_t )1, sizeof(Phrase ));
#line 168
  p_phr = (Phrase *)tmp;
  }
#line 170
  if (! p_phr) {
    {
#line 170
    __assert_fail("p_phr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  170U, "CheckUserChoose");
    }
  }
#line 171
  inte.from = from;
#line 172
  inte.to = to;
#line 173
  *pp_phr = (Phrase *)((void *)0);
#line 179
  chno = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (chno < nSelect)) {
#line 179
      goto while_break;
    }
    {
#line 180
    c = *(selectInterval + chno);
#line 181
    tmp___0 = IsIntersect(inte, c);
    }
#line 181
    if (tmp___0) {
      {
#line 181
      tmp___1 = IsContain(inte, c);
      }
#line 181
      if (! tmp___1) {
        {
#line 182
        free((void *)p_phr);
        }
#line 183
        return (0);
      }
    }
#line 179
    chno ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  pUserPhraseData = UserGetPhraseFirst(pgdata, (uint16_t const   *)new_phoneSeq);
#line 192
  p_phr->freq = -1;
  }
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 194
    chno = 0;
    {
#line 194
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 194
      if (! (chno < nSelect)) {
#line 194
        goto while_break___1;
      }
      {
#line 195
      c = *(selectInterval + chno);
#line 197
      tmp___5 = IsContain(inte, c);
      }
#line 197
      if (tmp___5) {
        {
#line 202
        len = c.to - c.from;
#line 203
        tmp___2 = ueStrNBytes((char const   *)(*(selectStr + chno)), len);
#line 203
        tmp___3 = ueStrSeek(pUserPhraseData->wordSeq, (size_t )(c.from - from));
#line 203
        tmp___4 = memcmp((void const   *)tmp___3, (void const   *)(*(selectStr + chno)),
                         (size_t )tmp___2);
        }
#line 203
        if (tmp___4) {
#line 207
          goto while_break___1;
        }
      }
#line 194
      chno ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 211
    if (chno == nSelect) {
#line 213
      if (pUserPhraseData->userfreq > p_phr->freq) {
#line 214
        user_alloc = to - from;
#line 214
        if (user_alloc > 0) {
          {
#line 215
          ueStrNCpy(p_phr->phrase, (char const   *)pUserPhraseData->wordSeq, (size_t )user_alloc,
                    1);
          }
        }
#line 219
        p_phr->freq = pUserPhraseData->userfreq;
#line 220
        *pp_phr = p_phr;
      }
    }
    {
#line 193
    pUserPhraseData = UserGetPhraseNext(pgdata, (uint16_t const   *)new_phoneSeq);
    }
#line 193
    if (! ((unsigned long )pUserPhraseData != (unsigned long )((void *)0))) {
#line 193
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  if (p_phr->freq != -1) {
#line 226
    return (1);
  }
  {
#line 228
  free((void *)p_phr);
  }
#line 229
  return (0);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int CheckChoose(ChewingData *pgdata , int ph_id , int from , int to , Phrase **pp_phr ,
                       char (*selectStr)[301] , IntervalType *selectInterval , int nSelect ) 
{ 
  IntervalType inte ;
  IntervalType c ;
  int chno ;
  int len ;
  Phrase *phrase ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 243
  tmp = calloc((size_t )1, sizeof(Phrase ));
#line 243
  phrase = (Phrase *)tmp;
  }
#line 245
  if (! phrase) {
    {
#line 245
    __assert_fail("phrase", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  245U, "CheckChoose");
    }
  }
  {
#line 246
  inte.from = from;
#line 247
  inte.to = to;
#line 248
  *pp_phr = (Phrase *)((void *)0);
#line 251
  GetPhraseFirst(pgdata, phrase, ph_id);
  }
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    chno = 0;
    {
#line 253
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 253
      if (! (chno < nSelect)) {
#line 253
        goto while_break___0;
      }
      {
#line 254
      c = *(selectInterval + chno);
#line 256
      tmp___4 = IsContain(inte, c);
      }
#line 256
      if (tmp___4) {
        {
#line 261
        len = c.to - c.from;
#line 262
        tmp___0 = ueStrNBytes((char const   *)(*(selectStr + chno)), len);
#line 262
        tmp___1 = ueStrSeek(phrase->phrase, (size_t )(c.from - from));
#line 262
        tmp___2 = memcmp((void const   *)tmp___1, (void const   *)(*(selectStr + chno)),
                         (size_t )tmp___0);
        }
#line 262
        if (tmp___2) {
#line 266
          goto while_break___0;
        }
      } else {
        {
#line 268
        tmp___3 = IsIntersect(inte, *(selectInterval + chno));
        }
#line 268
        if (tmp___3) {
          {
#line 269
          free((void *)phrase);
          }
#line 270
          return (0);
        }
      }
#line 253
      chno ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    if (chno == nSelect) {
#line 274
      *pp_phr = phrase;
#line 275
      return (1);
    }
    {
#line 252
    tmp___5 = GetPhraseNext(pgdata, phrase);
    }
#line 252
    if (! tmp___5) {
#line 252
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  free((void *)phrase);
  }
#line 279
  return (0);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
int TreeFindPhrase(ChewingData *pgdata , int begin , int end , uint16_t const   *phoneSeq ) 
{ 
  int child ;
  int tree_p ;
  int i ;

  {
#line 289
  tree_p = 0;
#line 290
  i = begin;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i <= end)) {
#line 290
      goto while_break;
    }
#line 291
    child = (pgdata->static_data.tree + tree_p)->child_begin;
    {
#line 291
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 291
      if (child != -1) {
#line 291
        if (! (child <= (pgdata->static_data.tree + tree_p)->child_end)) {
#line 291
          goto while_break___0;
        }
      } else {
#line 291
        goto while_break___0;
      }
#line 297
      if (0 <= child) {
#line 297
        if (! ((unsigned long )child * sizeof(TreeType ) < pgdata->static_data.tree_size)) {
          {
#line 297
          __assert_fail("0 <= child && child * sizeof(TreeType) < pgdata->static_data.tree_size",
                        "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                        297U, "TreeFindPhrase");
          }
        }
      } else {
        {
#line 297
        __assert_fail("0 <= child && child * sizeof(TreeType) < pgdata->static_data.tree_size",
                      "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                      297U, "TreeFindPhrase");
        }
      }
#line 299
      if ((int )(pgdata->static_data.tree + child)->phone_id == (int )*(phoneSeq + i)) {
#line 300
        goto while_break___0;
      }
#line 291
      child ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    if (child == -1) {
#line 304
      return (-1);
    } else
#line 303
    if (child > (pgdata->static_data.tree + tree_p)->child_end) {
#line 304
      return (-1);
    } else {
#line 306
      tree_p = child;
    }
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return ((pgdata->static_data.tree + tree_p)->phrase_id);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void AddInterval(TreeDataType *ptd , int begin , int end , int p_id , Phrase *p_phrase ,
                        int dict_or_user ) 
{ 


  {
#line 316
  ptd->interval[ptd->nInterval].from = begin;
#line 317
  ptd->interval[ptd->nInterval].to = end + 1;
#line 318
  ptd->interval[ptd->nInterval].pho_id = p_id;
#line 319
  ptd->interval[ptd->nInterval].p_phr = p_phrase;
#line 320
  ptd->interval[ptd->nInterval].source = dict_or_user;
#line 321
  (ptd->nInterval) ++;
#line 322
  return;
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void internal_release_Phrase(UsedPhraseMode mode , Phrase *pUser , Phrase *pDict ) 
{ 


  {
  {
#line 335
  if ((unsigned int )mode == 1U) {
#line 335
    goto case_1;
  }
#line 339
  if ((unsigned int )mode == 2U) {
#line 339
    goto case_2;
  }
#line 343
  goto switch_default;
  case_1: /* CIL Label */ 
#line 336
  if ((unsigned long )pDict != (unsigned long )((void *)0)) {
    {
#line 337
    free((void *)pDict);
    }
  }
#line 338
  goto switch_break;
  case_2: /* CIL Label */ 
#line 340
  if ((unsigned long )pUser != (unsigned long )((void *)0)) {
    {
#line 341
    free((void *)pUser);
    }
  }
#line 342
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 344
  if ((unsigned long )pDict != (unsigned long )((void *)0)) {
    {
#line 345
    free((void *)pDict);
    }
  }
#line 346
  if ((unsigned long )pUser != (unsigned long )((void *)0)) {
    {
#line 347
    free((void *)pUser);
    }
  }
#line 348
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void FindInterval(ChewingData *pgdata , TreeDataType *ptd ) 
{ 
  int end ;
  int begin ;
  int pho_id ;
  Phrase *p_phrase ;
  Phrase *puserphrase ;
  Phrase *pdictphrase ;
  UsedPhraseMode i_used_phrase ;
  uint16_t new_phoneSeq[50] ;
  int tmp ;
  UserPhraseData *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 359
  begin = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (begin < pgdata->nPhoneSeq)) {
#line 359
      goto while_break;
    }
#line 360
    end = begin;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (! (end < pgdata->nPhoneSeq)) {
#line 360
        goto while_break___0;
      }
      {
#line 361
      tmp = CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt);
      }
#line 361
      if (! tmp) {
#line 362
        goto __Cont;
      }
      {
#line 365
      memcpy((void */* __restrict  */)(new_phoneSeq), (void const   */* __restrict  */)(& pgdata->phoneSeq[begin]),
             sizeof(uint16_t ) * (unsigned long )((end - begin) + 1));
#line 369
      new_phoneSeq[(end - begin) + 1] = (uint16_t )0;
#line 370
      pdictphrase = (Phrase *)((void *)0);
#line 370
      puserphrase = pdictphrase;
#line 371
      i_used_phrase = (UsedPhraseMode )0;
#line 374
      tmp___0 = UserGetPhraseFirst(pgdata, (uint16_t const   *)(new_phoneSeq));
      }
#line 374
      if (tmp___0) {
        {
#line 374
        tmp___1 = CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1, & p_phrase,
                                  pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect);
        }
#line 374
        if (tmp___1) {
#line 377
          puserphrase = p_phrase;
        }
      }
      {
#line 381
      pho_id = TreeFindPhrase(pgdata, begin, end, (uint16_t const   *)(pgdata->phoneSeq));
      }
#line 382
      if (pho_id != -1) {
        {
#line 382
        tmp___2 = CheckChoose(pgdata, pho_id, begin, end + 1, & p_phrase, pgdata->selectStr,
                              pgdata->selectInterval, pgdata->nSelect);
        }
#line 382
        if (tmp___2) {
#line 389
          pdictphrase = p_phrase;
        }
      }
#line 396
      if ((unsigned long )puserphrase != (unsigned long )((void *)0)) {
#line 396
        if ((unsigned long )pdictphrase == (unsigned long )((void *)0)) {
#line 397
          i_used_phrase = (UsedPhraseMode )1;
        } else {
#line 396
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 399
      if ((unsigned long )puserphrase == (unsigned long )((void *)0)) {
#line 399
        if ((unsigned long )pdictphrase != (unsigned long )((void *)0)) {
#line 400
          i_used_phrase = (UsedPhraseMode )2;
        } else {
#line 399
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 402
      if ((unsigned long )puserphrase != (unsigned long )((void *)0)) {
#line 402
        if ((unsigned long )pdictphrase != (unsigned long )((void *)0)) {
          {
#line 404
          tmp___3 = strcmp((char const   *)(puserphrase->phrase), (char const   *)(pdictphrase->phrase));
          }
#line 404
          if (tmp___3) {
#line 410
            if (puserphrase->freq > pdictphrase->freq) {
#line 411
              i_used_phrase = (UsedPhraseMode )1;
            } else {
#line 414
              i_used_phrase = (UsedPhraseMode )2;
            }
          } else {
#line 407
            i_used_phrase = (UsedPhraseMode )1;
          }
        }
      }
      {
#line 419
      if ((unsigned int )i_used_phrase == 1U) {
#line 419
        goto case_1;
      }
#line 423
      if ((unsigned int )i_used_phrase == 2U) {
#line 423
        goto case_2;
      }
#line 428
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 420
      AddInterval(ptd, begin, end, -1, puserphrase, 1);
      }
#line 422
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 424
      AddInterval(ptd, begin, end, pho_id, pdictphrase, 0);
      }
#line 426
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 429
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 431
      internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);
      }
      __Cont: /* CIL Label */ 
#line 360
      end ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 359
    begin ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  return;
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void SetInfo(int len , TreeDataType *ptd ) 
{ 
  int i ;
  int a ;

  {
#line 443
  i = 0;
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i <= len)) {
#line 443
      goto while_break;
    }
#line 444
    ptd->leftmost[i] = i;
#line 443
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  i = 0;
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 445
    if (! (i < ptd->nInterval)) {
#line 445
      goto while_break___0;
    }
#line 446
    ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = (char)1;
#line 447
    ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = (char)1;
#line 445
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 451
  a = 0;
  {
#line 451
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 451
    if (! (a <= len)) {
#line 451
      goto while_break___1;
    }
#line 452
    i = 0;
    {
#line 452
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 452
      if (! (i <= len)) {
#line 452
        goto while_break___2;
      }
#line 453
      if (! ptd->graph[a][i]) {
#line 454
        goto __Cont;
      }
#line 455
      if (ptd->leftmost[i] < ptd->leftmost[a]) {
#line 456
        ptd->leftmost[a] = ptd->leftmost[i];
      }
      __Cont: /* CIL Label */ 
#line 452
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 451
    a ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 459
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int CompRecord(RecordNode const   **pa , RecordNode const   **pb ) 
{ 
  int diff ;

  {
#line 467
  diff = (int )((*pb)->nMatchCnnct - (*pa)->nMatchCnnct);
#line 469
  if (diff) {
#line 470
    return (diff);
  }
#line 471
  return ((int )((*pb)->score - (*pa)->score));
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void Discard1(TreeDataType *ptd ) 
{ 
  int a ;
  int b ;
  char failflag[1275] ;
  int nInterval2 ;
  int i ;
  int tmp ;

  {
  {
#line 488
  memset((void *)(failflag), 0, sizeof(failflag));
#line 489
  a = 0;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (a < ptd->nInterval)) {
#line 489
      goto while_break;
    }
#line 490
    if (failflag[a]) {
#line 491
      goto __Cont;
    }
#line 492
    b = 0;
    {
#line 492
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 492
      if (! (b < ptd->nInterval)) {
#line 492
        goto while_break___0;
      }
#line 493
      if (a == b) {
#line 494
        goto __Cont___0;
      } else
#line 493
      if (failflag[b]) {
#line 494
        goto __Cont___0;
      }
#line 495
      if (ptd->interval[b].from >= ptd->interval[a].from) {
#line 495
        if (ptd->interval[b].to <= ptd->interval[a].to) {
#line 497
          goto __Cont___0;
        }
      }
#line 498
      if (ptd->interval[b].from <= ptd->interval[a].from) {
#line 498
        if (ptd->interval[b].to <= ptd->interval[a].from) {
#line 500
          goto __Cont___0;
        }
      }
#line 501
      if (ptd->interval[b].from >= ptd->interval[a].to) {
#line 501
        if (ptd->interval[b].to >= ptd->interval[a].to) {
#line 503
          goto __Cont___0;
        }
      }
#line 504
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 492
      b ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 508
    if (b >= ptd->nInterval) {
#line 511
      i = 0;
      {
#line 511
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 511
        if (! (i < ptd->nInterval)) {
#line 511
          goto while_break___1;
        }
#line 512
        if (! failflag[i]) {
#line 512
          if (i != a) {
#line 512
            if (ptd->interval[i].from >= ptd->interval[a].from) {
#line 512
              if (ptd->interval[i].to <= ptd->interval[a].to) {
#line 517
                failflag[i] = (char)1;
              }
            }
          }
        }
#line 511
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 489
    a ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  nInterval2 = 0;
#line 524
  a = 0;
  {
#line 524
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 524
    if (! (a < ptd->nInterval)) {
#line 524
      goto while_break___2;
    }
#line 525
    if (! failflag[a]) {
#line 526
      tmp = nInterval2;
#line 526
      nInterval2 ++;
#line 526
      ptd->interval[tmp] = ptd->interval[a];
    } else
#line 529
    if ((unsigned long )ptd->interval[a].p_phr != (unsigned long )((void *)0)) {
      {
#line 530
      free((void *)ptd->interval[a].p_phr);
      }
    }
#line 524
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 534
  ptd->nInterval = nInterval2;
#line 535
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void Discard2(TreeDataType *ptd ) 
{ 
  int i ;
  int j ;
  char overwrite[50] ;
  char failflag[50] ;
  int nInterval2 ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 554
  memset((void *)(failflag), 0, sizeof(failflag));
#line 555
  i = 0;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! (i < ptd->nInterval)) {
#line 555
      goto while_break;
    }
#line 556
    if (ptd->leftmost[ptd->interval[i].from] == 0) {
#line 557
      goto __Cont;
    }
    {
#line 559
    memset((void *)(overwrite), 0, sizeof(overwrite));
#line 560
    j = 0;
    }
    {
#line 560
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 560
      if (! (j < ptd->nInterval)) {
#line 560
        goto while_break___0;
      }
#line 561
      if (j == i) {
#line 562
        goto __Cont___0;
      }
      {
#line 563
      memset((void *)(& overwrite[ptd->interval[j].from]), 1, (size_t )(ptd->interval[j].to - ptd->interval[j].from));
      }
      __Cont___0: /* CIL Label */ 
#line 560
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 568
    tmp = memchr((void const   *)(& overwrite[ptd->interval[i].from]), 1, (size_t )(ptd->interval[i].to - ptd->interval[i].from));
    }
#line 568
    if (tmp) {
#line 572
      failflag[i] = (char)1;
    }
    __Cont: /* CIL Label */ 
#line 555
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  nInterval2 = 0;
#line 576
  i = 0;
  {
#line 576
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 576
    if (! (i < ptd->nInterval)) {
#line 576
      goto while_break___1;
    }
#line 577
    if (! failflag[i]) {
#line 578
      tmp___0 = nInterval2;
#line 578
      nInterval2 ++;
#line 578
      ptd->interval[tmp___0] = ptd->interval[i];
    }
#line 576
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 579
  ptd->nInterval = nInterval2;
#line 580
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void LoadChar(ChewingData *pgdata , char *buf , int buf_len , uint16_t const   *phoneSeq ,
                     int nPhoneSeq ) 
{ 
  int i ;
  Word word ;
  size_t tmp ;

  {
  {
#line 587
  memset((void *)buf, 0, (size_t )buf_len);
#line 588
  i = 0;
  }
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (i < nPhoneSeq)) {
#line 588
      goto while_break;
    }
    {
#line 589
    GetCharFirst(pgdata, & word, (uint16_t )*(phoneSeq + i));
#line 590
    tmp = strlen((char const   *)buf);
#line 590
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(word.word),
            ((size_t )buf_len - tmp) - 1UL);
#line 588
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  *(buf + (buf_len - 1)) = (char )'\000';
#line 593
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void OutputRecordStr(ChewingData *pgdata , char *out_buf , int out_buf_len ,
                            int const   *record , int nRecord , uint16_t *phoneSeq ,
                            int nPhoneSeq , char (*selectStr)[301] , IntervalType *selectInterval ,
                            int nSelect , TreeDataType const   *ptd ) 
{ 
  PhraseIntervalType inter ;
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 608
  LoadChar(pgdata, out_buf, out_buf_len, (uint16_t const   *)phoneSeq, nPhoneSeq);
#line 609
  i = 0;
  }
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! (i < nRecord)) {
#line 609
      goto while_break;
    }
    {
#line 610
    inter = ptd->interval[*(record + i)];
#line 611
    tmp = ueStrSeek(out_buf, (size_t )inter.from);
#line 611
    ueStrNCpy(tmp, (char const   *)((inter.p_phr)->phrase), (size_t )(inter.to - inter.from),
              -1);
#line 609
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  i = 0;
  {
#line 616
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 616
    if (! (i < nSelect)) {
#line 616
      goto while_break___0;
    }
    {
#line 617
    inter.from = (selectInterval + i)->from;
#line 618
    inter.to = (selectInterval + i)->to;
#line 619
    tmp___0 = ueStrSeek(out_buf, (size_t )inter.from);
#line 619
    ueStrNCpy(tmp___0, (char const   *)(*(selectStr + i)), (size_t )(inter.to - inter.from),
              -1);
#line 616
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 623
  return;
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int rule_largest_sum(int const   *record , int nRecord , TreeDataType const   *ptd ) 
{ 
  int i ;
  int score ;
  PhraseIntervalType inter ;

  {
#line 627
  score = 0;
#line 630
  i = 0;
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! (i < nRecord)) {
#line 630
      goto while_break;
    }
#line 631
    inter = ptd->interval[*(record + i)];
#line 632
    if (! inter.p_phr) {
      {
#line 632
      __assert_fail("inter.p_phr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                    632U, "rule_largest_sum");
      }
    }
#line 633
    score += inter.to - inter.from;
#line 630
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  return (score);
}
}
#line 638 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int rule_largest_avgwordlen(int const   *record , int nRecord , TreeDataType const   *ptd ) 
{ 
  int tmp ;

  {
  {
#line 641
  tmp = rule_largest_sum(record, nRecord, ptd);
  }
#line 641
  return ((6 * tmp) / nRecord);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int rule_smallest_lenvariance(int const   *record , int nRecord , TreeDataType const   *ptd ) 
{ 
  int i ;
  int j ;
  int score ;
  PhraseIntervalType inter1 ;
  PhraseIntervalType inter2 ;
  int tmp ;

  {
#line 646
  score = 0;
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i < nRecord)) {
#line 650
      goto while_break;
    }
#line 651
    j = i + 1;
    {
#line 651
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 651
      if (! (j < nRecord)) {
#line 651
        goto while_break___0;
      }
#line 652
      inter1 = ptd->interval[*(record + i)];
#line 653
      inter2 = ptd->interval[*(record + j)];
#line 654
      if (inter1.p_phr) {
#line 654
        if (! inter2.p_phr) {
          {
#line 654
          __assert_fail("inter1.p_phr && inter2.p_phr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                        654U, "rule_smallest_lenvariance");
          }
        }
      } else {
        {
#line 654
        __assert_fail("inter1.p_phr && inter2.p_phr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                      654U, "rule_smallest_lenvariance");
        }
      }
      {
#line 655
      tmp = abs((inter1.to - inter1.from) - (inter2.to - inter2.from));
#line 655
      score += tmp;
#line 651
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 658
  return (- score);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int rule_largest_freqsum(int const   *record , int nRecord , TreeDataType const   *ptd ) 
{ 
  int i ;
  int score ;
  PhraseIntervalType inter ;
  int tmp ;

  {
#line 663
  score = 0;
#line 666
  i = 0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (i < nRecord)) {
#line 666
      goto while_break;
    }
#line 667
    inter = ptd->interval[*(record + i)];
#line 668
    if (! inter.p_phr) {
      {
#line 668
      __assert_fail("inter.p_phr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                    668U, "rule_largest_freqsum");
      }
    }
#line 671
    if (inter.to - inter.from == 1) {
#line 671
      tmp = (inter.p_phr)->freq / 512;
    } else {
#line 671
      tmp = (inter.p_phr)->freq;
    }
#line 671
    score += tmp;
#line 666
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  return (score);
}
}
#line 678 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int LoadPhraseAndCountScore(int const   *record , int nRecord , TreeDataType const   *ptd ) 
{ 
  int total_score ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 680
  total_score = 0;
#line 682
  if (nRecord) {
    {
#line 683
    tmp = rule_largest_sum(record, nRecord, ptd);
#line 683
    total_score += 1000 * tmp;
#line 684
    tmp___0 = rule_largest_avgwordlen(record, nRecord, ptd);
#line 684
    total_score += 1000 * tmp___0;
#line 685
    tmp___1 = rule_smallest_lenvariance(record, nRecord, ptd);
#line 685
    total_score += 100 * tmp___1;
#line 686
    tmp___2 = rule_largest_freqsum(record, nRecord, ptd);
#line 686
    total_score += tmp___2;
    }
  }
#line 688
  return (total_score);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static int IsRecContain(int const   *intA , int nA , int const   *intB , int nB ,
                        TreeDataType const   *ptd ) 
{ 
  int big ;
  int sml ;
  int tmp ;

  {
#line 695
  big = 0;
#line 695
  sml = 0;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (sml < nB)) {
#line 695
      goto while_break;
    }
    {
#line 696
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 696
      if (big < nA) {
#line 696
        if (! (ptd->interval[*(intA + big)].from < ptd->interval[*(intB + sml)].to)) {
#line 696
          goto while_break___0;
        }
      } else {
#line 696
        goto while_break___0;
      }
      {
#line 700
      tmp = PhraseIntervalContain(ptd->interval[*(intA + big)], ptd->interval[*(intB + sml)]);
      }
#line 700
      if (tmp) {
#line 703
        goto while_break___0;
      }
#line 704
      big ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 706
    if (big >= nA) {
#line 710
      return (0);
    } else
#line 706
    if (ptd->interval[*(intA + big)].from >= ptd->interval[*(intB + sml)].to) {
#line 710
      return (0);
    }
#line 695
    sml ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  return (1);
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void SortListByScore(TreeDataType *ptd ) 
{ 
  int i ;
  int listLen ;
  RecordNode *p ;
  RecordNode **arr ;
  void *tmp ;

  {
#line 720
  listLen = 0;
#line 720
  p = ptd->phList;
  {
#line 720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 720
    if (! p) {
#line 720
      goto while_break;
    }
#line 720
    listLen ++;
#line 720
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 725
  ptd->nPhListLen = listLen;
#line 727
  tmp = calloc((size_t )listLen, sizeof(RecordNode *));
#line 727
  arr = (RecordNode **)tmp;
  }
#line 728
  if (! arr) {
    {
#line 728
    __assert_fail("arr", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  728U, "SortListByScore");
    }
  }
#line 730
  i = 0;
#line 730
  p = ptd->phList;
  {
#line 730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 730
    if (! (i < listLen)) {
#line 730
      goto while_break___0;
    }
    {
#line 734
    *(arr + i) = p;
#line 735
    p->score = LoadPhraseAndCountScore((int const   *)p->arrIndex, p->nInter, (TreeDataType const   *)ptd);
#line 730
    p = p->next;
#line 730
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 741
  qsort((void *)arr, (size_t )listLen, sizeof(RecordNode *), (int (*)(void const   * ,
                                                                      void const   * ))(& CompRecord));
#line 743
  ptd->phList = *(arr + 0);
#line 744
  i = 1;
  }
  {
#line 744
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 744
    if (! (i < listLen)) {
#line 744
      goto while_break___1;
    }
#line 745
    (*(arr + (i - 1)))->next = *(arr + i);
#line 744
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 747
  (*(arr + (listLen - 1)))->next = (struct tagRecordNode *)((void *)0);
#line 749
  free((void *)arr);
  }
#line 750
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void SaveRecord(int const   *record , int nInter , TreeDataType *ptd ) 
{ 
  RecordNode *now ;
  RecordNode *p ;
  RecordNode *pre ;
  int tmp ;
  RecordNode *tp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 757
  pre = (RecordNode *)((void *)0);
#line 758
  p = ptd->phList;
  {
#line 758
  while (1) {
    while_continue: /* CIL Label */ ;
#line 758
    if (! p) {
#line 758
      goto while_break;
    }
    {
#line 760
    tmp = IsRecContain((int const   *)p->arrIndex, p->nInter, record, nInter, (TreeDataType const   *)ptd);
    }
#line 760
    if (tmp) {
#line 761
      return;
    }
    {
#line 765
    tmp___0 = IsRecContain(record, nInter, (int const   *)p->arrIndex, p->nInter,
                           (TreeDataType const   *)ptd);
    }
#line 765
    if (tmp___0) {
#line 766
      tp = p;
#line 768
      if (pre) {
#line 769
        pre->next = p->next;
      } else {
#line 771
        ptd->phList = (ptd->phList)->next;
      }
      {
#line 772
      p = p->next;
#line 773
      free((void *)tp->arrIndex);
#line 774
      free((void *)tp);
      }
    } else {
#line 777
      pre = p;
#line 777
      p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 779
  tmp___1 = calloc((size_t )1, sizeof(RecordNode ));
#line 779
  now = (RecordNode *)tmp___1;
  }
#line 780
  if (! now) {
    {
#line 780
    __assert_fail("now", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  780U, "SaveRecord");
    }
  }
  {
#line 781
  now->next = ptd->phList;
#line 782
  tmp___2 = calloc((size_t )nInter, sizeof(int ));
#line 782
  now->arrIndex = (int *)tmp___2;
  }
#line 783
  if (! now->arrIndex) {
    {
#line 783
    __assert_fail("now->arrIndex", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  783U, "SaveRecord");
    }
  }
  {
#line 784
  now->nInter = nInter;
#line 785
  memcpy((void */* __restrict  */)now->arrIndex, (void const   */* __restrict  */)record,
         (unsigned long )nInter * sizeof(int ));
#line 786
  ptd->phList = now;
  }
#line 787
  return;
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void RecursiveSave(int depth , int to , int *record , TreeDataType *ptd ) 
{ 
  int first ;
  int i ;
  int tmp ;

  {
#line 793
  first = *(record + (depth - 1)) + 1;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (ptd->interval[first].from < to) {
#line 793
      if (! (first < ptd->nInterval)) {
#line 793
        goto while_break;
      }
    } else {
#line 793
      goto while_break;
    }
#line 793
    first ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  if (first == ptd->nInterval) {
    {
#line 800
    SaveRecord((int const   *)(record + 1), depth - 1, ptd);
    }
#line 801
    return;
  }
  {
#line 803
  *(record + depth) = first;
#line 804
  RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);
#line 806
  i = first + 1;
  }
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 806
    tmp = PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]);
    }
#line 806
    if (tmp) {
#line 806
      if (! (i < ptd->nInterval)) {
#line 806
        goto while_break___0;
      }
    } else {
#line 806
      goto while_break___0;
    }
    {
#line 812
    *(record + depth) = i;
#line 813
    RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);
#line 806
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 815
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void SaveList(TreeDataType *ptd ) 
{ 
  int record[51] ;
  unsigned int tmp ;

  {
#line 819
  record[0] = -1;
#line 819
  tmp = 1U;
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (tmp >= 51U) {
#line 819
      goto while_break;
    }
#line 819
    record[tmp] = 0;
#line 819
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 821
  RecursiveSave(1, 0, record, ptd);
  }
#line 822
  return;
}
}
#line 824 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void InitPhrasing(TreeDataType *ptd ) 
{ 


  {
  {
#line 826
  memset((void *)ptd, 0, sizeof(TreeDataType ));
  }
#line 827
  return;
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void SaveDispInterval(PhrasingOutput *ppo , TreeDataType *ptd ) 
{ 
  int i ;

  {
#line 833
  i = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (i < (ptd->phList)->nInter)) {
#line 833
      goto while_break;
    }
#line 834
    ppo->dispInterval[i].from = ptd->interval[*((ptd->phList)->arrIndex + i)].from;
#line 836
    ppo->dispInterval[i].to = ptd->interval[*((ptd->phList)->arrIndex + i)].to;
#line 833
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  ppo->nDispInterval = (ptd->phList)->nInter;
#line 840
  return;
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void CleanUpMem(TreeDataType *ptd ) 
{ 
  int i ;
  RecordNode *pNode ;

  {
#line 847
  i = 0;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! (i < ptd->nInterval)) {
#line 847
      goto while_break;
    }
#line 848
    if (ptd->interval[i].p_phr) {
      {
#line 849
      free((void *)ptd->interval[i].p_phr);
#line 850
      ptd->interval[i].p_phr = (Phrase *)((void *)0);
      }
    }
#line 847
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 853
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 853
    if (! ((unsigned long )ptd->phList != (unsigned long )((void *)0))) {
#line 853
      goto while_break___0;
    }
    {
#line 854
    pNode = ptd->phList;
#line 855
    ptd->phList = pNode->next;
#line 856
    free((void *)pNode->arrIndex);
#line 857
    free((void *)pNode);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 859
  return;
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void CountMatchCnnct(TreeDataType *ptd , int const   *bUserArrCnnct , int nPhoneSeq ) 
{ 
  RecordNode *p ;
  int i ;
  int k ;
  int sum ;

  {
#line 866
  p = ptd->phList;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! p) {
#line 866
      goto while_break;
    }
#line 868
    sum = 0;
#line 868
    i = 1;
    {
#line 868
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 868
      if (! (i < nPhoneSeq)) {
#line 868
        goto while_break___0;
      }
#line 869
      if (! *(bUserArrCnnct + i)) {
#line 870
        goto __Cont;
      }
#line 872
      k = 0;
      {
#line 872
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 872
        if (! (k < p->nInter)) {
#line 872
          goto while_break___1;
        }
#line 873
        if (ptd->interval[*(p->arrIndex + k)].from < i) {
#line 873
          if (ptd->interval[*(p->arrIndex + k)].to > i) {
#line 876
            sum ++;
#line 877
            goto while_break___1;
          }
        }
#line 872
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 868
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 881
    p->nMatchCnnct = sum;
#line 866
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  return;
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static void ShowList(ChewingData *pgdata , TreeDataType const   *ptd ) 
{ 
  RecordNode const   *p ;
  int i ;

  {
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 890
    (*(pgdata->logger))(pgdata->loggerData, 3, "After SaveList :\n");
    }
#line 890
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  p = (RecordNode const   *)ptd->phList;
  {
#line 891
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 891
    if (! p) {
#line 891
      goto while_break___0;
    }
    {
#line 892
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 892
      (*(pgdata->logger))(pgdata->loggerData, 3, "  interval : ");
      }
#line 892
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 893
    i = 0;
    {
#line 893
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 893
      if (! (i < (int )p->nInter)) {
#line 893
        goto while_break___2;
      }
      {
#line 894
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 894
        (*(pgdata->logger))(pgdata->loggerData, 3, "[%d %d] ", ptd->interval[*(p->arrIndex + i)].from,
                            ptd->interval[*(p->arrIndex + i)].to);
        }
#line 894
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 893
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 899
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 899
      (*(pgdata->logger))(pgdata->loggerData, 3, "\n      score : %d , nMatchCnnct : %d\n",
                          p->score, p->nMatchCnnct);
      }
#line 899
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 891
    p = (RecordNode const   *)p->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 905
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 905
    (*(pgdata->logger))(pgdata->loggerData, 3, "\n");
    }
#line 905
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 906
  return;
}
}
#line 908 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
static RecordNode *NextCut(TreeDataType *tdt , PhrasingOutput *ppo ) 
{ 
  int i ;
  RecordNode *former ;
  RecordNode *want ;

  {
#line 915
  if (ppo->nNumCut >= tdt->nPhListLen) {
#line 916
    ppo->nNumCut = 0;
  }
#line 917
  if (ppo->nNumCut == 0) {
#line 918
    return (tdt->phList);
  }
#line 921
  former = tdt->phList;
#line 922
  i = 0;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! (i < ppo->nNumCut - 1)) {
#line 922
      goto while_break;
    }
#line 923
    former = former->next;
#line 924
    if (! former) {
      {
#line 924
      __assert_fail("former", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                    924U, "NextCut");
      }
    }
#line 922
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 928
  want = former->next;
#line 929
  if (! want) {
    {
#line 929
    __assert_fail("want", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c",
                  929U, "NextCut");
    }
  }
#line 930
  former->next = (former->next)->next;
#line 933
  want->next = tdt->phList;
#line 934
  tdt->phList = want;
#line 936
  return (tdt->phList);
}
}
#line 939 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/tree.c"
int Phrasing(ChewingData *pgdata ) 
{ 
  TreeDataType treeData ;

  {
  {
#line 943
  InitPhrasing(& treeData);
#line 945
  FindInterval(pgdata, & treeData);
#line 946
  SetInfo(pgdata->nPhoneSeq, & treeData);
#line 947
  Discard1(& treeData);
#line 948
  Discard2(& treeData);
#line 949
  SaveList(& treeData);
#line 950
  CountMatchCnnct(& treeData, (int const   *)(pgdata->bUserArrCnnct), pgdata->nPhoneSeq);
#line 951
  SortListByScore(& treeData);
#line 952
  NextCut(& treeData, & pgdata->phrOut);
#line 954
  ShowList(pgdata, (TreeDataType const   *)(& treeData));
#line 957
  OutputRecordStr(pgdata, pgdata->phrOut.chiBuf, (int )sizeof(pgdata->phrOut.chiBuf),
                  (int const   *)(treeData.phList)->arrIndex, (treeData.phList)->nInter,
                  pgdata->phoneSeq, pgdata->nPhoneSeq, pgdata->selectStr, pgdata->selectInterval,
                  pgdata->nSelect, (TreeDataType const   *)(& treeData));
#line 965
  SaveDispInterval(& pgdata->phrOut, & treeData);
#line 968
  CleanUpMem(& treeData);
  }
#line 969
  return (0);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/chewing-utf8-util.c"
static char const   utf8len_tab___0[256]  = 
#line 16 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/common/chewing-utf8-util.c"
  {      (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4, 
        (char const   )5,      (char const   )5,      (char const   )5,      (char const   )5, 
        (char const   )6,      (char const   )6,      (char const   )1,      (char const   )1};
#line 26 "../include/internal/char-private.h"
int GetCharNext(ChewingData *pgdata , Word *wrd_ptr ) ;
#line 27
int InitChar(ChewingData *pgdata , char const   *prefix ) ;
#line 28
void TerminateChar(ChewingData *pgdata ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
static int CompUint16(uint16_t const   *pa , uint16_t const   *pb ) 
{ 


  {
#line 53
  return ((int )((int const   )*pa - (int const   )*pb));
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
void TerminateChar(ChewingData *pgdata ) 
{ 


  {
  {
#line 59
  pgdata->static_data.arrPhone = (uint16_t *)((void *)0);
#line 60
  plat_mmap_close(& pgdata->static_data.char_phone_mmap);
#line 62
  pgdata->static_data.char_begin = (int *)((void *)0);
#line 63
  plat_mmap_close(& pgdata->static_data.char_begin_mmap);
#line 65
  pgdata->static_data.char_ = (void *)0;
#line 66
  plat_mmap_close(& pgdata->static_data.char_mmap);
#line 68
  pgdata->static_data.phone_num = (size_t )0;
  }
#line 76
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
int InitChar(ChewingData *pgdata , char const   *prefix ) 
{ 
  char filename[4096] ;
  size_t len ;
  size_t offset ;
  size_t file_size ;
  size_t csize ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 87
  tmp = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                 prefix, "us_freq.dat");
#line 87
  len = (size_t )tmp;
  }
#line 88
  if (len + 1UL > sizeof(filename)) {
#line 89
    return (-1);
  }
  {
#line 91
  plat_mmap_set_invalid(& pgdata->static_data.char_mmap);
#line 92
  file_size = plat_mmap_create(& pgdata->static_data.char_mmap, (char const   *)(filename),
                               1);
  }
#line 93
  if (file_size <= 0UL) {
#line 94
    return (-1);
  }
  {
#line 96
  csize = file_size;
#line 97
  offset = (size_t )0;
#line 98
  pgdata->static_data.char_ = plat_mmap_set_view(& pgdata->static_data.char_mmap,
                                                 & offset, & csize);
  }
#line 99
  if (! pgdata->static_data.char_) {
#line 100
    return (-1);
  }
  {
#line 102
  tmp___0 = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                     prefix, "ch_index_begin.dat");
#line 102
  len = (size_t )tmp___0;
  }
#line 103
  if (len + 1UL > sizeof(filename)) {
#line 104
    return (-1);
  }
  {
#line 106
  plat_mmap_set_invalid(& pgdata->static_data.char_begin_mmap);
#line 107
  file_size = plat_mmap_create(& pgdata->static_data.char_begin_mmap, (char const   *)(filename),
                               1);
  }
#line 108
  if (file_size <= 0UL) {
#line 109
    return (-1);
  }
  {
#line 111
  pgdata->static_data.phone_num = file_size / sizeof(int );
#line 113
  offset = (size_t )0;
#line 114
  csize = file_size;
#line 115
  tmp___1 = plat_mmap_set_view(& pgdata->static_data.char_begin_mmap, & offset, & csize);
#line 115
  pgdata->static_data.char_begin = (int *)tmp___1;
  }
#line 116
  if (! pgdata->static_data.char_begin) {
#line 117
    return (-1);
  }
  {
#line 119
  tmp___2 = snprintf((char */* __restrict  */)(filename), sizeof(filename), (char const   */* __restrict  */)"%s/%s",
                     prefix, "ch_index_phone.dat");
#line 119
  len = (size_t )tmp___2;
  }
#line 120
  if (len + 1UL > sizeof(filename)) {
#line 121
    return (-1);
  }
  {
#line 123
  plat_mmap_set_invalid(& pgdata->static_data.char_phone_mmap);
#line 124
  file_size = plat_mmap_create(& pgdata->static_data.char_phone_mmap, (char const   *)(filename),
                               1);
  }
#line 125
  if (file_size <= 0UL) {
#line 126
    return (-1);
  }
#line 128
  if (pgdata->static_data.phone_num != file_size / sizeof(uint16_t )) {
#line 129
    return (-1);
  }
  {
#line 131
  offset = (size_t )0;
#line 132
  csize = file_size;
#line 133
  tmp___3 = plat_mmap_set_view(& pgdata->static_data.char_phone_mmap, & offset, & csize);
#line 133
  pgdata->static_data.arrPhone = (uint16_t *)tmp___3;
  }
#line 134
  if (! pgdata->static_data.arrPhone) {
#line 135
    return (-1);
  }
#line 137
  return (0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
static void Str2Word(ChewingData *pgdata , Word *wrd_ptr ) 
{ 
  unsigned char size ;

  {
  {
#line 190
  size = *((unsigned char *)pgdata->static_data.char_cur_pos);
#line 191
  pgdata->static_data.char_cur_pos = (void *)((unsigned char *)pgdata->static_data.char_cur_pos + sizeof(unsigned char ));
#line 192
  memcpy((void */* __restrict  */)(wrd_ptr->word), (void const   */* __restrict  */)pgdata->static_data.char_cur_pos,
         (size_t )size);
#line 193
  pgdata->static_data.char_cur_pos = (void *)((unsigned char *)pgdata->static_data.char_cur_pos + (int )size);
#line 194
  wrd_ptr->word[size] = (char )'\000';
  }
#line 196
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
int GetCharFirst(ChewingData *pgdata , Word *wrd_ptr , uint16_t phoneid ) 
{ 
  uint16_t *pinx ;
  void *tmp ;

  {
  {
#line 202
  tmp = bsearch((void const   *)(& phoneid), (void const   *)pgdata->static_data.arrPhone,
                pgdata->static_data.phone_num, sizeof(uint16_t ), (int (*)(void const   * ,
                                                                           void const   * ))(& CompUint16));
#line 202
  pinx = (uint16_t *)tmp;
  }
#line 205
  if (! pinx) {
#line 206
    return (0);
  }
  {
#line 211
  pgdata->static_data.char_cur_pos = (void *)((unsigned char *)pgdata->static_data.char_ + *(pgdata->static_data.char_begin + (pinx - pgdata->static_data.arrPhone)));
#line 213
  pgdata->static_data.char_end_pos = *(pgdata->static_data.char_begin + ((pinx - pgdata->static_data.arrPhone) + 1L));
#line 214
  Str2Word(pgdata, wrd_ptr);
  }
#line 215
  return (1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/char.c"
int GetCharNext(ChewingData *pgdata , Word *wrd_ptr ) 
{ 


  {
#line 224
  if ((unsigned long )((unsigned char *)pgdata->static_data.char_cur_pos) >= (unsigned long )((unsigned char *)pgdata->static_data.char_ + pgdata->static_data.char_end_pos)) {
#line 225
    return (0);
  }
  {
#line 227
  Str2Word(pgdata, wrd_ptr);
  }
#line 228
  return (1);
}
}
#line 14 "../include/internal/choice-private.h"
int ChoiceFirstAvail(ChewingData *pgdata ) ;
#line 15
int ChoiceNextAvail(ChewingData *pgdata ) ;
#line 16
int ChoicePrevAvail(ChewingContext *ctx ) ;
#line 17
int ChoiceSelect(ChewingData *pgdata , int selectNo ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static void ChangeSelectIntervalAndBreakpoint(ChewingData *pgdata , int from , int to ,
                                              char const   *str ) 
{ 
  int i ;
  int user_alloc ;
  IntervalType inte ;
  int tmp ;

  {
#line 46
  inte.from = from;
#line 47
  inte.to = to;
#line 48
  i = 0;
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (i < pgdata->nSelect)) {
#line 48
      goto while_break;
    }
    {
#line 49
    tmp = IsIntersect(inte, pgdata->selectInterval[i]);
    }
#line 49
    if (tmp) {
      {
#line 50
      RemoveSelectElement(i, pgdata);
#line 51
      i --;
      }
    }
#line 48
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  pgdata->selectInterval[pgdata->nSelect].from = from;
#line 56
  pgdata->selectInterval[pgdata->nSelect].to = to;
#line 59
  user_alloc = to - from;
#line 59
  if (user_alloc == 0) {
#line 60
    return;
  }
  {
#line 62
  ueStrNCpy(pgdata->selectStr[pgdata->nSelect], str, (size_t )user_alloc, 1);
#line 65
  (pgdata->nSelect) ++;
  }
#line 67
  if (user_alloc > 1) {
    {
#line 68
    memset((void *)(& pgdata->bUserArrBrkpt[from + 1]), 0, sizeof(int ) * (unsigned long )(user_alloc - 1));
#line 69
    memset((void *)(& pgdata->bUserArrCnnct[from + 1]), 0, sizeof(int ) * (unsigned long )(user_alloc - 1));
    }
  }
#line 71
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static void SetAvailInfo(ChewingData *pgdata , int begin , int end ) 
{ 
  AvailInfo *pai ;
  uint16_t const   *phoneSeq ;
  int nPhoneSeq ;
  int const   *bSymbolArrBrkpt ;
  int pho_id ;
  int diff ;
  uint16_t userPhoneSeq[50] ;
  int i ;
  int head___0 ;
  int head_tmp ;
  int tail___0 ;
  int tail_tmp ;
  UserPhraseData *tmp ;

  {
#line 76
  pai = & pgdata->availInfo;
#line 77
  phoneSeq = (uint16_t const   *)(pgdata->phoneSeq);
#line 78
  nPhoneSeq = pgdata->nPhoneSeq;
#line 79
  bSymbolArrBrkpt = (int const   *)(pgdata->bSymbolArrBrkpt);
#line 88
  tail___0 = 0;
#line 88
  head___0 = tail___0;
#line 90
  pai->nAvail = 0;
#line 92
  if (pgdata->config.bPhraseChoiceRearward) {
#line 93
    i = end;
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
#line 93
      if (! (i >= begin)) {
#line 93
        goto while_break;
      }
#line 94
      head___0 = i;
#line 95
      if (*(bSymbolArrBrkpt + i)) {
#line 96
        goto while_break;
      }
#line 93
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 98
    head_tmp = end;
  } else {
#line 100
    head___0 = begin;
#line 100
    head_tmp = head___0;
  }
#line 103
  if (pgdata->config.bPhraseChoiceRearward) {
#line 104
    tail___0 = end;
#line 104
    tail_tmp = tail___0;
  } else {
#line 106
    i = begin;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (i < nPhoneSeq)) {
#line 106
        goto while_break___0;
      }
#line 107
      if (*(bSymbolArrBrkpt + i)) {
#line 108
        goto while_break___0;
      }
#line 109
      tail___0 = i;
#line 106
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    tail_tmp = begin;
  }
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 114
    if (head___0 <= head_tmp) {
#line 114
      if (! (tail_tmp <= tail___0)) {
#line 114
        goto while_break___1;
      }
    } else {
#line 114
      goto while_break___1;
    }
    {
#line 115
    diff = tail_tmp - head_tmp;
#line 116
    pho_id = TreeFindPhrase(pgdata, head_tmp, tail_tmp, phoneSeq);
    }
#line 118
    if (pho_id != -1) {
#line 120
      pai->avail[pai->nAvail].len = diff + 1;
#line 121
      pai->avail[pai->nAvail].id = pho_id;
#line 122
      (pai->nAvail) ++;
    } else {
      {
#line 125
      memcpy((void */* __restrict  */)(userPhoneSeq), (void const   */* __restrict  */)(phoneSeq + head_tmp),
             sizeof(uint16_t ) * (unsigned long )(diff + 1));
#line 129
      userPhoneSeq[diff + 1] = (uint16_t )0;
#line 130
      tmp = UserGetPhraseFirst(pgdata, (uint16_t const   *)(userPhoneSeq));
      }
#line 130
      if (tmp) {
#line 132
        pai->avail[pai->nAvail].len = diff + 1;
#line 133
        pai->avail[pai->nAvail].id = -1;
#line 134
        (pai->nAvail) ++;
      } else {
#line 136
        pai->avail[pai->nAvail].len = 0;
#line 137
        pai->avail[pai->nAvail].id = -1;
      }
    }
#line 141
    if (pgdata->config.bPhraseChoiceRearward) {
#line 142
      head_tmp --;
    } else {
#line 144
      tail_tmp ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static int ChoiceTheSame(ChoiceInfo *pci , char const   *str , int len ) 
{ 
  int i ;
  int tmp ;

  {
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < pci->nTotalChoice)) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp = memcmp((void const   *)(pci->totalChoiceStr[i]), (void const   *)str, (size_t )len);
    }
#line 155
    if (! tmp) {
#line 156
      return (1);
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static void ChoiceInfoAppendChi(ChewingData *pgdata , ChoiceInfo *pci , uint16_t phone ) 
{ 
  Word tempWord ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 164
  tmp___1 = GetCharFirst(pgdata, & tempWord, phone);
  }
#line 164
  if (tmp___1) {
    {
#line 165
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 166
      len = ueBytesFromChar((unsigned char )tempWord.word[0]);
#line 167
      tmp = ChoiceTheSame(pci, (char const   *)(tempWord.word), len);
      }
#line 167
      if (tmp) {
#line 169
        goto __Cont;
      }
#line 170
      if (! (pci->nTotalChoice < 567)) {
        {
#line 170
        __assert_fail("pci->nTotalChoice < (567)", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c",
                      170U, "ChoiceInfoAppendChi");
        }
      }
      {
#line 171
      memcpy((void */* __restrict  */)(pci->totalChoiceStr[pci->nTotalChoice]), (void const   */* __restrict  */)(tempWord.word),
             (size_t )len);
#line 174
      pci->totalChoiceStr[pci->nTotalChoice][len] = (char )'\000';
#line 176
      (pci->nTotalChoice) ++;
      }
      __Cont: /* CIL Label */ 
      {
#line 165
      tmp___0 = GetCharNext(pgdata, & tempWord);
      }
#line 165
      if (! tmp___0) {
#line 165
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 179
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static void SetChoiceInfo(ChewingData *pgdata ) 
{ 
  Phrase tempPhrase ;
  int len ;
  UserPhraseData *pUserPhraseData ;
  uint16_t userPhoneSeq[50] ;
  ChoiceInfo *pci ;
  AvailInfo *pai ;
  uint16_t *phoneSeq ;
  uint16_t *phoneSeqAlt ;
  int cursor ;
  int tmp ;
  int candPerPage ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 194
  pci = & pgdata->choiceInfo;
#line 195
  pai = & pgdata->availInfo;
#line 196
  phoneSeq = pgdata->phoneSeq;
#line 197
  phoneSeqAlt = pgdata->phoneSeqAlt;
#line 198
  tmp = PhoneSeqCursor(pgdata);
#line 198
  cursor = tmp;
#line 199
  candPerPage = pgdata->config.candPerPage;
#line 202
  memset((void *)(pci->totalChoiceStr), '\000', (size_t )37423);
#line 205
  pci->nTotalChoice = 0;
#line 206
  len = pai->avail[pai->currentAvail].len;
  }
#line 207
  if (! len) {
    {
#line 207
    __assert_fail("len", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c",
                  207U, "SetChoiceInfo");
    }
  }
#line 210
  if (len == 1) {
    {
#line 211
    ChoiceInfoAppendChi(pgdata, pci, *(phoneSeq + cursor));
    }
#line 213
    if ((int )*(phoneSeq + cursor) != (int )*(phoneSeqAlt + cursor)) {
      {
#line 214
      ChoiceInfoAppendChi(pgdata, pci, *(phoneSeqAlt + cursor));
      }
    }
#line 217
    if (pgdata->zuinData.kbtype == 1) {
#line 217
      goto _L;
    } else
#line 217
    if (pgdata->zuinData.kbtype == 7) {
      _L: /* CIL Label */ 
      {
#line 220
      if ((int )*(phoneSeq + cursor) == 10240) {
#line 220
        goto case_10240;
      }
#line 224
      if ((int )*(phoneSeq + cursor) == 128) {
#line 224
        goto case_128;
      }
#line 228
      if ((int )*(phoneSeq + cursor) == 10752) {
#line 228
        goto case_10752;
      }
#line 232
      if ((int )*(phoneSeq + cursor) == 2560) {
#line 232
        goto case_2560;
      }
#line 236
      if ((int )*(phoneSeq + cursor) == 2048) {
#line 236
        goto case_2048;
      }
#line 240
      if ((int )*(phoneSeq + cursor) == 24) {
#line 240
        goto case_24;
      }
#line 244
      if ((int )*(phoneSeq + cursor) == 16) {
#line 244
        goto case_16;
      }
#line 248
      if ((int )*(phoneSeq + cursor) == 7680) {
#line 248
        goto case_7680;
      }
#line 254
      if ((int )*(phoneSeq + cursor) == 88) {
#line 254
        goto case_88;
      }
#line 258
      if ((int )*(phoneSeq + cursor) == 104) {
#line 258
        goto case_104;
      }
#line 264
      if ((int )*(phoneSeq + cursor) == 8704) {
#line 264
        goto case_8704;
      }
#line 268
      if ((int )*(phoneSeq + cursor) == 8192) {
#line 268
        goto case_8192;
      }
#line 272
      if ((int )*(phoneSeq + cursor) == 80) {
#line 272
        goto case_80;
      }
#line 276
      if ((int )*(phoneSeq + cursor) == 72) {
#line 276
        goto case_72;
      }
#line 280
      goto switch_default;
      case_10240: /* CIL Label */ 
      {
#line 221
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )48);
      }
#line 223
      goto switch_break;
      case_128: /* CIL Label */ 
      {
#line 225
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )32);
      }
#line 227
      goto switch_break;
      case_10752: /* CIL Label */ 
      {
#line 229
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )1);
      }
#line 231
      goto switch_break;
      case_2560: /* CIL Label */ 
      {
#line 233
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )2);
      }
#line 235
      goto switch_break;
      case_2048: /* CIL Label */ 
      {
#line 237
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )3);
      }
#line 239
      goto switch_break;
      case_24: /* CIL Label */ 
      {
#line 241
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )4608);
      }
#line 243
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 245
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )5632);
      }
#line 247
      goto switch_break;
      case_7680: /* CIL Label */ 
      {
#line 249
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )6144);
#line 251
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )4);
      }
#line 253
      goto switch_break;
      case_88: /* CIL Label */ 
      {
#line 255
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )5120);
      }
#line 257
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 259
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )4096);
#line 261
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )96);
      }
#line 263
      goto switch_break;
      case_8704: /* CIL Label */ 
      {
#line 265
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )7168);
      }
#line 267
      goto switch_break;
      case_8192: /* CIL Label */ 
      {
#line 269
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )6656);
      }
#line 271
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 273
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )3584);
      }
#line 275
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 277
      ChoiceInfoAppendChi(pgdata, pci, (uint16_t )1536);
      }
#line 279
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 281
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
#line 287
    if (pai->avail[pai->currentAvail].id != -1) {
      {
#line 288
      GetPhraseFirst(pgdata, & tempPhrase, pai->avail[pai->currentAvail].id);
      }
      {
#line 289
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 290
        tmp___0 = ueBytesFromChar((unsigned char )tempPhrase.phrase[0]);
#line 290
        tmp___1 = ChoiceTheSame(pci, (char const   *)(tempPhrase.phrase), len * tmp___0);
        }
#line 290
        if (tmp___1) {
#line 294
          goto __Cont;
        }
        {
#line 296
        ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], (char const   *)(tempPhrase.phrase),
                  (size_t )len, 1);
#line 298
        (pci->nTotalChoice) ++;
        }
        __Cont: /* CIL Label */ 
        {
#line 289
        tmp___2 = GetPhraseNext(pgdata, & tempPhrase);
        }
#line 289
        if (! tmp___2) {
#line 289
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 302
    memcpy((void */* __restrict  */)(userPhoneSeq), (void const   */* __restrict  */)(phoneSeq + cursor),
           sizeof(uint16_t ) * (unsigned long )len);
#line 303
    userPhoneSeq[len] = (uint16_t )0;
#line 304
    pUserPhraseData = UserGetPhraseFirst(pgdata, (uint16_t const   *)(userPhoneSeq));
    }
#line 305
    if (pUserPhraseData) {
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 308
        tmp___3 = ueBytesFromChar((unsigned char )*(pUserPhraseData->wordSeq + 0));
#line 308
        tmp___4 = ChoiceTheSame(pci, (char const   *)pUserPhraseData->wordSeq, len * tmp___3);
        }
#line 308
        if (tmp___4) {
#line 312
          goto __Cont___0;
        }
        {
#line 314
        ueStrNCpy(pci->totalChoiceStr[pci->nTotalChoice], (char const   *)pUserPhraseData->wordSeq,
                  (size_t )len, 1);
#line 318
        (pci->nTotalChoice) ++;
        }
        __Cont___0: /* CIL Label */ 
        {
#line 306
        pUserPhraseData = UserGetPhraseNext(pgdata, (uint16_t const   *)(userPhoneSeq));
        }
#line 306
        if (! ((unsigned long )pUserPhraseData != (unsigned long )((void *)0))) {
#line 306
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 326
  pci->nChoicePerPage = candPerPage;
#line 327
  if (! (pci->nTotalChoice > 0)) {
    {
#line 327
    __assert_fail("pci->nTotalChoice > 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c",
                  327U, "SetChoiceInfo");
    }
  }
#line 328
  pci->nPage = ((pci->nTotalChoice + pci->nChoicePerPage) - 1) / pci->nChoicePerPage;
#line 329
  pci->pageNo = 0;
#line 330
  pci->isSymbol = 0;
#line 331
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static int SeekPhraseHead(ChewingData *pgdata ) 
{ 
  int i ;
  int phoneSeq ;
  int tmp ;

  {
  {
#line 339
  tmp = PhoneSeqCursor(pgdata);
#line 339
  phoneSeq = tmp;
#line 340
  i = pgdata->nPrefer - 1;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i >= 0)) {
#line 340
      goto while_break;
    }
#line 341
    if (pgdata->preferInterval[i].from > phoneSeq) {
#line 343
      goto __Cont;
    } else
#line 341
    if (pgdata->preferInterval[i].to < phoneSeq) {
#line 343
      goto __Cont;
    }
#line 344
    return (pgdata->preferInterval[i].from);
    __Cont: /* CIL Label */ 
#line 340
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return (0);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
int ChoiceFirstAvail(ChewingData *pgdata ) 
{ 
  int end ;
  int begin ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 355
  pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
#line 358
  if (pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor) {
#line 359
    (pgdata->chiSymbolCursor) --;
  }
  {
#line 362
  end = PhoneSeqCursor(pgdata);
  }
#line 364
  if (pgdata->config.bPhraseChoiceRearward) {
    {
#line 365
    tmp = SeekPhraseHead(pgdata);
#line 365
    tmp___0 = CountSymbols(pgdata, pgdata->chiSymbolCursor);
#line 365
    pgdata->chiSymbolCursor = tmp + tmp___0;
    }
  }
  {
#line 368
  begin = PhoneSeqCursor(pgdata);
#line 370
  pgdata->bSelect = 1;
#line 372
  SetAvailInfo(pgdata, begin, end);
  }
#line 374
  if (! pgdata->availInfo.nAvail) {
    {
#line 375
    tmp___1 = ChoiceEndChoice(pgdata);
    }
#line 375
    return (tmp___1);
  }
  {
#line 377
  pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;
#line 378
  SetChoiceInfo(pgdata);
  }
#line 379
  return (0);
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
int ChoicePrevAvail(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;

  {
#line 384
  pgdata = ctx->data;
#line 385
  if (pgdata->choiceInfo.isSymbol != 0) {
#line 385
    return (0);
  }
#line 386
  (pgdata->availInfo.currentAvail) ++;
#line 386
  if (pgdata->availInfo.currentAvail >= pgdata->availInfo.nAvail) {
#line 387
    pgdata->availInfo.currentAvail = 0;
  }
  {
#line 388
  SetChoiceInfo(pgdata);
  }
#line 389
  return (0);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
int ChoiceNextAvail(ChewingData *pgdata ) 
{ 


  {
#line 395
  if (pgdata->choiceInfo.isSymbol) {
#line 395
    return (0);
  }
#line 396
  (pgdata->availInfo.currentAvail) --;
#line 396
  if (pgdata->availInfo.currentAvail < 0) {
#line 397
    pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;
  }
  {
#line 398
  SetChoiceInfo(pgdata);
  }
#line 399
  return (0);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
int ChoiceEndChoice(ChewingData *pgdata ) 
{ 


  {
#line 404
  pgdata->bSelect = 0;
#line 405
  pgdata->choiceInfo.nTotalChoice = 0;
#line 406
  pgdata->choiceInfo.nPage = 0;
#line 408
  if (pgdata->choiceInfo.isSymbol != 0) {
#line 408
    goto _L;
  } else
#line 408
  if (pgdata->choiceInfo.isSymbol != 2) {
    _L: /* CIL Label */ 
#line 410
    pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;
#line 411
    if (! (pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen)) {
      {
#line 411
      __assert_fail("pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c",
                    411U, "ChoiceEndChoice");
      }
    }
  }
#line 413
  pgdata->choiceInfo.isSymbol = 0;
#line 414
  return (0);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
static void ChangeUserData(ChewingData *pgdata , int selectNo ) 
{ 
  uint16_t userPhoneSeq[50] ;
  int len ;
  int tmp ;

  {
  {
#line 422
  len = ueStrLen((char const   *)(pgdata->choiceInfo.totalChoiceStr[selectNo]));
#line 423
  tmp = PhoneSeqCursor(pgdata);
#line 423
  memcpy((void */* __restrict  */)(userPhoneSeq), (void const   */* __restrict  */)(& pgdata->phoneSeq[tmp]),
         (unsigned long )len * sizeof(uint16_t ));
#line 427
  userPhoneSeq[len] = (uint16_t )0;
#line 428
  UserUpdatePhrase(pgdata, (uint16_t const   *)(userPhoneSeq), (char const   *)(pgdata->choiceInfo.totalChoiceStr[selectNo]));
  }
#line 429
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/choice.c"
int ChoiceSelect(ChewingData *pgdata , int selectNo ) 
{ 
  ChoiceInfo *pci ;
  AvailInfo *pai ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 434
  pci = & pgdata->choiceInfo;
#line 435
  pai = & pgdata->availInfo;
#line 437
  ChangeUserData(pgdata, selectNo);
#line 438
  tmp = PhoneSeqCursor(pgdata);
#line 438
  tmp___0 = PhoneSeqCursor(pgdata);
#line 438
  ChangeSelectIntervalAndBreakpoint(pgdata, tmp___0, tmp + pai->avail[pai->currentAvail].len,
                                    (char const   *)(pci->totalChoiceStr[selectNo]));
#line 443
  ChoiceEndChoice(pgdata);
  }
#line 444
  return (0);
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 31 "../include/internal/pinyin-private.h"
int InitPinyin(ChewingData *pgdata , char const   *prefix ) ;
#line 32
void TerminatePinyin(ChewingData *pgdata ) ;
#line 38 "../include/chewingio.h"
int __attribute__((__visibility__("default")))  chewing_handle_Space(ChewingContext *ctx ) ;
#line 44
int __attribute__((__visibility__("default")))  chewing_handle_Esc(ChewingContext *ctx ) ;
#line 50
int __attribute__((__visibility__("default")))  chewing_handle_Enter(ChewingContext *ctx ) ;
#line 56
int __attribute__((__visibility__("default")))  chewing_handle_Del(ChewingContext *ctx ) ;
#line 62
int __attribute__((__visibility__("default")))  chewing_handle_Backspace(ChewingContext *ctx ) ;
#line 68
int __attribute__((__visibility__("default")))  chewing_handle_Tab(ChewingContext *ctx ) ;
#line 74
int __attribute__((__visibility__("default")))  chewing_handle_ShiftLeft(ChewingContext *ctx ) ;
#line 80
int __attribute__((__visibility__("default")))  chewing_handle_Left(ChewingContext *ctx ) ;
#line 86
int __attribute__((__visibility__("default")))  chewing_handle_ShiftRight(ChewingContext *ctx ) ;
#line 92
int __attribute__((__visibility__("default")))  chewing_handle_Right(ChewingContext *ctx ) ;
#line 98
int __attribute__((__visibility__("default")))  chewing_handle_Up(ChewingContext *ctx ) ;
#line 104
int __attribute__((__visibility__("default")))  chewing_handle_Home(ChewingContext *ctx ) ;
#line 111
int __attribute__((__visibility__("default")))  chewing_handle_End(ChewingContext *ctx ) ;
#line 117
int __attribute__((__visibility__("default")))  chewing_handle_PageUp(ChewingContext *ctx ) ;
#line 123
int __attribute__((__visibility__("default")))  chewing_handle_PageDown(ChewingContext *ctx ) ;
#line 129
int __attribute__((__visibility__("default")))  chewing_handle_Down(ChewingContext *ctx ) ;
#line 135
int __attribute__((__visibility__("default")))  chewing_handle_Capslock(ChewingContext *ctx ) ;
#line 142
int __attribute__((__visibility__("default")))  chewing_handle_Default(ChewingContext *ctx ,
                                                                       int key ) ;
#line 149
int __attribute__((__visibility__("default")))  chewing_handle_CtrlNum(ChewingContext *ctx ,
                                                                       int key ) ;
#line 155
int __attribute__((__visibility__("default")))  chewing_handle_ShiftSpace(ChewingContext *ctx ) ;
#line 161
int __attribute__((__visibility__("default")))  chewing_handle_DblTab(ChewingContext *ctx ) ;
#line 168
int __attribute__((__visibility__("default")))  chewing_handle_Numlock(ChewingContext *ctx ,
                                                                       int key ) ;
#line 180
ChewingContext __attribute__((__visibility__("default")))  *chewing_new(void) ;
#line 188
void __attribute__((__visibility__("default")))  chewing_delete(ChewingContext *ctx ) ;
#line 193
void __attribute__((__visibility__("default")))  chewing_free(void *p ) ;
#line 209
int __attribute__((__visibility__("default")))  chewing_Init(char const   *dataPath  __attribute__((__unused__)) ,
                                                             char const   *hashPath  __attribute__((__unused__)) ) ;
#line 217
int __attribute__((__visibility__("default")))  chewing_Reset(ChewingContext *ctx ) ;
#line 223
void __attribute__((__visibility__("default")))  chewing_Terminate(void) ;
#line 232
int __attribute__((__visibility__("default")))  chewing_Configure(ChewingContext *ctx ,
                                                                  ChewingConfigData *pcd ) ;
#line 247
int __attribute__((__visibility__("default")))  chewing_set_KBType(ChewingContext *ctx ,
                                                                   int kbtype ) ;
#line 255
int __attribute__((__visibility__("default")))  chewing_get_KBType(ChewingContext *ctx ) ;
#line 263
char __attribute__((__visibility__("default")))  *chewing_get_KBString(ChewingContext *ctx ) ;
#line 270
int __attribute__((__visibility__("default")))  chewing_KBStr2Num(char *str ) ;
#line 284
void __attribute__((__visibility__("default")))  chewing_set_ChiEngMode(ChewingContext *ctx ,
                                                                        int mode ) ;
#line 293
int __attribute__((__visibility__("default")))  chewing_get_ChiEngMode(ChewingContext *ctx ) ;
#line 307
void __attribute__((__visibility__("default")))  chewing_set_ShapeMode(ChewingContext *ctx ,
                                                                       int mode ) ;
#line 316
int __attribute__((__visibility__("default")))  chewing_get_ShapeMode(ChewingContext *ctx ) ;
#line 330
void __attribute__((__visibility__("default")))  chewing_set_candPerPage(ChewingContext *ctx ,
                                                                         int n ) ;
#line 337
int __attribute__((__visibility__("default")))  chewing_get_candPerPage(ChewingContext *ctx ) ;
#line 351
void __attribute__((__visibility__("default")))  chewing_set_maxChiSymbolLen(ChewingContext *ctx ,
                                                                             int n ) ;
#line 358
int __attribute__((__visibility__("default")))  chewing_get_maxChiSymbolLen(ChewingContext *ctx ) ;
#line 373
void __attribute__((__visibility__("default")))  chewing_set_selKey(ChewingContext *ctx ,
                                                                    int *selkeys ,
                                                                    int len  __attribute__((__unused__)) ) ;
#line 380
int __attribute__((__visibility__("default")))  *chewing_get_selKey(ChewingContext *ctx ) ;
#line 394
void __attribute__((__visibility__("default")))  chewing_set_addPhraseDirection(ChewingContext *ctx ,
                                                                                int direction ) ;
#line 401
int __attribute__((__visibility__("default")))  chewing_get_addPhraseDirection(ChewingContext *ctx ) ;
#line 415
void __attribute__((__visibility__("default")))  chewing_set_spaceAsSelection(ChewingContext *ctx ,
                                                                              int mode ) ;
#line 422
int __attribute__((__visibility__("default")))  chewing_get_spaceAsSelection(ChewingContext *ctx ) ;
#line 436
void __attribute__((__visibility__("default")))  chewing_set_escCleanAllBuf(ChewingContext *ctx ,
                                                                            int mode ) ;
#line 443
int __attribute__((__visibility__("default")))  chewing_get_escCleanAllBuf(ChewingContext *ctx ) ;
#line 457
void __attribute__((__visibility__("default")))  chewing_set_hsuSelKeyType(ChewingContext *ctx ,
                                                                           int mode ) ;
#line 464
int __attribute__((__visibility__("default")))  chewing_get_hsuSelKeyType(ChewingContext *ctx ) ;
#line 478
void __attribute__((__visibility__("default")))  chewing_set_autoShiftCur(ChewingContext *ctx ,
                                                                          int mode ) ;
#line 485
int __attribute__((__visibility__("default")))  chewing_get_autoShiftCur(ChewingContext *ctx ) ;
#line 499
void __attribute__((__visibility__("default")))  chewing_set_easySymbolInput(ChewingContext *ctx ,
                                                                             int mode ) ;
#line 506
int __attribute__((__visibility__("default")))  chewing_get_easySymbolInput(ChewingContext *ctx ) ;
#line 520
void __attribute__((__visibility__("default")))  chewing_set_phraseChoiceRearward(ChewingContext *ctx ,
                                                                                  int mode ) ;
#line 527
int __attribute__((__visibility__("default")))  chewing_get_phraseChoiceRearward(ChewingContext *ctx ) ;
#line 540
unsigned short __attribute__((__visibility__("default")))  *chewing_get_phoneSeq(ChewingContext *ctx ) ;
#line 547
int __attribute__((__visibility__("default")))  chewing_get_phoneSeqLen(ChewingContext *ctx ) ;
#line 550
void __attribute__((__visibility__("default")))  chewing_set_logger(ChewingContext *ctx ,
                                                                    void (*logger)(void *data ,
                                                                                   int level ,
                                                                                   char const   *fmt 
                                                                                   , ...) ,
                                                                    void *data ) ;
#line 30 "../src/porting_layer/include/plat_path.h"
int get_search_path(char *path , size_t path_len ) ;
#line 31
int find_path_by_files(char const   *search_path , char const   * const  *files ,
                       char *output , size_t output_len ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  kb_type_str[12]  = 
#line 44 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
  {      (char const   */* const  */)"KB_DEFAULT",      (char const   */* const  */)"KB_HSU",      (char const   */* const  */)"KB_IBM",      (char const   */* const  */)"KB_GIN_YIEH", 
        (char const   */* const  */)"KB_ET",      (char const   */* const  */)"KB_ET26",      (char const   */* const  */)"KB_DVORAK",      (char const   */* const  */)"KB_DVORAK_HSU", 
        (char const   */* const  */)"KB_DACHEN_CP26",      (char const   */* const  */)"KB_HANYU_PINYIN",      (char const   */* const  */)"KB_THL_PINYIN",      (char const   */* const  */)"KB_MPS2_PINYIN"};
#line 59 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  CHAR_FILES[4]  = {      (char const   */* const  */)"us_freq.dat",      (char const   */* const  */)"ch_index_begin.dat",      (char const   */* const  */)"ch_index_phone.dat",      (char const   */* const  */)((void *)0)};
#line 70 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  DICT_FILES[4]  = {      (char const   */* const  */)"dict.dat",      (char const   */* const  */)"ph_index.dat",      (char const   */* const  */)"fonetree.dat",      (char const   */* const  */)((void *)0)};
#line 77 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  SYMBOL_TABLE_FILES[2]  = {      (char const   */* const  */)"symbols.dat",      (char const   */* const  */)((void *)0)};
#line 82 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  EASY_SYMBOL_FILES[2]  = {      (char const   */* const  */)"swkb.dat",      (char const   */* const  */)((void *)0)};
#line 87 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char const   * const  PINYIN_FILES[2]  = {      (char const   */* const  */)"pinyin.tab",      (char const   */* const  */)((void *)0)};
#line 92 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_KBStr2Num(char *str ) 
{ 
  int i ;
  int tmp ;

  {
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 12)) {
#line 97
      goto while_break;
    }
    {
#line 98
    tmp = strcmp((char const   *)str, (char const   *)kb_type_str[i]);
    }
#line 98
    if (! tmp) {
#line 99
      return ((int __attribute__((__visibility__("default")))  )i);
    }
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static void chooseCandidate(ChewingContext *ctx , int toSelect , int key_buf_cursor ) 
{ 
  ChewingData *pgdata ;
  int avail_willbe ;
  int tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
#line 106
  pgdata = ctx->data;
#line 107
  if (toSelect) {
#line 108
    if (! pgdata->bSelect) {
      {
#line 109
      ChoiceFirstAvail(pgdata);
      }
    } else {
#line 111
      if (pgdata->config.bPhraseChoiceRearward) {
#line 112
        if (pgdata->availInfo.currentAvail > 0) {
#line 112
          tmp = pgdata->availInfo.currentAvail - 1;
        } else {
#line 112
          tmp = pgdata->availInfo.nAvail - 1;
        }
        {
#line 112
        avail_willbe = tmp;
#line 115
        pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor - pgdata->availInfo.avail[avail_willbe].len;
#line 117
        tmp___0 = chewing_buffer_Len(ctx);
        }
#line 117
        if (tmp___0 > (int __attribute__((__visibility__("default")))  )pgdata->choiceInfo.oldChiSymbolCursor) {
#line 119
          (pgdata->chiSymbolCursor) ++;
        }
      }
      {
#line 122
      ChoiceNextAvail(pgdata);
      }
    }
  } else
#line 124
  if (pgdata->symbolKeyBuf[key_buf_cursor]) {
#line 126
    if (pgdata->choiceInfo.isSymbol == 0) {
      {
#line 127
      OpenSymbolChoice(pgdata);
      }
    }
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static void NullLogger(void *data  __attribute__((__unused__)) , int level  __attribute__((__unused__)) ,
                       char const   *fmt  __attribute__((__unused__))  , ...) 
{ 


  {
#line 133
  return;
}
}
#line 137
static ChewingData *allocate_ChewingData(void) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static int const   DEFAULT_SELKEY[10]  = 
#line 137
  {      (int const   )'1',      (int const   )'2',      (int const   )'3',      (int const   )'4', 
        (int const   )'5',      (int const   )'6',      (int const   )'7',      (int const   )'8', 
        (int const   )'9',      (int const   )'0'};
#line 135 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static ChewingData *allocate_ChewingData(void) 
{ 
  ChewingData *data ;
  void *tmp ;

  {
  {
#line 139
  tmp = calloc((size_t )1, sizeof(ChewingData ));
#line 139
  data = (ChewingData *)tmp;
  }
#line 140
  if (data) {
    {
#line 141
    data->config.candPerPage = 10;
#line 142
    data->config.maxChiSymbolLen = 39;
#line 143
    data->logger = & NullLogger;
#line 144
    memcpy((void */* __restrict  */)(data->config.selKey), (void const   */* __restrict  */)(DEFAULT_SELKEY),
           sizeof(data->config.selKey));
    }
  }
#line 147
  return (data);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
ChewingContext __attribute__((__visibility__("default")))  *chewing_new(void) 
{ 
  ChewingContext *ctx ;
  int ret ;
  char search_path[4096] ;
  char path[4096] ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 157
  tmp = calloc((size_t )1, sizeof(ChewingContext ));
#line 157
  ctx = (ChewingContext *)tmp;
  }
#line 158
  if (! ctx) {
#line 159
    goto error;
  }
  {
#line 161
  tmp___0 = calloc((size_t )1, sizeof(ChewingOutput ));
#line 161
  ctx->output = (ChewingOutput *)tmp___0;
  }
#line 162
  if (! ctx->output) {
#line 163
    goto error;
  }
  {
#line 165
  ctx->data = allocate_ChewingData();
  }
#line 166
  if (! ctx->data) {
#line 167
    goto error;
  }
  {
#line 169
  chewing_Reset(ctx);
#line 171
  ret = get_search_path(search_path, sizeof(search_path));
  }
#line 172
  if (ret) {
#line 173
    goto error;
  }
  {
#line 175
  ret = find_path_by_files((char const   *)(search_path), CHAR_FILES, path, sizeof(path));
  }
#line 177
  if (ret) {
#line 178
    goto error;
  }
  {
#line 179
  ret = InitChar(ctx->data, (char const   *)(path));
  }
#line 180
  if (ret) {
#line 181
    goto error;
  }
  {
#line 183
  ret = find_path_by_files((char const   *)(search_path), DICT_FILES, path, sizeof(path));
  }
#line 185
  if (ret) {
#line 186
    goto error;
  }
  {
#line 187
  ret = InitDict(ctx->data, (char const   *)(path));
  }
#line 188
  if (ret) {
#line 189
    goto error;
  }
  {
#line 190
  ret = InitTree(ctx->data, (char const   *)(path));
  }
#line 191
  if (ret) {
#line 192
    goto error;
  }
  {
#line 194
  ret = InitHash(ctx->data);
  }
#line 195
  if (! ret) {
#line 196
    goto error;
  }
  {
#line 198
  ctx->cand_no = 0;
#line 200
  ret = find_path_by_files((char const   *)(search_path), SYMBOL_TABLE_FILES, path,
                           sizeof(path));
  }
#line 202
  if (ret) {
#line 203
    goto error;
  }
  {
#line 204
  ret = InitSymbolTable(ctx->data, (char const   *)(path));
  }
#line 205
  if (ret) {
#line 206
    goto error;
  }
  {
#line 208
  ret = find_path_by_files((char const   *)(search_path), EASY_SYMBOL_FILES, path,
                           sizeof(path));
  }
#line 210
  if (ret) {
#line 211
    goto error;
  }
  {
#line 212
  ret = InitEasySymbolInput(ctx->data, (char const   *)(path));
  }
#line 213
  if (ret) {
#line 214
    goto error;
  }
  {
#line 216
  ret = find_path_by_files((char const   *)(search_path), PINYIN_FILES, path, sizeof(path));
  }
#line 218
  if (ret) {
#line 219
    goto error;
  }
  {
#line 220
  ret = InitPinyin(ctx->data, (char const   *)(path));
  }
#line 221
  if (! ret) {
#line 222
    goto error;
  }
#line 224
  return ((ChewingContext __attribute__((__visibility__("default")))  *)ctx);
  error: 
  {
#line 226
  chewing_delete(ctx);
  }
#line 227
  return ((ChewingContext __attribute__((__visibility__("default")))  *)((void *)0));
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_Init(char const   *dataPath  __attribute__((__unused__)) ,
                                                             char const   *hashPath  __attribute__((__unused__)) ) 
{ 


  {
#line 234
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_Reset(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingStaticData static_data ;
  ChewingConfigData old_config ;
  void (*logger)(void *data , int level , char const   *fmt  , ...) ;

  {
  {
#line 239
  pgdata = ctx->data;
#line 245
  old_config = pgdata->config;
#line 246
  static_data = pgdata->static_data;
#line 247
  logger = pgdata->logger;
#line 248
  memset((void *)pgdata, 0, sizeof(ChewingData ));
#line 249
  pgdata->config = old_config;
#line 250
  pgdata->static_data = static_data;
#line 251
  pgdata->logger = logger;
#line 254
  memset((void *)(& pgdata->zuinData), 0, sizeof(ZuinData ));
#line 257
  memset((void *)(& pgdata->choiceInfo), 0, sizeof(ChoiceInfo ));
#line 259
  pgdata->chiSymbolCursor = 0;
#line 260
  pgdata->chiSymbolBufLen = 0;
#line 261
  pgdata->nPhoneSeq = 0;
#line 262
  memset((void *)(pgdata->bUserArrCnnct), 0, sizeof(int ) * 51UL);
#line 263
  memset((void *)(pgdata->bUserArrBrkpt), 0, sizeof(int ) * 51UL);
#line 264
  pgdata->bChiSym = 1;
#line 265
  pgdata->bFullShape = 0;
#line 266
  pgdata->bSelect = 0;
#line 267
  pgdata->nSelect = 0;
#line 268
  pgdata->PointStart = -1;
#line 269
  pgdata->PointEnd = 0;
#line 270
  pgdata->phrOut.nNumCut = 0;
  }
#line 271
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_set_KBType(ChewingContext *ctx ,
                                                                   int kbtype ) 
{ 


  {
#line 276
  if (kbtype < 12) {
#line 276
    if (kbtype >= 0) {
#line 277
      (ctx->data)->zuinData.kbtype = kbtype;
#line 278
      return ((int __attribute__((__visibility__("default")))  )0);
    } else {
#line 280
      (ctx->data)->zuinData.kbtype = 0;
#line 281
      return ((int __attribute__((__visibility__("default")))  )-1);
    }
  } else {
#line 280
    (ctx->data)->zuinData.kbtype = 0;
#line 281
    return ((int __attribute__((__visibility__("default")))  )-1);
  }
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_KBType(ChewingContext *ctx ) 
{ 


  {
#line 287
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->zuinData.kbtype);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
char __attribute__((__visibility__("default")))  *chewing_get_KBString(ChewingContext *ctx ) 
{ 
  char *tmp ;

  {
  {
#line 292
  tmp = strdup((char const   *)kb_type_str[(ctx->data)->zuinData.kbtype]);
  }
#line 292
  return ((char __attribute__((__visibility__("default")))  *)tmp);
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_Terminate(void) 
{ 


  {
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_delete(ChewingContext *ctx ) 
{ 


  {
#line 301
  if (ctx) {
#line 302
    if (ctx->data) {
      {
#line 303
      TerminatePinyin(ctx->data);
#line 304
      TerminateEasySymbolTable(ctx->data);
#line 305
      TerminateSymbolTable(ctx->data);
#line 306
      TerminateHash(ctx->data);
#line 307
      TerminateTree(ctx->data);
#line 308
      TerminateDict(ctx->data);
#line 309
      TerminateChar(ctx->data);
#line 310
      free((void *)ctx->data);
      }
    }
#line 313
    if (ctx->output) {
      {
#line 314
      free((void *)ctx->output);
      }
    }
    {
#line 315
    free((void *)ctx);
    }
  }
#line 317
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_free(void *p ) 
{ 


  {
#line 322
  if (p) {
    {
#line 323
    free(p);
    }
  }
#line 324
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_Configure(ChewingContext *ctx ,
                                                                  ChewingConfigData *pcd ) 
{ 


  {
  {
#line 329
  chewing_set_candPerPage(ctx, pcd->candPerPage);
#line 330
  chewing_set_maxChiSymbolLen(ctx, pcd->maxChiSymbolLen);
#line 331
  chewing_set_selKey(ctx, pcd->selKey, 10);
#line 332
  chewing_set_addPhraseDirection(ctx, pcd->bAddPhraseForward);
#line 333
  chewing_set_spaceAsSelection(ctx, pcd->bSpaceAsSelection);
#line 334
  chewing_set_escCleanAllBuf(ctx, pcd->bEscCleanAllBuf);
#line 335
  chewing_set_autoShiftCur(ctx, pcd->bAutoShiftCur);
#line 336
  chewing_set_easySymbolInput(ctx, pcd->bEasySymbolInput);
#line 337
  chewing_set_phraseChoiceRearward(ctx, pcd->bPhraseChoiceRearward);
  }
#line 339
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_candPerPage(ChewingContext *ctx ,
                                                                         int n ) 
{ 


  {
#line 344
  if (1 <= n) {
#line 344
    if (n <= 10) {
#line 345
      (ctx->data)->config.candPerPage = n;
    }
  }
#line 346
  return;
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_candPerPage(ChewingContext *ctx ) 
{ 


  {
#line 350
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.candPerPage);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_maxChiSymbolLen(ChewingContext *ctx ,
                                                                             int n ) 
{ 


  {
#line 355
  if (0 <= n) {
#line 355
    if (n <= 39) {
#line 356
      (ctx->data)->config.maxChiSymbolLen = n;
    }
  }
#line 357
  return;
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_maxChiSymbolLen(ChewingContext *ctx ) 
{ 


  {
#line 361
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.maxChiSymbolLen);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_selKey(ChewingContext *ctx ,
                                                                    int *selkeys ,
                                                                    int len  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 367
  memcpy((void */* __restrict  */)((ctx->data)->config.selKey), (void const   */* __restrict  */)selkeys,
         sizeof(*(selkeys + 0)) * 10UL);
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  *chewing_get_selKey(ChewingContext *ctx ) 
{ 
  int *selkeys ;
  void *tmp ;

  {
  {
#line 375
  tmp = calloc((size_t )10, sizeof(int ));
#line 375
  selkeys = (int *)tmp;
  }
#line 376
  if (selkeys) {
    {
#line 377
    memcpy((void */* __restrict  */)selkeys, (void const   */* __restrict  */)((ctx->data)->config.selKey),
           sizeof(*selkeys) * 10UL);
    }
  }
#line 380
  return ((int __attribute__((__visibility__("default")))  *)selkeys);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_addPhraseDirection(ChewingContext *ctx ,
                                                                                int direction ) 
{ 


  {
#line 385
  if (direction == 0) {
#line 386
    (ctx->data)->config.bAddPhraseForward = direction;
  } else
#line 385
  if (direction == 1) {
#line 386
    (ctx->data)->config.bAddPhraseForward = direction;
  }
#line 387
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_addPhraseDirection(ChewingContext *ctx ) 
{ 


  {
#line 391
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bAddPhraseForward);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_spaceAsSelection(ChewingContext *ctx ,
                                                                              int mode ) 
{ 


  {
#line 396
  if (mode == 0) {
#line 397
    (ctx->data)->config.bSpaceAsSelection = mode;
  } else
#line 396
  if (mode == 1) {
#line 397
    (ctx->data)->config.bSpaceAsSelection = mode;
  }
#line 398
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_spaceAsSelection(ChewingContext *ctx ) 
{ 


  {
#line 402
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bSpaceAsSelection);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_escCleanAllBuf(ChewingContext *ctx ,
                                                                            int mode ) 
{ 


  {
#line 407
  if (mode == 0) {
#line 408
    (ctx->data)->config.bEscCleanAllBuf = mode;
  } else
#line 407
  if (mode == 1) {
#line 408
    (ctx->data)->config.bEscCleanAllBuf = mode;
  }
#line 409
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_escCleanAllBuf(ChewingContext *ctx ) 
{ 


  {
#line 413
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bEscCleanAllBuf);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_hsuSelKeyType(ChewingContext *ctx ,
                                                                           int mode ) 
{ 


  {
#line 419
  (ctx->data)->config.hsuSelKeyType = mode;
#line 420
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_hsuSelKeyType(ChewingContext *ctx ) 
{ 


  {
#line 425
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.hsuSelKeyType);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_autoShiftCur(ChewingContext *ctx ,
                                                                          int mode ) 
{ 


  {
#line 430
  if (mode == 0) {
#line 431
    (ctx->data)->config.bAutoShiftCur = mode;
  } else
#line 430
  if (mode == 1) {
#line 431
    (ctx->data)->config.bAutoShiftCur = mode;
  }
#line 432
  return;
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_autoShiftCur(ChewingContext *ctx ) 
{ 


  {
#line 436
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bAutoShiftCur);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_easySymbolInput(ChewingContext *ctx ,
                                                                             int mode ) 
{ 


  {
#line 441
  if (mode == 0) {
#line 442
    (ctx->data)->config.bEasySymbolInput = mode;
  } else
#line 441
  if (mode == 1) {
#line 442
    (ctx->data)->config.bEasySymbolInput = mode;
  }
#line 443
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_easySymbolInput(ChewingContext *ctx ) 
{ 


  {
#line 447
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bEasySymbolInput);
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_phraseChoiceRearward(ChewingContext *ctx ,
                                                                                  int mode ) 
{ 


  {
#line 452
  if (mode == 0) {
#line 453
    (ctx->data)->config.bPhraseChoiceRearward = mode;
  } else
#line 452
  if (mode == 1) {
#line 453
    (ctx->data)->config.bPhraseChoiceRearward = mode;
  }
#line 454
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_phraseChoiceRearward(ChewingContext *ctx ) 
{ 


  {
#line 458
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->config.bPhraseChoiceRearward);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_ChiEngMode(ChewingContext *ctx ,
                                                                        int mode ) 
{ 


  {
#line 463
  if (mode == 1) {
#line 464
    (ctx->data)->bChiSym = mode;
  } else
#line 463
  if (mode == 0) {
#line 464
    (ctx->data)->bChiSym = mode;
  }
#line 465
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_ChiEngMode(ChewingContext *ctx ) 
{ 


  {
#line 469
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->bChiSym);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_ShapeMode(ChewingContext *ctx ,
                                                                       int mode ) 
{ 


  {
#line 474
  if (mode == 0) {
#line 475
    (ctx->data)->bFullShape = mode;
  } else
#line 474
  if (mode == 1) {
#line 475
    (ctx->data)->bFullShape = mode;
  }
#line 476
  return;
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_ShapeMode(ChewingContext *ctx ) 
{ 


  {
#line 480
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->bFullShape);
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static void CheckAndResetRange(ChewingData *pgdata ) 
{ 


  {
#line 485
  if (pgdata->PointStart > -1) {
#line 486
    pgdata->PointStart = -1;
#line 487
    pgdata->PointEnd = 0;
  }
#line 489
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static int DoSelect(ChewingData *pgdata , int num ) 
{ 


  {
#line 493
  if (! (pgdata->choiceInfo.pageNo >= 0)) {
    {
#line 493
    __assert_fail("pgdata->choiceInfo.pageNo >= 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c",
                  493U, "DoSelect");
    }
  }
#line 494
  if (num >= 0) {
#line 495
    num += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;
#line 497
    if (num < pgdata->choiceInfo.nTotalChoice) {
#line 498
      if (pgdata->choiceInfo.isSymbol != 0) {
        {
#line 499
        SymbolChoice(pgdata, num);
        }
      } else {
        {
#line 503
        AddSelect(pgdata, num);
#line 505
        ChoiceSelect(pgdata, num);
        }
#line 507
        if (pgdata->config.bAutoShiftCur != 0) {
#line 507
          if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {
#line 510
            if (pgdata->config.bPhraseChoiceRearward) {
#line 511
              (pgdata->chiSymbolCursor) ++;
            } else {
#line 513
              pgdata->chiSymbolCursor += pgdata->availInfo.avail[pgdata->availInfo.currentAvail].len;
            }
          }
        }
      }
#line 518
      return (1);
    }
  }
#line 521
  return (0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Space(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  int __attribute__((__visibility__("default")))  tmp ;
  int tmp___0 ;
  int __attribute__((__visibility__("default")))  tmp___1 ;
  int __attribute__((__visibility__("default")))  tmp___2 ;

  {
#line 526
  pgdata = ctx->data;
#line 534
  if (! pgdata->config.bSpaceAsSelection) {
    {
#line 537
    tmp = chewing_handle_Default(ctx, ' ');
    }
#line 537
    return (tmp);
  } else
#line 534
  if (pgdata->bChiSym != 1) {
    {
#line 537
    tmp = chewing_handle_Default(ctx, ' ');
    }
#line 537
    return (tmp);
  } else {
    {
#line 534
    tmp___0 = ZuinIsEntering(& (ctx->data)->zuinData);
    }
#line 534
    if (tmp___0) {
      {
#line 537
      tmp = chewing_handle_Default(ctx, ' ');
      }
#line 537
      return (tmp);
    }
  }
  {
#line 540
  CheckAndResetRange(pgdata);
  }
#line 542
  if (pgdata->bSelect) {
    {
#line 543
    tmp___1 = chewing_handle_Right(ctx);
    }
#line 543
    return (tmp___1);
  } else {
    {
#line 545
    tmp___2 = chewing_handle_Down(ctx);
    }
#line 545
    return (tmp___2);
  }
#line 547
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Esc(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 552
  pgdata = ctx->data;
#line 553
  pgo = ctx->output;
#line 554
  keystrokeRtn = 8;
#line 556
  CheckAndResetRange(pgdata);
#line 558
  tmp___0 = ChewingIsEntering(pgdata);
  }
#line 558
  if (tmp___0) {
#line 561
    if (pgdata->bSelect) {
      {
#line 562
      ChoiceEndChoice(pgdata);
      }
    } else {
      {
#line 564
      tmp = ZuinIsEntering(& pgdata->zuinData);
      }
#line 564
      if (tmp) {
        {
#line 565
        ZuinRemoveAll(& pgdata->zuinData);
        }
      } else
#line 567
      if (pgdata->config.bEscCleanAllBuf) {
        {
#line 568
        CleanAllBuf(pgdata);
#line 569
        pgo->nCommitStr = pgdata->chiSymbolBufLen;
        }
      }
    }
  } else {
#line 559
    keystrokeRtn = 1;
  }
  {
#line 572
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 573
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Enter(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int nCommitStr ;
  int keystrokeRtn ;
  int buf ;
  int key ;
  int tmp ;

  {
  {
#line 578
  pgdata = ctx->data;
#line 579
  pgo = ctx->output;
#line 580
  nCommitStr = pgdata->chiSymbolBufLen;
#line 581
  keystrokeRtn = 8;
#line 583
  tmp = ChewingIsEntering(pgdata);
  }
#line 583
  if (tmp) {
#line 586
    if (pgdata->bSelect) {
#line 587
      keystrokeRtn = 12;
    } else
#line 589
    if (pgdata->PointStart > -1) {
#line 590
      buf = pgdata->chiSymbolCursor;
#line 592
      if (pgdata->PointEnd > 1) {
#line 593
        if (! pgdata->config.bAddPhraseForward) {
#line 594
          pgdata->chiSymbolCursor = pgdata->PointStart;
#line 595
          key = 48 + pgdata->PointEnd;
        } else {
#line 598
          pgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;
#line 599
          key = 48 + pgdata->PointEnd;
        }
        {
#line 602
        chewing_handle_CtrlNum(ctx, key);
#line 603
        pgdata->chiSymbolCursor = buf;
        }
      } else
#line 605
      if (pgdata->PointEnd < 1) {
#line 606
        if (pgdata->config.bAddPhraseForward) {
#line 607
          pgdata->chiSymbolCursor = buf - pgdata->PointEnd;
        }
        {
#line 608
        key = 48 - pgdata->PointEnd;
#line 609
        chewing_handle_CtrlNum(ctx, key);
#line 610
        pgdata->chiSymbolCursor = buf;
        }
      }
#line 612
      pgdata->PointStart = -1;
#line 613
      pgdata->PointEnd = 0;
    } else {
      {
#line 616
      keystrokeRtn = 2;
#line 617
      WriteChiSymbolToBuf(pgo->commitStr, nCommitStr, pgdata);
#line 618
      AutoLearnPhrase(pgdata);
#line 619
      CleanAllBuf(pgdata);
#line 620
      pgo->nCommitStr = nCommitStr;
      }
    }
  } else {
#line 584
    keystrokeRtn = 1;
  }
  {
#line 623
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 624
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Del(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 629
  pgdata = ctx->data;
#line 630
  pgo = ctx->output;
#line 631
  keystrokeRtn = 8;
#line 633
  CheckAndResetRange(pgdata);
#line 635
  tmp = ChewingIsEntering(pgdata);
  }
#line 635
  if (! tmp) {
#line 636
    keystrokeRtn = 1;
  }
#line 639
  if (! pgdata->bSelect) {
    {
#line 640
    tmp___0 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 640
    if (! tmp___0) {
#line 640
      if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {
        {
#line 643
        ChewingKillChar(pgdata, pgdata->chiSymbolCursor, 0);
        }
      }
    }
    {
#line 648
    CallPhrasing(pgdata);
    }
  }
  {
#line 650
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 651
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Backspace(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 656
  pgdata = ctx->data;
#line 657
  pgo = ctx->output;
#line 658
  keystrokeRtn = 8;
#line 660
  CheckAndResetRange(pgdata);
#line 662
  tmp = ChewingIsEntering(pgdata);
  }
#line 662
  if (! tmp) {
#line 663
    keystrokeRtn = 1;
  }
#line 666
  if (! pgdata->bSelect) {
    {
#line 667
    tmp___0 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 667
    if (tmp___0) {
      {
#line 668
      ZuinRemoveLast(& pgdata->zuinData);
      }
    } else
#line 670
    if (pgdata->chiSymbolCursor > 0) {
      {
#line 671
      ChewingKillChar(pgdata, pgdata->chiSymbolCursor - 1, 1);
      }
    }
    {
#line 676
    CallPhrasing(pgdata);
    }
  }
  {
#line 678
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 680
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 683 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Up(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int key_buf_cursor ;
  int tmp ;

  {
  {
#line 685
  pgdata = ctx->data;
#line 686
  pgo = ctx->output;
#line 687
  keystrokeRtn = 8;
#line 690
  CheckAndResetRange(pgdata);
#line 692
  tmp = ChewingIsEntering(pgdata);
  }
#line 692
  if (! tmp) {
#line 693
    keystrokeRtn = 1;
  }
#line 696
  key_buf_cursor = pgdata->chiSymbolCursor;
#line 698
  if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {
#line 699
    key_buf_cursor --;
  }
#line 702
  if (! pgdata->symbolKeyBuf[key_buf_cursor]) {
    {
#line 704
    chewing_handle_Esc(ctx);
    }
  }
  {
#line 707
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 708
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Down(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int toSelect ;
  int keystrokeRtn ;
  int key_buf_cursor ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 713
  pgdata = ctx->data;
#line 714
  pgo = ctx->output;
#line 715
  toSelect = 0;
#line 716
  keystrokeRtn = 8;
#line 719
  CheckAndResetRange(pgdata);
#line 721
  tmp = ChewingIsEntering(pgdata);
  }
#line 721
  if (! tmp) {
#line 722
    keystrokeRtn = 1;
  }
#line 725
  key_buf_cursor = pgdata->chiSymbolCursor;
#line 727
  if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {
#line 728
    key_buf_cursor --;
  }
  {
#line 731
  tmp___0 = ChewingIsChiAt(key_buf_cursor, pgdata);
  }
#line 731
  if (tmp___0) {
#line 732
    toSelect = 1;
  }
  {
#line 734
  chooseCandidate(ctx, toSelect, key_buf_cursor);
#line 736
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 737
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_ShiftLeft(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 743
  pgdata = ctx->data;
#line 744
  pgo = ctx->output;
#line 745
  keystrokeRtn = 8;
#line 747
  tmp = ChewingIsEntering(pgdata);
  }
#line 747
  if (! tmp) {
#line 748
    keystrokeRtn = 1;
  }
#line 750
  if (! pgdata->bSelect) {
    {
#line 752
    tmp___1 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 752
    if (! tmp___1) {
#line 752
      if (pgdata->chiSymbolCursor > 0) {
#line 752
        if (pgdata->PointEnd > -9) {
#line 756
          if (pgdata->PointStart == -1) {
#line 757
            pgdata->PointStart = pgdata->chiSymbolCursor;
          }
          {
#line 758
          (pgdata->chiSymbolCursor) --;
#line 759
          tmp___0 = ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata);
          }
#line 759
          if (tmp___0) {
#line 761
            (pgdata->PointEnd) --;
          }
#line 763
          if (pgdata->PointEnd == 0) {
#line 764
            pgdata->PointStart = -1;
          }
        }
      }
    }
  }
  {
#line 768
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 769
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Left(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 774
  pgdata = ctx->data;
#line 775
  pgo = ctx->output;
#line 776
  keystrokeRtn = 8;
#line 778
  tmp = ChewingIsEntering(pgdata);
  }
#line 778
  if (! tmp) {
#line 779
    keystrokeRtn = 1;
  }
#line 782
  if (pgdata->bSelect) {
#line 783
    if (! (pgdata->choiceInfo.nPage > 0)) {
      {
#line 783
      __assert_fail("pgdata->choiceInfo.nPage > 0", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c",
                    783U, "chewing_handle_Left");
      }
    }
#line 784
    if (pgdata->choiceInfo.pageNo > 0) {
#line 785
      (pgdata->choiceInfo.pageNo) --;
    } else {
#line 787
      pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;
    }
  } else {
    {
#line 790
    tmp___0 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 790
    if (! tmp___0) {
#line 790
      if (pgdata->chiSymbolCursor > 0) {
        {
#line 793
        CheckAndResetRange(pgdata);
#line 794
        (pgdata->chiSymbolCursor) --;
        }
      }
    }
  }
  {
#line 797
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 798
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_ShiftRight(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 804
  pgdata = ctx->data;
#line 805
  pgo = ctx->output;
#line 806
  keystrokeRtn = 8;
#line 808
  tmp = ChewingIsEntering(pgdata);
  }
#line 808
  if (! tmp) {
#line 809
    keystrokeRtn = 1;
  }
#line 812
  if (! pgdata->bSelect) {
    {
#line 814
    tmp___1 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 814
    if (! tmp___1) {
#line 814
      if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {
#line 814
        if (pgdata->PointEnd < 9) {
#line 818
          if (pgdata->PointStart == -1) {
#line 819
            pgdata->PointStart = pgdata->chiSymbolCursor;
          }
          {
#line 820
          tmp___0 = ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata);
          }
#line 820
          if (tmp___0) {
#line 822
            (pgdata->PointEnd) ++;
          }
#line 824
          (pgdata->chiSymbolCursor) ++;
#line 825
          if (pgdata->PointEnd == 0) {
#line 826
            pgdata->PointStart = -1;
          }
        }
      }
    }
  }
  {
#line 830
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 831
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 834 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Right(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 836
  pgdata = ctx->data;
#line 837
  pgo = ctx->output;
#line 838
  keystrokeRtn = 8;
#line 840
  tmp = ChewingIsEntering(pgdata);
  }
#line 840
  if (! tmp) {
#line 841
    keystrokeRtn = 1;
  }
#line 844
  if (pgdata->bSelect) {
#line 845
    if (pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1) {
#line 846
      (pgdata->choiceInfo.pageNo) ++;
    } else {
#line 848
      pgdata->choiceInfo.pageNo = 0;
    }
  } else {
    {
#line 851
    tmp___0 = ZuinIsEntering(& pgdata->zuinData);
    }
#line 851
    if (! tmp___0) {
#line 851
      if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {
        {
#line 854
        CheckAndResetRange(pgdata);
#line 855
        (pgdata->chiSymbolCursor) ++;
        }
      }
    }
  }
  {
#line 859
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 860
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Tab(ChewingContext *ctx ) 
{ 
  int cursor ;
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 866
  pgdata = ctx->data;
#line 867
  pgo = ctx->output;
#line 868
  keystrokeRtn = 8;
#line 870
  CheckAndResetRange(pgdata);
#line 872
  tmp = ChewingIsEntering(pgdata);
  }
#line 872
  if (! tmp) {
#line 873
    keystrokeRtn = 1;
  }
#line 877
  if (! pgdata->bSelect) {
#line 878
    if (pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen) {
#line 879
      (pgdata->phrOut.nNumCut) ++;
    } else {
      {
#line 881
      tmp___1 = ChewingIsChiAt(pgdata->chiSymbolCursor - 1, pgdata);
      }
#line 881
      if (tmp___1) {
        {
#line 882
        cursor = PhoneSeqCursor(pgdata);
#line 883
        tmp___0 = IsPreferIntervalConnted(cursor, pgdata);
        }
#line 883
        if (tmp___0) {
#line 884
          pgdata->bUserArrBrkpt[cursor] = 1;
#line 885
          pgdata->bUserArrCnnct[cursor] = 0;
        } else {
#line 888
          pgdata->bUserArrBrkpt[cursor] = 0;
#line 889
          pgdata->bUserArrCnnct[cursor] = 1;
        }
      }
    }
    {
#line 892
    CallPhrasing(pgdata);
    }
  }
  {
#line 894
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 895
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 898 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_DblTab(ChewingContext *ctx ) 
{ 
  int cursor ;
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;

  {
  {
#line 901
  pgdata = ctx->data;
#line 902
  pgo = ctx->output;
#line 903
  keystrokeRtn = 8;
#line 905
  CheckAndResetRange(pgdata);
#line 907
  tmp = ChewingIsEntering(pgdata);
  }
#line 907
  if (! tmp) {
#line 908
    keystrokeRtn = 1;
  }
#line 911
  if (! pgdata->bSelect) {
    {
#line 912
    cursor = PhoneSeqCursor(pgdata);
#line 913
    pgdata->bUserArrBrkpt[cursor] = 0;
#line 914
    pgdata->bUserArrCnnct[cursor] = 0;
    }
  }
  {
#line 916
  CallPhrasing(pgdata);
#line 918
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 919
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Capslock(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;

  {
  {
#line 925
  pgdata = ctx->data;
#line 926
  pgo = ctx->output;
#line 928
  pgdata->bChiSym = 1 - pgdata->bChiSym;
#line 929
  MakeOutputWithRtn(pgo, pgdata, 8);
  }
#line 930
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Home(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;

  {
  {
#line 935
  pgdata = ctx->data;
#line 936
  pgo = ctx->output;
#line 937
  keystrokeRtn = 8;
#line 939
  CheckAndResetRange(pgdata);
#line 941
  tmp = ChewingIsEntering(pgdata);
  }
#line 941
  if (tmp) {
#line 944
    if (! pgdata->bSelect) {
#line 945
      pgdata->chiSymbolCursor = 0;
    }
  } else {
#line 942
    keystrokeRtn = 1;
  }
  {
#line 947
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 948
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 951 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_End(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;

  {
  {
#line 953
  pgdata = ctx->data;
#line 954
  pgo = ctx->output;
#line 955
  keystrokeRtn = 8;
#line 957
  CheckAndResetRange(pgdata);
#line 959
  tmp = ChewingIsEntering(pgdata);
  }
#line 959
  if (tmp) {
#line 962
    if (! pgdata->bSelect) {
#line 963
      pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
    }
  } else {
#line 960
    keystrokeRtn = 1;
  }
  {
#line 965
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 966
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_PageUp(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;

  {
  {
#line 971
  pgdata = ctx->data;
#line 972
  pgo = ctx->output;
#line 973
  keystrokeRtn = 8;
#line 975
  CheckAndResetRange(pgdata);
#line 977
  tmp = ChewingIsEntering(pgdata);
  }
#line 977
  if (tmp) {
#line 980
    if (! pgdata->bSelect) {
#line 981
      pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
    }
  } else {
#line 978
    keystrokeRtn = 1;
  }
  {
#line 983
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 984
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_PageDown(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int tmp ;

  {
  {
#line 989
  pgdata = ctx->data;
#line 990
  pgo = ctx->output;
#line 991
  keystrokeRtn = 8;
#line 993
  CheckAndResetRange(pgdata);
#line 995
  tmp = ChewingIsEntering(pgdata);
  }
#line 995
  if (tmp) {
#line 998
    if (! pgdata->bSelect) {
#line 999
      pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
    }
  } else {
#line 996
    keystrokeRtn = 1;
  }
  {
#line 1001
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 1002
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
static int dvorak_convert(int key ) 
{ 
  char dkey[68] ;
  char qkey[68] ;
  size_t i ;
  char __constr_expr_13[68] ;

  {
#line 1008
  dkey[0] = (char )'\'';
#line 1008
  dkey[1] = (char )'\"';
#line 1008
  dkey[2] = (char )',';
#line 1008
  dkey[3] = (char )'<';
#line 1008
  dkey[4] = (char )'.';
#line 1008
  dkey[5] = (char )'>';
#line 1008
  dkey[6] = (char )'p';
#line 1008
  dkey[7] = (char )'P';
#line 1008
  dkey[8] = (char )'y';
#line 1008
  dkey[9] = (char )'Y';
#line 1008
  dkey[10] = (char )'f';
#line 1008
  dkey[11] = (char )'F';
#line 1008
  dkey[12] = (char )'g';
#line 1008
  dkey[13] = (char )'G';
#line 1008
  dkey[14] = (char )'c';
#line 1008
  dkey[15] = (char )'C';
#line 1008
  dkey[16] = (char )'r';
#line 1008
  dkey[17] = (char )'R';
#line 1008
  dkey[18] = (char )'l';
#line 1008
  dkey[19] = (char )'L';
#line 1008
  dkey[20] = (char )'/';
#line 1008
  dkey[21] = (char )'?';
#line 1008
  dkey[22] = (char )'=';
#line 1008
  dkey[23] = (char )'+';
#line 1008
  dkey[24] = (char )'\\';
#line 1008
  dkey[25] = (char )'|';
#line 1008
  dkey[26] = (char )'a';
#line 1008
  dkey[27] = (char )'A';
#line 1008
  dkey[28] = (char )'o';
#line 1008
  dkey[29] = (char )'O';
#line 1008
  dkey[30] = (char )'e';
#line 1008
  dkey[31] = (char )'E';
#line 1008
  dkey[32] = (char )'u';
#line 1008
  dkey[33] = (char )'U';
#line 1008
  dkey[34] = (char )'i';
#line 1008
  dkey[35] = (char )'I';
#line 1008
  dkey[36] = (char )'d';
#line 1008
  dkey[37] = (char )'D';
#line 1008
  dkey[38] = (char )'h';
#line 1008
  dkey[39] = (char )'H';
#line 1008
  dkey[40] = (char )'t';
#line 1008
  dkey[41] = (char )'T';
#line 1008
  dkey[42] = (char )'n';
#line 1008
  dkey[43] = (char )'N';
#line 1008
  dkey[44] = (char )'s';
#line 1008
  dkey[45] = (char )'S';
#line 1008
  dkey[46] = (char )'-';
#line 1008
  dkey[47] = (char )'_';
#line 1008
  dkey[48] = (char )';';
#line 1008
  dkey[49] = (char )':';
#line 1008
  dkey[50] = (char )'q';
#line 1008
  dkey[51] = (char )'Q';
#line 1008
  dkey[52] = (char )'j';
#line 1008
  dkey[53] = (char )'J';
#line 1008
  dkey[54] = (char )'k';
#line 1008
  dkey[55] = (char )'K';
#line 1008
  dkey[56] = (char )'x';
#line 1008
  dkey[57] = (char )'X';
#line 1008
  dkey[58] = (char )'b';
#line 1008
  dkey[59] = (char )'B';
#line 1008
  dkey[60] = (char )'m';
#line 1008
  dkey[61] = (char )'M';
#line 1008
  dkey[62] = (char )'w';
#line 1008
  dkey[63] = (char )'W';
#line 1008
  dkey[64] = (char )'v';
#line 1008
  dkey[65] = (char )'V';
#line 1008
  dkey[66] = (char )'z';
#line 1008
  dkey[67] = (char )'Z';
#line 1015
  qkey[0] = (char )'q';
#line 1015
  qkey[1] = (char )'Q';
#line 1015
  qkey[2] = (char )'w';
#line 1015
  qkey[3] = (char )'W';
#line 1015
  qkey[4] = (char )'e';
#line 1015
  qkey[5] = (char )'E';
#line 1015
  qkey[6] = (char )'r';
#line 1015
  qkey[7] = (char )'R';
#line 1015
  qkey[8] = (char )'t';
#line 1015
  qkey[9] = (char )'T';
#line 1015
  qkey[10] = (char )'y';
#line 1015
  qkey[11] = (char )'Y';
#line 1015
  qkey[12] = (char )'u';
#line 1015
  qkey[13] = (char )'U';
#line 1015
  qkey[14] = (char )'i';
#line 1015
  qkey[15] = (char )'I';
#line 1015
  qkey[16] = (char )'o';
#line 1015
  qkey[17] = (char )'O';
#line 1015
  qkey[18] = (char )'p';
#line 1015
  qkey[19] = (char )'P';
#line 1015
  qkey[20] = (char )'[';
#line 1015
  qkey[21] = (char )'{';
#line 1015
  qkey[22] = (char )']';
#line 1015
  qkey[23] = (char )'}';
#line 1015
  qkey[24] = (char )'\\';
#line 1015
  qkey[25] = (char )'|';
#line 1015
  qkey[26] = (char )'a';
#line 1015
  qkey[27] = (char )'A';
#line 1015
  qkey[28] = (char )'s';
#line 1015
  qkey[29] = (char )'S';
#line 1015
  qkey[30] = (char )'d';
#line 1015
  qkey[31] = (char )'D';
#line 1015
  qkey[32] = (char )'f';
#line 1015
  qkey[33] = (char )'F';
#line 1015
  qkey[34] = (char )'g';
#line 1015
  qkey[35] = (char )'G';
#line 1015
  qkey[36] = (char )'h';
#line 1015
  qkey[37] = (char )'H';
#line 1015
  qkey[38] = (char )'j';
#line 1015
  qkey[39] = (char )'J';
#line 1015
  qkey[40] = (char )'k';
#line 1015
  qkey[41] = (char )'K';
#line 1015
  qkey[42] = (char )'l';
#line 1015
  qkey[43] = (char )'L';
#line 1015
  qkey[44] = (char )';';
#line 1015
  qkey[45] = (char )':';
#line 1015
  qkey[46] = (char )'\'';
#line 1015
  qkey[47] = (char )'\"';
#line 1015
  qkey[48] = (char )'z';
#line 1015
  qkey[49] = (char )'Z';
#line 1015
  qkey[50] = (char )'x';
#line 1015
  qkey[51] = (char )'X';
#line 1015
  qkey[52] = (char )'c';
#line 1015
  qkey[53] = (char )'C';
#line 1015
  qkey[54] = (char )'v';
#line 1015
  qkey[55] = (char )'V';
#line 1015
  qkey[56] = (char )'b';
#line 1015
  qkey[57] = (char )'B';
#line 1015
  qkey[58] = (char )'n';
#line 1015
  qkey[59] = (char )'N';
#line 1015
  qkey[60] = (char )'m';
#line 1015
  qkey[61] = (char )'M';
#line 1015
  qkey[62] = (char )',';
#line 1015
  qkey[63] = (char )'<';
#line 1015
  qkey[64] = (char )'.';
#line 1015
  qkey[65] = (char )'>';
#line 1015
  qkey[66] = (char )'/';
#line 1015
  qkey[67] = (char )'?';
#line 1026
  i = (size_t )0;
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1026
    if (! (i < sizeof(dkey) / sizeof(__constr_expr_13[0]))) {
#line 1026
      goto while_break;
    }
#line 1027
    if (key == (int )qkey[i]) {
#line 1028
      key = (int )dkey[i];
#line 1029
      return (key);
    }
#line 1026
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1032
  return (key);
}
}
#line 1035 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Default(ChewingContext *ctx ,
                                                                       int key ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int rtn ;
  int num ;
  int keystrokeRtn ;
  int bQuickCommit ;
  unsigned short const   **tmp ;
  int __attribute__((__visibility__("default")))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int i ;

  {
#line 1037
  pgdata = ctx->data;
#line 1038
  pgo = ctx->output;
#line 1040
  keystrokeRtn = 8;
#line 1041
  bQuickCommit = 0;
#line 1044
  ((ctx->data)->static_data.chewing_lifetime) ++;
#line 1047
  if (key & 65280) {
#line 1048
    keystrokeRtn = 1;
#line 1049
    goto End_KeyDefault;
  }
  {
#line 1053
  tmp = __ctype_b_loc();
  }
#line 1053
  if (! ((int const   )*(*tmp + key) & 16384)) {
#line 1054
    goto End_KeyDefault;
  }
  {
#line 1056
  CheckAndResetRange(pgdata);
  }
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1058
    (*(pgdata->logger))(pgdata->loggerData, 1, "[ File: %s  Func: %s  Line: %d ]\n",
                        "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c",
                        "chewing_handle_Default", 1058);
    }
#line 1058
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1059
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1059
    (*(pgdata->logger))(pgdata->loggerData, 3, "   key=%d", key);
    }
#line 1059
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1062
  if (pgdata->zuinData.kbtype == 7) {
    {
#line 1063
    key = dvorak_convert(key);
    }
  }
#line 1067
  if (pgdata->bSelect) {
#line 1068
    if (key == 32) {
      {
#line 1069
      tmp___0 = chewing_handle_Right(ctx);
      }
#line 1069
      return (tmp___0);
    }
    {
#line 1071
    num = CountSelKeyNum(key, pgdata);
    }
#line 1072
    if (num >= 0) {
      {
#line 1073
      DoSelect(pgdata, num);
      }
#line 1074
      goto End_keyproc;
    }
    {
#line 1078
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1078
      (*(pgdata->logger))(pgdata->loggerData, 3, "\t\tchecking paging key, got \'%c\'\n",
                          key);
      }
#line 1078
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1083
    if (key == 74) {
#line 1083
      goto case_74;
    }
#line 1083
    if (key == 106) {
#line 1083
      goto case_74;
    }
#line 1098
    if (key == 75) {
#line 1098
      goto case_75;
    }
#line 1098
    if (key == 107) {
#line 1098
      goto case_75;
    }
#line 1111
    goto switch_default;
    case_74: /* CIL Label */ 
    case_106: /* CIL Label */ 
#line 1084
    if (pgdata->chiSymbolCursor > 0) {
      {
#line 1085
      tmp___1 = ChewingIsEntering(pgdata);
      }
#line 1085
      if (! tmp___1) {
#line 1086
        keystrokeRtn = 1;
      }
      {
#line 1088
      CheckAndResetRange(pgdata);
#line 1089
      (pgdata->chiSymbolCursor) --;
#line 1090
      tmp___2 = ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata);
      }
#line 1090
      if (tmp___2) {
        {
#line 1091
        ChoiceFirstAvail(pgdata);
        }
      } else {
        {
#line 1093
        OpenSymbolChoice(pgdata);
        }
      }
    }
#line 1096
    goto End_Paging;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 1099
    if (pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen) {
      {
#line 1100
      tmp___3 = ChewingIsEntering(pgdata);
      }
#line 1100
      if (! tmp___3) {
#line 1101
        keystrokeRtn = 1;
      }
      {
#line 1103
      CheckAndResetRange(pgdata);
#line 1104
      (pgdata->chiSymbolCursor) ++;
#line 1105
      tmp___4 = ChewingIsChiAt(pgdata->chiSymbolCursor, pgdata);
      }
#line 1105
      if (tmp___4) {
        {
#line 1106
        ChoiceFirstAvail(pgdata);
        }
      } else {
        {
#line 1108
        OpenSymbolChoice(pgdata);
        }
      }
    }
#line 1110
    goto End_Paging;
    switch_default: /* CIL Label */ 
#line 1112
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 1117
  if (pgdata->bChiSym == 1) {
#line 1118
    if (pgdata->config.bEasySymbolInput != 0) {
      {
#line 1119
      EasySymbolInput(key, pgdata);
      }
#line 1120
      goto End_keyproc;
    }
#line 1124
    if (key == 96) {
      {
#line 1125
      pgdata->bSelect = 1;
#line 1126
      pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
#line 1128
      HaninSymbolInput(pgdata);
      }
#line 1129
      goto End_KeyDefault;
    }
    {
#line 1132
    rtn = ZuinPhoInput(pgdata, key);
    }
    {
#line 1133
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1133
      (*(pgdata->logger))(pgdata->loggerData, 3, "\t\tChinese mode key, ZuinPhoInput return value = %d\n",
                          rtn);
      }
#line 1133
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1138
    if (rtn == 4) {
      {
#line 1139
      rtn = SpecialSymbolInput(key, pgdata);
      }
    }
    {
#line 1141
    if (rtn == 1) {
#line 1141
      goto case_1;
    }
#line 1144
    if (rtn == 2) {
#line 1144
      goto case_2;
    }
#line 1147
    if (rtn == 16) {
#line 1147
      goto case_16;
    }
#line 1151
    if (rtn == 0) {
#line 1151
      goto case_0;
    }
#line 1151
    if (rtn == 4) {
#line 1151
      goto case_0;
    }
#line 1140
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 1142
    keystrokeRtn = 8;
#line 1143
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 1145
    AddChi(pgdata->zuinData.phone, pgdata->zuinData.phoneAlt, pgdata);
    }
#line 1146
    goto switch_break___0;
    case_16: /* CIL Label */ 
#line 1148
    keystrokeRtn = 12;
#line 1149
    goto switch_break___0;
    case_0: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 1152
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1152
      (*(pgdata->logger))(pgdata->loggerData, 3, "\t\tbefore isupper(key),key=%d\n",
                          key);
      }
#line 1152
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1156
    tmp___5 = __ctype_b_loc();
    }
#line 1156
    if ((int const   )*(*tmp___5 + key) & 256) {
      {
#line 1157
      key = tolower(key);
      }
    }
    {
#line 1159
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1159
      (*(pgdata->logger))(pgdata->loggerData, 3, "\t\tafter isupper(key),key=%d\n",
                          key);
      }
#line 1159
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1164
    if (pgdata->chiSymbolBufLen == 0) {
#line 1165
      bQuickCommit = 1;
    }
#line 1168
    if (pgdata->config.bEasySymbolInput == 0) {
#line 1169
      if (pgdata->bFullShape) {
        {
#line 1170
        rtn = FullShapeSymbolInput(key, pgdata);
        }
      } else {
        {
#line 1172
        rtn = SymbolInput(key, pgdata);
        }
      }
    }
#line 1175
    if (rtn == 1) {
#line 1176
      keystrokeRtn = 1;
#line 1181
      bQuickCommit = 0;
    } else {
#line 1184
      keystrokeRtn = 8;
    }
#line 1186
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else {
#line 1193
    if (pgdata->chiSymbolBufLen == 0) {
#line 1194
      bQuickCommit = 1;
    }
#line 1196
    if (pgdata->bFullShape) {
      {
#line 1197
      rtn = FullShapeSymbolInput(key, pgdata);
      }
    } else {
      {
#line 1200
      rtn = SymbolInput(key, pgdata);
      }
    }
#line 1203
    if (rtn == 1) {
#line 1204
      keystrokeRtn = 1;
#line 1205
      bQuickCommit = 0;
    }
  }
  End_keyproc: 
#line 1211
  if (! bQuickCommit) {
    {
#line 1212
    CallPhrasing(pgdata);
#line 1213
    tmp___6 = ReleaseChiSymbolBuf(pgdata, pgo);
    }
#line 1213
    if (tmp___6 != 0) {
#line 1214
      keystrokeRtn = 2;
    }
  } else {
    {
#line 1218
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1218
      (*(pgdata->logger))(pgdata->loggerData, 3, "\t\tQuick commit buf[0]=%c\n", (int )pgdata->chiSymbolBuf[0].s[0]);
      }
#line 1218
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1221
    pgo->commitStr[0] = pgdata->chiSymbolBuf[0];
#line 1222
    pgo->nCommitStr = 1;
#line 1223
    pgdata->chiSymbolBufLen = 0;
#line 1224
    pgdata->chiSymbolCursor = 0;
#line 1225
    keystrokeRtn = 2;
  }
#line 1228
  if (pgdata->phrOut.nNumCut > 0) {
#line 1230
    i = 0;
    {
#line 1230
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1230
      if (! (i < pgdata->phrOut.nDispInterval)) {
#line 1230
        goto while_break___6;
      }
#line 1231
      pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].from] = 1;
#line 1232
      pgdata->bUserArrBrkpt[pgdata->phrOut.dispInterval[i].to] = 1;
#line 1230
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1234
    pgdata->phrOut.nNumCut = 0;
  }
  End_KeyDefault: 
  {
#line 1238
  CallPhrasing(pgdata);
  }
  End_Paging: 
  {
#line 1240
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 1241
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1244 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_CtrlNum(ChewingContext *ctx ,
                                                                       int key ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;
  int newPhraseLen ;
  int i ;
  uint16_t addPhoneSeq[50] ;
  char addWordSeq[301] ;
  int phraseState ;
  int cursor ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1246
  pgdata = ctx->data;
#line 1247
  pgo = ctx->output;
#line 1248
  keystrokeRtn = 8;
#line 1256
  CheckAndResetRange(pgdata);
  }
#line 1258
  if (pgdata->bSelect) {
#line 1259
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 1261
  CallPhrasing(pgdata);
#line 1262
  newPhraseLen = key - 48;
  }
#line 1264
  if (key == 48) {
#line 1264
    goto _L;
  } else
#line 1264
  if (key == 49) {
    _L: /* CIL Label */ 
    {
#line 1265
    pgdata->bSelect = 1;
#line 1266
    pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
#line 1268
    HaninSymbolInput(pgdata);
#line 1269
    CallPhrasing(pgdata);
#line 1270
    MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
    }
#line 1271
    return ((int __attribute__((__visibility__("default")))  )0);
  }
  {
#line 1274
  cursor = PhoneSeqCursor(pgdata);
  }
#line 1275
  if (! pgdata->config.bAddPhraseForward) {
#line 1276
    if (newPhraseLen >= 1) {
#line 1276
      if ((cursor + newPhraseLen) - 1 <= pgdata->nPhoneSeq) {
        {
#line 1279
        tmp___0 = NoSymbolBetween(pgdata, cursor, cursor + newPhraseLen);
        }
#line 1279
        if (tmp___0) {
          {
#line 1284
          memcpy((void */* __restrict  */)(addPhoneSeq), (void const   */* __restrict  */)(& pgdata->phoneSeq[cursor]),
                 sizeof(uint16_t ) * (unsigned long )newPhraseLen);
#line 1287
          addPhoneSeq[newPhraseLen] = (uint16_t )0;
#line 1288
          tmp = ueStrSeek((char *)(& pgdata->phrOut.chiBuf), (size_t )cursor);
#line 1288
          ueStrNCpy(addWordSeq, (char const   *)tmp, (size_t )newPhraseLen, 1);
#line 1294
          phraseState = UserUpdatePhrase(pgdata, (uint16_t const   *)(addPhoneSeq),
                                         (char const   *)(addWordSeq));
#line 1295
          SetUpdatePhraseMsg(pgdata, (char const   *)(addWordSeq), newPhraseLen, phraseState);
#line 1302
          i = 1;
          }
          {
#line 1302
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1302
            if (! (i < newPhraseLen)) {
#line 1302
              goto while_break;
            }
#line 1303
            pgdata->bUserArrBrkpt[cursor + i] = 0;
#line 1302
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    }
  } else
#line 1308
  if (newPhraseLen >= 1) {
#line 1308
    if (cursor - newPhraseLen >= 0) {
      {
#line 1311
      tmp___2 = NoSymbolBetween(pgdata, cursor - newPhraseLen, cursor);
      }
#line 1311
      if (tmp___2) {
        {
#line 1315
        memcpy((void */* __restrict  */)(addPhoneSeq), (void const   */* __restrict  */)(& pgdata->phoneSeq[cursor - newPhraseLen]),
               sizeof(uint16_t ) * (unsigned long )newPhraseLen);
#line 1318
        addPhoneSeq[newPhraseLen] = (uint16_t )0;
#line 1319
        tmp___1 = ueStrSeek((char *)(& pgdata->phrOut.chiBuf), (size_t )(cursor - newPhraseLen));
#line 1319
        ueStrNCpy(addWordSeq, (char const   *)tmp___1, (size_t )newPhraseLen, 1);
#line 1324
        phraseState = UserUpdatePhrase(pgdata, (uint16_t const   *)(addPhoneSeq),
                                       (char const   *)(addWordSeq));
#line 1325
        SetUpdatePhraseMsg(pgdata, (char const   *)(addWordSeq), newPhraseLen, phraseState);
#line 1332
        i = 1;
        }
        {
#line 1332
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1332
          if (! (i < newPhraseLen)) {
#line 1332
            goto while_break___0;
          }
#line 1333
          pgdata->bUserArrBrkpt[(cursor - newPhraseLen) + i] = 0;
#line 1332
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1337
  CallPhrasing(pgdata);
#line 1338
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
#line 1339
  MakeOutputAddMsgAndCleanInterval(pgo, pgdata);
  }
#line 1340
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1343 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_ShiftSpace(ChewingContext *ctx ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int keystrokeRtn ;

  {
#line 1345
  pgdata = ctx->data;
#line 1346
  pgo = ctx->output;
#line 1347
  keystrokeRtn = 8;
#line 1349
  if (! pgdata->bSelect) {
    {
#line 1350
    CheckAndResetRange(pgdata);
    }
  }
  {
#line 1352
  CallPhrasing(pgdata);
#line 1353
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 1354
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1357 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_handle_Numlock(ChewingContext *ctx ,
                                                                       int key ) 
{ 
  ChewingData *pgdata ;
  ChewingOutput *pgo ;
  int rtn ;
  int QuickCommit ;
  int keystrokeRtn ;
  int tmp ;
  int num ;
  int tmp___0 ;

  {
#line 1359
  pgdata = ctx->data;
#line 1360
  pgo = ctx->output;
#line 1361
  QuickCommit = 0;
#line 1362
  keystrokeRtn = 8;
#line 1364
  if (! pgdata->bSelect) {
#line 1368
    if (pgdata->chiSymbolBufLen == 0) {
#line 1369
      QuickCommit = 1;
    }
    {
#line 1371
    rtn = SymbolInput(key, pgdata);
    }
#line 1373
    if (rtn == 1) {
#line 1374
      keystrokeRtn = 1;
    } else
#line 1376
    if (QuickCommit) {
#line 1377
      pgo->commitStr[0] = pgdata->chiSymbolBuf[0];
#line 1378
      pgo->nCommitStr = 1;
#line 1379
      pgdata->chiSymbolBufLen = 0;
#line 1380
      pgdata->chiSymbolCursor = 0;
#line 1381
      keystrokeRtn = 2;
    } else {
      {
#line 1384
      CallPhrasing(pgdata);
#line 1385
      tmp = ReleaseChiSymbolBuf(pgdata, pgo);
      }
#line 1385
      if (tmp != 0) {
#line 1386
        keystrokeRtn = 2;
      }
    }
  } else {
#line 1394
    num = -1;
#line 1395
    if (key > 48) {
#line 1395
      if (key < 57) {
#line 1396
        num = key - 49;
      } else {
#line 1395
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1397
    if (key == 48) {
#line 1398
      num = 9;
    }
    {
#line 1399
    DoSelect(pgdata, num);
    }
  }
  {
#line 1401
  CallPhrasing(pgdata);
#line 1402
  tmp___0 = ReleaseChiSymbolBuf(pgdata, pgo);
  }
#line 1402
  if (tmp___0 != 0) {
#line 1403
    keystrokeRtn = 2;
  }
  {
#line 1404
  MakeOutputWithRtn(pgo, pgdata, keystrokeRtn);
  }
#line 1405
  return ((int __attribute__((__visibility__("default")))  )0);
}
}
#line 1408 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
unsigned short __attribute__((__visibility__("default")))  *chewing_get_phoneSeq(ChewingContext *ctx ) 
{ 
  uint16_t *seq ;
  void *tmp ;

  {
  {
#line 1411
  tmp = calloc((size_t )(ctx->data)->nPhoneSeq, sizeof(uint16_t ));
#line 1411
  seq = (uint16_t *)tmp;
  }
#line 1412
  if (seq) {
    {
#line 1413
    memcpy((void */* __restrict  */)seq, (void const   */* __restrict  */)((ctx->data)->phoneSeq),
           sizeof(uint16_t ) * (unsigned long )(ctx->data)->nPhoneSeq);
    }
  }
#line 1414
  return ((unsigned short __attribute__((__visibility__("default")))  *)seq);
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
int __attribute__((__visibility__("default")))  chewing_get_phoneSeqLen(ChewingContext *ctx ) 
{ 


  {
#line 1419
  return ((int __attribute__((__visibility__("default")))  )(ctx->data)->nPhoneSeq);
}
}
#line 1422 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/chewingio.c"
void __attribute__((__visibility__("default")))  chewing_set_logger(ChewingContext *ctx ,
                                                                    void (*logger)(void *data ,
                                                                                   int level ,
                                                                                   char const   *fmt 
                                                                                   , ...) ,
                                                                    void *data ) 
{ 


  {
#line 1426
  if (! logger) {
#line 1427
    logger = & NullLogger;
#line 1428
    data = (void *)0;
  }
#line 1430
  (ctx->data)->logger = logger;
#line 1431
  (ctx->data)->loggerData = data;
#line 1432
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/pinyin.c"
void TerminatePinyin(ChewingData *pgdata ) 
{ 


  {
  {
#line 25
  free((void *)pgdata->static_data.hanyuInitialsMap);
#line 26
  free((void *)pgdata->static_data.hanyuFinalsMap);
  }
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/pinyin.c"
int InitPinyin(ChewingData *pgdata , char const   *prefix ) 
{ 
  char filename[4096] ;
  int i ;
  FILE *fd ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 36
  sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"%s/%s",
          prefix, "pinyin.tab");
#line 40
  fd = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
  }
#line 42
  if (! fd) {
#line 43
    return (0);
  }
  {
#line 45
  ret = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d",
               & pgdata->static_data.HANYU_INITIALS);
  }
#line 46
  if (ret != 1) {
#line 47
    return (0);
  }
  {
#line 49
  (pgdata->static_data.HANYU_INITIALS) ++;
#line 50
  tmp = calloc((size_t )pgdata->static_data.HANYU_INITIALS, sizeof(keymap ));
#line 50
  pgdata->static_data.hanyuInitialsMap = (keymap *)tmp;
#line 51
  i = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < pgdata->static_data.HANYU_INITIALS - 1)) {
#line 51
      goto while_break;
    }
    {
#line 52
    ret = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s %s",
                 (pgdata->static_data.hanyuInitialsMap + i)->pinyin, (pgdata->static_data.hanyuInitialsMap + i)->zuin);
    }
#line 55
    if (ret != 2) {
#line 56
      return (0);
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 60
  ret = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%d",
               & pgdata->static_data.HANYU_FINALS);
  }
#line 61
  if (ret != 1) {
#line 62
    return (0);
  }
  {
#line 64
  (pgdata->static_data.HANYU_FINALS) ++;
#line 65
  tmp___0 = calloc((size_t )pgdata->static_data.HANYU_FINALS, sizeof(keymap ));
#line 65
  pgdata->static_data.hanyuFinalsMap = (keymap *)tmp___0;
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 66
    if (! (i < pgdata->static_data.HANYU_FINALS - 1)) {
#line 66
      goto while_break___0;
    }
    {
#line 67
    ret = fscanf((FILE */* __restrict  */)fd, (char const   */* __restrict  */)"%s %s",
                 (pgdata->static_data.hanyuFinalsMap + i)->pinyin, (pgdata->static_data.hanyuFinalsMap + i)->zuin);
    }
#line 70
    if (ret != 2) {
#line 71
      return (0);
    }
#line 66
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 75
  fclose(fd);
  }
#line 77
  return (1);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/pinyin.c"
int PinyinToZuin(ChewingData *pgdata , char const   *pinyinKeySeq , char *zuinKeySeq ,
                 char *zuinKeySeqAlt ) 
{ 
  char const   *p ;
  char const   *cursor ;
  char const   *initial ;
  char const   *final ;
  char const   *seq ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char s[9] ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;

  {
  {
#line 91
  cursor = (char const   *)((void *)0);
#line 92
  initial = (char const   *)0;
#line 93
  final = (char const   *)0;
#line 94
  seq = (char const   *)0;
#line 98
  tmp___1 = strcmp(pinyinKeySeq, "tzu");
  }
#line 98
  if (tmp___1) {
    {
#line 101
    tmp = strcmp(pinyinKeySeq, "ssu");
    }
#line 101
    if (tmp) {
      {
#line 101
      tmp___0 = strcmp(pinyinKeySeq, "szu");
      }
#line 101
      if (! tmp___0) {
#line 103
        seq = "n n";
      }
    } else {
#line 103
      seq = "n n";
    }
  } else {
#line 99
    seq = "y yj";
  }
  {
#line 107
  tmp___16 = strcmp(pinyinKeySeq, "e");
  }
#line 107
  if (tmp___16) {
    {
#line 110
    tmp___15 = strcmp(pinyinKeySeq, "ch");
    }
#line 110
    if (tmp___15) {
      {
#line 113
      tmp___14 = strcmp(pinyinKeySeq, "sh");
      }
#line 113
      if (tmp___14) {
        {
#line 116
        tmp___13 = strcmp(pinyinKeySeq, "c");
        }
#line 116
        if (tmp___13) {
          {
#line 119
          tmp___12 = strcmp(pinyinKeySeq, "s");
          }
#line 119
          if (tmp___12) {
            {
#line 122
            tmp___11 = strcmp(pinyinKeySeq, "nu");
            }
#line 122
            if (tmp___11) {
              {
#line 125
              tmp___10 = strcmp(pinyinKeySeq, "lu");
              }
#line 125
              if (tmp___10) {
                {
#line 128
                tmp___9 = strcmp(pinyinKeySeq, "luan");
                }
#line 128
                if (tmp___9) {
                  {
#line 131
                  tmp___8 = strcmp(pinyinKeySeq, "niu");
                  }
#line 131
                  if (tmp___8) {
                    {
#line 134
                    tmp___7 = strcmp(pinyinKeySeq, "liu");
                    }
#line 134
                    if (tmp___7) {
                      {
#line 137
                      tmp___6 = strcmp(pinyinKeySeq, "jiu");
                      }
#line 137
                      if (tmp___6) {
                        {
#line 140
                        tmp___5 = strcmp(pinyinKeySeq, "chiu");
                        }
#line 140
                        if (tmp___5) {
                          {
#line 143
                          tmp___4 = strcmp(pinyinKeySeq, "shiu");
                          }
#line 143
                          if (tmp___4) {
                            {
#line 146
                            tmp___3 = strcmp(pinyinKeySeq, "ju");
                            }
#line 146
                            if (tmp___3) {
                              {
#line 149
                              tmp___2 = strcmp(pinyinKeySeq, "juan");
                              }
#line 149
                              if (! tmp___2) {
#line 150
                                seq = "rm0 5j0";
                              }
                            } else {
#line 147
                              seq = "rm 5j";
                            }
                          } else {
#line 144
                            seq = "vu. vm";
                          }
                        } else {
#line 141
                          seq = "fu. fm";
                        }
                      } else {
#line 138
                        seq = "ru. rm";
                      }
                    } else {
#line 135
                      seq = "xu. xm";
                    }
                  } else {
#line 132
                    seq = "su. sm";
                  }
                } else {
#line 129
                  seq = "xj0 xm0";
                }
              } else {
#line 126
                seq = "xj xm";
              }
            } else {
#line 123
              seq = "sj sm";
            }
          } else {
#line 120
            seq = "n v";
          }
        } else {
#line 117
          seq = "h f";
        }
      } else {
#line 114
        seq = "g v";
      }
    } else {
#line 111
      seq = "t f";
    }
  } else {
#line 108
    seq = "k ,";
  }
  {
#line 155
  if (pgdata->zuinData.kbtype == 9) {
#line 155
    goto case_9;
  }
#line 169
  if (pgdata->zuinData.kbtype == 10) {
#line 169
    goto case_10;
  }
#line 183
  if (pgdata->zuinData.kbtype == 11) {
#line 183
    goto case_11;
  }
#line 154
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___20 = strcmp(pinyinKeySeq, "chi");
  }
#line 156
  if (tmp___20) {
    {
#line 159
    tmp___19 = strcmp(pinyinKeySeq, "shi");
    }
#line 159
    if (tmp___19) {
      {
#line 162
      tmp___18 = strcmp(pinyinKeySeq, "ci");
      }
#line 162
      if (tmp___18) {
        {
#line 165
        tmp___17 = strcmp(pinyinKeySeq, "si");
        }
#line 165
        if (! tmp___17) {
#line 166
          seq = "n vu";
        }
      } else {
#line 163
        seq = "h fu";
      }
    } else {
#line 160
      seq = "g vu";
    }
  } else {
#line 157
    seq = "t fu";
  }
#line 168
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 170
  tmp___24 = strcmp(pinyinKeySeq, "chi");
  }
#line 170
  if (tmp___24) {
    {
#line 173
    tmp___23 = strcmp(pinyinKeySeq, "shi");
    }
#line 173
    if (tmp___23) {
      {
#line 176
      tmp___22 = strcmp(pinyinKeySeq, "ci");
      }
#line 176
      if (tmp___22) {
        {
#line 179
        tmp___21 = strcmp(pinyinKeySeq, "si");
        }
#line 179
        if (! tmp___21) {
#line 180
          seq = "vu n";
        }
      } else {
#line 177
        seq = "fu h";
      }
    } else {
#line 174
      seq = "vu g";
    }
  } else {
#line 171
    seq = "fu t";
  }
#line 182
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 184
  tmp___37 = strcmp(pinyinKeySeq, "chi");
  }
#line 184
  if (tmp___37) {
    {
#line 187
    tmp___36 = strcmp(pinyinKeySeq, "shi");
    }
#line 187
    if (tmp___36) {
      {
#line 190
      tmp___35 = strcmp(pinyinKeySeq, "ci");
      }
#line 190
      if (tmp___35) {
        {
#line 193
        tmp___34 = strcmp(pinyinKeySeq, "si");
        }
#line 193
        if (tmp___34) {
          {
#line 196
          tmp___33 = strcmp(pinyinKeySeq, "niu");
          }
#line 196
          if (tmp___33) {
            {
#line 199
            tmp___32 = strcmp(pinyinKeySeq, "liu");
            }
#line 199
            if (tmp___32) {
              {
#line 202
              tmp___31 = strcmp(pinyinKeySeq, "jiu");
              }
#line 202
              if (tmp___31) {
                {
#line 205
                tmp___30 = strcmp(pinyinKeySeq, "chiu");
                }
#line 205
                if (tmp___30) {
                  {
#line 208
                  tmp___29 = strcmp(pinyinKeySeq, "shiu");
                  }
#line 208
                  if (tmp___29) {
                    {
#line 211
                    tmp___28 = strcmp(pinyinKeySeq, "ju");
                    }
#line 211
                    if (tmp___28) {
                      {
#line 214
                      tmp___27 = strcmp(pinyinKeySeq, "juan");
                      }
#line 214
                      if (tmp___27) {
                        {
#line 217
                        tmp___26 = strcmp(pinyinKeySeq, "juen");
                        }
#line 217
                        if (tmp___26) {
                          {
#line 220
                          tmp___25 = strcmp(pinyinKeySeq, "tzu");
                          }
#line 220
                          if (! tmp___25) {
#line 221
                            seq = "yj y";
                          }
                        } else {
#line 218
                          seq = "5jp 5jp";
                        }
                      } else {
#line 215
                        seq = "5j0 rm0";
                      }
                    } else {
#line 212
                      seq = "5j rm";
                    }
                  } else {
#line 209
                    seq = "vm vu.";
                  }
                } else {
#line 206
                  seq = "fm fu.";
                }
              } else {
#line 203
                seq = "rm ru.";
              }
            } else {
#line 200
              seq = "xm xu.";
            }
          } else {
#line 197
            seq = "sm su.";
          }
        } else {
#line 194
          seq = "vu n";
        }
      } else {
#line 191
        seq = "fu h";
      }
    } else {
#line 188
      seq = "vu g";
    }
  } else {
#line 185
    seq = "fu t";
  }
#line 223
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 225
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
    {
#line 227
    strcpy((char */* __restrict  */)(s), (char const   */* __restrict  */)seq);
#line 228
    tmp___38 = strtok((char */* __restrict  */)(s), (char const   */* __restrict  */)" ");
#line 228
    initial = (char const   *)tmp___38;
#line 229
    strcpy((char */* __restrict  */)zuinKeySeq, (char const   */* __restrict  */)initial);
#line 230
    tmp___39 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 230
    initial = (char const   *)tmp___39;
#line 231
    strcpy((char */* __restrict  */)zuinKeySeqAlt, (char const   */* __restrict  */)initial);
    }
#line 232
    return (0);
  }
#line 236
  i = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < pgdata->static_data.HANYU_INITIALS)) {
#line 236
      goto while_break;
    }
    {
#line 237
    tmp___40 = strstr(pinyinKeySeq, (char const   *)((pgdata->static_data.hanyuInitialsMap + i)->pinyin));
#line 237
    p = (char const   *)tmp___40;
    }
#line 238
    if ((unsigned long )p == (unsigned long )pinyinKeySeq) {
      {
#line 239
      initial = (char const   *)((pgdata->static_data.hanyuInitialsMap + i)->zuin);
#line 240
      tmp___41 = strlen((char const   *)((pgdata->static_data.hanyuInitialsMap + i)->pinyin));
#line 240
      cursor = pinyinKeySeq + tmp___41;
      }
#line 242
      goto while_break;
    }
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (i == pgdata->static_data.HANYU_INITIALS) {
#line 251
    return (1);
  }
#line 254
  if (cursor) {
#line 255
    i = 0;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! (i < pgdata->static_data.HANYU_FINALS)) {
#line 255
        goto while_break___0;
      }
      {
#line 256
      tmp___42 = strcmp(cursor, (char const   *)((pgdata->static_data.hanyuFinalsMap + i)->pinyin));
      }
#line 256
      if (tmp___42 == 0) {
#line 257
        final = (char const   *)((pgdata->static_data.hanyuFinalsMap + i)->zuin);
#line 258
        goto while_break___0;
      }
#line 255
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 261
    if (i == pgdata->static_data.HANYU_FINALS) {
#line 262
      return (2);
    }
  }
  {
#line 270
  tmp___43 = strcmp(final, "=");
  }
#line 270
  if (! tmp___43) {
#line 271
    final = "";
  }
  {
#line 277
  tmp___51 = strcmp(final, "u");
  }
#line 277
  if (! tmp___51) {
    {
#line 278
    tmp___44 = strcmp(initial, "5");
    }
#line 278
    if (tmp___44) {
      {
#line 278
      tmp___45 = strcmp(initial, "t");
      }
#line 278
      if (tmp___45) {
        {
#line 278
        tmp___46 = strcmp(initial, "g");
        }
#line 278
        if (tmp___46) {
          {
#line 278
          tmp___47 = strcmp(initial, "b");
          }
#line 278
          if (tmp___47) {
            {
#line 278
            tmp___48 = strcmp(initial, "y");
            }
#line 278
            if (tmp___48) {
              {
#line 278
              tmp___49 = strcmp(initial, "h");
              }
#line 278
              if (tmp___49) {
                {
#line 278
                tmp___50 = strcmp(initial, "n");
                }
#line 278
                if (! tmp___50) {
#line 285
                  final = "";
                }
              } else {
#line 285
                final = "";
              }
            } else {
#line 285
              final = "";
            }
          } else {
#line 285
            final = "";
          }
        } else {
#line 285
          final = "";
        }
      } else {
#line 285
        final = "";
      }
    } else {
#line 285
      final = "";
    }
  }
  {
#line 294
  tmp___55 = strcmp(initial, "f");
  }
#line 294
  if (tmp___55) {
    {
#line 294
    tmp___56 = strcmp(initial, "r");
    }
#line 294
    if (tmp___56) {
      {
#line 294
      tmp___57 = strcmp(initial, "v");
      }
#line 294
      if (! tmp___57) {
        _L: /* CIL Label */ 
        {
#line 297
        tmp___54 = strcmp(final, "j0");
        }
#line 297
        if (tmp___54) {
          {
#line 300
          tmp___53 = strcmp(final, "jp");
          }
#line 300
          if (tmp___53) {
            {
#line 303
            tmp___52 = strcmp(final, "j");
            }
#line 303
            if (! tmp___52) {
#line 304
              final = "m";
            }
          } else {
#line 301
            final = "mp";
          }
        } else {
#line 298
          final = "m0";
        }
      }
    } else {
#line 294
      goto _L;
    }
  } else {
#line 294
    goto _L;
  }
  {
#line 317
  tmp___63 = strstr(final, "u");
  }
#line 317
  if ((unsigned long )final == (unsigned long )tmp___63) {
#line 317
    goto _L___0;
  } else {
    {
#line 317
    tmp___64 = strstr(final, "m");
    }
#line 317
    if ((unsigned long )final == (unsigned long )tmp___64) {
      _L___0: /* CIL Label */ 
      {
#line 319
      tmp___61 = strcmp(initial, "n");
      }
#line 319
      if (tmp___61) {
        {
#line 322
        tmp___60 = strcmp(initial, "g");
        }
#line 322
        if (tmp___60) {
          {
#line 325
          tmp___59 = strcmp(initial, "h");
          }
#line 325
          if (tmp___59) {
            {
#line 328
            tmp___58 = strcmp(initial, "t");
            }
#line 328
            if (! tmp___58) {
#line 329
              initial = "f";
            }
          } else {
#line 326
            initial = "f";
          }
        } else {
#line 323
          initial = "v";
        }
      } else {
#line 320
        initial = "v";
      }
    } else {
      {
#line 333
      tmp___62 = strcmp(initial, "r");
      }
#line 333
      if (! tmp___62) {
#line 334
        initial = "5";
      }
    }
  }
  {
#line 342
  tmp___67 = strcmp(initial, "1");
  }
#line 342
  if (tmp___67) {
    {
#line 342
    tmp___68 = strcmp(initial, "q");
    }
#line 342
    if (tmp___68) {
      {
#line 342
      tmp___69 = strcmp(initial, "a");
      }
#line 342
      if (tmp___69) {
        {
#line 342
        tmp___70 = strcmp(initial, "z");
        }
#line 342
        if (! tmp___70) {
          _L___1: /* CIL Label */ 
          {
#line 348
          tmp___66 = strcmp(final, "ji");
          }
#line 348
          if (tmp___66) {
            {
#line 350
            tmp___65 = strcmp(final, "j/");
            }
#line 350
            if (! tmp___65) {
#line 351
              final = "/";
            }
          } else {
#line 349
            final = "i";
          }
        }
      } else {
#line 342
        goto _L___1;
      }
    } else {
#line 342
      goto _L___1;
    }
  } else {
#line 342
    goto _L___1;
  }
  {
#line 356
  sprintf((char */* __restrict  */)zuinKeySeq, (char const   */* __restrict  */)"%s%s",
          initial, final);
#line 357
  strcpy((char */* __restrict  */)zuinKeySeqAlt, (char const   */* __restrict  */)zuinKeySeq);
  }
#line 358
  return (0);
}
}
#line 359 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c"
int get_search_path(char *path , size_t path_len ) 
{ 
  char *chewing_path ;
  char *home ;

  {
  {
#line 33
  chewing_path = getenv("CHEWING_PATH");
  }
#line 34
  if (chewing_path) {
    {
#line 35
    strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)chewing_path,
            path_len);
    }
  } else {
    {
#line 37
    home = getenv("HOME");
    }
#line 38
    if (home) {
      {
#line 39
      snprintf((char */* __restrict  */)path, path_len, (char const   */* __restrict  */)"%s/.chewing:/usr/local/lib/libchewing",
               home);
      }
    } else {
      {
#line 43
      strncpy((char */* __restrict  */)path, (char const   */* __restrict  */)":/usr/local/lib/libchewing",
              path_len);
      }
    }
  }
#line 47
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c"
static int are_all_files_readable(char const   *path , char const   * const  *files ,
                                  char *output , size_t output_len ) 
{ 
  int i ;
  int tmp ;

  {
#line 138
  if (! path) {
    {
#line 138
    __assert_fail("path", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  138U, "are_all_files_readable");
    }
  }
#line 139
  if (! files) {
    {
#line 139
    __assert_fail("files", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  139U, "are_all_files_readable");
    }
  }
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )*(files + i) != (unsigned long )((void *)0))) {
#line 141
      goto while_break;
    }
    {
#line 142
    snprintf((char */* __restrict  */)output, output_len, (char const   */* __restrict  */)"%s/%s",
             path, *(files + i));
#line 144
    tmp = access((char const   *)output, 4);
    }
#line 144
    if (tmp != 0) {
#line 145
      return (0);
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (1);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c"
int find_path_by_files(char const   *search_path , char const   * const  *files ,
                       char *output , size_t output_len ) 
{ 
  char buffer[4096] ;
  char *path ;
  char *saveptr ;
  int ret ;

  {
#line 163
  if (! search_path) {
    {
#line 163
    __assert_fail("search_path", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  163U, "find_path_by_files");
    }
  }
#line 164
  if (! files) {
    {
#line 164
    __assert_fail("files", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  164U, "find_path_by_files");
    }
  }
#line 165
  if (! output) {
    {
#line 165
    __assert_fail("output", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  165U, "find_path_by_files");
    }
  }
#line 166
  if (! output_len) {
    {
#line 166
    __assert_fail("output_len", "/home/june/repo/benchmarks/collector/temp/libchewing-0.3.5/src/porting_layer/src/plat_path.c",
                  166U, "find_path_by_files");
    }
  }
  {
#line 169
  strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)search_path,
          sizeof(buffer));
#line 171
  path = strtok_r((char */* __restrict  */)(buffer), (char const   */* __restrict  */)":",
                  (char **/* __restrict  */)(& saveptr));
  }
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! path) {
#line 171
      goto while_break;
    }
    {
#line 174
    ret = are_all_files_readable((char const   *)path, files, output, output_len);
    }
#line 175
    if (ret) {
      {
#line 176
      snprintf((char */* __restrict  */)output, output_len, (char const   */* __restrict  */)"%s",
               path);
      }
#line 177
      return (0);
    }
    {
#line 171
    path = strtok_r((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":",
                    (char **/* __restrict  */)(& saveptr));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (-1);
}
}
