/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 104 "../libsent/include/sent/stddefs.h"
typedef unsigned char boolean;
#line 183 "../libsent/include/sent/stddefs.h"
typedef float PROB;
#line 184 "../libsent/include/sent/stddefs.h"
typedef float LOGPROB;
#line 186 "../libsent/include/sent/stddefs.h"
typedef float VECT;
#line 53 "../libsent/include/sent/util.h"
struct _bmalloc_base {
   void *base ;
   char *now ;
   char *end ;
   struct _bmalloc_base *next ;
};
#line 53 "../libsent/include/sent/util.h"
typedef struct _bmalloc_base BMALLOC_BASE;
#line 34 "../libsent/include/sent/ptree.h"
union __anonunion_value_34 {
   void *data ;
   int thres_bit ;
};
#line 34 "../libsent/include/sent/ptree.h"
struct _apatnode {
   union __anonunion_value_34 value ;
   struct _apatnode *left0 ;
   struct _apatnode *right1 ;
};
#line 34 "../libsent/include/sent/ptree.h"
typedef struct _apatnode APATNODE;
#line 76 "../libsent/include/sent/mfcc.h"
struct __anonstruct_Value_39 {
   long smp_period ;
   long smp_freq ;
   int framesize ;
   int frameshift ;
   float preEmph ;
   int lifter ;
   int fbank_num ;
   int delWin ;
   int accWin ;
   float silFloor ;
   float escale ;
   int hipass ;
   int lopass ;
   int enormal ;
   int raw_e ;
   int zmeanframe ;
   int usepower ;
   float vtln_alpha ;
   float vtln_upper ;
   float vtln_lower ;
   int delta ;
   int acc ;
   int energy ;
   int c0 ;
   int absesup ;
   int cmn ;
   int cvn ;
   int mfcc_dim ;
   int baselen ;
   int vecbuflen ;
   int veclen ;
   int loaded ;
};
#line 76 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_Value_39 Value;
#line 96 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_HTK_HMM_StreamInfo_46 {
   short num ;
   short vsize[50] ;
};
#line 96 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_HTK_HMM_StreamInfo_46 HTK_HMM_StreamInfo;
#line 102 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_HTK_HMM_Options_47 {
   HTK_HMM_StreamInfo stream_info ;
   short vec_size ;
   short cov_type ;
   short dur_type ;
   short param_type ;
};
#line 102 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_HTK_HMM_Options_47 HTK_HMM_Options;
#line 111 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_trans {
   char *name ;
   short statenum ;
   PROB **a ;
   int id ;
   struct _HTK_HMM_trans *next ;
};
#line 111 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_trans HTK_HMM_Trans;
#line 120 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_variance {
   char *name ;
   VECT *vec ;
   short len ;
   struct _HTK_HMM_variance *next ;
};
#line 120 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_variance HTK_HMM_Var;
#line 128 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_dens {
   char *name ;
   VECT *mean ;
   short meanlen ;
   HTK_HMM_Var *var ;
   LOGPROB gconst ;
   struct _HTK_HMM_dens *next ;
};
#line 128 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_dens HTK_HMM_Dens;
#line 142 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_stream_weight {
   char *name ;
   VECT *weight ;
   short len ;
   struct _HTK_HMM_stream_weight *next ;
};
#line 142 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_stream_weight HTK_HMM_StreamWeight;
#line 157 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_PDF {
   char *name ;
   boolean tmix ;
   short stream_id ;
   short mix_num ;
   HTK_HMM_Dens **b ;
   PROB *bweight ;
   struct _HTK_HMM_PDF *next ;
};
#line 157 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_PDF HTK_HMM_PDF;
#line 171 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_state {
   char *name ;
   short nstream ;
   HTK_HMM_StreamWeight *w ;
   HTK_HMM_PDF **pdf ;
   int id ;
   struct _HTK_HMM_state *next ;
};
#line 171 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_state HTK_HMM_State;
#line 181 "../libsent/include/sent/htk_hmm.h"
struct _HTK_HMM_data {
   char *name ;
   short state_num ;
   HTK_HMM_State **s ;
   HTK_HMM_Trans *tr ;
   struct _HTK_HMM_data *next ;
};
#line 181 "../libsent/include/sent/htk_hmm.h"
typedef struct _HTK_HMM_data HTK_HMM_Data;
#line 249 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_CD_State_Set_50 {
   HTK_HMM_State **s ;
   unsigned short num ;
   unsigned short maxnum ;
};
#line 249 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_CD_State_Set_50 CD_State_Set;
#line 261 "../libsent/include/sent/htk_hmm.h"
struct _cd_set {
   char *name ;
   CD_State_Set *stateset ;
   unsigned short state_num ;
   HTK_HMM_Trans *tr ;
   struct _cd_set *next ;
};
#line 261 "../libsent/include/sent/htk_hmm.h"
typedef struct _cd_set CD_Set;
#line 269 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_HMM_CDSET_INFO_51 {
   boolean binary_malloc ;
   APATNODE *cdtree ;
};
#line 269 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_HMM_CDSET_INFO_51 HMM_CDSET_INFO;
#line 297 "../libsent/include/sent/htk_hmm.h"
union __anonunion_body_52 {
   HTK_HMM_Data *defined ;
   CD_Set *pseudo ;
};
#line 297 "../libsent/include/sent/htk_hmm.h"
struct _HMM_logical {
   char *name ;
   boolean is_pseudo ;
   union __anonunion_body_52 body ;
   struct _HMM_logical *next ;
};
#line 297 "../libsent/include/sent/htk_hmm.h"
typedef struct _HMM_logical HMM_Logical;
#line 323 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_HMM_basephone_54 {
   int num ;
   int bgnnum ;
   int endnum ;
   APATNODE *root ;
};
#line 323 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_HMM_basephone_54 HMM_basephone;
#line 335 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_HTK_HMM_INFO_55 {
   HTK_HMM_Options opt ;
   HTK_HMM_Trans *trstart ;
   HTK_HMM_Var *vrstart ;
   HTK_HMM_Dens *dnstart ;
   HTK_HMM_PDF *pdfstart ;
   HTK_HMM_StreamWeight *swstart ;
   HTK_HMM_State *ststart ;
   HTK_HMM_Data *start ;
   HMM_Logical *lgstart ;
   APATNODE *tr_root ;
   APATNODE *vr_root ;
   APATNODE *sw_root ;
   APATNODE *dn_root ;
   APATNODE *pdf_root ;
   APATNODE *st_root ;
   APATNODE *physical_root ;
   APATNODE *logical_root ;
   APATNODE *codebook_root ;
   HMM_basephone basephone ;
   HMM_CDSET_INFO cdset_info ;
   boolean need_multipath ;
   boolean multipath ;
   boolean is_triphone ;
   boolean is_tied_mixture ;
   short cdset_method ;
   short cdmax_num ;
   HMM_Logical *sp ;
   LOGPROB iwsp_penalty ;
   boolean variance_inversed ;
   int totaltransnum ;
   int totalmixnum ;
   int totalstatenum ;
   int totalhmmnum ;
   int totallogicalnum ;
   int totalpseudonum ;
   int totalpdfnum ;
   int codebooknum ;
   int maxcodebooksize ;
   int maxmixturenum ;
   int maxstatenum ;
   BMALLOC_BASE *mroot ;
   BMALLOC_BASE *lroot ;
   BMALLOC_BASE *cdset_root ;
   int *tmp_mixnum ;
   void *hook ;
};
#line 335 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_HTK_HMM_INFO_55 HTK_HMM_INFO;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 185 "../libsent/include/sent/stddefs.h"
typedef short SP16;
#line 196 "../libsent/include/sent/stddefs.h"
typedef unsigned short WORD_ID;
#line 88 "../libsent/include/sent/adin.h"
struct __anonstruct_DS_FILTER_41 {
   int decrate ;
   int intrate ;
   double hdn[513] ;
   int hdn_len ;
   int delay ;
   double x[256] ;
   double y[512] ;
   double rb[512] ;
   int indx ;
   int bp ;
   int count ;
};
#line 88 "../libsent/include/sent/adin.h"
typedef struct __anonstruct_DS_FILTER_41 DS_FILTER;
#line 105 "../libsent/include/sent/adin.h"
struct __anonstruct_DS_BUFFER_42 {
   DS_FILTER *fir[3] ;
   double *buf[4] ;
   int buflen ;
};
#line 105 "../libsent/include/sent/adin.h"
typedef struct __anonstruct_DS_BUFFER_42 DS_BUFFER;
#line 115 "../libsent/include/sent/adin.h"
struct __anonstruct_ZEROCROSS_43 {
   int trigger ;
   int length ;
   int offset ;
   int zero_cross ;
   int is_trig ;
   int sign ;
   int top ;
   int valid_len ;
   SP16 *data ;
   int *is_zc ;
   int level ;
};
#line 115 "../libsent/include/sent/adin.h"
typedef struct __anonstruct_ZEROCROSS_43 ZEROCROSS;
#line 68 "../libsent/include/sent/htk_param.h"
struct __anonstruct_HTK_Param_Header_47 {
   unsigned int samplenum ;
   unsigned int wshift ;
   unsigned short sampsize ;
   short samptype ;
};
#line 68 "../libsent/include/sent/htk_param.h"
typedef struct __anonstruct_HTK_Param_Header_47 HTK_Param_Header;
#line 76 "../libsent/include/sent/htk_param.h"
struct __anonstruct_HTK_Param_48 {
   HTK_Param_Header header ;
   unsigned int samplenum ;
   short veclen ;
   VECT **parvec ;
   short veclen_alloc ;
   unsigned int samplenum_alloc ;
   BMALLOC_BASE *mroot ;
};
#line 76 "../libsent/include/sent/htk_param.h"
typedef struct __anonstruct_HTK_Param_48 HTK_Param;
#line 117 "../libsent/include/sent/mfcc.h"
struct __anonstruct_FBankInfo_51 {
   int fftN ;
   int n ;
   int klo ;
   int khi ;
   float fres ;
   float *cf ;
   short *loChan ;
   float *loWt ;
   float *Re ;
   float *Im ;
};
#line 117 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_FBankInfo_51 FBankInfo;
#line 131 "../libsent/include/sent/mfcc.h"
struct __anonstruct_DeltaBuf_52 {
   float **mfcc ;
   int veclen ;
   float *vec ;
   int win ;
   int len ;
   int store ;
   boolean *is_on ;
   int B ;
};
#line 131 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_DeltaBuf_52 DeltaBuf;
#line 143 "../libsent/include/sent/mfcc.h"
struct __anonstruct_MFCCWork_53 {
   float *bf ;
   double *fbank ;
   FBankInfo fb ;
   int bflen ;
   double *costbl_hamming ;
   int costbl_hamming_len ;
   double *costbl_fft ;
   double *sintbl_fft ;
   int tbllen ;
   double *costbl_makemfcc ;
   int costbl_makemfcc_len ;
   double *sintbl_wcep ;
   int sintbl_wcep_len ;
   float sqrt2var ;
   float *ssbuf ;
   int ssbuflen ;
   float ss_floor ;
   float ss_alpha ;
};
#line 143 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_MFCCWork_53 MFCCWork;
#line 173 "../libsent/include/sent/mfcc.h"
struct __anonstruct_CMEAN_54 {
   float *mfcc_sum ;
   float *mfcc_var ;
   int framenum ;
};
#line 173 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_CMEAN_54 CMEAN;
#line 183 "../libsent/include/sent/mfcc.h"
struct __anonstruct_CMNWork_55 {
   CMEAN *clist ;
   int clist_max ;
   int clist_num ;
   float cweight ;
   float *cmean_init ;
   float *cvar_init ;
   int mfcc_dim ;
   int veclen ;
   boolean mean ;
   boolean var ;
   boolean cmean_init_set ;
   CMEAN now ;
};
#line 183 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_CMNWork_55 CMNWork;
#line 202 "../libsent/include/sent/mfcc.h"
struct __anonstruct_ENERGYWork_56 {
   LOGPROB max_last ;
   LOGPROB min_last ;
   LOGPROB max ;
};
#line 202 "../libsent/include/sent/mfcc.h"
typedef struct __anonstruct_ENERGYWork_56 ENERGYWork;
#line 51 "../libsent/include/sent/ptree.h"
union __anonunion_value_58 {
   int data ;
   int thres_bit ;
};
#line 51 "../libsent/include/sent/ptree.h"
struct _patnode {
   union __anonunion_value_58 value ;
   struct _patnode *left0 ;
   struct _patnode *right1 ;
};
#line 51 "../libsent/include/sent/ptree.h"
typedef struct _patnode PATNODE;
#line 199 "../libsent/include/sent/htk_hmm.h"
struct __anonstruct_GS_SET_62 {
   HTK_HMM_State *state ;
};
#line 199 "../libsent/include/sent/htk_hmm.h"
typedef struct __anonstruct_GS_SET_62 GS_SET;
#line 56 "../libsent/include/sent/hmm_calc.h"
struct __anonstruct_MIXCACHE_70 {
   LOGPROB score ;
   int id ;
};
#line 56 "../libsent/include/sent/hmm_calc.h"
typedef struct __anonstruct_MIXCACHE_70 MIXCACHE;
#line 65 "../libsent/include/sent/hmm_calc.h"
struct __hmmwork__ {
   LOGPROB (*calc_outprob)(struct __hmmwork__ * ) ;
   LOGPROB (*calc_outprob_state)(struct __hmmwork__ * ) ;
   void (*compute_gaussset)(struct __hmmwork__ * , HTK_HMM_Dens **g , int num , int *last_id ,
                            int lnum ) ;
   boolean (*compute_gaussset_init)(struct __hmmwork__ * ) ;
   void (*compute_gaussset_free)(struct __hmmwork__ * ) ;
   HTK_HMM_INFO *OP_hmminfo ;
   HTK_HMM_INFO *OP_gshmm ;
   HTK_Param *OP_param ;
   int OP_gprune_num ;
   int OP_time ;
   int OP_last_time ;
   HTK_HMM_State *OP_state ;
   int OP_state_id ;
   short OP_nstream ;
   VECT *OP_vec_stream[50] ;
   short OP_veclen_stream[50] ;
   VECT *OP_vec ;
   short OP_veclen ;
   int OP_calced_maxnum ;
   LOGPROB *OP_calced_score ;
   int *OP_calced_id ;
   int OP_calced_num ;
   int statenum ;
   LOGPROB **outprob_cache ;
   int outprob_allocframenum ;
   BMALLOC_BASE *croot ;
   LOGPROB *last_cache ;
   MIXCACHE ***mixture_cache ;
   short **mixture_cache_num ;
   BMALLOC_BASE *mroot ;
   int *tmix_last_id ;
   int tmix_allocframenum ;
   boolean *mixcalced ;
   LOGPROB *dimthres ;
   int dimthres_num ;
   LOGPROB *backmax ;
   int backmax_num ;
   LOGPROB *cd_nbest_maxprobs ;
   int cd_nbest_maxn ;
   int my_nbest ;
   int gms_allocframenum ;
   GS_SET *gsset ;
   int gsset_num ;
   int *state2gs ;
   boolean *gms_is_selected ;
   LOGPROB **fallback_score ;
   int *gsindex ;
   LOGPROB *t_fs ;
   int **gms_last_max_id_list ;
};
#line 65 "../libsent/include/sent/hmm_calc.h"
typedef struct __hmmwork__ HMMWork;
#line 53 "../libsent/include/sent/vocabulary.h"
struct __anonstruct_WORD_INFO_74 {
   WORD_ID maxnum ;
   WORD_ID num ;
   WORD_ID errnum ;
   WORD_ID linenum ;
   boolean do_conv ;
   boolean ok_flag ;
   unsigned char *wlen ;
   char **wname ;
   char **woutput ;
   HMM_Logical ***wseq ;
   WORD_ID *wton ;
   LOGPROB *cprob ;
   WORD_ID cwnum ;
   WORD_ID head_silwid ;
   WORD_ID tail_silwid ;
   short maxwn ;
   short maxwlen ;
   int totalstatenum ;
   int totalmodelnum ;
   int totaltransnum ;
   boolean *is_transparent ;
   APATNODE *errph_root ;
   BMALLOC_BASE *mroot ;
   void *work ;
   int work_num ;
};
#line 53 "../libsent/include/sent/vocabulary.h"
typedef struct __anonstruct_WORD_INFO_74 WORD_INFO;
#line 114 "../libsent/include/sent/ngram2.h"
typedef unsigned int NNID;
#line 118 "../libsent/include/sent/ngram2.h"
typedef unsigned char NNID_UPPER;
#line 119 "../libsent/include/sent/ngram2.h"
typedef unsigned short NNID_LOWER;
#line 137 "../libsent/include/sent/ngram2.h"
struct __anonstruct_NGRAM_TUPLE_INFO_75 {
   NNID totalnum ;
   boolean is24bit ;
   NNID bgnlistlen ;
   NNID_UPPER *bgn_upper ;
   NNID_LOWER *bgn_lower ;
   NNID *bgn ;
   WORD_ID *num ;
   WORD_ID *nnid2wid ;
   LOGPROB *prob ;
   NNID context_num ;
   LOGPROB *bo_wt ;
   boolean ct_compaction ;
   NNID_UPPER *nnid2ctid_upper ;
   NNID_LOWER *nnid2ctid_lower ;
};
#line 137 "../libsent/include/sent/ngram2.h"
typedef struct __anonstruct_NGRAM_TUPLE_INFO_75 NGRAM_TUPLE_INFO;
#line 165 "../libsent/include/sent/ngram2.h"
struct __ngram_info__ {
   int n ;
   int dir ;
   boolean from_bin ;
   boolean bigram_index_reversed ;
   boolean bos_eos_swap ;
   WORD_ID max_word_num ;
   char **wname ;
   PATNODE *root ;
   WORD_ID unk_id ;
   int unk_num ;
   LOGPROB unk_num_log ;
   boolean isopen ;
   NGRAM_TUPLE_INFO *d ;
   LOGPROB *bo_wt_1 ;
   LOGPROB *p_2 ;
   LOGPROB (*bigram_prob)(struct __ngram_info__ * , WORD_ID  , WORD_ID  ) ;
   BMALLOC_BASE *mroot ;
};
#line 165 "../libsent/include/sent/ngram2.h"
typedef struct __ngram_info__ NGRAM_INFO;
#line 55 "../libsent/include/sent/dfa.h"
struct _dfa_arc {
   short label ;
   int to_state ;
   struct _dfa_arc *next ;
};
#line 55 "../libsent/include/sent/dfa.h"
typedef struct _dfa_arc DFA_ARC;
#line 62 "../libsent/include/sent/dfa.h"
struct __anonstruct_DFA_STATE_76 {
   int number ;
   unsigned int status ;
   DFA_ARC *arc ;
};
#line 62 "../libsent/include/sent/dfa.h"
typedef struct __anonstruct_DFA_STATE_76 DFA_STATE;
#line 69 "../libsent/include/sent/dfa.h"
struct __anonstruct_TERM_INFO_77 {
   int term_num ;
   WORD_ID **tw ;
   int *wnum ;
};
#line 69 "../libsent/include/sent/dfa.h"
typedef struct __anonstruct_TERM_INFO_77 TERM_INFO;
#line 76 "../libsent/include/sent/dfa.h"
struct __anonstruct_DFA_INFO_78 {
   DFA_STATE *st ;
   int maxstatenum ;
   int state_num ;
   int arc_num ;
   int term_num ;
   int **cp ;
   int *cplen ;
   int *cpalloclen ;
   int *cp_begin ;
   int cp_begin_len ;
   int cp_begin_alloclen ;
   int *cp_end ;
   int cp_end_len ;
   int cp_end_alloclen ;
   TERM_INFO term ;
   boolean *is_sp ;
   WORD_ID sp_id ;
};
#line 76 "../libsent/include/sent/dfa.h"
typedef struct __anonstruct_DFA_INFO_78 DFA_INFO;
#line 32 "../libjulius/include/julius/multi-gram.h"
struct __multi_gram__ {
   char name[512] ;
   unsigned short id ;
   DFA_INFO *dfa ;
   WORD_INFO *winfo ;
   int hook ;
   boolean newbie ;
   boolean active ;
   int state_begin ;
   int cate_begin ;
   int word_begin ;
   struct __multi_gram__ *next ;
};
#line 32 "../libjulius/include/julius/multi-gram.h"
typedef struct __multi_gram__ MULTIGRAM;
#line 48 "../libjulius/include/julius/multi-gram.h"
struct __gram_list__ {
   char *dfafile ;
   char *dictfile ;
   struct __gram_list__ *next ;
};
#line 48 "../libjulius/include/julius/multi-gram.h"
typedef struct __gram_list__ GRAMLIST;
#line 55 "../libjulius/include/julius/wchmm.h"
union __anonunion_cache_80 {
   HTK_HMM_State *state ;
   CD_State_Set *lset ;
};
#line 55 "../libjulius/include/julius/wchmm.h"
struct __anonstruct_RC_INFO_79 {
   HMM_Logical *hmm ;
   short state_loc ;
   boolean last_is_lset ;
   union __anonunion_cache_80 cache ;
   WORD_ID lastwid_cache ;
};
#line 55 "../libjulius/include/julius/wchmm.h"
typedef struct __anonstruct_RC_INFO_79 RC_INFO;
#line 72 "../libjulius/include/julius/wchmm.h"
union __anonunion_cache_82 {
   HTK_HMM_State *state ;
   CD_State_Set *lset ;
};
#line 72 "../libjulius/include/julius/wchmm.h"
struct __anonstruct_LRC_INFO_81 {
   HMM_Logical *hmm ;
   short state_loc ;
   boolean last_is_lset ;
   WORD_ID category ;
   union __anonunion_cache_82 cache ;
   WORD_ID lastwid_cache ;
};
#line 72 "../libjulius/include/julius/wchmm.h"
typedef struct __anonstruct_LRC_INFO_81 LRC_INFO;
#line 93 "../libjulius/include/julius/wchmm.h"
union __anonunion_ACOUSTIC_SPEC_83 {
   HTK_HMM_State *state ;
   CD_State_Set *lset ;
   RC_INFO *rset ;
   LRC_INFO *lrset ;
};
#line 93 "../libjulius/include/julius/wchmm.h"
typedef union __anonunion_ACOUSTIC_SPEC_83 ACOUSTIC_SPEC;
#line 117 "../libjulius/include/julius/wchmm.h"
struct __anonstruct_LM_PROB_CACHE_85 {
   LOGPROB *probcache ;
   WORD_ID *lastwcache ;
   LOGPROB **iw_sc_cache ;
   int iw_cache_num ;
};
#line 117 "../libjulius/include/julius/wchmm.h"
typedef struct __anonstruct_LM_PROB_CACHE_85 LM_PROB_CACHE;
#line 162 "../libjulius/include/julius/wchmm.h"
struct __A_CELL2__ {
   unsigned short n ;
   int arc[4] ;
   LOGPROB a[4] ;
   struct __A_CELL2__ *next ;
};
#line 162 "../libjulius/include/julius/wchmm.h"
typedef struct __A_CELL2__ A_CELL2;
#line 178 "../libjulius/include/julius/wchmm.h"
struct wchmm_state {
   ACOUSTIC_SPEC out ;
   int scid ;
};
#line 178 "../libjulius/include/julius/wchmm.h"
typedef struct wchmm_state WCHMM_STATE;
#line 199 "../libjulius/include/julius/wchmm.h"
struct __anonstruct_WCHMM_WORK_86 {
   int *out_from ;
   int *out_from_next ;
   LOGPROB *out_a ;
   LOGPROB *out_a_next ;
   int out_from_len ;
};
#line 199 "../libjulius/include/julius/wchmm.h"
typedef struct __anonstruct_WCHMM_WORK_86 WCHMM_WORK;
#line 211 "../libjulius/include/julius/wchmm.h"
struct wchmm_info {
   int lmtype ;
   int lmvar ;
   boolean category_tree ;
   HTK_HMM_INFO *hmminfo ;
   NGRAM_INFO *ngram ;
   DFA_INFO *dfa ;
   WORD_INFO *winfo ;
   boolean ccd_flag ;
   int maxwcn ;
   int n ;
   WCHMM_STATE *state ;
   LOGPROB *self_a ;
   LOGPROB *next_a ;
   A_CELL2 **ac ;
   WORD_ID *stend ;
   int **offset ;
   int *wordend ;
   int startnum ;
   int *startnode ;
   int *wordbegin ;
   int maxstartnum ;
   WORD_ID *start2wid ;
   int *start2isolate ;
   int isolatenum ;
   LOGPROB *wordend_a ;
   unsigned char *outstyle ;
   WORD_ID *scword ;
   LOGPROB *fscore ;
   int fsnum ;
   WORD_ID **sclist ;
   WORD_ID *sclen ;
   int scnum ;
   BMALLOC_BASE *malloc_root ;
   APATNODE *lcdset_category_root ;
   BMALLOC_BASE *lcdset_mroot ;
   HMMWork *hmmwrk ;
   LM_PROB_CACHE lmcache ;
   WCHMM_WORK wrk ;
   int separated_word_count ;
   char lccbuf[263] ;
   char lccbuf2[263] ;
   LOGPROB (*uni_prob_user)(WORD_INFO * , WORD_ID  , LOGPROB  ) ;
   LOGPROB (*bi_prob_user)(WORD_INFO * , WORD_ID  , WORD_ID  , LOGPROB  ) ;
};
#line 211 "../libjulius/include/julius/wchmm.h"
typedef struct wchmm_info WCHMM_INFO;
#line 28 "../libjulius/include/julius/trellis.h"
struct __trellis_atom__ {
   LOGPROB backscore ;
   LOGPROB lscore ;
   WORD_ID wid ;
   short begintime ;
   short endtime ;
   struct __trellis_atom__ *last_tre ;
   struct __trellis_atom__ *next ;
};
#line 28 "../libjulius/include/julius/trellis.h"
typedef struct __trellis_atom__ TRELLIS_ATOM;
#line 46 "../libjulius/include/julius/trellis.h"
struct __backtrellis__ {
   int framelen ;
   int *num ;
   TRELLIS_ATOM ***rw ;
   TRELLIS_ATOM *list ;
   BMALLOC_BASE *root ;
};
#line 46 "../libjulius/include/julius/trellis.h"
typedef struct __backtrellis__ BACKTRELLIS;
#line 43 "../libjulius/include/julius/graph.h"
struct __word_graph__ {
   WORD_ID wid ;
   int lefttime ;
   int righttime ;
   LOGPROB fscore_head ;
   LOGPROB fscore_tail ;
   LOGPROB gscore_head ;
   LOGPROB gscore_tail ;
   LOGPROB lscore_tmp ;
   LOGPROB forward_score ;
   LOGPROB backward_score ;
   LOGPROB cmscore ;
   LOGPROB amavg ;
   HMM_Logical *headphone ;
   HMM_Logical *tailphone ;
   struct __word_graph__ **leftword ;
   LOGPROB *left_lscore ;
   int leftwordnum ;
   int leftwordmaxnum ;
   struct __word_graph__ **rightword ;
   LOGPROB *right_lscore ;
   int rightwordnum ;
   int rightwordmaxnum ;
   struct __word_graph__ *next ;
   boolean mark ;
   int id ;
   boolean saved ;
   boolean purged ;
   LOGPROB graph_cm ;
};
#line 43 "../libjulius/include/julius/graph.h"
typedef struct __word_graph__ WordGraph;
#line 82 "../libjulius/include/julius/graph.h"
struct __confnet_cluster__ {
   WordGraph **wg ;
   int wgnum ;
   int wgnum_alloc ;
   WORD_ID *words ;
   LOGPROB *pp ;
   int wordsnum ;
   struct __confnet_cluster__ *next ;
};
#line 82 "../libjulius/include/julius/graph.h"
typedef struct __confnet_cluster__ CN_CLUSTER;
#line 29 "../libjulius/include/julius/beam.h"
typedef int TOKENID;
#line 35 "../libjulius/include/julius/beam.h"
struct __anonstruct_TOKEN2_87 {
   TRELLIS_ATOM *last_tre ;
   WORD_ID last_cword ;
   LOGPROB last_lscore ;
   LOGPROB score ;
   int node ;
};
#line 35 "../libjulius/include/julius/beam.h"
typedef struct __anonstruct_TOKEN2_87 TOKEN2;
#line 88 "../libjulius/include/julius/search.h"
struct __recogprocess__;
#line 88 "../libjulius/include/julius/search.h"
struct __node__ {
   struct __node__ *next ;
   struct __node__ *prev ;
   boolean endflag ;
   WORD_ID seq[150] ;
   short seqnum ;
   LOGPROB score ;
   short bestt ;
   short estimated_next_t ;
   LOGPROB *g ;
   LOGPROB final_g ;
   int state ;
   TRELLIS_ATOM *tre ;
   LOGPROB *g_prev ;
   HMM_Logical *last_ph ;
   boolean last_ph_sp_attached ;
   LOGPROB lscore ;
   LOGPROB totallscore ;
   LOGPROB cmscore[150] ;
   short *wordend_frame ;
   LOGPROB *wordend_gscore ;
   WordGraph *prevgraph ;
   WordGraph *lastcontext ;
   struct __recogprocess__ *region ;
};
#line 88 "../libjulius/include/julius/search.h"
typedef struct __node__ NODE;
#line 68 "../libjulius/include/julius/jconf.h"
struct __anonstruct_analysis_92 {
   Value para ;
   Value para_default ;
   Value para_hmm ;
   Value para_htk ;
   char *cmnload_filename ;
   boolean cmn_update ;
   char *cmnsave_filename ;
   float cmn_map_weight ;
};
#line 68 "../libjulius/include/julius/jconf.h"
struct __anonstruct_frontend_93 {
   float ss_alpha ;
   float ss_floor ;
   boolean sscalc ;
   int sscalc_len ;
   char *ssload_filename ;
};
#line 68 "../libjulius/include/julius/jconf.h"
struct __jconf_am__ {
   short id ;
   char name[64] ;
   char *hmmfilename ;
   char *mapfilename ;
   int gprune_method ;
   int mixnum_thres ;
   char *spmodel_name ;
   char *hmm_gs_filename ;
   int gs_statenum ;
   short iwcdmethod ;
   short iwcdmaxn ;
   LOGPROB iwsp_penalty ;
   boolean force_multipath ;
   struct __anonstruct_analysis_92 analysis ;
   struct __anonstruct_frontend_93 frontend ;
   int gprune_plugin_source ;
   struct __jconf_am__ *next ;
};
#line 68 "../libjulius/include/julius/jconf.h"
typedef struct __jconf_am__ JCONF_AM;
#line 226 "../libjulius/include/julius/jconf.h"
struct __jconf_lm_namelist__ {
   char *name ;
   struct __jconf_lm_namelist__ *next ;
};
#line 226 "../libjulius/include/julius/jconf.h"
typedef struct __jconf_lm_namelist__ JCONF_LM_NAMELIST;
#line 242 "../libjulius/include/julius/jconf.h"
struct __jconf_lm__ {
   short id ;
   char name[64] ;
   int lmtype ;
   int lmvar ;
   char *dictfilename ;
   char *head_silname ;
   char *tail_silname ;
   boolean forcedict_flag ;
   char *ngram_filename ;
   char *ngram_filename_lr_arpa ;
   char *ngram_filename_rl_arpa ;
   char *dfa_filename ;
   GRAMLIST *gramlist_root ;
   GRAMLIST *wordlist_root ;
   boolean enable_iwsp ;
   boolean enable_iwspword ;
   char *iwspentry ;
   int separate_wnum ;
   char wordrecog_head_silence_model_name[256] ;
   char wordrecog_tail_silence_model_name[256] ;
   char wordrecog_silence_context_name[256] ;
   char unknown_name[30] ;
   JCONF_LM_NAMELIST *additional_dict_files ;
   JCONF_LM_NAMELIST *additional_dict_entries ;
   struct __jconf_lm__ *next ;
};
#line 242 "../libjulius/include/julius/jconf.h"
typedef struct __jconf_lm__ JCONF_LM;
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_lmp_94 {
   LOGPROB lm_weight ;
   LOGPROB lm_penalty ;
   LOGPROB lm_weight2 ;
   LOGPROB lm_penalty2 ;
   LOGPROB lm_penalty_trans ;
   LOGPROB penalty1 ;
   LOGPROB penalty2 ;
   boolean lmp2_specified ;
   boolean lmp_specified ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_pass1_95 {
   int specified_trellis_beam_width ;
   LOGPROB score_pruning_width ;
   boolean old_tree_function_flag ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_pass2_96 {
   int nbest ;
   int enveloped_bestfirst_width ;
   LOGPROB scan_beam_thres ;
   int hypo_overflow ;
   int stack_size ;
   int lookup_range ;
   boolean looktrellis_flag ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_graph_97 {
   boolean enabled ;
   boolean lattice ;
   boolean confnet ;
   int graph_merge_neighbor_range ;
   int graphout_cut_depth ;
   int graphout_limit_boundary_loop_num ;
   boolean graphout_search_delay ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_successive_98 {
   boolean enabled ;
   int sp_frame_duration ;
   char *pausemodelname ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_annotate_99 {
   LOGPROB cm_alpha ;
   boolean align_result_word_flag ;
   boolean align_result_phoneme_flag ;
   boolean align_result_state_flag ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_output_100 {
   int output_hypo_maxnum ;
   boolean progout_flag ;
   int progout_interval ;
   int progout_interval_frame ;
   boolean multigramout_flag ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __anonstruct_sw_101 {
   boolean trellis_check_flag ;
   boolean triphone_check_flag ;
   boolean wchmm_check_flag ;
   boolean start_inactive ;
   boolean fallback_pass1_flag ;
};
#line 380 "../libjulius/include/julius/jconf.h"
struct __jconf_search__ {
   short id ;
   char name[64] ;
   JCONF_AM *amconf ;
   JCONF_LM *lmconf ;
   boolean compute_only_1pass ;
   boolean ccd_handling ;
   boolean force_ccd_handling ;
   struct __anonstruct_lmp_94 lmp ;
   struct __anonstruct_pass1_95 pass1 ;
   struct __anonstruct_pass2_96 pass2 ;
   struct __anonstruct_graph_97 graph ;
   struct __anonstruct_successive_98 successive ;
   struct __anonstruct_annotate_99 annotate ;
   struct __anonstruct_output_100 output ;
   struct __anonstruct_sw_101 sw ;
   struct __jconf_search__ *next ;
};
#line 380 "../libjulius/include/julius/jconf.h"
typedef struct __jconf_search__ JCONF_SEARCH;
#line 803 "../libjulius/include/julius/jconf.h"
struct __anonstruct_input_102 {
   int type ;
   int speech_input ;
   int device ;
   int plugin_source ;
   long sfreq ;
   long period ;
   int framesize ;
   int frameshift ;
   boolean use_ds48to16 ;
   char *inputlist_filename ;
   int adinnet_port ;
   boolean paramtype_check_flag ;
};
#line 803 "../libjulius/include/julius/jconf.h"
struct __anonstruct_detect_103 {
   int level_thres ;
   int head_margin_msec ;
   int tail_margin_msec ;
   int zero_cross_num ;
   int silence_cut ;
   int chunk_size ;
};
#line 803 "../libjulius/include/julius/jconf.h"
struct __anonstruct_preprocess_104 {
   boolean strip_zero_sample ;
   boolean use_zmean ;
};
#line 803 "../libjulius/include/julius/jconf.h"
struct __anonstruct_reject_105 {
   char *gmm_filename ;
   int gmm_gprune_num ;
   char *gmm_reject_cmn_string ;
   int rejectshortlen ;
};
#line 803 "../libjulius/include/julius/jconf.h"
struct __anonstruct_decodeopt_106 {
   boolean realtime_flag ;
   boolean force_realtime_flag ;
   boolean forced_realtime ;
   boolean segment ;
};
#line 803 "../libjulius/include/julius/jconf.h"
struct __Jconf__ {
   struct __anonstruct_input_102 input ;
   struct __anonstruct_detect_103 detect ;
   struct __anonstruct_preprocess_104 preprocess ;
   struct __anonstruct_reject_105 reject ;
   struct __anonstruct_decodeopt_106 decodeopt ;
   JCONF_AM *am_root ;
   JCONF_LM *lm_root ;
   JCONF_SEARCH *search_root ;
   JCONF_LM *lmnow ;
   JCONF_AM *amnow ;
   JCONF_SEARCH *searchnow ;
   JCONF_AM *gmm ;
   short optsection ;
   boolean optsectioning ;
};
#line 803 "../libjulius/include/julius/jconf.h"
typedef struct __Jconf__ Jconf;
#line 114 "../libjulius/include/julius/recog.h"
struct __FSBeam__ {
   TOKEN2 *tlist[2] ;
   TOKENID *tindex[2] ;
   int maxtnum ;
   int expand_step ;
   boolean expanded ;
   int tnum[2] ;
   int n_start ;
   int n_end ;
   int tl ;
   int tn ;
   LOGPROB score_pruning_max ;
   LOGPROB score_pruning_threshold ;
   int score_pruning_count ;
   TOKENID *token ;
   LOGPROB wordend_best_score ;
   int wordend_best_node ;
   TRELLIS_ATOM *wordend_best_tre ;
   WORD_ID wordend_best_last_cword ;
   int totalnodenum ;
   TRELLIS_ATOM bos ;
   boolean nodes_malloced ;
   LOGPROB lm_weight ;
   LOGPROB lm_penalty ;
   LOGPROB lm_penalty_trans ;
   LOGPROB penalty1 ;
   boolean in_sparea ;
   int tmp_sparea_start ;
   WORD_ID last_tre_word ;
   boolean first_sparea ;
   int sp_duration ;
   char *pausemodelnames ;
   char **pausemodel ;
   int pausemodelnum ;
};
#line 114 "../libjulius/include/julius/recog.h"
typedef struct __FSBeam__ FSBeam;
#line 179 "../libjulius/include/julius/recog.h"
struct __RealBeam__ {
   int maxframelen ;
   SP16 *window ;
   int windowlen ;
   int windownum ;
   boolean last_is_segmented ;
   SP16 *rest_Speech ;
   int rest_alloc_len ;
   int rest_len ;
};
#line 179 "../libjulius/include/julius/recog.h"
typedef struct __RealBeam__ RealBeam;
#line 199 "../libjulius/include/julius/recog.h"
struct __StackDecode__ {
   int hypo_len_count[151] ;
   int maximum_filled_length ;
   LOGPROB *framemaxscore ;
   NODE *stocker_root ;
   int popctr ;
   int genectr ;
   int pushctr ;
   int finishnum ;
   NODE *current ;
   LOGPROB cm_alpha ;
   LOGPROB cm_tmpbestscore ;
   LOGPROB cm_tmpsum ;
   int l_stacksize ;
   int l_stacknum ;
   NODE *l_start ;
   NODE *l_bottom ;
   LOGPROB *wordtrellis[2] ;
   LOGPROB *g ;
   HMM_Logical **phmmseq ;
   int phmmlen_max ;
   boolean *has_sp ;
   short *wend_token_frame[2] ;
   LOGPROB *wend_token_gscore[2] ;
   short *wef ;
   LOGPROB *wes ;
   WORD_ID *cnword ;
   WORD_ID *cnwordrev ;
};
#line 199 "../libjulius/include/julius/recog.h"
typedef struct __StackDecode__ StackDecode;
#line 256 "../libjulius/include/julius/recog.h"
struct __anonstruct_LMFunc_108 {
   LOGPROB (*uniprob)(WORD_INFO * , WORD_ID  , LOGPROB  ) ;
   LOGPROB (*biprob)(WORD_INFO * , WORD_ID  , WORD_ID  , LOGPROB  ) ;
   LOGPROB (*lmprob)(WORD_INFO * , WORD_ID * , int  , WORD_ID  , LOGPROB  ) ;
};
#line 256 "../libjulius/include/julius/recog.h"
typedef struct __anonstruct_LMFunc_108 LMFunc;
#line 266 "../libjulius/include/julius/recog.h"
struct __gmm_calc__ {
   LOGPROB *gmm_score ;
   boolean *is_voice ;
   int framecount ;
   short OP_nstream ;
   VECT *OP_vec_stream[50] ;
   short OP_veclen_stream[50] ;
   LOGPROB *OP_calced_score ;
   int *OP_calced_id ;
   int OP_calced_num ;
   int OP_calced_maxnum ;
   int OP_gprune_num ;
   VECT *OP_vec ;
   short OP_veclen ;
   HTK_HMM_Data *max_d ;
   int max_i ;
   LOGPROB gmm_max_cm ;
};
#line 266 "../libjulius/include/julius/recog.h"
typedef struct __gmm_calc__ GMMCalc;
#line 308 "../libjulius/include/julius/recog.h"
struct __sentence_align__ {
   int num ;
   short unittype ;
   WORD_ID *w ;
   HMM_Logical **ph ;
   short *loc ;
   boolean *is_iwsp ;
   int *begin_frame ;
   int *end_frame ;
   LOGPROB *avgscore ;
   LOGPROB allscore ;
   struct __sentence_align__ *next ;
};
#line 308 "../libjulius/include/julius/recog.h"
typedef struct __sentence_align__ SentenceAlign;
#line 326 "../libjulius/include/julius/recog.h"
struct __sentence__ {
   WORD_ID word[150] ;
   int word_num ;
   LOGPROB score ;
   LOGPROB confidence[150] ;
   LOGPROB score_lm ;
   LOGPROB score_am ;
   int gram_id ;
   SentenceAlign *align ;
};
#line 326 "../libjulius/include/julius/recog.h"
typedef struct __sentence__ Sentence;
#line 342 "../libjulius/include/julius/recog.h"
struct __adin__ {
   boolean (*ad_standby)(int  , void * ) ;
   boolean (*ad_begin)(char * ) ;
   boolean (*ad_end)() ;
   boolean (*ad_resume)() ;
   boolean (*ad_pause)() ;
   boolean (*ad_terminate)() ;
   int (*ad_read)(SP16 * , int  ) ;
   char *(*ad_input_name)() ;
   int thres ;
   int noise_zerocross ;
   int nc_max ;
   int chunk_size ;
   boolean adin_cut_on ;
   boolean silence_cut_default ;
   boolean strip_flag ;
   boolean enable_thread ;
   boolean need_zmean ;
   int c_length ;
   int c_offset ;
   SP16 *swapbuf ;
   int sbsize ;
   int sblen ;
   int rest_tail ;
   ZEROCROSS zc ;
   pthread_t adin_thread ;
   pthread_mutex_t mutex ;
   SP16 *speech ;
   int speechlen ;
   boolean transfer_online ;
   boolean adinthread_buffer_overflowed ;
   boolean adinthread_ended ;
   boolean ignore_speech_while_recog ;
   SP16 *buffer ;
   int bpmax ;
   int bp ;
   int current_len ;
   SP16 *cbuf ;
   boolean down_sample ;
   SP16 *buffer48 ;
   int io_rate ;
   boolean is_valid_data ;
   int nc ;
   boolean end_of_stream ;
   boolean need_init ;
   DS_BUFFER *ds ;
   boolean rehash ;
   boolean input_side_segment ;
   unsigned int total_captured_len ;
   unsigned int last_trigger_sample ;
   unsigned int last_trigger_len ;
   char current_input_name[2048] ;
};
#line 342 "../libjulius/include/julius/recog.h"
typedef struct __adin__ ADIn;
#line 447 "../libjulius/include/julius/recog.h"
struct __Output__ {
   int status ;
   int num_frame ;
   int length_msec ;
   Sentence *sent ;
   int sentnum ;
   WordGraph *wg1 ;
   int wg1_num ;
   WordGraph *wg ;
   CN_CLUSTER *confnet ;
   Sentence pass1 ;
};
#line 447 "../libjulius/include/julius/recog.h"
typedef struct __Output__ Output;
#line 484 "../libjulius/include/julius/recog.h"
struct __anonstruct_cmn_109 {
   char *load_filename ;
   boolean update ;
   char *save_filename ;
   float map_weight ;
   boolean loaded ;
   CMNWork *wrk ;
};
#line 484 "../libjulius/include/julius/recog.h"
struct __anonstruct_frontend_110 {
   float *ssbuf ;
   int sslen ;
   float ss_alpha ;
   float ss_floor ;
   boolean sscalc ;
   int sscalc_len ;
   char *ssload_filename ;
   MFCCWork *mfccwrk_ss ;
};
#line 484 "../libjulius/include/julius/recog.h"
struct __anonstruct_func_111 {
   boolean (*fv_standby)() ;
   boolean (*fv_begin)() ;
   int (*fv_read)(VECT * , int  ) ;
   boolean (*fv_end)() ;
   boolean (*fv_resume)() ;
   boolean (*fv_pause)() ;
   boolean (*fv_terminate)() ;
   char *(*fv_input_name)() ;
};
#line 484 "../libjulius/include/julius/recog.h"
struct __mfcc_calc__ {
   short id ;
   Value *para ;
   boolean htk_loaded ;
   boolean hmm_loaded ;
   boolean paramtype_check_flag ;
   MFCCWork *wrk ;
   HTK_Param *param ;
   HTK_Param *rest_param ;
   struct __anonstruct_cmn_109 cmn ;
   struct __anonstruct_frontend_110 frontend ;
   ENERGYWork ewrk ;
   DeltaBuf *db ;
   DeltaBuf *ab ;
   VECT *tmpmfcc ;
   boolean valid ;
   int f ;
   int last_time ;
   int sparea_start ;
   boolean segmented ;
   boolean segmented_by_input ;
   int plugin_source ;
   struct __anonstruct_func_111 func ;
   struct __mfcc_calc__ *next ;
};
#line 484 "../libjulius/include/julius/recog.h"
typedef struct __mfcc_calc__ MFCCCalc;
#line 722 "../libjulius/include/julius/recog.h"
struct __process_am__ {
   JCONF_AM *config ;
   MFCCCalc *mfcc ;
   HTK_HMM_INFO *hmminfo ;
   HTK_HMM_INFO *hmm_gs ;
   HMMWork hmmwrk ;
   struct __process_am__ *next ;
};
#line 722 "../libjulius/include/julius/recog.h"
typedef struct __process_am__ PROCESS_AM;
#line 763 "../libjulius/include/julius/recog.h"
struct __process_lm__ {
   JCONF_LM *config ;
   PROCESS_AM *am ;
   int lmtype ;
   int lmvar ;
   WORD_INFO *winfo ;
   NGRAM_INFO *ngram ;
   MULTIGRAM *grammars ;
   int gram_maxid ;
   DFA_INFO *dfa ;
   boolean global_modified ;
   LMFunc lmfunc ;
   struct __process_lm__ *next ;
};
#line 763 "../libjulius/include/julius/recog.h"
typedef struct __process_lm__ PROCESS_LM;
#line 843 "../libjulius/include/julius/recog.h"
struct __recogprocess__ {
   boolean live ;
   short active ;
   JCONF_SEARCH *config ;
   PROCESS_AM *am ;
   PROCESS_LM *lm ;
   int lmtype ;
   int lmvar ;
   boolean ccd_flag ;
   WCHMM_INFO *wchmm ;
   int trellis_beam_width ;
   BACKTRELLIS *backtrellis ;
   FSBeam pass1 ;
   StackDecode pass2 ;
   WORD_ID pass1_wseq[150] ;
   int pass1_wnum ;
   LOGPROB pass1_score ;
   WORD_ID sp_break_last_word ;
   WORD_ID sp_break_last_nword ;
   boolean sp_break_last_nword_allow_override ;
   WORD_ID sp_break_2_begin_word ;
   WORD_ID sp_break_2_end_word ;
   int peseqlen ;
   int graph_totalwordnum ;
   Output result ;
   boolean graphout ;
   char *order_matrix ;
   int order_matrix_count ;
   boolean have_interim ;
   void *hook ;
   struct __recogprocess__ *next ;
};
#line 843 "../libjulius/include/julius/recog.h"
typedef struct __recogprocess__ RecogProcess;
#line 1025 "../libjulius/include/julius/recog.h"
struct __Recog__ {
   Jconf *jconf ;
   ADIn *adin ;
   RealBeam real ;
   MFCCCalc *mfcclist ;
   PROCESS_AM *amlist ;
   PROCESS_LM *lmlist ;
   RecogProcess *process_list ;
   boolean process_segment ;
   SP16 *speech ;
   int speechalloclen ;
   int speechlen ;
   int peseqlen ;
   HTK_HMM_INFO *gmm ;
   MFCCCalc *gmmmfcc ;
   GMMCalc *gc ;
   boolean process_active ;
   boolean process_want_terminate ;
   boolean process_want_reload ;
   short gram_switch_input_method ;
   boolean process_online ;
   boolean (*calc_vector)(MFCCCalc * , SP16 * , int  ) ;
   boolean triggered ;
   void (*callback_function[33][10])() ;
   void *callback_user_data[33][10] ;
   int callback_function_num[33] ;
   int callback_list_code[330] ;
   int callback_list_loc[330] ;
   int callback_num ;
   void *hook ;
};
#line 1025 "../libjulius/include/julius/recog.h"
typedef struct __Recog__ Recog;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 17 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef short FLAG;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef unsigned int CLASSFLAGS;
#line 55
struct _FA;
#line 55 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _ARC {
   int inp ;
   struct _FA *fa ;
   CLASSFLAGS start ;
   CLASSFLAGS accpt ;
   struct _ARC *next ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _ARC ARC;
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _UNIFYARC {
   int inp ;
   struct _FA *us ;
   CLASSFLAGS start ;
   CLASSFLAGS accpt ;
   struct _UNIFYARC *next ;
   FLAG reserved ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _UNIFYARC UNIFYARC;
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _FALIST {
   struct _FA *fa ;
   struct _FALIST *next ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _FALIST FALIST;
#line 79 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _FA {
   int stat ;
   ARC *nsList ;
   CLASSFLAGS start ;
   CLASSFLAGS accpt ;
   CLASSFLAGS aStart ;
   FLAG traversed ;
   int psNum ;
   UNIFYARC *usList ;
   FALIST *group ;
   FLAG volatiled ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _FA FA;
#line 143 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
struct _FAQ {
   FA *fa ;
   struct _FAQ *next ;
};
#line 143 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
typedef struct _FAQ FAQ;
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _BODY {
   char name[256] ;
   FLAG abort ;
   struct _BODY *next ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _BODY BODY;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _BODYLIST {
   BODY *body ;
   struct _BODYLIST *next ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _BODYLIST BODYLIST;
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
struct _CLASS {
   short no ;
   char name[256] ;
   struct _CLASS *next ;
   BODYLIST *bodyList ;
   int branch ;
   FLAG usedFA ;
   FLAG used ;
   FLAG tmp ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
typedef struct _CLASS CLASS;
#line 10 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
struct _HIS {
   CLASS *class ;
   FA *fa ;
   struct _HIS *prev ;
   ARC *nsList ;
   FA *cloneFA ;
};
#line 10 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
typedef struct _HIS HIS;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
struct _TOKEN {
   CLASS *class ;
   FLAG abort ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
typedef struct _TOKEN TOKEN;
#line 78 "/usr/share/bison/bison.simple"
union yyalloc {
   short yyss ;
   char *yyvs ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
struct yy_buffer_state;
#line 118 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 160 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
typedef unsigned int yy_size_t;
#line 163 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 283 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
typedef unsigned char YY_CHAR;
#line 285 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
typedef int yy_state_type;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.h"
struct __nextword__ {
   WORD_ID id ;
   int next_state ;
   boolean can_insert_sp ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.h"
typedef struct __nextword__ NEXTWORD;
#line 24 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.h"
struct __node_____0 {
   boolean endflag ;
   WORD_ID seq[150] ;
   short seqnum ;
   int state ;
};
#line 24 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.h"
typedef struct __node_____0 NODE___0;
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
struct __wtoken__ {
   WORD_ID wid ;
   struct __wtoken__ *next ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
typedef struct __wtoken__ WTOKEN;
#line 13 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
struct __state_chain__ {
   int state ;
   struct __state_chain__ *next ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
typedef struct __state_chain__ STATECHAIN;
#line 98 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
struct __stateq__ {
   char *s ;
   int len ;
   int checked ;
   void *ac ;
   int start ;
   int end ;
   int id ;
   struct __stateq__ *next ;
};
#line 98 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
typedef struct __stateq__ STATEQ;
#line 113 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
struct __arc__ {
   int label ;
   STATEQ *to ;
   struct __arc__ *next ;
};
#line 113 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
typedef struct __arc__ STATEQ_ARC;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi.h"
int do_connect(char *hostname , int portnum ) ;
#line 83
char *do_receive(int sd___0 , char *buf___13 , int maxlen ) ;
#line 86
void japi_die(int sd___0 ) ;
#line 87
void japi_get_version(int sd___0 ) ;
#line 88
void japi_get_status(int sd___0 ) ;
#line 89
void japi_pause_recog(int sd___0 ) ;
#line 90
void japi_terminate_recog(int sd___0 ) ;
#line 91
void japi_resume_recog(int sd___0 ) ;
#line 92
void japi_set_input_handler_on_change(int sd___0 , char *arg ) ;
#line 95
void japi_get_graminfo(int sd___0 ) ;
#line 96
void japi_change_grammar(int sd___0 , char *prefixpath ) ;
#line 97
void japi_add_grammar(int sd___0 , char *prefixpath ) ;
#line 98
void japi_delete_grammar(int sd___0 , char *idlist ) ;
#line 99
void japi_activate_grammar(int sd___0 , char *idlist ) ;
#line 100
void japi_deactivate_grammar(int sd___0 , char *idlist ) ;
#line 101
void japi_sync_grammar(int sd___0 ) ;
#line 102
void japi_add_words(int sd___0 , char *idstr , char *dictfile ) ;
#line 105
void japi_list_process(int sd___0 ) ;
#line 106
void japi_current_process(int sd___0 , char *pname ) ;
#line 107
void japi_shift_process(int sd___0 ) ;
#line 108
void japi_add_process(int sd___0 , char *jconffile ) ;
#line 109
void japi_del_process(int sd___0 , char *pname ) ;
#line 110
void japi_activate_process(int sd___0 , char *pname ) ;
#line 111
void japi_deactivate_process(int sd___0 , char *pname ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
static char sbuf[4096]  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
static char rbuf[4096]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
void do_command(int sd___0 ) 
{ 
  char *p___0 ;
  char *com ;
  char *arg1 ;
  char *arg2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  {
#line 48
  com = strtok((char */* __restrict  */)(sbuf), (char const   */* __restrict  */)" \t\n");
  }
#line 49
  if ((unsigned long )com == (unsigned long )((void *)0)) {
#line 49
    return;
  }
  {
#line 50
  arg2 = (char *)((void *)0);
#line 50
  arg1 = arg2;
#line 51
  p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
  }
#line 51
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
    {
#line 52
    arg1 = p___0;
#line 53
    p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
#line 53
    if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 54
      arg2 = p___0;
    }
  }
  {
#line 57
  tmp___20 = strcmp((char const   *)com, "die");
  }
#line 57
  if (tmp___20) {
    {
#line 59
    tmp___19 = strcmp((char const   *)com, "version");
    }
#line 59
    if (tmp___19) {
      {
#line 61
      tmp___18 = strcmp((char const   *)com, "status");
      }
#line 61
      if (tmp___18) {
        {
#line 63
        tmp___17 = strcmp((char const   *)com, "graminfo");
        }
#line 63
        if (tmp___17) {
          {
#line 65
          tmp___16 = strcmp((char const   *)com, "pause");
          }
#line 65
          if (tmp___16) {
            {
#line 67
            tmp___15 = strcmp((char const   *)com, "terminate");
            }
#line 67
            if (tmp___15) {
              {
#line 69
              tmp___14 = strcmp((char const   *)com, "resume");
              }
#line 69
              if (tmp___14) {
                {
#line 71
                tmp___13 = strcmp((char const   *)com, "inputparam");
                }
#line 71
                if (tmp___13) {
                  {
#line 73
                  tmp___12 = strcmp((char const   *)com, "changegram");
                  }
#line 73
                  if (tmp___12) {
                    {
#line 75
                    tmp___11 = strcmp((char const   *)com, "addgram");
                    }
#line 75
                    if (tmp___11) {
                      {
#line 77
                      tmp___10 = strcmp((char const   *)com, "deletegram");
                      }
#line 77
                      if (tmp___10) {
                        {
#line 79
                        tmp___9 = strcmp((char const   *)com, "activategram");
                        }
#line 79
                        if (tmp___9) {
                          {
#line 81
                          tmp___8 = strcmp((char const   *)com, "deactivategram");
                          }
#line 81
                          if (tmp___8) {
                            {
#line 83
                            tmp___7 = strcmp((char const   *)com, "syncgram");
                            }
#line 83
                            if (tmp___7) {
                              {
#line 85
                              tmp___6 = strcmp((char const   *)com, "listprocess");
                              }
#line 85
                              if (tmp___6) {
                                {
#line 87
                                tmp___5 = strcmp((char const   *)com, "currentprocess");
                                }
#line 87
                                if (tmp___5) {
                                  {
#line 89
                                  tmp___4 = strcmp((char const   *)com, "shiftprocess");
                                  }
#line 89
                                  if (tmp___4) {
                                    {
#line 91
                                    tmp___3 = strcmp((char const   *)com, "addprocess");
                                    }
#line 91
                                    if (tmp___3) {
                                      {
#line 93
                                      tmp___2 = strcmp((char const   *)com, "delprocess");
                                      }
#line 93
                                      if (tmp___2) {
                                        {
#line 95
                                        tmp___1 = strcmp((char const   *)com, "activateprocess");
                                        }
#line 95
                                        if (tmp___1) {
                                          {
#line 97
                                          tmp___0 = strcmp((char const   *)com, "deactivateprocess");
                                          }
#line 97
                                          if (tmp___0) {
                                            {
#line 99
                                            tmp = strcmp((char const   *)com, "addword");
                                            }
#line 99
                                            if (tmp) {
                                              {
#line 102
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"No such command: [%s]\n",
                                                      com);
                                              }
                                            } else {
                                              {
#line 100
                                              japi_add_words(sd___0, arg1, arg2);
                                              }
                                            }
                                          } else {
                                            {
#line 98
                                            japi_deactivate_process(sd___0, arg1);
                                            }
                                          }
                                        } else {
                                          {
#line 96
                                          japi_activate_process(sd___0, arg1);
                                          }
                                        }
                                      } else {
                                        {
#line 94
                                        japi_del_process(sd___0, arg1);
                                        }
                                      }
                                    } else {
                                      {
#line 92
                                      japi_add_process(sd___0, arg1);
                                      }
                                    }
                                  } else {
                                    {
#line 90
                                    japi_shift_process(sd___0);
                                    }
                                  }
                                } else {
                                  {
#line 88
                                  japi_current_process(sd___0, arg1);
                                  }
                                }
                              } else {
                                {
#line 86
                                japi_list_process(sd___0);
                                }
                              }
                            } else {
                              {
#line 84
                              japi_sync_grammar(sd___0);
                              }
                            }
                          } else {
                            {
#line 82
                            japi_deactivate_grammar(sd___0, arg1);
                            }
                          }
                        } else {
                          {
#line 80
                          japi_activate_grammar(sd___0, arg1);
                          }
                        }
                      } else {
                        {
#line 78
                        japi_delete_grammar(sd___0, arg1);
                        }
                      }
                    } else {
                      {
#line 76
                      japi_add_grammar(sd___0, arg1);
                      }
                    }
                  } else {
                    {
#line 74
                    japi_change_grammar(sd___0, arg1);
                    }
                  }
                } else {
                  {
#line 72
                  japi_set_input_handler_on_change(sd___0, arg1);
                  }
                }
              } else {
                {
#line 70
                japi_resume_recog(sd___0);
                }
              }
            } else {
              {
#line 68
              japi_terminate_recog(sd___0);
              }
            }
          } else {
            {
#line 66
            japi_pause_recog(sd___0);
            }
          }
        } else {
          {
#line 64
          japi_get_graminfo(sd___0);
          }
        }
      } else {
        {
#line 62
        japi_get_status(sd___0);
        }
      }
    } else {
      {
#line 60
      japi_get_version(sd___0);
      }
    }
  } else {
    {
#line 58
    japi_die(sd___0);
    }
  }
#line 104
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
void do_output(int sd___0 ) 
{ 
  char *tmp ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 121
    tmp = do_receive(sd___0, rbuf, 4096);
    }
#line 121
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 121
      goto while_break;
    }
#line 122
    if ((int )rbuf[0] == 46) {
#line 122
      if ((int )rbuf[1] == 0) {
#line 122
        goto while_break;
      }
    }
    {
#line 123
    printf((char const   */* __restrict  */)"> %s\n", rbuf);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  fflush(stdout);
  }
#line 126
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
void command_loop(int sd___0 ) 
{ 
  fd_set readfds ;
  int nfd ;
  int __d0 ;
  int __d1 ;
  char *tmp ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 215
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 216
    readfds.__fds_bits[sd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd___0 % (8 * (int )sizeof(__fd_mask ));
#line 217
    readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 219
    nfd = select(sd___0 + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 221
    if (nfd < 0) {
      {
#line 222
      perror("Error: select");
#line 223
      exit(1);
      }
    }
#line 225
    if ((readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 227
      tmp = fgets((char */* __restrict  */)(sbuf), 4096, (FILE */* __restrict  */)stdin);
      }
#line 227
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        {
#line 228
        do_command(sd___0);
        }
      }
    }
#line 231
    if ((readfds.__fds_bits[sd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << sd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 233
      do_output(sd___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
void usage(void) 
{ 


  {
  {
#line 253
  printf((char const   */* __restrict  */)"usage: jcontrol host [portnum (def=%d)]\n",
         10500);
  }
#line 254
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/jcontrol.c"
int main(int argc , char **argv ) 
{ 
  int port ;
  int sd___0 ;

  {
#line 280
  if (argc < 2) {
    {
#line 281
    usage();
    }
#line 282
    return (1);
  }
#line 284
  if (argc < 3) {
#line 285
    port = 10500;
  } else {
    {
#line 287
    port = atoi((char const   *)*(argv + 2));
    }
  }
  {
#line 289
  sd___0 = do_connect(*(argv + 1), port);
#line 290
  command_loop(sd___0);
  }
#line 292
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi.h"
void do_sendf(int sd___0 , char *fmt  , ...) ;
#line 82
void do_send(int sd___0 , char *buf___13 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_list_process(int sd___0 ) 
{ 


  {
  {
#line 31
  do_send(sd___0, (char *)"LISTPROCESS\n");
  }
#line 32
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_current_process(int sd___0 , char *pname ) 
{ 


  {
  {
#line 39
  do_send(sd___0, (char *)"CURRENTPROCESS\n");
  }
#line 40
  if ((unsigned long )pname == (unsigned long )((void *)0)) {
    {
#line 41
    do_send(sd___0, (char *)"\n");
    }
  } else {
    {
#line 43
    do_sendf(sd___0, (char *)"%s\n", pname);
    }
  }
#line 45
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_shift_process(int sd___0 ) 
{ 


  {
  {
#line 52
  do_send(sd___0, (char *)"SHIFTPROCESS\n");
  }
#line 53
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_add_process(int sd___0 , char *jconffile ) 
{ 


  {
#line 59
  if ((unsigned long )jconffile == (unsigned long )((void *)0)) {
    {
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: addprocess needs jconf file name as argument\n");
    }
#line 61
    return;
  }
  {
#line 63
  do_send(sd___0, (char *)"ADDPROCESS\n");
#line 64
  do_sendf(sd___0, (char *)"%s\n", jconffile);
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_del_process(int sd___0 , char *pname ) 
{ 


  {
#line 71
  if ((unsigned long )pname == (unsigned long )((void *)0)) {
    {
#line 72
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: delprocess needs process name as argument\n");
    }
#line 73
    return;
  }
  {
#line 75
  do_send(sd___0, (char *)"DELPROCESS\n");
#line 76
  do_sendf(sd___0, (char *)"%s\n", pname);
  }
#line 77
  return;
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_activate_process(int sd___0 , char *pname ) 
{ 


  {
#line 83
  if ((unsigned long )pname == (unsigned long )((void *)0)) {
    {
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: activateprocess needs process name as argument\n");
    }
#line 85
    return;
  }
  {
#line 87
  do_send(sd___0, (char *)"ACTIVATEPROCESS\n");
#line 88
  do_sendf(sd___0, (char *)"%s\n", pname);
  }
#line 89
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_process.c"
void japi_deactivate_process(int sd___0 , char *pname ) 
{ 


  {
#line 95
  if ((unsigned long )pname == (unsigned long )((void *)0)) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: deactivateprocess needs process name as argument\n");
    }
#line 97
    return;
  }
  {
#line 99
  do_send(sd___0, (char *)"DEACTIVATEPROCESS\n");
#line 100
  do_sendf(sd___0, (char *)"%s\n", pname);
  }
#line 101
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_die(int sd___0 ) 
{ 


  {
  {
#line 42
  do_send(sd___0, (char *)"DIE\n");
  }
#line 43
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_get_version(int sd___0 ) 
{ 


  {
  {
#line 60
  do_send(sd___0, (char *)"VERSION\n");
  }
#line 61
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_get_status(int sd___0 ) 
{ 


  {
  {
#line 78
  do_send(sd___0, (char *)"STATUS\n");
  }
#line 79
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_pause_recog(int sd___0 ) 
{ 


  {
  {
#line 99
  do_send(sd___0, (char *)"PAUSE\n");
  }
#line 100
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_terminate_recog(int sd___0 ) 
{ 


  {
  {
#line 119
  do_send(sd___0, (char *)"TERMINATE\n");
  }
#line 120
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_resume_recog(int sd___0 ) 
{ 


  {
  {
#line 138
  do_send(sd___0, (char *)"RESUME\n");
  }
#line 139
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_misc.c"
void japi_set_input_handler_on_change(int sd___0 , char *arg ) 
{ 


  {
  {
#line 168
  do_sendf(sd___0, (char *)"INPUTONCHANGE\n%s\n", arg);
  }
#line 169
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi.h"
void do_disconnect(int sd___0 ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
static struct hostent *hp  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
static struct sockaddr_in sin  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
int do_connect(char *hostname , int portnum ) 
{ 
  int sd___0 ;
  int tmp ;

  {
  {
#line 66
  hp = gethostbyname((char const   *)hostname);
  }
#line 66
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: host \"%s\" not found\n",
            hostname);
#line 68
    exit(1);
    }
  }
  {
#line 90
  sd___0 = socket(2, 1, 0);
  }
#line 90
  if (sd___0 < 0) {
    {
#line 91
    perror("Error: socket()");
#line 92
    exit(1);
    }
  }
  {
#line 97
  memset((void *)((char *)(& sin)), 0, sizeof(sin));
#line 98
  memcpy((void */* __restrict  */)(& sin.sin_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
         (size_t )hp->h_length);
#line 99
  sin.sin_family = (sa_family_t )hp->h_addrtype;
#line 100
  sin.sin_port = htons((uint16_t )portnum);
#line 101
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connecting to %s:%d...",
          hostname, portnum);
#line 102
  tmp = connect(sd___0, (struct sockaddr  const  *)((struct sockaddr *)(& sin)), (socklen_t )sizeof(sin));
  }
#line 102
  if (tmp < 0) {
    {
#line 103
    perror("Error");
#line 104
    exit(1);
    }
  }
  {
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
  }
#line 107
  return (sd___0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
void do_disconnect(int sd___0 ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = close(sd___0);
  }
#line 128
  if (tmp < 0) {
    {
#line 129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: close() failed");
    }
  }
#line 132
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
static char buf[4096]  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
void do_sendf(int sd___0 , char *fmt  , ...) 
{ 
  va_list ap ;
  int n ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 157
  __builtin_va_start(ap, fmt);
#line 158
  vsnprintf((char */* __restrict  */)(buf), (size_t )4096, (char const   */* __restrict  */)fmt,
            ap);
#line 162
  tmp = strlen((char const   *)(buf));
#line 162
  tmp___0 = write(sd___0, (void const   *)(buf), tmp);
#line 162
  n = (int )tmp___0;
  }
#line 164
  if (n < 0) {
    {
#line 165
    perror("Error: do_sendf");
    }
  }
  {
#line 167
  __builtin_va_end(ap);
  }
#line 168
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
void do_send(int sd___0 , char *buf___13 ) 
{ 
  int n ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 192
  tmp = strlen((char const   *)buf___13);
#line 192
  tmp___0 = write(sd___0, (void const   *)buf___13, tmp);
#line 192
  n = (int )tmp___0;
  }
#line 194
  if (n < 0) {
    {
#line 195
    perror("Error: do_send");
    }
  }
#line 197
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/server.c"
char *do_receive(int sd___0 , char *buf___13 , int maxlen ) 
{ 
  int cnt ;
  char *p___0 ;
  ssize_t tmp ;

  {
#line 227
  p___0 = buf___13;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    tmp = read(sd___0, (void *)p___0, (size_t )1);
#line 232
    cnt = (int )tmp;
    }
#line 234
    if (cnt <= 0) {
#line 234
      return ((char *)((void *)0));
    }
#line 235
    if ((int )*p___0 == 10) {
#line 235
      if ((unsigned long )p___0 > (unsigned long )buf___13) {
#line 236
        *p___0 = (char )'\000';
#line 237
        goto while_break;
      } else {
#line 235
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 239
      p___0 ++;
#line 239
      if ((unsigned long )p___0 >= (unsigned long )(buf___13 + maxlen)) {
        {
#line 240
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: do_receive: line too long (> %d)\n",
                maxlen);
#line 241
        exit(1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (buf___13);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
static char buf___0[4096]  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
static int check_grammar_path(char *prefix ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 50
  tmp = strlen((char const   *)prefix);
#line 50
  i = (int )(tmp - 1UL);
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if ((int )*(prefix + i) != 46) {
#line 51
      if (! (i >= 0)) {
#line 51
        goto while_break;
      }
    } else {
#line 51
      goto while_break;
    }
#line 51
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  if (i < 0) {
#line 52
    goto _L;
  } else {
    {
#line 52
    tmp___3 = strcmp((char const   *)(prefix + i), ".dict");
    }
#line 52
    if (tmp___3 != 0) {
      _L: /* CIL Label */ 
      {
#line 53
      snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"%s.dfa",
               prefix);
#line 54
      tmp___0 = access((char const   *)(buf___0), 4);
      }
#line 54
      if (tmp___0 < 0) {
        {
#line 55
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s.dfa\" not exist\n",
                prefix);
        }
#line 56
        return (-1);
      }
      {
#line 58
      snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"%s.dict",
               prefix);
#line 59
      tmp___1 = access((char const   *)(buf___0), 4);
      }
#line 59
      if (tmp___1 < 0) {
        {
#line 60
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s.dict\" not exist\n",
                prefix);
        }
#line 61
        return (-1);
      }
    } else {
      {
#line 64
      tmp___2 = access((char const   *)prefix, 4);
      }
#line 64
      if (tmp___2 < 0) {
        {
#line 65
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s\" not exist\n",
                prefix);
        }
      }
    }
  }
#line 68
  return (0);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
static int send_grammar(int sd___0 , char *prefix ) 
{ 
  FILE *fp___2 ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 95
  tmp = strlen((char const   *)prefix);
#line 95
  i = (int )(tmp - 1UL);
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if ((int )*(prefix + i) != 46) {
#line 96
      if (! (i >= 0)) {
#line 96
        goto while_break;
      }
    } else {
#line 96
      goto while_break;
    }
#line 96
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  if (i < 0) {
#line 97
    goto _L;
  } else {
    {
#line 97
    tmp___1 = strcmp((char const   *)(prefix + i), ".dict");
    }
#line 97
    if (tmp___1 != 0) {
      _L: /* CIL Label */ 
      {
#line 98
      snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"%s.dfa",
               prefix);
#line 99
      fp___2 = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"r");
      }
#line 99
      if ((unsigned long )fp___2 == (unsigned long )((void *)0)) {
        {
#line 100
        perror("japi_change_grammar");
        }
#line 100
        return (-1);
      }
      {
#line 102
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 102
        tmp___0 = fgets((char */* __restrict  */)(buf___0), 4096, (FILE */* __restrict  */)fp___2);
        }
#line 102
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 102
          goto while_break___0;
        }
        {
#line 103
        do_send(sd___0, buf___0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 105
      do_send(sd___0, (char *)"DFAEND\n");
#line 106
      fclose(fp___2);
#line 107
      snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"%s.dict",
               prefix);
      }
    } else {
      {
#line 109
      snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"%s",
               prefix);
      }
    }
  }
  {
#line 111
  fp___2 = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"r");
  }
#line 111
  if ((unsigned long )fp___2 == (unsigned long )((void *)0)) {
    {
#line 112
    perror("japi_change_grammar");
    }
#line 112
    return (-1);
  }
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 114
    tmp___2 = fgets((char */* __restrict  */)(buf___0), 4096, (FILE */* __restrict  */)fp___2);
    }
#line 114
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 114
      goto while_break___1;
    }
    {
#line 115
    do_send(sd___0, buf___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 117
  do_send(sd___0, (char *)"DICEND\n");
#line 118
  fclose(fp___2);
  }
#line 119
  return (0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
static int send_idlist(int sd___0 , char *idstr ) 
{ 
  char *p___0 ;

  {
  {
#line 147
  strcpy((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)idstr);
#line 148
  p___0 = buf___0;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! ((int )*p___0 != 0)) {
#line 149
      goto while_break;
    }
#line 150
    if ((int )*p___0 == 44) {
#line 150
      *p___0 = (char )' ';
    }
#line 151
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 154
  do_sendf(sd___0, (char *)"%s\n", buf___0);
  }
#line 155
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_change_grammar(int sd___0 , char *prefixpath ) 
{ 
  int tmp ;

  {
  {
#line 177
  tmp = check_grammar_path(prefixpath);
  }
#line 177
  if (tmp < 0) {
#line 177
    return;
  }
  {
#line 181
  snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"CHANGEGRAM %s\n",
           prefixpath);
#line 182
  do_send(sd___0, buf___0);
#line 183
  send_grammar(sd___0, prefixpath);
  }
#line 184
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_add_grammar(int sd___0 , char *prefixpath ) 
{ 
  int tmp ;

  {
  {
#line 205
  tmp = check_grammar_path(prefixpath);
  }
#line 205
  if (tmp < 0) {
#line 205
    return;
  }
  {
#line 209
  snprintf((char */* __restrict  */)(buf___0), (size_t )4096, (char const   */* __restrict  */)"ADDGRAM %s\n",
           prefixpath);
#line 210
  do_send(sd___0, buf___0);
#line 211
  send_grammar(sd___0, prefixpath);
  }
#line 212
  return;
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_delete_grammar(int sd___0 , char *idlist ) 
{ 


  {
  {
#line 231
  do_send(sd___0, (char *)"DELGRAM\n");
#line 232
  send_idlist(sd___0, idlist);
  }
#line 233
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_activate_grammar(int sd___0 , char *idlist ) 
{ 


  {
  {
#line 252
  do_send(sd___0, (char *)"ACTIVATEGRAM\n");
#line 253
  send_idlist(sd___0, idlist);
  }
#line 254
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_deactivate_grammar(int sd___0 , char *idlist ) 
{ 


  {
  {
#line 275
  do_send(sd___0, (char *)"DEACTIVATEGRAM\n");
#line 276
  send_idlist(sd___0, idlist);
  }
#line 277
  return;
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_sync_grammar(int sd___0 ) 
{ 


  {
  {
#line 301
  do_send(sd___0, (char *)"SYNCGRAM\n");
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_get_graminfo(int sd___0 ) 
{ 


  {
  {
#line 307
  do_send(sd___0, (char *)"GRAMINFO\n");
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/jcontrol/japi_grammar.c"
void japi_add_words(int sd___0 , char *idstr , char *dictfile ) 
{ 
  FILE *fp___2 ;
  char *tmp ;

  {
  {
#line 315
  fp___2 = fopen((char const   */* __restrict  */)dictfile, (char const   */* __restrict  */)"r");
  }
#line 315
  if ((unsigned long )fp___2 == (unsigned long )((void *)0)) {
    {
#line 316
    perror("japi_add_words");
    }
#line 317
    return;
  }
  {
#line 319
  do_send(sd___0, (char *)"ADDWORD\n");
#line 320
  do_sendf(sd___0, (char *)"%s\n", idstr);
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    tmp = fgets((char */* __restrict  */)(buf___0), 4096, (FILE */* __restrict  */)fp___2);
    }
#line 321
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 321
      goto while_break;
    }
    {
#line 322
    do_send(sd___0, buf___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  do_send(sd___0, (char *)"DICEND\n");
#line 325
  fclose(fp___2);
  }
#line 326
  return;
}
}
#line 73 "../libsent/include/sent/util.h"
extern FILE *fopen_writefile(char * ) ;
#line 74
extern int fclose_writefile(FILE * ) ;
#line 110
extern void confout_version(FILE *strm ) ;
#line 113
extern void confout_am(FILE *strm ) ;
#line 279 "../libsent/include/sent/mfcc.h"
extern void undef_para(Value *para ) ;
#line 281
extern void make_default_para_htk(Value *para ) ;
#line 282
extern void apply_para(Value *dst , Value *src ) ;
#line 283
extern boolean htk_config_file_parse(char *HTKconffile , Value *para ) ;
#line 284
extern void calc_para_from_header(Value *para , short param_type , short vec_size ) ;
#line 285
extern void put_para(FILE *fp , Value *para ) ;
#line 489 "../libsent/include/sent/htk_hmm.h"
extern void print_hmmdef_info(FILE *fp , HTK_HMM_INFO * ) ;
#line 491
extern HTK_HMM_INFO *hmminfo_new() ;
#line 493
extern boolean init_hmminfo(HTK_HMM_INFO *hmminfo , char *filename , char *mapfile ,
                            Value *para ) ;
#line 536
extern boolean write_binhmm(FILE *fp , HTK_HMM_INFO *hmm , Value *para ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbinhmm/mkbinhmm.c"
HTK_HMM_INFO *hmminfo  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbinhmm/mkbinhmm.c"
Value para  ;
#line 17 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbinhmm/mkbinhmm.c"
Value para_htk  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbinhmm/mkbinhmm.c"
static void usage___0(char *s ) 
{ 


  {
  {
#line 23
  printf((char const   */* __restrict  */)"mkbinhmm: convert HMM definition file to binary format for Julius\n");
#line 24
  printf((char const   */* __restrict  */)"usage: %s [-htkconf HTKConfig] hmmdefs binhmm\n",
         s);
#line 25
  printf((char const   */* __restrict  */)"\nLibrary configuration: ");
#line 26
  confout_version(stdout);
#line 27
  confout_am(stdout);
#line 28
  printf((char const   */* __restrict  */)"\n");
  }
#line 29
  return;
}
}
#line 478 "../libsent/include/sent/htk_hmm.h"
extern boolean save_hmmlist_bin(FILE *fp , HTK_HMM_INFO *hmminfo ) ;
#line 520
extern boolean make_cdset(HTK_HMM_INFO *hmminfo ) ;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbinhmm/mkbinhmmlist.c"
static void usage___1(char *s ) 
{ 


  {
  {
#line 23
  printf((char const   */* __restrict  */)"mkbinhmmlist: convert HMMList file to binary format for Julius\n");
#line 24
  printf((char const   */* __restrict  */)"usage: %s hmmdefs hmmlist binhmmlist\n",
         s);
#line 25
  printf((char const   */* __restrict  */)"\nLibrary configuration: ");
#line 26
  confout_version(stdout);
#line 27
  confout_am(stdout);
#line 28
  printf((char const   */* __restrict  */)"\n");
  }
#line 29
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 87 "../libsent/include/sent/util.h"
extern void *mymalloc(size_t size ) ;
#line 111
extern void confout_audio(FILE *strm ) ;
#line 115
extern void confout_process(FILE *strm ) ;
#line 62 "../libsent/include/sent/tcpip.h"
extern int rd(int fd , char *data , int *len , int maxlen ) ;
#line 63
extern int wt(int fd , char *data , int len ) ;
#line 67
extern int make_connection(char *hostname , int port_num ) ;
#line 111 "../libsent/include/sent/speech.h"
extern int wrsamp(int fd , SP16 *buf , int len ) ;
#line 114
extern FILE *wrwav_open(char *filename , int sfreq ) ;
#line 115
extern boolean wrwav_data(FILE *fp , SP16 *buf , int len ) ;
#line 116
extern boolean wrwav_close(FILE *fp ) ;
#line 36 "../libjulius/include/julius/jfunc.h"
extern int j_open_stream(Recog *recog , char *file_or_dev_name ) ;
#line 54
extern int j_config_load_args(Jconf *jconf , int argc , char **argv ) ;
#line 62
extern boolean j_adin_init(Recog *recog ) ;
#line 110
extern Jconf *j_jconf_new() ;
#line 112
extern Recog *j_recog_new() ;
#line 41 "../libjulius/include/julius/useropt.h"
extern boolean j_add_option(char *fmt , int argnum , int reqargnum , char *desc ,
                            boolean (*func)(Jconf *jconf , char **arg , int argnum ) ) ;
#line 279 "../libjulius/include/julius/extern.h"
extern int adin_go(int (*ad_process)(SP16 * , int  , Recog * ) , int (*ad_check)(Recog * ) ,
                   Recog *recog ) ;
#line 282
extern boolean adin_end(ADIn *a ) ;
#line 293
extern int callback_add(Recog *recog , int code , void (*func)(Recog *recog , void *data ) ,
                        void *data ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int file_counter  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int sfreq  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int speech_output  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int total_speechlen  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int speechlen  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static char *filename  =    (char *)((void *)0);
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int fd  =    -1;
#line 64 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static FILE *fp  =    (FILE *)((void *)0);
#line 65 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int size  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean use_raw  =    (boolean )0;
#line 67 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean continuous_segment  =    (boolean )1;
#line 68 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int startid  =    0;
#line 69 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int sid  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static char *outpath  =    (char *)((void *)0);
#line 71 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_port_in  =    5530;
#line 72 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_port[10]  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static char *adinnet_serv[10]  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int sd[10]  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_servnum  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_portnum  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean writing_file  =    (boolean )0;
#line 78 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean stop_at_next  =    (boolean )0;
#line 81 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean pause_each  =    (boolean )0;
#line 82 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean loose_sync  =    (boolean )0;
#line 83 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int rewind_msec  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int trigger_sample  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_help(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adintool --- AD-in tool to record/split/send/receive speech data\n");
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: adintool [options] -in inputdev -out outputdev\n");
#line 95
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"inputdev: read speech data from:\n");
#line 97
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    mic         microphone (default)\n");
#line 102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    file        speech file (filename given from prompt)\n");
#line 103
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    adinnet     from adinnet client (I\'m server)\n");
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    stdin       standard tty input\n");
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  (other input can be specified by \"-input xxx\" as in Julius)\n");
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"outputdev: output data to:\n");
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    file        speech file (\"foo.0000.wav\" - \"foo.N.wav\"\n");
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    adinnet     to adinnet server (I\'m client)\n");
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    stdout      standard tty output\n");
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"I/O options:\n");
#line 115
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -server host[,host,...] (adinnet-out) server hostnames\n");
#line 116
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -port num[,num,...]     (adinnet-out) port numbers (%d)\n",
          5530);
#line 117
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -inport num     (adinnet-in) port number (%d)\n",
          5530);
#line 118
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -filename foo   (file-out) filename to record\n");
#line 119
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -startid id     (file-out) recording start id (%04d)\n",
          startid);
#line 121
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Recording and Pause segmentation options:\n");
#line 123
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (input segmentation: on for file/mic/stdin, off for adinnet)\n");
#line 124
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-nosegment]          not segment input speech\n");
#line 125
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-segment]            force segmentation of input speech\n");
#line 126
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-cutsilence]         (same as \"-segment\")\n");
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-oneshot]            record only the first segment\n");
#line 128
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-freq frequency]     sampling frequency in Hz    (%ld)\n",
          (jconf->am_root)->analysis.para_default.smp_freq);
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-48]                 48000Hz recording with down sampling (16kHz only)\n");
#line 130
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-lv unsignedshort]   silence cut level threshold (%d)\n",
          jconf->detect.level_thres);
#line 131
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-zc zerocrossnum]    silence cut zerocross num   (%d)\n",
          jconf->detect.zero_cross_num);
#line 132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-headmargin msec]    head margin length          (%d)\n",
          jconf->detect.head_margin_msec);
#line 133
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-tailmargin msec]    tail margin length          (%d)\n",
          jconf->detect.tail_margin_msec);
#line 134
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-chunksize sample]   chunk size for processing   (%d)\n",
          jconf->detect.chunk_size);
#line 135
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-nostrip]            do not strip zero samples\n");
#line 136
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-zmean]              remove DC by zero mean\n");
#line 137
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-raw]                output in RAW format\n");
#line 138
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-autopause]          automatically pause at each input end\n");
#line 139
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-loosesync]          loose sync of resume among servers\n");
#line 140
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-rewind msec]        rewind input if spoken while pause at resume\n");
#line 141
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  [-C jconffile]        load jconf to set parameters (ignore other options\n");
#line 143
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLibrary configuration: ");
#line 144
  confout_version(stderr);
#line 145
  confout_audio(stderr);
#line 146
  confout_process(stderr);
#line 147
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 148
  exit(1);
  }
#line 149
  return ((boolean )1);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_in(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 155
  jconf->input.plugin_source = -1;
#line 156
  jconf->input.type = 0;
  {
#line 158
  if ((int )*(*(arg + 0) + 0) == 109) {
#line 158
    goto case_109;
  }
#line 166
  if ((int )*(*(arg + 0) + 0) == 102) {
#line 166
    goto case_102;
  }
#line 170
  if ((int )*(*(arg + 0) + 0) == 115) {
#line 170
    goto case_115;
  }
#line 174
  if ((int )*(*(arg + 0) + 0) == 97) {
#line 174
    goto case_97;
  }
#line 177
  if ((int )*(*(arg + 0) + 0) == 110) {
#line 177
    goto case_110;
  }
#line 185
  goto switch_default;
  case_109: /* CIL Label */ 
#line 160
  jconf->input.speech_input = 1;
#line 165
  goto switch_break;
  case_102: /* CIL Label */ 
#line 167
  jconf->input.speech_input = 0;
#line 168
  jconf->detect.silence_cut = 1;
#line 169
  goto switch_break;
  case_115: /* CIL Label */ 
#line 171
  jconf->input.speech_input = 5;
#line 172
  jconf->detect.silence_cut = 1;
#line 173
  goto switch_break;
  case_97: /* CIL Label */ 
#line 175
  jconf->input.speech_input = 2;
#line 176
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 181
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: netaudio input not available\n");
  }
#line 182
  return ((boolean )0);
#line 184
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 186
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no such input device: %s\n",
          *(arg + 0));
  }
#line 187
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
#line 189
  return ((boolean )1);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_out(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 195
  if ((int )*(*(arg + 0) + 0) == 102) {
#line 195
    goto case_102;
  }
#line 198
  if ((int )*(*(arg + 0) + 0) == 115) {
#line 198
    goto case_115;
  }
#line 201
  if ((int )*(*(arg + 0) + 0) == 97) {
#line 201
    goto case_97;
  }
#line 204
  goto switch_default;
  case_102: /* CIL Label */ 
#line 196
  speech_output = 0;
#line 197
  goto switch_break;
  case_115: /* CIL Label */ 
#line 199
  speech_output = 1;
#line 200
  goto switch_break;
  case_97: /* CIL Label */ 
#line 202
  speech_output = 2;
#line 203
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 205
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: no such output device: %s\n",
          *(arg + 0));
  }
#line 206
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
#line 208
  return ((boolean )1);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_server(Jconf *jconf , char **arg , int argnum ) 
{ 
  char *p___0 ;
  char *q___0 ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 214
  if (speech_output == 2) {
    {
#line 215
    tmp = strlen((char const   *)*(arg + 0));
#line 215
    tmp___0 = malloc(tmp + 1UL);
#line 215
    p___0 = (char *)tmp___0;
#line 216
    strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)*(arg + 0));
#line 217
    q___0 = strtok((char */* __restrict  */)p___0, (char const   */* __restrict  */)",");
    }
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
#line 217
      if (! q___0) {
#line 217
        goto while_break;
      }
#line 218
      if (adinnet_servnum >= 10) {
        {
#line 219
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: too many servers (> %d): %s\n",
                10, *(arg + 0));
        }
#line 220
        return ((boolean )0);
      }
      {
#line 222
      tmp___1 = strlen((char const   *)q___0);
#line 222
      tmp___2 = malloc(tmp___1 + 1UL);
#line 222
      adinnet_serv[adinnet_servnum] = (char *)tmp___2;
#line 223
      strcpy((char */* __restrict  */)adinnet_serv[adinnet_servnum], (char const   */* __restrict  */)q___0);
#line 224
      adinnet_servnum ++;
#line 217
      q___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 226
    free((void *)p___0);
    }
  } else {
    {
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: server [%s] should be with adinnet\n",
            *(arg + 0));
    }
#line 229
    return ((boolean )0);
  }
#line 231
  return ((boolean )1);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_NA(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 245
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: NetAudio(DatLink) not supported\n");
  }
#line 246
  return ((boolean )0);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_inport(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 252
  adinnet_port_in = atoi((char const   *)*(arg + 0));
  }
#line 253
  return ((boolean )1);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_port(Jconf *jconf , char **arg , int argnum ) 
{ 
  char *p___0 ;
  char *q___0 ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 260
  tmp = strlen((char const   *)*(arg + 0));
#line 260
  tmp___0 = malloc(tmp + 1UL);
#line 260
  p___0 = (char *)tmp___0;
#line 261
  strcpy((char */* __restrict  */)p___0, (char const   */* __restrict  */)*(arg + 0));
#line 262
  q___0 = strtok((char */* __restrict  */)p___0, (char const   */* __restrict  */)",");
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! q___0) {
#line 262
      goto while_break;
    }
#line 263
    if (adinnet_portnum >= 10) {
      {
#line 264
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: too many server ports (> %d): %s\n",
              10, *(arg + 0));
      }
#line 265
      return ((boolean )0);
    }
    {
#line 267
    adinnet_port[adinnet_portnum] = atoi((char const   *)q___0);
#line 268
    adinnet_portnum ++;
#line 262
    q___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 270
  free((void *)p___0);
  }
#line 271
  return ((boolean )1);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_filename(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 277
  filename = *(arg + 0);
#line 278
  return ((boolean )1);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_startid(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 283
  startid = atoi((char const   *)*(arg + 0));
  }
#line 284
  return ((boolean )1);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_freq(Jconf *jconf , char **arg , int argnum ) 
{ 
  int tmp ;

  {
  {
#line 289
  tmp = atoi((char const   *)*(arg + 0));
#line 289
  (jconf->amnow)->analysis.para.smp_freq = (long )tmp;
#line 290
  (jconf->amnow)->analysis.para.smp_period = (long )(10000000.0 / (double )((float )(jconf->amnow)->analysis.para.smp_freq));
  }
#line 291
  return ((boolean )1);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_nosegment(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 296
  jconf->detect.silence_cut = 0;
#line 297
  return ((boolean )1);
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_segment(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 302
  jconf->detect.silence_cut = 1;
#line 303
  return ((boolean )1);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_oneshot(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 308
  continuous_segment = (boolean )0;
#line 309
  return ((boolean )1);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_raw(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 314
  use_raw = (boolean )1;
#line 315
  return ((boolean )1);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_autopause(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 320
  pause_each = (boolean )1;
#line 321
  return ((boolean )1);
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_loosesync(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 326
  loose_sync = (boolean )1;
#line 327
  return ((boolean )1);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean opt_rewind(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 332
  rewind_msec = atoi((char const   *)*(arg + 0));
  }
#line 333
  return ((boolean )1);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
void put_status(Recog *recog ) 
{ 
  int i ;
  Jconf *jconf ;

  {
  {
#line 350
  jconf = recog->jconf;
#line 352
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"----\n");
#line 353
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input stream:\n");
#line 354
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t             input type = ");
  }
  {
#line 356
  if (jconf->input.type == 0) {
#line 356
    goto case_0;
  }
#line 359
  if (jconf->input.type == 1) {
#line 359
    goto case_1;
  }
#line 355
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 357
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waveform\n");
  }
#line 358
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 360
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"feature vector sequence\n");
  }
#line 361
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 363
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t           input source = ");
  }
#line 364
  if (jconf->input.plugin_source != -1) {
    {
#line 365
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"plugin\n");
    }
  } else
#line 366
  if (jconf->input.speech_input == 0) {
    {
#line 367
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"waveform file\n");
    }
  } else
#line 368
  if (jconf->input.speech_input == 3) {
    {
#line 369
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"feature vector file (HTK format)\n");
    }
  } else
#line 370
  if (jconf->input.speech_input == 5) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"standard input\n");
    }
  } else
#line 372
  if (jconf->input.speech_input == 2) {
    {
#line 373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinnet client\n");
    }
  } else
#line 386
  if (jconf->input.speech_input == 1) {
    {
#line 387
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"microphone\n");
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t    device API          = ");
    }
    {
#line 390
    if (jconf->input.device == 0) {
#line 390
      goto case_0___0;
    }
#line 391
    if (jconf->input.device == 1) {
#line 391
      goto case_1___0;
    }
#line 392
    if (jconf->input.device == 2) {
#line 392
      goto case_2;
    }
#line 393
    if (jconf->input.device == 3) {
#line 393
      goto case_3;
    }
#line 394
    if (jconf->input.device == 4) {
#line 394
      goto case_4;
    }
#line 389
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"default\n");
    }
#line 390
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"alsa\n");
    }
#line 391
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 392
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"oss\n");
    }
#line 392
    goto switch_break___0;
    case_3: /* CIL Label */ 
    {
#line 393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"esd\n");
    }
#line 393
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pulseaudio\n");
    }
#line 394
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 398
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Segmentation: ");
  }
#line 399
  if (jconf->detect.silence_cut) {
#line 400
    if (continuous_segment) {
      {
#line 401
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"on, continuous\n");
      }
    } else {
      {
#line 403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"on, only one snapshot\n");
      }
    }
#line 405
    if ((recog->adin)->down_sample) {
      {
#line 406
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  SampleRate: 48000Hz -> %d Hz\n",
              sfreq);
      }
    } else {
      {
#line 408
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  SampleRate: %d Hz\n",
              sfreq);
      }
    }
    {
#line 410
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       Level: %d / 32767\n",
            jconf->detect.level_thres);
#line 411
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   ZeroCross: %d per sec.\n",
            jconf->detect.zero_cross_num);
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  HeadMargin: %d msec.\n",
            jconf->detect.head_margin_msec);
#line 413
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  TailMargin: %d msec.\n",
            jconf->detect.tail_margin_msec);
    }
  } else {
    {
#line 415
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OFF\n");
    }
  }
#line 417
  if (jconf->preprocess.strip_zero_sample) {
    {
#line 418
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ZeroFrames: drop\n");
    }
  } else {
    {
#line 420
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  ZeroFrames: keep\n");
    }
  }
#line 422
  if (jconf->preprocess.use_zmean) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   remove DC: on\n");
    }
  } else {
    {
#line 425
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   remove DC: off\n");
    }
  }
#line 427
  if (pause_each) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Autopause: on\n");
    }
  } else {
    {
#line 430
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Autopause: off\n");
    }
  }
#line 432
  if (loose_sync) {
    {
#line 433
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   LooseSync: on\n");
    }
  } else {
    {
#line 435
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   LooseSync: off\n");
    }
  }
#line 437
  if (rewind_msec > 0) {
    {
#line 438
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Rewind: %d msec\n",
            rewind_msec);
    }
  } else {
    {
#line 440
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"      Rewind: no\n");
    }
  }
  {
#line 442
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   Output to: ");
  }
  {
#line 444
  if (speech_output == 0) {
#line 444
    goto case_0___1;
  }
#line 459
  if (speech_output == 1) {
#line 459
    goto case_1___1;
  }
#line 463
  if (speech_output == 2) {
#line 463
    goto case_2___0;
  }
#line 443
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
#line 445
  if (jconf->detect.silence_cut) {
#line 446
    if (continuous_segment) {
#line 447
      if (use_raw) {
        {
#line 448
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.%04d.raw, %s.%04d.raw, ...\n",
                filename, startid, filename, startid + 1);
        }
      } else {
        {
#line 450
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.%04d.wav, %s.%04d.wav, ...\n",
                filename, startid, filename, startid + 1);
        }
      }
    } else {
      {
#line 453
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              outpath);
      }
    }
  } else {
    {
#line 456
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s (warning: inifinite recording: be care of disk space!)\n",
            outpath);
    }
  }
#line 458
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
  {
#line 460
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"STDOUT\n");
#line 461
  use_raw = (boolean )1;
  }
#line 462
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  {
#line 464
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinnet server");
#line 465
  i = 0;
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < adinnet_servnum)) {
#line 465
      goto while_break;
    }
    {
#line 466
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s:%d)",
            adinnet_serv[i], adinnet_port[i]);
#line 465
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 469
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 471
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"----\n");
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static char *new_output_filename(char *filename___2 , char *suffix ) 
{ 
  int len ;
  int slen___0 ;
  char *buf___13 ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 480
  tmp = strlen((char const   *)filename___2);
#line 480
  len = (int )tmp;
#line 481
  tmp___0 = strlen((char const   *)suffix);
#line 481
  slen___0 = (int )tmp___0;
  }
#line 482
  if (len < slen___0) {
    {
#line 483
    tmp___1 = mymalloc((size_t )((len + slen___0) + 1));
#line 483
    buf___13 = strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)filename___2);
#line 484
    strcat((char */* __restrict  */)buf___13, (char const   */* __restrict  */)suffix);
    }
  } else {
    {
#line 482
    tmp___3 = strcmp((char const   *)(filename___2 + (len - slen___0)), (char const   *)suffix);
    }
#line 482
    if (tmp___3 != 0) {
      {
#line 483
      tmp___1 = mymalloc((size_t )((len + slen___0) + 1));
#line 483
      buf___13 = strcpy((char */* __restrict  */)((char *)tmp___1), (char const   */* __restrict  */)filename___2);
#line 484
      strcat((char */* __restrict  */)buf___13, (char const   */* __restrict  */)suffix);
      }
    } else {
      {
#line 486
      tmp___2 = mymalloc((size_t )(len + 1));
#line 486
      buf___13 = strcpy((char */* __restrict  */)((char *)tmp___2), (char const   */* __restrict  */)filename___2);
      }
    }
  }
#line 488
  return (buf___13);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adin_callback_file(SP16 *now , int len , Recog *recog ) 
{ 
  int count ;
  int start ;
  int w ;
  int tmp ;
  int tmp___0 ;
  boolean tmp___1 ;

  {
#line 522
  start = 0;
#line 524
  if ((recog->jconf)->input.speech_input == 1) {
#line 524
    if (speechlen == 0) {
#line 526
      if (rewind_msec > 0) {
#line 526
        if (! (recog->adin)->is_valid_data) {
          {
#line 530
          printf((char const   */* __restrict  */)"disgard already recorded %d samples\n",
                 len);
          }
#line 531
          return (0);
        }
      }
      {
#line 534
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                    \r");
      }
#line 535
      if (rewind_msec > 0) {
        {
#line 539
        printf((char const   */* __restrict  */)"buffered samples=%d\n", len);
#line 540
        w = (rewind_msec * sfreq) / 1000;
        }
#line 541
        if (len > w) {
#line 542
          start = len - w;
#line 543
          len = w;
        } else {
#line 545
          start = 0;
        }
        {
#line 547
        printf((char const   */* __restrict  */)"will process from %d\n", start);
        }
      }
    }
  }
#line 552
  if (speech_output == 0) {
#line 552
    if (speechlen == 0) {
#line 553
      if (continuous_segment) {
#line 554
        if (use_raw) {
          {
#line 555
          sprintf((char */* __restrict  */)outpath, (char const   */* __restrict  */)"%s.%04d.raw",
                  filename, sid);
          }
        } else {
          {
#line 557
          sprintf((char */* __restrict  */)outpath, (char const   */* __restrict  */)"%s.%04d.wav",
                  filename, sid);
          }
        }
      }
      {
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s]",
              outpath);
#line 561
      tmp___0 = access((char const   *)outpath, 0);
      }
#line 561
      if (tmp___0 == 0) {
        {
#line 562
        tmp = access((char const   *)outpath, 2);
        }
#line 562
        if (tmp == 0) {
          {
#line 563
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(override)");
          }
        } else {
          {
#line 565
          perror("adintool");
          }
#line 566
          return (-1);
        }
      }
#line 569
      if (use_raw) {
        {
#line 570
        fd = open((char const   *)outpath, 66, 420);
        }
#line 570
        if (fd == -1) {
          {
#line 575
          perror("adintool");
          }
#line 576
          return (-1);
        }
      } else {
        {
#line 579
        fp = wrwav_open(outpath, sfreq);
        }
#line 579
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 580
          perror("adintool");
          }
#line 581
          return (-1);
        }
      }
#line 584
      writing_file = (boolean )1;
    }
  }
#line 588
  if (use_raw) {
    {
#line 589
    count = wrsamp(fd, now + start, len);
    }
#line 590
    if (count < 0) {
      {
#line 591
      perror("adinrec: cannot write");
      }
#line 592
      return (-1);
    }
#line 594
    if ((unsigned long )count < (unsigned long )len * sizeof(SP16 )) {
      {
#line 595
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: cannot write more %d bytes\ncurrent length = %d\n",
              count, (unsigned long )speechlen * sizeof(SP16 ));
      }
#line 596
      return (-1);
    }
  } else {
    {
#line 599
    tmp___1 = wrwav_data(fp, now + start, len);
    }
#line 599
    if ((int )tmp___1 == 0) {
      {
#line 600
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: cannot write\n");
      }
#line 601
      return (-1);
    }
  }
#line 606
  speechlen += len;
#line 609
  if ((recog->jconf)->input.speech_input == 1) {
#line 610
    if (speechlen > 304000) {
#line 611
      (recog->adin)->rehash = (boolean )1;
    }
  }
  {
#line 616
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
  }
#line 618
  return (0);
}
}
#line 644 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adin_callback_adinnet(SP16 *now , int len , Recog *recog ) 
{ 
  int count ;
  int start ;
  int w ;
  int i ;

  {
#line 651
  start = 0;
#line 653
  if ((recog->jconf)->input.speech_input == 1) {
#line 653
    if (speechlen == 0) {
#line 655
      if (rewind_msec > 0) {
#line 655
        if (! (recog->adin)->is_valid_data) {
          {
#line 659
          printf((char const   */* __restrict  */)"disgard already recorded %d samples\n",
                 len);
          }
#line 660
          return (0);
        }
      }
      {
#line 663
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                    \r");
      }
#line 664
      if (rewind_msec > 0) {
        {
#line 668
        printf((char const   */* __restrict  */)"buffered samples=%d\n", len);
#line 669
        w = (rewind_msec * sfreq) / 1000;
        }
#line 670
        if (len > w) {
#line 671
          start = len - w;
#line 672
          len = w;
        } else {
#line 674
          start = 0;
        }
        {
#line 676
        printf((char const   */* __restrict  */)"will process from %d\n", start);
        }
      }
    }
  }
#line 683
  i = 0;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (i < adinnet_servnum)) {
#line 683
      goto while_break;
    }
    {
#line 684
    count = wt(sd[i], (char *)(now + start), (int )((unsigned long )len * sizeof(SP16 )));
    }
#line 685
    if (count < 0) {
      {
#line 686
      perror("adintool: cannot write");
#line 687
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to send data to %s:%d\n",
              adinnet_serv[i], adinnet_port[i]);
      }
    }
#line 683
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 694
  speechlen += len;
#line 696
  if ((recog->adin)->enable_thread) {
#line 698
    if ((recog->adin)->speechlen > 304000) {
      {
#line 699
      (recog->adin)->rehash = (boolean )1;
#line 700
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"+");
      }
    }
  }
  {
#line 706
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
  }
#line 707
  return (0);
}
}
#line 721 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static void adin_send_end_of_segment(void) 
{ 
  char p___0 ;
  int i ;
  int tmp ;

  {
#line 727
  i = 0;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
#line 727
    if (! (i < adinnet_servnum)) {
#line 727
      goto while_break;
    }
    {
#line 728
    tmp = wt(sd[i], & p___0, 0);
    }
#line 728
    if (tmp < 0) {
      {
#line 729
      perror("adintool: cannot write");
#line 730
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to send EOS to %s:%d\n",
              adinnet_serv[i], adinnet_port[i]);
      }
    }
#line 727
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 733
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int unknown_command_counter  =    0;
#line 759 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_check_command(void) 
{ 
  fd_set rfds ;
  struct timeval tv ;
  int status ;
  int cnt ;
  int ret ;
  char com ;
  int i ;
  int max_sd ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 770
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  max_sd = 0;
#line 772
  i = 0;
  {
#line 772
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 772
    if (! (i < adinnet_servnum)) {
#line 772
      goto while_break___0;
    }
#line 773
    if (max_sd < sd[i]) {
#line 773
      max_sd = sd[i];
    }
#line 774
    rfds.__fds_bits[sd[i] / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd[i] % (8 * (int )sizeof(__fd_mask ));
#line 772
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 776
  tv.tv_sec = (__time_t )0;
#line 777
  tv.tv_usec = (__suseconds_t )1;
#line 778
  status = select(max_sd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 779
  if (status < 0) {
    {
#line 780
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adintool: cannot check command from adinnet server\n");
    }
#line 781
    return (-2);
  }
#line 783
  if (status > 0) {
#line 784
    i = 0;
    {
#line 784
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 784
      if (! (i < adinnet_servnum)) {
#line 784
        goto while_break___1;
      }
#line 785
      if ((rfds.__fds_bits[sd[i] / (8 * (int )sizeof(__fd_mask ))] & (1L << sd[i] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 786
        ret = rd(sd[i], & com, & cnt, 1);
        }
        {
#line 788
        if ((int )com == 48) {
#line 788
          goto case_48;
        }
#line 793
        if ((int )com == 49) {
#line 793
          goto case_49;
        }
#line 797
        if ((int )com == 50) {
#line 797
          goto case_50;
        }
#line 803
        goto switch_default;
        case_48: /* CIL Label */ 
        {
#line 789
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: PAUSE>\n",
                i + 1);
#line 790
        stop_at_next = (boolean )1;
        }
#line 792
        return (-1);
        case_49: /* CIL Label */ 
        {
#line 794
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: RESUME - already running, ignored>\n",
                i + 1);
        }
#line 796
        goto switch_break;
        case_50: /* CIL Label */ 
        {
#line 798
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: TERMINATE>\n",
                i + 1);
#line 799
        stop_at_next = (boolean )1;
        }
#line 801
        return (-2);
#line 802
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 804
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adintool: unknown command from #%d: %d\n",
                i + 1, (int )com);
#line 805
        unknown_command_counter ++;
        }
#line 808
        if (unknown_command_counter > 100) {
          {
#line 809
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"killed by a flood of unknown commands from server\n");
#line 810
          exit(1);
          }
        }
        switch_break: /* CIL Label */ ;
        }
      }
#line 784
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 816
  return (0);
}
}
#line 819 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int resume_count[10]  ;
#line 834 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static int adinnet_wait_command(void) 
{ 
  fd_set rfds ;
  int status ;
  int cnt ;
  int ret ;
  char com ;
  int i ;
  int count ;
  int max_sd ;
  int __d0 ;
  int __d1 ;

  {
  {
#line 843
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<< waiting RESUME >>>");
  }
  {
#line 845
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (loose_sync) {
#line 848
      i = 0;
      {
#line 848
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 848
        if (! (i < adinnet_servnum)) {
#line 848
          goto while_break___0;
        }
#line 849
        if (resume_count[i] == 0) {
#line 849
          goto while_break___0;
        }
#line 848
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 851
      if (i >= adinnet_servnum) {
#line 852
        i = 0;
        {
#line 852
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 852
          if (! (i < adinnet_servnum)) {
#line 852
            goto while_break___1;
          }
#line 852
          resume_count[i] = 0;
#line 852
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 853
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>RESUME\n");
        }
#line 854
        return (1);
      }
    } else {
#line 858
      count = resume_count[0];
#line 859
      i = 1;
      {
#line 859
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 859
        if (! (i < adinnet_servnum)) {
#line 859
          goto while_break___2;
        }
#line 860
        if (count != resume_count[i]) {
#line 860
          goto while_break___2;
        }
#line 859
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 862
      if (i >= adinnet_servnum) {
#line 862
        if (count > 0) {
#line 864
          i = 0;
          {
#line 864
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 864
            if (! (i < adinnet_servnum)) {
#line 864
              goto while_break___3;
            }
#line 864
            resume_count[i] = 0;
#line 864
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 865
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)">>RESUME\n");
          }
#line 866
          return (1);
        }
      }
    }
    {
#line 870
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 870
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 870
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 871
    max_sd = 0;
#line 872
    i = 0;
    {
#line 872
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 872
      if (! (i < adinnet_servnum)) {
#line 872
        goto while_break___5;
      }
#line 873
      if (max_sd < sd[i]) {
#line 873
        max_sd = sd[i];
      }
#line 874
      rfds.__fds_bits[sd[i] / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd[i] % (8 * (int )sizeof(__fd_mask ));
#line 872
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 876
    status = select(max_sd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 877
    if (status < 0) {
      {
#line 878
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adintool: cannot check command from adinnet server\n");
      }
#line 879
      return (-1);
    } else {
#line 881
      i = 0;
      {
#line 881
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 881
        if (! (i < adinnet_servnum)) {
#line 881
          goto while_break___6;
        }
#line 882
        if ((rfds.__fds_bits[sd[i] / (8 * (int )sizeof(__fd_mask ))] & (1L << sd[i] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 883
          ret = rd(sd[i], & com, & cnt, 1);
          }
          {
#line 885
          if ((int )com == 48) {
#line 885
            goto case_48;
          }
#line 894
          if ((int )com == 49) {
#line 894
            goto case_49;
          }
#line 903
          if ((int )com == 50) {
#line 903
            goto case_50;
          }
#line 912
          goto switch_default;
          case_48: /* CIL Label */ 
#line 887
          if (loose_sync) {
            {
#line 888
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: PAUSE - already paused, reset sync>\n",
                    i + 1);
#line 889
            i = 0;
            }
            {
#line 889
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 889
              if (! (i < adinnet_servnum)) {
#line 889
                goto while_break___7;
              }
#line 889
              resume_count[i] = 0;
#line 889
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
            {
#line 891
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: PAUSE - already paused, ignored>\n",
                    i + 1);
            }
          }
#line 893
          goto switch_break;
          case_49: /* CIL Label */ 
#line 896
          (resume_count[i]) ++;
#line 897
          if (loose_sync) {
            {
#line 898
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: RESUME>\n",
                    i + 1);
            }
          } else {
            {
#line 900
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: RESUME @%d>\n",
                    i + 1, resume_count[i]);
            }
          }
#line 902
          goto switch_break;
          case_50: /* CIL Label */ 
#line 905
          if (loose_sync) {
            {
#line 906
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: TERMINATE - already paused, reset sync>\n",
                    i + 1);
#line 907
            i = 0;
            }
            {
#line 907
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 907
              if (! (i < adinnet_servnum)) {
#line 907
                goto while_break___8;
              }
#line 907
              resume_count[i] = 0;
#line 907
              i ++;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
            {
#line 909
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<#%d: TERMINATE - already paused, ignored>\n",
                    i + 1);
            }
          }
#line 911
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 913
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adintool: unknown command from #%d: %d\n",
                  i + 1, (int )com);
#line 914
          unknown_command_counter ++;
          }
#line 917
          if (unknown_command_counter > 100) {
            {
#line 918
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"killed by a flood of unknown commands from server\n");
#line 919
            exit(1);
            }
          }
          switch_break: /* CIL Label */ ;
          }
        }
#line 881
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 926
  return (0);
}
}
#line 930 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static boolean close_files(void) 
{ 
  int tmp ;
  boolean tmp___0 ;

  {
#line 933
  size = (int )(sizeof(SP16 ) * (unsigned long )speechlen);
#line 935
  if (writing_file) {
#line 936
    if (use_raw) {
      {
#line 937
      tmp = close(fd);
      }
#line 937
      if (tmp != 0) {
        {
#line 938
        perror("adinrec");
        }
#line 939
        return ((boolean )0);
      }
    } else {
      {
#line 942
      tmp___0 = wrwav_close(fp);
      }
#line 942
      if ((int )tmp___0 == 0) {
        {
#line 943
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: failed to close file\n");
        }
#line 944
        return ((boolean )0);
      }
    }
    {
#line 947
    printf((char const   */* __restrict  */)"%s: %d samples (%.2f sec.) [%6d (%5.2fs) - %6d (%5.2fs)]\n",
           outpath, speechlen, (double )((float )speechlen / (float )sfreq), trigger_sample,
           (double )((float )trigger_sample / (float )sfreq), trigger_sample + speechlen,
           (double )((float )(trigger_sample + speechlen) / (float )sfreq));
#line 953
    writing_file = (boolean )0;
    }
  }
#line 956
  return ((boolean )1);
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static void interrupt_record(int signum ) 
{ 


  {
  {
#line 963
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Interrupt]");
  }
#line 964
  if (speech_output == 0) {
    {
#line 966
    close_files();
    }
  }
  {
#line 969
  exit(1);
  }
}
}
#line 972 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adintool/adintool.c"
static void record_trigger_time(Recog *recog , void *data ) 
{ 


  {
#line 975
  trigger_sample = (int )(recog->adin)->last_trigger_sample;
#line 976
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static int speechlen___0  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static int fd___0  =    -1;
#line 30 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static FILE *fp___0  =    (FILE *)((void *)0);
#line 31 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static int size___0  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static int sfreq___0  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static char *filename___0  =    (char *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static boolean stout  =    (boolean )0;
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static boolean use_raw___0  =    (boolean )0;
#line 42 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static boolean opt_help___0(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec --- record one sentence input to a file\n");
#line 46
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: adinrec [options..] filename\n");
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-input mic|pulseaudio|alsa|oss|esd|...]  input source       (mic)\n");
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-freq frequency]     sampling frequency in Hz    (%ld)\n",
          (jconf->am_root)->analysis.para_default.smp_freq);
#line 49
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-48]                 48000Hz recording with down sampling (16kHz only)\n");
#line 50
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-lv unsignedshort]   silence cut level threshold (%d)\n",
          jconf->detect.level_thres);
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-zc zerocrossnum]    silence cut zerocross num   (%d)\n",
          jconf->detect.zero_cross_num);
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-headmargin msec]    head margin length          (%d)\n",
          jconf->detect.head_margin_msec);
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-tailmargin msec]    tail margin length          (%d)\n",
          jconf->detect.tail_margin_msec);
#line 54
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-chunksize sample]   chunk size for processing   (%d)\n",
          jconf->detect.chunk_size);
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-nostrip]            not strip off zero samples\n");
#line 56
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-zmean]              remove DC by zero mean\n");
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-nocutsilence]       disable VAD, record all stream\n");
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-raw]                output in RAW format\n");
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLibrary configuration: ");
#line 60
  confout_version(stderr);
#line 61
  confout_audio(stderr);
#line 62
  confout_process(stderr);
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 64
  exit(1);
  }
#line 65
  return ((boolean )1);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static boolean opt_raw___0(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 71
  use_raw___0 = (boolean )1;
#line 72
  return ((boolean )1);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static boolean opt_freq___0(Jconf *jconf , char **arg , int argnum ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = atoi((char const   *)*(arg + 0));
#line 77
  (jconf->amnow)->analysis.para.smp_freq = (long )tmp;
#line 78
  (jconf->amnow)->analysis.para.smp_period = (long )(10000000.0 / (double )((float )(jconf->amnow)->analysis.para.smp_freq));
  }
#line 79
  return ((boolean )1);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static int adin_callback_file___0(SP16 *now , int len , Recog *recog ) 
{ 
  int count ;
  boolean tmp ;

  {
#line 109
  if (speechlen___0 == 0) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                    \r");
    }
  }
#line 114
  if (use_raw___0) {
#line 115
    if (fd___0 == -1) {
#line 116
      if (stout) {
#line 117
        fd___0 = 1;
      } else {
        {
#line 119
        fd___0 = open((char const   *)filename___0, 66, 420);
        }
#line 119
        if (fd___0 == -1) {
          {
#line 124
          perror("adinrec");
          }
#line 125
          return (-1);
        }
      }
    }
  } else
#line 130
  if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
    {
#line 131
    fp___0 = wrwav_open(filename___0, sfreq___0);
    }
#line 131
    if ((unsigned long )fp___0 == (unsigned long )((void *)0)) {
      {
#line 132
      perror("adinrec");
      }
#line 133
      return (-1);
    }
  }
#line 138
  if (use_raw___0) {
    {
#line 139
    count = wrsamp(fd___0, now, len);
    }
#line 140
    if (count < 0) {
      {
#line 141
      perror("adinrec: cannot write");
      }
#line 142
      return (-1);
    }
#line 144
    if ((unsigned long )count < (unsigned long )len * sizeof(SP16 )) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: cannot write more %d bytes\ncurrent length = %d\n",
              count, (unsigned long )speechlen___0 * sizeof(SP16 ));
      }
#line 146
      return (-1);
    }
  } else {
    {
#line 149
    tmp = wrwav_data(fp___0, now, len);
    }
#line 149
    if ((int )tmp == 0) {
      {
#line 150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: cannot write\n");
      }
#line 151
      return (-1);
    }
  }
  {
#line 155
  speechlen___0 += len;
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
  }
#line 159
  return (0);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static void close_file(void) 
{ 
  int tmp ;
  boolean tmp___0 ;

  {
#line 166
  size___0 = (int )(sizeof(SP16 ) * (unsigned long )speechlen___0);
#line 167
  if (use_raw___0) {
#line 168
    if (fd___0 >= 0) {
      {
#line 169
      tmp = close(fd___0);
      }
#line 169
      if (tmp != 0) {
        {
#line 170
        perror("adinrec");
        }
      }
    }
  } else
#line 174
  if ((unsigned long )fp___0 != (unsigned long )((void *)0)) {
    {
#line 175
    tmp___0 = wrwav_close(fp___0);
    }
#line 175
    if ((int )tmp___0 == 0) {
      {
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adinrec: failed to close file\n");
      }
    }
  }
  {
#line 180
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%d samples (%d bytes, %.2f sec.) recorded\n",
          speechlen___0, size___0, (double )((float )speechlen___0 / (float )sfreq___0));
  }
#line 181
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/adinrec/adinrec.c"
static void interrupt_record___0(int signum ) 
{ 


  {
  {
#line 187
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[Interrupt]");
#line 189
  close_file();
#line 191
  exit(1);
  }
}
}
#line 112 "../libsent/include/sent/util.h"
extern void confout_lm(FILE *strm ) ;
#line 235 "../libsent/include/sent/ngram2.h"
extern boolean ngram_write_bin(FILE *fp , NGRAM_INFO *ndata , char *header_str ) ;
#line 243
extern NGRAM_INFO *ngram_info_new() ;
#line 245
extern boolean init_ngram_bin(NGRAM_INFO *ndata , char *ngram_file ) ;
#line 246
extern boolean init_ngram_arpa(NGRAM_INFO *ndata , char *ngram_file , int dir ) ;
#line 247
extern boolean init_ngram_arpa_additional(NGRAM_INFO *ndata , char *bigram_file ) ;
#line 251
extern void print_ngram_info(FILE *fp , NGRAM_INFO *ndata ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkbingram/mkbingram.c"
static NGRAM_INFO *ngram___0  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 99 "../libsent/include/sent/util.h"
extern void jlog(char *format  , ...) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.h"
boolean charconv_iconv_setup(char *fromcode , char *tocode , boolean *enable_conv ) ;
#line 12
char *charconv_iconv(char *instr , char *outstr , int maxoutlen ) ;
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv_iconv.c"
static iconv_t cd  =    (iconv_t )-1;
#line 44 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv_iconv.c"
boolean charconv_iconv_setup(char *fromcode , char *tocode , boolean *enable_conv ) 
{ 
  int tmp ;

  {
#line 48
  if ((unsigned long )cd != (unsigned long )((iconv_t )-1)) {
    {
#line 49
    tmp = iconv_close(cd);
    }
#line 49
    if (tmp < 0) {
      {
#line 50
      perror("j_prinf_set_iconv");
      }
#line 51
      return ((boolean )0);
    }
#line 53
    cd = (iconv_t )-1;
  }
#line 56
  if ((unsigned long )tocode == (unsigned long )((void *)0)) {
#line 58
    *enable_conv = (boolean )0;
  } else {
#line 61
    if ((unsigned long )fromcode == (unsigned long )((void *)0)) {
      {
#line 62
      jlog((char *)"Error: charconv_iconv: charset names of both input and output should be given.\n");
#line 63
      jlog((char *)"Error: charconv_iconf: use \"-charconv from to\" instead of \"-kanji\".\n");
#line 64
      *enable_conv = (boolean )0;
      }
#line 65
      return ((boolean )0);
    }
    {
#line 68
    cd = iconv_open((char const   *)tocode, (char const   *)fromcode);
    }
#line 69
    if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
      {
#line 71
      jlog((char *)"Error: charconv_iconv: unknown charset name in \"%s\" or \"%s\"\n",
           fromcode, tocode);
#line 72
      jlog((char *)"Error: charconv_iconv: do \"iconv --list\" to get the list of available charset names.\n");
#line 73
      *enable_conv = (boolean )0;
      }
#line 74
      return ((boolean )0);
    }
#line 76
    *enable_conv = (boolean )1;
  }
#line 78
  return ((boolean )1);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv_iconv.c"
char *charconv_iconv(char *instr , char *outstr , int maxoutlen ) 
{ 
  char *src ;
  char *dst ;
  size_t srclen ;
  size_t dstlen ;
  size_t ret ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 98
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
    {
#line 99
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InternalError: codeconv: conversion descriptor not allocated\n");
#line 99
    exit(-1);
    }
  }
  {
#line 101
  tmp = strlen((char const   *)instr);
#line 101
  srclen = tmp + 1UL;
#line 102
  dstlen = (size_t )maxoutlen;
#line 103
  src = instr;
#line 104
  dst = outstr;
#line 105
  ret = iconv(cd, (char **/* __restrict  */)(& src), (size_t */* __restrict  */)(& srclen),
              (char **/* __restrict  */)(& dst), (size_t */* __restrict  */)(& dstlen));
  }
#line 106
  if (ret == 0xffffffffffffffffUL) {
    {
#line 107
    tmp___0 = __errno_location();
    }
    {
#line 108
    if (*tmp___0 == 84) {
#line 108
      goto case_84;
    }
#line 111
    if (*tmp___0 == 22) {
#line 111
      goto case_22;
    }
#line 114
    if (*tmp___0 == 7) {
#line 114
      goto case_7;
    }
#line 107
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InternalError: codeconv: invalid multibyte sequence in the input\n");
#line 109
    exit(-1);
    }
#line 110
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InternalError: codeconv: incomplete multibyte sequence in the input\n");
#line 112
    exit(-1);
    }
#line 113
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"InternalError: codeconv: converted string size exceeded buffer (>%d)\n",
            maxoutlen);
#line 115
    exit(-1);
    }
#line 116
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 121
  return (outstr);
}
}
#line 67 "../libsent/include/sent/util.h"
extern char *getl_fp(char * , int  , FILE * ) ;
#line 68
extern char *get_line_from_stdin(char *buf , int buflen , char *prompt ) ;
#line 50 "../libjulius/include/julius/global.h"
boolean verbose_flag ;
#line 38 "../libjulius/include/julius/jfunc.h"
extern int j_recognize_stream(Recog *recog ) ;
#line 63
extern char *j_get_current_filename(Recog *recog ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/app.h"
void main_recognition_stream_loop(Recog *recog ) ;
#line 40
void outfile_set_fname(char *input_filename ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/recogloop.c"
boolean outfile_enabled ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/recogloop.c"
static char speechfilename[2048]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/recogloop.c"
void main_recognition_stream_loop(Recog *recog ) 
{ 
  Jconf *jconf ;
  int file_counter___0 ;
  int ret ;
  FILE *mfclist ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 39
  jconf = recog->jconf;
#line 42
  file_counter___0 = 0;
#line 44
  if (jconf->input.speech_input == 3) {
#line 45
    if ((unsigned long )jconf->input.inputlist_filename != (unsigned long )((void *)0)) {
      {
#line 47
      mfclist = fopen((char const   */* __restrict  */)jconf->input.inputlist_filename,
                      (char const   */* __restrict  */)"r");
      }
#line 47
      if ((unsigned long )mfclist == (unsigned long )((void *)0)) {
        {
#line 48
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: cannot open inputlist \"%s\"\n",
                jconf->input.inputlist_filename);
        }
#line 49
        return;
      }
    }
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 59
    printf((char const   */* __restrict  */)"\n");
    }
#line 60
    if (verbose_flag) {
      {
#line 60
      printf((char const   */* __restrict  */)"------\n");
      }
    }
    {
#line 61
    fflush(stdout);
    }
#line 66
    if (jconf->input.speech_input == 3) {
#line 68
      if (verbose_flag) {
        {
#line 68
        jlog((char *)"### read analyzed parameter\n");
        }
      }
#line 69
      if ((unsigned long )jconf->input.inputlist_filename != (unsigned long )((void *)0)) {
        {
#line 70
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 71
          tmp = getl_fp(speechfilename, 2048, mfclist);
          }
#line 71
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
            {
#line 72
            fclose(mfclist);
#line 73
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d files processed\n",
                    file_counter___0);
            }
#line 77
            return;
          }
#line 70
          if (! ((int )speechfilename[0] == 0)) {
#line 70
            if (! ((int )speechfilename[0] == 35)) {
#line 70
              goto while_break___0;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 81
        tmp___0 = get_line_from_stdin(speechfilename, 2048, (char *)"enter MFCC filename->");
        }
#line 81
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          {
#line 82
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d files processed\n",
                  file_counter___0);
          }
#line 86
          return;
        }
      }
#line 89
      if (verbose_flag) {
        {
#line 89
        printf((char const   */* __restrict  */)"\ninput MFCC file: %s\n", speechfilename);
        }
      }
#line 90
      if (outfile_enabled) {
        {
#line 90
        outfile_set_fname(speechfilename);
        }
      }
      {
#line 93
      ret = j_open_stream(recog, speechfilename);
      }
      {
#line 95
      if (ret == 0) {
#line 95
        goto case_0;
      }
#line 97
      if (ret == -1) {
#line 97
        goto case_neg_1;
      }
#line 100
      if (ret == -2) {
#line 100
        goto case_neg_2;
      }
#line 94
      goto switch_break;
      case_0: /* CIL Label */ 
#line 96
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 99
      goto __Cont;
      case_neg_2: /* CIL Label */ 
#line 101
      return;
      switch_break: /* CIL Label */ ;
      }
      {
#line 105
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 107
        ret = j_recognize_stream(recog);
        }
        {
#line 110
        if (ret == 1) {
#line 110
          goto case_1;
        }
#line 115
        if (ret == 0) {
#line 115
          goto case_0___0;
        }
#line 118
        if (ret == -1) {
#line 118
          goto case_neg_1___0;
        }
#line 109
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 114
        goto switch_break___0;
        case_0___0: /* CIL Label */ 
#line 117
        goto switch_break___0;
        case_neg_1___0: /* CIL Label */ 
#line 119
        return;
        switch_break___0: /* CIL Label */ ;
        }
#line 105
        if (! (ret == 1)) {
#line 105
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 124
      file_counter___0 ++;
    } else {
#line 128
      if (verbose_flag) {
        {
#line 128
        jlog((char *)"### read waveform input\n");
        }
      }
      {
#line 130
      ret = j_open_stream(recog, (char *)((void *)0));
      }
      {
#line 132
      if (ret == 0) {
#line 132
        goto case_0___1;
      }
#line 134
      if (ret == -1) {
#line 134
        goto case_neg_1___1;
      }
#line 137
      if (ret == -2) {
#line 137
        goto case_neg_2___0;
      }
#line 131
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 133
      goto switch_break___1;
      case_neg_1___1: /* CIL Label */ 
#line 136
      goto __Cont;
      case_neg_2___0: /* CIL Label */ 
#line 138
      if (jconf->input.speech_input == 0) {
        {
#line 139
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d files processed\n",
                file_counter___0);
        }
      } else
#line 140
      if (jconf->input.speech_input == 5) {
        {
#line 141
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"reached end of input on stdin\n");
        }
      } else {
        {
#line 143
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to begin input stream\n");
        }
      }
#line 145
      return;
      switch_break___1: /* CIL Label */ ;
      }
#line 147
      if (outfile_enabled) {
        {
#line 148
        tmp___1 = j_get_current_filename(recog);
#line 148
        outfile_set_fname(tmp___1);
        }
      }
      {
#line 151
      ret = j_recognize_stream(recog);
      }
#line 159
      if (ret == -1) {
#line 160
        return;
      }
#line 165
      if (jconf->input.speech_input == 0) {
#line 166
        file_counter___0 ++;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 294 "../libjulius/include/julius/extern.h"
extern int callback_add_adin(Recog *recog , int code , void (*func)(Recog *recog ,
                                                                    SP16 *buf , int len ,
                                                                    void *data ) ,
                             void *data ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/app.h"
void record_add_option(void) ;
#line 44
void record_setup(Recog *recog , void *data ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static char *record_dirname  =    (char *)((void *)0);
#line 47 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static char rectmpfilename[1024]  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static char recordfilename[1024]  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static int recordlen  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static FILE *recfile_fp  =    (FILE *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static boolean open_error  =    (boolean )0;
#line 67 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void timestring(char *t , int maxlen ) 
{ 
  time_t timep ;
  struct tm *lmtm ;

  {
  {
#line 73
  time(& timep);
#line 74
  lmtm = localtime((time_t const   *)(& timep));
#line 76
  snprintf((char */* __restrict  */)t, (size_t )maxlen, (char const   */* __restrict  */)"%04d.%02d%02d.%02d%02d%02d",
           1900 + lmtm->tm_year, 1 + lmtm->tm_mon, lmtm->tm_mday, lmtm->tm_hour, lmtm->tm_min,
           lmtm->tm_sec);
  }
#line 77
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void make_record_filename(char *buf___13 , int buflen , char *basename , char *dirname ) 
{ 


  {
#line 100
  if ((unsigned long )dirname == (unsigned long )((void *)0)) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no record directory specified??\n");
    }
#line 102
    return;
  }
  {
#line 104
  snprintf((char */* __restrict  */)buf___13, (size_t )buflen, (char const   */* __restrict  */)"%s/%s.wav",
           dirname, basename);
  }
#line 111
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void make_tmp_filename(char *buf___13 , int buflen , char *dirname ) 
{ 
  __pid_t tmp ;

  {
  {
#line 133
  tmp = getpid();
#line 133
  snprintf((char */* __restrict  */)buf___13, (size_t )buflen, (char const   */* __restrict  */)"%s/tmprecord.%d",
           dirname, tmp);
  }
#line 135
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void record_sample_open(Recog *recog , void *dummy ) 
{ 


  {
#line 150
  if ((unsigned long )recfile_fp != (unsigned long )((void *)0)) {
    {
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: record_sample_open: re-opened before closed!\n");
    }
#line 152
    return;
  }
  {
#line 155
  make_tmp_filename(rectmpfilename, 1024, record_dirname);
#line 156
  recfile_fp = wrwav_open(rectmpfilename, (int )(recog->jconf)->input.sfreq);
  }
#line 156
  if ((unsigned long )recfile_fp == (unsigned long )((void *)0)) {
    {
#line 157
    perror("Error: record_sample_open");
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open \"%s\" (temporary record file)\n",
            rectmpfilename);
#line 159
    open_error = (boolean )1;
    }
#line 160
    return;
  }
#line 163
  recordlen = 0;
#line 164
  return;
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static char tstr[20]  ;
#line 180 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void record_sample_write(Recog *recog , SP16 *speech___0 , int samplenum ,
                                void *dummy ) 
{ 
  boolean tmp ;

  {
#line 185
  if ((unsigned long )recfile_fp == (unsigned long )((void *)0)) {
#line 186
    if (! open_error) {
      {
#line 186
      record_sample_open(recog, dummy);
      }
    }
  }
  {
#line 189
  tmp = wrwav_data(recfile_fp, speech___0, samplenum);
  }
#line 189
  if ((int )tmp == 0) {
    {
#line 190
    perror("Error: record_sample_write");
#line 191
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to write samples to \"%s\"\n",
            rectmpfilename);
    }
#line 192
    return;
  }
#line 197
  if (recordlen == 0) {
    {
#line 198
    timestring(tstr, 18);
    }
  }
  {
#line 200
  make_record_filename(recordfilename, 1024, tstr, record_dirname);
#line 202
  recordlen += samplenum;
  }
#line 203
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static void record_sample_close(Recog *recog , void *dummy ) 
{ 
  boolean tmp ;
  int tmp___0 ;

  {
#line 219
  open_error = (boolean )0;
#line 220
  if ((unsigned long )recfile_fp == (unsigned long )((void *)0)) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: record_sample_close; file not opened yet!?\n");
    }
#line 222
    return;
  }
  {
#line 225
  tmp = wrwav_close(recfile_fp);
  }
#line 225
  if ((int )tmp == 0) {
    {
#line 226
    perror("Error: record_sample_close");
    }
  }
#line 228
  recfile_fp = (FILE *)((void *)0);
#line 230
  if (recordlen == 0) {
    {
#line 231
    unlink((char const   *)(rectmpfilename));
    }
#line 232
    if (verbose_flag) {
      {
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No input, not recorded\n");
      }
    }
#line 235
    return;
  }
  {
#line 239
  tmp___0 = rename((char const   *)(rectmpfilename), (char const   *)(recordfilename));
  }
#line 239
  if (tmp___0 < 0) {
    {
#line 240
    perror("Error: record_sample_close");
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to move %s to %s\n",
            rectmpfilename, recordfilename);
    }
#line 242
    return;
  }
#line 244
  if (verbose_flag) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recorded to \"%s\" (%d bytes, %.2f sec.)\n",
            recordfilename, (unsigned long )recordlen * sizeof(SP16 ), (double )((float )recordlen / (float )(recog->jconf)->input.sfreq));
    }
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
static boolean opt_record(Jconf *jconf , char **arg , int argnum ) 
{ 
  int tmp ;

  {
  {
#line 253
  record_dirname = strdup((char const   *)*(arg + 0));
#line 255
  tmp = access((char const   *)record_dirname, 7);
  }
#line 255
  if (tmp == -1) {
    {
#line 256
    perror("checkdir");
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: cannot write to dir %s\n",
            record_dirname);
    }
#line 258
    return ((boolean )0);
  }
#line 261
  return ((boolean )1);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
void record_add_option(void) 
{ 


  {
  {
#line 266
  j_add_option((char *)"-record", 1, 1, (char *)"record input waveform to file in dir",
               & opt_record);
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/record.c"
void record_setup(Recog *recog , void *data ) 
{ 


  {
#line 273
  if (record_dirname) {
    {
#line 275
    callback_add_adin(recog, 26, & record_sample_write, data);
#line 276
    callback_add(recog, 7, & record_sample_close, data);
#line 277
    printf((char const   */* __restrict  */)"Input speech data will be stored to = %s/\n",
           record_dirname);
    }
  }
#line 279
  return;
}
}
#line 514 "../libsent/include/sent/htk_hmm.h"
extern char *center_name(char *hmmname , char *buf ) ;
#line 51 "../libjulius/include/julius/global.h"
extern boolean debug2_flag ;
#line 221 "../libjulius/include/julius/extern.h"
extern void wordgraph_dump(FILE *fp , WordGraph *root , WORD_INFO *winfo ) ;
#line 257
extern int multigram_get_all_num(PROCESS_LM *lm ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.h"
char *charconv(char *instr , char *outstr , int maxoutlen ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/app.h"
void print_all_gram(Recog *recog ) ;
#line 36
void setup_output_tty(Recog *recog , void *data ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
boolean separate_score_flag ;
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static boolean have_progout  =    (boolean )0;
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static WORD_ID confword[150]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static int confwordnum  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static char inbuf[4096]  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static char outbuf[4096]  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
void myprintf(char *fmt  , ...) 
{ 
  va_list ap ;
  int ret ;
  char *tmp ;

  {
  {
#line 45
  __builtin_va_start(ap, fmt);
#line 46
  ret = vsnprintf((char */* __restrict  */)(inbuf), (size_t )4096, (char const   */* __restrict  */)fmt,
                  ap);
#line 47
  __builtin_va_end(ap);
  }
#line 48
  if (ret > 0) {
    {
#line 49
    tmp = charconv(inbuf, outbuf, 4096);
#line 49
    printf((char const   */* __restrict  */)"%s", tmp);
    }
  }
#line 51
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_process_online(Recog *recog , void *dummy ) 
{ 


  {
#line 88
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_process_offline(Recog *recog , void *dummy ) 
{ 


  {
#line 104
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_recready(Recog *recog , void *dummy ) 
{ 


  {
#line 122
  if ((recog->jconf)->input.speech_input == 1) {
#line 122
    goto _L;
  } else
#line 122
  if ((recog->jconf)->input.speech_input == 4) {
    _L: /* CIL Label */ 
#line 123
    if (! recog->process_segment) {
      {
#line 124
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<<< please speak >>>");
      }
    }
  }
#line 127
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_recstart(Recog *recog , void *dummy ) 
{ 


  {
#line 141
  if ((recog->jconf)->input.speech_input == 1) {
#line 141
    goto _L;
  } else
#line 141
  if ((recog->jconf)->input.speech_input == 4) {
    _L: /* CIL Label */ 
#line 142
    if (! recog->process_segment) {
      {
#line 143
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\r                    \r");
      }
    }
  }
#line 146
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_recend(Recog *recog , void *dummy ) 
{ 


  {
#line 161
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_param(Recog *recog , void *dummy ) 
{ 


  {
#line 180
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_recognition_begin(Recog *recog , void *dummy ) 
{ 


  {
#line 201
  if ((recog->jconf)->decodeopt.segment) {
#line 202
    if (have_progout) {
#line 203
      confwordnum = 0;
    }
  }
#line 206
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_recognition_end(Recog *recog , void *dummy ) 
{ 


  {
#line 223
  if (recog->process_segment) {
#line 224
    if (verbose_flag) {
      {
#line 225
      printf((char const   */* __restrict  */)"Segmented by short pause, continue to next...\n");
      }
    }
  }
#line 230
  if ((recog->jconf)->decodeopt.segment) {
#line 231
    if (have_progout) {
#line 232
      if (confwordnum > 0) {
        {
#line 233
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
  }
#line 237
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_segment_begin(Recog *recog , void *dummy ) 
{ 


  {
#line 253
  return;
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_segment_end(Recog *recog , void *dummy ) 
{ 


  {
#line 269
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static int wst  ;
#line 275 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static int writelen  ;
#line 288 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_pass1_begin(Recog *recog , void *dummy ) 
{ 


  {
#line 291
  if (! (recog->jconf)->decodeopt.realtime_flag) {
#line 292
    if (verbose_flag) {
      {
#line 292
      jlog((char *)"### Recognition: 1st pass (LR beam)\n");
      }
    }
  }
#line 295
  wst = 0;
#line 297
  if ((recog->jconf)->decodeopt.segment) {
#line 298
    if (have_progout) {
#line 299
      writelen = 0;
    }
  }
#line 303
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_pass1_current(Recog *recog , void *dummy ) 
{ 
  int i ;
  int j ;
  int bgn ;
  int len ;
  int num ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  RecogProcess *r ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 337
  r = recog->process_list;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! r) {
#line 337
      goto while_break;
    }
#line 338
    if (! r->live) {
#line 338
      goto __Cont;
    }
#line 339
    if (! r->have_interim) {
#line 339
      goto __Cont;
    }
    {
#line 341
    winfo___0 = (r->lm)->winfo;
#line 342
    seq = r->result.pass1.word;
#line 343
    num = r->result.pass1.word_num;
#line 346
    printf((char const   */* __restrict  */)"\r");
    }
#line 348
    if ((r->config)->successive.enabled) {
#line 350
      if (have_progout) {
#line 354
        len = 0;
#line 355
        i = 0;
        {
#line 355
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 355
          if (! (i < confwordnum)) {
#line 355
            goto while_break___0;
          }
          {
#line 356
          tmp = strlen((char const   *)*(winfo___0->woutput + confword[i]));
          }
#line 356
          if ((size_t )len + tmp > 72UL) {
#line 357
            j = len;
            {
#line 357
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 357
              if (! (j < writelen)) {
#line 357
                goto while_break___1;
              }
              {
#line 357
              printf((char const   */* __restrict  */)" ");
#line 357
              j ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 358
            printf((char const   */* __restrict  */)"\n");
#line 359
            j = i;
            }
            {
#line 359
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 359
              if (! (j < confwordnum)) {
#line 359
                goto while_break___2;
              }
#line 359
              confword[j - i] = confword[j];
#line 359
              j ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 360
            confwordnum -= i;
#line 361
            len = 0;
#line 362
            i = 0;
#line 363
            writelen = 0;
          }
          {
#line 365
          myprintf((char *)"%s", *(winfo___0->woutput + confword[i]));
#line 366
          tmp___0 = strlen((char const   *)*(winfo___0->woutput + confword[i]));
#line 366
          len = (int )((size_t )len + tmp___0);
#line 355
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 370
        if (! r->pass1.first_sparea) {
          {
#line 371
          printf((char const   */* __restrict  */)"|");
#line 372
          len ++;
          }
#line 374
          if ((int )confword[confwordnum - 1] == (int )*(seq + 0)) {
#line 375
            bgn = 1;
          } else {
#line 377
            bgn = 0;
          }
#line 380
          i = bgn;
          {
#line 380
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 380
            if (! (i < num)) {
#line 380
              goto while_break___3;
            }
            {
#line 381
            tmp___2 = strlen((char const   *)*(winfo___0->woutput + *(seq + i)));
            }
#line 381
            if ((size_t )len + tmp___2 > 76UL) {
#line 382
              if (i < num - 1) {
#line 382
                goto __Cont___0;
              }
              {
#line 383
              myprintf((char *)"*");
#line 384
              len ++;
              }
            } else {
              {
#line 386
              myprintf((char *)"%s", *(winfo___0->woutput + *(seq + i)));
#line 387
              tmp___1 = strlen((char const   *)*(winfo___0->woutput + *(seq + i)));
#line 387
              len = (int )((size_t )len + tmp___1);
              }
            }
            __Cont___0: /* CIL Label */ 
#line 380
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 390
          printf((char const   */* __restrict  */)"|");
#line 391
          len ++;
          }
        }
        {
#line 394
        fflush(stdout);
        }
#line 396
        if (writelen < len) {
#line 396
          writelen = len;
        }
#line 398
        return;
      }
    }
#line 402
    len = 0;
#line 403
    if (wst == 0) {
      {
#line 404
      len += 11;
#line 405
      printf((char const   */* __restrict  */)"pass1_best:");
      }
    }
#line 408
    bgn = wst;
#line 409
    i = bgn;
    {
#line 409
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 409
      if (! (i < num)) {
#line 409
        goto while_break___4;
      }
      {
#line 410
      tmp___3 = strlen((char const   *)*(winfo___0->woutput + *(seq + i)));
#line 410
      len = (int )((size_t )len + (tmp___3 + 1UL));
      }
#line 411
      if (len > 70) {
        {
#line 412
        wst = i;
#line 413
        printf((char const   */* __restrict  */)"\n");
#line 414
        len = 0;
        }
      }
      {
#line 416
      myprintf((char *)" %s", *(winfo___0->woutput + *(seq + i)));
#line 409
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 418
    if (writelen < len) {
#line 418
      writelen = len;
    }
    __Cont: /* CIL Label */ 
#line 337
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  fflush(stdout);
  }
#line 423
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static char buf___1[256]  ;
#line 449 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_pass1(Recog *recog , void *dummy ) 
{ 
  int i ;
  int j ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  int num ;
  RecogProcess *r ;
  boolean multi ;
  int len ;
  size_t tmp ;

  {
#line 461
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 461
    multi = (boolean )1;
  } else {
#line 462
    multi = (boolean )0;
  }
#line 464
  r = recog->process_list;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! r) {
#line 464
      goto while_break;
    }
#line 465
    if (! r->live) {
#line 465
      goto __Cont;
    }
#line 466
    if (r->result.status < 0) {
#line 466
      goto __Cont;
    }
#line 467
    if (have_progout) {
#line 467
      if ((r->config)->successive.enabled) {
#line 467
        goto __Cont;
      }
    }
#line 468
    if ((r->config)->output.progout_flag) {
      {
#line 468
      printf((char const   */* __restrict  */)"\r");
      }
    }
#line 470
    winfo___0 = (r->lm)->winfo;
#line 471
    seq = r->result.pass1.word;
#line 472
    num = r->result.pass1.word_num;
#line 475
    if (multi) {
      {
#line 475
      printf((char const   */* __restrict  */)"[#%d %s]\n", (int )(r->config)->id,
             (r->config)->name);
      }
    }
    {
#line 476
    printf((char const   */* __restrict  */)"pass1_best:");
    }
#line 477
    if ((r->config)->output.progout_flag) {
#line 478
      len = 0;
#line 479
      i = 0;
      {
#line 479
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 479
        if (! (i < num)) {
#line 479
          goto while_break___0;
        }
        {
#line 480
        tmp = strlen((char const   *)*(winfo___0->woutput + *(seq + i)));
#line 480
        len = (int )((size_t )len + (tmp + 1UL));
#line 481
        myprintf((char *)" %s", *(winfo___0->woutput + *(seq + i)));
#line 479
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 483
      j = len;
      {
#line 483
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 483
        if (! (j < writelen)) {
#line 483
          goto while_break___1;
        }
        {
#line 483
        printf((char const   */* __restrict  */)" ");
#line 483
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 485
      i = 0;
      {
#line 485
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 485
        if (! (i < num)) {
#line 485
          goto while_break___2;
        }
        {
#line 486
        myprintf((char *)" %s", *(winfo___0->woutput + *(seq + i)));
#line 485
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 489
    printf((char const   */* __restrict  */)"\n");
    }
#line 491
    if (verbose_flag) {
      {
#line 493
      printf((char const   */* __restrict  */)"pass1_best_wordseq:");
#line 494
      i = 0;
      }
      {
#line 494
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 494
        if (! (i < num)) {
#line 494
          goto while_break___3;
        }
        {
#line 495
        myprintf((char *)" %s", *(winfo___0->wname + *(seq + i)));
#line 494
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 497
      printf((char const   */* __restrict  */)"\n");
#line 499
      printf((char const   */* __restrict  */)"pass1_best_phonemeseq:");
#line 500
      i = 0;
      }
      {
#line 500
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 500
        if (! (i < num)) {
#line 500
          goto while_break___4;
        }
#line 501
        j = 0;
        {
#line 501
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 501
          if (! (j < (int )*(winfo___0->wlen + *(seq + i)))) {
#line 501
            goto while_break___5;
          }
          {
#line 502
          center_name((*(*(winfo___0->wseq + *(seq + i)) + j))->name, buf___1);
#line 503
          myprintf((char *)" %s", buf___1);
#line 501
          j ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 505
        if (i < num - 1) {
          {
#line 505
          printf((char const   */* __restrict  */)" |");
          }
        }
#line 500
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 507
      printf((char const   */* __restrict  */)"\n");
      }
#line 508
      if (debug2_flag) {
        {
#line 510
        printf((char const   */* __restrict  */)"pass1_best_HMMseq_logical:");
#line 511
        i = 0;
        }
        {
#line 511
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 511
          if (! (i < num)) {
#line 511
            goto while_break___6;
          }
#line 512
          j = 0;
          {
#line 512
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 512
            if (! (j < (int )*(winfo___0->wlen + *(seq + i)))) {
#line 512
              goto while_break___7;
            }
            {
#line 513
            myprintf((char *)" %s", (*(*(winfo___0->wseq + *(seq + i)) + j))->name);
#line 512
            j ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 515
          if (i < num - 1) {
            {
#line 515
            printf((char const   */* __restrict  */)" |");
            }
          }
#line 511
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 517
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 520
      printf((char const   */* __restrict  */)"pass1_best_score: %f", (double )r->result.pass1.score);
      }
#line 521
      if (r->lmtype == 1) {
#line 522
        if (separate_score_flag) {
          {
#line 523
          printf((char const   */* __restrict  */)" (AM: %f  LM: %f)", (double )r->result.pass1.score_am,
                 (double )r->result.pass1.score_lm);
          }
        }
      }
      {
#line 528
      printf((char const   */* __restrict  */)"\n");
      }
    }
    __Cont: /* CIL Label */ 
#line 464
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return;
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_pass1_end(Recog *recog , void *dummy ) 
{ 


  {
#line 589
  if ((recog->jconf)->decodeopt.segment) {
#line 590
    if (have_progout) {
#line 590
      return;
    }
  }
#line 594
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void put_hypo_woutput(WORD_ID *seq , int n , WORD_INFO *winfo___0 ) 
{ 
  int i ;

  {
#line 618
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
#line 619
    i = 0;
    {
#line 619
    while (1) {
      while_continue: /* CIL Label */ ;
#line 619
      if (! (i < n)) {
#line 619
        goto while_break;
      }
      {
#line 620
      myprintf((char *)" %s", *(winfo___0->woutput + *(seq + i)));
#line 619
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 623
  printf((char const   */* __restrict  */)"\n");
  }
#line 624
  return;
}
}
#line 640 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void put_hypo_wname(WORD_ID *seq , int n , WORD_INFO *winfo___0 ) 
{ 
  int i ;

  {
#line 645
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
#line 646
    i = 0;
    {
#line 646
    while (1) {
      while_continue: /* CIL Label */ ;
#line 646
      if (! (i < n)) {
#line 646
        goto while_break;
      }
      {
#line 647
      myprintf((char *)" %s", *(winfo___0->wname + *(seq + i)));
#line 646
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 650
  printf((char const   */* __restrict  */)"\n");
  }
#line 651
  return;
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static char buf___2[256]  ;
#line 667 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void put_hypo_phoneme(WORD_ID *seq , int n , WORD_INFO *winfo___0 ) 
{ 
  int i ;
  int j ;
  WORD_ID w ;

  {
#line 674
  if ((unsigned long )seq != (unsigned long )((void *)0)) {
#line 675
    i = 0;
    {
#line 675
    while (1) {
      while_continue: /* CIL Label */ ;
#line 675
      if (! (i < n)) {
#line 675
        goto while_break;
      }
#line 676
      if (i > 0) {
        {
#line 676
        printf((char const   */* __restrict  */)" |");
        }
      }
#line 677
      w = *(seq + i);
#line 678
      j = 0;
      {
#line 678
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 678
        if (! (j < (int )*(winfo___0->wlen + w))) {
#line 678
          goto while_break___0;
        }
        {
#line 679
        center_name((*(*(winfo___0->wseq + w) + j))->name, buf___2);
#line 680
        myprintf((char *)" %s", buf___2);
#line 678
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 675
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 684
  printf((char const   */* __restrict  */)"\n");
  }
#line 685
  return;
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void put_hypo_cmscore(LOGPROB *cmscore , int n ) 
{ 
  int i ;

  {
#line 719
  if ((unsigned long )cmscore != (unsigned long )((void *)0)) {
#line 720
    i = 0;
    {
#line 720
    while (1) {
      while_continue: /* CIL Label */ ;
#line 720
      if (! (i < n)) {
#line 720
        goto while_break;
      }
      {
#line 721
      printf((char const   */* __restrict  */)" %5.3f", (double )*(cmscore + i));
#line 720
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 724
  printf((char const   */* __restrict  */)"\n");
  }
#line 725
  return;
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_pass2(Recog *recog , void *dummy ) 
{ 
  int i ;
  int j ;
  int len ;
  char ec[5] ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  int seqnum ;
  int n ;
  int num ;
  Sentence *s ;
  RecogProcess *r ;
  boolean multi ;
  HMM_Logical *p___0 ;
  SentenceAlign *align ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 751
  ec[0] = (char)27;
#line 751
  ec[1] = (char )'[';
#line 751
  ec[2] = (char )'1';
#line 751
  ec[3] = (char )'m';
#line 751
  ec[4] = (char)0;
#line 762
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 762
    multi = (boolean )1;
  } else {
#line 763
    multi = (boolean )0;
  }
#line 765
  r = recog->process_list;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! r) {
#line 765
      goto while_break;
    }
#line 766
    if (! r->live) {
#line 766
      goto __Cont;
    }
#line 767
    if (multi) {
      {
#line 767
      printf((char const   */* __restrict  */)"[#%d %s]\n", (int )(r->config)->id,
             (r->config)->name);
      }
    }
#line 769
    if ((r->config)->successive.enabled) {
#line 770
      if (r->result.status < 0) {
#line 770
        if ((r->config)->output.progout_flag) {
          {
#line 773
          printf((char const   */* __restrict  */)"\r");
#line 774
          winfo___0 = (r->lm)->winfo;
          }
#line 776
          if (r->result.status == -1) {
#line 779
            seq = r->result.pass1.word;
#line 780
            seqnum = r->result.pass1.word_num;
#line 781
            j = 0;
#line 783
            if ((int )confword[confwordnum - 1] == (int )*(seq + 0)) {
#line 783
              j ++;
            }
#line 786
            i = j;
            {
#line 786
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 786
              if (! (i < seqnum)) {
#line 786
                goto while_break___0;
              }
#line 787
              tmp = confwordnum;
#line 787
              confwordnum ++;
#line 787
              confword[tmp] = *(seq + i);
#line 786
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 791
          len = 0;
#line 793
          i = 0;
          {
#line 793
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 793
            if (! (i < confwordnum)) {
#line 793
              goto while_break___1;
            }
            {
#line 794
            tmp___0 = strlen((char const   *)*(winfo___0->woutput + confword[i]));
            }
#line 794
            if ((size_t )len + tmp___0 > 72UL) {
#line 795
              j = len;
              {
#line 795
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 795
                if (! (j < writelen)) {
#line 795
                  goto while_break___2;
                }
                {
#line 795
                printf((char const   */* __restrict  */)" ");
#line 795
                j ++;
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 796
              printf((char const   */* __restrict  */)"\n");
#line 797
              j = i;
              }
              {
#line 797
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 797
                if (! (j < confwordnum)) {
#line 797
                  goto while_break___3;
                }
#line 797
                confword[j - i] = confword[j];
#line 797
                j ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 798
              confwordnum -= i;
#line 799
              len = 0;
#line 800
              i = 0;
#line 801
              writelen = 0;
            }
            {
#line 803
            myprintf((char *)"%s", *(winfo___0->woutput + confword[i]));
#line 804
            tmp___1 = strlen((char const   *)*(winfo___0->woutput + confword[i]));
#line 804
            len = (int )((size_t )len + tmp___1);
#line 793
            i ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 806
          i = len;
          {
#line 806
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 806
            if (! (i < writelen)) {
#line 806
              goto while_break___4;
            }
            {
#line 806
            printf((char const   */* __restrict  */)" ");
#line 806
            i ++;
            }
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 807
          fflush(stdout);
          }
#line 809
          goto __Cont;
        }
      }
    }
#line 813
    if (r->result.status < 0) {
      {
#line 815
      if (r->result.status == -6) {
#line 815
        goto case_neg_6;
      }
#line 818
      if (r->result.status == -5) {
#line 818
        goto case_neg_5;
      }
#line 821
      if (r->result.status == -4) {
#line 821
        goto case_neg_4;
      }
#line 824
      if (r->result.status == -3) {
#line 824
        goto case_neg_3;
      }
#line 827
      if (r->result.status == -2) {
#line 827
        goto case_neg_2;
      }
#line 830
      if (r->result.status == -1) {
#line 830
        goto case_neg_1;
      }
#line 814
      goto switch_break;
      case_neg_6: /* CIL Label */ 
      {
#line 816
      printf((char const   */* __restrict  */)"<input rejected by power>\n");
      }
#line 817
      goto switch_break;
      case_neg_5: /* CIL Label */ 
      {
#line 819
      printf((char const   */* __restrict  */)"<input teminated by request>\n");
      }
#line 820
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 822
      printf((char const   */* __restrict  */)"<input rejected by decoder (silence input result)>\n");
      }
#line 823
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 825
      printf((char const   */* __restrict  */)"<input rejected by GMM>\n");
      }
#line 826
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 828
      printf((char const   */* __restrict  */)"<input rejected by short input>\n");
      }
#line 829
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 831
      printf((char const   */* __restrict  */)"<search failed>\n");
      }
#line 832
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 834
      goto __Cont;
    }
#line 837
    winfo___0 = (r->lm)->winfo;
#line 838
    num = r->result.sentnum;
#line 840
    n = 0;
    {
#line 840
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 840
      if (! (n < num)) {
#line 840
        goto while_break___5;
      }
#line 841
      s = r->result.sent + n;
#line 842
      seq = s->word;
#line 843
      seqnum = s->word_num;
#line 845
      if ((r->config)->successive.enabled) {
#line 846
        if ((r->config)->output.progout_flag) {
          {
#line 847
          printf((char const   */* __restrict  */)"\r");
#line 849
          j = 0;
          }
#line 851
          if ((int )confword[confwordnum - 1] == (int )*(seq + 0)) {
#line 851
            j ++;
          }
#line 852
          i = j;
          {
#line 852
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 852
            if (! (i < seqnum)) {
#line 852
              goto while_break___6;
            }
#line 853
            tmp___2 = confwordnum;
#line 853
            confwordnum ++;
#line 853
            confword[tmp___2] = *(seq + i);
#line 852
            i ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 857
          len = 0;
#line 858
          i = 0;
          {
#line 858
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 858
            if (! (i < confwordnum)) {
#line 858
              goto while_break___7;
            }
            {
#line 859
            tmp___3 = strlen((char const   *)*(winfo___0->woutput + confword[i]));
            }
#line 859
            if ((size_t )len + tmp___3 > 72UL) {
#line 860
              j = len;
              {
#line 860
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 860
                if (! (j < writelen)) {
#line 860
                  goto while_break___8;
                }
                {
#line 860
                printf((char const   */* __restrict  */)" ");
#line 860
                j ++;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
              {
#line 861
              printf((char const   */* __restrict  */)"\n");
#line 862
              j = i;
              }
              {
#line 862
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 862
                if (! (j < confwordnum)) {
#line 862
                  goto while_break___9;
                }
#line 862
                confword[j - i] = confword[j];
#line 862
                j ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 863
              confwordnum -= i;
#line 864
              len = 0;
#line 865
              i = 0;
#line 866
              writelen = 0;
            }
            {
#line 868
            myprintf((char *)"%s", *(winfo___0->woutput + confword[i]));
#line 869
            tmp___4 = strlen((char const   *)*(winfo___0->woutput + confword[i]));
#line 869
            len = (int )((size_t )len + tmp___4);
#line 858
            i ++;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 871
          i = len;
          {
#line 871
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 871
            if (! (i < writelen)) {
#line 871
              goto while_break___10;
            }
            {
#line 871
            printf((char const   */* __restrict  */)" ");
#line 871
            i ++;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
#line 873
          goto while_break___5;
        }
      }
#line 877
      if (debug2_flag) {
        {
#line 878
        printf((char const   */* __restrict  */)"\n%s", ec);
        }
      }
      {
#line 880
      printf((char const   */* __restrict  */)"sentence%d:", n + 1);
#line 881
      put_hypo_woutput(seq, seqnum, winfo___0);
      }
#line 882
      if (verbose_flag) {
        {
#line 883
        printf((char const   */* __restrict  */)"wseq%d:", n + 1);
#line 884
        put_hypo_wname(seq, seqnum, winfo___0);
#line 885
        printf((char const   */* __restrict  */)"phseq%d:", n + 1);
#line 886
        put_hypo_phoneme(seq, seqnum, winfo___0);
#line 897
        printf((char const   */* __restrict  */)"cmscore%d:", n + 1);
#line 898
        put_hypo_cmscore(s->confidence, seqnum);
        }
      }
#line 902
      if (debug2_flag) {
        {
#line 903
        ec[2] = (char )'0';
#line 904
        printf((char const   */* __restrict  */)"%s\n", ec);
        }
      }
#line 906
      if (verbose_flag) {
        {
#line 907
        printf((char const   */* __restrict  */)"score%d: %f", n + 1, (double )s->score);
        }
#line 908
        if (r->lmtype == 1) {
#line 909
          if (separate_score_flag) {
            {
#line 910
            printf((char const   */* __restrict  */)" (AM: %f  LM: %f)", (double )s->score_am,
                   (double )s->score_lm);
            }
          }
        }
        {
#line 913
        printf((char const   */* __restrict  */)"\n");
        }
#line 914
        if (r->lmtype == 2) {
          {
#line 917
          tmp___5 = multigram_get_all_num(r->lm);
          }
#line 917
          if (tmp___5 > 1) {
            {
#line 918
            printf((char const   */* __restrict  */)"grammar%d: %d\n", n + 1, s->gram_id);
            }
          }
        }
      }
#line 924
      align = s->align;
      {
#line 924
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 924
        if (! align) {
#line 924
          goto while_break___11;
        }
        {
#line 925
        printf((char const   */* __restrict  */)"=== begin forced alignment ===\n");
        }
        {
#line 927
        if ((int )align->unittype == 0) {
#line 927
          goto case_0;
        }
#line 929
        if ((int )align->unittype == 1) {
#line 929
          goto case_1;
        }
#line 931
        if ((int )align->unittype == 2) {
#line 931
          goto case_2;
        }
#line 926
        goto switch_break___0;
        case_0: /* CIL Label */ 
        {
#line 928
        printf((char const   */* __restrict  */)"-- word alignment --\n");
        }
#line 928
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 930
        printf((char const   */* __restrict  */)"-- phoneme alignment --\n");
        }
#line 930
        goto switch_break___0;
        case_2: /* CIL Label */ 
        {
#line 932
        printf((char const   */* __restrict  */)"-- state alignment --\n");
        }
#line 932
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 934
        printf((char const   */* __restrict  */)" id: from  to    n_score    unit\n");
#line 935
        printf((char const   */* __restrict  */)" ----------------------------------------\n");
#line 936
        i = 0;
        }
        {
#line 936
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 936
          if (! (i < align->num)) {
#line 936
            goto while_break___12;
          }
          {
#line 937
          printf((char const   */* __restrict  */)"[%4d %4d]  %f  ", *(align->begin_frame + i),
                 *(align->end_frame + i), (double )*(align->avgscore + i));
          }
          {
#line 939
          if ((int )align->unittype == 0) {
#line 939
            goto case_0___0;
          }
#line 942
          if ((int )align->unittype == 1) {
#line 942
            goto case_1___0;
          }
#line 952
          if ((int )align->unittype == 2) {
#line 952
            goto case_2___0;
          }
#line 938
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
          {
#line 940
          myprintf((char *)"%s\t[%s]\n", *(winfo___0->wname + *(align->w + i)), *(winfo___0->woutput + *(align->w + i)));
          }
#line 941
          goto switch_break___1;
          case_1___0: /* CIL Label */ 
#line 943
          p___0 = *(align->ph + i);
#line 944
          if (p___0->is_pseudo) {
            {
#line 945
            printf((char const   */* __restrict  */)"{%s}\n", p___0->name);
            }
          } else {
            {
#line 946
            tmp___6 = strcmp((char const   *)p___0->name, (char const   *)(p___0->body.defined)->name);
            }
#line 946
            if (tmp___6) {
              {
#line 949
              printf((char const   */* __restrict  */)"%s[%s]\n", p___0->name, (p___0->body.defined)->name);
              }
            } else {
              {
#line 947
              printf((char const   */* __restrict  */)"%s\n", p___0->name);
              }
            }
          }
#line 951
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 953
          p___0 = *(align->ph + i);
#line 954
          if (p___0->is_pseudo) {
            {
#line 955
            printf((char const   */* __restrict  */)"{%s}", p___0->name);
            }
          } else {
            {
#line 956
            tmp___7 = strcmp((char const   *)p___0->name, (char const   *)(p___0->body.defined)->name);
            }
#line 956
            if (tmp___7) {
              {
#line 959
              printf((char const   */* __restrict  */)"%s[%s]", p___0->name, (p___0->body.defined)->name);
              }
            } else {
              {
#line 957
              printf((char const   */* __restrict  */)"%s", p___0->name);
              }
            }
          }
#line 961
          if (((r->am)->hmminfo)->multipath) {
#line 962
            if (*(align->is_iwsp + i)) {
              {
#line 963
              printf((char const   */* __restrict  */)" #%d (sp)\n", (int )*(align->loc + i));
              }
            } else {
              {
#line 965
              printf((char const   */* __restrict  */)" #%d\n", (int )*(align->loc + i));
              }
            }
          } else {
            {
#line 968
            printf((char const   */* __restrict  */)" #%d\n", (int )*(align->loc + i));
            }
          }
#line 970
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 936
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 974
        printf((char const   */* __restrict  */)"re-computed AM score: %f\n", (double )align->allscore);
#line 976
        printf((char const   */* __restrict  */)"=== end forced alignment ===\n");
#line 924
        align = align->next;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 840
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 765
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  fflush(stdout);
  }
#line 983
  return;
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_pass2_begin(Recog *recog , void *dummy ) 
{ 


  {
#line 1000
  if (verbose_flag) {
    {
#line 1000
    jlog((char *)"### Recognition: 2nd pass (RL heuristic best-first)\n");
    }
  }
#line 1003
  return;
}
}
#line 1015 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void status_pass2_end(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 1018
  fflush(stdout);
  }
#line 1019
  return;
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_graph(Recog *recog , void *dummy ) 
{ 
  WordGraph *wg ;
  int tw1 ;
  int tw2 ;
  int i ;
  WORD_INFO *winfo___0 ;
  RecogProcess *r ;
  boolean multi ;

  {
#line 1049
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 1049
    multi = (boolean )1;
  } else {
#line 1050
    multi = (boolean )0;
  }
#line 1052
  r = recog->process_list;
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    if (! r) {
#line 1052
      goto while_break;
    }
#line 1053
    if (! r->live) {
#line 1053
      goto __Cont;
    }
#line 1054
    if ((unsigned long )r->result.wg == (unsigned long )((void *)0)) {
#line 1054
      goto __Cont;
    }
#line 1055
    if (multi) {
      {
#line 1055
      printf((char const   */* __restrict  */)"[#%d %s]\n", (int )(r->config)->id,
             (r->config)->name);
      }
    }
    {
#line 1057
    winfo___0 = (r->lm)->winfo;
#line 1060
    wordgraph_dump(stdout, r->result.wg, winfo___0);
#line 1062
    printf((char const   */* __restrict  */)"-------------------------- begin wordgraph show -------------------------\n");
#line 1063
    wg = r->result.wg;
    }
    {
#line 1063
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1063
      if (! wg) {
#line 1063
        goto while_break___0;
      }
      {
#line 1064
      tw1 = (70 * wg->lefttime) / r->peseqlen;
#line 1065
      tw2 = (70 * wg->righttime) / r->peseqlen;
#line 1066
      printf((char const   */* __restrict  */)"%4d:", wg->id);
#line 1067
      i = 0;
      }
      {
#line 1067
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1067
        if (! (i < tw1)) {
#line 1067
          goto while_break___1;
        }
        {
#line 1067
        printf((char const   */* __restrict  */)" ");
#line 1067
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1068
      myprintf((char *)" %s\n", *(winfo___0->woutput + wg->wid));
#line 1069
      printf((char const   */* __restrict  */)"%4d:", wg->lefttime);
#line 1070
      i = 0;
      }
      {
#line 1070
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1070
        if (! (i < tw1)) {
#line 1070
          goto while_break___2;
        }
        {
#line 1070
        printf((char const   */* __restrict  */)" ");
#line 1070
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1071
      printf((char const   */* __restrict  */)"|");
#line 1072
      i = tw1 + 1;
      }
      {
#line 1072
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1072
        if (! (i < tw2)) {
#line 1072
          goto while_break___3;
        }
        {
#line 1072
        printf((char const   */* __restrict  */)"-");
#line 1072
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1073
      printf((char const   */* __restrict  */)"|\n");
#line 1063
      wg = wg->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1075
    printf((char const   */* __restrict  */)"-------------------------- end wordgraph show ---------------------------\n");
    }
    __Cont: /* CIL Label */ 
#line 1052
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  return;
}
}
#line 1089 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_confnet(Recog *recog , void *dummy ) 
{ 
  CN_CLUSTER *c ;
  int i ;
  RecogProcess *r ;
  boolean multi ;
  char const   *tmp ;

  {
#line 1097
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 1097
    multi = (boolean )1;
  } else {
#line 1098
    multi = (boolean )0;
  }
#line 1100
  r = recog->process_list;
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (! r) {
#line 1100
      goto while_break;
    }
#line 1101
    if (! r->live) {
#line 1101
      goto __Cont;
    }
#line 1102
    if ((unsigned long )r->result.confnet == (unsigned long )((void *)0)) {
#line 1102
      goto __Cont;
    }
#line 1103
    if (multi) {
      {
#line 1103
      printf((char const   */* __restrict  */)"[#%d %s]\n", (int )(r->config)->id,
             (r->config)->name);
      }
    }
    {
#line 1105
    printf((char const   */* __restrict  */)"---- begin confusion network ---\n");
#line 1106
    c = r->result.confnet;
    }
    {
#line 1106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1106
      if (! c) {
#line 1106
        goto while_break___0;
      }
#line 1107
      i = 0;
      {
#line 1107
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1107
        if (! (i < c->wordsnum)) {
#line 1107
          goto while_break___1;
        }
#line 1108
        if ((int )*(c->words + i) == 65535) {
#line 1108
          tmp = "-";
        } else {
#line 1108
          tmp = (char const   *)*(((r->lm)->winfo)->woutput + *(c->words + i));
        }
        {
#line 1108
        myprintf((char *)"(%s:%.3f)", tmp, (double )*(c->pp + i));
        }
#line 1109
        if (i == 0) {
          {
#line 1109
          printf((char const   */* __restrict  */)"  ");
          }
        }
#line 1107
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1111
      printf((char const   */* __restrict  */)"\n");
#line 1106
      c = c->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1120
    printf((char const   */* __restrict  */)"---- end confusion network ---\n");
    }
    __Cont: /* CIL Label */ 
#line 1100
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1122
  return;
}
}
#line 1134 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void result_gmm(Recog *recog , void *dummy ) 
{ 
  HTK_HMM_Data *d ;
  GMMCalc *gc ;
  int i ;

  {
#line 1141
  gc = recog->gc;
#line 1143
  if (debug2_flag) {
    {
#line 1144
    printf((char const   */* __restrict  */)"--- GMM result begin ---\n");
#line 1145
    i = 0;
#line 1146
    d = (recog->gmm)->start;
    }
    {
#line 1146
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1146
      if (! d) {
#line 1146
        goto while_break;
      }
      {
#line 1147
      myprintf((char *)"  [%8s: total=%f avg=%f]\n", d->name, (double )*(gc->gmm_score + i),
               (double )(*(gc->gmm_score + i) / (float )gc->framecount));
#line 1148
      i ++;
#line 1146
      d = d->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1150
    myprintf((char *)"  max = \"%s\"", (gc->max_d)->name);
#line 1152
    printf((char const   */* __restrict  */)" (CM: %f)", (double )gc->gmm_max_cm);
#line 1154
    printf((char const   */* __restrict  */)"\n");
#line 1155
    printf((char const   */* __restrict  */)"--- GMM result end ---\n");
    }
  } else
#line 1156
  if (verbose_flag) {
    {
#line 1157
    myprintf((char *)"GMM: max = \"%s\"", (gc->max_d)->name);
#line 1159
    printf((char const   */* __restrict  */)" (CM: %f)", (double )gc->gmm_max_cm);
#line 1161
    printf((char const   */* __restrict  */)"\n");
    }
  } else
#line 1163
  if ((recog->jconf)->decodeopt.segment) {
#line 1164
    if (! have_progout) {
      {
#line 1165
      myprintf((char *)"[GMM: %s]\n", (gc->max_d)->name);
      }
    }
  } else {
    {
#line 1168
    myprintf((char *)"[GMM: %s]\n", (gc->max_d)->name);
    }
  }
#line 1171
  return;
}
}
#line 1183 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
void print_all_gram(Recog *recog ) 
{ 
  MULTIGRAM *m ;
  RecogProcess *r ;
  boolean multi ;
  char buf___13[1024] ;
  char const   *tmp ;

  {
#line 1191
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 1191
    multi = (boolean )1;
  } else {
#line 1192
    multi = (boolean )0;
  }
#line 1194
  r = recog->process_list;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! r) {
#line 1194
      goto while_break;
    }
#line 1195
    if (! r->live) {
#line 1195
      goto __Cont;
    }
#line 1196
    if (multi) {
      {
#line 1196
      printf((char const   */* __restrict  */)"[#%d %s]\n", (int )(r->config)->id,
             (r->config)->name);
      }
    }
#line 1197
    if (r->lmtype == 1) {
      {
#line 1198
      printf((char const   */* __restrict  */)"NOT A GRAMMAR-BASED LM\n");
      }
#line 1199
      goto __Cont;
    }
    {
#line 1201
    printf((char const   */* __restrict  */)"[grammars]\n");
#line 1202
    m = (r->lm)->grammars;
    }
    {
#line 1202
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1202
      if (! m) {
#line 1202
        goto while_break___0;
      }
#line 1203
      buf___13[0] = (char )'\000';
#line 1204
      if (m->dfa) {
        {
#line 1205
        snprintf((char */* __restrict  */)(buf___13), (size_t )1024, (char const   */* __restrict  */)", %3d categories, %4d nodes",
                 (m->dfa)->term_num, (m->dfa)->state_num);
        }
      }
#line 1208
      if (m->newbie) {
        {
#line 1208
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" (new)");
        }
      }
#line 1209
      if (m->hook != 0) {
        {
#line 1210
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" (next:");
        }
#line 1211
        if (m->hook & 1) {
          {
#line 1212
          strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" delete");
          }
        }
#line 1214
        if (m->hook & 2) {
          {
#line 1215
          strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" activate");
          }
        }
#line 1217
        if (m->hook & 4) {
          {
#line 1218
          strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" deactivate");
          }
        }
#line 1220
        if (m->hook & 8) {
          {
#line 1221
          strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" modified");
          }
        }
        {
#line 1223
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)")");
        }
      }
#line 1225
      if (m->active) {
#line 1225
        tmp = "active";
      } else {
#line 1225
        tmp = "inactive";
      }
      {
#line 1225
      myprintf((char *)"  #%2d: [%-11s] %4d words%s \"%s\"\n", (int )m->id, tmp, (int )(m->winfo)->num,
               buf___13, m->name);
#line 1202
      m = m->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1232
    if ((unsigned long )(r->lm)->dfa != (unsigned long )((void *)0)) {
      {
#line 1233
      printf((char const   */* __restrict  */)"  Global:            %4d words, %3d categories, %4d nodes\n",
             (int )((r->lm)->winfo)->num, ((r->lm)->dfa)->term_num, ((r->lm)->dfa)->state_num);
      }
    }
    __Cont: /* CIL Label */ 
#line 1194
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  return;
}
}
#line 1259 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
static void frame_indicator(Recog *recog , void *dummy ) 
{ 
  RecogProcess *r ;

  {
#line 1264
  if ((recog->jconf)->decodeopt.segment) {
#line 1265
    r = recog->process_list;
    {
#line 1265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1265
      if (! r) {
#line 1265
        goto while_break;
      }
#line 1266
      if (! r->live) {
#line 1266
        goto __Cont;
      }
#line 1267
      if (r->pass1.in_sparea) {
        {
#line 1268
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
        }
#line 1269
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 1265
      r = r->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1272
    if (! r) {
      {
#line 1273
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-");
      }
    }
  } else {
    {
#line 1276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
    }
  }
#line 1278
  return;
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_stdout.c"
void setup_output_tty(Recog *recog , void *data ) 
{ 
  JCONF_SEARCH *s ;
  boolean ok_p ;

  {
  {
#line 1284
  callback_add(recog, 1, & status_process_online, data);
#line 1285
  callback_add(recog, 2, & status_process_offline, data);
#line 1286
  callback_add(recog, 5, & status_recready, data);
#line 1287
  callback_add(recog, 6, & status_recstart, data);
#line 1288
  callback_add(recog, 7, & status_recend, data);
#line 1289
  callback_add(recog, 8, & status_recognition_begin, data);
#line 1290
  callback_add(recog, 9, & status_recognition_end, data);
  }
#line 1291
  if ((recog->jconf)->decodeopt.segment) {
    {
#line 1292
    callback_add(recog, 10, & status_segment_begin, data);
#line 1293
    callback_add(recog, 11, & status_segment_end, data);
    }
  }
  {
#line 1295
  callback_add(recog, 12, & status_pass1_begin, data);
#line 1299
  ok_p = (boolean )1;
#line 1300
  s = (recog->jconf)->search_root;
  }
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! s) {
#line 1300
      goto while_break;
    }
#line 1301
    if (s->output.progout_flag) {
#line 1301
      ok_p = (boolean )0;
    }
#line 1300
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  if (ok_p) {
#line 1304
    have_progout = (boolean )0;
  } else {
#line 1306
    have_progout = (boolean )1;
  }
#line 1309
  if (! (recog->jconf)->decodeopt.realtime_flag) {
#line 1309
    if (verbose_flag) {
#line 1309
      if (! have_progout) {
        {
#line 1310
        callback_add(recog, 13, & frame_indicator, data);
        }
      }
    }
  }
  {
#line 1312
  callback_add(recog, 15, & result_pass1_current, data);
#line 1313
  callback_add(recog, 16, & result_pass1, data);
#line 1317
  callback_add(recog, 14, & status_pass1_end, data);
#line 1318
  callback_add(recog, 18, & status_param, data);
#line 1319
  callback_add(recog, 19, & status_pass2_begin, data);
#line 1320
  callback_add(recog, 20, & status_pass2_end, data);
#line 1321
  callback_add(recog, 21, & result_pass2, data);
#line 1322
  callback_add(recog, 22, & result_gmm, data);
#line 1324
  callback_add(recog, 23, & result_graph, data);
#line 1326
  callback_add(recog, 24, & result_confnet, data);
  }
#line 1329
  return;
}
}
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 65 "../libsent/include/sent/tcpip.h"
extern int ready_as_server(int port_num ) ;
#line 66
extern int accept_from(int sd ) ;
#line 69
extern int close_socket(int sd ) ;
#line 89 "../libsent/include/sent/vocabulary.h"
extern WORD_INFO *word_info_new() ;
#line 90
extern void word_info_free(WORD_INFO *winfo ) ;
#line 96
extern void voca_load_start(WORD_INFO *winfo , HTK_HMM_INFO *hmminfo , boolean ignore_tri_conv ) ;
#line 97
extern boolean voca_load_line(char *buf , WORD_INFO *winfo , HTK_HMM_INFO *hmminfo ) ;
#line 98
extern boolean voca_load_end(WORD_INFO *winfo ) ;
#line 100
extern boolean voca_load_htkdict_fp(FILE * , WORD_INFO * , HTK_HMM_INFO * , boolean  ) ;
#line 105
extern boolean voca_load_word_line(char *buf , WORD_INFO *winfo , HTK_HMM_INFO *hmminfo ,
                                   char *headphone , char *tailpohone , char *contextphone ) ;
#line 107
extern boolean voca_load_wordlist_fp(FILE *fp , WORD_INFO *winfo , HTK_HMM_INFO *hmminfo ,
                                     char *headphone , char *tailphone , char *contextphone ) ;
#line 100 "../libsent/include/sent/dfa.h"
extern DFA_INFO *dfa_info_new() ;
#line 101
extern void dfa_info_free(DFA_INFO *dfa ) ;
#line 105
extern boolean rddfa_fp(FILE *fp , DFA_INFO *dinfo ) ;
#line 41 "../libjulius/include/julius/jfunc.h"
extern void j_request_pause(Recog *recog ) ;
#line 42
extern void j_request_terminate(Recog *recog ) ;
#line 43
extern void j_request_resume(Recog *recog ) ;
#line 44
extern void schedule_grammar_update(Recog *recog ) ;
#line 56
extern int j_config_load_file(Jconf *jconf , char *filename ) ;
#line 75
extern JCONF_SEARCH *j_get_searchconf_by_name(Jconf *jconf , char *name ) ;
#line 78
extern boolean j_process_deactivate(Recog *recog , char *name ) ;
#line 80
extern boolean j_process_activate(Recog *recog , char *name ) ;
#line 83
extern boolean j_process_add_lm(Recog *recog , JCONF_LM *lmconf , JCONF_SEARCH *sconf ,
                                char *name ) ;
#line 107
extern JCONF_SEARCH *j_jconf_search_new() ;
#line 108
extern void j_jconf_search_free(JCONF_SEARCH *sconf ) ;
#line 247 "../libjulius/include/julius/extern.h"
extern int multigram_add(DFA_INFO *dfa , WORD_INFO *winfo , char *name , PROCESS_LM *lm ) ;
#line 248
extern boolean multigram_delete(int gid , PROCESS_LM *lm ) ;
#line 249
extern void multigram_delete_all(PROCESS_LM *lm ) ;
#line 250
extern boolean multigram_update(PROCESS_LM *lm ) ;
#line 251
extern boolean multigram_build(RecogProcess *r ) ;
#line 252
extern int multigram_activate(int gid , PROCESS_LM *lm ) ;
#line 253
extern int multigram_deactivate(int gid , PROCESS_LM *lm ) ;
#line 260
extern int multigram_get_id_by_name(PROCESS_LM *lm , char *gramname ) ;
#line 265
extern boolean multigram_add_words_to_grammar_by_id(PROCESS_LM *lm , unsigned short id ,
                                                    WORD_INFO *winfo ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/app.h"
int module_send(int sd___0 , char *fmt  , ...) ;
#line 23
void module_add_option(void) ;
#line 24
boolean is_module_mode(void) ;
#line 25
void module_setup(Recog *recog , void *data ) ;
#line 26
void module_server(void) ;
#line 27
void module_disconnect(void) ;
#line 30
void decode_output_selection(char *str ) ;
#line 31
void send_gram_info(RecogProcess *r ) ;
#line 32
void setup_output_msock(Recog *recog , void *data ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static int module_mode  =    0;
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static int module_port  =    10500;
#line 9 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
int module_sd  =    -1;
#line 10 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static FILE *module_fp  ;
#line 11 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static RecogProcess *cur  =    (RecogProcess *)((void *)0);
#line 14 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char mbuf[4096]  ;
#line 15 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char buf___3[4096]  ;
#line 16 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char inbuf___0[4096]  ;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char outbuf___0[4096]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
int module_send(int sd___0 , char *fmt  , ...) 
{ 
  va_list ap ;
  int ret ;
  char *buf___13 ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 37
  __builtin_va_start(ap, fmt);
#line 38
  ret = vsnprintf((char */* __restrict  */)(inbuf___0), (size_t )4096, (char const   */* __restrict  */)fmt,
                  ap);
#line 39
  __builtin_va_end(ap);
  }
#line 40
  if (ret > 0) {
    {
#line 43
    buf___13 = charconv(inbuf___0, outbuf___0, 4096);
#line 47
    tmp = strlen((char const   *)buf___13);
#line 47
    tmp___0 = write(sd___0, (void const   *)buf___13, tmp);
    }
#line 47
    if (tmp___0 < 0L) {
      {
#line 54
      perror("Error: module_send:");
      }
    }
  }
#line 57
  return (ret);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char *myfgets(char *buf___13 , int maxlen , FILE *fp___2 ) 
{ 
  char *ret ;
  int len ;
  size_t tmp ;

  {
  {
#line 66
  ret = fgets((char */* __restrict  */)buf___13, maxlen, (FILE */* __restrict  */)fp___2);
  }
#line 66
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 67
    tmp = strlen((char const   *)buf___13);
#line 67
    len = (int )tmp;
    }
#line 68
    if ((int )*(buf___13 + (len - 1)) == 10) {
#line 69
      *(buf___13 + (len - 1)) = (char )'\000';
#line 70
      if (len >= 2) {
#line 70
        if ((int )*(buf___13 + (len - 2)) == 13) {
#line 71
          *(buf___13 + (len - 2)) = (char )'\000';
        }
      }
    }
  }
#line 75
  return (ret);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static boolean read_grammar(FILE *fp___2 , DFA_INFO **ret_dfa , WORD_INFO **ret_winfo ,
                            HTK_HMM_INFO *hmminfo___0 , RecogProcess *r ) 
{ 
  DFA_INFO *dfa___2 ;
  WORD_INFO *winfo___0 ;
  JCONF_LM *lmconf ;
  boolean tmp ;
  char *tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;

  {
#line 93
  dfa___2 = (DFA_INFO *)((void *)0);
#line 98
  if (r->lmvar != 2) {
    {
#line 99
    dfa___2 = dfa_info_new();
#line 100
    tmp = rddfa_fp(fp___2, dfa___2);
    }
#line 100
    if (! tmp) {
#line 101
      return ((boolean )0);
    }
  }
  {
#line 104
  winfo___0 = word_info_new();
  }
#line 105
  if (r->lmvar == 2) {
#line 106
    lmconf = (r->lm)->config;
#line 107
    if ((int )lmconf->wordrecog_silence_context_name[0] == 0) {
#line 107
      tmp___0 = (char *)((void *)0);
    } else {
#line 107
      tmp___0 = lmconf->wordrecog_silence_context_name;
    }
    {
#line 107
    tmp___1 = voca_load_wordlist_fp(fp___2, winfo___0, hmminfo___0, lmconf->wordrecog_head_silence_model_name,
                                    lmconf->wordrecog_tail_silence_model_name, tmp___0);
    }
#line 107
    if (! tmp___1) {
#line 108
      return ((boolean )0);
    }
  } else {
    {
#line 111
    tmp___2 = voca_load_htkdict_fp(fp___2, winfo___0, hmminfo___0, (boolean )0);
    }
#line 111
    if (! tmp___2) {
      {
#line 112
      dfa_info_free(dfa___2);
      }
#line 113
      return ((boolean )0);
    }
  }
#line 116
  *ret_dfa = dfa___2;
#line 117
  *ret_winfo = winfo___0;
#line 118
  return ((boolean )1);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void send_process_stat(RecogProcess *r ) 
{ 


  {
  {
#line 125
  module_send(module_sd, (char *)"<SR ID=\"%d\" NAME=\"%s\"", (int )(r->config)->id,
              (r->config)->name);
  }
  {
#line 127
  if (r->lmtype == 1) {
#line 127
    goto case_1;
  }
#line 128
  if (r->lmtype == 2) {
#line 128
    goto case_2;
  }
#line 126
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 127
  module_send(module_sd, (char *)" LMTYPE=\"PROB\"");
  }
#line 127
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 128
  module_send(module_sd, (char *)" LMTYPE=\"DFA\"");
  }
#line 128
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 131
  if (r->lmvar == 0) {
#line 131
    goto case_0;
  }
#line 132
  if (r->lmvar == 1) {
#line 132
    goto case_1___0;
  }
#line 133
  if (r->lmvar == 2) {
#line 133
    goto case_2___0;
  }
#line 134
  if (r->lmvar == 3) {
#line 134
    goto case_3;
  }
#line 130
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 131
  module_send(module_sd, (char *)" LMVAR=\"NGRAM\"");
  }
#line 131
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 132
  module_send(module_sd, (char *)" LMVAR=\"GRAMMAR\"");
  }
#line 132
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 133
  module_send(module_sd, (char *)" LMVAR=\"WORD\"");
  }
#line 133
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 134
  module_send(module_sd, (char *)" LMVAR=\"USER\"");
  }
#line 134
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 136
  if (r->live) {
    {
#line 137
    module_send(module_sd, (char *)" LIVE=\"ACTIVE\"");
    }
  } else {
    {
#line 139
    module_send(module_sd, (char *)" LIVE=\"INACTIVE\"");
    }
  }
  {
#line 141
  module_send(module_sd, (char *)"/>\n.\n");
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void send_current_process(RecogProcess *r ) 
{ 


  {
  {
#line 147
  module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"CURRENT\">\n");
#line 148
  send_process_stat(r);
#line 149
  module_send(module_sd, (char *)"</RECOGPROCESS>\n.\n");
  }
#line 150
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char *p  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static char *q  ;
#line 545
extern int ( /* missing proto */  j_process_remove)() ;
#line 546
extern int ( /* missing proto */  j_process_lm_remove)() ;
#line 179 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void msock_exec_command(char *command , Recog *recog ) 
{ 
  DFA_INFO *new_dfa ;
  WORD_INFO *new_winfo ;
  int gid ;
  int ret ;
  RecogProcess *r ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  boolean tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  boolean tmp___10 ;
  char *tmp___11 ;
  boolean tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  JCONF_SEARCH *sconf ;
  RecogProcess *r___0 ;
  char *tmp___15 ;
  Jconf *jconf ;
  JCONF_LM *lmconf ;
  JCONF_SEARCH *sconf___0 ;
  RecogProcess *r___1 ;
  char *tmp___16 ;
  boolean tmp___17 ;
  JCONF_SEARCH *sconf___1 ;
  JCONF_LM *lmconf___0 ;
  RecogProcess *r___2 ;
  char *tmp___18 ;
  RecogProcess *r___3 ;
  char *tmp___19 ;
  boolean tmp___20 ;
  char *tmp___21 ;
  boolean tmp___22 ;
  WORD_INFO *words ;
  boolean ret___0 ;
  int id ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  boolean tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  int tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;

  {
  {
#line 190
  printf((char const   */* __restrict  */)"[[%s]]\n", command);
  }
#line 192
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
#line 193
    cur = recog->process_list;
  }
  {
#line 196
  tmp___51 = strcmp((char const   *)command, "STATUS");
  }
#line 196
  if (tmp___51) {
    {
#line 203
    tmp___50 = strcmp((char const   *)command, "DIE");
    }
#line 203
    if (tmp___50) {
      {
#line 214
      tmp___49 = strcmp((char const   *)command, "VERSION");
      }
#line 214
      if (tmp___49) {
        {
#line 218
        tmp___48 = strcmp((char const   *)command, "PAUSE");
        }
#line 218
        if (tmp___48) {
          {
#line 221
          tmp___47 = strcmp((char const   *)command, "TERMINATE");
          }
#line 221
          if (tmp___47) {
            {
#line 223
            tmp___46 = strcmp((char const   *)command, "RESUME");
            }
#line 223
            if (tmp___46) {
              {
#line 225
              tmp___45 = strcmp((char const   *)command, "INPUTONCHANGE");
              }
#line 225
              if (tmp___45) {
                {
#line 242
                tmp___43 = strlen("GRAMINFO");
#line 242
                tmp___44 = strncmp((char const   *)command, "GRAMINFO", tmp___43);
                }
#line 242
                if (tmp___44) {
                  {
#line 244
                  tmp___41 = strlen("CHANGEGRAM");
#line 244
                  tmp___42 = strncmp((char const   *)command, "CHANGEGRAM", tmp___41);
                  }
#line 244
                  if (tmp___42) {
                    {
#line 278
                    tmp___39 = strlen("ADDGRAM");
#line 278
                    tmp___40 = strncmp((char const   *)command, "ADDGRAM", tmp___39);
                    }
#line 278
                    if (tmp___40) {
                      {
#line 310
                      tmp___38 = strcmp((char const   *)command, "DELGRAM");
                      }
#line 310
                      if (tmp___38) {
                        {
#line 347
                        tmp___37 = strcmp((char const   *)command, "ACTIVATEGRAM");
                        }
#line 347
                        if (tmp___37) {
                          {
#line 384
                          tmp___36 = strcmp((char const   *)command, "DEACTIVATEGRAM");
                          }
#line 384
                          if (tmp___36) {
                            {
#line 420
                            tmp___35 = strcmp((char const   *)command, "SYNCGRAM");
                            }
#line 420
                            if (tmp___35) {
                              {
#line 434
                              tmp___34 = strcmp((char const   *)command, "CURRENTPROCESS");
                              }
#line 434
                              if (tmp___34) {
                                {
#line 469
                                tmp___33 = strcmp((char const   *)command, "SHIFTPROCESS");
                                }
#line 469
                                if (tmp___33) {
                                  {
#line 478
                                  tmp___32 = strcmp((char const   *)command, "ADDPROCESS");
                                  }
#line 478
                                  if (tmp___32) {
                                    {
#line 518
                                    tmp___31 = strcmp((char const   *)command, "DELPROCESS");
                                    }
#line 518
                                    if (tmp___31) {
                                      {
#line 559
                                      tmp___30 = strcmp((char const   *)command, "LISTPROCESS");
                                      }
#line 559
                                      if (tmp___30) {
                                        {
#line 569
                                        tmp___29 = strcmp((char const   *)command,
                                                          "ACTIVATEPROCESS");
                                        }
#line 569
                                        if (tmp___29) {
                                          {
#line 583
                                          tmp___28 = strcmp((char const   *)command,
                                                            "DEACTIVATEPROCESS");
                                          }
#line 583
                                          if (tmp___28) {
                                            {
#line 598
                                            tmp___27 = strcmp((char const   *)command,
                                                              "ADDWORD");
                                            }
#line 598
                                            if (! tmp___27) {
                                              {
#line 604
                                              tmp___23 = myfgets(buf___3, 4096, module_fp);
                                              }
#line 604
                                              if ((unsigned long )tmp___23 == (unsigned long )((void *)0)) {
                                                {
#line 607
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Error: msock(DEACTIVATEPROCESS): no argument\n");
#line 608
                                                module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO ARGUMENT\"/>\n.\n");
                                                }
#line 609
                                                return;
                                              }
                                              {
#line 611
                                              id = atoi((char const   *)(buf___3));
#line 614
                                              words = word_info_new();
#line 615
                                              voca_load_start(words, (cur->am)->hmminfo,
                                                              (boolean )0);
                                              }
                                              {
#line 616
                                              while (1) {
                                                while_continue: /* CIL Label */ ;
                                                {
#line 616
                                                tmp___25 = myfgets(buf___3, 4096,
                                                                   module_fp);
                                                }
#line 616
                                                if (! ((unsigned long )tmp___25 != (unsigned long )((void *)0))) {
#line 616
                                                  goto while_break;
                                                }
#line 619
                                                if (cur->lmvar == 2) {
#line 620
                                                  if ((int )((cur->lm)->config)->wordrecog_silence_context_name[0] == 0) {
#line 620
                                                    tmp___24 = (char *)((void *)0);
                                                  } else {
#line 620
                                                    tmp___24 = ((cur->lm)->config)->wordrecog_silence_context_name;
                                                  }
                                                  {
#line 620
                                                  ret___0 = voca_load_word_line(buf___3,
                                                                                words,
                                                                                (cur->am)->hmminfo,
                                                                                ((cur->lm)->config)->wordrecog_head_silence_model_name,
                                                                                ((cur->lm)->config)->wordrecog_tail_silence_model_name,
                                                                                tmp___24);
                                                  }
                                                } else {
                                                  {
#line 625
                                                  ret___0 = voca_load_line(buf___3,
                                                                           words,
                                                                           (cur->am)->hmminfo);
                                                  }
                                                }
#line 627
                                                if ((int )ret___0 == 0) {
#line 627
                                                  goto while_break;
                                                }
                                              }
                                              while_break: /* CIL Label */ ;
                                              }
                                              {
#line 629
                                              ret___0 = voca_load_end(words);
                                              }
#line 630
                                              if ((int )ret___0 == 0) {
                                                {
#line 631
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Error: msock(ADDWORD): error in reading word entries\n");
#line 632
                                                module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"ERROR IN READING WORD ENTRIES\"/>\n.\n");
#line 633
                                                word_info_free(words);
                                                }
#line 634
                                                return;
                                              }
#line 636
                                              if ((int )words->num == 0) {
                                                {
#line 637
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Error: msock(ADDWORD): no word specified\n");
#line 638
                                                module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO WORD SPECIFIED\"/>\n.\n");
#line 639
                                                word_info_free(words);
                                                }
#line 640
                                                return;
                                              }
                                              {
#line 642
                                              printf((char const   */* __restrict  */)"%d words read\n",
                                                     (int )words->num);
#line 644
                                              tmp___26 = multigram_add_words_to_grammar_by_id(cur->lm,
                                                                                              (unsigned short )id,
                                                                                              words);
                                              }
#line 644
                                              if ((int )tmp___26 == 0) {
                                                {
#line 645
                                                fprintf((FILE */* __restrict  */)stderr,
                                                        (char const   */* __restrict  */)"Error: msock(ADDWORD): failed to add words to grammar #%d\n",
                                                        id);
#line 646
                                                module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"FAILED\"/>\n.\n");
#line 647
                                                word_info_free(words);
                                                }
#line 648
                                                return;
                                              }
                                              {
#line 651
                                              schedule_grammar_update(recog);
#line 652
                                              module_send(module_sd, (char *)"%d words added to grammar #%d\n.\n",
                                                          (int )words->num, id);
#line 653
                                              module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"ADDEDWORD\" GRAMMARID=\"%d\" NUM=\"%d\"/>\n.\n",
                                                          id, (int )words->num);
#line 655
                                              word_info_free(words);
                                              }
                                            }
                                          } else {
                                            {
#line 584
                                            tmp___21 = myfgets(buf___3, 4096, module_fp);
                                            }
#line 584
                                            if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
                                              {
#line 587
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"Error: msock(DEACTIVATEPROCESS): no argument\n");
#line 588
                                              module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO ARGUMENT\"/>\n.\n");
                                              }
#line 589
                                              return;
                                            }
                                            {
#line 591
                                            tmp___22 = j_process_deactivate(recog,
                                                                            buf___3);
                                            }
#line 591
                                            if ((int )tmp___22 == 0) {
                                              {
#line 592
                                              module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"DEACTIVATION FAILED\"/>\n.\n");
                                              }
                                            } else {
                                              {
#line 594
                                              module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"DEACTIVATED\" NAME=\"%s\"/>\n.\n",
                                                          buf___3);
                                              }
                                            }
                                            {
#line 596
                                            module_send(module_sd, (char *)".\n");
                                            }
                                          }
                                        } else {
                                          {
#line 570
                                          tmp___19 = myfgets(buf___3, 4096, module_fp);
                                          }
#line 570
                                          if ((unsigned long )tmp___19 == (unsigned long )((void *)0)) {
                                            {
#line 573
                                            fprintf((FILE */* __restrict  */)stderr,
                                                    (char const   */* __restrict  */)"Error: msock(ACTIVATEPROCESS): no argument\n");
#line 574
                                            module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO ARGUMENT\"/>\n.\n");
                                            }
#line 575
                                            return;
                                          }
                                          {
#line 577
                                          tmp___20 = j_process_activate(recog, buf___3);
                                          }
#line 577
                                          if ((int )tmp___20 == 0) {
                                            {
#line 578
                                            module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"ACTIVATION FAILED\"/>\n.\n");
                                            }
                                          } else {
                                            {
#line 580
                                            module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"ACTIVATED\" NAME=\"%s\"/>\n.\n",
                                                        buf___3);
                                            }
                                          }
                                        }
                                      } else {
                                        {
#line 562
                                        module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"STATUS\">\n");
#line 563
                                        r___3 = recog->process_list;
                                        }
                                        {
#line 563
                                        while (1) {
                                          while_continue___0: /* CIL Label */ ;
#line 563
                                          if (! r___3) {
#line 563
                                            goto while_break___0;
                                          }
                                          {
#line 564
                                          send_process_stat(r___3);
#line 563
                                          r___3 = r___3->next;
                                          }
                                        }
                                        while_break___0: /* CIL Label */ ;
                                        }
                                        {
#line 566
                                        module_send(module_sd, (char *)"</RECOGPROCESS>\n.\n");
                                        }
                                      }
                                    } else {
                                      {
#line 523
                                      tmp___18 = myfgets(buf___3, 4096, module_fp);
                                      }
#line 523
                                      if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
                                        {
#line 526
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(DELPROCESS): no argument\n");
#line 527
                                        module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO ARGUMENT\"/>\n.\n");
                                        }
#line 528
                                        return;
                                      }
                                      {
#line 531
                                      sconf___1 = j_get_searchconf_by_name(recog->jconf,
                                                                           buf___3);
                                      }
#line 532
                                      if ((unsigned long )sconf___1 == (unsigned long )((void *)0)) {
                                        {
#line 533
                                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(DELPROCESS): no searchconf named %s\n",
                                                buf___3);
#line 534
                                        module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO RECOGPROCESS OF THE NAME\"/>\n.\n");
                                        }
#line 535
                                        return;
                                      }
                                      {
#line 538
                                      lmconf___0 = sconf___1->lmconf;
#line 539
                                      printf((char const   */* __restrict  */)"remove process: SR%02d %s, LM%02d %s\n",
                                             (int )sconf___1->id, sconf___1->name,
                                             (int )lmconf___0->id, lmconf___0->name);
#line 540
                                      module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"DELETE\">\n");
#line 541
                                      r___2 = recog->process_list;
                                      }
                                      {
#line 541
                                      while (1) {
                                        while_continue___1: /* CIL Label */ ;
#line 541
                                        if (! r___2) {
#line 541
                                          goto while_break___1;
                                        }
#line 542
                                        if ((unsigned long )r___2->config == (unsigned long )sconf___1) {
                                          {
#line 542
                                          send_process_stat(r___2);
                                          }
                                        }
#line 541
                                        r___2 = r___2->next;
                                      }
                                      while_break___1: /* CIL Label */ ;
                                      }
                                      {
#line 544
                                      module_send(module_sd, (char *)"</RECOGPROCESS>\n.\n");
#line 545
                                      j_process_remove(recog, sconf___1);
#line 546
                                      j_process_lm_remove(recog, lmconf___0);
#line 548
                                      r___2 = recog->process_list;
                                      }
                                      {
#line 548
                                      while (1) {
                                        while_continue___2: /* CIL Label */ ;
#line 548
                                        if (! r___2) {
#line 548
                                          goto while_break___2;
                                        }
#line 549
                                        if ((unsigned long )r___2 == (unsigned long )cur) {
#line 549
                                          goto while_break___2;
                                        }
#line 548
                                        r___2 = r___2->next;
                                      }
                                      while_break___2: /* CIL Label */ ;
                                      }
#line 551
                                      if (! r___2) {
                                        {
#line 552
                                        cur = recog->process_list;
#line 553
                                        printf((char const   */* __restrict  */)"now current moved to SR%02d %s\n",
                                               (int )(cur->config)->id, (cur->config)->name);
#line 554
                                        send_current_process(cur);
                                        }
                                      }
                                    }
                                  } else {
                                    {
#line 485
                                    tmp___16 = myfgets(buf___3, 4096, module_fp);
                                    }
#line 485
                                    if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
                                      {
#line 488
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(ADDPROCESS): no argument\n");
#line 489
                                      module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO ARGUMENT\"/>\n.\n");
                                      }
#line 490
                                      return;
                                    }
                                    {
#line 493
                                    jconf = j_jconf_new();
#line 494
                                    j_config_load_file(jconf, buf___3);
#line 495
                                    lmconf = jconf->lmnow;
#line 498
                                    sconf___0 = j_jconf_search_new();
#line 502
                                    tmp___17 = j_process_add_lm(recog, lmconf, sconf___0,
                                                                buf___3);
                                    }
#line 502
                                    if ((int )tmp___17 == 0) {
                                      {
#line 503
                                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: failed to regist new process \"%s\"\n",
                                              buf___3);
#line 504
                                      module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"FAILED TO REGISTER\"/>\n.\n");
#line 505
                                      j_jconf_search_free(sconf___0);
                                      }
#line 506
                                      return;
                                    }
                                    {
#line 508
                                    printf((char const   */* __restrict  */)"added process: SR%02d %s\n",
                                           (int )sconf___0->id, sconf___0->name);
#line 509
                                    module_send(module_sd, (char *)"<RECOGPROCESS INFO=\"ADDED\">\n");
#line 510
                                    r___1 = recog->process_list;
                                    }
                                    {
#line 510
                                    while (1) {
                                      while_continue___3: /* CIL Label */ ;
#line 510
                                      if (! r___1) {
#line 510
                                        goto while_break___3;
                                      }
#line 511
                                      if ((unsigned long )r___1->config == (unsigned long )sconf___0) {
                                        {
#line 512
                                        send_process_stat(r___1);
                                        }
                                      }
#line 510
                                      r___1 = r___1->next;
                                    }
                                    while_break___3: /* CIL Label */ ;
                                    }
                                    {
#line 515
                                    module_send(module_sd, (char *)"</RECOGPROCESS>\n.\n");
                                    }
                                  }
                                } else {
#line 470
                                  cur = cur->next;
#line 471
                                  if ((unsigned long )cur == (unsigned long )((void *)0)) {
                                    {
#line 472
                                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SHIFTPROCESS: reached end, rotated to first\n");
#line 473
                                    cur = recog->process_list;
                                    }
                                  }
                                  {
#line 475
                                  send_process_stat(cur);
                                  }
                                }
                              } else {
                                {
#line 437
                                tmp___15 = myfgets(buf___3, 4096, module_fp);
                                }
#line 437
                                if ((unsigned long )tmp___15 == (unsigned long )((void *)0)) {
                                  {
#line 441
                                  send_current_process(cur);
                                  }
#line 442
                                  return;
                                }
#line 444
                                if ((int )buf___3[0] == 0) {
                                  {
#line 446
                                  send_current_process(cur);
                                  }
#line 447
                                  return;
                                }
                                {
#line 449
                                sconf = j_get_searchconf_by_name(recog->jconf, buf___3);
                                }
#line 450
                                if ((unsigned long )sconf == (unsigned long )((void *)0)) {
                                  {
#line 451
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(CURRENTPROCESS): no such process \"%s\"\n",
                                          buf___3);
#line 452
                                  module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO SUCH PROCESS\"/>\n.\n");
                                  }
#line 453
                                  return;
                                }
#line 455
                                r___0 = recog->process_list;
                                {
#line 455
                                while (1) {
                                  while_continue___4: /* CIL Label */ ;
#line 455
                                  if (! r___0) {
#line 455
                                    goto while_break___4;
                                  }
#line 456
                                  if ((unsigned long )r___0->config == (unsigned long )sconf) {
#line 457
                                    cur = r___0;
#line 458
                                    goto while_break___4;
                                  }
#line 455
                                  r___0 = r___0->next;
                                }
                                while_break___4: /* CIL Label */ ;
                                }
#line 461
                                if (! r___0) {
                                  {
#line 462
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(CURRENTPROCESS): no process assigned to searchconf \"%s\"??\n",
                                          buf___3);
#line 463
                                  module_send(module_sd, (char *)"<RECOGPROCESS STATUS=\"ERROR\" REASON=\"NO SUCH PROCESS\"/>\n.\n");
                                  }
#line 464
                                  return;
                                }
                                {
#line 466
                                send_current_process(cur);
                                }
                              }
                            } else
#line 422
                            if (cur->lmtype == 2) {
                              {
#line 423
                              multigram_update(cur->lm);
#line 424
                              r = recog->process_list;
                              }
                              {
#line 424
                              while (1) {
                                while_continue___5: /* CIL Label */ ;
#line 424
                                if (! r) {
#line 424
                                  goto while_break___5;
                                }
#line 425
                                if (r->lmtype == 2) {
#line 425
                                  if ((r->lm)->global_modified) {
                                    {
#line 426
                                    multigram_build(r);
                                    }
                                  }
                                }
#line 424
                                r = r->next;
                              }
                              while_break___5: /* CIL Label */ ;
                              }
                              {
#line 429
                              (cur->lm)->global_modified = (boolean )0;
#line 430
                              module_send(module_sd, (char *)"<GRAMMAR STATUS=\"READY\"/>\n.\n");
                              }
                            } else {
                              {
#line 432
                              module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                              }
                            }
                          } else {
                            {
#line 387
                            tmp___14 = myfgets(buf___3, 4096, module_fp);
                            }
#line 387
                            if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
                              {
#line 390
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(DEACTIVATEGRAM): no argument\n");
                              }
#line 391
                              return;
                            }
#line 393
                            if (cur->lmtype == 2) {
                              {
#line 395
                              p = strtok((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)" ");
                              }
                              {
#line 395
                              while (1) {
                                while_continue___6: /* CIL Label */ ;
#line 395
                                if (! p) {
#line 395
                                  goto while_break___6;
                                }
#line 396
                                q = p;
                                {
#line 397
                                while (1) {
                                  while_continue___7: /* CIL Label */ ;
#line 397
                                  if ((int )*q != 0) {
#line 397
                                    if ((int )*q != 13) {
#line 397
                                      if (! ((int )*q != 10)) {
#line 397
                                        goto while_break___7;
                                      }
                                    } else {
#line 397
                                      goto while_break___7;
                                    }
                                  } else {
#line 397
                                    goto while_break___7;
                                  }
#line 398
                                  if ((int )*q < 48) {
#line 398
                                    goto while_break___7;
                                  } else
#line 398
                                  if ((int )*q > 57) {
#line 398
                                    goto while_break___7;
                                  }
#line 399
                                  q ++;
                                }
                                while_break___7: /* CIL Label */ ;
                                }
#line 401
                                if ((int )*q == 0) {
                                  {
#line 402
                                  gid = atoi((char const   *)p);
                                  }
                                } else
#line 401
                                if ((int )*q == 13) {
                                  {
#line 402
                                  gid = atoi((char const   *)p);
                                  }
                                } else
#line 401
                                if ((int )*q == 10) {
                                  {
#line 402
                                  gid = atoi((char const   *)p);
                                  }
                                } else {
                                  {
#line 404
                                  gid = multigram_get_id_by_name(cur->lm, p);
                                  }
#line 405
                                  if (gid == -1) {
#line 405
                                    goto __Cont___1;
                                  }
                                }
                                {
#line 407
                                ret = multigram_deactivate(gid, cur->lm);
                                }
#line 408
                                if (ret == 1) {
                                  {
#line 410
                                  module_send(module_sd, (char *)"<WARN MESSAGE=\"Gram #%d already inactive\"/>\n.\n",
                                              gid);
                                  }
                                } else
#line 411
                                if (ret == -1) {
                                  {
#line 413
                                  module_send(module_sd, (char *)"<WARN MESSAGE=\"Gram #%d not found\"/>\n.\n",
                                              gid);
                                  }
                                }
                                __Cont___1: /* CIL Label */ 
                                {
#line 395
                                p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
                                }
                              }
                              while_break___6: /* CIL Label */ ;
                              }
                              {
#line 416
                              schedule_grammar_update(recog);
                              }
                            } else {
                              {
#line 418
                              module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                              }
                            }
                          }
                        } else {
                          {
#line 350
                          tmp___13 = myfgets(buf___3, 4096, module_fp);
                          }
#line 350
                          if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
                            {
#line 353
                            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(ACTIVATEGRAM): no argument\n");
                            }
#line 354
                            return;
                          }
#line 357
                          if (cur->lmtype == 2) {
                            {
#line 358
                            p = strtok((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)" ");
                            }
                            {
#line 358
                            while (1) {
                              while_continue___8: /* CIL Label */ ;
#line 358
                              if (! p) {
#line 358
                                goto while_break___8;
                              }
#line 359
                              q = p;
                              {
#line 360
                              while (1) {
                                while_continue___9: /* CIL Label */ ;
#line 360
                                if ((int )*q != 0) {
#line 360
                                  if ((int )*q != 13) {
#line 360
                                    if (! ((int )*q != 10)) {
#line 360
                                      goto while_break___9;
                                    }
                                  } else {
#line 360
                                    goto while_break___9;
                                  }
                                } else {
#line 360
                                  goto while_break___9;
                                }
#line 361
                                if ((int )*q < 48) {
#line 361
                                  goto while_break___9;
                                } else
#line 361
                                if ((int )*q > 57) {
#line 361
                                  goto while_break___9;
                                }
#line 362
                                q ++;
                              }
                              while_break___9: /* CIL Label */ ;
                              }
#line 364
                              if ((int )*q == 0) {
                                {
#line 365
                                gid = atoi((char const   *)p);
                                }
                              } else
#line 364
                              if ((int )*q == 13) {
                                {
#line 365
                                gid = atoi((char const   *)p);
                                }
                              } else
#line 364
                              if ((int )*q == 10) {
                                {
#line 365
                                gid = atoi((char const   *)p);
                                }
                              } else {
                                {
#line 367
                                gid = multigram_get_id_by_name(cur->lm, p);
                                }
#line 368
                                if (gid == -1) {
#line 368
                                  goto __Cont___0;
                                }
                              }
                              {
#line 370
                              ret = multigram_activate(gid, cur->lm);
                              }
#line 371
                              if (ret == 1) {
                                {
#line 373
                                module_send(module_sd, (char *)"<WARN MESSAGE=\"Gram #%d already active\"/>\n.\n",
                                            gid);
                                }
                              } else
#line 374
                              if (ret == -1) {
                                {
#line 376
                                module_send(module_sd, (char *)"<WARN MESSAGE=\"Gram #%d not found\"/>\n.\n",
                                            gid);
                                }
                              }
                              __Cont___0: /* CIL Label */ 
                              {
#line 358
                              p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
                              }
                            }
                            while_break___8: /* CIL Label */ ;
                            }
                            {
#line 380
                            schedule_grammar_update(recog);
                            }
                          } else {
                            {
#line 382
                            module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                            }
                          }
                        }
                      } else {
                        {
#line 313
                        tmp___11 = myfgets(buf___3, 4096, module_fp);
                        }
#line 313
                        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
                          {
#line 316
                          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(DELGRAM): no argument\n");
                          }
#line 317
                          return;
                        }
#line 322
                        if (cur->lmtype == 2) {
                          {
#line 323
                          p = strtok((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)" ");
                          }
                          {
#line 323
                          while (1) {
                            while_continue___10: /* CIL Label */ ;
#line 323
                            if (! p) {
#line 323
                              goto while_break___10;
                            }
#line 324
                            q = p;
                            {
#line 325
                            while (1) {
                              while_continue___11: /* CIL Label */ ;
#line 325
                              if ((int )*q != 0) {
#line 325
                                if ((int )*q != 13) {
#line 325
                                  if (! ((int )*q != 10)) {
#line 325
                                    goto while_break___11;
                                  }
                                } else {
#line 325
                                  goto while_break___11;
                                }
                              } else {
#line 325
                                goto while_break___11;
                              }
#line 326
                              if ((int )*q < 48) {
#line 326
                                goto while_break___11;
                              } else
#line 326
                              if ((int )*q > 57) {
#line 326
                                goto while_break___11;
                              }
#line 327
                              q ++;
                            }
                            while_break___11: /* CIL Label */ ;
                            }
#line 329
                            if ((int )*q == 0) {
                              {
#line 330
                              gid = atoi((char const   *)p);
                              }
                            } else
#line 329
                            if ((int )*q == 13) {
                              {
#line 330
                              gid = atoi((char const   *)p);
                              }
                            } else
#line 329
                            if ((int )*q == 10) {
                              {
#line 330
                              gid = atoi((char const   *)p);
                              }
                            } else {
                              {
#line 332
                              gid = multigram_get_id_by_name(cur->lm, p);
                              }
#line 333
                              if (gid == -1) {
#line 333
                                goto __Cont;
                              }
                            }
                            {
#line 335
                            tmp___12 = multigram_delete(gid, cur->lm);
                            }
#line 335
                            if ((int )tmp___12 == 0) {
                              {
#line 336
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: msock(DELGRAM): gram #%d failed to delete, ignored\n",
                                      gid);
#line 338
                              module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"Gram #%d not found\"/>\n.\n",
                                          gid);
                              }
                            }
                            __Cont: /* CIL Label */ 
                            {
#line 323
                            p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
                            }
                          }
                          while_break___10: /* CIL Label */ ;
                          }
                          {
#line 343
                          schedule_grammar_update(recog);
                          }
                        } else {
                          {
#line 345
                          module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                          }
                        }
                      }
                    } else {
                      {
#line 281
                      tmp___7 = strlen("ADDGRAM");
#line 281
                      p = command + tmp___7;
                      }
                      {
#line 282
                      while (1) {
                        while_continue___12: /* CIL Label */ ;
#line 282
                        if ((int )*p == 32) {
#line 282
                          if ((int )*p != 13) {
#line 282
                            if ((int )*p != 10) {
#line 282
                              if (! ((int )*p != 0)) {
#line 282
                                goto while_break___12;
                              }
                            } else {
#line 282
                              goto while_break___12;
                            }
                          } else {
#line 282
                            goto while_break___12;
                          }
                        } else {
#line 282
                          goto while_break___12;
                        }
#line 282
                        p ++;
                      }
                      while_break___12: /* CIL Label */ ;
                      }
#line 283
                      if ((int )*p != 13) {
#line 283
                        if ((int )*p != 10) {
#line 283
                          if ((int )*p != 0) {
#line 284
                            q = buf___3;
                            {
#line 285
                            while (1) {
                              while_continue___13: /* CIL Label */ ;
#line 285
                              if ((int )*p != 32) {
#line 285
                                if ((int )*p != 13) {
#line 285
                                  if ((int )*p != 10) {
#line 285
                                    if (! ((int )*p != 0)) {
#line 285
                                      goto while_break___13;
                                    }
                                  } else {
#line 285
                                    goto while_break___13;
                                  }
                                } else {
#line 285
                                  goto while_break___13;
                                }
                              } else {
#line 285
                                goto while_break___13;
                              }
#line 285
                              tmp___8 = q;
#line 285
                              q ++;
#line 285
                              tmp___9 = p;
#line 285
                              p ++;
#line 285
                              *tmp___8 = *tmp___9;
                            }
                            while_break___13: /* CIL Label */ ;
                            }
#line 286
                            *q = (char )'\000';
#line 287
                            p = buf___3;
                          } else {
#line 289
                            p = (char *)((void *)0);
                          }
                        } else {
#line 289
                          p = (char *)((void *)0);
                        }
                      } else {
#line 289
                        p = (char *)((void *)0);
                      }
                      {
#line 292
                      tmp___10 = read_grammar(module_fp, & new_dfa, & new_winfo, (cur->am)->hmminfo,
                                              cur);
                      }
#line 292
                      if ((int )tmp___10 == 0) {
                        {
#line 293
                        module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"WRONG DATA\"/>\n.\n");
                        }
                      } else
#line 295
                      if (cur->lmtype == 2) {
                        {
#line 297
                        multigram_add(new_dfa, new_winfo, p, cur->lm);
#line 300
                        cur->active = (short)1;
#line 302
                        schedule_grammar_update(recog);
#line 304
                        module_send(module_sd, (char *)"<GRAMMAR STATUS=\"RECEIVED\"/>\n.\n");
#line 305
                        send_gram_info(cur);
                        }
                      } else {
                        {
#line 307
                        module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                        }
                      }
                    }
                  } else {
                    {
#line 247
                    tmp___3 = strlen("CHANGEGRAM");
#line 247
                    p = command + tmp___3;
                    }
                    {
#line 248
                    while (1) {
                      while_continue___14: /* CIL Label */ ;
#line 248
                      if ((int )*p == 32) {
#line 248
                        if ((int )*p != 13) {
#line 248
                          if ((int )*p != 10) {
#line 248
                            if (! ((int )*p != 0)) {
#line 248
                              goto while_break___14;
                            }
                          } else {
#line 248
                            goto while_break___14;
                          }
                        } else {
#line 248
                          goto while_break___14;
                        }
                      } else {
#line 248
                        goto while_break___14;
                      }
#line 248
                      p ++;
                    }
                    while_break___14: /* CIL Label */ ;
                    }
#line 249
                    if ((int )*p != 13) {
#line 249
                      if ((int )*p != 10) {
#line 249
                        if ((int )*p != 0) {
#line 250
                          q = buf___3;
                          {
#line 251
                          while (1) {
                            while_continue___15: /* CIL Label */ ;
#line 251
                            if ((int )*p != 32) {
#line 251
                              if ((int )*p != 13) {
#line 251
                                if ((int )*p != 10) {
#line 251
                                  if (! ((int )*p != 0)) {
#line 251
                                    goto while_break___15;
                                  }
                                } else {
#line 251
                                  goto while_break___15;
                                }
                              } else {
#line 251
                                goto while_break___15;
                              }
                            } else {
#line 251
                              goto while_break___15;
                            }
#line 251
                            tmp___4 = q;
#line 251
                            q ++;
#line 251
                            tmp___5 = p;
#line 251
                            p ++;
#line 251
                            *tmp___4 = *tmp___5;
                          }
                          while_break___15: /* CIL Label */ ;
                          }
#line 252
                          *q = (char )'\000';
#line 253
                          p = buf___3;
                        } else {
#line 255
                          p = (char *)((void *)0);
                        }
                      } else {
#line 255
                        p = (char *)((void *)0);
                      }
                    } else {
#line 255
                      p = (char *)((void *)0);
                    }
                    {
#line 258
                    tmp___6 = read_grammar(module_fp, & new_dfa, & new_winfo, (cur->am)->hmminfo,
                                           cur);
                    }
#line 258
                    if ((int )tmp___6 == 0) {
                      {
#line 259
                      module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"WRONG DATA\"/>\n.\n");
                      }
                    } else
#line 261
                    if (cur->lmtype == 2) {
                      {
#line 263
                      multigram_delete_all(cur->lm);
#line 265
                      multigram_add(new_dfa, new_winfo, p, cur->lm);
#line 268
                      schedule_grammar_update(recog);
#line 270
                      cur->active = (short)1;
#line 272
                      module_send(module_sd, (char *)"<GRAMMAR STATUS=\"RECEIVED\"/>\n.\n");
#line 273
                      send_gram_info(cur);
                      }
                    } else {
                      {
#line 275
                      module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
                      }
                    }
                  }
                } else {
                  {
#line 243
                  send_gram_info(cur);
                  }
                }
              } else {
                {
#line 227
                tmp = myfgets(buf___3, 4096, module_fp);
                }
#line 227
                if ((unsigned long )tmp == (unsigned long )((void *)0)) {
                  {
#line 230
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(INPUTONCHANGE): no argument\n");
                  }
#line 231
                  return;
                }
                {
#line 233
                tmp___2 = strcmp((char const   *)(buf___3), "TERMINATE");
                }
#line 233
                if (tmp___2) {
                  {
#line 235
                  tmp___1 = strcmp((char const   *)(buf___3), "PAUSE");
                  }
#line 235
                  if (tmp___1) {
                    {
#line 237
                    tmp___0 = strcmp((char const   *)(buf___3), "WAIT");
                    }
#line 237
                    if (tmp___0) {
                      {
#line 240
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: msock(INPUTONCHANGE): unknown method [%s]\n",
                              buf___3);
#line 240
                      exit(-1);
                      }
                    } else {
#line 238
                      recog->gram_switch_input_method = (short)2;
                    }
                  } else {
#line 236
                    recog->gram_switch_input_method = (short)1;
                  }
                } else {
#line 234
                  recog->gram_switch_input_method = (short)0;
                }
              }
            } else {
              {
#line 224
              j_request_resume(recog);
              }
            }
          } else {
            {
#line 222
            j_request_terminate(recog);
            }
          }
        } else {
          {
#line 220
          j_request_pause(recog);
          }
        }
      } else {
        {
#line 216
        module_send(module_sd, (char *)"<ENGINEINFO TYPE=\"%s\" VERSION=\"%s\" CONF=\"%s\"/>\n.\n",
                    "JuliusLib", "4.2.2", "fast");
        }
      }
    } else {
      {
#line 205
      close_socket(module_sd);
#line 206
      module_sd = -1;
      }
    }
  } else
#line 198
  if (recog->process_active) {
    {
#line 199
    module_send(module_sd, (char *)"<SYSINFO PROCESS=\"ACTIVE\"/>\n.\n");
    }
  } else {
    {
#line 201
    module_send(module_sd, (char *)"<SYSINFO PROCESS=\"SLEEP\"/>\n.\n");
    }
  }
#line 657
  return;
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void msock_check_and_process_command(Recog *recog , void *dummy ) 
{ 
  fd_set rfds ;
  int ret ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 679
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 679
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 680
  rfds.__fds_bits[module_sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << module_sd % (8 * (int )sizeof(__fd_mask ));
#line 681
  tv.tv_sec = (__time_t )0;
#line 682
  tv.tv_usec = (__suseconds_t )0;
#line 683
  ret = select(module_sd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 684
  if (ret < 0) {
    {
#line 685
    perror("msock_check_and_process_command: cannot poll\n");
    }
  }
#line 687
  if (ret > 0) {
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 690
      tmp = select(module_sd + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 690
      if (tmp > 0) {
        {
#line 690
        tmp___0 = myfgets(mbuf, 4096, module_fp);
        }
#line 690
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 690
          goto while_break___0;
        }
      } else {
#line 690
        goto while_break___0;
      }
      {
#line 693
      msock_exec_command(mbuf, recog);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 696
  return;
}
}
#line 713 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void msock_process_command(Recog *recog , void *dummy ) 
{ 
  char *tmp ;

  {
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! (! recog->process_active)) {
#line 717
      goto while_break;
    }
    {
#line 718
    tmp = myfgets(mbuf, 4096, module_fp);
    }
#line 718
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
      {
#line 721
      msock_exec_command(mbuf, recog);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return;
}
}
#line 726 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static void module_regist_callback(Recog *recog , void *data ) 
{ 


  {
  {
#line 729
  callback_add(recog, 0, & msock_check_and_process_command, data);
#line 730
  callback_add(recog, 29, & msock_process_command, data);
  }
#line 731
  return;
}
}
#line 734 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static boolean opt_module(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 737
  module_mode = 1;
#line 738
  if (argnum > 0) {
    {
#line 739
    module_port = atoi((char const   *)*(arg + 0));
    }
  }
#line 741
  return ((boolean )1);
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
static boolean opt_outcode(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 747
  decode_output_selection(*(arg + 0));
  }
#line 748
  return ((boolean )1);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
void module_add_option(void) 
{ 


  {
  {
#line 754
  j_add_option((char *)"-module", 1, 0, (char *)"run as a server module", & opt_module);
#line 755
  j_add_option((char *)"-outcode", 1, 1, (char *)"select info to output to the module: WLPSCwlps",
               & opt_outcode);
  }
#line 756
  return;
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
boolean is_module_mode(void) 
{ 


  {
#line 761
  return ((boolean )module_mode);
}
}
#line 764 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
void module_setup(Recog *recog , void *data ) 
{ 


  {
  {
#line 768
  module_regist_callback(recog, data);
#line 769
  setup_output_msock(recog, data);
  }
#line 770
  return;
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
void module_server(void) 
{ 
  int listen_sd ;

  {
  {
#line 781
  listen_sd = ready_as_server(module_port);
  }
#line 781
  if (listen_sd < 0) {
    {
#line 782
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: failed to bind socket\n");
    }
#line 783
    return;
  }
  {
#line 786
  printf((char const   */* __restrict  */)"///////////////////////////////\n");
#line 787
  printf((char const   */* __restrict  */)"///  Module mode ready\n");
#line 788
  printf((char const   */* __restrict  */)"///  waiting client at %5d\n", module_port);
#line 789
  printf((char const   */* __restrict  */)"///////////////////////////////\n");
#line 790
  printf((char const   */* __restrict  */)"///  ");
#line 793
  module_sd = accept_from(listen_sd);
  }
#line 793
  if (module_sd < 0) {
    {
#line 794
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: failed to accept connection\n");
    }
#line 795
    return;
  }
  {
#line 808
  module_fp = fdopen(module_sd, "r+");
  }
#line 808
  if ((unsigned long )module_fp == (unsigned long )((void *)0)) {
    {
#line 809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error; failed to fdopen socket\n");
    }
#line 810
    return;
  }
#line 813
  return;
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/module.c"
void module_disconnect(void) 
{ 


  {
#line 819
  if (module_sd >= 0) {
    {
#line 820
    module_send(module_sd, (char *)"<SYSINFO PROCESS=\"ERREXIT\"/>\n.\n");
#line 821
    close_socket(module_sd);
#line 822
    module_sd = -1;
    }
  }
#line 824
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_process_online___0(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 48
  module_send(module_sd, (char *)"<STARTPROC/>\n.\n");
  }
#line 49
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_process_offline___0(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 63
  module_send(module_sd, (char *)"<STOPPROC/>\n.\n");
  }
#line 64
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out1_word  =    (boolean )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out1_lm  =    (boolean )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out1_phone  =    (boolean )0;
#line 69 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out1_score  =    (boolean )0;
#line 70 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_word  =    (boolean )1;
#line 70 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_lm  =    (boolean )1;
#line 70 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_phone  =    (boolean )1;
#line 70 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_score  =    (boolean )1;
#line 71 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out1_never  =    (boolean )1;
#line 71 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_never  =    (boolean )0;
#line 73 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static boolean out2_cm  =    (boolean )1;
#line 88 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
void decode_output_selection(char *str ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 92
  out1_score = (boolean )0;
#line 92
  out1_phone = out1_score;
#line 92
  out1_lm = out1_phone;
#line 92
  out1_word = out1_lm;
#line 93
  out2_score = (boolean )0;
#line 93
  out2_phone = out2_score;
#line 93
  out2_lm = out2_phone;
#line 93
  out2_word = out2_lm;
#line 95
  out2_cm = (boolean )0;
#line 97
  tmp = strlen((char const   *)str);
#line 97
  i = (int )(tmp - 1UL);
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i >= 0)) {
#line 97
      goto while_break;
    }
    {
#line 99
    if ((int )*(str + i) == 87) {
#line 99
      goto case_87;
    }
#line 100
    if ((int )*(str + i) == 76) {
#line 100
      goto case_76;
    }
#line 101
    if ((int )*(str + i) == 80) {
#line 101
      goto case_80;
    }
#line 102
    if ((int )*(str + i) == 83) {
#line 102
      goto case_83;
    }
#line 103
    if ((int )*(str + i) == 119) {
#line 103
      goto case_119;
    }
#line 104
    if ((int )*(str + i) == 108) {
#line 104
      goto case_108;
    }
#line 105
    if ((int )*(str + i) == 112) {
#line 105
      goto case_112;
    }
#line 106
    if ((int )*(str + i) == 115) {
#line 106
      goto case_115;
    }
#line 108
    if ((int )*(str + i) == 67) {
#line 108
      goto case_67;
    }
#line 110
    goto switch_default;
    case_87: /* CIL Label */ 
#line 99
    out2_word = (boolean )1;
#line 99
    goto switch_break;
    case_76: /* CIL Label */ 
#line 100
    out2_lm = (boolean )1;
#line 100
    goto switch_break;
    case_80: /* CIL Label */ 
#line 101
    out2_phone = (boolean )1;
#line 101
    goto switch_break;
    case_83: /* CIL Label */ 
#line 102
    out2_score = (boolean )1;
#line 102
    goto switch_break;
    case_119: /* CIL Label */ 
#line 103
    out1_word = (boolean )1;
#line 103
    goto switch_break;
    case_108: /* CIL Label */ 
#line 104
    out1_lm = (boolean )1;
#line 104
    goto switch_break;
    case_112: /* CIL Label */ 
#line 105
    out1_phone = (boolean )1;
#line 105
    goto switch_break;
    case_115: /* CIL Label */ 
#line 106
    out1_score = (boolean )1;
#line 106
    goto switch_break;
    case_67: /* CIL Label */ 
#line 108
    out2_cm = (boolean )1;
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: unknown outcode `%c\', ignored\n",
            (int )*(str + i));
    }
#line 112
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 97
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  out1_never = (boolean )(! ((((int )out1_word | (int )out1_lm) | (int )out1_phone) | (int )out1_score));
#line 116
  out2_never = (boolean )(! (((((int )out2_word | (int )out2_lm) | (int )out2_phone) | (int )out2_score) | (int )out2_cm));
#line 122
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static char buf___4[256]  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void msock_word_out1(WORD_ID w , RecogProcess *r ) 
{ 
  int j ;
  WORD_INFO *winfo___0 ;

  {
#line 145
  winfo___0 = (r->lm)->winfo;
#line 147
  if (out1_word) {
    {
#line 148
    module_send(module_sd, (char *)" WORD=\"%s\"", *(winfo___0->woutput + w));
    }
  }
#line 150
  if (out1_lm) {
    {
#line 151
    module_send(module_sd, (char *)" CLASSID=\"%s\"", *(winfo___0->wname + w));
    }
  }
#line 153
  if (out1_phone) {
    {
#line 154
    module_send(module_sd, (char *)" PHONE=\"");
#line 155
    j = 0;
    }
    {
#line 155
    while (1) {
      while_continue: /* CIL Label */ ;
#line 155
      if (! (j < (int )*(winfo___0->wlen + w))) {
#line 155
        goto while_break;
      }
      {
#line 156
      center_name((*(*(winfo___0->wseq + w) + j))->name, buf___4);
      }
#line 157
      if (j == 0) {
        {
#line 157
        module_send(module_sd, (char *)"%s", buf___4);
        }
      } else {
        {
#line 158
        module_send(module_sd, (char *)" %s", buf___4);
        }
      }
#line 155
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 160
    module_send(module_sd, (char *)"\"");
    }
  }
#line 162
  return;
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static char buf___5[256]  ;
#line 178 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void msock_word_out2(WORD_ID w , RecogProcess *r ) 
{ 
  int j ;
  WORD_INFO *winfo___0 ;

  {
#line 185
  winfo___0 = (r->lm)->winfo;
#line 187
  if (out2_word) {
    {
#line 188
    module_send(module_sd, (char *)" WORD=\"%s\"", *(winfo___0->woutput + w));
    }
  }
#line 190
  if (out2_lm) {
    {
#line 191
    module_send(module_sd, (char *)" CLASSID=\"%s\"", *(winfo___0->wname + w));
    }
  }
#line 193
  if (out2_phone) {
    {
#line 194
    module_send(module_sd, (char *)" PHONE=\"");
#line 195
    j = 0;
    }
    {
#line 195
    while (1) {
      while_continue: /* CIL Label */ ;
#line 195
      if (! (j < (int )*(winfo___0->wlen + w))) {
#line 195
        goto while_break;
      }
      {
#line 196
      center_name((*(*(winfo___0->wseq + w) + j))->name, buf___5);
      }
#line 197
      if (j == 0) {
        {
#line 197
        module_send(module_sd, (char *)"%s", buf___5);
        }
      } else {
        {
#line 198
        module_send(module_sd, (char *)" %s", buf___5);
        }
      }
#line 195
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 200
    module_send(module_sd, (char *)"\"");
    }
  }
#line 202
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_pass1_begin___0(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 221
  module_send(module_sd, (char *)"<STARTRECOG/>\n.\n");
  }
#line 222
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void result_pass1_current___0(Recog *recog , void *dummy ) 
{ 
  int i ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  int num ;
  RecogProcess *r ;
  boolean multi ;
  time_t tmp ;
  time_t tmp___0 ;

  {
#line 256
  if (out1_never) {
#line 256
    return;
  }
#line 258
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 258
    multi = (boolean )1;
  } else {
#line 259
    multi = (boolean )0;
  }
#line 261
  r = recog->process_list;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! r) {
#line 261
      goto while_break;
    }
#line 262
    if (! r->live) {
#line 262
      goto __Cont;
    }
#line 263
    if (! r->have_interim) {
#line 263
      goto __Cont;
    }
#line 265
    winfo___0 = (r->lm)->winfo;
#line 266
    seq = r->result.pass1.word;
#line 267
    num = r->result.pass1.word_num;
#line 269
    if (multi) {
      {
#line 270
      module_send(module_sd, (char *)"<RECOGOUT ID=\"SR%02d\" NAME=\"%s\">\n", (int )(r->config)->id,
                  (r->config)->name);
      }
    } else {
      {
#line 272
      module_send(module_sd, (char *)"<RECOGOUT>\n");
      }
    }
#line 274
    if (out1_score) {
      {
#line 275
      tmp = time((time_t *)((void *)0));
#line 275
      module_send(module_sd, (char *)"  <PHYPO PASS=\"1\" SCORE=\"%f\" FRAME=\"%d\" TIME=\"%ld\"/>\n",
                  (double )r->result.pass1.score, r->result.num_frame, tmp);
      }
    } else {
      {
#line 277
      tmp___0 = time((time_t *)((void *)0));
#line 277
      module_send(module_sd, (char *)"  <PHYPO PASS=\"1\" FRAME=\"%d\" TIME=\"%ld\"/>\n",
                  r->result.num_frame, tmp___0);
      }
    }
#line 279
    i = 0;
    {
#line 279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 279
      if (! (i < num)) {
#line 279
        goto while_break___0;
      }
      {
#line 280
      module_send(module_sd, (char *)"    <WHYPO");
#line 281
      msock_word_out1(*(seq + i), r);
#line 282
      module_send(module_sd, (char *)"/>\n");
#line 279
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 284
    module_send(module_sd, (char *)"  </PHYPO>\n</RECOGOUT>\n.\n");
    }
    __Cont: /* CIL Label */ 
#line 261
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void result_pass1_final(Recog *recog , void *dummy ) 
{ 
  int i ;
  RecogProcess *r ;
  boolean multi ;

  {
#line 318
  if (out1_never) {
#line 318
    return;
  }
#line 320
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 320
    multi = (boolean )1;
  } else {
#line 321
    multi = (boolean )0;
  }
#line 323
  r = recog->process_list;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! r) {
#line 323
      goto while_break;
    }
#line 324
    if (! r->live) {
#line 324
      goto __Cont;
    }
#line 325
    if (r->result.status < 0) {
#line 325
      goto __Cont;
    }
#line 327
    if (multi) {
      {
#line 328
      module_send(module_sd, (char *)"<RECOGOUT ID=\"SR%02d\" NAME=\"%s\">\n", (int )(r->config)->id,
                  (r->config)->name);
      }
    } else {
      {
#line 330
      module_send(module_sd, (char *)"<RECOGOUT>\n");
      }
    }
#line 332
    if (out1_score) {
      {
#line 333
      module_send(module_sd, (char *)"  <SHYPO PASS=\"1\" SCORE=\"%f\">\n", (double )r->result.pass1.score);
      }
    } else {
      {
#line 335
      module_send(module_sd, (char *)"  <SHYPO PASS=\"1\">\n", (double )r->result.pass1.score);
      }
    }
#line 337
    i = 0;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if (! (i < r->result.pass1.word_num)) {
#line 337
        goto while_break___0;
      }
      {
#line 338
      module_send(module_sd, (char *)"    <WHYPO");
#line 339
      msock_word_out1(r->result.pass1.word[i], r);
#line 340
      module_send(module_sd, (char *)"/>\n");
#line 337
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 342
    module_send(module_sd, (char *)"  </SHYPO>\n</RECOGOUT>\n.\n");
    }
    __Cont: /* CIL Label */ 
#line 323
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 344
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_pass1_end___0(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 359
  module_send(module_sd, (char *)"<ENDRECOG/>\n.\n");
  }
#line 360
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void result_pass2___0(Recog *recog , void *dummy ) 
{ 
  int i ;
  int n ;
  int num ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  int seqnum ;
  Sentence *s ;
  RecogProcess *r ;
  boolean multi ;
  SentenceAlign *align ;

  {
#line 393
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 393
    multi = (boolean )1;
  } else {
#line 394
    multi = (boolean )0;
  }
#line 396
  r = recog->process_list;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! r) {
#line 396
      goto while_break;
    }
#line 397
    if (! r->live) {
#line 397
      goto __Cont;
    }
#line 399
    if (r->result.status < 0) {
      {
#line 401
      if (r->result.status == -6) {
#line 401
        goto case_neg_6;
      }
#line 404
      if (r->result.status == -5) {
#line 404
        goto case_neg_5;
      }
#line 407
      if (r->result.status == -4) {
#line 407
        goto case_neg_4;
      }
#line 410
      if (r->result.status == -3) {
#line 410
        goto case_neg_3;
      }
#line 413
      if (r->result.status == -2) {
#line 413
        goto case_neg_2;
      }
#line 416
      if (r->result.status == -1) {
#line 416
        goto case_neg_1;
      }
#line 400
      goto switch_break;
      case_neg_6: /* CIL Label */ 
      {
#line 402
      module_send(module_sd, (char *)"<REJECTED REASON=\"by power\"");
      }
#line 403
      goto switch_break;
      case_neg_5: /* CIL Label */ 
      {
#line 405
      module_send(module_sd, (char *)"<REJECTED REASON=\"input terminated by request\"");
      }
#line 406
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 408
      module_send(module_sd, (char *)"<REJECTED REASON=\"result has pause words only\"");
      }
#line 409
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 411
      module_send(module_sd, (char *)"<REJECTED REASON=\"by GMM\"");
      }
#line 412
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 414
      module_send(module_sd, (char *)"<REJECTED REASON=\"too short input\"");
      }
#line 415
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 417
      module_send(module_sd, (char *)"<RECOGFAIL");
      }
#line 418
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 420
      if (multi) {
        {
#line 421
        module_send(module_sd, (char *)" ID=\"SR%02d\" NAME=\"%s\"", (int )(r->config)->id,
                    (r->config)->name);
        }
      }
      {
#line 423
      module_send(module_sd, (char *)"/>\n.\n");
      }
#line 424
      goto __Cont;
    }
#line 427
    if (out2_never) {
#line 427
      goto __Cont;
    }
#line 429
    winfo___0 = (r->lm)->winfo;
#line 430
    num = r->result.sentnum;
#line 432
    if (multi) {
      {
#line 433
      module_send(module_sd, (char *)"<RECOGOUT ID=\"SR%02d\" NAME=\"%s\">\n", (int )(r->config)->id,
                  (r->config)->name);
      }
    } else {
      {
#line 435
      module_send(module_sd, (char *)"<RECOGOUT>\n");
      }
    }
#line 437
    n = 0;
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! (n < num)) {
#line 437
        goto while_break___0;
      }
      {
#line 438
      s = r->result.sent + n;
#line 439
      seq = s->word;
#line 440
      seqnum = s->word_num;
#line 442
      module_send(module_sd, (char *)"  <SHYPO RANK=\"%d\"", n + 1);
      }
#line 443
      if (out2_score) {
        {
#line 444
        module_send(module_sd, (char *)" SCORE=\"%f\"", (double )s->score);
        }
#line 445
        if (r->lmtype == 1) {
#line 446
          if (separate_score_flag) {
            {
#line 447
            module_send(module_sd, (char *)" AMSCORE=\"%f\" LMSCORE=\"%f\"", (double )s->score_am,
                        (double )s->score_lm);
            }
          }
        }
      }
#line 451
      if (r->lmtype == 2) {
        {
#line 453
        module_send(module_sd, (char *)" GRAM=\"%d\"", s->gram_id);
        }
      }
      {
#line 456
      module_send(module_sd, (char *)">\n");
#line 457
      i = 0;
      }
      {
#line 457
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 457
        if (! (i < seqnum)) {
#line 457
          goto while_break___1;
        }
        {
#line 458
        module_send(module_sd, (char *)"    <WHYPO");
#line 459
        msock_word_out2(*(seq + i), r);
        }
#line 464
        if (out2_cm) {
          {
#line 465
          module_send(module_sd, (char *)" CM=\"%5.3f\"", (double )s->confidence[i]);
          }
        }
#line 470
        align = s->align;
        {
#line 470
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 470
          if (! align) {
#line 470
            goto while_break___2;
          }
          {
#line 472
          if ((int )align->unittype == 0) {
#line 472
            goto case_0;
          }
#line 476
          if ((int )align->unittype == 2) {
#line 476
            goto case_2;
          }
#line 476
          if ((int )align->unittype == 1) {
#line 476
            goto case_2;
          }
#line 471
          goto switch_break___0;
          case_0: /* CIL Label */ 
          {
#line 473
          module_send(module_sd, (char *)" BEGINFRAME=\"%d\" ENDFRAME=\"%d\"", *(align->begin_frame + i),
                      *(align->end_frame + i));
          }
#line 474
          goto switch_break___0;
          case_2: /* CIL Label */ 
          case_1: /* CIL Label */ 
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"-palign\" and \"-salign\" does not supported for module output\n");
          }
#line 478
          goto switch_break___0;
          switch_break___0: /* CIL Label */ ;
          }
#line 470
          align = align->next;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 482
        module_send(module_sd, (char *)"/>\n");
#line 457
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 484
      module_send(module_sd, (char *)"  </SHYPO>\n");
#line 437
      n ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 486
    module_send(module_sd, (char *)"</RECOGOUT>\n.\n");
    }
    __Cont: /* CIL Label */ 
#line 396
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void result_graph___0(Recog *recog , void *dummy ) 
{ 
  WordGraph *wg ;
  int i ;
  int nodenum ;
  int arcnum ;
  WORD_INFO *winfo___0 ;
  WordGraph *root___0 ;
  RecogProcess *r ;
  boolean multi ;

  {
#line 521
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 521
    multi = (boolean )1;
  } else {
#line 522
    multi = (boolean )0;
  }
#line 524
  r = recog->process_list;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if (! r) {
#line 524
      goto while_break;
    }
#line 525
    if (! r->live) {
#line 525
      goto __Cont;
    }
#line 526
    if ((unsigned long )r->result.wg == (unsigned long )((void *)0)) {
#line 526
      goto __Cont;
    }
#line 528
    winfo___0 = (r->lm)->winfo;
#line 529
    root___0 = r->result.wg;
#line 530
    nodenum = r->graph_totalwordnum;
#line 531
    arcnum = 0;
#line 532
    wg = root___0;
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 532
      if (! wg) {
#line 532
        goto while_break___0;
      }
#line 533
      arcnum += wg->rightwordnum;
#line 532
      wg = wg->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 536
    module_send(module_sd, (char *)"<GRAPHOUT");
    }
#line 537
    if (multi) {
      {
#line 537
      module_send(module_sd, (char *)" ID=\"SR%02d\" NAME=\"%s\"", (int )(r->config)->id,
                  (r->config)->name);
      }
    }
    {
#line 538
    module_send(module_sd, (char *)" NODENUM=\"%d\" ARCNUM=\"%d\">\n", nodenum, arcnum);
#line 539
    wg = root___0;
    }
    {
#line 539
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 539
      if (! wg) {
#line 539
        goto while_break___1;
      }
      {
#line 540
      module_send(module_sd, (char *)"    <NODE GID=\"%d\"", wg->id);
#line 541
      msock_word_out2(wg->wid, r);
#line 542
      module_send(module_sd, (char *)" BEGIN=\"%d\"", wg->lefttime);
#line 543
      module_send(module_sd, (char *)" END=\"%d\"", wg->righttime);
#line 544
      module_send(module_sd, (char *)"/>\n");
#line 539
      wg = wg->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 546
    wg = root___0;
    {
#line 546
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 546
      if (! wg) {
#line 546
        goto while_break___2;
      }
#line 547
      i = 0;
      {
#line 547
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 547
        if (! (i < wg->rightwordnum)) {
#line 547
          goto while_break___3;
        }
        {
#line 548
        module_send(module_sd, (char *)"    <ARC FROM=\"%d\" TO=\"%d\"/>\n", wg->id,
                    (*(wg->rightword + i))->id);
#line 547
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 546
      wg = wg->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 551
    module_send(module_sd, (char *)"</GRAPHOUT>\n.\n");
    }
    __Cont: /* CIL Label */ 
#line 524
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return;
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_recready___0(Recog *recog , void *dummy ) 
{ 
  time_t tmp ;

  {
  {
#line 568
  tmp = time((time_t *)((void *)0));
#line 568
  module_send(module_sd, (char *)"<INPUT STATUS=\"LISTEN\" TIME=\"%ld\"/>\n.\n", tmp);
  }
#line 569
  return;
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_recstart___0(Recog *recog , void *dummy ) 
{ 
  time_t tmp ;

  {
  {
#line 584
  tmp = time((time_t *)((void *)0));
#line 584
  module_send(module_sd, (char *)"<INPUT STATUS=\"STARTREC\" TIME=\"%ld\"/>\n.\n",
              tmp);
  }
#line 585
  return;
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_recend___0(Recog *recog , void *dummy ) 
{ 
  time_t tmp ;

  {
  {
#line 599
  tmp = time((time_t *)((void *)0));
#line 599
  module_send(module_sd, (char *)"<INPUT STATUS=\"ENDREC\" TIME=\"%ld\"/>\n.\n", tmp);
  }
#line 600
  return;
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void status_param___0(Recog *recog , void *dummy ) 
{ 
  MFCCCalc *mfcc ;
  boolean multi ;
  int frames ;
  int msec ;

  {
#line 621
  if ((unsigned long )(recog->mfcclist)->next != (unsigned long )((void *)0)) {
#line 621
    multi = (boolean )1;
  } else {
#line 622
    multi = (boolean )0;
  }
#line 624
  mfcc = recog->mfcclist;
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! mfcc) {
#line 624
      goto while_break;
    }
#line 625
    frames = (int )(mfcc->param)->samplenum;
#line 626
    msec = (int )((double )(((float )(mfcc->param)->samplenum * (float )(recog->jconf)->input.period) * (float )(recog->jconf)->input.frameshift) / 10000.0);
#line 627
    if (multi) {
      {
#line 628
      module_send(module_sd, (char *)"<INPUTPARAM MFCCID=\"%02d\" FRAMES=\"%d\" MSEC=\"%d\"/>\n.\n",
                  (int )mfcc->id, frames, msec);
      }
    } else {
      {
#line 630
      module_send(module_sd, (char *)"<INPUTPARAM FRAMES=\"%d\" MSEC=\"%d\"/>\n.\n",
                  frames, msec);
      }
    }
#line 624
    mfcc = mfcc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
static void result_gmm___0(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 648
  module_send(module_sd, (char *)"<GMM RESULT=\"%s\"", ((recog->gc)->max_d)->name);
#line 650
  module_send(module_sd, (char *)" CMSCORE=\"%f\"", (double )(recog->gc)->gmm_max_cm);
#line 652
  module_send(module_sd, (char *)"/>\n.\n");
  }
#line 653
  return;
}
}
#line 665 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
void send_gram_info(RecogProcess *r ) 
{ 
  MULTIGRAM *m ;
  char buf___13[1024] ;
  char const   *tmp ;

  {
#line 671
  if (r->lmtype == 1) {
    {
#line 672
    module_send(module_sd, (char *)"<GRAMMAR STATUS=\"ERROR\" REASON=\"NOT A GRAMMAR-BASED LM\"/>\n.\n");
    }
#line 673
    return;
  }
  {
#line 675
  module_send(module_sd, (char *)"<GRAMINFO>\n");
#line 676
  m = (r->lm)->grammars;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! m) {
#line 676
      goto while_break;
    }
#line 677
    buf___13[0] = (char )'\000';
#line 678
    if (m->dfa) {
      {
#line 679
      snprintf((char */* __restrict  */)(buf___13), (size_t )1024, (char const   */* __restrict  */)", %3d categories, %4d nodes",
               (m->dfa)->term_num, (m->dfa)->state_num);
      }
    }
#line 682
    if (m->newbie) {
      {
#line 682
      strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" (new)");
      }
    }
#line 683
    if (m->hook != 0) {
      {
#line 684
      strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" (next:");
      }
#line 685
      if (m->hook & 1) {
        {
#line 686
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" delete");
        }
      }
#line 688
      if (m->hook & 2) {
        {
#line 689
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" activate");
        }
      }
#line 691
      if (m->hook & 4) {
        {
#line 692
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" deactivate");
        }
      }
#line 694
      if (m->hook & 8) {
        {
#line 695
        strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)" modified");
        }
      }
      {
#line 697
      strcat((char */* __restrict  */)(buf___13), (char const   */* __restrict  */)")");
      }
    }
#line 699
    if (m->active) {
#line 699
      tmp = "active";
    } else {
#line 699
      tmp = "inactive";
    }
    {
#line 699
    module_send(module_sd, (char *)"  #%2d: [%-11s] %4d words%s \"%s\"\n", (int )m->id,
                tmp, (int )(m->winfo)->num, buf___13, m->name);
#line 676
    m = m->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 706
  if ((unsigned long )(r->lm)->dfa != (unsigned long )((void *)0)) {
    {
#line 707
    module_send(module_sd, (char *)"  Global:            %4d words, %3d categories, %4d nodes\n",
                (int )((r->lm)->winfo)->num, ((r->lm)->dfa)->term_num, ((r->lm)->dfa)->state_num);
    }
  }
  {
#line 709
  module_send(module_sd, (char *)"</GRAMINFO>\n.\n");
  }
#line 710
  return;
}
}
#line 724 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_module.c"
void setup_output_msock(Recog *recog , void *data ) 
{ 


  {
  {
#line 727
  callback_add(recog, 1, & status_process_online___0, data);
#line 728
  callback_add(recog, 2, & status_process_offline___0, data);
#line 731
  callback_add(recog, 5, & status_recready___0, data);
#line 732
  callback_add(recog, 6, & status_recstart___0, data);
#line 733
  callback_add(recog, 7, & status_recend___0, data);
#line 734
  callback_add(recog, 12, & status_pass1_begin___0, data);
#line 735
  callback_add(recog, 14, & status_pass1_end___0, data);
#line 736
  callback_add(recog, 15, & result_pass1_current___0, data);
#line 737
  callback_add(recog, 16, & result_pass1_final, data);
#line 739
  callback_add(recog, 18, & status_param___0, data);
#line 741
  callback_add(recog, 21, & result_pass2___0, data);
#line 742
  callback_add(recog, 22, & result_gmm___0, data);
#line 744
  callback_add(recog, 23, & result_graph___0, data);
  }
#line 749
  return;
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.h"
void charconv_add_option(void) ;
#line 5
boolean charconv_setup(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static boolean convert_enabled  =    (boolean )0;
#line 46 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static boolean charconv_setup_real(char *fromcode , char *tocode ) 
{ 
  boolean enabled ;
  boolean ret ;

  {
  {
#line 54
  ret = charconv_iconv_setup(fromcode, tocode, & enabled);
#line 64
  convert_enabled = enabled;
  }
#line 67
  return (ret);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
char *charconv(char *instr , char *outstr , int maxoutlen ) 
{ 
  char *ret ;

  {
#line 86
  if ((int )convert_enabled == 0) {
#line 86
    return (instr);
  }
  {
#line 90
  ret = charconv_iconv(instr, outstr, maxoutlen);
  }
#line 101
  return (ret);
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static char *from_code  =    (char *)((void *)0);
#line 109 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static char *to_code  =    (char *)((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static boolean opt_charconv(Jconf *jconf , char **arg , int argnum ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 115
  if (from_code) {
    {
#line 115
    free((void *)from_code);
    }
  }
#line 116
  if (to_code) {
    {
#line 116
    free((void *)to_code);
    }
  }
  {
#line 117
  tmp = strlen((char const   *)*(arg + 0));
#line 117
  tmp___0 = mymalloc(tmp + 1UL);
#line 117
  from_code = strcpy((char */* __restrict  */)((char *)tmp___0), (char const   */* __restrict  */)*(arg + 0));
#line 118
  tmp___1 = strlen((char const   *)*(arg + 1));
#line 118
  tmp___2 = mymalloc(tmp___1 + 1UL);
#line 118
  to_code = strcpy((char */* __restrict  */)((char *)tmp___2), (char const   */* __restrict  */)*(arg + 1));
  }
#line 122
  return ((boolean )1);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static boolean opt_nocharconv(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 128
  if (from_code) {
    {
#line 128
    free((void *)from_code);
    }
  }
#line 129
  if (to_code) {
    {
#line 129
    free((void *)to_code);
    }
  }
#line 130
  from_code = (char *)((void *)0);
#line 131
  to_code = (char *)((void *)0);
#line 135
  return ((boolean )1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
static boolean opt_kanji(Jconf *jconf , char **arg , int argnum ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 141
  if (from_code) {
    {
#line 141
    free((void *)from_code);
    }
  }
#line 142
  if (to_code) {
    {
#line 142
    free((void *)to_code);
    }
  }
  {
#line 143
  from_code = (char *)((void *)0);
#line 144
  tmp___1 = strcmp((char const   *)*(arg + 0), "noconv");
  }
#line 144
  if (tmp___1) {
    {
#line 147
    tmp = strlen((char const   *)*(arg + 0));
#line 147
    tmp___0 = mymalloc(tmp + 1UL);
#line 147
    to_code = strcpy((char */* __restrict  */)((char *)tmp___0), (char const   */* __restrict  */)*(arg + 0));
    }
  } else {
#line 145
    to_code = (char *)((void *)0);
  }
#line 152
  return ((boolean )1);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
void charconv_add_option(void) 
{ 


  {
  {
#line 158
  j_add_option((char *)"-charconv", 2, 2, (char *)"convert character set for output",
               & opt_charconv);
#line 159
  j_add_option((char *)"-nocharconv", 0, 0, (char *)"disable charconv", & opt_nocharconv);
#line 160
  j_add_option((char *)"-kanji", 1, 1, (char *)"convert character set for output",
               & opt_kanji);
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/charconv.c"
boolean charconv_setup(void) 
{ 
  boolean tmp ;

  {
#line 167
  if ((unsigned long )from_code != (unsigned long )((void *)0)) {
#line 167
    if ((unsigned long )to_code != (unsigned long )((void *)0)) {
      {
#line 168
      tmp = charconv_setup_real(from_code, to_code);
      }
#line 168
      if ((int )tmp == 0) {
        {
#line 169
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: character set conversion setup failed\n");
        }
#line 170
        return ((boolean )0);
      }
    }
  }
#line 174
  return ((boolean )1);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/app.h"
void setup_output_file(Recog *recog , void *data ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static char fname[4096]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static FILE *fp___1  =    (FILE *)((void *)0);
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
void outfile_set_fname(char *input_filename ) 
{ 
  char *p___0 ;

  {
  {
#line 42
  strncpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)input_filename,
          (size_t )4096);
#line 43
  p___0 = strrchr((char const   *)(fname), '.');
  }
#line 43
  if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
#line 44
    *p___0 = (char )'\000';
  }
  {
#line 46
  strcat((char */* __restrict  */)(fname), (char const   */* __restrict  */)".out");
  }
#line 47
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_open(Recog *recog , void *dummy ) 
{ 


  {
  {
#line 52
  fp___1 = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"w");
  }
#line 52
  if ((unsigned long )fp___1 == (unsigned long )((void *)0)) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output_rec: failed to open \"%s\", result not saved\n",
            fname);
    }
#line 54
    return;
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_close(Recog *recog , void *dummy ) 
{ 


  {
#line 61
  if ((unsigned long )fp___1 != (unsigned long )((void *)0)) {
    {
#line 62
    fclose(fp___1);
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"result written to \"%s\"\n",
            fname);
    }
  }
#line 65
  fp___1 = (FILE *)((void *)0);
#line 66
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static char phbuf[256]  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_sentence(Recog *recog , void *dummy ) 
{ 
  RecogProcess *r ;
  Sentence *s ;
  WORD_INFO *winfo___0 ;
  WORD_ID *seq ;
  int seqnum ;
  int n ;
  int num ;
  int i ;
  int j ;
  boolean multi ;
  SentenceAlign *align ;
  HMM_Logical *p___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 83
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 83
    multi = (boolean )1;
  } else {
#line 84
    multi = (boolean )0;
  }
#line 86
  r = recog->process_list;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! r) {
#line 86
      goto while_break;
    }
#line 87
    if (! r->live) {
#line 87
      goto __Cont;
    }
#line 88
    if (multi) {
      {
#line 88
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[#%d %s]\n",
              (int )(r->config)->id, (r->config)->name);
      }
    }
#line 90
    if (r->result.status < 0) {
      {
#line 92
      if (r->result.status == -6) {
#line 92
        goto case_neg_6;
      }
#line 95
      if (r->result.status == -5) {
#line 95
        goto case_neg_5;
      }
#line 98
      if (r->result.status == -4) {
#line 98
        goto case_neg_4;
      }
#line 101
      if (r->result.status == -3) {
#line 101
        goto case_neg_3;
      }
#line 104
      if (r->result.status == -2) {
#line 104
        goto case_neg_2;
      }
#line 107
      if (r->result.status == -1) {
#line 107
        goto case_neg_1;
      }
#line 91
      goto switch_break;
      case_neg_6: /* CIL Label */ 
      {
#line 93
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<input rejected by power>\n");
      }
#line 94
      goto switch_break;
      case_neg_5: /* CIL Label */ 
      {
#line 96
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<input teminated by request>\n");
      }
#line 97
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 99
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<input rejected by decoder (silence input result)>\n");
      }
#line 100
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 102
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<input rejected by GMM>\n");
      }
#line 103
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 105
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<input rejected by short input>\n");
      }
#line 106
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 108
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"<search failed>\n");
      }
#line 109
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 111
      goto __Cont;
    }
#line 114
    winfo___0 = (r->lm)->winfo;
#line 115
    num = r->result.sentnum;
#line 117
    n = 0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (n < num)) {
#line 117
        goto while_break___0;
      }
      {
#line 118
      s = r->result.sent + n;
#line 119
      seq = s->word;
#line 120
      seqnum = s->word_num;
#line 122
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"sentence%d:",
              n + 1);
#line 123
      i = 0;
      }
      {
#line 123
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 123
        if (! (i < seqnum)) {
#line 123
          goto while_break___1;
        }
        {
#line 124
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" %s",
                *(winfo___0->woutput + *(seq + i)));
#line 123
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 126
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 128
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"wseq%d:",
              n + 1);
#line 129
      i = 0;
      }
      {
#line 129
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 129
        if (! (i < seqnum)) {
#line 129
          goto while_break___2;
        }
        {
#line 130
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" %s",
                *(winfo___0->wname + *(seq + i)));
#line 129
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 132
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 134
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"phseq%d:",
              n + 1);
#line 135
      i = 0;
      }
      {
#line 135
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 135
        if (! (i < seqnum)) {
#line 135
          goto while_break___3;
        }
#line 136
        if (i > 0) {
          {
#line 136
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" |");
          }
        }
#line 137
        j = 0;
        {
#line 137
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 137
          if (! (j < (int )*(winfo___0->wlen + *(seq + i)))) {
#line 137
            goto while_break___4;
          }
          {
#line 138
          center_name((*(*(winfo___0->wseq + *(seq + i)) + j))->name, phbuf);
#line 139
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" %s",
                  phbuf);
#line 137
          j ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 135
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 142
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 145
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"cmscore%d:",
              n + 1);
#line 146
      i = 0;
      }
      {
#line 146
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 146
        if (! (i < seqnum)) {
#line 146
          goto while_break___5;
        }
        {
#line 147
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" %5.3f",
                (double )s->confidence[i]);
#line 146
        i ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 149
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 151
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"score%d: %f",
              n + 1, (double )s->score);
      }
#line 152
      if (r->lmtype == 1) {
        {
#line 153
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" (AM: %f  LM: %f)",
                (double )s->score_am, (double )s->score_lm);
        }
      }
      {
#line 155
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
      }
#line 156
      if (r->lmtype == 2) {
        {
#line 157
        tmp = multigram_get_all_num(r->lm);
        }
#line 157
        if (tmp > 1) {
          {
#line 158
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"grammar%d: %d\n",
                  n + 1, s->gram_id);
          }
        }
      }
#line 162
      align = s->align;
      {
#line 162
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 162
        if (! align) {
#line 162
          goto while_break___6;
        }
        {
#line 163
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"=== begin forced alignment ===\n");
        }
        {
#line 165
        if ((int )align->unittype == 0) {
#line 165
          goto case_0;
        }
#line 167
        if ((int )align->unittype == 1) {
#line 167
          goto case_1;
        }
#line 169
        if ((int )align->unittype == 2) {
#line 169
          goto case_2;
        }
#line 164
        goto switch_break___0;
        case_0: /* CIL Label */ 
        {
#line 166
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-- word alignment --\n");
        }
#line 166
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 168
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-- phoneme alignment --\n");
        }
#line 168
        goto switch_break___0;
        case_2: /* CIL Label */ 
        {
#line 170
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-- state alignment --\n");
        }
#line 170
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 172
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" id: from  to    n_score    unit\n");
#line 173
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" ----------------------------------------\n");
#line 174
        i = 0;
        }
        {
#line 174
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 174
          if (! (i < align->num)) {
#line 174
            goto while_break___7;
          }
          {
#line 175
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[%4d %4d]  %f  ",
                  *(align->begin_frame + i), *(align->end_frame + i), (double )*(align->avgscore + i));
          }
          {
#line 177
          if ((int )align->unittype == 0) {
#line 177
            goto case_0___0;
          }
#line 180
          if ((int )align->unittype == 1) {
#line 180
            goto case_1___0;
          }
#line 190
          if ((int )align->unittype == 2) {
#line 190
            goto case_2___0;
          }
#line 176
          goto switch_break___1;
          case_0___0: /* CIL Label */ 
          {
#line 178
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%s\t[%s]\n",
                  *(winfo___0->wname + *(align->w + i)), *(winfo___0->woutput + *(align->w + i)));
          }
#line 179
          goto switch_break___1;
          case_1___0: /* CIL Label */ 
#line 181
          p___0 = *(align->ph + i);
#line 182
          if (p___0->is_pseudo) {
            {
#line 183
            fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"{%s}\n",
                    p___0->name);
            }
          } else {
            {
#line 184
            tmp___0 = strcmp((char const   *)p___0->name, (char const   *)(p___0->body.defined)->name);
            }
#line 184
            if (tmp___0) {
              {
#line 187
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%s[%s]\n",
                      p___0->name, (p___0->body.defined)->name);
              }
            } else {
              {
#line 185
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%s\n",
                      p___0->name);
              }
            }
          }
#line 189
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 191
          p___0 = *(align->ph + i);
#line 192
          if (p___0->is_pseudo) {
            {
#line 193
            fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"{%s}",
                    p___0->name);
            }
          } else {
            {
#line 194
            tmp___1 = strcmp((char const   *)p___0->name, (char const   *)(p___0->body.defined)->name);
            }
#line 194
            if (tmp___1) {
              {
#line 197
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%s[%s]",
                      p___0->name, (p___0->body.defined)->name);
              }
            } else {
              {
#line 195
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%s",
                      p___0->name);
              }
            }
          }
#line 199
          if (((r->am)->hmminfo)->multipath) {
#line 200
            if (*(align->is_iwsp + i)) {
              {
#line 201
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" #%d (sp)\n",
                      (int )*(align->loc + i));
              }
            } else {
              {
#line 203
              fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" #%d\n",
                      (int )*(align->loc + i));
              }
            }
          } else {
            {
#line 206
            fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" #%d\n",
                    (int )*(align->loc + i));
            }
          }
#line 208
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 174
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 212
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"re-computed AM score: %f\n",
                (double )align->allscore);
#line 214
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"=== end forced alignment ===\n");
#line 162
        align = align->next;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 117
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 86
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return;
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_gmm(Recog *recog , void *dummy ) 
{ 
  HTK_HMM_Data *d ;
  GMMCalc *gc ;
  int i ;

  {
  {
#line 228
  gc = recog->gc;
#line 230
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"--- GMM result begin ---\n");
#line 231
  i = 0;
#line 232
  d = (recog->gmm)->start;
  }
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! d) {
#line 232
      goto while_break;
    }
    {
#line 233
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"  [%8s: total=%f avg=%f]\n",
            d->name, (double )*(gc->gmm_score + i), (double )(*(gc->gmm_score + i) / (float )gc->framecount));
#line 234
    i ++;
#line 232
    d = d->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"  max = \"%s\"",
          (gc->max_d)->name);
#line 238
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" (CM: %f)",
          (double )gc->gmm_max_cm);
#line 240
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 241
  fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"--- GMM result end ---\n");
  }
#line 242
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_graph(Recog *recog , void *dummy ) 
{ 
  WordGraph *wg ;
  int tw1 ;
  int tw2 ;
  int i ;
  WORD_INFO *winfo___0 ;
  RecogProcess *r ;
  boolean multi ;

  {
#line 253
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 253
    multi = (boolean )1;
  } else {
#line 254
    multi = (boolean )0;
  }
#line 256
  r = recog->process_list;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! r) {
#line 256
      goto while_break;
    }
#line 257
    if (! r->live) {
#line 257
      goto __Cont;
    }
#line 258
    if ((unsigned long )r->result.wg == (unsigned long )((void *)0)) {
#line 258
      goto __Cont;
    }
#line 259
    if (multi) {
      {
#line 259
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[#%d %s]\n",
              (int )(r->config)->id, (r->config)->name);
      }
    }
    {
#line 261
    winfo___0 = (r->lm)->winfo;
#line 264
    wordgraph_dump(fp___1, r->result.wg, winfo___0);
#line 266
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-------------------------- begin wordgraph show -------------------------\n");
#line 267
    wg = r->result.wg;
    }
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      if (! wg) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      tw1 = (70 * wg->lefttime) / r->peseqlen;
#line 269
      tw2 = (70 * wg->righttime) / r->peseqlen;
#line 270
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%4d:",
              wg->id);
#line 271
      i = 0;
      }
      {
#line 271
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 271
        if (! (i < tw1)) {
#line 271
          goto while_break___1;
        }
        {
#line 271
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" ");
#line 271
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 272
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" %s\n",
              *(winfo___0->woutput + wg->wid));
#line 273
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"%4d:",
              wg->lefttime);
#line 274
      i = 0;
      }
      {
#line 274
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 274
        if (! (i < tw1)) {
#line 274
          goto while_break___2;
        }
        {
#line 274
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)" ");
#line 274
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 275
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"|");
#line 276
      i = tw1 + 1;
      }
      {
#line 276
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 276
        if (! (i < tw2)) {
#line 276
          goto while_break___3;
        }
        {
#line 276
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-");
#line 276
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 277
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"|\n");
#line 267
      wg = wg->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 279
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"-------------------------- end wordgraph show ---------------------------\n");
    }
    __Cont: /* CIL Label */ 
#line 256
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
static void outfile_confnet(Recog *recog , void *dummy ) 
{ 
  CN_CLUSTER *c ;
  int i ;
  RecogProcess *r ;
  boolean multi ;
  char const   *tmp ;

  {
#line 291
  if ((unsigned long )(recog->process_list)->next != (unsigned long )((void *)0)) {
#line 291
    multi = (boolean )1;
  } else {
#line 292
    multi = (boolean )0;
  }
#line 294
  r = recog->process_list;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! r) {
#line 294
      goto while_break;
    }
#line 295
    if (! r->live) {
#line 295
      goto __Cont;
    }
#line 296
    if ((unsigned long )r->result.confnet == (unsigned long )((void *)0)) {
#line 296
      goto __Cont;
    }
#line 297
    if (multi) {
      {
#line 297
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"[#%d %s]\n",
              (int )(r->config)->id, (r->config)->name);
      }
    }
    {
#line 299
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"---- begin confusion network ---\n");
#line 300
    c = r->result.confnet;
    }
    {
#line 300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 300
      if (! c) {
#line 300
        goto while_break___0;
      }
#line 301
      i = 0;
      {
#line 301
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 301
        if (! (i < c->wordsnum)) {
#line 301
          goto while_break___1;
        }
#line 302
        if ((int )*(c->words + i) == 65535) {
#line 302
          tmp = "-";
        } else {
#line 302
          tmp = (char const   *)*(((r->lm)->winfo)->woutput + *(c->words + i));
        }
        {
#line 302
        fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"(%s:%.3f)",
                tmp, (double )*(c->pp + i));
        }
#line 303
        if (i == 0) {
          {
#line 303
          fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"  ");
          }
        }
#line 301
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 305
      fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"\n");
#line 300
      c = c->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 307
    fprintf((FILE */* __restrict  */)fp___1, (char const   */* __restrict  */)"---- end confusion network ---\n");
    }
    __Cont: /* CIL Label */ 
#line 294
    r = r->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/output_file.c"
void setup_output_file(Recog *recog , void *data ) 
{ 


  {
  {
#line 315
  callback_add(recog, 8, & outfile_open, data);
#line 316
  callback_add(recog, 9, & outfile_close, data);
#line 317
  callback_add(recog, 21, & outfile_sentence, data);
#line 318
  callback_add(recog, 22, & outfile_gmm, data);
#line 319
  callback_add(recog, 23, & outfile_graph, data);
#line 320
  callback_add(recog, 24, & outfile_confnet, data);
  }
#line 321
  return;
}
}
#line 97 "../libsent/include/sent/util.h"
extern void jlog_set_output(FILE *fp ) ;
#line 64 "../libjulius/include/julius/jfunc.h"
extern void j_recog_info(Recog *recog ) ;
#line 113
extern void j_recog_free(Recog *recog ) ;
#line 129 "../libjulius/include/julius/extern.h"
extern void j_put_version(FILE *stream ) ;
#line 167
extern void j_output_argument_help(FILE *fp ) ;
#line 178
extern boolean j_jconf_finalize(Jconf *jconf ) ;
#line 190
extern boolean j_load_all(Recog *recog , Jconf *jconf ) ;
#line 192
extern boolean j_final_fusion(Recog *recog ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
boolean separate_score_flag  =    (boolean )0;
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
boolean outfile_enabled  =    (boolean )0;
#line 31 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static char *logfile  =    (char *)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean nolog  =    (boolean )0;
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean opt_help___1(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Julius rev.%s - based on ",
          "4.2.2");
#line 43
  j_output_argument_help(stderr);
#line 44
  exit(1);
  }
#line 45
  return ((boolean )1);
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean opt_separatescore(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 50
  separate_score_flag = (boolean )1;
#line 51
  return ((boolean )1);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean opt_logfile(Jconf *jconf , char **arg , int argnum ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 56
  tmp = strlen((char const   *)*(arg + 0));
#line 56
  tmp___0 = malloc(tmp + 1UL);
#line 56
  logfile = (char *)tmp___0;
#line 57
  strcpy((char */* __restrict  */)logfile, (char const   */* __restrict  */)*(arg + 0));
  }
#line 58
  return ((boolean )1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean opt_nolog(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 63
  nolog = (boolean )1;
#line 64
  return ((boolean )1);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/julius/main.c"
static boolean opt_outfile(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
#line 69
  outfile_enabled = (boolean )1;
#line 70
  return ((boolean )1);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 96 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
void errMes(char *fmt  , ...) ;
#line 98
void verboseMes(char *fmt  , ...) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
void r_makeTriplet(FA *fa , FILE *fp_fa ) ;
#line 18
int getNewStatNo(FA *fa ) ;
#line 19
FA *processTripletQueue(FA *fa ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static int FAprocessed  =    0;
#line 22
int FAtotal ;
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static int TFAtravTotal  =    0;
#line 24 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static int TFAtravSuccess  =    0;
#line 26
char FAfile[1024] ;
#line 27
FA *FAlist ;
#line 28
int NoNewLine ;
#line 31
int SW_Verbose ;
#line 32
int SW_Quiet ;
#line 33
int SW_SemiQuiet ;
#line 34
int SW_Compati ;
#line 35
int SW_EdgeStart ;
#line 36
int SW_EdgeAccpt ;
#line 38 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
void makeTriplet(void) 
{ 
  FILE *fp_fa ;
  FA *fa ;

  {
  {
#line 43
  FAprocessed = 0;
#line 44
  fp_fa = fopen((char const   */* __restrict  */)(FAfile), (char const   */* __restrict  */)"w");
  }
#line 44
  if ((unsigned long )fp_fa == (unsigned long )((void *)0)) {
    {
#line 45
    errMes((char *)"Can\'t open dfa File for writting\"%s\"", FAfile);
    }
  }
  {
#line 47
  getNewStatNo(FAlist);
  }
#line 48
  if (! SW_Quiet) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now making triplet list");
#line 50
    NoNewLine = 1;
    }
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    fa = processTripletQueue((FA *)((void *)0));
    }
#line 53
    if ((unsigned long )fa == (unsigned long )((void *)0)) {
#line 53
      goto while_break;
    }
    {
#line 54
    r_makeTriplet(fa, fp_fa);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  fclose(fp_fa);
  }
#line 57
  if (! SW_Quiet) {
    {
#line 58
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making triplet list[%d/%d]\n",
            FAprocessed, FAtotal);
#line 59
    NoNewLine = 0;
    }
  }
#line 61
  if (SW_Verbose) {
    {
#line 62
    verboseMes((char *)"r_makeTriplet: %d/%d(%d%%)", TFAtravSuccess, TFAtravTotal,
               (100 * TFAtravSuccess) / TFAtravTotal);
    }
  }
#line 65
  if (NoNewLine) {
    {
#line 65
    _IO_putc('\n', stderr);
#line 65
    NoNewLine = 0;
    }
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
void r_makeTriplet(FA *fa , FILE *fp_fa ) 
{ 
  ARC *arc ;
  CLASSFLAGS accpt ;
  CLASSFLAGS start ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  TFAtravTotal ++;
#line 75
  if ((int )fa->traversed == 2) {
#line 76
    return;
  }
#line 78
  fa->traversed = (FLAG )2;
#line 79
  TFAtravSuccess ++;
#line 81
  FAprocessed ++;
#line 82
  if (! SW_SemiQuiet) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making triplet list[%d/%d]",
            FAprocessed, FAtotal);
#line 84
    NoNewLine = 1;
    }
  }
#line 87
  arc = fa->nsList;
#line 87
  if ((unsigned long )arc == (unsigned long )((void *)0)) {
#line 88
    if (SW_EdgeAccpt) {
#line 88
      if (SW_EdgeStart) {
#line 88
        return;
      }
    }
#line 89
    if (! SW_EdgeAccpt) {
#line 90
      accpt = fa->accpt;
    } else {
#line 92
      accpt = (CLASSFLAGS )0;
    }
#line 94
    if (! SW_EdgeStart) {
#line 95
      start = fa->start;
    } else {
#line 97
      start = (CLASSFLAGS )0;
    }
#line 99
    if (SW_Compati) {
      {
#line 100
      fprintf((FILE */* __restrict  */)fp_fa, (char const   */* __restrict  */)"%d -1 -1 %x\n",
              fa->stat, accpt & 1U);
      }
    } else {
      {
#line 102
      fprintf((FILE */* __restrict  */)fp_fa, (char const   */* __restrict  */)"%d -1 -1 %x %x\n",
              fa->stat, accpt, start);
      }
    }
#line 104
    return;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )arc != (unsigned long )((void *)0))) {
#line 106
      goto while_break;
    }
#line 107
    if (! SW_EdgeAccpt) {
#line 108
      accpt = fa->accpt;
    } else {
#line 110
      accpt = arc->accpt;
    }
#line 112
    if (! SW_EdgeStart) {
#line 113
      start = fa->start;
    } else {
#line 115
      start = arc->start;
    }
#line 117
    if (SW_Compati) {
      {
#line 118
      accpt &= 1U;
#line 119
      tmp = getNewStatNo(arc->fa);
#line 119
      fprintf((FILE */* __restrict  */)fp_fa, (char const   */* __restrict  */)"%d %d %d %x\n",
              fa->stat, arc->inp, tmp, accpt);
      }
    } else {
      {
#line 122
      tmp___0 = getNewStatNo(arc->fa);
#line 122
      fprintf((FILE */* __restrict  */)fp_fa, (char const   */* __restrict  */)"%d %d %d %x %x\n",
              fa->stat, arc->inp, tmp___0, accpt, start);
      }
    }
#line 125
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static int FAstat  =    0;
#line 129 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
int getNewStatNo(FA *fa ) 
{ 
  int tmp ;

  {
#line 133
  if (fa->stat >= 0) {
#line 133
    return (fa->stat);
  }
  {
#line 134
  fa->stat = FAstat;
#line 135
  processTripletQueue(fa);
#line 136
  tmp = FAstat;
#line 136
  FAstat ++;
  }
#line 136
  return (tmp);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static FAQ *queueTop  =    (FAQ *)((void *)0);
#line 149 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
static FAQ *queuqTail  =    (FAQ *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/triplet.c"
FA *processTripletQueue(FA *fa ) 
{ 
  FAQ *newFAQ ;
  void *tmp ;
  FAQ *popedFAQ ;
  FA *popedFA ;

  {
#line 152
  if ((unsigned long )fa != (unsigned long )((void *)0)) {
    {
#line 153
    tmp = malloc(sizeof(FAQ ));
#line 153
    newFAQ = (FAQ *)tmp;
    }
#line 153
    if ((unsigned long )newFAQ == (unsigned long )((void *)0)) {
      {
#line 154
      errMes((char *)"Can\'t malloc queue for breadth-first search of triplet list");
      }
    }
#line 156
    newFAQ->fa = fa;
#line 157
    newFAQ->next = (struct _FAQ *)((void *)0);
#line 159
    if ((unsigned long )queueTop == (unsigned long )((void *)0)) {
#line 160
      queuqTail = newFAQ;
#line 160
      queueTop = queuqTail;
#line 161
      return ((FA *)((void *)0));
    } else {
#line 163
      queuqTail->next = newFAQ;
#line 164
      queuqTail = newFAQ;
#line 165
      return ((FA *)((void *)0));
    }
  } else
#line 168
  if ((unsigned long )queueTop != (unsigned long )((void *)0)) {
    {
#line 169
    popedFAQ = queueTop;
#line 170
    popedFA = queueTop->fa;
#line 171
    queueTop = queueTop->next;
#line 172
    free((void *)popedFAQ);
    }
#line 173
    return (popedFA);
  } else {
#line 175
    return ((FA *)((void *)0));
  }
}
}
#line 41 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.h"
void makeDFA(void) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.h"
void connectFA(FA *fa , int inp , FA *nextFA , CLASSFLAGS accpt , CLASSFLAGS start ) ;
#line 10
FA *makeNewFA(void) ;
#line 13
FALIST *freeFAlist(FALIST *faList ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void r_makeDFA(FA *fa ) ;
#line 12
ARC *unifyFA(FA *dstFA , ARC *prevarc , ARC *curarc , FA *prevFA ) ;
#line 13
void usArc2nsArc(FA *fa ) ;
#line 14
void connectUnifyFA(FA *fa , int inp , FA *nextFA , FLAG reserved , CLASSFLAGS accpt ,
                    CLASSFLAGS start ) ;
#line 16
ARC *unconnectFA(FA *srcFA , ARC *arcPrev , ARC *arc ) ;
#line 17
void killFA(FA *fa ) ;
#line 18
void killIsolatedLoop(FA *vanishFA , FA *curFA ) ;
#line 19
int chkIsolatedLoop(FA *vanishFA , FA *curFA ) ;
#line 21
FALIST *appendGroup(FALIST *groupTop , FA *fa ) ;
#line 22
FALIST *insertFAlist(FALIST *top , FALIST *preAtom , FALIST *nextAtom , FA *fa ) ;
#line 23
FA *chkGroup(FALIST *group , CLASSFLAGS accptFlag , CLASSFLAGS startFlag , FLAG *newFlag ) ;
#line 25
int cmpFAlist(FALIST *group1 , FALIST *group2 ) ;
#line 26
FALIST *volatileFA(FALIST *volatileList , FA *fa ) ;
#line 27
void unvolatileFA(FALIST *volatileList ) ;
#line 28
void verboseGroup(FALIST *group ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
static FALIST *GroupList  =    (FALIST *)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
static int DFAtravTotal  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
static int DFAtravSuccess  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
static int FAprocessed___0  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void makeDFA(void) 
{ 


  {
#line 48
  if (! SW_Quiet) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now making deterministic finite automaton");
#line 50
    NoNewLine = 1;
    }
  }
  {
#line 52
  r_makeDFA(FAlist);
  }
#line 53
  if (! SW_Quiet) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making deterministic finite automaton[%d/%d] \n",
            FAprocessed___0, FAtotal);
    }
#line 55
    if (FAtotal != FAprocessed___0) {
      {
#line 56
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* %d released FA nodes are left on isolated loop\n",
              FAtotal - FAprocessed___0);
      }
    }
#line 58
    NoNewLine = 0;
  }
#line 62
  FAtotal = FAprocessed___0;
#line 63
  if (SW_Verbose) {
    {
#line 64
    verboseMes((char *)"** traversing efficiency ( success/total )");
#line 65
    verboseMes((char *)"r_makeDFA:     %d/%d(%d%%)", DFAtravSuccess, DFAtravTotal,
               (100 * DFAtravSuccess) / DFAtravTotal);
    }
  }
#line 68
  if (NoNewLine) {
    {
#line 68
    _IO_putc('\n', stderr);
#line 68
    NoNewLine = 0;
    }
  }
  {
#line 69
  freeFAlist(GroupList);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void r_makeDFA(FA *fa ) 
{ 
  ARC *prevarc ;
  ARC *curarc ;
  int inp ;
  int bundleNum ;
  FLAG reserved ;
  int i ;
  FLAG newFlag ;
  FALIST *volatileList ;
  CLASSFLAGS unifyAccptFlag ;
  CLASSFLAGS unifyStartFlag ;
  FA *unifyingDstFA ;
  ARC *arc ;
  int inp___0 ;
  FALIST *group ;
  CLASSFLAGS accptFlag ;
  CLASSFLAGS startFlag ;

  {
  {
#line 74
  prevarc = (ARC *)((void *)0);
#line 78
  reserved = (FLAG )0;
#line 81
  volatileList = (FALIST *)((void *)0);
#line 85
  verboseMes((char *)"[func]r_makeDFA(FA %08x)", (long )fa);
#line 86
  DFAtravTotal ++;
  }
#line 87
  if ((int )fa->traversed == 1) {
    {
#line 88
    verboseMes((char *)"traversed...");
    }
#line 89
    return;
  }
#line 91
  fa->traversed = (FLAG )1;
#line 92
  DFAtravSuccess ++;
#line 94
  FAprocessed___0 ++;
#line 95
  if (! SW_SemiQuiet) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making deterministic finite automaton[%d/%d] ",
            FAprocessed___0, FAtotal);
#line 97
    NoNewLine = 1;
    }
  }
#line 99
  curarc = fa->nsList;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! ((unsigned long )curarc != (unsigned long )((void *)0))) {
#line 100
      goto while_break;
    }
#line 101
    unifyingDstFA = (FA *)((void *)0);
#line 103
    arc = curarc;
#line 104
    inp___0 = arc->inp;
#line 105
    group = (FALIST *)((void *)0);
#line 106
    accptFlag = (CLASSFLAGS )0;
#line 107
    startFlag = (CLASSFLAGS )0;
#line 109
    bundleNum = 0;
    {
#line 110
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if ((unsigned long )arc == (unsigned long )((void *)0)) {
#line 111
        goto while_break___0;
      } else
#line 111
      if (arc->inp != inp___0) {
#line 111
        goto while_break___0;
      }
      {
#line 112
      group = appendGroup(group, arc->fa);
#line 113
      accptFlag |= (arc->fa)->accpt;
#line 114
      startFlag |= (arc->fa)->start;
#line 115
      arc = arc->next;
#line 116
      bundleNum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    if (bundleNum > 1) {
      {
#line 119
      unifyingDstFA = chkGroup(group, accptFlag, startFlag, & newFlag);
      }
    } else {
      {
#line 123
      freeFAlist(group);
#line 124
      prevarc = curarc;
#line 125
      curarc = curarc->next;
      }
#line 126
      goto while_continue;
    }
#line 130
    inp = curarc->inp;
#line 131
    unifyAccptFlag = (CLASSFLAGS )0;
#line 132
    unifyStartFlag = (CLASSFLAGS )0;
#line 133
    i = 0;
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 133
      if (! (i < bundleNum)) {
#line 133
        goto while_break___1;
      }
#line 134
      unifyAccptFlag |= curarc->accpt;
#line 135
      unifyStartFlag |= curarc->start;
#line 136
      if (! newFlag) {
        {
#line 138
        curarc = unconnectFA(fa, prevarc, curarc);
        }
      } else
#line 140
      if ((unsigned long )curarc->fa == (unsigned long )fa) {
        {
#line 141
        reserved = (FLAG )1;
#line 143
        curarc = unconnectFA(fa, prevarc, curarc);
        }
      } else {
        {
#line 145
        curarc = unifyFA(unifyingDstFA, prevarc, curarc, fa);
        }
      }
#line 133
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 149
    connectUnifyFA(fa, inp, unifyingDstFA, reserved, unifyAccptFlag, unifyStartFlag);
#line 151
    reserved = (FLAG )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 153
  usArc2nsArc(fa);
#line 156
  curarc = fa->nsList;
  }
  {
#line 157
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 157
    if (! ((unsigned long )curarc != (unsigned long )((void *)0))) {
#line 157
      goto while_break___2;
    }
    {
#line 158
    r_makeDFA(curarc->fa);
#line 159
    curarc = curarc->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void connectUnifyFA(FA *fa , int inp , FA *nextFA , FLAG reserved , CLASSFLAGS accpt ,
                    CLASSFLAGS start ) 
{ 
  UNIFYARC *newArc ;
  UNIFYARC *curArc ;
  UNIFYARC *nextArc ;
  UNIFYARC *top ;
  void *tmp ;

  {
  {
#line 170
  curArc = (UNIFYARC *)((void *)0);
#line 172
  top = fa->usList;
#line 174
  tmp = calloc((size_t )1, sizeof(UNIFYARC ));
#line 174
  newArc = (UNIFYARC *)tmp;
  }
#line 174
  if ((unsigned long )newArc == (unsigned long )((void *)0)) {
    {
#line 175
    errMes((char *)"Can\'t alloc forward arc buffer of finite automaton.");
    }
  }
#line 177
  newArc->inp = inp;
#line 178
  newArc->us = nextFA;
#line 179
  newArc->reserved = reserved;
#line 180
  newArc->accpt = accpt;
#line 181
  newArc->start = start;
#line 183
  nextArc = top;
#line 183
  if ((unsigned long )nextArc != (unsigned long )((void *)0)) {
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 185
      if (nextArc->inp > inp) {
#line 185
        goto while_break;
      }
#line 186
      if (nextArc->inp == inp) {
#line 186
        if ((unsigned long )nextArc->us == (unsigned long )nextFA) {
#line 186
          return;
        }
      }
#line 187
      curArc = nextArc;
#line 188
      nextArc = nextArc->next;
#line 188
      if ((unsigned long )nextArc == (unsigned long )((void *)0)) {
#line 188
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 191
  if ((unsigned long )curArc == (unsigned long )((void *)0)) {
#line 192
    newArc->next = top;
#line 193
    fa->usList = newArc;
  } else {
#line 195
    newArc->next = nextArc;
#line 196
    curArc->next = newArc;
  }
#line 198
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void usArc2nsArc(FA *fa ) 
{ 
  UNIFYARC *uptr ;
  UNIFYARC *disused_uptr ;
  ARC *nptr ;
  ARC *newarc ;
  void *tmp ;

  {
#line 207
  uptr = fa->usList;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((unsigned long )uptr != (unsigned long )((void *)0))) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp = calloc((size_t )1, sizeof(ARC ));
#line 209
    newarc = (ARC *)tmp;
    }
#line 209
    if ((unsigned long )newarc == (unsigned long )((void *)0)) {
      {
#line 210
      errMes((char *)"Can\'t alloc forward arc buffer of finite automaton.");
      }
    }
    {
#line 212
    connectFA(fa, uptr->inp, uptr->us, uptr->accpt, uptr->start);
#line 213
    uptr = uptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  uptr = fa->usList;
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )uptr != (unsigned long )((void *)0))) {
#line 217
      goto while_break___0;
    }
#line 218
    if (uptr->reserved) {
#line 219
      (uptr->us)->accpt |= fa->accpt;
#line 220
      nptr = fa->nsList;
      {
#line 221
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 221
        if (! ((unsigned long )nptr != (unsigned long )((void *)0))) {
#line 221
          goto while_break___1;
        }
        {
#line 222
        connectFA(uptr->us, nptr->inp, nptr->fa, nptr->accpt, nptr->start);
#line 223
        nptr = nptr->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 226
    disused_uptr = uptr;
#line 227
    uptr = uptr->next;
#line 228
    free((void *)disused_uptr);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
FALIST *volatileFA(FALIST *volatileList , FA *fa ) 
{ 
  FALIST *atom ;
  void *tmp ;

  {
  {
#line 236
  tmp = malloc(sizeof(FALIST ));
#line 236
  atom = (FALIST *)tmp;
  }
#line 236
  if ((unsigned long )atom == (unsigned long )((void *)0)) {
    {
#line 237
    errMes((char *)"Can\'t alloc FA list buffer.");
    }
  }
#line 239
  fa->volatiled = (FLAG )1;
#line 241
  atom->fa = fa;
#line 242
  atom->next = volatileList;
#line 243
  return (atom);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void unvolatileFA(FALIST *volatileList ) 
{ 
  FALIST *atom ;
  FA *fa ;

  {
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! ((unsigned long )volatileList != (unsigned long )((void *)0))) {
#line 251
      goto while_break;
    }
    {
#line 252
    atom = volatileList;
#line 253
    fa = atom->fa;
#line 254
    fa->volatiled = (FLAG )0;
#line 258
    volatileList = volatileList->next;
#line 259
    free((void *)atom);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
ARC *unifyFA(FA *dstFA , ARC *prevarc , ARC *curarc , FA *prevFA ) 
{ 
  FA *srcFA ;
  ARC *arc ;
  ARC *tmp ;

  {
#line 265
  srcFA = curarc->fa;
#line 266
  arc = srcFA->nsList;
#line 268
  dstFA->accpt |= srcFA->accpt;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )arc != (unsigned long )((void *)0))) {
#line 269
      goto while_break;
    }
    {
#line 270
    connectFA(dstFA, arc->inp, arc->fa, arc->accpt, arc->start);
#line 271
    arc = arc->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 273
  tmp = unconnectFA(prevFA, prevarc, curarc);
  }
#line 273
  return (tmp);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
ARC *unconnectFA(FA *srcFA , ARC *arcPrev , ARC *arc ) 
{ 
  ARC *arcNext ;
  FA *vanishFA ;

  {
#line 282
  arcNext = arc->next;
#line 285
  if ((unsigned long )arcPrev == (unsigned long )((void *)0)) {
#line 286
    srcFA->nsList = arcNext;
  } else {
#line 288
    arcPrev->next = arcNext;
  }
  {
#line 290
  vanishFA = arc->fa;
#line 291
  free((void *)arc);
#line 293
  (vanishFA->psNum) --;
  }
#line 293
  if (vanishFA->psNum == 0) {
    {
#line 294
    killFA(vanishFA);
    }
  }
#line 298
  return (arcNext);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void killFA(FA *fa ) 
{ 
  ARC *arc ;

  {
  {
#line 303
  arc = fa->nsList;
#line 304
  verboseMes((char *)"a FA node is vanished");
  }
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! ((unsigned long )arc != (unsigned long )((void *)0))) {
#line 305
      goto while_break;
    }
    {
#line 306
    arc = unconnectFA(fa, (ARC *)((void *)0), arc);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  free((void *)fa);
#line 309
  FAtotal --;
  }
#line 310
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
int chkIsolatedLoop(FA *vanishFA , FA *curFA ) 
{ 
  ARC *arc ;
  int result ;
  FA *nextFA ;

  {
#line 319
  if (curFA->volatiled) {
#line 319
    return (0);
  }
#line 320
  if (curFA->psNum > 1) {
#line 320
    return (0);
  }
#line 321
  arc = curFA->nsList;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! ((unsigned long )arc != (unsigned long )((void *)0))) {
#line 323
      goto while_break;
    }
#line 324
    nextFA = arc->fa;
#line 325
    if ((unsigned long )nextFA == (unsigned long )vanishFA) {
#line 325
      return (1);
    }
    {
#line 326
    result = chkIsolatedLoop(vanishFA, nextFA);
    }
#line 327
    if (result) {
#line 327
      return (1);
    }
#line 328
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void killIsolatedLoop(FA *vanishFA , FA *curFA ) 
{ 
  ARC *arc ;
  ARC *prevarc ;
  FA *nextFA ;

  {
#line 338
  prevarc = (ARC *)((void *)0);
#line 340
  if (curFA->volatiled) {
#line 340
    return;
  }
#line 341
  if (curFA->psNum > 1) {
#line 341
    return;
  }
#line 343
  arc = curFA->nsList;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )arc != (unsigned long )((void *)0))) {
#line 344
      goto while_break;
    }
#line 345
    nextFA = arc->fa;
#line 346
    if ((unsigned long )nextFA != (unsigned long )vanishFA) {
      {
#line 347
      unconnectFA(curFA, prevarc, arc);
      }
    }
#line 349
    prevarc = arc;
#line 350
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 352
  free((void *)curFA);
#line 353
  FAtotal --;
  }
#line 354
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
FALIST *appendGroup(FALIST *groupTop , FA *fa ) 
{ 
  FALIST *preAtom ;
  FALIST *curAtom ;
  FALIST *srcCurAtom ;
  long cmp ;
  FALIST *tmp ;

  {
#line 361
  preAtom = (FALIST *)((void *)0);
#line 362
  curAtom = groupTop;
#line 363
  srcCurAtom = (FALIST *)((void *)0);
#line 366
  if ((unsigned long )fa->group == (unsigned long )((void *)0)) {
    {
#line 367
    while (1) {
      while_continue: /* CIL Label */ ;
#line 367
      if (! ((unsigned long )curAtom != (unsigned long )((void *)0))) {
#line 367
        goto while_break;
      }
#line 368
      cmp = (long )fa - (long )curAtom->fa;
#line 369
      if (cmp == 0L) {
#line 369
        return (groupTop);
      }
#line 370
      if (cmp < 0L) {
#line 370
        goto while_break;
      }
#line 371
      preAtom = curAtom;
#line 372
      curAtom = curAtom->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 374
    tmp = insertFAlist(groupTop, preAtom, curAtom, fa);
    }
#line 374
    return (tmp);
  } else {
#line 379
    srcCurAtom = fa->group;
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! ((unsigned long )srcCurAtom != (unsigned long )((void *)0))) {
#line 379
        goto while_break___0;
      }
#line 381
      if ((unsigned long )curAtom == (unsigned long )((void *)0)) {
        {
#line 382
        groupTop = insertFAlist(groupTop, preAtom, curAtom, srcCurAtom->fa);
#line 383
        preAtom = (FALIST *)((void *)0);
#line 384
        curAtom = groupTop;
        }
      }
#line 396
      cmp = (long )srcCurAtom->fa - (long )curAtom->fa;
#line 397
      if (cmp == 0L) {
#line 397
        goto __Cont;
      }
#line 398
      if (cmp < 0L) {
        {
#line 399
        groupTop = insertFAlist(groupTop, preAtom, curAtom, srcCurAtom->fa);
#line 400
        preAtom = (FALIST *)((void *)0);
#line 401
        curAtom = groupTop;
        }
      } else {
#line 403
        preAtom = curAtom;
#line 404
        curAtom = curAtom->next;
      }
      __Cont: /* CIL Label */ 
#line 379
      srcCurAtom = srcCurAtom->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 407
    return (groupTop);
  }
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
FALIST *insertFAlist(FALIST *top , FALIST *preAtom , FALIST *nextAtom , FA *fa ) 
{ 
  FALIST *atom ;
  void *tmp ;

  {
  {
#line 415
  tmp = malloc(sizeof(FALIST ));
#line 415
  atom = (FALIST *)tmp;
  }
#line 415
  if ((unsigned long )atom == (unsigned long )((void *)0)) {
    {
#line 416
    errMes((char *)"Can\'t alloc group buffer for unifying FA");
    }
  }
#line 418
  atom->fa = fa;
#line 419
  if ((unsigned long )preAtom == (unsigned long )((void *)0)) {
#line 420
    atom->next = nextAtom;
#line 421
    return (atom);
  } else {
#line 423
    preAtom->next = atom;
#line 424
    atom->next = nextAtom;
#line 425
    return (top);
  }
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
FA *chkGroup(FALIST *group , CLASSFLAGS accptFlag , CLASSFLAGS startFlag , FLAG *newFlag ) 
{ 
  FALIST *curGroupList ;
  FALIST *preGroupList ;
  int cmp ;
  FA *fa ;

  {
#line 432
  curGroupList = GroupList;
#line 433
  preGroupList = (FALIST *)((void *)0);
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! ((unsigned long )curGroupList != (unsigned long )((void *)0))) {
#line 437
      goto while_break;
    }
    {
#line 438
    cmp = cmpFAlist((curGroupList->fa)->group, group);
    }
#line 439
    if (cmp == 0) {
#line 440
      if (SW_Compati) {
        {
#line 442
        freeFAlist(group);
#line 443
        *newFlag = (FLAG )0;
        }
#line 444
        return (curGroupList->fa);
      } else
#line 440
      if (accptFlag == (curGroupList->fa)->accpt) {
        {
#line 442
        freeFAlist(group);
#line 443
        *newFlag = (FLAG )0;
        }
#line 444
        return (curGroupList->fa);
      } else
#line 440
      if (startFlag == (curGroupList->fa)->start) {
        {
#line 442
        freeFAlist(group);
#line 443
        *newFlag = (FLAG )0;
        }
#line 444
        return (curGroupList->fa);
      }
    }
#line 447
    if (cmp < 0) {
#line 447
      goto while_break;
    }
#line 448
    preGroupList = curGroupList;
#line 449
    curGroupList = curGroupList->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  if (SW_Verbose) {
    {
#line 452
    verboseGroup(group);
    }
  }
  {
#line 454
  fa = makeNewFA();
#line 455
  GroupList = insertFAlist(GroupList, preGroupList, curGroupList, fa);
#line 456
  fa->group = group;
#line 457
  fa->accpt = accptFlag;
#line 458
  fa->start = startFlag;
#line 459
  *newFlag = (FLAG )1;
  }
#line 460
  return (fa);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
void verboseGroup(FALIST *group ) 
{ 


  {
  {
#line 465
  verboseMes((char *)"Created New Group");
  }
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 466
    if (! ((unsigned long )group != (unsigned long )((void *)0))) {
#line 466
      goto while_break;
    }
    {
#line 467
    verboseMes((char *)"  FAadr: %08x", (long )group->fa);
#line 468
    group = group->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/dfa.c"
int cmpFAlist(FALIST *group1 , FALIST *group2 ) 
{ 
  long cmp ;

  {
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if ((unsigned long )group1 == (unsigned long )((void *)0)) {
#line 477
      if ((unsigned long )group2 == (unsigned long )((void *)0)) {
#line 477
        return (0);
      }
    }
#line 478
    if ((unsigned long )group1 == (unsigned long )((void *)0)) {
#line 478
      return (-1);
    }
#line 479
    if ((unsigned long )group2 == (unsigned long )((void *)0)) {
#line 479
      return (1);
    }
#line 480
    cmp = (long )group1->fa - (long )group2->fa;
#line 481
    if (cmp != 0L) {
#line 481
      return ((int )cmp);
    }
#line 482
    group1 = group1->next;
#line 483
    group2 = group2->next;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 379 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
void warnMes(char *fmt  , ...) ;
#line 100
void setVoca(void) ;
#line 102
void setGram(void) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.h"
void makeNFA(void) ;
#line 12 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
void getSwitch(int argc , char **argv ) ;
#line 13
int setSwitch(char *sw ) ;
#line 14
int setFilename(char *fname___0 , int kind ) ;
#line 15
void usage(void) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char VerNo[17]  = 
#line 17
  {      (char )'v',      (char )'e',      (char )'r',      (char )'.', 
        (char )'1',      (char )'.',      (char )'4',      (char )'4', 
        (char )'-',      (char )'f',      (char )'l',      (char )'e', 
        (char )'x',      (char )'-',      (char )'p',      (char )'1', 
        (char )'\000'};
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
CLASS *ClassList  =    (CLASS *)((void *)0);
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
CLASS *ClassListTail  =    (CLASS *)((void *)0);
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
CLASS *StartSymbol  =    (CLASS *)((void *)0);
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char GramFile[1024]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char VocaFile[1024]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char FAfile[1024]  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char HeaderFile[1024]  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int NoNewLine  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
FA *FAlist  =    (FA *)((void *)0);
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
char Clipboard[1024]  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
static int optF  =    0;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_SentList  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_NoWarning  =    0;
#line 35 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_Compati  =    0;
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_Quiet  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_SemiQuiet  =    0;
#line 38 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_Debug  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_NFAoutput  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_Verbose  =    0;
#line 41 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_EdgeStart  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int SW_EdgeAccpt  ;
#line 62 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
void getSwitch(int argc , char **argv ) 
{ 
  int i ;
  int filemode ;
  int filefinish ;

  {
#line 65
  filemode = 0;
#line 66
  filefinish = 0;
#line 68
  i = 1;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < argc)) {
#line 68
      goto while_break;
    }
#line 69
    if (filemode == 0) {
#line 70
      if ((int )*(*(argv + i) + 0) == 45) {
        {
#line 71
        filemode = setSwitch(*(argv + i) + 1);
        }
      } else {
        {
#line 73
        usage();
        }
      }
    } else {
      {
#line 76
      filefinish = setFilename(*(argv + i), filemode);
#line 77
      filemode = 0;
      }
    }
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  if (! filefinish) {
    {
#line 80
    usage();
    }
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int setSwitch(char *sw ) 
{ 
  char *sname[20] ;
  int swNo ;
  int tmp ;

  {
#line 85
  sname[0] = (char *)"l";
#line 85
  sname[1] = (char *)"nw";
#line 85
  sname[2] = (char *)"c";
#line 85
  sname[3] = (char *)"db";
#line 85
  sname[4] = (char *)"dfa";
#line 85
  sname[5] = (char *)"nfa";
#line 85
  sname[6] = (char *)"fg";
#line 85
  sname[7] = (char *)"fv";
#line 85
  sname[8] = (char *)"fo";
#line 85
  sname[9] = (char *)"fh";
#line 85
  sname[10] = (char *)"f";
#line 85
  sname[11] = (char *)"v";
#line 85
  sname[12] = (char *)"c";
#line 85
  sname[13] = (char *)"e";
#line 85
  sname[14] = (char *)"e0";
#line 85
  sname[15] = (char *)"e1";
#line 85
  sname[16] = (char *)"q0";
#line 85
  sname[17] = (char *)"q";
#line 85
  sname[18] = (char *)"q1";
#line 85
  sname[19] = (char *)((void *)0);
#line 94
  swNo = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if ((unsigned long )sname[swNo] == (unsigned long )((void *)0)) {
#line 95
      goto while_break;
    }
    {
#line 96
    tmp = strcmp((char const   *)sw, (char const   *)sname[swNo]);
    }
#line 96
    if (tmp == 0) {
#line 96
      goto while_break;
    }
#line 94
    swNo ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  if (swNo == 0) {
#line 99
    goto case_0;
  }
#line 102
  if (swNo == 1) {
#line 102
    goto case_1;
  }
#line 105
  if (swNo == 2) {
#line 105
    goto case_2;
  }
#line 108
  if (swNo == 3) {
#line 108
    goto case_3;
  }
#line 111
  if (swNo == 4) {
#line 111
    goto case_4;
  }
#line 115
  if (swNo == 5) {
#line 115
    goto case_5;
  }
#line 119
  if (swNo == 6) {
#line 119
    goto case_6;
  }
#line 121
  if (swNo == 7) {
#line 121
    goto case_7;
  }
#line 123
  if (swNo == 8) {
#line 123
    goto case_8;
  }
#line 125
  if (swNo == 9) {
#line 125
    goto case_9;
  }
#line 127
  if (swNo == 10) {
#line 127
    goto case_10;
  }
#line 129
  if (swNo == 11) {
#line 129
    goto case_11;
  }
#line 132
  if (swNo == 12) {
#line 132
    goto case_12;
  }
#line 135
  if (swNo == 13) {
#line 135
    goto case_13;
  }
#line 139
  if (swNo == 14) {
#line 139
    goto case_14;
  }
#line 142
  if (swNo == 15) {
#line 142
    goto case_15;
  }
#line 145
  if (swNo == 16) {
#line 145
    goto case_16;
  }
#line 148
  if (swNo == 18) {
#line 148
    goto case_18;
  }
#line 148
  if (swNo == 17) {
#line 148
    goto case_18;
  }
#line 151
  goto switch_default;
  case_0: /* CIL Label */ 
#line 100
  SW_SentList = 1;
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  SW_NoWarning = 1;
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
#line 106
  SW_Compati = 1;
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 109
  SW_Debug = 1;
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  if (optF) {
    {
#line 112
    usage();
    }
  }
#line 113
  SW_NFAoutput = 0;
#line 114
  goto switch_break;
  case_5: /* CIL Label */ 
#line 116
  if (optF) {
    {
#line 116
    usage();
    }
  }
#line 117
  SW_NFAoutput = 1;
#line 118
  goto switch_break;
  case_6: /* CIL Label */ 
#line 120
  return (1);
  case_7: /* CIL Label */ 
#line 122
  return (2);
  case_8: /* CIL Label */ 
#line 124
  return (3);
  case_9: /* CIL Label */ 
#line 126
  return (4);
  case_10: /* CIL Label */ 
#line 128
  return (5);
  case_11: /* CIL Label */ 
#line 130
  SW_Verbose = 1;
#line 131
  goto switch_break;
  case_12: /* CIL Label */ 
#line 133
  SW_Compati = 1;
#line 134
  goto switch_break;
  case_13: /* CIL Label */ 
#line 136
  SW_EdgeAccpt = 1;
#line 137
  SW_EdgeStart = 1;
#line 138
  goto switch_break;
  case_14: /* CIL Label */ 
#line 140
  SW_EdgeAccpt = 1;
#line 141
  goto switch_break;
  case_15: /* CIL Label */ 
#line 143
  SW_EdgeStart = 1;
#line 144
  goto switch_break;
  case_16: /* CIL Label */ 
#line 146
  SW_Quiet = 1;
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
#line 149
  SW_SemiQuiet = 1;
#line 150
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 152
  usage();
  }
  switch_break: /* CIL Label */ ;
  }
#line 154
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
static int f_gram  =    0;
#line 160 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
static int f_voca  =    0;
#line 161 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
static int f_out  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
static int f_header  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
int setFilename(char *fname___0 , int kind ) 
{ 


  {
  {
#line 164
  if (kind == 1) {
#line 164
    goto case_1;
  }
#line 168
  if (kind == 2) {
#line 168
    goto case_2;
  }
#line 172
  if (kind == 3) {
#line 172
    goto case_3;
  }
#line 176
  if (kind == 4) {
#line 176
    goto case_4;
  }
#line 180
  if (kind == 5) {
#line 180
    goto case_5;
  }
#line 163
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 165
  strcpy((char */* __restrict  */)(GramFile), (char const   */* __restrict  */)fname___0);
#line 166
  f_gram = 1;
  }
#line 167
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 169
  strcpy((char */* __restrict  */)(VocaFile), (char const   */* __restrict  */)fname___0);
#line 170
  f_voca = 1;
  }
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 173
  strcpy((char */* __restrict  */)(FAfile), (char const   */* __restrict  */)fname___0);
#line 174
  f_out = 1;
  }
#line 175
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 177
  strcpy((char */* __restrict  */)(HeaderFile), (char const   */* __restrict  */)fname___0);
#line 178
  f_header = 1;
  }
#line 179
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 181
  sprintf((char */* __restrict  */)(GramFile), (char const   */* __restrict  */)"%s.grammar",
          fname___0);
#line 182
  sprintf((char */* __restrict  */)(VocaFile), (char const   */* __restrict  */)"%s.voca",
          fname___0);
  }
#line 183
  if (SW_NFAoutput) {
    {
#line 184
    sprintf((char */* __restrict  */)(FAfile), (char const   */* __restrict  */)"%s.nfa",
            fname___0);
    }
  } else {
    {
#line 186
    sprintf((char */* __restrict  */)(FAfile), (char const   */* __restrict  */)"%s.dfa",
            fname___0);
    }
  }
  {
#line 188
  optF = 1;
#line 189
  sprintf((char */* __restrict  */)(HeaderFile), (char const   */* __restrict  */)"%s.h",
          fname___0);
#line 190
  f_header = 1;
#line 190
  f_out = f_header;
#line 190
  f_voca = f_out;
#line 190
  f_gram = f_voca;
  }
#line 191
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 193
  if (f_gram) {
#line 193
    if (f_voca) {
#line 193
      if (f_out) {
#line 193
        if (f_header) {
#line 194
          return (1);
        } else {
#line 196
          return (0);
        }
      } else {
#line 196
        return (0);
      }
    } else {
#line 196
      return (0);
    }
  } else {
#line 196
    return (0);
  }
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
void errMes(char *fmt  , ...) 
{ 
  va_list argp ;

  {
#line 203
  if (NoNewLine) {
    {
#line 203
    _IO_putc('\n', stderr);
    }
  }
  {
#line 204
  __builtin_va_start(argp, fmt);
#line 205
  vsprintf((char */* __restrict  */)(Clipboard), (char const   */* __restrict  */)fmt,
           argp);
#line 206
  __builtin_va_end(argp);
#line 207
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error:       %s\n",
          Clipboard);
#line 208
  exit(1);
  }
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
void warnMes(char *fmt  , ...) 
{ 
  va_list argp ;

  {
#line 214
  if (SW_NoWarning) {
#line 214
    return;
  }
#line 215
  if (NoNewLine) {
    {
#line 215
    _IO_putc('\n', stderr);
    }
  }
  {
#line 216
  __builtin_va_start(argp, fmt);
#line 217
  vsprintf((char */* __restrict  */)(Clipboard), (char const   */* __restrict  */)fmt,
           argp);
#line 218
  __builtin_va_end(argp);
#line 219
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning:     %s\n",
          Clipboard);
#line 220
  NoNewLine = 0;
  }
#line 221
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/main.c"
void verboseMes(char *fmt  , ...) 
{ 
  va_list argp ;

  {
#line 225
  if (! SW_Verbose) {
#line 225
    return;
  }
#line 226
  if (NoNewLine) {
    {
#line 226
    _IO_putc('\n', stderr);
    }
  }
  {
#line 227
  __builtin_va_start(argp, fmt);
#line 228
  vsprintf((char */* __restrict  */)(Clipboard), (char const   */* __restrict  */)fmt,
           argp);
#line 229
  __builtin_va_end(argp);
#line 230
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[verbose]    %s\n",
          Clipboard);
#line 231
  NoNewLine = 0;
  }
#line 232
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/mkfa.h"
CLASS *getClass(char *name ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.h"
FALIST *appendFAlist(FALIST *faList , FA *fa ) ;
#line 12
FALIST *cpyFAlist(FALIST *dst , FALIST *src ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FA *r_makeNFA(CLASS *class , FA *fa , FA *exitFA , FALIST *orgExtraFAs , HIS *his ) ;
#line 24
int getNextToken(TOKEN *token , BODYLIST **pBodyList , BODY **pBody ) ;
#line 25
void connectFAforNFA(FA *fa , int inp , FA *nextFA , HIS *his ) ;
#line 26
FA *appendFA(FA *fa , int input , HIS *his ) ;
#line 27
ARC *appendArc(ARC *top , FA *dst , int inp , CLASSFLAGS accpt , CLASSFLAGS start ) ;
#line 28
void appendHisArc(HIS *his , FA *fa , int inp , FA *nextFA , CLASSFLAGS accpt , CLASSFLAGS start ) ;
#line 29
void chkClassInfo(CLASS *class ) ;
#line 31
FA *getRecursion(CLASS *class , HIS *his ) ;
#line 32
void chkLeftRecursion(CLASS *class , FA *fa , HIS *his ) ;
#line 33
char *strAncestors(HIS *me , HIS *ancestor ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
static int FAprocessed___1  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
int FAtotal  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void makeNFA(void) 
{ 


  {
#line 48
  if ((unsigned long )StartSymbol == (unsigned long )((void *)0)) {
    {
#line 49
    errMes((char *)"No definition of grammar");
    }
  }
  {
#line 51
  FAprocessed___1 = 0;
#line 52
  FAlist = makeNewFA();
#line 53
  (FAlist->psNum) ++;
  }
#line 54
  if (! SW_Quiet) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making nondeterministic finite automaton");
#line 56
    NoNewLine = 1;
    }
  }
  {
#line 58
  r_makeNFA(StartSymbol, FAlist, (FA *)((void *)0), (FALIST *)((void *)0), (HIS *)((void *)0));
  }
#line 59
  if (! SW_Quiet) {
    {
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making nondeterministic finite automaton[%d/%d]\n",
            FAtotal, FAtotal);
#line 61
    NoNewLine = 0;
    }
  }
  {
#line 63
  chkClassInfo(ClassList);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FA *r_makeNFA(CLASS *class , FA *fa , FA *exitFA , FALIST *orgExtraFAs , HIS *his ) 
{ 
  FA *baseFA ;
  FA *loopFA ;
  HIS curhis ;
  TOKEN curToken ;
  TOKEN nextToken ;
  FLAG exitFlag ;
  BODYLIST *bodyList ;
  BODY *body ;
  FALIST *extraFAs ;
  CLASSFLAGS initStartFlag ;
  int tmp ;
  FALIST *anExtraFAs ;
  FA *extraFA ;
  FALIST *pExtraFAs ;
  int tmp___0 ;
  FA *extraFA___0 ;
  FALIST *pExtraFAs___0 ;
  int tmp___1 ;
  FALIST *extraFA___1 ;
  char *tmp___2 ;
  ARC *curArc ;
  ARC *tmpArc ;

  {
#line 68
  baseFA = fa;
#line 69
  loopFA = (FA *)((void *)0);
#line 73
  exitFlag = (FLAG )0;
#line 74
  bodyList = class->bodyList;
#line 75
  body = (BODY *)((void *)0);
#line 76
  extraFAs = (FALIST *)((void *)0);
#line 79
  if (! SW_SemiQuiet) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow making nondeterministic finite automaton[%d/%d]",
            FAtotal, FAtotal);
#line 81
    NoNewLine = 1;
    }
  }
#line 84
  class->usedFA = (FLAG )1;
#line 85
  if ((int )class->no >= 0) {
#line 86
    fa->start |= (unsigned int )(1 << (int )class->no);
#line 87
    fa->aStart |= (unsigned int )(1 << (int )class->no);
  }
#line 89
  initStartFlag = fa->aStart;
#line 91
  if ((unsigned long )exitFA == (unsigned long )((void *)0)) {
    {
#line 91
    exitFA = makeNewFA();
    }
  }
  {
#line 92
  chkLeftRecursion(class, fa, his);
#line 93
  curhis.class = class;
#line 94
  curhis.fa = fa;
#line 95
  curhis.prev = his;
#line 96
  curhis.nsList = (ARC *)((void *)0);
#line 97
  curhis.cloneFA = (FA *)((void *)0);
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 100
    getNextToken(& nextToken, & bodyList, & body);
#line 101
    extraFAs = cpyFAlist(extraFAs, orgExtraFAs);
    }
    {
#line 102
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 103
      curToken = nextToken;
#line 104
      tmp___1 = getNextToken(& nextToken, & bodyList, & body);
      }
#line 104
      if (tmp___1) {
#line 105
        if ((curToken.class)->branch > 0) {
          {
#line 106
          loopFA = getRecursion(nextToken.class, & curhis);
          }
#line 106
          if ((unsigned long )loopFA != (unsigned long )((void *)0)) {
#line 107
            if (curToken.abort) {
              {
#line 110
              extraFAs = appendFAlist(extraFAs, exitFA);
#line 111
              exitFlag = (FLAG )1;
              }
            }
            {
#line 114
            fa = r_makeNFA(curToken.class, fa, loopFA, extraFAs, & curhis);
#line 116
            tmp = getNextToken(& curToken, & bodyList, & body);
            }
#line 116
            if (tmp) {
              {
#line 117
              errMes((char *)"Symbols following recursion exist in class \"%s\"",
                     class->name);
              }
            }
#line 119
            goto while_break___0;
          } else {
#line 121
            anExtraFAs = (FALIST *)((void *)0);
#line 122
            if (curToken.abort) {
              {
#line 124
              anExtraFAs = cpyFAlist(anExtraFAs, extraFAs);
#line 125
              anExtraFAs = appendFAlist(anExtraFAs, exitFA);
#line 126
              exitFlag = (FLAG )1;
              }
            }
            {
#line 128
            fa = r_makeNFA(curToken.class, fa, (FA *)((void *)0), anExtraFAs, & curhis);
#line 129
            freeFAlist(anExtraFAs);
            }
#line 130
            goto while_continue___0;
          }
        } else {
#line 133
          if (curToken.abort) {
            {
#line 135
            pExtraFAs = extraFAs;
#line 136
            connectFAforNFA(fa, (int )(curToken.class)->no, exitFA, & curhis);
            }
            {
#line 137
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 137
              if (! ((unsigned long )pExtraFAs != (unsigned long )((void *)0))) {
#line 137
                goto while_break___1;
              }
              {
#line 138
              extraFA = pExtraFAs->fa;
#line 139
              connectFAforNFA(fa, (int )(curToken.class)->no, extraFA, & curhis);
#line 140
              pExtraFAs = pExtraFAs->next;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 142
            exitFlag = (FLAG )1;
          }
          {
#line 144
          loopFA = getRecursion(nextToken.class, & curhis);
          }
#line 144
          if ((unsigned long )loopFA != (unsigned long )((void *)0)) {
            {
#line 145
            connectFAforNFA(fa, (int )(curToken.class)->no, loopFA, & curhis);
#line 146
            tmp___0 = getNextToken(& curToken, & bodyList, & body);
            }
#line 146
            if (tmp___0) {
              {
#line 147
              errMes((char *)"Symbols following recursion exist in class \"%s\"",
                     class->name);
              }
            }
#line 149
            goto while_break___0;
          } else {
            {
#line 151
            fa = appendFA(fa, (int )(curToken.class)->no, & curhis);
            }
#line 152
            goto while_continue___0;
          }
        }
      } else {
#line 156
        exitFlag = (FLAG )1;
#line 157
        if ((curToken.class)->branch > 0) {
          {
#line 158
          exitFA = r_makeNFA(curToken.class, fa, exitFA, extraFAs, & curhis);
          }
        } else {
#line 161
          pExtraFAs___0 = extraFAs;
          {
#line 162
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 162
            if (! ((unsigned long )pExtraFAs___0 != (unsigned long )((void *)0))) {
#line 162
              goto while_break___2;
            }
            {
#line 163
            extraFA___0 = pExtraFAs___0->fa;
#line 164
            connectFAforNFA(fa, (int )(curToken.class)->no, extraFA___0, & curhis);
#line 165
            pExtraFAs___0 = pExtraFAs___0->next;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 167
          connectFAforNFA(fa, (int )(curToken.class)->no, exitFA, & curhis);
          }
        }
#line 169
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 173
    if ((int )class->no >= 0) {
#line 174
      extraFA___1 = extraFAs;
      {
#line 175
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 175
        if (! ((unsigned long )extraFA___1 != (unsigned long )((void *)0))) {
#line 175
          goto while_break___3;
        }
#line 176
        (extraFA___1->fa)->accpt |= (unsigned int )(1 << (int )class->no);
#line 177
        extraFA___1 = extraFA___1->next;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 180
    if ((unsigned long )bodyList == (unsigned long )((void *)0)) {
#line 180
      goto while_break;
    }
#line 181
    fa = baseFA;
#line 182
    fa->aStart = initStartFlag;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  if (! exitFlag) {
    {
#line 186
    tmp___2 = strAncestors(curhis.prev, (HIS *)((void *)0));
#line 186
    errMes((char *)"Infinite definition is formed %s", tmp___2);
    }
  }
#line 188
  if ((int )class->no >= 0) {
#line 189
    exitFA->accpt |= (unsigned int )(1 << (int )class->no);
#line 190
    if ((unsigned long )curhis.cloneFA != (unsigned long )((void *)0)) {
#line 191
      (curhis.cloneFA)->accpt |= (unsigned int )(1 << (int )class->no);
    }
  }
  {
#line 194
  extraFAs = freeFAlist(extraFAs);
  }
#line 196
  if ((unsigned long )curhis.cloneFA == (unsigned long )((void *)0)) {
#line 198
    curArc = curhis.nsList;
    {
#line 198
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 198
      if (! ((unsigned long )curArc != (unsigned long )((void *)0))) {
#line 198
        goto while_break___4;
      }
      {
#line 199
      ((curArc->fa)->psNum) --;
#line 202
      tmpArc = curArc->next;
#line 203
      free((void *)curArc);
#line 204
      curArc = tmpArc;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 207
  return (exitFA);
}
}
#line 210 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FALIST *appendFAlist(FALIST *faList , FA *fa ) 
{ 
  FALIST *atom ;
  void *tmp ;

  {
  {
#line 214
  tmp = calloc((size_t )1, sizeof(FALIST ));
#line 214
  atom = (FALIST *)tmp;
  }
#line 214
  if ((unsigned long )atom == (unsigned long )((void *)0)) {
    {
#line 215
    errMes((char *)"Can\'t alloc FA list buffer.");
    }
  }
#line 218
  atom->fa = fa;
#line 219
  atom->next = faList;
#line 220
  return (atom);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FALIST *cpyFAlist(FALIST *dst , FALIST *src ) 
{ 


  {
#line 225
  if ((unsigned long )dst != (unsigned long )((void *)0)) {
    {
#line 225
    dst = freeFAlist(dst);
    }
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! ((unsigned long )src != (unsigned long )((void *)0))) {
#line 226
      goto while_break;
    }
    {
#line 227
    dst = appendFAlist(dst, src->fa);
#line 228
    src = src->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return (dst);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FALIST *freeFAlist(FALIST *faList ) 
{ 
  FALIST *atom ;

  {
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! ((unsigned long )faList != (unsigned long )((void *)0))) {
#line 235
      goto while_break;
    }
    {
#line 236
    atom = faList;
#line 237
    faList = faList->next;
#line 238
    free((void *)atom);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return ((FALIST *)((void *)0));
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
int getNextToken(TOKEN *token , BODYLIST **pBodyList , BODY **pBody ) 
{ 
  BODYLIST *bodyList ;
  BODY *body ;
  CLASS *tmp ;

  {
#line 245
  bodyList = *pBodyList;
#line 246
  body = *pBody;
#line 248
  if ((unsigned long )body == (unsigned long )((void *)0)) {
#line 249
    body = bodyList->body;
  } else {
#line 251
    body = body->next;
#line 252
    if ((unsigned long )body == (unsigned long )((void *)0)) {
#line 253
      bodyList = bodyList->next;
#line 254
      *pBodyList = bodyList;
#line 255
      *pBody = body;
#line 256
      return (0);
    }
  }
  {
#line 259
  tmp = getClass(body->name);
#line 259
  token->class = tmp;
  }
#line 259
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 260
    errMes((char *)"undefined class \"%s\"", body->name);
    }
  }
#line 262
  token->abort = body->abort;
#line 263
  *pBodyList = bodyList;
#line 264
  *pBody = body;
#line 265
  return (1);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FA *makeNewFA(void) 
{ 
  FA *newFA ;
  void *tmp ;

  {
  {
#line 271
  tmp = calloc((size_t )1, sizeof(FA ));
#line 271
  newFA = (FA *)tmp;
  }
#line 271
  if ((unsigned long )newFA == (unsigned long )((void *)0)) {
    {
#line 272
    errMes((char *)"Can\'t alloc Finite Automaton buffer");
    }
  }
#line 274
  newFA->stat = -1;
#line 275
  FAtotal ++;
#line 276
  return (newFA);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FA *appendFA(FA *fa , int input , HIS *his ) 
{ 
  FA *newFA ;

  {
  {
#line 283
  newFA = makeNewFA();
#line 284
  connectFAforNFA(fa, input, newFA, his);
  }
#line 285
  return (newFA);
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void connectFAforNFA(FA *fa , int inp , FA *nextFA , HIS *his ) 
{ 
  CLASSFLAGS startOnArc ;

  {
  {
#line 290
  startOnArc = fa->aStart;
#line 292
  fa->aStart = (CLASSFLAGS )0;
#line 293
  connectFA(fa, inp, nextFA, (CLASSFLAGS )0, startOnArc);
#line 294
  appendHisArc(his, fa, inp, nextFA, (CLASSFLAGS )0, startOnArc);
  }
#line 295
  return;
}
}
#line 297 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void connectFA(FA *fa , int inp , FA *nextFA , CLASSFLAGS accpt , CLASSFLAGS start ) 
{ 


  {
  {
#line 301
  fa->nsList = appendArc(fa->nsList, nextFA, inp, accpt, start);
#line 302
  (nextFA->psNum) ++;
  }
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
ARC *appendArc(ARC *top , FA *dst , int inp , CLASSFLAGS accpt , CLASSFLAGS start ) 
{ 
  ARC *newArc ;
  ARC *curArc ;
  ARC *nextArc ;
  void *tmp ;

  {
  {
#line 310
  curArc = (ARC *)((void *)0);
#line 313
  tmp = calloc((size_t )1, sizeof(ARC ));
#line 313
  newArc = (ARC *)tmp;
  }
#line 313
  if ((unsigned long )newArc == (unsigned long )((void *)0)) {
    {
#line 314
    errMes((char *)"Can\'t alloc forward arc buffer of finite automaton.");
    }
  }
#line 316
  newArc->inp = inp;
#line 317
  newArc->fa = dst;
#line 318
  newArc->start = start;
#line 319
  newArc->accpt = accpt;
#line 321
  nextArc = top;
#line 321
  if ((unsigned long )nextArc != (unsigned long )((void *)0)) {
    {
#line 322
    while (1) {
      while_continue: /* CIL Label */ ;
#line 323
      if (nextArc->inp > inp) {
#line 323
        goto while_break;
      }
#line 324
      if (nextArc->inp == inp) {
#line 324
        if ((unsigned long )nextArc->fa == (unsigned long )dst) {
#line 325
          nextArc->start |= newArc->start;
#line 326
          nextArc->accpt |= newArc->accpt;
#line 327
          return (top);
        }
      }
#line 329
      curArc = nextArc;
#line 330
      nextArc = nextArc->next;
#line 330
      if ((unsigned long )nextArc == (unsigned long )((void *)0)) {
#line 330
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 333
  if ((unsigned long )curArc == (unsigned long )((void *)0)) {
#line 334
    newArc->next = top;
#line 335
    return (newArc);
  } else {
#line 337
    newArc->next = nextArc;
#line 338
    curArc->next = newArc;
#line 339
    return (top);
  }
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void appendHisArc(HIS *his , FA *fa , int inp , FA *nextFA , CLASSFLAGS accpt , CLASSFLAGS start ) 
{ 


  {
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if ((unsigned long )his != (unsigned long )((void *)0)) {
#line 347
      if (! ((unsigned long )his->fa == (unsigned long )fa)) {
#line 347
        goto while_break;
      }
    } else {
#line 347
      goto while_break;
    }
    {
#line 348
    his->nsList = appendArc(his->nsList, nextFA, inp, accpt, start);
    }
#line 349
    if ((unsigned long )his->cloneFA != (unsigned long )((void *)0)) {
#line 349
      (his->cloneFA)->nsList = his->nsList;
    }
#line 350
    his = his->prev;
#line 351
    (nextFA->psNum) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void chkClassInfo(CLASS *class ) 
{ 
  CLASS *freeClass ;
  int wrong ;

  {
#line 358
  wrong = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    if ((unsigned long )class == (unsigned long )((void *)0)) {
#line 361
      goto while_break;
    }
#line 362
    if (class->branch > 0) {
#line 362
      if (! class->usedFA) {
#line 362
        if (! class->tmp) {
          {
#line 363
          warnMes((char *)"Class \"%s\" isn\'t used", class->name);
          }
        }
      }
    }
#line 365
    if (! class->used) {
      {
#line 366
      warnMes((char *)"\"%s\" in voca not referred by grammar", class->name);
#line 367
      wrong = 1;
      }
    }
    {
#line 369
    freeClass = class;
#line 370
    class = class->next;
#line 371
    free((void *)freeClass);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (wrong) {
    {
#line 374
    errMes((char *)"Some vocabulary not referred in grammar, compilation terminated");
    }
  }
#line 376
  return;
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
FA *getRecursion(CLASS *class , HIS *his ) 
{ 


  {
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! ((unsigned long )his != (unsigned long )((void *)0))) {
#line 380
      goto while_break;
    }
#line 381
    if ((unsigned long )his->class == (unsigned long )class) {
#line 382
      if ((unsigned long )his->cloneFA == (unsigned long )((void *)0)) {
        {
#line 383
        his->cloneFA = makeNewFA();
#line 384
        (his->cloneFA)->nsList = his->nsList;
        }
      }
#line 386
      return (his->cloneFA);
    }
#line 388
    his = his->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return ((FA *)((void *)0));
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
void chkLeftRecursion(CLASS *class , FA *fa , HIS *his ) 
{ 
  HIS *hisPtr ;
  char *tmp ;

  {
#line 395
  hisPtr = his;
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if ((unsigned long )hisPtr != (unsigned long )((void *)0)) {
#line 397
      if (! ((unsigned long )hisPtr->fa == (unsigned long )fa)) {
#line 397
        goto while_break;
      }
    } else {
#line 397
      goto while_break;
    }
#line 398
    if ((unsigned long )hisPtr->class == (unsigned long )class) {
      {
#line 399
      tmp = strAncestors(his, hisPtr);
#line 399
      errMes((char *)"Left recusion is formed %s", tmp);
      }
    }
#line 401
    hisPtr = hisPtr->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return;
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
static char ancestorsList[1024]  ;
#line 413 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
static char className[1024]  ;
#line 405 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
char *strAncestors(HIS *me , HIS *ancestor ) 
{ 


  {
#line 408
  if ((unsigned long )me == (unsigned long )((void *)0)) {
    {
#line 409
    sprintf((char */* __restrict  */)(ancestorsList), (char const   */* __restrict  */)"in class,\"%s\"",
            StartSymbol->name);
    }
  } else
#line 410
  if ((unsigned long )me == (unsigned long )ancestor) {
    {
#line 411
    sprintf((char */* __restrict  */)(ancestorsList), (char const   */* __restrict  */)"in class,\"%s\"",
            (me->class)->name);
    }
  } else {
    {
#line 414
    strcpy((char */* __restrict  */)(ancestorsList), (char const   */* __restrict  */)"between classes");
    }
    {
#line 415
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 416
      sprintf((char */* __restrict  */)(className), (char const   */* __restrict  */)",\"%s\"",
              (me->class)->name);
#line 417
      strcat((char */* __restrict  */)(ancestorsList), (char const   */* __restrict  */)(className));
      }
#line 418
      if ((unsigned long )me == (unsigned long )ancestor) {
#line 418
        goto while_break;
      }
#line 419
      me = me->prev;
#line 419
      if ((unsigned long )me == (unsigned long )((void *)0)) {
#line 419
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 422
  return (ancestorsList);
}
}
#line 425 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/nfa.c"
CLASS *getClass(char *name ) 
{ 
  CLASS *class ;
  int tmp ;

  {
#line 427
  class = ClassList;
#line 428
  if ((unsigned long )class == (unsigned long )((void *)0)) {
#line 428
    return ((CLASS *)((void *)0));
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 430
    tmp = strcmp((char const   *)(class->name), (char const   *)name);
    }
#line 430
    if (tmp == 0) {
#line 431
      class->used = (FLAG )1;
#line 432
      return (class);
    }
#line 434
    class = class->next;
#line 435
    if ((unsigned long )class == (unsigned long )((void *)0)) {
#line 435
      return ((CLASS *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 689 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
char *gettoken(char *line___0 , char *dst ) ;
#line 17
BODY *appendTerm(BODY *list , char *name ) ;
#line 18
BODY *entryTerm(char *name , BODY *body , int listLen ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
static char line[1000]  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
void setVoca(void) 
{ 
  char token1[256] ;
  char token2[256] ;
  int virgin ;
  int bodynum ;
  BODY *bodyList ;
  FILE *fp___2 ;
  char identifier[256] ;
  unsigned int tmp ;
  char *ptr ;
  char *tmp___0 ;

  {
#line 25
  virgin = 1;
#line 26
  bodynum = 0;
#line 27
  bodyList = (BODY *)((void *)0);
#line 30
  identifier[0] = (char )'\000';
#line 30
  tmp = 1U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (tmp >= 256U) {
#line 30
      goto while_break;
    }
#line 30
    identifier[tmp] = (char)0;
#line 30
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  fp___2 = fopen((char const   */* __restrict  */)(VocaFile), (char const   */* __restrict  */)"r");
  }
#line 32
  if ((unsigned long )fp___2 == (unsigned long )((void *)0)) {
    {
#line 33
    errMes((char *)"Can\'t open vocabulary file\"%s\"", VocaFile);
    }
  }
#line 35
  if (! SW_Quiet) {
#line 36
    if (NoNewLine) {
      {
#line 36
      _IO_putc('\n', stderr);
#line 36
      NoNewLine = 0;
      }
    }
    {
#line 37
    fputs((char const   */* __restrict  */)"Now parsing vocabulary file\n", (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 40
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 42
    ptr = line;
#line 43
    tmp___0 = fgets((char */* __restrict  */)(line), 1000, (FILE */* __restrict  */)fp___2);
    }
#line 43
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 44
      entryTerm(identifier, bodyList, bodynum);
      }
#line 45
      goto while_break___0;
    }
#line 47
    if ((int )line[0] == 0) {
#line 47
      goto while_continue___0;
    }
#line 48
    if ((int )line[0] == 35) {
      {
#line 49
      ptr = gettoken(ptr, token1);
      }
#line 49
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 49
        goto while_continue___0;
      }
#line 50
      if (! virgin) {
        {
#line 51
        entryTerm(identifier, bodyList, bodynum);
#line 52
        bodyList = (BODY *)((void *)0);
#line 53
        bodynum = 0;
        }
      } else {
#line 55
        virgin = 0;
      }
      {
#line 57
      strcpy((char */* __restrict  */)(identifier), (char const   */* __restrict  */)(token1 + 1));
      }
#line 58
      goto while_continue___0;
    } else {
      {
#line 60
      ptr = gettoken(ptr, token1);
      }
#line 61
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 61
        goto while_continue___0;
      }
      {
#line 62
      ptr = gettoken(ptr, token2);
      }
#line 63
      if ((unsigned long )ptr == (unsigned long )((void *)0)) {
        {
#line 64
        bodyList = appendTerm(bodyList, token1);
        }
      } else {
        {
#line 66
        bodyList = appendTerm(bodyList, token2);
        }
      }
#line 68
      bodynum ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
char *gettoken(char *line___0 , char *dst ) 
{ 
  char *ptr ;
  char ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 75
  ptr = dst;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    tmp = line___0;
#line 79
    line___0 ++;
#line 79
    ch = *tmp;
#line 80
    if ((int )ch == 0) {
#line 80
      return ((char *)((void *)0));
    }
#line 78
    if (! ((int )ch == 32)) {
#line 78
      if (! ((int )ch == 9)) {
#line 78
        if (! ((int )ch == 13)) {
#line 78
          if (! ((int )ch == 10)) {
#line 78
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    tmp___0 = ptr;
#line 84
    ptr ++;
#line 84
    *tmp___0 = ch;
#line 85
    tmp___1 = line___0;
#line 85
    line___0 ++;
#line 85
    ch = *tmp___1;
#line 86
    if ((int )ch == 32) {
#line 87
      *ptr = (char )'\000';
#line 88
      return (line___0);
    } else
#line 86
    if ((int )ch == 9) {
#line 87
      *ptr = (char )'\000';
#line 88
      return (line___0);
    } else
#line 86
    if ((int )ch == 13) {
#line 87
      *ptr = (char )'\000';
#line 88
      return (line___0);
    } else
#line 86
    if ((int )ch == 10) {
#line 87
      *ptr = (char )'\000';
#line 88
      return (line___0);
    }
#line 90
    if ((int )ch == 0) {
#line 91
      *ptr = (char )'\000';
#line 92
      return (line___0 - 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
BODY *appendTerm(BODY *list , char *name ) 
{ 
  BODY *newTerm ;
  void *tmp ;

  {
  {
#line 101
  tmp = malloc(sizeof(BODY ));
#line 101
  newTerm = (BODY *)tmp;
  }
#line 101
  if ((unsigned long )newTerm == (unsigned long )((void *)0)) {
    {
#line 102
    errMes((char *)"Can\'t alloc term list buffer");
    }
  }
  {
#line 104
  strcpy((char */* __restrict  */)(newTerm->name), (char const   */* __restrict  */)name);
#line 105
  newTerm->abort = (FLAG )0;
#line 106
  newTerm->next = list;
  }
#line 107
  return (newTerm);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
static int InputNo  =    0;
#line 110 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/voca.c"
BODY *entryTerm(char *name , BODY *body , int listLen ) 
{ 
  CLASS *class ;
  BODYLIST *bodyList ;
  CLASS *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 116
  tmp = getClass(name);
  }
#line 116
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 117
    errMes((char *)"Class redefined \"%s\"", name);
    }
  }
  {
#line 119
  tmp___0 = malloc(sizeof(CLASS ));
#line 119
  class = (CLASS *)tmp___0;
  }
#line 119
  if ((unsigned long )class == (unsigned long )((void *)0)) {
    {
#line 120
    errMes((char *)"Can\'t alloc memory for Class Finite Automaton.");
    }
  }
  {
#line 122
  tmp___1 = InputNo;
#line 122
  InputNo ++;
#line 122
  class->no = (short )tmp___1;
#line 123
  strcpy((char */* __restrict  */)(class->name), (char const   */* __restrict  */)name);
#line 124
  class->branch = - listLen;
#line 125
  class->usedFA = (FLAG )0;
#line 126
  class->used = (FLAG )0;
#line 127
  class->tmp = (FLAG )0;
  }
#line 128
  if ((unsigned long )ClassListTail == (unsigned long )((void *)0)) {
#line 129
    ClassList = class;
  } else {
#line 131
    ClassListTail->next = class;
  }
  {
#line 133
  ClassListTail = class;
#line 135
  tmp___2 = malloc(sizeof(BODYLIST ));
#line 135
  bodyList = (BODYLIST *)tmp___2;
  }
#line 135
  if ((unsigned long )bodyList == (unsigned long )((void *)0)) {
    {
#line 136
    errMes((char *)"Can\'t alloc nonterminal list buffer");
    }
  }
#line 138
  bodyList->body = body;
#line 139
  bodyList->next = (struct _BODYLIST *)((void *)0);
#line 150
  return ((BODY *)((void *)0));
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 49 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 6 "gram.y"
void appendNonTerm(char *name , int modeAssign ) ;
#line 7
BODY *setNonTerm(void) ;
#line 8
CLASS *entryNonTerm(char *name , BODY *body , int modeAccpt , int start , int member ,
                    int tmp ) ;
#line 9
void pushBody(CLASS *class , BODY *newbody ) ;
#line 10
int unifyBody(char *className___0 , BODY *body , BODY *newbody ) ;
#line 11
char *getNewClassName(char *keyname ) ;
#line 12
void outputHeader(char *name ) ;
#line 13
char *chkNoInstantClass(void) ;
#line 25 "gram.y"
static char HeadName[256]  ;
#line 26 "gram.y"
static char BodyName[100][256]  ;
#line 27 "gram.y"
static int BodyNo  =    0;
#line 28 "gram.y"
static int ClassNo  =    0;
#line 29 "gram.y"
static int ModeAssignAccptFlag  =    1;
#line 30 "gram.y"
static int BlockReverseSw  ;
#line 31 "gram.y"
static int ModeBlock  =    0;
#line 32 "gram.y"
static int CurClassNo  =    0;
#line 33 "gram.y"
static int StartFlag  =    0;
#line 34 "gram.y"
static FILE *FPheader  ;
#line 35 "gram.y"
static int ErrParse  =    0;
#line 36 "gram.y"
static int GramModifyNum  =    0;
#line 55 "gram.y"
static char const   yytranslate[268]  = 
#line 55
  {      (char const   )0,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2, 
        (char const   )1,      (char const   )3,      (char const   )4,      (char const   )5, 
        (char const   )6,      (char const   )7,      (char const   )8,      (char const   )9, 
        (char const   )10,      (char const   )11,      (char const   )12,      (char const   )13};
#line 131 "gram.y"
static short const   yyr1[28]  = 
#line 131
  {      (short const   )0,      (short const   )14,      (short const   )14,      (short const   )15, 
        (short const   )15,      (short const   )15,      (short const   )15,      (short const   )15, 
        (short const   )16,      (short const   )17,      (short const   )17,      (short const   )18, 
        (short const   )18,      (short const   )19,      (short const   )19,      (short const   )19, 
        (short const   )20,      (short const   )20,      (short const   )21,      (short const   )22, 
        (short const   )22,      (short const   )23,      (short const   )23,      (short const   )24, 
        (short const   )25,      (short const   )25,      (short const   )26,      (short const   )26};
#line 139 "gram.y"
static short const   yyr2[28]  = 
#line 139
  {      (short const   )0,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )2, 
        (short const   )6,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )1,      (short const   )2,      (short const   )4,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )2,      (short const   )1, 
        (short const   )2,      (short const   )1,      (short const   )1,      (short const   )1};
#line 149 "gram.y"
static short const   yydefact[44]  = 
#line 149
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )25, 
        (short const   )0,      (short const   )0,      (short const   )9,      (short const   )21, 
        (short const   )26,      (short const   )27,      (short const   )0,      (short const   )3, 
        (short const   )0,      (short const   )4,      (short const   )16,      (short const   )0, 
        (short const   )5,      (short const   )6,      (short const   )7,      (short const   )24, 
        (short const   )10,      (short const   )17,      (short const   )22,      (short const   )2, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )23, 
        (short const   )0,      (short const   )19,      (short const   )0,      (short const   )11, 
        (short const   )13,      (short const   )0,      (short const   )15,      (short const   )18, 
        (short const   )20,      (short const   )0,      (short const   )12,      (short const   )14, 
        (short const   )8,      (short const   )0,      (short const   )0,      (short const   )0};
#line 158 "gram.y"
static short const   yydefgoto[13]  = 
#line 158
  {      (short const   )23,      (short const   )10,      (short const   )11,      (short const   )12, 
        (short const   )30,      (short const   )31,      (short const   )13,      (short const   )14, 
        (short const   )28,      (short const   )15,      (short const   )29,      (short const   )16, 
        (short const   )17};
#line 164 "gram.y"
static short const   yypact[44]  = 
#line 164
  {      (short const   )29,      (short const   )14,      (short const   )5,      (short const   )-32768, 
        (short const   )36,      (short const   )0,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )2,      (short const   )-32768, 
        (short const   )20,      (short const   )-32768,      (short const   )-32768,      (short const   )25, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )5,      (short const   )34,      (short const   )8,      (short const   )-32768, 
        (short const   )5,      (short const   )34,      (short const   )42,      (short const   )8, 
        (short const   )-32768,      (short const   )-5,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )5,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-32768,      (short const   )49,      (short const   )50,      (short const   )-32768};
#line 173 "gram.y"
static short const   yypgoto[13]  = 
#line 173
  {      (short const   )51,      (short const   )-32768,      (short const   )-32768,      (short const   )-32768, 
        (short const   )21,      (short const   )-32768,      (short const   )-32768,      (short const   )-3, 
        (short const   )24,      (short const   )12,      (short const   )-32768,      (short const   )-32768, 
        (short const   )-2};
#line 183 "gram.y"
static short const   yytable[54]  = 
#line 183
  {      (short const   )19,      (short const   )21,      (short const   )-1,      (short const   )1, 
        (short const   )25,      (short const   )2,      (short const   )3,      (short const   )8, 
        (short const   )9,      (short const   )4,      (short const   )5,      (short const   )22, 
        (short const   )6,      (short const   )7,      (short const   )8,      (short const   )9, 
        (short const   )5,      (short const   )8,      (short const   )9,      (short const   )7, 
        (short const   )8,      (short const   )9,      (short const   )26,      (short const   )32, 
        (short const   )34,      (short const   )24,      (short const   )35,      (short const   )18, 
        (short const   )32,      (short const   )34,      (short const   )1,      (short const   )39, 
        (short const   )2,      (short const   )3,      (short const   )25,      (short const   )40, 
        (short const   )4,      (short const   )5,      (short const   )33,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )33, 
        (short const   )5,      (short const   )27,      (short const   )20,      (short const   )7, 
        (short const   )37,      (short const   )42,      (short const   )43,      (short const   )41, 
        (short const   )38,      (short const   )36};
#line 193 "gram.y"
static short const   yycheck[54]  = 
#line 193
  {      (short const   )2,      (short const   )4,      (short const   )0,      (short const   )1, 
        (short const   )9,      (short const   )3,      (short const   )4,      (short const   )12, 
        (short const   )13,      (short const   )7,      (short const   )8,      (short const   )11, 
        (short const   )10,      (short const   )11,      (short const   )12,      (short const   )13, 
        (short const   )8,      (short const   )12,      (short const   )13,      (short const   )11, 
        (short const   )12,      (short const   )13,      (short const   )24,      (short const   )26, 
        (short const   )26,      (short const   )5,      (short const   )28,      (short const   )13, 
        (short const   )31,      (short const   )31,      (short const   )1,      (short const   )33, 
        (short const   )3,      (short const   )4,      (short const   )9,      (short const   )37, 
        (short const   )7,      (short const   )8,      (short const   )26,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )31, 
        (short const   )8,      (short const   )11,      (short const   )10,      (short const   )11, 
        (short const   )6,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )31,      (short const   )29};
#line 341 "/usr/share/bison/bison.simple"
int yyparse(void) ;
#line 373 "/usr/share/bison/bison.simple"
int yychar  ;
#line 373 "/usr/share/bison/bison.simple"
char *yylval  ;
#line 373 "/usr/share/bison/bison.simple"
int yynerrs  ;
#line 573
int yylex(void) ;
#line 799
int yyerror(char *mes ) ;
#line 376 "/usr/share/bison/bison.simple"
int yyparse(void) 
{ 
  register int yystate ;
  register int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yychar1 ;
  short yyssa[200] ;
  short *yyss ;
  register short *yyssp ;
  char *yyvsa[200] ;
  char **yyvs ;
  register char **yyvsp ;
  unsigned long yystacksize ;
  char *yyval ;
  int yylen ;
  unsigned long yysize ;
  short *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int tmp___0 ;

  {
#line 391
  yychar1 = 0;
#line 403
  yyss = yyssa;
#line 408
  yyvs = yyvsa;
#line 424
  yystacksize = 200UL;
#line 440
  yystate = 0;
#line 441
  yyerrstatus = 0;
#line 442
  yynerrs = 0;
#line 443
  yychar = -2;
#line 450
  yyssp = yyss;
#line 451
  yyvsp = yyvs;
#line 455
  goto yysetstate;
  yynewstate: 
#line 464
  yyssp ++;
  yysetstate: 
#line 467
  *yyssp = (short )yystate;
#line 469
  if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 472
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 508
    if (yystacksize >= 10000UL) {
#line 509
      goto yyoverflowlab;
    }
#line 510
    yystacksize *= 2UL;
#line 511
    if (yystacksize > 10000UL) {
#line 512
      yystacksize = 10000UL;
    }
    {
#line 515
    yyss1 = yyss;
#line 516
    tmp = __builtin_alloca(yystacksize * (sizeof(short ) + sizeof(char *)) + (sizeof(union yyalloc ) - 1UL));
#line 516
    yyptr = (union yyalloc *)tmp;
    }
#line 518
    if (! yyptr) {
#line 519
      goto yyoverflowlab;
    }
    {
#line 520
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 520
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 520
      yyss = & yyptr->yyss;
#line 520
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 520
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 520
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 521
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 521
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 521
      yyvs = & yyptr->yyvs;
#line 521
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 521
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 521
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 526
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 527
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 527
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 532
    yyssp = (yyss + yysize) - 1;
#line 533
    yyvsp = (yyvs + yysize) - 1;
#line 541
    if ((unsigned long )yyssp >= (unsigned long )((yyss + yystacksize) - 1)) {
#line 542
      goto yyabortlab;
    }
  }
#line 547
  goto yybackup;
  yybackup: 
#line 561
  yyn = (int )yypact[yystate];
#line 562
  if (yyn == -32768) {
#line 563
    goto yydefault;
  }
#line 570
  if (yychar == -2) {
    {
#line 573
    yychar = yylex();
    }
  }
#line 578
  if (yychar <= 0) {
#line 580
    yychar1 = 0;
#line 581
    yychar = 0;
  } else
#line 587
  if ((unsigned int )yychar <= 267U) {
#line 587
    yychar1 = (int )yytranslate[yychar];
  } else {
#line 587
    yychar1 = 27;
  }
#line 606
  yyn += yychar1;
#line 607
  if (yyn < 0) {
#line 608
    goto yydefault;
  } else
#line 607
  if (yyn > 53) {
#line 608
    goto yydefault;
  } else
#line 607
  if ((int const   )yycheck[yyn] != (int const   )yychar1) {
#line 608
    goto yydefault;
  }
#line 610
  yyn = (int )yytable[yyn];
#line 619
  if (yyn < 0) {
#line 621
    if (yyn == -32768) {
#line 622
      goto yyerrlab;
    }
#line 623
    yyn = - yyn;
#line 624
    goto yyreduce;
  } else
#line 626
  if (yyn == 0) {
#line 627
    goto yyerrlab;
  }
#line 629
  if (yyn == 43) {
#line 630
    goto yyacceptlab;
  }
#line 637
  if (yychar != 0) {
#line 638
    yychar = -2;
  }
#line 640
  yyvsp ++;
#line 640
  *yyvsp = yylval;
#line 647
  if (yyerrstatus) {
#line 648
    yyerrstatus --;
  }
#line 650
  yystate = yyn;
#line 651
  goto yynewstate;
  yydefault: 
#line 658
  yyn = (int )yydefact[yystate];
#line 659
  if (yyn == 0) {
#line 660
    goto yyerrlab;
  }
#line 661
  goto yyreduce;
  yyreduce: 
#line 669
  yylen = (int )yyr2[yyn];
#line 679
  yyval = *(yyvsp + (1 - yylen));
  {
#line 707
  if (yyn == 7) {
#line 707
    goto case_7;
  }
#line 63
  if (yyn == 9) {
#line 63 "gram.y"
    goto case_9;
  }
#line 71
  if (yyn == 10) {
#line 71
    goto case_10;
  }
#line 76
  if (yyn == 13) {
#line 76
    goto case_13;
  }
#line 83
  if (yyn == 14) {
#line 83
    goto case_14;
  }
#line 87
  if (yyn == 16) {
#line 87
    goto case_16;
  }
#line 93
  if (yyn == 17) {
#line 93
    goto case_17;
  }
#line 97
  if (yyn == 21) {
#line 97
    goto case_21;
  }
#line 106
  if (yyn == 22) {
#line 106
    goto case_22;
  }
#line 111
  if (yyn == 23) {
#line 111
    goto case_23;
  }
#line 116
  if (yyn == 24) {
#line 116
    goto case_24;
  }
#line 121
  if (yyn == 25) {
#line 121
    goto case_25;
  }
#line 705 "/usr/share/bison/bison.simple"
  goto switch_break;
  case_7: /* CIL Label */ 
#line 60 "gram.y"
  yyerrstatus = 0;
#line 62
  goto switch_break;
  case_9: /* CIL Label */ 
#line 67
  BlockReverseSw = 0;
#line 68
  if (ModeAssignAccptFlag) {
    {
#line 68
    outputHeader(*(yyvsp + 0));
    }
  }
#line 70
  goto switch_break;
  case_10: /* CIL Label */ 
#line 72
  BlockReverseSw = 1;
#line 73
  if (! ModeAssignAccptFlag) {
    {
#line 73
    outputHeader(*(yyvsp + 0));
    }
  }
#line 75
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 80
  appendNonTerm(HeadName, ModeAssignAccptFlag ^ BlockReverseSw);
  }
#line 82
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 84
  entryNonTerm(HeadName, (BODY *)((void *)0), ModeAssignAccptFlag ^ BlockReverseSw,
               0, 1, 0);
  }
#line 86
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 90
  appendNonTerm(HeadName, ModeAssignAccptFlag);
  }
#line 92
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 94
  appendNonTerm(HeadName, ! ModeAssignAccptFlag);
  }
#line 96
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 103
  strcpy((char */* __restrict  */)(HeadName), (char const   */* __restrict  */)*(yyvsp + 0));
  }
#line 105
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 107
  StartFlag = 1;
#line 108
  strcpy((char */* __restrict  */)(HeadName), (char const   */* __restrict  */)*(yyvsp + 0));
  }
#line 110
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 113
  tmp___0 = BodyNo;
#line 113
  BodyNo ++;
#line 113
  strcpy((char */* __restrict  */)(BodyName[tmp___0]), (char const   */* __restrict  */)*(yyvsp + 0));
  }
#line 115
  goto switch_break;
  case_24: /* CIL Label */ 
#line 118
  ModeAssignAccptFlag = 1;
#line 120
  goto switch_break;
  case_25: /* CIL Label */ 
#line 122
  ModeAssignAccptFlag = 0;
#line 124
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 707 "/usr/share/bison/bison.simple"
  yyvsp -= yylen;
#line 708
  yyssp -= yylen;
#line 724
  yyvsp ++;
#line 724
  *yyvsp = yyval;
#line 733
  yyn = (int )yyr1[yyn];
#line 735
  yystate = (int )((int const   )yypgoto[yyn - 14] + (int const   )*yyssp);
#line 736
  if (yystate >= 0) {
#line 736
    if (yystate <= 53) {
#line 736
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 737
        yystate = (int )yytable[yystate];
      } else {
#line 739
        yystate = (int )yydefgoto[yyn - 14];
      }
    } else {
#line 739
      yystate = (int )yydefgoto[yyn - 14];
    }
  } else {
#line 739
    yystate = (int )yydefgoto[yyn - 14];
  }
#line 741
  goto yynewstate;
  yyerrlab: 
#line 749
  if (! yyerrstatus) {
    {
#line 751
    yynerrs ++;
#line 799
    yyerror("parse error");
    }
  }
#line 801
  goto yyerrlab1;
  yyerrlab1: 
#line 808
  if (yyerrstatus == 3) {
#line 814
    if (yychar == 0) {
#line 815
      goto yyabortlab;
    }
#line 818
    yychar = -2;
  }
#line 824
  yyerrstatus = 3;
#line 826
  goto yyerrhandle;
  yyerrdefault: 
#line 850
  if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 851
    goto yyabortlab;
  }
#line 852
  yyvsp --;
#line 853
  yyssp --;
#line 853
  yystate = (int )*yyssp;
  yyerrhandle: 
#line 873
  yyn = (int )yypact[yystate];
#line 874
  if (yyn == -32768) {
#line 875
    goto yyerrdefault;
  }
#line 877
  yyn ++;
#line 878
  if (yyn < 0) {
#line 879
    goto yyerrdefault;
  } else
#line 878
  if (yyn > 53) {
#line 879
    goto yyerrdefault;
  } else
#line 878
  if ((int const   )yycheck[yyn] != 1) {
#line 879
    goto yyerrdefault;
  }
#line 881
  yyn = (int )yytable[yyn];
#line 882
  if (yyn < 0) {
#line 884
    if (yyn == -32768) {
#line 885
      goto yyerrdefault;
    }
#line 886
    yyn = - yyn;
#line 887
    goto yyreduce;
  } else
#line 889
  if (yyn == 0) {
#line 890
    goto yyerrdefault;
  }
#line 892
  if (yyn == 43) {
#line 893
    goto yyacceptlab;
  }
#line 897
  yyvsp ++;
#line 897
  *yyvsp = yylval;
#line 902
  yystate = yyn;
#line 903
  goto yynewstate;
  yyacceptlab: 
#line 910
  yyresult = 0;
#line 911
  goto yyreturn;
  yyabortlab: 
#line 917
  yyresult = 1;
#line 918
  goto yyreturn;
  yyoverflowlab: 
  {
#line 924
  yyerror("parser stack overflow");
#line 925
  yyresult = 2;
  }
  yyreturn: 
#line 930
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 931
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 931
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 933
  return (yyresult);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
int yywrap(void) 
{ 


  {
#line 82
  return (1);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
int yyleng  ;
#line 121
FILE *yyin ;
#line 121
FILE *yyout ;
#line 220 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static YY_BUFFER_STATE yy_current_buffer  =    (YY_BUFFER_STATE )0;
#line 230 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static char yy_hold_char  ;
#line 232 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int yy_n_chars  ;
#line 238 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static char *yy_c_buf_p  =    (char *)0;
#line 239 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int yy_init  =    1;
#line 240 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int yy_start  =    0;
#line 245 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int yy_did_buffer_switch_on_eof  ;
#line 247
void yyrestart(FILE *input_file ) ;
#line 249
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 250
void yy_load_buffer_state(void) ;
#line 251
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size___1 ) ;
#line 252
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 253
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 254
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 257
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size___1 ) ;
#line 258
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) ;
#line 259
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) ;
#line 261
static void *yy_flex_alloc(yy_size_t size___1 ) ;
#line 262
static void *yy_flex_realloc(void *ptr , yy_size_t size___1 ) ;
#line 263
static void yy_flex_free(void *ptr ) ;
#line 284 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
FILE *yyin  =    (FILE *)0;
#line 284 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
FILE *yyout  =    (FILE *)0;
#line 286 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
char *yytext  ;
#line 289
static yy_state_type yy_get_previous_state(void) ;
#line 290
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 291
static int yy_get_next_buffer(void) ;
#line 292
static void yy_fatal_error(char const   *msg ) ;
#line 306 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static short const   yy_accept[33]  = 
#line 306
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )15, 
        (short const   )13,      (short const   )12,      (short const   )10,      (short const   )7, 
        (short const   )13,      (short const   )13,      (short const   )8,      (short const   )2, 
        (short const   )9,      (short const   )13,      (short const   )3,      (short const   )4, 
        (short const   )0,      (short const   )11,      (short const   )0,      (short const   )0, 
        (short const   )2,      (short const   )1,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )0,      (short const   )0, 
        (short const   )0,      (short const   )0,      (short const   )5,      (short const   )6, 
        (short const   )0};
#line 314 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int const   yy_ec[256]  = 
#line 314
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )2,      (int const   )3,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )4,      (int const   )1,      (int const   )5, 
        (int const   )1,      (int const   )6,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )7,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )9,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )10,      (int const   )11,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )12,      (int const   )8,      (int const   )13, 
        (int const   )8,      (int const   )14,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )15,      (int const   )16, 
        (int const   )8,      (int const   )8,      (int const   )17,      (int const   )18, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )8, 
        (int const   )1,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )8, 
        (int const   )8,      (int const   )8,      (int const   )8,      (int const   )19, 
        (int const   )1,      (int const   )20,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1};
#line 346 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static int const   yy_meta[21]  = 
#line 346
  {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )1,      (int const   )1,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )1, 
        (int const   )1};
#line 352 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static short const   yy_base[36]  = 
#line 352
  {      (short const   )0,      (short const   )0,      (short const   )0,      (short const   )39, 
        (short const   )40,      (short const   )40,      (short const   )40,      (short const   )40, 
        (short const   )35,      (short const   )10,      (short const   )40,      (short const   )0, 
        (short const   )40,      (short const   )0,      (short const   )40,      (short const   )40, 
        (short const   )34,      (short const   )40,      (short const   )18,      (short const   )22, 
        (short const   )0,      (short const   )0,      (short const   )16,      (short const   )18, 
        (short const   )18,      (short const   )15,      (short const   )17,      (short const   )12, 
        (short const   )13,      (short const   )15,      (short const   )40,      (short const   )40, 
        (short const   )40,      (short const   )24,      (short const   )21,      (short const   )20};
#line 360 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static short const   yy_def[36]  = 
#line 360
  {      (short const   )0,      (short const   )32,      (short const   )1,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )33,      (short const   )32,      (short const   )32,      (short const   )34, 
        (short const   )32,      (short const   )35,      (short const   )32,      (short const   )32, 
        (short const   )33,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )34,      (short const   )35,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )0,      (short const   )32,      (short const   )32,      (short const   )32};
#line 368 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static short const   yy_nxt[61]  = 
#line 368
  {      (short const   )0,      (short const   )4,      (short const   )5,      (short const   )6, 
        (short const   )7,      (short const   )8,      (short const   )9,      (short const   )10, 
        (short const   )11,      (short const   )12,      (short const   )13,      (short const   )11, 
        (short const   )11,      (short const   )11,      (short const   )11,      (short const   )11, 
        (short const   )11,      (short const   )11,      (short const   )11,      (short const   )14, 
        (short const   )15,      (short const   )18,      (short const   )21,      (short const   )20, 
        (short const   )19,      (short const   )16,      (short const   )16,      (short const   )31, 
        (short const   )30,      (short const   )29,      (short const   )28,      (short const   )27, 
        (short const   )26,      (short const   )25,      (short const   )24,      (short const   )23, 
        (short const   )22,      (short const   )17,      (short const   )17,      (short const   )32, 
        (short const   )3,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32};
#line 378 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static short const   yy_chk[61]  = 
#line 378
  {      (short const   )0,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )1,      (short const   )1,      (short const   )1, 
        (short const   )1,      (short const   )9,      (short const   )35,      (short const   )34, 
        (short const   )9,      (short const   )33,      (short const   )33,      (short const   )29, 
        (short const   )28,      (short const   )27,      (short const   )26,      (short const   )25, 
        (short const   )24,      (short const   )23,      (short const   )22,      (short const   )19, 
        (short const   )18,      (short const   )16,      (short const   )8,      (short const   )3, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32,      (short const   )32,      (short const   )32,      (short const   )32, 
        (short const   )32};
#line 388 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static yy_state_type yy_last_accepting_state  ;
#line 389 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/mkdfa/mkfa-1.44-flex/lex.yy.c"
static char *yy_last_accepting_cpos  ;
#line 560 "lex.yy.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  register YY_CHAR yy_c ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp ;
  int tmp___0 ;

  {
#line 556
  if (yy_init) {
#line 558
    yy_init = 0;
#line 564
    if (! yy_start) {
#line 565
      yy_start = 1;
    }
#line 567
    if (! yyin) {
#line 568
      yyin = stdin;
    }
#line 570
    if (! yyout) {
#line 571
      yyout = stdout;
    }
#line 573
    if (! yy_current_buffer) {
      {
#line 574
      yy_current_buffer = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 577
    yy_load_buffer_state();
    }
  }
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 582
    yy_cp = yy_c_buf_p;
#line 585
    *yy_cp = yy_hold_char;
#line 590
    yy_bp = yy_cp;
#line 592
    yy_current_state = yy_start;
    yy_match: 
    {
#line 594
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 596
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 597
      if (yy_accept[yy_current_state]) {
#line 599
        yy_last_accepting_state = yy_current_state;
#line 600
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 602
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 602
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 602
          goto while_break___1;
        }
#line 604
        yy_current_state = (int )yy_def[yy_current_state];
#line 605
        if (yy_current_state >= 33) {
#line 606
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 608
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 609
      yy_cp ++;
#line 594
      if (! ((int const   )yy_base[yy_current_state] != 40)) {
#line 594
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 614
    yy_act = (int )yy_accept[yy_current_state];
#line 615
    if (yy_act == 0) {
#line 617
      yy_cp = yy_last_accepting_cpos;
#line 618
      yy_current_state = yy_last_accepting_state;
#line 619
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 622
    yytext = yy_bp;
#line 622
    yyleng = (int )(yy_cp - yy_bp);
#line 622
    yy_hold_char = *yy_cp;
#line 622
    *yy_cp = (char )'\000';
#line 622
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 630
    if (yy_act == 0) {
#line 630
      goto case_0;
    }
#line 637
    if (yy_act == 1) {
#line 637
      goto case_1;
    }
#line 7
    if (yy_act == 2) {
#line 7 "gram.l"
      goto case_2;
    }
#line 12
    if (yy_act == 3) {
#line 12
      goto case_3;
    }
#line 17
    if (yy_act == 4) {
#line 17
      goto case_4;
    }
#line 22
    if (yy_act == 5) {
#line 22
      goto case_5;
    }
#line 24
    if (yy_act == 6) {
#line 24
      goto case_6;
    }
#line 25
    if (yy_act == 7) {
#line 25
      goto case_7;
    }
#line 26
    if (yy_act == 8) {
#line 26
      goto case_8;
    }
#line 27
    if (yy_act == 9) {
#line 27
      goto case_9;
    }
#line 28
    if (yy_act == 10) {
#line 28
      goto case_10;
    }
#line 29
    if (yy_act == 11) {
#line 29
      goto case_11;
    }
#line 30
    if (yy_act == 12) {
#line 30
      goto case_12;
    }
#line 31
    if (yy_act == 13) {
#line 31
      goto case_13;
    }
#line 36
    if (yy_act == 14) {
#line 36
      goto case_14;
    }
#line 723
    if (yy_act == 16) {
#line 723 "lex.yy.c"
      goto case_16;
    }
#line 726
    if (yy_act == 15) {
#line 726
      goto case_15;
    }
#line 848
    goto switch_default;
    case_0: /* CIL Label */ 
#line 632
    *yy_cp = yy_hold_char;
#line 633
    yy_cp = yy_last_accepting_cpos;
#line 634
    yy_current_state = yy_last_accepting_state;
#line 635
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 3 "gram.l"
    yylval = yytext + 1;
#line 4
    return (264);
#line 6
    goto switch_break;
    case_2: /* CIL Label */ 
#line 8
    yylval = yytext;
#line 9
    return (265);
#line 11
    goto switch_break;
    case_3: /* CIL Label */ 
#line 13
    ModeBlock = 1;
#line 14
    return (259);
#line 16
    goto switch_break;
    case_4: /* CIL Label */ 
#line 18
    ModeBlock = 0;
#line 19
    return (260);
#line 21
    goto switch_break;
    case_5: /* CIL Label */ 
#line 22
    return (257);
#line 23
    goto switch_break;
    case_6: /* CIL Label */ 
#line 23
    return (258);
#line 24
    goto switch_break;
    case_7: /* CIL Label */ 
#line 24
    return (261);
#line 25
    goto switch_break;
    case_8: /* CIL Label */ 
#line 25
    return (262);
#line 26
    goto switch_break;
    case_9: /* CIL Label */ 
#line 26
    return (263);
#line 27
    goto switch_break;
    case_10: /* CIL Label */ 
#line 27
    return (267);
#line 28
    goto switch_break;
    case_11: /* CIL Label */ 
#line 28
    return (266);
#line 29
    goto switch_break;
    case_12: /* CIL Label */ ;
#line 30
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 32
    errMes((char *)"Lexical mistake \"%s\"", yytext);
#line 33
    exit(1);
    }
#line 35
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 35
    fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1, (FILE */* __restrict  */)yyout);
    }
#line 36
    goto switch_break;
    case_16: /* CIL Label */ 
#line 724 "lex.yy.c"
    return (0);
    case_15: /* CIL Label */ 
#line 729
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 732
    *yy_cp = yy_hold_char;
#line 735
    if (yy_current_buffer->yy_buffer_status == 0) {
#line 746
      yy_n_chars = yy_current_buffer->yy_n_chars;
#line 747
      yy_current_buffer->yy_input_file = yyin;
#line 748
      yy_current_buffer->yy_buffer_status = 1;
    }
#line 758
    if ((unsigned long )yy_c_buf_p <= (unsigned long )(yy_current_buffer->yy_ch_buf + yy_n_chars)) {
      {
#line 762
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 764
      yy_current_state = yy_get_previous_state();
#line 775
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 777
      yy_bp = yytext + 0;
      }
#line 779
      if (yy_next_state) {
#line 782
        yy_c_buf_p ++;
#line 782
        yy_cp = yy_c_buf_p;
#line 783
        yy_current_state = yy_next_state;
#line 784
        goto yy_match;
      } else {
#line 789
        yy_cp = yy_c_buf_p;
#line 790
        goto yy_find_action;
      }
    } else {
      {
#line 794
      tmp = yy_get_next_buffer();
      }
      {
#line 796
      if (tmp == 1) {
#line 796
        goto case_1___0;
      }
#line 825
      if (tmp == 0) {
#line 825
        goto case_0___0;
      }
#line 835
      if (tmp == 2) {
#line 835
        goto case_2___0;
      }
#line 794
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 798
      yy_did_buffer_switch_on_eof = 0;
#line 800
      tmp___0 = yywrap();
      }
#line 800
      if (tmp___0) {
#line 811
        yy_c_buf_p = yytext + 0;
#line 813
        yy_act = (15 + (yy_start - 1) / 2) + 1;
#line 814
        goto do_action;
      } else
#line 819
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 820
        yyrestart(yyin);
        }
      }
#line 822
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 826
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 829
      yy_current_state = yy_get_previous_state();
#line 831
      yy_cp = yy_c_buf_p;
#line 832
      yy_bp = yytext + 0;
      }
#line 833
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 836
      yy_c_buf_p = yy_current_buffer->yy_ch_buf + yy_n_chars;
#line 839
      yy_current_state = yy_get_previous_state();
#line 841
      yy_cp = yy_c_buf_p;
#line 842
      yy_bp = yytext + 0;
      }
#line 843
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 845
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 849
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 864 "lex.yy.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int n___0 ;

  {
#line 866
  dest = yy_current_buffer->yy_ch_buf;
#line 867
  source = yytext;
#line 871
  if ((unsigned long )yy_c_buf_p > (unsigned long )(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 872
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 875
  if (yy_current_buffer->yy_fill_buffer == 0) {
#line 877
    if (yy_c_buf_p - yytext == 1L) {
#line 882
      return (1);
    } else {
#line 890
      return (2);
    }
  }
#line 897
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 899
  i = 0;
  {
#line 899
  while (1) {
    while_continue: /* CIL Label */ ;
#line 899
    if (! (i < number_to_move)) {
#line 899
      goto while_break;
    }
#line 900
    tmp = dest;
#line 900
    dest ++;
#line 900
    tmp___0 = source;
#line 900
    source ++;
#line 900
    *tmp = *tmp___0;
#line 899
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 902
  if (yy_current_buffer->yy_buffer_status == 2) {
#line 906
    yy_n_chars = 0;
#line 906
    yy_current_buffer->yy_n_chars = yy_n_chars;
  } else {
#line 910
    num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 913
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 913
      if (! (num_to_read <= 0)) {
#line 913
        goto while_break___0;
      }
#line 921
      b = yy_current_buffer;
#line 923
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 926
      if (b->yy_is_our_buffer) {
#line 928
        new_size = (int )(b->yy_buf_size * 2U);
#line 930
        if (new_size <= 0) {
#line 931
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 933
          b->yy_buf_size *= 2U;
        }
        {
#line 935
        tmp___1 = yy_flex_realloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U);
#line 935
        b->yy_ch_buf = (char *)tmp___1;
        }
      } else {
#line 942
        b->yy_ch_buf = (char *)0;
      }
#line 944
      if (! b->yy_ch_buf) {
        {
#line 945
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 948
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 950
      num_to_read = (int )((yy_current_buffer->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 955
    if (num_to_read > 8192) {
#line 956
      num_to_read = 8192;
    }
#line 959
    if (yy_current_buffer->yy_is_interactive) {
#line 959
      c = '*';
#line 959
      n = 0;
      {
#line 959
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 959
        if (n < num_to_read) {
          {
#line 959
          c = _IO_getc(yyin);
          }
#line 959
          if (c != -1) {
#line 959
            if (! (c != 10)) {
#line 959
              goto while_break___1;
            }
          } else {
#line 959
            goto while_break___1;
          }
        } else {
#line 959
          goto while_break___1;
        }
#line 959
        *((yy_current_buffer->yy_ch_buf + number_to_move) + n) = (char )c;
#line 959
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 959
      if (c == 10) {
#line 959
        if (n >= 1) {
#line 959
          if ((int )*((yy_current_buffer->yy_ch_buf + number_to_move) + (n - 1)) == 13) {
#line 959
            *((yy_current_buffer->yy_ch_buf + number_to_move) + (n - 1)) = (char )c;
          } else {
#line 959
            tmp___2 = n;
#line 959
            n ++;
#line 959
            *((yy_current_buffer->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
          }
        } else {
#line 959
          tmp___2 = n;
#line 959
          n ++;
#line 959
          *((yy_current_buffer->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
        }
      }
#line 959
      if (c == -1) {
        {
#line 959
        tmp___3 = ferror(yyin);
        }
#line 959
        if (tmp___3) {
          {
#line 959
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 959
      yy_n_chars = n;
    } else {
      {
#line 959
      tmp___4 = __errno_location();
#line 959
      *tmp___4 = 0;
      }
      {
#line 959
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 959
        tmp___7 = fread((void */* __restrict  */)(yy_current_buffer->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 959
        yy_n_chars = (int )tmp___7;
        }
#line 959
        if (yy_n_chars == 0) {
          {
#line 959
          tmp___8 = ferror(yyin);
          }
#line 959
          if (! tmp___8) {
#line 959
            goto while_break___2;
          }
        } else {
#line 959
          goto while_break___2;
        }
        {
#line 959
        tmp___5 = __errno_location();
        }
#line 959
        if (*tmp___5 != 4) {
          {
#line 959
          yy_fatal_error("input in flex scanner failed");
          }
#line 959
          goto while_break___2;
        }
        {
#line 959
        tmp___6 = __errno_location();
#line 959
        *tmp___6 = 0;
#line 959
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 959
      n___0 = 0;
      {
#line 959
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 959
        if (! (n___0 < yy_n_chars)) {
#line 959
          goto while_break___3;
        }
#line 959
        if ((int )*((yy_current_buffer->yy_ch_buf + number_to_move) + n___0) == 10) {
#line 959
          if (n___0 >= 1) {
#line 959
            if ((int )*((yy_current_buffer->yy_ch_buf + number_to_move) + (n___0 - 1)) == 13) {
#line 959
              *((yy_current_buffer->yy_ch_buf + number_to_move) + (n___0 - 1)) = (char )'\n';
            }
          }
        }
#line 959
        n___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 962
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
#line 965
  if (yy_n_chars == 0) {
#line 967
    if (number_to_move == 0) {
      {
#line 969
      ret_val = 1;
#line 970
      yyrestart(yyin);
      }
    } else {
#line 975
      ret_val = 2;
#line 976
      yy_current_buffer->yy_buffer_status = 2;
    }
  } else {
#line 982
    ret_val = 0;
  }
#line 984
  yy_n_chars += number_to_move;
#line 985
  *(yy_current_buffer->yy_ch_buf + yy_n_chars) = (char)0;
#line 986
  *(yy_current_buffer->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 988
  yytext = yy_current_buffer->yy_ch_buf + 0;
#line 990
  return (ret_val);
}
}
#line 996 "lex.yy.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1001
  yy_current_state = yy_start;
#line 1003
  yy_cp = yytext + 0;
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1003
      goto while_break;
    }
#line 1005
    if (*yy_cp) {
#line 1005
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1005
      tmp = (int const   )1;
    }
#line 1005
    yy_c = (YY_CHAR )tmp;
#line 1006
    if (yy_accept[yy_current_state]) {
#line 1008
      yy_last_accepting_state = yy_current_state;
#line 1009
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1011
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1011
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1011
        goto while_break___0;
      }
#line 1013
      yy_current_state = (int )yy_def[yy_current_state];
#line 1014
      if (yy_current_state >= 33) {
#line 1015
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1017
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1003
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1020
  return (yy_current_state);
}
}
#line 1031 "lex.yy.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1038
  yy_cp = yy_c_buf_p;
#line 1040
  yy_c = (YY_CHAR )1;
#line 1041
  if (yy_accept[yy_current_state]) {
#line 1043
    yy_last_accepting_state = yy_current_state;
#line 1044
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1046
      goto while_break;
    }
#line 1048
    yy_current_state = (int )yy_def[yy_current_state];
#line 1049
    if (yy_current_state >= 33) {
#line 1050
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1052
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1053
  yy_is_jam = yy_current_state == 32;
#line 1055
  if (yy_is_jam) {
#line 1055
    tmp = 0;
  } else {
#line 1055
    tmp = yy_current_state;
  }
#line 1055
  return (tmp);
}
}
#line 1178 "lex.yy.c"
void yyrestart(FILE *input_file ) 
{ 


  {
#line 1184
  if (! yy_current_buffer) {
    {
#line 1185
    yy_current_buffer = yy_create_buffer(yyin, 16384);
    }
  }
  {
#line 1187
  yy_init_buffer(yy_current_buffer, input_file);
#line 1188
  yy_load_buffer_state();
  }
#line 1189
  return;
}
}
#line 1193 "lex.yy.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 


  {
#line 1199
  if ((unsigned long )yy_current_buffer == (unsigned long )new_buffer) {
#line 1200
    return;
  }
#line 1202
  if (yy_current_buffer) {
#line 1205
    *yy_c_buf_p = yy_hold_char;
#line 1206
    yy_current_buffer->yy_buf_pos = yy_c_buf_p;
#line 1207
    yy_current_buffer->yy_n_chars = yy_n_chars;
  }
  {
#line 1210
  yy_current_buffer = new_buffer;
#line 1211
  yy_load_buffer_state();
#line 1218
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1219
  return;
}
}
#line 1223 "lex.yy.c"
void yy_load_buffer_state(void) 
{ 


  {
#line 1228
  yy_n_chars = yy_current_buffer->yy_n_chars;
#line 1229
  yy_c_buf_p = yy_current_buffer->yy_buf_pos;
#line 1229
  yytext = yy_c_buf_p;
#line 1230
  yyin = yy_current_buffer->yy_input_file;
#line 1231
  yy_hold_char = *yy_c_buf_p;
#line 1232
  return;
}
}
#line 1236 "lex.yy.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size___1 ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1245
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1245
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1246
  if (! b) {
    {
#line 1247
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1249
  b->yy_buf_size = (yy_size_t )size___1;
#line 1254
  tmp___0 = yy_flex_alloc(b->yy_buf_size + 2U);
#line 1254
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1255
  if (! b->yy_ch_buf) {
    {
#line 1256
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1258
  b->yy_is_our_buffer = 1;
#line 1260
  yy_init_buffer(b, file);
  }
#line 1262
  return (b);
}
}
#line 1267 "lex.yy.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1273
  if (! b) {
#line 1274
    return;
  }
#line 1276
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
#line 1277
    yy_current_buffer = (YY_BUFFER_STATE )0;
  }
#line 1279
  if (b->yy_is_our_buffer) {
    {
#line 1280
    yy_flex_free((void *)b->yy_ch_buf);
    }
  }
  {
#line 1282
  yy_flex_free((void *)b);
  }
#line 1283
  return;
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 1297 "lex.yy.c"
void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1306
  yy_flush_buffer(b);
#line 1308
  b->yy_input_file = file;
#line 1309
  b->yy_fill_buffer = 1;
  }
#line 1317
  if (file) {
    {
#line 1317
    tmp = fileno(file);
#line 1317
    tmp___0 = isatty(tmp);
#line 1317
    b->yy_is_interactive = tmp___0 > 0;
    }
  } else {
#line 1317
    b->yy_is_interactive = 0;
  }
#line 1320
  return;
}
}
#line 1324 "lex.yy.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 


  {
#line 1331
  if (! b) {
#line 1332
    return;
  }
#line 1334
  b->yy_n_chars = 0;
#line 1340
  *(b->yy_ch_buf + 0) = (char)0;
#line 1341
  *(b->yy_ch_buf + 1) = (char)0;
#line 1343
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1345
  b->yy_at_bol = 1;
#line 1346
  b->yy_buffer_status = 0;
#line 1348
  if ((unsigned long )b == (unsigned long )yy_current_buffer) {
    {
#line 1349
    yy_load_buffer_state();
    }
  }
#line 1350
  return;
}
}
#line 1355 "lex.yy.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size___1 ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1364
  if (size___1 < 2U) {
#line 1368
    return ((YY_BUFFER_STATE )0);
  } else
#line 1364
  if ((int )*(base + (size___1 - 2U)) != 0) {
#line 1368
    return ((YY_BUFFER_STATE )0);
  } else
#line 1364
  if ((int )*(base + (size___1 - 1U)) != 0) {
#line 1368
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1370
  tmp = yy_flex_alloc((yy_size_t )sizeof(struct yy_buffer_state ));
#line 1370
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1371
  if (! b) {
    {
#line 1372
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 1374
  b->yy_buf_size = size___1 - 2U;
#line 1375
  tmp___0 = base;
#line 1375
  b->yy_ch_buf = tmp___0;
#line 1375
  b->yy_buf_pos = tmp___0;
#line 1376
  b->yy_is_our_buffer = 0;
#line 1377
  b->yy_input_file = (FILE *)0;
#line 1378
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1379
  b->yy_is_interactive = 0;
#line 1380
  b->yy_at_bol = 1;
#line 1381
  b->yy_fill_buffer = 0;
#line 1382
  b->yy_buffer_status = 0;
#line 1384
  yy_switch_to_buffer(b);
  }
#line 1386
  return (b);
}
}
#line 1393 "lex.yy.c"
YY_BUFFER_STATE yy_scan_string(char const   *yy_str ) 
{ 
  int len ;
  YY_BUFFER_STATE tmp ;

  {
#line 1400
  len = 0;
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1400
    if (! *(yy_str + len)) {
#line 1400
      goto while_break;
    }
#line 1400
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1403
  tmp = yy_scan_bytes(yy_str, len);
  }
#line 1403
  return (tmp);
}
}
#line 1410 "lex.yy.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *bytes , int len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf___13 ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1423
  n = (yy_size_t )(len + 2);
#line 1424
  tmp = yy_flex_alloc(n);
#line 1424
  buf___13 = (char *)tmp;
  }
#line 1425
  if (! buf___13) {
    {
#line 1426
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 1428
  i = 0;
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1428
    if (! (i < len)) {
#line 1428
      goto while_break;
    }
#line 1429
    *(buf___13 + i) = (char )*(bytes + i);
#line 1428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1431
  tmp___0 = (char)0;
#line 1431
  *(buf___13 + (len + 1)) = tmp___0;
#line 1431
  *(buf___13 + len) = tmp___0;
#line 1433
  b = yy_scan_buffer(buf___13, n);
  }
#line 1434
  if (! b) {
    {
#line 1435
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 1440
  b->yy_is_our_buffer = 1;
#line 1442
  return (b);
}
}
#line 1504 "lex.yy.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 1510
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1511
  exit(2);
  }
}
}
#line 1568 "lex.yy.c"
static void *yy_flex_alloc(yy_size_t size___1 ) 
{ 
  void *tmp ;

  {
  {
#line 1574
  tmp = malloc((size_t )size___1);
  }
#line 1574
  return (tmp);
}
}
#line 1578 "lex.yy.c"
static void *yy_flex_realloc(void *ptr , yy_size_t size___1 ) 
{ 
  void *tmp ;

  {
  {
#line 1592
  tmp = realloc((void *)((char *)ptr), (size_t )size___1);
  }
#line 1592
  return (tmp);
}
}
#line 1596 "lex.yy.c"
static void yy_flex_free(void *ptr ) 
{ 


  {
  {
#line 1602
  free(ptr);
  }
#line 1603
  return;
}
}
#line 129 "gram.y"
void appendNonTerm(char *name , int modeAssign ) 
{ 
  BODY *body ;

  {
  {
#line 133
  body = setNonTerm();
#line 134
  entryNonTerm(name, body, modeAssign, StartFlag, ModeBlock, 0);
#line 135
  BodyNo = 0;
  }
#line 136
  return;
}
}
#line 138 "gram.y"
BODY *setNonTerm(void) 
{ 
  int i ;
  BODY *body ;
  BODY *top ;
  BODY *prev ;
  void *tmp ;

  {
#line 142
  top = (BODY *)((void *)0);
#line 142
  prev = (BODY *)((void *)0);
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < BodyNo)) {
#line 144
      goto while_break;
    }
    {
#line 145
    tmp = malloc(sizeof(BODY ));
#line 145
    body = (BODY *)tmp;
    }
#line 145
    if ((unsigned long )body == (unsigned long )((void *)0)) {
      {
#line 146
      errMes((char *)"Can\'t alloc nonterminal list buffer");
      }
    }
    {
#line 148
    strcpy((char */* __restrict  */)(body->name), (char const   */* __restrict  */)(BodyName[i]));
#line 149
    body->abort = (FLAG )0;
    }
#line 150
    if ((unsigned long )prev != (unsigned long )((void *)0)) {
#line 151
      prev->next = body;
    } else {
#line 153
      top = body;
    }
#line 155
    prev = body;
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  body->next = (struct _BODY *)((void *)0);
#line 158
  return (top);
}
}
#line 161 "gram.y"
CLASS *entryNonTerm(char *name , BODY *body , int modeAccpt , int start , int member ,
                    int tmp ) 
{ 
  CLASS *class ;
  void *tmp___0 ;

  {
  {
#line 165
  class = getClass(name);
  }
#line 166
  if ((unsigned long )class != (unsigned long )((void *)0)) {
#line 167
    if (member) {
      {
#line 168
      errMes((char *)"Accepted flag of class \"%s\" is re-assigned", HeadName);
#line 169
      ErrParse ++;
      }
    }
  } else {
    {
#line 172
    tmp___0 = malloc(sizeof(CLASS ));
#line 172
    class = (CLASS *)tmp___0;
    }
#line 172
    if ((unsigned long )class == (unsigned long )((void *)0)) {
      {
#line 173
      errMes((char *)"Can\'t alloc memory for Class Finite Automaton.");
      }
    }
    {
#line 175
    strcpy((char */* __restrict  */)(class->name), (char const   */* __restrict  */)name);
    }
#line 176
    if (modeAccpt) {
#line 177
      if (member) {
#line 178
        class->no = (short )CurClassNo;
      } else
#line 180
      if (! tmp) {
        {
#line 181
        outputHeader(name);
#line 182
        class->no = (short )CurClassNo;
        }
      }
    } else {
#line 186
      class->no = (short)-1;
    }
#line 188
    class->branch = 0;
#line 189
    class->usedFA = (FLAG )0;
#line 190
    class->used = (FLAG )1;
#line 191
    class->bodyList = (BODYLIST *)((void *)0);
#line 192
    class->tmp = (FLAG )tmp;
#line 193
    class->next = (struct _CLASS *)((void *)0);
#line 194
    if ((unsigned long )ClassListTail == (unsigned long )((void *)0)) {
#line 195
      ClassList = class;
    } else {
#line 197
      ClassListTail->next = class;
    }
#line 199
    ClassListTail = class;
  }
#line 201
  if ((unsigned long )body != (unsigned long )((void *)0)) {
    {
#line 201
    pushBody(class, body);
    }
  }
#line 202
  if (start) {
#line 203
    StartFlag = 0;
#line 204
    if ((unsigned long )StartSymbol == (unsigned long )((void *)0)) {
#line 205
      StartSymbol = class;
    } else {
      {
#line 207
      errMes((char *)"Start symbol is redifined as \"%s\"", class->name);
#line 208
      ErrParse ++;
      }
    }
  }
#line 211
  return (class);
}
}
#line 214 "gram.y"
void pushBody(CLASS *class , BODY *newbody ) 
{ 
  BODYLIST *bodyList ;
  BODYLIST *preBodyList ;
  BODYLIST *newBodyList ;
  BODY *body ;
  int cmp ;
  int defineNo ;
  int tmp ;
  void *tmp___0 ;

  {
#line 216
  bodyList = class->bodyList;
#line 217
  preBodyList = (BODYLIST *)((void *)0);
#line 221
  defineNo = 1;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )bodyList != (unsigned long )((void *)0))) {
#line 223
      goto while_break;
    }
    {
#line 224
    body = bodyList->body;
#line 225
    cmp = strcmp((char const   *)(body->name), (char const   *)(newbody->name));
    }
#line 226
    if (cmp > 0) {
#line 226
      goto while_break;
    }
#line 227
    if (cmp == 0) {
      {
#line 228
      tmp = unifyBody(class->name, body, newbody);
      }
#line 228
      if (tmp) {
        {
#line 229
        warnMes((char *)"Class \"%s\" is defined as \"%s..\" again.", class->name,
                body->name);
        }
      }
#line 231
      return;
    }
#line 233
    preBodyList = bodyList;
#line 234
    bodyList = bodyList->next;
#line 235
    defineNo ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  tmp___0 = malloc(sizeof(BODYLIST ));
#line 237
  newBodyList = (BODYLIST *)tmp___0;
  }
#line 237
  if ((unsigned long )newBodyList == (unsigned long )((void *)0)) {
    {
#line 238
    errMes((char *)"Can\'t alloc class body buffer.");
    }
  }
#line 240
  newBodyList->body = newbody;
#line 242
  if ((unsigned long )preBodyList != (unsigned long )((void *)0)) {
#line 243
    preBodyList->next = newBodyList;
  } else {
#line 245
    class->bodyList = newBodyList;
  }
#line 247
  newBodyList->next = bodyList;
#line 248
  (class->branch) ++;
#line 249
  return;
}
}
#line 251 "gram.y"
int unifyBody(char *className___0 , BODY *body , BODY *newbody ) 
{ 
  BODY *bodyNext ;
  BODY *newbodyNext ;
  char *newClassName ;
  BODY *newBody ;
  CLASS *class ;
  int tmp ;
  void *tmp___0 ;

  {
#line 258
  bodyNext = body->next;
#line 259
  newbodyNext = newbody->next;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if ((unsigned long )bodyNext == (unsigned long )((void *)0)) {
#line 261
      if ((unsigned long )newbodyNext == (unsigned long )((void *)0)) {
#line 262
        return (-1);
      }
    }
#line 264
    if ((unsigned long )newbodyNext == (unsigned long )((void *)0)) {
#line 265
      if (body->abort) {
#line 266
        return (-1);
      } else {
#line 268
        body->abort = (FLAG )1;
#line 269
        return (0);
      }
    }
#line 272
    if ((unsigned long )bodyNext == (unsigned long )((void *)0)) {
#line 273
      body->abort = (FLAG )1;
#line 274
      body->next = newbodyNext;
#line 275
      return (0);
    }
    {
#line 277
    tmp = strcmp((char const   *)(bodyNext->name), (char const   *)(newbodyNext->name));
    }
#line 277
    if (tmp) {
#line 277
      goto while_break;
    }
#line 278
    body = bodyNext;
#line 279
    newbody = newbodyNext;
#line 280
    bodyNext = body->next;
#line 281
    newbodyNext = newbody->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  class = getClass(body->name);
  }
#line 284
  if ((unsigned long )class != (unsigned long )((void *)0)) {
#line 284
    if (class->tmp) {
      {
#line 285
      entryNonTerm(body->name, newbodyNext, 0, 0, 0, 1);
      }
    } else {
#line 284
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 287
    newClassName = getNewClassName(className___0);
#line 288
    entryNonTerm(newClassName, bodyNext, 0, 0, 0, 1);
#line 289
    entryNonTerm(newClassName, newbodyNext, 0, 0, 0, 1);
#line 290
    tmp___0 = malloc(sizeof(BODY ));
#line 290
    newBody = (BODY *)tmp___0;
    }
#line 290
    if ((unsigned long )newBody == (unsigned long )((void *)0)) {
      {
#line 291
      errMes((char *)"Can\'t alloc body buffer of tmp class, \"%s\".", newClassName);
      }
    }
    {
#line 293
    strcpy((char */* __restrict  */)(newBody->name), (char const   */* __restrict  */)newClassName);
#line 294
    newBody->abort = (FLAG )0;
#line 295
    newBody->next = (struct _BODY *)((void *)0);
#line 296
    body->next = newBody;
#line 297
    newbody->next = newBody;
    }
  }
#line 299
  return (0);
}
}
#line 304 "gram.y"
static char classname[256]  ;
#line 305 "gram.y"
static int tmpClassNo  =    0;
#line 302 "gram.y"
char *getNewClassName(char *keyname ) 
{ 
  int tmp ;

  {
  {
#line 307
  tmp = tmpClassNo;
#line 307
  tmpClassNo ++;
#line 307
  sprintf((char */* __restrict  */)(classname), (char const   */* __restrict  */)"%s#%d",
          keyname, tmp);
  }
#line 308
  if (! SW_SemiQuiet) {
    {
#line 309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow modifying grammar to minimize states[%d]",
            GramModifyNum);
#line 310
    NoNewLine = 1;
    }
  }
#line 312
  GramModifyNum ++;
#line 313
  return (classname);
}
}
#line 316 "gram.y"
void setGram(void) 
{ 
  char *name ;

  {
  {
#line 320
  yyin = fopen((char const   */* __restrict  */)(GramFile), (char const   */* __restrict  */)"r");
  }
#line 320
  if ((unsigned long )yyin == (unsigned long )((void *)0)) {
    {
#line 321
    errMes((char *)"Can\'t open grammar file \"%s\"", GramFile);
    }
  }
#line 323
  if (SW_Compati) {
    {
#line 324
    strcpy((char */* __restrict  */)(HeaderFile), (char const   */* __restrict  */)"/dev/null");
    }
  }
  {
#line 326
  FPheader = fopen((char const   */* __restrict  */)(HeaderFile), (char const   */* __restrict  */)"w");
  }
#line 326
  if ((unsigned long )FPheader == (unsigned long )((void *)0)) {
    {
#line 327
    errMes((char *)"Can\'t open Header File for writting\"%s\"", HeaderFile);
    }
  }
  {
#line 329
  fprintf((FILE */* __restrict  */)FPheader, (char const   */* __restrict  */)"/* Header of class reduction flag for finite automaton parser\n                    made with mkfa %s\n\n        Do logicalAND between label and FA\'s field #4,#5.\n*/\n\n",
          VerNo);
  }
#line 335
  if (! SW_Quiet) {
    {
#line 335
    fputs((char const   */* __restrict  */)"Now parsing grammar file\n", (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 336
  yyparse();
  }
#line 337
  if (! SW_Quiet) {
    {
#line 338
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\rNow modifying grammar to minimize states[%d]\n",
            GramModifyNum - 1);
#line 339
    NoNewLine = 0;
    }
  }
#line 341
  if ((unsigned long )StartSymbol == (unsigned long )((void *)0)) {
#line 341
    StartSymbol = ClassList;
  }
  {
#line 342
  fprintf((FILE */* __restrict  */)FPheader, (char const   */* __restrict  */)"/* Start Symbol: %s */\n",
          StartSymbol->name);
#line 343
  fclose(FPheader);
#line 344
  name = chkNoInstantClass();
  }
#line 344
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    {
#line 345
    errMes((char *)"Prototype-declared Class \"%s\" has no instant definitions", name);
    }
  }
#line 347
  if (ErrParse) {
    {
#line 347
    errMes((char *)"%d fatal errors exist", ErrParse);
    }
  }
#line 348
  return;
}
}
#line 350 "gram.y"
void outputHeader(char *name ) 
{ 
  int tmp ;

  {
#line 352
  if ((unsigned long )ClassNo >= sizeof(CLASSFLAGS ) * 8UL) {
#line 353
    if (! SW_Compati) {
      {
#line 354
      warnMes((char *)"Class accepted flag overflow.\"%s\"", name);
#line 355
      CurClassNo = -1;
      }
    }
  } else {
#line 358
    if (! SW_Compati) {
      {
#line 359
      fprintf((FILE */* __restrict  */)FPheader, (char const   */* __restrict  */)"#define ACCEPT_%s 0x%08x\n",
              name, 1 << ClassNo);
      }
    }
#line 362
    tmp = ClassNo;
#line 362
    ClassNo ++;
#line 362
    CurClassNo = tmp;
  }
#line 364
  return;
}
}
#line 366 "gram.y"
char *chkNoInstantClass(void) 
{ 
  CLASS *class ;

  {
#line 368
  class = ClassList;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )class != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
#line 371
    if (! class->branch) {
#line 371
      return (class->name);
    }
#line 372
    class = class->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 374
  return ((char *)((void *)0));
}
}
#line 377 "gram.y"
int yyerror(char *mes ) 
{ 


  {
  {
#line 379
  errMes(mes);
#line 380
  ErrParse ++;
  }
#line 381
  return (0);
}
}
#line 66 "../../libsent/include/sent/util.h"
extern char *getl(char * , int  , FILE * ) ;
#line 71
extern FILE *fopen_readfile(char * ) ;
#line 72
extern int fclose_readfile(FILE * ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/common.h"
void init_term(char *filename___2 , char **termname___0 ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/rdterm.c"
static char buf___6[512]  ;
#line 14 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/rdterm.c"
void init_term(char *filename___2 , char **termname___0 ) 
{ 
  FILE *fd___2 ;
  int n ;
  char *p___0 ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 22
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading in term file (optional)...");
#line 24
  fd___2 = fopen_readfile(filename___2);
  }
#line 24
  if ((unsigned long )fd___2 == (unsigned long )((void *)0)) {
    {
#line 25
    *(termname___0 + 0) = (char *)((void *)0);
#line 26
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not found\n");
    }
#line 27
    return;
  }
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 30
    tmp = getl(buf___6, (int )sizeof(buf___6), fd___2);
    }
#line 30
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 30
      goto while_break;
    }
    {
#line 31
    p___0 = strtok((char */* __restrict  */)(buf___6), (char const   */* __restrict  */)" \t\n");
    }
#line 31
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      {
#line 32
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: term file failed to parse, corrupted or invalid data?\n");
      }
#line 33
      return;
    }
    {
#line 35
    n = atoi((char const   *)p___0);
#line 36
    p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
    }
#line 36
    if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
      {
#line 37
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: term file failed to parse, corrupted or invalid data?\n");
      }
#line 38
      return;
    }
    {
#line 40
    *(termname___0 + n) = strdup((char const   *)p___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 42
  tmp___0 = fclose_readfile(fd___2);
  }
#line 42
  if (tmp___0 == -1) {
    {
#line 43
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"close error\n");
#line 44
    exit(1);
    }
  }
  {
#line 47
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done\n");
  }
#line 48
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.h"
NEXTWORD **nw_malloc(void) ;
#line 32
void nw_free(NEXTWORD **nw ) ;
#line 33
int dfa_firstwords(NEXTWORD **nw ) ;
#line 34
int dfa_nextwords(NODE___0 *hypo , NEXTWORD **nw ) ;
#line 35
int dfa_firstterms(NEXTWORD **nw ) ;
#line 36
int dfa_nextterms(NODE___0 *hypo , NEXTWORD **nw ) ;
#line 37
boolean dfa_acceptable(NODE___0 *hypo ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
WORD_INFO *winfo ;
#line 14
DFA_INFO *dfa ;
#line 16 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
NEXTWORD **nw_malloc(void) 
{ 
  NEXTWORD **nw ;
  NEXTWORD *nwtmp ;
  int i ;
  int maxnw ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 24
  maxnw = (int )winfo->num * 2;
#line 26
  tmp = malloc((unsigned long )maxnw * sizeof(NEXTWORD *));
#line 26
  nw = (NEXTWORD **)tmp;
#line 27
  tmp___0 = malloc((unsigned long )maxnw * sizeof(NEXTWORD ));
#line 27
  nwtmp = (NEXTWORD *)tmp___0;
#line 28
  *(nw + 0) = nwtmp;
#line 29
  i = 1;
  }
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (i < maxnw)) {
#line 29
      goto while_break;
    }
#line 30
    *(nw + i) = nwtmp + i;
#line 29
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  return (nw);
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
void nw_free(NEXTWORD **nw ) 
{ 


  {
  {
#line 39
  free((void *)*(nw + 0));
#line 40
  free((void *)nw);
  }
#line 41
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
int dfa_firstwords(NEXTWORD **nw ) 
{ 
  DFA_ARC *arc ;
  int i ;
  int cate ;
  int iw ;
  int ns ;
  int num ;

  {
#line 53
  num = 0;
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < dfa->state_num)) {
#line 55
      goto while_break;
    }
#line 56
    if (((dfa->st + i)->status & 268435456U) != 0U) {
#line 57
      arc = (dfa->st + i)->arc;
      {
#line 57
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 57
        if (! arc) {
#line 57
          goto while_break___0;
        }
#line 58
        cate = (int )arc->label;
#line 59
        ns = arc->to_state;
#line 61
        iw = 0;
        {
#line 61
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 61
          if (! (iw < *(dfa->term.wnum + cate))) {
#line 61
            goto while_break___1;
          }
#line 62
          (*(nw + num))->id = *(*(dfa->term.tw + cate) + iw);
#line 63
          (*(nw + num))->next_state = ns;
#line 64
          (*(nw + num))->can_insert_sp = (boolean )0;
#line 65
          num ++;
#line 61
          iw ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 57
        arc = arc->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  return (num);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
int dfa_firstterms(NEXTWORD **nw ) 
{ 
  DFA_ARC *arc ;
  int i ;
  int cate ;
  int ns ;
  int num ;

  {
#line 78
  num = 0;
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < dfa->state_num)) {
#line 80
      goto while_break;
    }
#line 81
    if (((dfa->st + i)->status & 268435456U) != 0U) {
#line 82
      arc = (dfa->st + i)->arc;
      {
#line 82
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 82
        if (! arc) {
#line 82
          goto while_break___0;
        }
#line 83
        cate = (int )arc->label;
#line 84
        ns = arc->to_state;
#line 86
        if (*(dfa->term.wnum + cate) == 0) {
#line 86
          goto __Cont;
        }
#line 87
        (*(nw + num))->id = *(*(dfa->term.tw + cate) + 0);
#line 88
        (*(nw + num))->next_state = ns;
#line 89
        (*(nw + num))->can_insert_sp = (boolean )0;
#line 90
        num ++;
        __Cont: /* CIL Label */ 
#line 82
        arc = arc->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (num);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
int dfa_nextwords(NODE___0 *hypo , NEXTWORD **nw ) 
{ 
  DFA_ARC *arc ;
  DFA_ARC *arc2 ;
  int iw ;
  int cate ;
  int ns ;
  int cate2 ;
  int ns2 ;
  int num ;

  {
#line 106
  num = 0;
#line 108
  arc = (dfa->st + hypo->state)->arc;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! arc) {
#line 108
      goto while_break;
    }
#line 109
    cate = (int )arc->label;
#line 110
    ns = arc->to_state;
#line 111
    if (*(dfa->is_sp + cate)) {
#line 113
      arc2 = (dfa->st + ns)->arc;
      {
#line 113
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 113
        if (! arc2) {
#line 113
          goto while_break___0;
        }
#line 114
        cate2 = (int )arc2->label;
#line 115
        ns2 = arc2->to_state;
#line 116
        iw = 0;
        {
#line 116
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 116
          if (! (iw < *(dfa->term.wnum + cate2))) {
#line 116
            goto while_break___1;
          }
#line 117
          (*(nw + num))->id = *(*(dfa->term.tw + cate2) + iw);
#line 118
          (*(nw + num))->next_state = ns2;
#line 119
          (*(nw + num))->can_insert_sp = (boolean )1;
#line 120
          num ++;
#line 116
          iw ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 113
        arc2 = arc2->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 125
      iw = 0;
      {
#line 125
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 125
        if (! (iw < *(dfa->term.wnum + cate))) {
#line 125
          goto while_break___2;
        }
#line 126
        (*(nw + num))->id = *(*(dfa->term.tw + cate) + iw);
#line 127
        (*(nw + num))->next_state = ns;
#line 128
        (*(nw + num))->can_insert_sp = (boolean )0;
#line 129
        num ++;
#line 125
        iw ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 108
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  return (num);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
int dfa_nextterms(NODE___0 *hypo , NEXTWORD **nw ) 
{ 
  DFA_ARC *arc ;
  DFA_ARC *arc2 ;
  int cate ;
  int ns ;
  int cate2 ;
  int ns2 ;
  int num ;

  {
#line 140
  num = 0;
#line 142
  arc = (dfa->st + hypo->state)->arc;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! arc) {
#line 142
      goto while_break;
    }
#line 143
    cate = (int )arc->label;
#line 144
    ns = arc->to_state;
#line 145
    if (*(dfa->is_sp + cate)) {
#line 147
      arc2 = (dfa->st + ns)->arc;
      {
#line 147
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 147
        if (! arc2) {
#line 147
          goto while_break___0;
        }
#line 148
        cate2 = (int )arc2->label;
#line 149
        ns2 = arc2->to_state;
#line 150
        if (*(dfa->term.wnum + cate2) == 0) {
#line 150
          goto __Cont;
        }
#line 151
        (*(nw + num))->id = *(*(dfa->term.tw + cate2) + 0);
#line 152
        (*(nw + num))->next_state = ns2;
#line 153
        (*(nw + num))->can_insert_sp = (boolean )1;
#line 154
        num ++;
        __Cont: /* CIL Label */ 
#line 147
        arc2 = arc2->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 158
      if (*(dfa->term.wnum + cate) == 0) {
#line 158
        goto __Cont___0;
      }
#line 159
      (*(nw + num))->id = *(*(dfa->term.tw + cate) + 0);
#line 160
      (*(nw + num))->next_state = ns;
#line 161
      (*(nw + num))->can_insert_sp = (boolean )0;
#line 162
      num ++;
    }
    __Cont___0: /* CIL Label */ 
#line 142
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (num);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/gen_next.c"
boolean dfa_acceptable(NODE___0 *hypo ) 
{ 


  {
#line 174
  if ((dfa->st + hypo->state)->status & 1U) {
#line 175
    return ((boolean )1);
  } else {
#line 177
    return ((boolean )0);
  }
}
}
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 93 "../../libsent/include/sent/vocabulary.h"
extern boolean init_voca(WORD_INFO *winfo , char *filename , HTK_HMM_INFO *hmminfo ,
                         boolean  , boolean  ) ;
#line 109 "../../libsent/include/sent/dfa.h"
extern boolean init_dfa(DFA_INFO *dinfo , char *filename ) ;
#line 130
extern boolean make_dfa_voca_ref(DFA_INFO *dinfo , WORD_INFO *winfo ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
WORD_INFO *winfo  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
DFA_INFO *dfa  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
char **termname  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
boolean verbose_flag  =    (boolean )0;
#line 22 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
boolean term_mode  =    (boolean )0;
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
boolean no_term_file  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
NODE___0 *new_generate(void) 
{ 
  NEXTWORD **nw ;
  NODE___0 *now ;
  int i ;
  int j ;
  int num ;
  int selected ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  short tmp___10 ;
  boolean tmp___11 ;

  {
  {
#line 33
  nw = nw_malloc();
#line 34
  tmp = mymalloc(sizeof(NODE___0 ));
#line 34
  now = (NODE___0 *)tmp;
#line 35
  now->endflag = (boolean )0;
#line 36
  now->seqnum = (short)0;
  }
#line 39
  if (term_mode) {
    {
#line 40
    num = dfa_firstterms(nw);
    }
  } else {
    {
#line 42
    num = dfa_firstwords(nw);
    }
  }
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (verbose_flag) {
#line 47
      if (no_term_file) {
#line 48
        i = 0;
        {
#line 48
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 48
          if (! (i < num)) {
#line 48
            goto while_break___0;
          }
          {
#line 48
          printf((char const   */* __restrict  */)"\t-> %s\t%s\n", *(winfo->wname + (*(nw + i))->id),
                 *(winfo->woutput + (*(nw + i))->id));
#line 48
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 50
        i = 0;
        {
#line 50
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 50
          if (! (i < num)) {
#line 50
            goto while_break___1;
          }
          {
#line 50
          printf((char const   */* __restrict  */)"\t-> %s\t%s\n", *(termname + *(winfo->wton + (*(nw + i))->id)),
                 *(winfo->woutput + (*(nw + i))->id));
#line 50
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 54
    if (num == 1) {
#line 55
      selected = 0;
    } else {
      {
#line 57
      tmp___4 = rand();
      }
#line 57
      if (tmp___4 > 0) {
        {
#line 57
        tmp___1 = rand();
#line 57
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 57
        tmp___2 = rand();
#line 57
        tmp___3 = - tmp___2;
        }
      }
#line 57
      j = tmp___3 % num;
#line 58
      i = 0;
      {
#line 58
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 58
        if (! (i < j)) {
#line 58
          goto while_break___2;
        }
        {
#line 59
        tmp___9 = rand();
        }
#line 59
        if (tmp___9 > 0) {
          {
#line 59
          tmp___6 = rand();
#line 59
          tmp___8 = tmp___6;
          }
        } else {
          {
#line 59
          tmp___7 = rand();
#line 59
          tmp___8 = - tmp___7;
          }
        }
#line 59
        selected = tmp___8 % num;
#line 58
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 62
    if (selected >= num) {
#line 62
      selected = num - 1;
    }
#line 64
    tmp___10 = now->seqnum;
#line 64
    now->seqnum = (short )((int )now->seqnum + 1);
#line 64
    now->seq[tmp___10] = (*(nw + selected))->id;
#line 65
    now->state = (*(nw + selected))->next_state;
#line 67
    if ((int )now->seqnum >= 150) {
      {
#line 68
      printf((char const   */* __restrict  */)"word num exceeded %d\n", 150);
#line 69
      nw_free(nw);
      }
#line 70
      return (now);
    }
#line 74
    if (verbose_flag) {
      {
#line 75
      printf((char const   */* __restrict  */)"(%3d) %s\n", now->state, *(winfo->woutput + now->seq[(int )now->seqnum - 1]));
      }
    }
    {
#line 79
    tmp___11 = dfa_acceptable(now);
    }
#line 79
    if (tmp___11) {
#line 79
      goto while_break;
    }
#line 82
    if (term_mode) {
      {
#line 83
      num = dfa_nextterms(now, nw);
      }
    } else {
      {
#line 85
      num = dfa_nextwords(now, nw);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  nw_free(nw);
  }
#line 90
  return (now);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
static boolean match_node(NODE___0 *a , NODE___0 *b ) 
{ 
  int i ;

  {
#line 99
  if ((int )a->seqnum != (int )b->seqnum) {
#line 99
    return ((boolean )0);
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! (i < (int )a->seqnum)) {
#line 100
      goto while_break;
    }
#line 101
    if ((int )a->seq[i] != (int )b->seq[i]) {
#line 101
      return ((boolean )0);
    }
#line 100
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((boolean )1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
static void generate_main(int num ) 
{ 
  NODE___0 *sent ;
  NODE___0 **stock ;
  int i ;
  int n ;
  int c ;
  void *tmp ;
  boolean tmp___0 ;
  int tmp___1 ;

  {
  {
#line 114
  tmp = mymalloc(sizeof(NODE___0 *) * (unsigned long )num);
#line 114
  stock = (NODE___0 **)tmp;
#line 115
  n = 0;
#line 116
  c = 0;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (n < num)) {
#line 117
      goto while_break;
    }
    {
#line 118
    sent = new_generate();
#line 119
    i = 0;
    }
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! (i < n)) {
#line 119
        goto while_break___0;
      }
      {
#line 120
      tmp___0 = match_node(sent, *(stock + i));
      }
#line 120
      if (tmp___0) {
#line 120
        goto while_break___0;
      }
#line 119
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 122
    if (i >= n) {
#line 123
      tmp___1 = n;
#line 123
      n ++;
#line 123
      *(stock + tmp___1) = sent;
#line 124
      i = (int )sent->seqnum - 1;
      {
#line 124
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 124
        if (! (i >= 0)) {
#line 124
          goto while_break___1;
        }
#line 125
        if (term_mode) {
#line 126
          if (no_term_file) {
            {
#line 127
            printf((char const   */* __restrict  */)" %s", *(winfo->wname + sent->seq[i]));
            }
          } else {
            {
#line 129
            printf((char const   */* __restrict  */)" %s", *(termname + *(winfo->wton + sent->seq[i])));
            }
          }
        } else {
          {
#line 132
          printf((char const   */* __restrict  */)" %s", *(winfo->woutput + sent->seq[i]));
          }
        }
#line 124
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 135
      printf((char const   */* __restrict  */)"\n");
#line 136
      c = 0;
      }
    } else {
#line 138
      c ++;
#line 139
      if (c >= 300) {
        {
#line 140
        printf((char const   */* __restrict  */)"no further sentence in the last %d trial\n",
               c);
        }
#line 141
        goto while_break;
      }
      {
#line 143
      free((void *)sent);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 147
    if (! (i < n)) {
#line 147
      goto while_break___2;
    }
    {
#line 147
    free((void *)*(stock + i));
#line 147
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 148
  free((void *)stock);
  }
#line 149
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
static char *usage___2(char *s ) 
{ 


  {
  {
#line 155
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"generate --- sentence random generator\n");
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-v] [-n] prefix\n",
          s);
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n num  ... generate N sentences (default: 10)\n");
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t      ... use category symbols instead of words (needs .term)\n");
#line 159
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s string ... specify short-pause model\n");
#line 160
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v      ... verbose output\n");
#line 161
  exit(1);
  }
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/generate/generate.c"
static void put_dfainfo(void) 
{ 


  {
  {
#line 167
  printf((char const   */* __restrict  */)"%d categories, %d words\n", dfa->term_num,
         (int )winfo->num);
#line 168
  printf((char const   */* __restrict  */)"DFA has %d nodes and %d arcs\n", dfa->state_num,
         dfa->arc_num);
  }
#line 169
  return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 102 "../../libsent/include/sent/dfa.h"
extern void dfa_state_init(DFA_INFO *dinfo ) ;
#line 106
extern boolean rddfa_line(char *line , DFA_INFO *dinfo , int *state_max , int *arc_num ,
                          int *terminal_max ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
static DFA_INFO *dfa___0  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
static char buf___7[1024]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
static char *mygetl(char *buf___13 , int maxlen , FILE *fp___2 ) 
{ 
  int newline ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___0 = fgets((char */* __restrict  */)buf___13, maxlen, (FILE */* __restrict  */)fp___2);
    }
#line 42
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 42
      goto while_break;
    }
    {
#line 43
    tmp = strlen((char const   *)buf___13);
#line 43
    newline = (int )(tmp - 1UL);
    }
#line 44
    if ((int )*(buf___13 + newline) == 10) {
#line 45
      *(buf___13 + newline) = (char )'\000';
#line 46
      newline --;
    }
#line 48
    if (newline >= 0) {
#line 48
      if ((int )*(buf___13 + newline) == 13) {
#line 48
        *(buf___13 + newline) = (char )'\000';
      }
    }
#line 49
    if ((int )*(buf___13 + 0) == 0) {
#line 49
      goto while_continue;
    }
#line 50
    return (buf___13);
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return ((char *)((void *)0));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
static boolean myrddfa(FILE *fp___2 , DFA_INFO *dinfo ) 
{ 
  int state_max ;
  int arc_num ;
  int terminal_max ;
  boolean tmp ;
  char *tmp___0 ;

  {
  {
#line 68
  dfa_state_init(dinfo);
#line 69
  state_max = 0;
#line 70
  arc_num = 0;
#line 71
  terminal_max = 0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    tmp___0 = mygetl(buf___7, 1024, fp___2);
    }
#line 72
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 72
      goto while_break;
    }
    {
#line 73
    tmp = rddfa_line(buf___7, dinfo, & state_max, & arc_num, & terminal_max);
    }
#line 73
    if ((int )tmp == 0) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  dinfo->state_num = state_max + 1;
#line 78
  dinfo->arc_num = arc_num;
#line 79
  dinfo->term_num = terminal_max + 1;
#line 80
  return ((boolean )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
static void usage___3(void) 
{ 


  {
  {
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: dfa_minimize [dfafile] [-o outfile]\n");
  }
#line 91
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_minimize/dfa_minimize.c"
void minimize(DFA_INFO *dfa___2 , FILE *fpout ) 
{ 
  int *group ;
  int gnum ;
  int *gmark ;
  int **l ;
  int **pt ;
  int i ;
  int n ;
  int s ;
  int g ;
  DFA_ARC *ac ;
  boolean modified ;
  int starting ;
  int *glist ;
  int groupnum ;
  int arcnum ;
  int *is_start ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int *is_accept ;
  void *tmp___7 ;

  {
  {
#line 120
  tmp = malloc(sizeof(int ) * (unsigned long )dfa___2->state_num);
#line 120
  group = (int *)tmp;
#line 121
  tmp___0 = malloc(sizeof(int ) * (unsigned long )dfa___2->state_num);
#line 121
  gmark = (int *)tmp___0;
#line 122
  tmp___1 = malloc(sizeof(int *) * (unsigned long )dfa___2->state_num);
#line 122
  l = (int **)tmp___1;
#line 123
  i = 0;
  }
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < dfa___2->state_num)) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___2 = malloc(sizeof(int ) * (unsigned long )dfa___2->term_num);
#line 124
    *(l + i) = (int *)tmp___2;
#line 123
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp___3 = malloc(sizeof(int *) * (unsigned long )dfa___2->state_num);
#line 126
  pt = (int **)tmp___3;
#line 130
  i = 0;
  }
  {
#line 130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 130
    if (! (i < dfa___2->state_num)) {
#line 130
      goto while_break___0;
    }
#line 131
    if (((dfa___2->st + i)->status & 1U) != 0U) {
#line 132
      *(group + i) = 0;
    } else {
#line 134
      *(group + i) = 1;
    }
#line 130
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 137
  gnum = 2;
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 141
    modified = (boolean )0;
#line 147
    s = 0;
    {
#line 147
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 147
      if (! (s < dfa___2->state_num)) {
#line 147
        goto while_break___2;
      }
#line 148
      i = 0;
      {
#line 148
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 148
        if (! (i < dfa___2->term_num)) {
#line 148
          goto while_break___3;
        }
#line 148
        *(*(l + s) + i) = -1;
#line 148
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 149
      ac = (dfa___2->st + s)->arc;
      {
#line 149
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 149
        if (! ac) {
#line 149
          goto while_break___4;
        }
#line 150
        *(*(l + s) + ac->label) = *(group + ac->to_state);
#line 149
        ac = ac->next;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 147
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 169
    g = 0;
    {
#line 169
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 169
      if (! (g < gnum)) {
#line 169
        goto while_break___5;
      }
#line 170
      n = 0;
#line 171
      s = 0;
      {
#line 171
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 171
        if (! (s < dfa___2->state_num)) {
#line 171
          goto while_break___6;
        }
#line 172
        if (*(group + s) != g) {
#line 172
          goto __Cont;
        }
#line 174
        i = 0;
        {
#line 174
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 174
          if (! (i < n)) {
#line 174
            goto while_break___7;
          }
          {
#line 175
          tmp___4 = memcmp((void const   *)*(l + s), (void const   *)*(pt + i), sizeof(int ) * (unsigned long )dfa___2->term_num);
          }
#line 175
          if (tmp___4 == 0) {
#line 175
            goto while_break___7;
          }
#line 174
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 177
        if (i < n) {
#line 180
          *(gmark + s) = i;
        } else {
#line 185
          *(pt + n) = *(l + s);
#line 186
          *(gmark + s) = n;
#line 187
          n ++;
        }
        __Cont: /* CIL Label */ 
#line 171
        s ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 191
      if (n > 1) {
#line 195
        s = 0;
        {
#line 195
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 195
          if (! (s < dfa___2->state_num)) {
#line 195
            goto while_break___8;
          }
#line 196
          if (*(group + s) != g) {
#line 196
            goto __Cont___0;
          }
#line 197
          *(group + s) = gnum + *(gmark + s);
          __Cont___0: /* CIL Label */ 
#line 195
          s ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 200
        gnum += n;
#line 201
        modified = (boolean )1;
      }
#line 169
      g ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 140
    if (! modified) {
#line 140
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  s = 0;
  {
#line 207
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 207
    if (! (s < dfa___2->state_num)) {
#line 207
      goto while_break___9;
    }
#line 208
    i = 0;
    {
#line 208
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 208
      if (! (i < dfa___2->term_num)) {
#line 208
        goto while_break___10;
      }
#line 208
      *(*(l + s) + i) = -1;
#line 208
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 209
    ac = (dfa___2->st + s)->arc;
    {
#line 209
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 209
      if (! ac) {
#line 209
        goto while_break___11;
      }
#line 210
      *(*(l + s) + ac->label) = *(group + ac->to_state);
#line 209
      ac = ac->next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 207
    s ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 216
  tmp___5 = malloc(sizeof(int ) * (unsigned long )gnum);
#line 216
  glist = (int *)tmp___5;
#line 217
  g = 0;
  }
  {
#line 217
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 217
    if (! (g < gnum)) {
#line 217
      goto while_break___12;
    }
#line 217
    *(glist + g) = -1;
#line 217
    g ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 218
  n = 0;
#line 219
  s = 0;
  {
#line 219
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 219
    if (! (s < dfa___2->state_num)) {
#line 219
      goto while_break___13;
    }
#line 220
    if (*(glist + *(group + s)) == -1) {
#line 221
      *(glist + *(group + s)) = n;
#line 222
      n ++;
    }
#line 219
    s ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 225
  groupnum = n;
#line 230
  tmp___6 = malloc(sizeof(int ) * (unsigned long )groupnum);
#line 230
  is_start = (int *)tmp___6;
#line 231
  g = 0;
  }
  {
#line 231
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 231
    if (! (g < groupnum)) {
#line 231
      goto while_break___14;
    }
#line 231
    *(is_start + g) = 0;
#line 231
    g ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 232
  s = 0;
  {
#line 232
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 232
    if (! (s < dfa___2->state_num)) {
#line 232
      goto while_break___15;
    }
#line 233
    if ((dfa___2->st + s)->status & 268435456U) {
#line 234
      *(is_start + *(glist + *(group + s))) = 1;
    }
#line 232
    s ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 237
  starting = -1;
#line 238
  g = 0;
  {
#line 238
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 238
    if (! (g < groupnum)) {
#line 238
      goto while_break___16;
    }
#line 239
    if (*(is_start + g) == 1) {
#line 240
      if (starting == -1) {
#line 241
        starting = g;
      } else {
        {
#line 243
        printf((char const   */* __restrict  */)"Error: more than one initial node??\n");
#line 244
        g = 0;
        }
        {
#line 244
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 244
          if (! (g < groupnum)) {
#line 244
            goto while_break___17;
          }
#line 245
          if (*(is_start + g) == 1) {
            {
#line 245
            printf((char const   */* __restrict  */)" %d", g);
            }
          }
#line 244
          g ++;
        }
        while_break___17: /* CIL Label */ ;
        }
        {
#line 247
        printf((char const   */* __restrict  */)"\n");
#line 248
        printf((char const   */* __restrict  */)"Warning: resulting DFA may not be used in Julian by multiple initial nodes!!\n");
#line 249
        starting = 0;
        }
#line 250
        goto while_break___16;
      }
    }
#line 238
    g ++;
  }
  while_break___16: /* CIL Label */ ;
  }
  {
#line 257
  free((void *)is_start);
#line 258
  g = 0;
  }
  {
#line 258
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 258
    if (! (g < gnum)) {
#line 258
      goto while_break___18;
    }
#line 259
    if (*(glist + g) == 0) {
#line 260
      *(glist + g) = starting;
    } else
#line 261
    if (*(glist + g) == starting) {
#line 262
      *(glist + g) = 0;
    }
#line 258
    g ++;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 277
  tmp___7 = malloc(sizeof(int ) * (unsigned long )groupnum);
#line 277
  is_accept = (int *)tmp___7;
#line 278
  g = 0;
  }
  {
#line 278
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 278
    if (! (g < groupnum)) {
#line 278
      goto while_break___19;
    }
#line 278
    *(is_accept + g) = 0;
#line 278
    g ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 279
  s = 0;
  {
#line 279
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 279
    if (! (s < dfa___2->state_num)) {
#line 279
      goto while_break___20;
    }
#line 280
    if ((dfa___2->st + s)->status & 1U) {
#line 281
      *(is_accept + *(glist + *(group + s))) = 1;
    }
#line 279
    s ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 285
  arcnum = 0;
#line 286
  g = 0;
  {
#line 286
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 286
    if (! (g < groupnum)) {
#line 286
      goto while_break___21;
    }
#line 287
    s = 0;
    {
#line 287
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 287
      if (! (s < dfa___2->state_num)) {
#line 287
        goto while_break___22;
      }
#line 288
      if (*(glist + *(group + s)) != g) {
#line 288
        goto __Cont___1;
      }
#line 289
      i = 0;
      {
#line 289
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 289
        if (! (i < dfa___2->term_num)) {
#line 289
          goto while_break___23;
        }
#line 290
        if (*(*(l + s) + i) == -1) {
#line 290
          goto __Cont___2;
        }
#line 291
        if (*(is_accept + g) == 1) {
          {
#line 292
          fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d %d %d 1 0\n",
                  g, i, *(glist + *(*(l + s) + i)));
#line 293
          *(is_accept + g) = 0;
          }
        } else {
          {
#line 295
          fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d %d %d 0 0\n",
                  g, i, *(glist + *(*(l + s) + i)));
          }
        }
#line 297
        arcnum ++;
        __Cont___2: /* CIL Label */ 
#line 289
        i ++;
      }
      while_break___23: /* CIL Label */ ;
      }
#line 299
      goto while_break___22;
      __Cont___1: /* CIL Label */ 
#line 287
      s ++;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 301
    if (*(is_accept + g) == 1) {
      {
#line 302
      fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d -1 -1 1 0\n",
              g);
      }
    }
#line 286
    g ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 306
  free((void *)is_accept);
#line 309
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> minimized: %d nodes, %d arcs\n",
          groupnum, arcnum);
#line 312
  free((void *)glist);
#line 313
  free((void *)pt);
#line 314
  i = 0;
  }
  {
#line 314
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 314
    if (! (i < dfa___2->state_num)) {
#line 314
      goto while_break___24;
    }
    {
#line 314
    free((void *)*(l + i));
#line 314
    i ++;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 315
  free((void *)l);
#line 316
  free((void *)gmark);
#line 317
  free((void *)group);
  }
#line 318
  return;
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
char *rl_gets(char *prompt ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/readline.c"
static char *line_read  =    (char *)((void *)0);
#line 94 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/readline.c"
char *rl_gets(char *prompt ) 
{ 
  char *p___0 ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 99
  if (! line_read) {
    {
#line 100
    tmp = malloc((size_t )1024);
#line 100
    line_read = (char *)tmp;
    }
#line 100
    if ((unsigned long )line_read == (unsigned long )((void *)0)) {
      {
#line 101
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"memory exceeded\n");
#line 102
      exit(1);
      }
    }
  }
  {
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
          prompt);
#line 107
  tmp___0 = fgets((char */* __restrict  */)line_read, 1024, (FILE */* __restrict  */)stdin);
  }
#line 107
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 108
    return ((char *)((void *)0));
  }
  {
#line 111
  tmp___1 = strlen((char const   *)line_read);
#line 111
  p___0 = (line_read + tmp___1) - 1;
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if ((unsigned long )p___0 >= (unsigned long )line_read) {
#line 112
      if (! ((int )*p___0 == 10)) {
#line 112
        goto while_break;
      }
    } else {
#line 112
      goto while_break;
    }
#line 113
    *p___0 = (char )'\000';
#line 114
    p___0 --;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if ((int )*line_read == 0) {
#line 117
    return ((char *)((void *)0));
  }
#line 119
  return (line_read);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.h"
void put_wtoken(WTOKEN **wseq___1 , int nseq___1 ) ;
#line 19
boolean new_get_wtoken(char *buf___13 , WTOKEN **wseq___1 , int *nseq_ret ) ;
#line 20
void free_wtoken(WTOKEN **wseq___1 , int nseq___1 ) ;
#line 21
int next_terms(int stateid , int *termbuf , int *nextstatebuf ) ;
#line 22
int compaction_int(int *a , int num ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
boolean reverse_mode  =    (boolean )0;
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static WTOKEN *wseq[150]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static int nseq  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static STATECHAIN *reach_state  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static boolean can_accept  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static int nseq_reached  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void push_state(int stateid ) 
{ 
  STATECHAIN *new ;
  void *tmp ;

  {
  {
#line 45
  tmp = mymalloc(sizeof(STATECHAIN ));
#line 45
  new = (STATECHAIN *)tmp;
#line 46
  new->state = stateid;
#line 47
  new->next = reach_state;
#line 48
  reach_state = new;
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void free_reachstate(void) 
{ 
  STATECHAIN *st ;
  STATECHAIN *tmp ;

  {
#line 56
  st = reach_state;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! st) {
#line 57
      goto while_break;
    }
    {
#line 58
    tmp = st->next;
#line 59
    free((void *)st);
#line 60
    st = tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void put_state(int s , int l ) 
{ 
  int i ;

  {
#line 68
  i = 0;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i <= l)) {
#line 68
      goto while_break;
    }
    {
#line 68
    printf((char const   */* __restrict  */)"  ");
#line 68
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  printf((char const   */* __restrict  */)"[%d]\n", s);
  }
#line 70
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void can_accept_recursive(int stateid , int iseq ) 
{ 
  WTOKEN *token ;
  int *nterms ;
  int *nstate ;
  int cnum ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 83
  tmp = mymalloc((sizeof(int ) * (unsigned long )dfa->term_num) * 2UL);
#line 83
  nterms = (int *)tmp;
#line 84
  tmp___0 = mymalloc((sizeof(int ) * (unsigned long )dfa->term_num) * 2UL);
#line 84
  nstate = (int *)tmp___0;
  }
#line 86
  if (verbose_flag) {
    {
#line 86
    put_state(stateid, iseq);
    }
  }
#line 89
  if (nseq_reached > iseq) {
#line 89
    nseq_reached = iseq;
  }
#line 90
  if (iseq < 0) {
    {
#line 92
    push_state(stateid);
    }
#line 93
    if ((dfa->st + stateid)->status & 1U) {
#line 94
      can_accept = (boolean )1;
    }
    {
#line 96
    free((void *)nterms);
#line 96
    free((void *)nstate);
    }
#line 97
    return;
  }
#line 100
  token = wseq[iseq];
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 100
    if (! token) {
#line 100
      goto while_break;
    }
#line 101
    if (verbose_flag) {
#line 102
      i = 0;
      {
#line 102
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 102
        if (! (i <= iseq)) {
#line 102
          goto while_break___0;
        }
        {
#line 102
        printf((char const   */* __restrict  */)"  ");
#line 102
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 103
      if (no_term_file) {
        {
#line 104
        printf((char const   */* __restrict  */)"%s(%s)\n", *(winfo->woutput + token->wid),
               *(winfo->wname + token->wid));
        }
      } else {
        {
#line 106
        printf((char const   */* __restrict  */)"%s(%s:%s)\n", *(winfo->woutput + token->wid),
               *(termname + *(winfo->wton + token->wid)), *(winfo->wname + token->wid));
        }
      }
    }
    {
#line 109
    cnum = next_terms(stateid, nterms, nstate);
#line 110
    i = 0;
    }
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      if (! (i < cnum)) {
#line 110
        goto while_break___1;
      }
#line 111
      if (*(nterms + i) == (int )*(winfo->wton + token->wid)) {
        {
#line 112
        can_accept_recursive(*(nstate + i), iseq - 1);
        }
      }
#line 110
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 100
    token = token->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  free((void *)nterms);
#line 117
  free((void *)nstate);
  }
#line 118
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void put_nextword(void) 
{ 
  STATECHAIN *tmp ;
  int state ;
  int *nterms ;
  int *nstate ;
  int cnum ;
  int i ;
  int j ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 160
  tmp___0 = mymalloc((sizeof(int ) * (unsigned long )dfa->term_num) * 2UL);
#line 160
  nterms = (int *)tmp___0;
#line 161
  tmp___1 = mymalloc((sizeof(int ) * (unsigned long )dfa->term_num) * 2UL);
#line 161
  nstate = (int *)tmp___1;
#line 163
  tmp = reach_state;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! tmp) {
#line 163
      goto while_break;
    }
    {
#line 164
    state = tmp->state;
#line 165
    cnum = next_terms(state, nterms, nstate);
#line 166
    cnum = compaction_int(nterms, cnum);
#line 167
    i = 0;
    }
    {
#line 167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (i < cnum)) {
#line 167
        goto while_break___0;
      }
#line 168
      if (no_term_file) {
        {
#line 169
        printf((char const   */* __restrict  */)"\t%-16d (", *(nterms + i));
        }
      } else {
        {
#line 171
        printf((char const   */* __restrict  */)"\t%16s (", *(termname + *(nterms + i)));
        }
      }
#line 173
      if (*(dfa->term.wnum + *(nterms + i)) > 3) {
#line 174
        j = 0;
        {
#line 174
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 174
          if (! (j < 3)) {
#line 174
            goto while_break___1;
          }
          {
#line 175
          printf((char const   */* __restrict  */)"%s ", *(winfo->woutput + *(*(dfa->term.tw + *(nterms + i)) + j)));
#line 174
          j ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 177
        printf((char const   */* __restrict  */)"...)\n");
        }
      } else {
#line 179
        j = 0;
        {
#line 179
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 179
          if (! (j < *(dfa->term.wnum + *(nterms + i)))) {
#line 179
            goto while_break___2;
          }
          {
#line 180
          printf((char const   */* __restrict  */)"%s ", *(winfo->woutput + *(*(dfa->term.tw + *(nterms + i)) + j)));
#line 179
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 182
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 167
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  free((void *)nterms);
#line 186
  free((void *)nstate);
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void nextword_main(void) 
{ 
  int i ;
  char *buf___13 ;
  boolean tmp ;

  {
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (term_mode) {
      {
#line 196
      buf___13 = rl_gets((char *)"cate > ");
      }
    } else {
      {
#line 197
      buf___13 = rl_gets((char *)"wseq > ");
      }
    }
#line 195
    if (! ((unsigned long )buf___13 == (unsigned long )((void *)0))) {
      {
#line 195
      tmp = new_get_wtoken(buf___13, wseq, & nseq);
      }
#line 195
      if (! ((int )tmp == 0)) {
#line 195
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  put_wtoken(wseq, nseq);
#line 201
  reach_state = (STATECHAIN *)((void *)0);
#line 202
  nseq_reached = nseq;
#line 203
  can_accept = (boolean )0;
#line 204
  i = 0;
  }
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    if (! (i < dfa->state_num)) {
#line 204
      goto while_break___0;
    }
#line 205
    if (((dfa->st + i)->status & 268435456U) != 0U) {
      {
#line 206
      can_accept_recursive(i, nseq - 1);
      }
    }
#line 204
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 210
  if ((unsigned long )reach_state == (unsigned long )((void *)0)) {
    {
#line 211
    printf((char const   */* __restrict  */)"REJECTED at %d\n", nseq_reached + 1);
    }
  } else {
#line 213
    if (can_accept) {
      {
#line 213
      printf((char const   */* __restrict  */)"ACCEPTABLE\n");
      }
    }
    {
#line 214
    printf((char const   */* __restrict  */)"PREDICTED CATEGORIES/WORDS:\n");
#line 215
    put_nextword();
    }
  }
  {
#line 218
  free_wtoken(wseq, nseq);
#line 219
  free_reachstate();
  }
#line 220
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static char *usage___4(char *s ) 
{ 


  {
  {
#line 226
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"nextword --- tty-based interactive grammar checker\n");
#line 227
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s prefix\n",
          s);
#line 228
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t      ... use category symbols instead of words (needs .term)\n");
#line 229
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s string ... specify short-pause model\n");
#line 230
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -r      ... reverse order input\n");
#line 231
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v      ... verbose output\n");
#line 233
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(READLINE feature disabled)\n");
#line 235
  exit(1);
  }
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/nextword.c"
static void put_dfainfo___0(void) 
{ 


  {
  {
#line 241
  printf((char const   */* __restrict  */)"%d categories, %d words\n", dfa->term_num,
         (int )winfo->num);
#line 242
  printf((char const   */* __restrict  */)"DFA has %d nodes and %d arcs\n", dfa->state_num,
         dfa->arc_num);
  }
#line 243
  return;
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/rdterm.c"
static char buf___8[512]  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/wtoken.c"
void put_wtoken(WTOKEN **wseq___1 , int nseq___1 ) 
{ 
  int i ;
  WTOKEN *tok ;

  {
  {
#line 31
  printf((char const   */* __restrict  */)"[wseq:");
#line 32
  i = 0;
  }
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (i < nseq___1)) {
#line 32
      goto while_break;
    }
    {
#line 33
    printf((char const   */* __restrict  */)" %s", *(winfo->woutput + (*(wseq___1 + i))->wid));
#line 32
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 35
  printf((char const   */* __restrict  */)"]\n");
#line 36
  printf((char const   */* __restrict  */)"[cate:");
#line 37
  i = 0;
  }
  {
#line 37
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! (i < nseq___1)) {
#line 37
      goto while_break___0;
    }
#line 38
    if ((unsigned long )(*(wseq___1 + i))->next != (unsigned long )((void *)0)) {
      {
#line 39
      printf((char const   */* __restrict  */)" (");
      }
    } else {
      {
#line 41
      printf((char const   */* __restrict  */)" ");
      }
    }
#line 43
    if (no_term_file) {
      {
#line 44
      printf((char const   */* __restrict  */)"%s", *(winfo->wname + (*(wseq___1 + i))->wid));
      }
    } else {
      {
#line 46
      printf((char const   */* __restrict  */)"%s", *(termname + *(winfo->wton + (*(wseq___1 + i))->wid)));
      }
    }
#line 48
    if ((unsigned long )(*(wseq___1 + i))->next != (unsigned long )((void *)0)) {
#line 49
      tok = (*(wseq___1 + i))->next;
      {
#line 49
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 49
        if (! tok) {
#line 49
          goto while_break___1;
        }
#line 50
        if (no_term_file) {
          {
#line 51
          printf((char const   */* __restrict  */)"|%s", *(winfo->wname + tok->wid));
          }
        } else {
          {
#line 53
          printf((char const   */* __restrict  */)"|%s", *(termname + *(winfo->wton + tok->wid)));
          }
        }
#line 49
        tok = tok->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 56
      printf((char const   */* __restrict  */)")");
      }
    }
#line 37
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 59
  printf((char const   */* __restrict  */)"]\n");
  }
#line 60
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/wtoken.c"
boolean new_get_wtoken(char *buf___13 , WTOKEN **wseq___1 , int *nseq_ret ) 
{ 
  char *p___0 ;
  int i ;
  int it ;
  WTOKEN *new ;
  WTOKEN *prev ;
  int nseq___1 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 72
  nseq___1 = 0;
#line 73
  p___0 = strtok((char */* __restrict  */)buf___13, (char const   */* __restrict  */)" ");
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! p___0) {
#line 73
      goto while_break;
    }
#line 74
    it = 0;
#line 75
    prev = (WTOKEN *)((void *)0);
#line 76
    if (term_mode) {
#line 77
      if (no_term_file) {
        {
#line 78
        tmp___2 = atoi((char const   *)p___0);
        }
#line 78
        if (tmp___2 >= 0) {
          {
#line 78
          tmp___3 = atoi((char const   *)p___0);
          }
#line 78
          if (tmp___3 < dfa->term_num) {
            {
#line 79
            tmp = mymalloc(sizeof(WTOKEN ));
#line 79
            new = (WTOKEN *)tmp;
#line 80
            tmp___0 = atoi((char const   *)p___0);
            }
#line 80
            if (*(dfa->term.wnum + tmp___0) == 0) {
              {
#line 81
              printf((char const   */* __restrict  */)"word %d: category \"%s\" has no word\n",
                     nseq___1 + 1, p___0);
              }
#line 82
              return ((boolean )0);
            }
            {
#line 84
            tmp___1 = atoi((char const   *)p___0);
#line 84
            new->wid = *(*(dfa->term.tw + tmp___1) + 0);
#line 85
            new->next = prev;
#line 86
            prev = new;
#line 87
            it ++;
            }
          }
        }
      } else {
#line 90
        i = 0;
        {
#line 90
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 90
          if (! (i < dfa->term_num)) {
#line 90
            goto while_break___0;
          }
          {
#line 91
          tmp___5 = strcmp((char const   *)p___0, (char const   *)*(termname + i));
          }
#line 91
          if (! tmp___5) {
#line 92
            if (*(dfa->term.wnum + i) == 0) {
              {
#line 93
              printf((char const   */* __restrict  */)"word %d: category \"%s\" has no word\n",
                     nseq___1 + 1, p___0);
              }
#line 94
              return ((boolean )0);
            }
            {
#line 96
            tmp___4 = mymalloc(sizeof(WTOKEN ));
#line 96
            new = (WTOKEN *)tmp___4;
#line 97
            new->wid = *(*(dfa->term.tw + i) + 0);
#line 98
            new->next = prev;
#line 99
            prev = new;
#line 100
            it ++;
            }
          }
#line 90
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 104
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        {
#line 105
        printf((char const   */* __restrict  */)"word %d: category \"%s\" not exist\n",
               nseq___1 + 1, p___0);
        }
#line 106
        return ((boolean )0);
      }
    } else {
#line 109
      i = 0;
      {
#line 109
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 109
        if (! (i < (int )winfo->num)) {
#line 109
          goto while_break___1;
        }
        {
#line 110
        tmp___7 = strcmp((char const   *)p___0, (char const   *)*(winfo->woutput + i));
        }
#line 110
        if (! tmp___7) {
          {
#line 111
          tmp___6 = mymalloc(sizeof(WTOKEN ));
#line 111
          new = (WTOKEN *)tmp___6;
#line 112
          new->wid = (WORD_ID )i;
#line 113
          new->next = prev;
#line 114
          prev = new;
#line 115
          it ++;
          }
        }
#line 109
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 118
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        {
#line 119
        printf((char const   */* __restrict  */)"word %d: word \"%s\" not in voca\n",
               nseq___1 + 1, p___0);
        }
#line 120
        return ((boolean )0);
      }
    }
    {
#line 123
    tmp___8 = nseq___1;
#line 123
    nseq___1 ++;
#line 123
    *(wseq___1 + tmp___8) = new;
#line 73
    p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  if (reverse_mode) {
#line 127
    i = 0;
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 127
      if (! (i < nseq___1 / 2)) {
#line 127
        goto while_break___2;
      }
#line 128
      new = *(wseq___1 + i);
#line 129
      *(wseq___1 + i) = *(wseq___1 + ((nseq___1 - 1) - i));
#line 130
      *(wseq___1 + ((nseq___1 - 1) - i)) = new;
#line 127
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 134
  *nseq_ret = nseq___1;
#line 136
  return ((boolean )1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/wtoken.c"
void free_wtoken(WTOKEN **wseq___1 , int nseq___1 ) 
{ 
  int i ;
  WTOKEN *tok ;
  WTOKEN *tmp ;

  {
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < nseq___1)) {
#line 146
      goto while_break;
    }
#line 147
    tok = *(wseq___1 + i);
    {
#line 148
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 148
      if (! tok) {
#line 148
        goto while_break___0;
      }
      {
#line 149
      tmp = tok->next;
#line 150
      free((void *)tok);
#line 151
      tok = tmp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/get_next.c"
int next_terms(int stateid , int *termbuf , int *nextstatebuf ) 
{ 
  DFA_ARC *arc ;
  DFA_ARC *arc2 ;
  int cate ;
  int ns ;
  int cnum ;

  {
#line 31
  cnum = 0;
#line 32
  arc = (dfa->st + stateid)->arc;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! arc) {
#line 32
      goto while_break;
    }
#line 33
    cate = (int )arc->label;
#line 34
    ns = arc->to_state;
#line 35
    if (*(dfa->is_sp + cate)) {
#line 36
      arc2 = (dfa->st + ns)->arc;
      {
#line 36
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 36
        if (! arc2) {
#line 36
          goto while_break___0;
        }
#line 37
        *(termbuf + cnum) = (int )arc2->label;
#line 38
        *(nextstatebuf + cnum) = arc2->to_state;
#line 39
        cnum ++;
#line 36
        arc2 = arc2->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 42
      *(termbuf + cnum) = cate;
#line 43
      *(nextstatebuf + cnum) = ns;
#line 44
      cnum ++;
    }
#line 32
    arc = arc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return (cnum);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/nextword/get_next.c"
int compaction_int(int *a , int num ) 
{ 
  int i ;
  int j ;
  int d ;
  int tmp ;

  {
#line 56
  d = 0;
#line 57
  i = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < num)) {
#line 57
      goto while_break;
    }
#line 58
    j = 0;
    {
#line 58
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 58
      if (! (j < d)) {
#line 58
        goto while_break___0;
      }
#line 59
      if (*(a + i) == *(a + j)) {
#line 60
        goto while_break___0;
      }
#line 58
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    if (j == d) {
#line 64
      tmp = d;
#line 64
      d ++;
#line 64
      *(a + tmp) = *(a + i);
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (d);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static DFA_INFO *dfa___1  ;
#line 25 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static char buf___9[1024]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static char *mygetl___0(char *buf___13 , int maxlen , FILE *fp___2 ) 
{ 
  int newline ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 42
    tmp___0 = fgets((char */* __restrict  */)buf___13, maxlen, (FILE */* __restrict  */)fp___2);
    }
#line 42
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 42
      goto while_break;
    }
    {
#line 43
    tmp = strlen((char const   *)buf___13);
#line 43
    newline = (int )(tmp - 1UL);
    }
#line 44
    if ((int )*(buf___13 + newline) == 10) {
#line 45
      *(buf___13 + newline) = (char )'\000';
#line 46
      newline --;
    }
#line 48
    if (newline >= 0) {
#line 48
      if ((int )*(buf___13 + newline) == 13) {
#line 48
        *(buf___13 + newline) = (char )'\000';
      }
    }
#line 49
    if ((int )*(buf___13 + 0) == 0) {
#line 49
      goto while_continue;
    }
#line 50
    return (buf___13);
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return ((char *)((void *)0));
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static boolean myrddfa___0(FILE *fp___2 , DFA_INFO *dinfo ) 
{ 
  int state_max ;
  int arc_num ;
  int terminal_max ;
  boolean tmp ;
  char *tmp___0 ;

  {
  {
#line 68
  dfa_state_init(dinfo);
#line 69
  state_max = 0;
#line 70
  arc_num = 0;
#line 71
  terminal_max = 0;
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    tmp___0 = mygetl___0(buf___9, 1024, fp___2);
    }
#line 72
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 72
      goto while_break;
    }
    {
#line 73
    tmp = rddfa_line(buf___9, dinfo, & state_max, & arc_num, & terminal_max);
    }
#line 73
    if ((int )tmp == 0) {
#line 74
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  dinfo->state_num = state_max + 1;
#line 78
  dinfo->arc_num = arc_num;
#line 79
  dinfo->term_num = terminal_max + 1;
#line 80
  return ((boolean )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static void usage___5(void) 
{ 


  {
  {
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: dfa_determinize [dfafile] [-o outfile]\n");
  }
#line 91
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
void sput(STATEQ *sq ) 
{ 
  int i ;
  STATEQ_ARC *ac ;

  {
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < sq->len)) {
#line 130
      goto while_break;
    }
#line 131
    if ((int )*(sq->s + i) == 1) {
      {
#line 131
      printf((char const   */* __restrict  */)"-%d", i);
      }
    }
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 133
  printf((char const   */* __restrict  */)"\n");
#line 134
  printf((char const   */* __restrict  */)"checked: %d\n", sq->checked);
#line 135
  printf((char const   */* __restrict  */)"to:\n");
#line 136
  ac = (STATEQ_ARC *)sq->ac;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! ac) {
#line 136
      goto while_break___0;
    }
    {
#line 137
    printf((char const   */* __restrict  */)"\t(%d) ", ac->label);
#line 138
    i = 0;
    }
    {
#line 138
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 138
      if (! (i < (ac->to)->len)) {
#line 138
        goto while_break___1;
      }
#line 139
      if ((int )*((ac->to)->s + i) == 1) {
        {
#line 139
        printf((char const   */* __restrict  */)"-%d", i);
        }
      }
#line 138
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 141
    printf((char const   */* __restrict  */)"\n");
#line 136
    ac = ac->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
STATEQ *snew(int num ) 
{ 
  STATEQ *new ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 158
  tmp = malloc(sizeof(STATEQ ));
#line 158
  new = (STATEQ *)tmp;
#line 159
  tmp___0 = malloc(sizeof(char ) * (unsigned long )num);
#line 159
  new->s = (char *)tmp___0;
#line 160
  new->len = num;
#line 161
  new->ac = (void *)0;
#line 162
  new->next = (struct __stateq__ *)((void *)0);
#line 163
  i = 0;
  }
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < num)) {
#line 163
      goto while_break;
    }
#line 163
    *(new->s + i) = (char)0;
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  new->checked = 0;
#line 165
  new->start = 0;
#line 166
  new->end = 0;
#line 167
  return (new);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
void sfree(STATEQ *sq ) 
{ 
  STATEQ_ARC *sac ;
  STATEQ_ARC *atmp ;

  {
#line 178
  sac = (STATEQ_ARC *)sq->ac;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! sac) {
#line 179
      goto while_break;
    }
    {
#line 180
    atmp = sac->next;
#line 181
    free((void *)sac);
#line 182
    sac = atmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  free((void *)sq->s);
#line 185
  free((void *)sq);
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
static STATEQ *root  =    (STATEQ *)((void *)0);
#line 199 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/dfa_determinize/dfa_determinize.c"
boolean determinize(DFA_INFO *dfa___2 , FILE *fpout ) 
{ 
  STATEQ *src ;
  STATEQ *stmp ;
  STATEQ *stest ;
  STATEQ_ARC *sac ;
  int i ;
  int t ;
  int tnum ;
  DFA_ARC *ac ;
  int *tlist ;
  int modified ;
  int arcnum ;
  int nodenum ;
  STATEQ **slist ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 212
  tmp = malloc(sizeof(int ) * (unsigned long )dfa___2->state_num);
#line 212
  tlist = (int *)tmp;
#line 215
  src = (STATEQ *)((void *)0);
#line 216
  i = 0;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < dfa___2->state_num)) {
#line 216
      goto while_break;
    }
#line 217
    if ((dfa___2->st + i)->status & 268435456U) {
#line 218
      if ((unsigned long )src == (unsigned long )((void *)0)) {
        {
#line 219
        src = snew(dfa___2->state_num);
#line 220
        *(src->s + i) = (char)1;
#line 221
        src->start = 1;
#line 222
        root = src;
        }
      } else {
        {
#line 224
        printf((char const   */* __restrict  */)"Error: more than one initial node??\n");
        }
#line 225
        return ((boolean )0);
      }
    }
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    modified = 0;
#line 236
    src = root;
    {
#line 236
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 236
      if (! src) {
#line 236
        goto while_break___1;
      }
#line 237
      if (src->checked == 1) {
#line 237
        goto __Cont;
      }
#line 244
      t = 0;
      {
#line 244
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 244
        if (! (t < dfa___2->term_num)) {
#line 244
          goto while_break___2;
        }
#line 250
        tnum = 0;
#line 251
        i = 0;
        {
#line 251
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 251
          if (! (i < src->len)) {
#line 251
            goto while_break___3;
          }
#line 252
          if ((int )*(src->s + i) == 1) {
#line 253
            ac = (dfa___2->st + i)->arc;
            {
#line 253
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 253
              if (! ac) {
#line 253
                goto while_break___4;
              }
#line 254
              if ((int )ac->label == t) {
#line 255
                *(tlist + tnum) = ac->to_state;
#line 256
                tnum ++;
              }
#line 253
              ac = ac->next;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 251
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 263
        if (tnum == 0) {
#line 263
          goto __Cont___0;
        }
        {
#line 266
        stest = snew(dfa___2->state_num);
#line 267
        i = 0;
        }
        {
#line 267
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 267
          if (! (i < tnum)) {
#line 267
            goto while_break___5;
          }
#line 268
          *(stest->s + *(tlist + i)) = (char)1;
#line 267
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 280
        stmp = root;
        {
#line 280
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 280
          if (! stmp) {
#line 280
            goto while_break___6;
          }
          {
#line 281
          tmp___0 = memcmp((void const   *)stmp->s, (void const   *)stest->s, sizeof(char ) * (unsigned long )stest->len);
          }
#line 281
          if (tmp___0 == 0) {
#line 282
            goto while_break___6;
          }
#line 280
          stmp = stmp->next;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 285
        if ((unsigned long )stmp == (unsigned long )((void *)0)) {
#line 290
          stest->next = root;
#line 291
          root = stest;
#line 292
          stmp = stest;
        } else {
          {
#line 298
          sfree(stest);
          }
        }
        {
#line 302
        tmp___1 = malloc(sizeof(STATEQ_ARC ));
#line 302
        sac = (STATEQ_ARC *)tmp___1;
#line 303
        sac->label = t;
#line 304
        sac->to = stmp;
#line 305
        sac->next = (struct __arc__ *)src->ac;
#line 306
        src->ac = (void *)sac;
        }
        __Cont___0: /* CIL Label */ 
#line 244
        t ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 308
      src->checked = 1;
#line 309
      modified = 1;
      __Cont: /* CIL Label */ 
#line 236
      src = src->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 231
    if (! (modified == 1)) {
#line 231
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  nodenum = 1;
#line 321
  src = root;
  {
#line 321
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 321
    if (! src) {
#line 321
      goto while_break___7;
    }
#line 322
    if (src->start == 1) {
#line 323
      src->id = 0;
    } else {
#line 325
      tmp___2 = nodenum;
#line 325
      nodenum ++;
#line 325
      src->id = tmp___2;
    }
#line 327
    i = 0;
    {
#line 327
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 327
      if (! (i < src->len)) {
#line 327
        goto while_break___8;
      }
#line 328
      if ((int )*(src->s + i) == 1) {
#line 329
        if ((dfa___2->st + i)->status & 1U) {
#line 330
          src->end = 1;
        }
      }
#line 327
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 321
    src = src->next;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 337
  tmp___3 = malloc(sizeof(STATEQ *) * (unsigned long )nodenum);
#line 337
  slist = (STATEQ **)tmp___3;
#line 338
  src = root;
  }
  {
#line 338
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 338
    if (! src) {
#line 338
      goto while_break___9;
    }
#line 338
    *(slist + src->id) = src;
#line 338
    src = src->next;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 339
  arcnum = 0;
#line 341
  i = 0;
  {
#line 341
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 341
    if (! (i < nodenum)) {
#line 341
      goto while_break___10;
    }
#line 342
    src = *(slist + i);
#line 343
    t = 0;
#line 344
    if (src->end == 1) {
#line 344
      t = 1;
    }
#line 345
    sac = (STATEQ_ARC *)src->ac;
    {
#line 345
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 345
      if (! sac) {
#line 345
        goto while_break___11;
      }
#line 346
      if (t == 1) {
        {
#line 347
        fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d %d %d 1 0\n",
                src->id, sac->label, (sac->to)->id);
#line 348
        t = 0;
        }
      } else {
        {
#line 350
        fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d %d %d 0 0\n",
                src->id, sac->label, (sac->to)->id);
        }
      }
#line 352
      arcnum ++;
#line 345
      sac = sac->next;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 354
    if (t == 1) {
      {
#line 355
      fprintf((FILE */* __restrict  */)fpout, (char const   */* __restrict  */)"%d -1 -1 1 0\n",
              src->id);
      }
    }
#line 341
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 358
  free((void *)slist);
#line 361
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-> determinized: %d nodes, %d arcs\n",
          nodenum, arcnum);
#line 364
  src = root;
  }
  {
#line 365
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 365
    if (! src) {
#line 365
      goto while_break___12;
    }
    {
#line 366
    stmp = src->next;
#line 367
    sfree(src);
#line 368
    src = stmp;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 370
  free((void *)tlist);
  }
#line 372
  return ((boolean )1);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/rdterm.c"
static char buf___10[512]  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static char buf___11[4096]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static WTOKEN *wseq___0[150]  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static int nseq___0  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static int nseq_reached___0  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static void put_wtoken___0(void) 
{ 
  int i ;
  WTOKEN *tok ;

  {
  {
#line 43
  printf((char const   */* __restrict  */)"wseq:");
#line 44
  i = 0;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i < nseq___0)) {
#line 44
      goto while_break;
    }
    {
#line 45
    printf((char const   */* __restrict  */)" %s", *(winfo->woutput + (wseq___0[i])->wid));
#line 44
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  printf((char const   */* __restrict  */)"\n");
#line 48
  printf((char const   */* __restrict  */)"cate:");
#line 49
  i = 0;
  }
  {
#line 49
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 49
    if (! (i < nseq___0)) {
#line 49
      goto while_break___0;
    }
#line 50
    if ((unsigned long )(wseq___0[i])->next != (unsigned long )((void *)0)) {
      {
#line 51
      printf((char const   */* __restrict  */)" (");
      }
    } else {
      {
#line 53
      printf((char const   */* __restrict  */)" ");
      }
    }
#line 55
    if (no_term_file) {
      {
#line 56
      printf((char const   */* __restrict  */)"%s", *(winfo->wname + (wseq___0[i])->wid));
      }
    } else {
      {
#line 58
      printf((char const   */* __restrict  */)"%s", *(termname + *(winfo->wton + (wseq___0[i])->wid)));
      }
    }
#line 60
    if ((unsigned long )(wseq___0[i])->next != (unsigned long )((void *)0)) {
#line 61
      tok = (wseq___0[i])->next;
      {
#line 61
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 61
        if (! tok) {
#line 61
          goto while_break___1;
        }
#line 62
        if (no_term_file) {
          {
#line 63
          printf((char const   */* __restrict  */)"|%s", *(winfo->wname + tok->wid));
          }
        } else {
          {
#line 65
          printf((char const   */* __restrict  */)"|%s", *(termname + *(winfo->wton + tok->wid)));
          }
        }
#line 61
        tok = tok->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 68
      printf((char const   */* __restrict  */)")");
      }
    }
#line 49
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 71
  printf((char const   */* __restrict  */)"\n");
  }
#line 72
  return;
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static boolean get_wtoken(void) 
{ 
  char *p___0 ;
  int i ;
  int it ;
  WTOKEN *new ;
  WTOKEN *prev ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 82
  if (term_mode) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"please input category sequence>");
    }
  } else {
    {
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"please input word sequence>");
    }
  }
  {
#line 87
  tmp = fgets((char */* __restrict  */)(buf___11), 4096, (FILE */* __restrict  */)stdin);
  }
#line 87
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 89
    exit(0);
    }
  }
  {
#line 93
  nseq___0 = 0;
#line 94
  p___0 = strtok((char */* __restrict  */)(buf___11), (char const   */* __restrict  */)" \n");
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! p___0) {
#line 94
      goto while_break;
    }
#line 95
    it = 0;
#line 96
    prev = (WTOKEN *)((void *)0);
#line 97
    if (term_mode) {
#line 98
      if (no_term_file) {
        {
#line 99
        tmp___3 = atoi((char const   *)p___0);
        }
#line 99
        if (tmp___3 >= 0) {
          {
#line 99
          tmp___4 = atoi((char const   *)p___0);
          }
#line 99
          if (tmp___4 < dfa->term_num) {
            {
#line 100
            tmp___0 = mymalloc(sizeof(WTOKEN ));
#line 100
            new = (WTOKEN *)tmp___0;
#line 101
            tmp___1 = atoi((char const   *)p___0);
            }
#line 101
            if (*(dfa->term.wnum + tmp___1) == 0) {
              {
#line 102
              printf((char const   */* __restrict  */)"rejected at %d: category \"%s\" has no word\n",
                     nseq___0 + 1, p___0);
              }
#line 103
              return ((boolean )0);
            }
            {
#line 105
            tmp___2 = atoi((char const   *)p___0);
#line 105
            new->wid = *(*(dfa->term.tw + tmp___2) + 0);
#line 106
            new->next = prev;
#line 107
            prev = new;
#line 108
            it ++;
            }
          }
        }
      } else {
#line 111
        i = 0;
        {
#line 111
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 111
          if (! (i < dfa->term_num)) {
#line 111
            goto while_break___0;
          }
          {
#line 112
          tmp___6 = strcmp((char const   *)p___0, (char const   *)*(termname + i));
          }
#line 112
          if (! tmp___6) {
#line 113
            if (*(dfa->term.wnum + i) == 0) {
              {
#line 114
              printf((char const   */* __restrict  */)"rejected at %d: category \"%s\" has no word\n",
                     nseq___0 + 1, p___0);
              }
#line 115
              return ((boolean )0);
            }
            {
#line 117
            tmp___5 = mymalloc(sizeof(WTOKEN ));
#line 117
            new = (WTOKEN *)tmp___5;
#line 118
            new->wid = *(*(dfa->term.tw + i) + 0);
#line 119
            new->next = prev;
#line 120
            prev = new;
#line 121
            it ++;
            }
          }
#line 111
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 125
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        {
#line 126
        printf((char const   */* __restrict  */)"rejected at %d: category \"%s\" not exist\n",
               nseq___0 + 1, p___0);
        }
#line 127
        return ((boolean )0);
      }
    } else {
#line 130
      i = 0;
      {
#line 130
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 130
        if (! (i < (int )winfo->num)) {
#line 130
          goto while_break___1;
        }
        {
#line 131
        tmp___8 = strcmp((char const   *)p___0, (char const   *)*(winfo->woutput + i));
        }
#line 131
        if (! tmp___8) {
          {
#line 132
          tmp___7 = mymalloc(sizeof(WTOKEN ));
#line 132
          new = (WTOKEN *)tmp___7;
#line 133
          new->wid = (WORD_ID )i;
#line 134
          new->next = prev;
#line 135
          prev = new;
#line 136
          it ++;
          }
        }
#line 130
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 139
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        {
#line 140
        printf((char const   */* __restrict  */)"rejected at %d: word \"%s\" not in voca\n",
               nseq___0 + 1, p___0);
        }
#line 141
        return ((boolean )0);
      }
    }
    {
#line 144
    tmp___9 = nseq___0;
#line 144
    nseq___0 ++;
#line 144
    wseq___0[tmp___9] = new;
#line 94
    p___0 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  put_wtoken___0();
  }
#line 149
  return ((boolean )1);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static void put_state___0(int s , int l ) 
{ 
  int i ;

  {
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i <= l)) {
#line 158
      goto while_break;
    }
    {
#line 158
    printf((char const   */* __restrict  */)"  ");
#line 158
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  printf((char const   */* __restrict  */)"[%d]\n", s);
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static boolean can_accept_recursive___0(int stateid , int iseq ) 
{ 
  WTOKEN *token ;
  DFA_ARC *arc ;
  DFA_ARC *arc2 ;
  int cate ;
  int cate2 ;
  int ns ;
  int ns2 ;
  int i ;
  boolean tmp ;
  boolean tmp___0 ;

  {
#line 170
  if (verbose_flag) {
    {
#line 170
    put_state___0(stateid, iseq);
    }
  }
#line 172
  if (nseq_reached___0 > iseq) {
#line 172
    nseq_reached___0 = iseq;
  }
#line 173
  if (iseq < 0) {
#line 175
    if ((dfa->st + stateid)->status | 1U) {
#line 176
      return ((boolean )1);
    } else {
#line 178
      return ((boolean )0);
    }
  }
#line 182
  token = wseq___0[iseq];
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! token) {
#line 182
      goto while_break;
    }
#line 183
    if (verbose_flag) {
#line 184
      i = 0;
      {
#line 184
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 184
        if (! (i <= iseq)) {
#line 184
          goto while_break___0;
        }
        {
#line 184
        printf((char const   */* __restrict  */)"  ");
#line 184
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 185
      if (no_term_file) {
        {
#line 186
        printf((char const   */* __restrict  */)"%s(%s)\n", *(winfo->woutput + token->wid),
               *(winfo->wname + token->wid));
        }
      } else {
        {
#line 188
        printf((char const   */* __restrict  */)"%s(%s:%s)\n", *(winfo->woutput + token->wid),
               *(termname + *(winfo->wton + token->wid)), *(winfo->wname + token->wid));
        }
      }
    }
#line 191
    arc = (dfa->st + stateid)->arc;
    {
#line 191
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 191
      if (! arc) {
#line 191
        goto while_break___1;
      }
#line 192
      cate = (int )arc->label;
#line 193
      ns = arc->to_state;
#line 194
      if (*(dfa->is_sp + cate)) {
#line 195
        arc2 = (dfa->st + ns)->arc;
        {
#line 195
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 195
          if (! arc2) {
#line 195
            goto while_break___2;
          }
#line 196
          cate2 = (int )arc2->label;
#line 197
          ns2 = arc2->to_state;
#line 198
          if (cate2 == (int )*(winfo->wton + token->wid)) {
            {
#line 199
            tmp = can_accept_recursive___0(ns2, iseq - 1);
            }
#line 199
            if (tmp) {
#line 200
              return ((boolean )1);
            } else
#line 203
            if (verbose_flag) {
              {
#line 203
              put_state___0(stateid, iseq);
              }
            }
          }
#line 195
          arc2 = arc2->next;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else
#line 208
      if (cate == (int )*(winfo->wton + token->wid)) {
        {
#line 209
        tmp___0 = can_accept_recursive___0(ns, iseq - 1);
        }
#line 209
        if (tmp___0) {
#line 210
          return ((boolean )1);
        } else
#line 213
        if (verbose_flag) {
          {
#line 213
          put_state___0(stateid, iseq);
          }
        }
      }
#line 191
      arc = arc->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 182
    token = token->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return ((boolean )0);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static void accept_main(void) 
{ 
  int i ;
  boolean tmp ;
  boolean tmp___0 ;

  {
  {
#line 229
  tmp = get_wtoken();
  }
#line 229
  if (! tmp) {
#line 229
    return;
  }
#line 230
  if (nseq___0 == 0) {
#line 230
    return;
  }
#line 232
  nseq_reached___0 = nseq___0;
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < dfa->state_num)) {
#line 234
      goto while_break;
    }
#line 235
    if (((dfa->st + i)->status & 268435456U) != 0U) {
      {
#line 236
      tmp___0 = can_accept_recursive___0(i, nseq___0 - 1);
      }
#line 236
      if (tmp___0) {
        {
#line 237
        printf((char const   */* __restrict  */)"accepted\n");
        }
#line 238
        return;
      }
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  printf((char const   */* __restrict  */)"rejected at %d by DFA\n", nseq_reached___0 + 1);
  }
#line 243
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static char *usage___6(char *s ) 
{ 


  {
  {
#line 249
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"accept_check --- determine acception/rejection of transcription from stdin\n");
#line 250
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-t] [-v] prefix\n",
          s);
#line 251
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t  ... use category symbols instead of words (needs .term)\n");
#line 252
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s string ... specify short-pause model\n");
#line 253
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v  ... verbose output\n");
#line 254
  exit(1);
  }
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/gramtools/accept_check/accept_check.c"
static void put_dfainfo___1(void) 
{ 


  {
  {
#line 260
  printf((char const   */* __restrict  */)"%d categories, %d words\n", dfa->term_num,
         (int )winfo->num);
#line 261
  printf((char const   */* __restrict  */)"DFA has %d nodes and %d arcs\n", dfa->state_num,
         dfa->arc_num);
  }
#line 262
  return;
}
}
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 228 "../libsent/include/sent/ngram2.h"
extern LOGPROB ngram_prob(NGRAM_INFO *ndata , int n , WORD_ID *w ) ;
#line 240
extern WORD_ID ngram_lookup_word(NGRAM_INFO *ndata , char *wordstr ) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static char *bos_default  =    (char *)"<s>";
#line 8 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static char *eos_default  =    (char *)"</s>";
#line 9 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static char *ignore_default  =    (char *)"<UNK>";
#line 19 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
NGRAM_INFO *ngram  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
WORD_INFO *dict  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static LOGPROB *findex  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static char buf___12[4096]  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/generate-ngram/generate-ngram.c"
static int s1(void *p___0 , void *q___0 ) 
{ 
  WORD_ID *a ;
  WORD_ID *b ;
  WORD_ID x___0 ;
  WORD_ID y ;

  {
#line 46
  a = (WORD_ID *)p___0;
#line 46
  b = (WORD_ID *)q___0;
#line 47
  x___0 = *a;
#line 47
  y = *b;
#line 48
  if (*(findex + x___0) > *(findex + y)) {
#line 48
    return (-1);
  } else
#line 49
  if (*(findex + x___0) < *(findex + y)) {
#line 49
    return (1);
  } else {
#line 50
    return (0);
  }
}
}
#line 94 "../libsent/include/sent/util.h"
extern void swap_bytes(char *buf , size_t unitbyte , size_t unitnum ) ;
#line 214 "../libsent/include/sent/mfcc.h"
extern MFCCWork *WMP_work_new(Value *para ) ;
#line 216
extern void WMP_free(MFCCWork *w ) ;
#line 276
extern float *new_SS_calculate(SP16 *wave , int wavelen , int *slen , MFCCWork *w ,
                               Value *para ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int fd___1  =    -1;
#line 20 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static char *filename___1  =    (char *)((void *)0);
#line 21 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static boolean stout___0  =    (boolean )0;
#line 22 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int sfreq___1  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int slen  =    3000;
#line 26 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static SP16 *speech  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int speechnum  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int samples  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static boolean opt_help___2(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mkss --- compute averate spectrum of mic input for SS\n");
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: mkss [options..] filename\n");
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-freq frequency]    sampling freq in Hz   (%ld)\n",
          (jconf->am_root)->analysis.para_default.smp_freq);
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-len msec]          record length in msec (%d)\n",
          slen);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-fsize samplenum]   window size           (%d)\n",
          (jconf->am_root)->analysis.para_default.framesize);
#line 38
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-fshift samplenum]  frame shift           (%d)\n",
          (jconf->am_root)->analysis.para_default.frameshift);
#line 39
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-zmean]             enable zmean         (off)\n");
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    [-zmeanframe]        frame-wise zmean     (off)\n");
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Library configuration: ");
#line 42
  confout_version(stderr);
#line 43
  confout_audio(stderr);
#line 44
  confout_process(stderr);
#line 45
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 46
  exit(1);
  }
#line 47
  return ((boolean )1);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static boolean opt_freq___1(Jconf *jconf , char **arg , int argnum ) 
{ 
  int tmp ;

  {
  {
#line 53
  tmp = atoi((char const   *)*(arg + 0));
#line 53
  (jconf->amnow)->analysis.para.smp_freq = (long )tmp;
#line 54
  (jconf->amnow)->analysis.para.smp_period = (long )(10000000.0 / (double )((float )(jconf->amnow)->analysis.para.smp_freq));
  }
#line 55
  return ((boolean )1);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static boolean opt_len(Jconf *jconf , char **arg , int argnum ) 
{ 


  {
  {
#line 60
  slen = atoi((char const   *)*(arg + 0));
  }
#line 61
  return ((boolean )1);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int adin_callback(SP16 *now , int len , Recog *recog ) 
{ 
  int num ;
  int ret ;

  {
#line 71
  if (speechnum + len > samples) {
#line 72
    num = samples - speechnum;
#line 74
    ret = 1;
  } else {
#line 76
    num = len;
#line 78
    ret = 0;
  }
  {
#line 80
  memcpy((void */* __restrict  */)(speech + speechnum), (void const   */* __restrict  */)now,
         (unsigned long )num * sizeof(SP16 ));
  }
#line 82
  if (speechnum / sfreq___1 != (speechnum + num) / sfreq___1) {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"|");
    }
  } else {
    {
#line 85
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".");
    }
  }
#line 88
  speechnum += num;
#line 90
  return (ret);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int x  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/julius-4.2.2/mkss/mkss.c"
static int sslen  ;
