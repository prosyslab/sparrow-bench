/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 68 "./../DylpStdLib/dylib_std.h"
typedef char bool;
#line 98 "./../DylpStdLib/dylib_std.h"
typedef unsigned int flags;
#line 118 "./../DylpStdLib/dylib_std.h"
struct lnk_struct_tag {
   struct lnk_struct_tag *llnxt ;
   void *llval ;
};
#line 118 "./../DylpStdLib/dylib_std.h"
typedef struct lnk_struct_tag lnk_struct;
#line 39 "./../DylpStdLib/dylib_io.h"
typedef int ioid;
#line 231 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
struct __anonstruct_pkcoeff_struct_27 {
   int ndx ;
   double val ;
};
#line 231 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
typedef struct __anonstruct_pkcoeff_struct_27 pkcoeff_struct;
#line 234 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
struct __anonstruct_pkvec_struct_28 {
   int ndx ;
   char const   *nme ;
   int dim ;
   double dflt ;
   int cnt ;
   int sze ;
   pkcoeff_struct *coeffs ;
};
#line 234 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
typedef struct __anonstruct_pkvec_struct_28 pkvec_struct;
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct rowhdr_struct_tag;
#line 102
struct colhdr_struct_tag;
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct coeff_struct_tag {
   struct rowhdr_struct_tag *rowhdr ;
   struct colhdr_struct_tag *colhdr ;
   double val ;
   struct coeff_struct_tag *rownxt ;
   struct coeff_struct_tag *colnxt ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct coeff_struct_tag coeff_struct;
#line 120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct colhdr_struct_tag {
   int ndx ;
   int len ;
   char const   *nme ;
   coeff_struct *coeffs ;
};
#line 120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct colhdr_struct_tag colhdr_struct;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct rowhdr_struct_tag {
   int ndx ;
   int len ;
   char const   *nme ;
   coeff_struct *coeffs ;
};
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct rowhdr_struct_tag rowhdr_struct;
#line 153 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct __anonstruct_conmtx_struct_29 {
   int coeffcnt ;
   colhdr_struct **cols ;
   rowhdr_struct **rows ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct __anonstruct_conmtx_struct_29 conmtx_struct;
#line 267 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct attvhdr_struct_tag {
   struct attvhdr_struct_tag *nxt ;
   flags what ;
   int elsze ;
   void *vec ;
   lnk_struct *pveclst ;
};
#line 267 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct attvhdr_struct_tag attvhdr_struct;
#line 308 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct __anonstruct_conbnd_struct_30 {
   int revs ;
   int inf ;
   double bnd ;
};
#line 308 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct __anonstruct_conbnd_struct_30 conbnd_struct;
#line 338
enum __anonenum_contyp_enum_31 {
    contypINV = 0,
    contypNB = 1,
    contypGE = 2,
    contypEQ = 3,
    contypLE = 4,
    contypRNG = 5
} ;
#line 338 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef enum __anonenum_contyp_enum_31 contyp_enum;
#line 354
enum __anonenum_vartyp_enum_32 {
    vartypINV = 0,
    vartypCON = 1,
    vartypINT = 2,
    vartypBIN = 3
} ;
#line 354 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef enum __anonenum_vartyp_enum_32 vartyp_enum;
#line 460 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
struct __anonstruct_consys_struct_33 {
   char const   *nme ;
   flags parts ;
   flags opts ;
   double inf ;
   double tiny ;
   int varcnt ;
   int archvcnt ;
   int logvcnt ;
   int intvcnt ;
   int binvcnt ;
   int maxcollen ;
   int maxcolndx ;
   int concnt ;
   int archccnt ;
   int cutccnt ;
   int maxrowlen ;
   int maxrowndx ;
   int colsze ;
   int rowsze ;
   conmtx_struct mtx ;
   double maxaij ;
   double minaij ;
   double *rowscale ;
   double *colscale ;
   char const   *objnme ;
   int objndx ;
   int xzndx ;
   double *obj ;
   vartyp_enum *vtyp ;
   double *vub ;
   double *vlb ;
   double *rhs ;
   double *rhslow ;
   contyp_enum *ctyp ;
   conbnd_struct *cub ;
   conbnd_struct *clb ;
   attvhdr_struct *attvecs ;
};
#line 460 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
typedef struct __anonstruct_consys_struct_33 consys_struct;
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
union __anonunion_fpunion_t_26 {
   unsigned char fpchr[8] ;
   double fpdbl ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
typedef union __anonunion_fpunion_t_26 fpunion_t;
#line 170 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
enum __anonenum_lpret_enum_34 {
    lpFATAL = -1,
    lpINV = 0,
    lpOPTIMAL = 1,
    lpUNBOUNDED = 2,
    lpSWING = 3,
    lpINFEAS = 4,
    lpACCCHK = 5,
    lpSTALLED = 6,
    lpITERLIM = 7,
    lpNOSPACE = 8,
    lpLOSTFEAS = 9,
    lpPUNT = 10,
    lpFORCEDUAL = 11,
    lpFORCEPRIMAL = 12,
    lpFORCEFULL = 13
} ;
#line 170 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef enum __anonenum_lpret_enum_34 lpret_enum;
#line 212
enum __anonenum_dyphase_enum_35 {
    dyINV = 0,
    dyINIT = 1,
    dyPRIMAL1 = 2,
    dyPRIMAL2 = 3,
    dyDUAL = 4,
    dyPURGEVAR = 5,
    dyGENVAR = 6,
    dyADDVAR = 7,
    dyPURGECON = 8,
    dyGENCON = 9,
    dyADDCON = 10,
    dyFORCEDUAL = 11,
    dyFORCEPRIMAL = 12,
    dyFORCEFULL = 13,
    dyDONE = 14
} ;
#line 212 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef enum __anonenum_dyphase_enum_35 dyphase_enum;
#line 274
enum __anonenum_dyret_enum_36 {
    dyrFATAL = -10,
    dyrITERLIM = -9,
    dyrSTALLED = -8,
    dyrBSPACE = -7,
    dyrSINGULAR = -6,
    dyrNUMERIC = -5,
    dyrLOSTPFEAS = -4,
    dyrLOSTDFEAS = -3,
    dyrDEGEN = -2,
    dyrMADPIV = -1,
    dyrINV = 0,
    dyrOK = 1,
    dyrPATCHED = 2,
    dyrRESELECT = 3,
    dyrREQCHK = 4,
    dyrACCCHK = 5,
    dyrPUNT = 6,
    dyrOPTIMAL = 7,
    dyrUNBOUND = 8,
    dyrSWING = 9,
    dyrINFEAS = 10
} ;
#line 274 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef enum __anonenum_dyret_enum_36 dyret_enum;
#line 661 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lptols_struct_40 {
   double inf ;
   double zero ;
   double pchk ;
   double pfeas ;
   double pfeas_scale ;
   double cost ;
   double dchk ;
   double dfeas ;
   double dfeas_scale ;
   double pivot ;
   double bogus ;
   double swing ;
   double toobig ;
   double purge ;
   double purgevar ;
   double reframe ;
};
#line 661 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_lptols_struct_40 lptols_struct;
#line 761
enum __anonenum_ibtype_enum_41 {
    ibINV = 0,
    ibLOGICAL = 1,
    ibSLACK = 2,
    ibARCH = 3
} ;
#line 761 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef enum __anonenum_ibtype_enum_41 ibtype_enum;
#line 777
enum __anonenum_cxtype_enum_42 {
    cxINV = 0,
    cxSINGLELP = 1,
    cxINITIALLP = 2,
    cxBANDC = 3
} ;
#line 777 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef enum __anonenum_cxtype_enum_42 cxtype_enum;
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_dpsel_44 {
   int strat ;
   bool flex ;
   bool allownopiv ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_ppsel_45 {
   int strat ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_con_46 {
   int actlvl ;
   int actlim ;
   int deactlvl ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_active_47 {
   float vars ;
   float cons ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_initcons_48 {
   double frac ;
   bool i1lopen ;
   double i1l ;
   bool i1uopen ;
   double i1u ;
   bool i2valid ;
   bool i2lopen ;
   double i2l ;
   bool i2uopen ;
   double i2u ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_finpurge_49 {
   bool cons ;
   bool vars ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_heroics_50 {
   bool d2p ;
   bool p2d ;
   bool flips ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_print_51 {
   int major ;
   int scaling ;
   int setup ;
   int crash ;
   int pricing ;
   int pivoting ;
   int pivreject ;
   int degen ;
   int phase1 ;
   int phase2 ;
   int dual ;
   int basis ;
   int conmgmt ;
   int varmgmt ;
   int force ;
   int tableau ;
   int rays ;
   int soln ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lpopts_struct_43 {
   cxtype_enum context ;
   int scan ;
   int iterlim ;
   int idlelim ;
   struct __anonstruct_dpsel_44 dpsel ;
   struct __anonstruct_ppsel_45 ppsel ;
   int factor ;
   int check ;
   int groom ;
   struct __anonstruct_con_46 con ;
   int addvar ;
   int dualadd ;
   int coldvars ;
   bool forcecold ;
   bool forcewarm ;
   bool usedual ;
   bool degen ;
   int degenpivlim ;
   int degenlite ;
   bool patch ;
   bool fullsys ;
   bool copyorigsys ;
   int scaling ;
   struct __anonstruct_active_47 active ;
   struct __anonstruct_initcons_48 initcons ;
   ibtype_enum coldbasis ;
   struct __anonstruct_finpurge_49 finpurge ;
   struct __anonstruct_heroics_50 heroics ;
   struct __anonstruct_print_51 print ;
};
#line 1101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_lpopts_struct_43 lpopts_struct;
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_simplex_68 {
   dyphase_enum active ;
   dyphase_enum next ;
   bool init_pse ;
   bool init_dse ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_ubnd_69 {
   int ndx ;
   double ratio ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_p1obj_70 {
   bool installed ;
   int infcnt ;
   int infvars_sze ;
   int *infvars ;
   double *p1obj ;
   double *p2obj ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_cons_72 {
   int loadable ;
   int unloadable ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_vars_73 {
   int loadable ;
   int unloadable ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_sys_71 {
   struct __anonstruct_cons_72 cons ;
   struct __anonstruct_vars_73 vars ;
   bool forcedfull ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_tot_74 {
   int iters ;
   int pivs ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_p1_75 {
   int iters ;
   int pivs ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_p2_76 {
   int iters ;
   int pivs ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_d2_77 {
   int iters ;
   int pivs ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_basis_78 {
   int etas ;
   int pivs ;
   int dinf ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lastz_79 {
   double piv ;
   double cd ;
   double vd ;
   double fp ;
   double fd ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_prim_80 {
   double norm1 ;
   double norm2 ;
   double max ;
   int maxndx ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_dual_81 {
   double norm1 ;
   double norm2 ;
   double max ;
   int maxndx ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lp_struct_67 {
   dyphase_enum phase ;
   lpret_enum lpret ;
   double z ;
   double inactzcorr ;
   struct __anonstruct_simplex_68 simplex ;
   double infeas ;
   int infeascnt ;
   struct __anonstruct_ubnd_69 ubnd ;
   struct __anonstruct_p1obj_70 p1obj ;
   struct __anonstruct_sys_71 sys ;
   struct __anonstruct_tot_74 tot ;
   struct __anonstruct_p1_75 p1 ;
   struct __anonstruct_p2_76 p2 ;
   struct __anonstruct_d2_77 d2 ;
   bool pivok ;
   bool prev_pivok ;
   struct __anonstruct_basis_78 basis ;
   int degen ;
   int degenpivcnt ;
   int idlecnt ;
   struct __anonstruct_lastz_79 lastz ;
   struct __anonstruct_prim_80 prim ;
   struct __anonstruct_dual_81 dual ;
};
#line 1537 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_lp_struct_67 lp_struct;
#line 451 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_basisel_struct_37 {
   int cndx ;
   int vndx ;
};
#line 451 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_basisel_struct_37 basisel_struct;
#line 453 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_basis_struct_38 {
   int len ;
   basisel_struct *el ;
};
#line 453 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_basis_struct_38 basis_struct;
#line 583 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lpprob_struct_39 {
   flags ctlopts ;
   dyphase_enum phase ;
   lpret_enum lpret ;
   double obj ;
   int iters ;
   consys_struct *consys ;
   basis_struct *basis ;
   flags *status ;
   double *x ;
   double *y ;
   bool *actvars ;
   int colsze ;
   int rowsze ;
};
#line 583 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_lpprob_struct_39 lpprob_struct;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
struct ENV;
#line 50 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
typedef struct ENV ENV;
#line 51
struct MEM;
#line 51 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
typedef struct MEM MEM;
#line 53 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
struct ENV {
   MEM *mem_ptr ;
   int mem_limit ;
   int mem_total ;
   int mem_tpeak ;
   int mem_count ;
   int mem_cpeak ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
struct MEM {
   int size ;
   int flag ;
   MEM *prev ;
   MEM *next ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
enum __anonenum_lexclass_21 {
    DY_LCNIL = 0,
    DY_LCNUM = 1,
    DY_LCID = 2,
    DY_LCDEL = 3,
    DY_LCFS = 4,
    DY_LCQS = 5,
    DY_LCEOF = 6,
    DY_LCERR = 7
} ;
#line 67 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
typedef enum __anonenum_lexclass_21 lexclass;
#line 74 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
struct __anonstruct_lex_struct_22 {
   lexclass class ;
   char *string ;
};
#line 74 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
typedef struct __anonstruct_lex_struct_22 lex_struct;
#line 107 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
enum __anonenum_bnftype_enum_23 {
    bnfG = 0,
    bnfNP = 1,
    bnfP = 2,
    bnfT = 3,
    bnfDS = 4,
    bnfDL = 5,
    bnfRS = 6,
    bnfRL = 7,
    bnfI = 8,
    bnfL = 9
} ;
#line 107 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef enum __anonenum_bnftype_enum_23 bnftype_enum;
#line 124
enum __anonenum_bnfttype_enum_24 {
    bnfttNIL = 0,
    bnfttN = 1,
    bnfttID = 2,
    bnfttD = 3,
    bnfttF = 4,
    bnfttQ = 5
} ;
#line 124 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef enum __anonenum_bnfttype_enum_24 bnfttype_enum;
#line 147
enum __anonenum_bnflblsrc_enum_25 {
    bnfncBNF = 0,
    bnfncS = 1,
    bnfncC = 2,
    bnfncN = 3
} ;
#line 147 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef enum __anonenum_bnflblsrc_enum_25 bnflblsrc_enum;
#line 266 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfdef_struct_26 {
   bnftype_enum type ;
   char const   *name ;
};
#line 266 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfdef_struct_26 bnfdef_struct;
#line 285
struct bnfref_struct_tag;
#line 285 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfGdef_struct_27 {
   bnftype_enum type ;
   char const   *name ;
   int size ;
   int link ;
   struct bnfref_struct_tag **comps ;
};
#line 285 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfGdef_struct_27 bnfGdef_struct;
#line 301 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfNPdef_struct_28 {
   bnftype_enum type ;
   char const   *name ;
   struct bnfref_struct_tag ***alts ;
};
#line 301 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfNPdef_struct_28 bnfNPdef_struct;
#line 313 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef bnfNPdef_struct bnfPdef_struct;
#line 337 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfTdef_struct_29 {
   bnftype_enum type ;
   char const   *name ;
   bnfttype_enum ttype ;
   char qschr ;
   char qechr ;
   int parm1 ;
   char const   *val ;
};
#line 337 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfTdef_struct_29 bnfTdef_struct;
#line 355 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfIdef_struct_30 {
   bnftype_enum type ;
   char const   *name ;
   int ival ;
};
#line 355 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfIdef_struct_30 bnfIdef_struct;
#line 371 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfLdef_struct_31 {
   bnftype_enum type ;
   char const   *name ;
   flags dflgs ;
   char *txt ;
};
#line 371 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfLdef_struct_31 bnfLdef_struct;
#line 406 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct __anonstruct_bnfLBdef_struct_32 {
   bnftype_enum type ;
   char const   *name ;
   flags dflgs ;
   bnflblsrc_enum nmcd ;
   bnflblsrc_enum ndcd ;
   int savnm ;
   struct bnfref_struct_tag *nmsrc ;
   int savnd ;
   struct bnfref_struct_tag *ndsrc ;
   int offset ;
   int offset2 ;
};
#line 406 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct __anonstruct_bnfLBdef_struct_32 bnfLBdef_struct;
#line 427 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
union __anonunion_bnfdef_any_33 {
   bnfdef_struct *com ;
   bnfGdef_struct *G ;
   bnfNPdef_struct *NP ;
   bnfPdef_struct *P ;
   bnfTdef_struct *T ;
   bnfIdef_struct *I ;
   bnfLdef_struct *L ;
   bnfLBdef_struct *LB ;
};
#line 427 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef union __anonunion_bnfdef_any_33 bnfdef_any;
#line 464 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct bnfref_struct_tag {
   bnftype_enum type ;
   char const   *name ;
   bnfdef_struct *defn ;
   flags uflgs ;
};
#line 464 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_struct_tag bnfref_struct;
#line 473 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef bnfref_struct bnfLBref_struct;
#line 474 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef bnfref_struct bnfLref_struct;
#line 487 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct bnfref_type2 {
   bnftype_enum type ;
   char const   *name ;
   bnfdef_struct *defn ;
   flags uflgs ;
   int offset ;
};
#line 490 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_type2 bnfTref_struct;
#line 491 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_type2 bnfIref_struct;
#line 508 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
struct bnfref_type3 {
   bnftype_enum type ;
   char const   *name ;
   bnfdef_struct *defn ;
   flags uflgs ;
   int offset ;
   bnfref_struct *sep ;
};
#line 512 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_type3 bnfGref_struct;
#line 513 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_type3 bnfNPref_struct;
#line 514 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef struct bnfref_type3 bnfPref_struct;
#line 522
struct bnfref_type1;
#line 522 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
union __anonunion_bnfref_any_34 {
   bnfref_struct *com ;
   struct bnfref_type1 *t1 ;
   struct bnfref_type2 *t2 ;
   struct bnfref_type3 *t3 ;
   bnfGref_struct *G ;
   bnfNPref_struct *NP ;
   bnfPref_struct *P ;
   bnfTref_struct *T ;
   bnfIref_struct *I ;
   bnfLref_struct *L ;
   bnfLBref_struct *LB ;
};
#line 522 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef union __anonunion_bnfref_any_34 bnfref_any;
#line 711 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
union __anonunion_parse_any_35 {
   void *g ;
   char *c ;
};
#line 711 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
typedef union __anonunion_parse_any_35 parse_any;
#line 124 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
struct deflbl_struct_tag {
   struct deflbl_struct_tag *lblnxt ;
   char const   *lblnmtxt ;
   void *lblval ;
   bool lbladv ;
};
#line 124 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
typedef struct deflbl_struct_tag deflbl_struct;
#line 129 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
struct udeflbl_struct_tag {
   struct udeflbl_struct_tag *lblnxt ;
   char const   *lblnmtxt ;
   void *lblval ;
};
#line 129 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
typedef struct udeflbl_struct_tag udeflbl_struct;
#line 135 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
struct __anonstruct_piv_83 {
   double delta ;
   double inf ;
   double maxinf ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
struct __anonstruct_flip_84 {
   double delta ;
   double inf ;
   double maxinf ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
struct __anonstruct_dualcand_struct_82 {
   int ndx ;
   double abarik ;
   double ratioik ;
   bool madpiv ;
   double ddelta ;
   int pivdir ;
   bool flippable ;
   bool rev ;
   struct __anonstruct_piv_83 piv ;
   struct __anonstruct_flip_84 flip ;
};
#line 135 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
typedef struct __anonstruct_dualcand_struct_82 dualcand_struct;
#line 64 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
struct __anonstruct_pivrej_struct_82 {
   int ndx ;
   int iter ;
   dyret_enum why ;
   double ratio ;
};
#line 64 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
typedef struct __anonstruct_pivrej_struct_82 pivrej_struct;
#line 92 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
struct __anonstruct_pivrejctl_struct_83 {
   int sze ;
   int cnt ;
   int mad ;
   int sing ;
   int iter_reduced ;
   double savedtol ;
   double pivmul ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
typedef struct __anonstruct_pivrejctl_struct_83 pivrejctl_struct;
#line 128 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
struct __anonstruct_degenstats_struct_82 {
   int iterin[25] ;
};
#line 128 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
typedef struct __anonstruct_degenstats_struct_82 degenstats_struct;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 80 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
struct LUF;
#line 80 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
typedef struct LUF LUF;
#line 81
struct LUF_WA;
#line 81 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
typedef struct LUF_WA LUF_WA;
#line 83 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
struct LUF {
   int n ;
   int valid ;
   int *fr_ptr ;
   int *fr_len ;
   int *fc_ptr ;
   int *fc_len ;
   int *vr_ptr ;
   int *vr_len ;
   int *vr_cap ;
   double *vr_piv ;
   int *vc_ptr ;
   int *vc_len ;
   int *vc_cap ;
   int *pp_row ;
   int *pp_col ;
   int *qq_row ;
   int *qq_col ;
   int sv_size ;
   int sv_beg ;
   int sv_end ;
   int *sv_ndx ;
   double *sv_val ;
   int sv_head ;
   int sv_tail ;
   int *sv_prev ;
   int *sv_next ;
   int *flag ;
   double *work ;
   int new_sva ;
   double piv_tol ;
   int piv_lim ;
   int suhl ;
   double eps_tol ;
   double max_gro ;
   int nnz_a ;
   int nnz_f ;
   int nnz_v ;
   double max_a ;
   double big_v ;
   int rank ;
};
#line 270 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
struct LUF_WA {
   double *rs_max ;
   int *rs_head ;
   int *rs_prev ;
   int *rs_next ;
   int *cs_head ;
   int *cs_prev ;
   int *cs_next ;
};
#line 76 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.h"
struct INV;
#line 76 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.h"
typedef struct INV INV;
#line 78 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.h"
struct INV {
   int m ;
   int valid ;
   LUF *luf ;
   int hh_max ;
   int hh_nfs ;
   int *hh_ndx ;
   int *hh_ptr ;
   int *hh_len ;
   int *p0_row ;
   int *p0_col ;
   int cc_len ;
   int *cc_ndx ;
   double *cc_val ;
   double upd_tol ;
   int nnz_h ;
   double min_vrratio ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_keytab.h"
struct keytab_entry_internal {
   char const   *keyword ;
   int min ;
   int token ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_keytab.h"
typedef struct keytab_entry_internal keytab_entry;
#line 37 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.h"
struct hel_tag {
   struct hel_tag *next ;
   char const   *key ;
   void *ent ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.h"
typedef struct hel_tag hel;
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
struct __anonstruct_fdcand_struct_82 {
   int ndx ;
   bool flippable ;
   double delta ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
typedef struct __anonstruct_fdcand_struct_82 fdcand_struct;
#line 83 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
struct __anonstruct_filblk_struct_27 {
   FILE *stream ;
   flags modes ;
   int refcnt ;
   char *dname ;
   char *fname ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
typedef struct __anonstruct_filblk_struct_27 filblk_struct;
#line 146
enum __anonenum_chrclass_28 {
    CCINV = 0,
    CCDIG = 1,
    CCIDB = 2,
    CCDEL = 3,
    CCIG = 4,
    CCIDC = 5,
    CCEOF = 6,
    CCERR = 7
} ;
#line 146 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
typedef enum __anonenum_chrclass_28 chrclass;
#line 148 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
struct __anonstruct_chartab_struct_29 {
   chrclass class1 ;
   chrclass class2 ;
   char chrtrn ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
typedef struct __anonstruct_chartab_struct_29 chartab_struct;
#line 1160 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
struct state_struct {
   char nxtchr ;
   struct state_struct *fail ;
};
#line 71 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.h"
enum __anonenum_cmd_retval_36 {
    cmdOK = 0,
    cmdHALTERROR = 1,
    cmdHALTNOERROR = 2
} ;
#line 71 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.h"
typedef enum __anonenum_cmd_retval_36 cmd_retval;
#line 258 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct boolopt_struct {
   char *str ;
   int val ;
};
#line 353
enum prntcodes {
    poINV = 0,
    poBASIS = 1,
    poCONMGMT = 2,
    poCRASH = 3,
    poDEGEN = 4,
    poDUAL = 5,
    poFORCE = 6,
    poMAJOR = 7,
    poPHASE1 = 8,
    poPHASE2 = 9,
    poPIVOTING = 10,
    poPIVREJ = 11,
    poPRICING = 12,
    poRAYS = 13,
    poSCALING = 14,
    poSETUP = 15,
    poSOLN = 16,
    poTABLEAU = 17,
    poVARMGMT = 18
} ;
#line 553 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct actfrac_struct {
   int var_seen ;
   float varfrac ;
   int con_seen ;
   float confrac ;
};
#line 664 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct finpurge_struct {
   int cons ;
   int vars ;
};
#line 795 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct interval_struct {
   struct interval_struct *nxt ;
   char ldelim ;
   double ub ;
   double lb ;
   char rdelim ;
};
#line 801 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct load_struct {
   int frac_valid ;
   double frac ;
   struct interval_struct *intervals ;
};
#line 1040 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
struct infinity_struct {
   int code ;
   double val ;
};
#line 1193
enum ctlcodes {
    ctlINV = 0,
    ctlACTIVESZE = 1,
    ctlADDVARLIM = 2,
    ctlBOGUS = 3,
    ctlCHECK = 4,
    ctlCOLD = 5,
    ctlCOLDBASIS = 6,
    ctlCOLDVARS = 7,
    ctlCONACTLIM = 8,
    ctlCONACTLVL = 9,
    ctlCONDEACTLVL = 10,
    ctlCONTEXT = 11,
    ctlCPYORIG = 12,
    ctlCOSTZ = 13,
    ctlDCHK = 14,
    ctlDEGEN = 15,
    ctlDEGENLITE = 16,
    ctlDEGENPIVS = 17,
    ctlDFEAS = 18,
    ctlDUALADD = 19,
    ctlDUALMULTIPIV = 20,
    ctlFACTOR = 21,
    ctlFINAL = 22,
    ctlFULLSYS = 23,
    ctlGROOM = 24,
    ctlINFINITY = 25,
    ctlITER = 26,
    ctlIDLE = 27,
    ctlLOAD = 28,
    ctlPATCH = 29,
    ctlPCHK = 30,
    ctlPFEAS = 31,
    ctlPIVOT = 32,
    ctlPRIMMULTIPIV = 33,
    ctlPURGE = 34,
    ctlPURGEVAR = 35,
    ctlREFRAME = 36,
    ctlSCALING = 37,
    ctlSCAN = 38,
    ctlSWING = 39,
    ctlUSEDUAL = 40,
    ctlWARM = 41,
    ctlZERO = 42
} ;
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_cons_53 {
   int sze ;
   double *angle ;
   int *actcnt ;
   int *deactcnt ;
   bool *init ;
   bool *fin ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_vars_54 {
   int sze ;
   int *actcnt ;
   int *deactcnt ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_angle_55 {
   float max ;
   float min ;
   int hist[37] ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_factor_56 {
   int cnt ;
   int prevpiv ;
   float avgpivs ;
   int maxpivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_pivrej_57 {
   int max ;
   int mad ;
   int sing ;
   int pivtol_red ;
   double min_pivtol ;
   int puntcall ;
   int puntret ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_dmulti_58 {
   int flippable ;
   int cnt ;
   int cands ;
   int promote ;
   int nontrivial ;
   int evals ;
   int flips ;
   int pivrnks ;
   int maxrnk ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_pmulti_59 {
   int cnt ;
   int cands ;
   int nontrivial ;
   int promote ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_infeas_60 {
   int prevpiv ;
   int maxcnt ;
   int totpivs ;
   int maxpivs ;
   int chgcnt1 ;
   int chgcnt2 ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_pdegen_61 {
   int cnt ;
   float avgsiz ;
   int maxsiz ;
   int totpivs ;
   float avgpivs ;
   int maxpivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_ddegen_62 {
   int cnt ;
   float avgsiz ;
   int maxsiz ;
   int totpivs ;
   float avgpivs ;
   int maxpivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_tot_63 {
   int iters ;
   int pivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_p1_64 {
   int iters ;
   int pivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_p2_65 {
   int iters ;
   int pivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_d2_66 {
   int iters ;
   int pivs ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
struct __anonstruct_lpstats_struct_52 {
   int phasecnts[15] ;
   dyphase_enum ini_simplex ;
   struct __anonstruct_cons_53 cons ;
   struct __anonstruct_vars_54 vars ;
   struct __anonstruct_angle_55 angle ;
   struct __anonstruct_factor_56 factor ;
   struct __anonstruct_pivrej_57 pivrej ;
   struct __anonstruct_dmulti_58 dmulti ;
   struct __anonstruct_pmulti_59 pmulti ;
   struct __anonstruct_infeas_60 infeas ;
   struct __anonstruct_pdegen_61 pdegen[25] ;
   struct __anonstruct_ddegen_62 ddegen[25] ;
   struct __anonstruct_tot_63 tot ;
   struct __anonstruct_p1_64 p1 ;
   struct __anonstruct_p2_65 p2 ;
   struct __anonstruct_d2_66 d2 ;
};
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
typedef struct __anonstruct_lpstats_struct_52 lpstats_struct;
#line 134 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
enum __anonenum_start_enum_82 {
    startCOLD = 0,
    startWARM = 1,
    startHOT = 2
} ;
#line 134 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
typedef enum __anonenum_start_enum_82 start_enum;
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
struct __anonstruct_angle_struct_82 {
   int ndx ;
   double angle ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
typedef struct __anonstruct_angle_struct_82 angle_struct;
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
struct __anonstruct_ineq_struct_83 {
   int cnt ;
   int perp ;
   int far ;
   angle_struct *angles ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
typedef struct __anonstruct_ineq_struct_83 ineq_struct;
#line 1263 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
struct __anonstruct_ibrank_struct_84 {
   int ndx ;
   int bndcnt ;
   int nonzero ;
   double ajmax ;
};
#line 1263 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
typedef struct __anonstruct_ibrank_struct_84 ibrank_struct;
#line 43 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_littab.c"
struct litent_internal {
   int refs ;
   char *text ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_littab.c"
typedef struct litent_internal litent;
#line 45 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
struct __anonstruct_cmdchns_24 {
   ioid chn ;
   bool cecho ;
   bool gecho ;
   bool prompt ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
struct __anonstruct_primcand_struct_82 {
   int ndx ;
   double deltakj ;
   double abarkj ;
   double ratiokj ;
   bool madpiv ;
   int dir ;
   int bnd ;
   bool hard ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
typedef struct __anonstruct_primcand_struct_82 primcand_struct;
#line 53 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
struct __anonstruct_patch_struct_82 {
   int pos ;
   int out ;
   int in ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
typedef struct __anonstruct_patch_struct_82 patch_struct;
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
struct __anonstruct_pivtols_struct_83 {
   double stable ;
   int look ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
typedef struct __anonstruct_pivtols_struct_83 pivtols_struct;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 30 "./../DylpStdLib/dylib_errs.h"
void errmsg(int errid  , ...) ;
#line 99 "./../DylpStdLib/dylib_io.h"
void dyio_outfmt(ioid id , bool echo , char const   *pattern  , ...) ;
#line 102
int dyio_outfxd(char *buffer___1 , int fldsze , char lcr , char const   *pattern 
                , ...) ;
#line 32 "./../DylpStdLib/dylib_strrtns.h"
char const   *stralloc(char const   *string ) ;
#line 33
bool strfree(char const   *string ) ;
#line 244 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
void pkvec_free(pkvec_struct *pkvec ) ;
#line 516 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_getrow_pk(consys_struct *consys , int rowndx , pkvec_struct **pkvec ) ;
#line 582
char const   *consys_prtvartyp(vartyp_enum vartyp ) ;
#line 582
char const   *consys_prtcontyp(contyp_enum contyp ) ;
#line 584
char *consys_assocnme(consys_struct *consys , flags which ) ;
#line 584
char *consys_conbndnme(char bndlett , int cndx , conbnd_struct *bnd ) ;
#line 584
char *consys_conbndval(conbnd_struct *bnd ) ;
#line 593
void consys_prtcon(ioid chn , bool echo , consys_struct *consys , int i , char const   *pfx ) ;
#line 602
void consys_chgnme(consys_struct *consys , char cv , int ndx , char const   *newnme ) ;
#line 626
char const   *consys_nme(consys_struct *consys , char cv , int ndx , bool pfx , char *clientbuf ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char const   *consys_prtcontyp(contyp_enum contyp ) 
{ 
  char const   *rtnnme ;

  {
#line 43
  rtnnme = "consys_prtcontyp";
  {
#line 46
  if ((unsigned int )contyp == 4U) {
#line 46
    goto case_4;
  }
#line 48
  if ((unsigned int )contyp == 2U) {
#line 48
    goto case_2;
  }
#line 50
  if ((unsigned int )contyp == 3U) {
#line 50
    goto case_3;
  }
#line 52
  if ((unsigned int )contyp == 1U) {
#line 52
    goto case_1;
  }
#line 54
  if ((unsigned int )contyp == 5U) {
#line 54
    goto case_5;
  }
#line 56
  if ((unsigned int )contyp == 0U) {
#line 56
    goto case_0;
  }
#line 58
  goto switch_default;
  case_4: /* CIL Label */ 
#line 47
  return ("<=");
  case_2: /* CIL Label */ 
#line 49
  return (">=");
  case_3: /* CIL Label */ 
#line 51
  return ("=");
  case_1: /* CIL Label */ 
#line 53
  return ("><");
  case_5: /* CIL Label */ 
#line 55
  return ("<=>");
  case_0: /* CIL Label */ 
#line 57
  return ("invalid");
  switch_default: /* CIL Label */ 
  {
#line 59
  errmsg(5, rtnnme, "contyp", (int )contyp);
  }
#line 60
  return ("unrecognised");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char const   *consys_prtvartyp(vartyp_enum vartyp ) 
{ 
  char const   *rtnnme ;

  {
#line 74
  rtnnme = "consys_prtvartyp";
  {
#line 77
  if ((unsigned int )vartyp == 1U) {
#line 77
    goto case_1;
  }
#line 79
  if ((unsigned int )vartyp == 2U) {
#line 79
    goto case_2;
  }
#line 81
  if ((unsigned int )vartyp == 3U) {
#line 81
    goto case_3;
  }
#line 83
  if ((unsigned int )vartyp == 0U) {
#line 83
    goto case_0;
  }
#line 85
  goto switch_default;
  case_1: /* CIL Label */ 
#line 78
  return ("continuous");
  case_2: /* CIL Label */ 
#line 80
  return ("general integer");
  case_3: /* CIL Label */ 
#line 82
  return ("binary");
  case_0: /* CIL Label */ 
#line 84
  return ("invalid");
  switch_default: /* CIL Label */ 
  {
#line 86
  errmsg(5, rtnnme, "vartyp", (int )vartyp);
  }
#line 87
  return ("unrecognised");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char nmbuf[128]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char *consys_assocnme(consys_struct *consys , flags which ) 
{ 
  int nmlen ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
#line 108
  if ((unsigned long )consys != (unsigned long )((void *)0)) {
    {
#line 109
    nmlen = (int )(sizeof(nmbuf) / 2UL);
#line 110
    dyio_outfxd(nmbuf, - nmlen, (char )'l', "%s", consys->nme);
#line 111
    strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)".");
    }
  } else {
#line 113
    nmbuf[0] = (char )'\000';
  }
  {
#line 114
  tmp = strlen((char const   *)(nmbuf));
#line 114
  nmlen = (int )tmp;
  }
  {
#line 117
  if (which == 1U) {
#line 117
    goto case_1;
  }
#line 120
  if (which == 1U << 13) {
#line 120
    goto case_exp;
  }
#line 123
  if (which == 1U << 12) {
#line 123
    goto case_exp___0;
  }
#line 126
  if (which == 1U << 3) {
#line 126
    goto case_exp___1;
  }
#line 129
  if (which == 1U << 4) {
#line 129
    goto case_exp___2;
  }
#line 132
  if (which == 1U << 5) {
#line 132
    goto case_exp___3;
  }
#line 135
  if (which == 1U << 6) {
#line 135
    goto case_exp___4;
  }
#line 138
  if (which == 1U << 9) {
#line 138
    goto case_exp___5;
  }
#line 141
  if (which == 1U << 7) {
#line 141
    goto case_exp___6;
  }
#line 144
  if (which == 1U << 8) {
#line 144
    goto case_exp___7;
  }
#line 147
  if (which == 1U << 10) {
#line 147
    goto case_exp___8;
  }
#line 150
  if (which == 1U << 11) {
#line 150
    goto case_exp___9;
  }
#line 153
  if (which == 1U << 14) {
#line 153
    goto case_exp___10;
  }
#line 156
  if (which == 1U << 15) {
#line 156
    goto case_exp___11;
  }
#line 159
  if (which == 1U << 2) {
#line 159
    goto case_exp___12;
  }
#line 162
  if (which == 1U << 1) {
#line 162
    goto case_exp___13;
  }
#line 165
  goto switch_default;
  case_1: /* CIL Label */ 
#line 118
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 118
    tmp___0 = "constraint matrix";
  } else {
#line 118
    tmp___0 = "mtx";
  }
  {
#line 118
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___0);
  }
#line 119
  goto switch_break;
  case_exp: /* CIL Label */ 
#line 121
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 121
    tmp___1 = "row header array";
  } else {
#line 121
    tmp___1 = "rowhdr";
  }
  {
#line 121
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___1);
  }
#line 122
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 124
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 124
    tmp___2 = "column header array";
  } else {
#line 124
    tmp___2 = "colhdr";
  }
  {
#line 124
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___2);
  }
#line 125
  goto switch_break;
  case_exp___1: /* CIL Label */ 
#line 127
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 127
    tmp___3 = "objective function";
  } else {
#line 127
    tmp___3 = "obj";
  }
  {
#line 127
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___3);
  }
#line 128
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 130
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 130
    tmp___4 = "variable upper bounds";
  } else {
#line 130
    tmp___4 = "vub";
  }
  {
#line 130
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___4);
  }
#line 131
  goto switch_break;
  case_exp___3: /* CIL Label */ 
#line 133
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 133
    tmp___5 = "variable lower bounds";
  } else {
#line 133
    tmp___5 = "vlb";
  }
  {
#line 133
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___5);
  }
#line 134
  goto switch_break;
  case_exp___4: /* CIL Label */ 
#line 136
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 136
    tmp___6 = "right-hand-side";
  } else {
#line 136
    tmp___6 = "rhs";
  }
  {
#line 136
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___6);
  }
#line 137
  goto switch_break;
  case_exp___5: /* CIL Label */ 
#line 139
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 139
    tmp___7 = "range right-hand-side";
  } else {
#line 139
    tmp___7 = "rhslow";
  }
  {
#line 139
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___7);
  }
#line 140
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 142
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 142
    tmp___8 = "constraint upper bounds";
  } else {
#line 142
    tmp___8 = "cub";
  }
  {
#line 142
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___8);
  }
#line 143
  goto switch_break;
  case_exp___7: /* CIL Label */ 
#line 145
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 145
    tmp___9 = "constraint lower bounds";
  } else {
#line 145
    tmp___9 = "clb";
  }
  {
#line 145
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___9);
  }
#line 146
  goto switch_break;
  case_exp___8: /* CIL Label */ 
#line 148
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 148
    tmp___10 = "variable type";
  } else {
#line 148
    tmp___10 = "vtyp";
  }
  {
#line 148
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___10);
  }
#line 149
  goto switch_break;
  case_exp___9: /* CIL Label */ 
#line 151
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 151
    tmp___11 = "constraint type";
  } else {
#line 151
    tmp___11 = "ctyp";
  }
  {
#line 151
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___11);
  }
#line 152
  goto switch_break;
  case_exp___10: /* CIL Label */ 
#line 154
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 154
    tmp___12 = "row scaling";
  } else {
#line 154
    tmp___12 = "rsc";
  }
  {
#line 154
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___12);
  }
#line 155
  goto switch_break;
  case_exp___11: /* CIL Label */ 
#line 157
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 157
    tmp___13 = "column scaling";
  } else {
#line 157
    tmp___13 = "csc";
  }
  {
#line 157
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___13);
  }
#line 158
  goto switch_break;
  case_exp___12: /* CIL Label */ 
#line 160
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 160
    tmp___14 = "generic column";
  } else {
#line 160
    tmp___14 = "col";
  }
  {
#line 160
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___14);
  }
#line 161
  goto switch_break;
  case_exp___13: /* CIL Label */ 
#line 163
  if ((unsigned long )consys == (unsigned long )((void *)0)) {
#line 163
    tmp___15 = "generic row";
  } else {
#line 163
    tmp___15 = "row";
  }
  {
#line 163
  strcat((char */* __restrict  */)(nmbuf), (char const   */* __restrict  */)tmp___15);
  }
#line 164
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 166
  dyio_outfxd(& nmbuf[nmlen], -26, (char )'l', "<<type error: %#08x>>", (int )which);
  }
#line 167
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 169
  return (nmbuf);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
void consys_chgnme(consys_struct *consys , char cv , int ndx , char const   *newnme ) 
{ 
  rowhdr_struct *rowhdr ;
  colhdr_struct *colhdr ;
  char const   *rtnnme ;

  {
#line 197
  rtnnme = "consys_chgnme";
  {
#line 254
  if ((int )cv == 99) {
#line 254
    goto case_99;
  }
#line 260
  if ((int )cv == 118) {
#line 260
    goto case_118;
  }
#line 266
  if ((int )cv == 111) {
#line 266
    goto case_111;
  }
#line 271
  if ((int )cv == 115) {
#line 271
    goto case_115;
  }
#line 276
  goto switch_default;
  case_99: /* CIL Label */ 
#line 255
  rowhdr = *(consys->mtx.rows + ndx);
#line 256
  if ((unsigned long )rowhdr->nme != (unsigned long )((void *)0)) {
    {
#line 257
    strfree(rowhdr->nme);
    }
  }
  {
#line 258
  rowhdr->nme = stralloc(newnme);
  }
#line 259
  goto switch_break;
  case_118: /* CIL Label */ 
#line 261
  colhdr = *(consys->mtx.cols + ndx);
#line 262
  if ((unsigned long )colhdr->nme != (unsigned long )((void *)0)) {
    {
#line 263
    strfree(colhdr->nme);
    }
  }
  {
#line 264
  colhdr->nme = stralloc(newnme);
  }
#line 265
  goto switch_break;
  case_111: /* CIL Label */ 
#line 267
  if ((unsigned long )consys->objnme != (unsigned long )((void *)0)) {
    {
#line 268
    strfree(consys->objnme);
    }
  }
  {
#line 269
  consys->objnme = stralloc(newnme);
  }
#line 270
  goto switch_break;
  case_115: /* CIL Label */ 
#line 272
  if ((unsigned long )consys->nme != (unsigned long )((void *)0)) {
    {
#line 273
    strfree(consys->nme);
    }
  }
  {
#line 274
  consys->nme = stralloc(newnme);
  }
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 277
  errmsg(1, rtnnme, 277);
  }
#line 278
  return;
  switch_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char ownbuf[32]  ;
#line 283 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char *consys_lognme(consys_struct *consys , int rowndx , char *clientbuf ) 
{ 
  int len ;
  rowhdr_struct *rowhdr ;
  char *nmebuf ;
  size_t tmp ;

  {
#line 339
  if ((unsigned long )clientbuf == (unsigned long )((void *)0)) {
#line 340
    nmebuf = ownbuf;
  } else {
#line 342
    nmebuf = clientbuf;
  }
  {
#line 347
  rowhdr = *(consys->mtx.rows + rowndx);
#line 348
  tmp = strlen(rowhdr->nme);
#line 348
  len = (int )tmp;
  }
#line 349
  if ((unsigned long )len > sizeof(nmebuf) - 5UL) {
#line 349
    len = (int )(sizeof(nmebuf) - 5UL);
  }
  {
#line 350
  strncpy((char */* __restrict  */)nmebuf, (char const   */* __restrict  */)rowhdr->nme,
          (size_t )len);
  }
#line 351
  if ((unsigned long )consys->ctyp != (unsigned long )((void *)0)) {
    {
#line 353
    if ((unsigned int )*(consys->ctyp + rowndx) == 4U) {
#line 353
      goto case_4;
    }
#line 356
    if ((unsigned int )*(consys->ctyp + rowndx) == 3U) {
#line 356
      goto case_3;
    }
#line 359
    if ((unsigned int )*(consys->ctyp + rowndx) == 2U) {
#line 359
      goto case_2;
    }
#line 362
    if ((unsigned int )*(consys->ctyp + rowndx) == 5U) {
#line 362
      goto case_5;
    }
#line 365
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 354
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".slk");
    }
#line 355
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 357
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".art");
    }
#line 358
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 360
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".sur");
    }
#line 361
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 363
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".rng");
    }
#line 364
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 366
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".inv");
    }
#line 367
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 369
    strcpy((char */* __restrict  */)(nmebuf + len), (char const   */* __restrict  */)".log");
    }
  }
#line 371
  return (nmebuf);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char ourbuf[32]  ;
#line 411 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char ourbuftoo[32]  ;
#line 374 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char const   *consys_nme(consys_struct *consys , char cv , int ndx , bool pfx , char *clientbuf ) 
{ 
  char *nmbuf___0 ;
  char const   *rtnbuf ;
  int nmlen ;
  int partlen ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 460
  if ((int )pfx == 0) {
#line 460
    if ((int )cv == 99) {
#line 460
      goto _L___0;
    } else
#line 460
    if ((int )cv == 118) {
#line 460
      if (ndx <= consys->varcnt) {
        _L___0: /* CIL Label */ 
#line 461
        if ((int )cv == 99) {
#line 462
          rtnbuf = (*(consys->mtx.rows + ndx))->nme;
        } else {
#line 464
          rtnbuf = (*(consys->mtx.cols + ndx))->nme;
        }
#line 465
        if ((unsigned long )clientbuf != (unsigned long )((void *)0)) {
          {
#line 466
          tmp = strlen(rtnbuf);
          }
#line 466
          if (tmp < 32UL) {
            {
#line 467
            strcpy((char */* __restrict  */)clientbuf, (char const   */* __restrict  */)rtnbuf);
            }
          } else {
            {
#line 469
            strncpy((char */* __restrict  */)clientbuf, (char const   */* __restrict  */)rtnbuf,
                    (size_t )31);
#line 470
            *(clientbuf + 31) = (char )'\000';
            }
          }
#line 471
          rtnbuf = (char const   *)clientbuf;
        }
      } else {
#line 460
        goto _L;
      }
    } else {
#line 460
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 485
    if ((unsigned long )clientbuf == (unsigned long )((void *)0)) {
#line 486
      nmbuf___0 = ourbuf;
    } else {
#line 488
      nmbuf___0 = clientbuf;
    }
#line 490
    if ((int )pfx == 1) {
      {
#line 491
      tmp___0 = strlen(consys->nme);
#line 491
      nmlen = (int )tmp___0;
      }
#line 492
      if (nmlen > 15) {
#line 492
        nmlen = 15;
      }
      {
#line 493
      strncpy((char */* __restrict  */)nmbuf___0, (char const   */* __restrict  */)consys->nme,
              (size_t )nmlen);
#line 494
      tmp___1 = nmlen;
#line 494
      nmlen ++;
#line 494
      *(nmbuf___0 + tmp___1) = (char )'.';
      }
    } else {
#line 496
      nmlen = 0;
    }
    {
#line 499
    if ((int )cv == 99) {
#line 499
      goto case_99;
    }
#line 510
    if ((int )cv == 118) {
#line 510
      goto case_118;
    }
#line 498
    goto switch_break;
    case_99: /* CIL Label */ 
#line 500
    if ((unsigned long )(*(consys->mtx.rows + ndx))->nme == (unsigned long )((void *)0)) {
      {
#line 501
      strcpy((char */* __restrict  */)(nmbuf___0 + nmlen), (char const   */* __restrict  */)"<<null>>");
      }
    } else {
      {
#line 503
      tmp___2 = strlen((*(consys->mtx.rows + ndx))->nme);
#line 503
      partlen = (int )tmp___2;
      }
#line 504
      if (partlen > (32 - nmlen) - 1) {
#line 505
        partlen = (32 - nmlen) - 1;
      }
      {
#line 506
      strncpy((char */* __restrict  */)(nmbuf___0 + nmlen), (char const   */* __restrict  */)(*(consys->mtx.rows + ndx))->nme,
              (size_t )partlen);
#line 507
      nmlen += partlen;
#line 508
      *(nmbuf___0 + nmlen) = (char )'\000';
      }
    }
#line 509
    goto switch_break;
    case_118: /* CIL Label */ 
#line 511
    if (ndx <= consys->varcnt) {
#line 512
      if ((unsigned long )(*(consys->mtx.cols + ndx))->nme == (unsigned long )((void *)0)) {
        {
#line 513
        strcpy((char */* __restrict  */)(nmbuf___0 + nmlen), (char const   */* __restrict  */)"<<null>>");
        }
      } else {
        {
#line 515
        tmp___3 = strlen((*(consys->mtx.cols + ndx))->nme);
#line 515
        partlen = (int )tmp___3;
        }
#line 516
        if (partlen > (32 - nmlen) - 1) {
#line 517
          partlen = (32 - nmlen) - 1;
        }
        {
#line 518
        strncpy((char */* __restrict  */)(nmbuf___0 + nmlen), (char const   */* __restrict  */)(*(consys->mtx.cols + ndx))->nme,
                (size_t )partlen);
#line 519
        nmlen += partlen;
#line 520
        *(nmbuf___0 + nmlen) = (char )'\000';
        }
      }
    } else {
      {
#line 522
      consys_lognme(consys, ndx - consys->varcnt, ourbuftoo);
#line 523
      tmp___4 = strlen((char const   *)(ourbuftoo));
#line 523
      partlen = (int )tmp___4;
      }
#line 524
      if (partlen > (32 - nmlen) - 1) {
#line 525
        partlen = (32 - nmlen) - 1;
      }
      {
#line 526
      strncpy((char */* __restrict  */)(nmbuf___0 + nmlen), (char const   */* __restrict  */)(ourbuftoo),
              (size_t )partlen);
#line 527
      nmlen += partlen;
#line 528
      *(nmbuf___0 + nmlen) = (char )'\000';
      }
    }
#line 530
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 531
    rtnbuf = (char const   *)nmbuf___0;
  }
#line 533
  return (rtnbuf);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char buf[32]  ;
#line 541 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char *consys_conbndnme(char bndlett , int cndx , conbnd_struct *bnd ) 
{ 
  char *bufptr ;
  int tmp ;

  {
  {
#line 565
  bufptr = & buf[0];
#line 566
  tmp = dyio_outfxd(bufptr, - ((int )(sizeof(buf) / 2UL - 1UL)), (char )'l', "%cB(%d",
                    (int )bndlett, cndx);
#line 566
  bufptr += tmp;
  }
#line 568
  if (bnd->inf < 0) {
    {
#line 569
    dyio_outfxd(bufptr, - ((int )(sizeof(buf) / 2UL - 1UL)), (char )'l', "\\%d)",
                - bnd->inf);
    }
  } else {
    {
#line 571
    dyio_outfxd(bufptr, -1, (char )'l', ")");
    }
  }
#line 573
  return (& buf[0]);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
static char buf___0[32]  ;
#line 576 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
char *consys_conbndval(conbnd_struct *bnd ) 
{ 
  char *bufptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 595
  bufptr = & buf___0[0];
#line 596
  if (bnd->inf > 0) {
    {
#line 597
    tmp = dyio_outfxd(bufptr, - ((int )(sizeof(buf___0) / 2UL - 1UL)), (char )'l',
                      "%d*inf+", bnd->inf);
#line 597
    bufptr += tmp;
    }
  } else
#line 600
  if (bnd->inf < 0) {
    {
#line 601
    tmp___0 = dyio_outfxd(bufptr, - ((int )(sizeof(buf___0) / 2UL - 1UL)), (char )'l',
                          "inf+");
#line 601
    bufptr += tmp___0;
    }
  }
  {
#line 603
  dyio_outfxd(bufptr, - ((int )(sizeof(buf___0) / 2UL - 1UL)), (char )'l', "%g", bnd->bnd);
  }
#line 605
  return (& buf___0[0]);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_io.c"
void consys_prtcon(ioid chn , bool echo , consys_struct *consys , int i , char const   *pfx ) 
{ 
  int linecnt ;
  int charcnt ;
  int ndx ;
  contyp_enum ctypi ;
  pkvec_struct *coni ;
  pkcoeff_struct *ai ;
  char buf___1[64] ;
  char const   *rtnnme ;
  char const   *errstring ;
  char const   *dfltpfx ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 638
  rtnnme = "consys_prtcon";
#line 638
  errstring = "<< !consys_prtcon print error! >>";
#line 638
  dfltpfx = "";
#line 654
  if ((unsigned long )pfx == (unsigned long )((void *)0)) {
#line 654
    pfx = dfltpfx;
  }
  {
#line 658
  ctypi = *(consys->ctyp + i);
#line 659
  dyio_outfmt(chn, echo, "\n%s", pfx);
  }
#line 660
  if ((unsigned int )ctypi == 5U) {
    {
#line 661
    dyio_outfmt(chn, echo, "%g <= ", *(consys->rhslow + i));
    }
  }
  {
#line 662
  tmp = consys_prtcontyp(ctypi);
#line 662
  tmp___0 = consys_nme(consys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 662
  dyio_outfmt(chn, echo, "%s (%d) %s %g", tmp___0, i, tmp, *(consys->rhs + i));
#line 672
  coni = (pkvec_struct *)((void *)0);
#line 673
  tmp___2 = consys_getrow_pk(consys, i, & coni);
  }
#line 673
  if ((int )tmp___2 == 0) {
    {
#line 674
    tmp___1 = consys_nme(consys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 674
    errmsg(122, rtnnme, consys->nme, "constraint", tmp___1, i);
#line 676
    dyio_outfmt(chn, echo, errstring);
    }
#line 677
    if ((unsigned long )coni != (unsigned long )((void *)0)) {
      {
#line 677
      pkvec_free(coni);
      }
    }
#line 678
    return;
  }
#line 680
  ai = coni->coeffs;
#line 681
  linecnt = 0;
#line 682
  ndx = 0;
  {
#line 682
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    if (! (ndx < coni->cnt)) {
#line 682
      goto while_break;
    }
#line 683
    if (linecnt == 0) {
      {
#line 684
      tmp___3 = consys_nme(consys, (char )'v', (ai + ndx)->ndx, (bool )0, (char *)((void *)0));
#line 684
      charcnt = dyio_outfxd(& buf___1[0], -60, (char )'l', "\n%s  % g %s(%d)", pfx,
                            (ai + ndx)->val, tmp___3, (ai + ndx)->ndx);
      }
    } else {
      {
#line 688
      tmp___4 = consys_nme(consys, (char )'v', (ai + ndx)->ndx, (bool )0, (char *)((void *)0));
#line 688
      charcnt = dyio_outfxd(& buf___1[0], -60, (char )'l', " %+g %s(%d)", (ai + ndx)->val,
                            tmp___4, (ai + ndx)->ndx);
      }
    }
#line 691
    if (linecnt + charcnt < 70) {
      {
#line 692
      dyio_outfmt(chn, echo, "%s", & buf___1[0]);
#line 693
      linecnt += charcnt;
      }
    } else {
#line 695
      ndx --;
#line 696
      linecnt = 0;
    }
#line 682
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 697
  pkvec_free(coni);
  }
#line 699
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 30 "./../DylpStdLib/dylib_errs.h"
void warn(int errid  , ...) ;
#line 99 "./../DylpStdLib/dylib_io.h"
void dyio_outchr(ioid id , bool echo , char chr ) ;
#line 181 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 516 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_getcol_pk(consys_struct *consys , int colndx , pkvec_struct **pkvec ) ;
#line 548
double consys_dotcol(consys_struct *consys , int colndx , double *vec ) ;
#line 1388 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
extern ioid dy_logchn ;
#line 1389
extern bool dy_gtxecho ;
#line 1704
lp_struct *dy_lp ;
#line 1705
consys_struct *dy_sys ;
#line 1706
lptols_struct *dy_tols ;
#line 1707
lpopts_struct *dy_opts ;
#line 1708
int *dy_basis ;
#line 1708
int *dy_degenset ;
#line 1708
int *dy_ddegenset ;
#line 1711
flags *dy_status ;
#line 1712
double *dy_x ;
#line 1712
double *dy_xbasic ;
#line 1712
double *dy_y ;
#line 1712
double *dy_cbar ;
#line 1750
dyret_enum dy_factor(flags *calcflgs ) ;
#line 1754
bool dy_setpivparms(int curdelta , int mindelta ) ;
#line 1755
char *dy_prtpivparms(int lvl ) ;
#line 1795
dyret_enum dy_degenout(int level___0 ) ;
#line 1804
dyret_enum dy_duenna(dyret_enum pivresult , int xjndx , int xindx , int xjcand , int xicand ) ;
#line 1804
dyret_enum dy_accchk(flags *checks ) ;
#line 1812
dyret_enum dy_addtopivrej(int j , dyret_enum why , double abarij , double maxabarij ) ;
#line 1812
dyret_enum dy_dealWithPunt(void) ;
#line 1815
bool dy_clrpivrej(int *entries ) ;
#line 1816
void dy_checkpivtol(void) ;
#line 1871
bool dy_reducerhs(double *rhs , bool init ) ;
#line 1871
bool dy_calcprimals(void) ;
#line 1875
double dy_calcobj(void) ;
#line 1875
double dy_calcdualobj(void) ;
#line 1875
double dy_calcpinfeas(void) ;
#line 1957
char const   *dy_prtlpphase(dyphase_enum phase , bool abbrv ) ;
#line 1959
char *dy_prtvstat(flags status ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_duenna.c"
static bool groombasis(void) 
{ 
  int i ;
  int ipos ;
  int staterrs ;
  double xi ;
  double *vlb ;
  double vlbi ;
  double *vub ;
  double vubi ;
  double tol ;
  flags stati ;
  flags newstati ;
  flags quali ;
  char statbuf[32] ;
  bool retval ;
  bool statok ;
  bool backout ;
  char const   *rtnnme ;
  int print ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___28 ;
  int tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___35 ;
  int tmp___36 ;
  double tmp___37 ;
  double tmp___38 ;
  double tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  double tmp___42 ;
  double tmp___44 ;
  int tmp___45 ;
  double tmp___46 ;
  double tmp___47 ;
  double tmp___48 ;
  double tmp___49 ;
  double tmp___50 ;
  double tmp___51 ;
  double tmp___52 ;
  double tmp___53 ;
  double tmp___54 ;
  double tmp___55 ;
  double tmp___56 ;
  double tmp___57 ;
  double tmp___58 ;
  double tmp___59 ;
  double tmp___61 ;
  int tmp___62 ;
  double tmp___63 ;
  double tmp___65 ;
  int tmp___66 ;
  double tmp___67 ;
  double tmp___68 ;
  double tmp___69 ;
  double tmp___70 ;
  double tmp___71 ;
  double tmp___72 ;
  double tmp___74 ;
  int tmp___75 ;
  double tmp___76 ;
  double tmp___77 ;
  double tmp___78 ;
  double tmp___79 ;
  double tmp___80 ;
  double tmp___81 ;
  double tmp___82 ;
  double tmp___83 ;
  double tmp___84 ;
  double tmp___85 ;
  double tmp___86 ;
  double tmp___87 ;
  double tmp___89 ;
  int tmp___90 ;
  double tmp___91 ;
  double tmp___92 ;
  double tmp___93 ;
  double tmp___94 ;
  double tmp___96 ;
  int tmp___97 ;
  double tmp___98 ;
  double tmp___99 ;
  double tmp___100 ;
  double tmp___101 ;
  double tmp___102 ;
  double tmp___103 ;
  char *tmp___104 ;
  char const   *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  double tmp___108 ;
  char *tmp___109 ;
  char const   *tmp___110 ;
  char const   *tmp___111 ;
  double tmp___112 ;
  char *tmp___113 ;
  char const   *tmp___114 ;
  char const   *tmp___115 ;
  double tmp___116 ;
  double tmp___117 ;
  double tmp___118 ;
  char *tmp___119 ;
  char const   *tmp___120 ;
  char const   *tmp___121 ;
  double tmp___122 ;
  char *tmp___123 ;
  char const   *tmp___124 ;
  char const   *tmp___125 ;
  double tmp___126 ;
  double tmp___127 ;
  char const   *tmp___128 ;

  {
#line 88
  rtnnme = "groombasis";
  {
#line 96
  if ((unsigned int )dy_lp->phase == 2U) {
#line 96
    goto case_2;
  }
#line 99
  if ((unsigned int )dy_lp->phase == 3U) {
#line 99
    goto case_3;
  }
#line 102
  if ((unsigned int )dy_lp->phase == 4U) {
#line 102
    goto case_4;
  }
#line 105
  if ((unsigned int )dy_lp->phase == 10U) {
#line 105
    goto case_10;
  }
#line 110
  if ((unsigned int )dy_lp->phase == 13U) {
#line 110
    goto case_13;
  }
#line 110
  if ((unsigned int )dy_lp->phase == 12U) {
#line 110
    goto case_13;
  }
#line 110
  if ((unsigned int )dy_lp->phase == 11U) {
#line 110
    goto case_13;
  }
#line 113
  goto switch_default;
  case_2: /* CIL Label */ 
#line 97
  print = dy_opts->print.phase1;
#line 98
  goto switch_break;
  case_3: /* CIL Label */ 
#line 100
  print = dy_opts->print.phase2;
#line 101
  goto switch_break;
  case_4: /* CIL Label */ 
#line 103
  print = dy_opts->print.phase2;
#line 104
  goto switch_break;
  case_10: /* CIL Label */ 
#line 106
  print = dy_opts->print.conmgmt;
#line 107
  goto switch_break;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 111
  if (dy_opts->print.conmgmt > dy_opts->print.varmgmt) {
#line 111
    print = dy_opts->print.conmgmt;
  } else {
#line 111
    print = dy_opts->print.varmgmt;
  }
#line 112
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 114
  errmsg(1, rtnnme, 114);
  }
#line 115
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 118
  vlb = dy_sys->vlb;
#line 119
  vub = dy_sys->vub;
#line 120
  tol = (dy_tols->pfeas * dy_tols->bogus) * 1.0e05;
#line 121
  backout = (bool )0;
#line 122
  retval = (bool )1;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    staterrs = 0;
#line 130
    ipos = 1;
    {
#line 130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 130
      if (! (ipos <= dy_sys->concnt)) {
#line 130
        goto while_break___0;
      }
#line 131
      i = *(dy_basis + ipos);
#line 132
      stati = *(dy_status + i) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 133
      quali = *(dy_status + i) & (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
#line 134
      vlbi = *(vlb + i);
#line 135
      vubi = *(vub + i);
#line 136
      statok = (bool )1;
#line 148
      if (dy_lp->degen > 0) {
#line 148
        if ((unsigned int )dy_lp->phase == 2U) {
#line 148
          goto _L___1;
        } else
#line 148
        if ((unsigned int )dy_lp->phase == 3U) {
          _L___1: /* CIL Label */ 
#line 150
          xi = *(dy_x + i);
#line 151
          if (*(dy_degenset + ipos) > 0) {
            {
#line 162
            tmp___3 = fabs(vlbi);
            }
#line 162
            if (tmp___3 < dy_tols->inf) {
              {
#line 162
              tmp___4 = fabs(xi - vlbi);
#line 162
              tmp___5 = fabs(vlbi);
              }
#line 162
              if (! (tmp___4 < dy_tols->pfeas * (1.0 + tmp___5))) {
#line 162
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 165
              tmp___0 = fabs(vubi);
              }
#line 165
              if (tmp___0 < dy_tols->inf) {
                {
#line 165
                tmp___1 = fabs(xi - vubi);
#line 165
                tmp___2 = fabs(vubi);
                }
#line 165
                if (! (tmp___1 < dy_tols->pfeas * (1.0 + tmp___2))) {
#line 165
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 168
                if (stati & (unsigned int )(1 << 4)) {
#line 168
                  tmp = 0;
                } else {
#line 168
                  tmp = 1;
                }
#line 168
                if (tmp) {
#line 169
                  backout = (bool )1;
                }
              }
            }
          } else {
            {
#line 171
            tmp___6 = fabs(xi);
            }
#line 171
            if (tmp___6 < dy_tols->inf) {
              {
#line 171
              tmp___7 = fabs(*(dy_xbasic + ipos) - xi);
#line 171
              tmp___8 = fabs(xi);
              }
#line 171
              if (! (tmp___7 < dy_tols->pfeas * (1.0 + tmp___8))) {
#line 174
                backout = (bool )1;
              }
            } else {
#line 174
              backout = (bool )1;
            }
          }
#line 175
          if ((int )backout == 1) {
#line 178
            if (print >= 1) {
              {
#line 179
              tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 179
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tbacking out antidegeneracy at (%s)%d due to accumulated",
                          tmp___9, dy_lp->tot.iters);
#line 182
              tmp___10 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 182
              dyio_outfmt(dy_logchn, dy_gtxecho, " error;\n\ttrue %s (%d) = %g ;",
                          tmp___10, i, xi);
              }
#line 184
              if (*(dy_degenset + ipos) > 0) {
                {
#line 185
                tmp___15 = fabs(xi - vlbi);
#line 185
                tmp___16 = fabs(xi - vubi);
                }
#line 185
                if (tmp___15 < tmp___16) {
                  {
#line 186
                  tmp___11 = fabs(vlbi);
#line 186
                  tmp___12 = fabs(xi - vlbi);
#line 186
                  dyio_outfmt(dy_logchn, dy_gtxecho, " lb = %g ; |x-lb| = %g, tol %g.",
                              vlbi, tmp___12, dy_tols->zero * ((double )1 + tmp___11));
                  }
                } else {
                  {
#line 191
                  tmp___13 = fabs(vubi);
#line 191
                  tmp___14 = fabs(xi - vubi);
#line 191
                  dyio_outfmt(dy_logchn, dy_gtxecho, " ub = %g ; |x-ub| = %g, tol %g.",
                              vubi, tmp___14, dy_tols->zero * ((double )1 + tmp___13));
                  }
                }
              } else {
                {
#line 196
                tmp___17 = fabs(xi);
#line 196
                tmp___18 = fabs(xi - *(dy_xbasic + ipos));
#line 196
                dyio_outfmt(dy_logchn, dy_gtxecho, "xbasic = %g ; |x-xbasic| = %g, tol %g.",
                            *(dy_xbasic + ipos), tmp___18, dy_tols->zero * ((double )1 + tmp___17));
                }
              }
            }
            {
#line 201
            dy_degenout(0);
            }
#line 202
            goto while_break___0;
          }
        }
      }
#line 206
      xi = *(dy_xbasic + ipos);
#line 207
      newstati = stati;
      {
#line 209
      if (stati == (flags )(1 << 11)) {
#line 209
        goto case_exp;
      }
#line 228
      if (stati == (flags )(1 << 3)) {
#line 228
        goto case_exp___0;
      }
#line 245
      if (stati == (flags )(1 << 2)) {
#line 245
        goto case_exp___1;
      }
#line 262
      if (stati == (flags )(1 << 1)) {
#line 262
        goto case_exp___2;
      }
#line 279
      if (stati == (flags )(1 << 10)) {
#line 279
        goto case_exp___3;
      }
#line 298
      if (stati == 1U) {
#line 298
        goto case_1;
      }
#line 308
      if (stati == (flags )(1 << 4)) {
#line 308
        goto case_exp___4;
      }
#line 208
      goto switch_break___0;
      case_exp: /* CIL Label */ 
      {
#line 210
      tmp___37 = fabs(vlbi);
      }
#line 210
      if (tmp___37 < dy_tols->inf) {
        {
#line 210
        tmp___35 = fabs(vlbi);
#line 210
        tmp___36 = vlbi - xi > dy_tols->pfeas * (1.0 + tmp___35);
        }
      } else {
#line 210
        tmp___36 = xi < vlbi;
      }
#line 210
      if (! tmp___36) {
        {
#line 211
        tmp___19 = fabs(xi - vlbi);
#line 211
        tmp___20 = fabs(vlbi);
        }
#line 211
        if (! (tmp___19 <= tol * (1.0 + tmp___20))) {
#line 211
          statok = (bool )0;
        }
        {
#line 212
        tmp___31 = fabs(vlbi);
        }
#line 212
        if (tmp___31 < dy_tols->inf) {
          {
#line 212
          tmp___32 = fabs(xi - vlbi);
#line 212
          tmp___33 = fabs(vlbi);
          }
#line 212
          if (tmp___32 < dy_tols->pfeas * (1.0 + tmp___33)) {
            {
#line 213
            tmp___21 = fabs(vubi);
            }
#line 213
            if (tmp___21 < dy_tols->inf) {
              {
#line 213
              tmp___22 = fabs(vlbi - vubi);
#line 213
              tmp___23 = fabs(vubi);
              }
#line 213
              if (tmp___22 < dy_tols->pfeas * (1.0 + tmp___23)) {
#line 214
                newstati = (flags )1;
              } else {
#line 216
                newstati = (flags )(1 << 3);
              }
            } else {
#line 216
              newstati = (flags )(1 << 3);
            }
          } else {
#line 212
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 219
          tmp___30 = fabs(vubi);
          }
#line 219
          if (tmp___30 < dy_tols->inf) {
            {
#line 219
            tmp___28 = fabs(vubi);
#line 219
            tmp___29 = vubi - xi > dy_tols->pfeas * (1.0 + tmp___28);
            }
          } else {
#line 219
            tmp___29 = xi < vubi;
          }
#line 219
          if (tmp___29) {
#line 220
            newstati = (flags )(1 << 2);
          } else {
            {
#line 222
            tmp___24 = fabs(vubi);
            }
#line 222
            if (tmp___24 < dy_tols->inf) {
              {
#line 222
              tmp___25 = fabs(xi - vubi);
#line 222
              tmp___26 = fabs(vubi);
              }
#line 222
              if (tmp___25 < dy_tols->pfeas * (1.0 + tmp___26)) {
#line 223
                newstati = (flags )(1 << 1);
              } else {
#line 226
                newstati = (flags )(1 << 10);
              }
            } else {
#line 226
              newstati = (flags )(1 << 10);
            }
          }
        }
      }
#line 227
      goto switch_break___0;
      case_exp___0: /* CIL Label */ 
      {
#line 229
      tmp___47 = fabs(vlbi);
      }
#line 229
      if (tmp___47 < dy_tols->inf) {
        {
#line 229
        tmp___48 = fabs(xi - vlbi);
#line 229
        tmp___49 = fabs(vlbi);
        }
#line 229
        if (! (tmp___48 < dy_tols->pfeas * (1.0 + tmp___49))) {
#line 229
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
#line 230
        tmp___38 = fabs(xi - vlbi);
#line 230
        tmp___39 = fabs(vlbi);
        }
#line 230
        if (! (tmp___38 <= tol * (1.0 + tmp___39))) {
#line 230
          statok = (bool )0;
        }
#line 231
        if (xi < vlbi) {
#line 232
          newstati = (flags )(1 << 11);
        } else {
          {
#line 234
          tmp___46 = fabs(vubi);
          }
#line 234
          if (tmp___46 < dy_tols->inf) {
            {
#line 234
            tmp___44 = fabs(vubi);
#line 234
            tmp___45 = vubi - xi > dy_tols->pfeas * (1.0 + tmp___44);
            }
          } else {
#line 234
            tmp___45 = xi < vubi;
          }
#line 234
          if (tmp___45) {
#line 235
            newstati = (flags )(1 << 2);
          } else {
            {
#line 237
            tmp___40 = fabs(vubi);
            }
#line 237
            if (tmp___40 < dy_tols->inf) {
              {
#line 237
              tmp___41 = fabs(xi - vubi);
#line 237
              tmp___42 = fabs(vubi);
              }
#line 237
              if (tmp___41 < dy_tols->pfeas * (1.0 + tmp___42)) {
#line 238
                newstati = (flags )(1 << 1);
              } else {
#line 241
                newstati = (flags )(1 << 10);
              }
            } else {
#line 241
              newstati = (flags )(1 << 10);
            }
          }
        }
      }
#line 244
      goto switch_break___0;
      case_exp___1: /* CIL Label */ 
      {
#line 246
      tmp___63 = fabs(vlbi);
      }
#line 246
      if (tmp___63 < dy_tols->inf) {
        {
#line 246
        tmp___61 = fabs(vlbi);
#line 246
        tmp___62 = xi - vlbi > dy_tols->pfeas * (1.0 + tmp___61);
        }
      } else {
#line 246
        tmp___62 = xi > vlbi;
      }
#line 246
      if (tmp___62) {
        {
#line 246
        tmp___67 = fabs(vubi);
        }
#line 246
        if (tmp___67 < dy_tols->inf) {
          {
#line 246
          tmp___65 = fabs(vubi);
#line 246
          tmp___66 = vubi - xi > dy_tols->pfeas * (1.0 + tmp___65);
          }
        } else {
#line 246
          tmp___66 = xi < vubi;
        }
#line 246
        if (! tmp___66) {
#line 246
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
        {
#line 247
        tmp___57 = fabs(vlbi);
        }
#line 247
        if (tmp___57 < dy_tols->inf) {
          {
#line 247
          tmp___58 = fabs(xi - vlbi);
#line 247
          tmp___59 = fabs(vlbi);
          }
#line 247
          if (tmp___58 < dy_tols->pfeas * (1.0 + tmp___59)) {
#line 248
            newstati = (flags )(1 << 3);
          } else {
#line 247
            goto _L___5;
          }
        } else {
          _L___5: /* CIL Label */ 
          {
#line 251
          tmp___54 = fabs(vubi);
          }
#line 251
          if (tmp___54 < dy_tols->inf) {
            {
#line 251
            tmp___55 = fabs(xi - vubi);
#line 251
            tmp___56 = fabs(vubi);
            }
#line 251
            if (tmp___55 < dy_tols->pfeas * (1.0 + tmp___56)) {
#line 252
              newstati = (flags )(1 << 1);
            } else {
#line 251
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 255
          if (xi > vubi) {
            {
#line 256
            tmp___50 = fabs(xi - vubi);
#line 256
            tmp___51 = fabs(vlbi);
            }
#line 256
            if (! (tmp___50 <= tol * (1.0 + tmp___51))) {
#line 256
              statok = (bool )0;
            }
#line 257
            newstati = (flags )(1 << 10);
          } else {
            {
#line 259
            tmp___52 = fabs(xi - vlbi);
#line 259
            tmp___53 = fabs(vlbi);
            }
#line 259
            if (! (tmp___52 <= tol * (1.0 + tmp___53))) {
#line 259
              statok = (bool )0;
            }
#line 260
            newstati = (flags )(1 << 11);
          }
        }
      }
#line 261
      goto switch_break___0;
      case_exp___2: /* CIL Label */ 
      {
#line 263
      tmp___77 = fabs(vubi);
      }
#line 263
      if (tmp___77 < dy_tols->inf) {
        {
#line 263
        tmp___78 = fabs(xi - vubi);
#line 263
        tmp___79 = fabs(vubi);
        }
#line 263
        if (! (tmp___78 < dy_tols->pfeas * (1.0 + tmp___79))) {
#line 263
          goto _L___7;
        }
      } else {
        _L___7: /* CIL Label */ 
        {
#line 264
        tmp___68 = fabs(xi - vubi);
#line 264
        tmp___69 = fabs(vubi);
        }
#line 264
        if (! (tmp___68 <= tol * (1.0 + tmp___69))) {
#line 264
          statok = (bool )0;
        }
#line 265
        if (xi > vubi) {
#line 266
          newstati = (flags )(1 << 10);
        } else {
          {
#line 268
          tmp___76 = fabs(vlbi);
          }
#line 268
          if (tmp___76 < dy_tols->inf) {
            {
#line 268
            tmp___74 = fabs(vlbi);
#line 268
            tmp___75 = xi - vlbi > dy_tols->pfeas * (1.0 + tmp___74);
            }
          } else {
#line 268
            tmp___75 = xi > vlbi;
          }
#line 268
          if (tmp___75) {
#line 269
            newstati = (flags )(1 << 2);
          } else {
            {
#line 271
            tmp___70 = fabs(vlbi);
            }
#line 271
            if (tmp___70 < dy_tols->inf) {
              {
#line 271
              tmp___71 = fabs(xi - vlbi);
#line 271
              tmp___72 = fabs(vlbi);
              }
#line 271
              if (tmp___71 < dy_tols->pfeas * (1.0 + tmp___72)) {
#line 272
                newstati = (flags )(1 << 3);
              } else {
#line 275
                newstati = (flags )(1 << 11);
              }
            } else {
#line 275
              newstati = (flags )(1 << 11);
            }
          }
        }
      }
#line 278
      goto switch_break___0;
      case_exp___3: /* CIL Label */ 
      {
#line 280
      tmp___98 = fabs(vubi);
      }
#line 280
      if (tmp___98 < dy_tols->inf) {
        {
#line 280
        tmp___96 = fabs(vubi);
#line 280
        tmp___97 = xi - vubi > dy_tols->pfeas * (1.0 + tmp___96);
        }
      } else {
#line 280
        tmp___97 = xi > vubi;
      }
#line 280
      if (! tmp___97) {
        {
#line 281
        tmp___80 = fabs(xi - vubi);
#line 281
        tmp___81 = fabs(vubi);
        }
#line 281
        if (! (tmp___80 <= tol * (1.0 + tmp___81))) {
#line 281
          statok = (bool )0;
        }
        {
#line 282
        tmp___92 = fabs(vubi);
        }
#line 282
        if (tmp___92 < dy_tols->inf) {
          {
#line 282
          tmp___93 = fabs(xi - vubi);
#line 282
          tmp___94 = fabs(vubi);
          }
#line 282
          if (tmp___93 < dy_tols->pfeas * (1.0 + tmp___94)) {
            {
#line 283
            tmp___82 = fabs(vubi);
            }
#line 283
            if (tmp___82 < dy_tols->inf) {
              {
#line 283
              tmp___83 = fabs(vlbi - vubi);
#line 283
              tmp___84 = fabs(vubi);
              }
#line 283
              if (tmp___83 < dy_tols->pfeas * (1.0 + tmp___84)) {
#line 284
                newstati = (flags )1;
              } else {
#line 286
                newstati = (flags )(1 << 1);
              }
            } else {
#line 286
              newstati = (flags )(1 << 1);
            }
          } else {
#line 282
            goto _L___8;
          }
        } else {
          _L___8: /* CIL Label */ 
          {
#line 289
          tmp___91 = fabs(vlbi);
          }
#line 289
          if (tmp___91 < dy_tols->inf) {
            {
#line 289
            tmp___89 = fabs(vlbi);
#line 289
            tmp___90 = xi - vlbi > dy_tols->pfeas * (1.0 + tmp___89);
            }
          } else {
#line 289
            tmp___90 = xi > vlbi;
          }
#line 289
          if (tmp___90) {
#line 290
            newstati = (flags )(1 << 2);
          } else {
            {
#line 292
            tmp___85 = fabs(vlbi);
            }
#line 292
            if (tmp___85 < dy_tols->inf) {
              {
#line 292
              tmp___86 = fabs(xi - vlbi);
#line 292
              tmp___87 = fabs(vlbi);
              }
#line 292
              if (tmp___86 < dy_tols->pfeas * (1.0 + tmp___87)) {
#line 293
                newstati = (flags )(1 << 3);
              } else {
#line 296
                newstati = (flags )(1 << 11);
              }
            } else {
#line 296
              newstati = (flags )(1 << 11);
            }
          }
        }
      }
#line 297
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 299
      tmp___101 = fabs(vubi);
      }
#line 299
      if (tmp___101 < dy_tols->inf) {
        {
#line 299
        tmp___102 = fabs(xi - vubi);
#line 299
        tmp___103 = fabs(vubi);
        }
#line 299
        if (! (tmp___102 < dy_tols->pfeas * (1.0 + tmp___103))) {
#line 299
          goto _L___9;
        }
      } else {
        _L___9: /* CIL Label */ 
        {
#line 300
        tmp___99 = fabs(xi - vubi);
#line 300
        tmp___100 = fabs(vubi);
        }
#line 300
        if (! (tmp___99 <= tol * (1.0 + tmp___100))) {
#line 300
          statok = (bool )0;
        }
#line 301
        if (xi > vubi) {
#line 302
          newstati = (flags )(1 << 10);
        } else {
#line 304
          newstati = (flags )(1 << 11);
        }
      }
#line 307
      goto switch_break___0;
      case_exp___4: /* CIL Label */ 
#line 309
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 322
      newstati |= quali;
#line 323
      *(dy_status + i) = newstati;
#line 325
      if ((int )statok == 1) {
#line 325
        if (print >= 3) {
#line 325
          if (stati != (newstati & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8))))) {
            {
#line 327
            stati |= quali;
#line 328
            tmp___104 = dy_prtvstat(stati);
#line 328
            tmp___105 = consys_nme(dy_sys, (char )'v', i, (bool )1, (char *)((void *)0));
#line 328
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n      status of %s (%d) corrected from %s",
                        tmp___105, i, tmp___104);
#line 331
            tmp___106 = dy_prtvstat(newstati);
#line 331
            dyio_outfmt(dy_logchn, dy_gtxecho, " to %s.", tmp___106);
            }
          }
        }
      }
#line 334
      if ((int )statok == 0) {
        {
#line 335
        staterrs ++;
#line 336
        stati |= quali;
#line 337
        tmp___107 = dy_prtvstat(stati);
#line 337
        strcpy((char */* __restrict  */)(statbuf), (char const   */* __restrict  */)tmp___107);
        }
        {
#line 339
        if (dy_opts->groom == 0) {
#line 339
          goto case_0;
        }
#line 340
        if (dy_opts->groom == 1) {
#line 340
          goto case_1___0;
        }
#line 352
        goto switch_default___0;
        case_0: /* CIL Label */ 
#line 339
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        {
#line 341
        tmp___116 = fabs(vubi - xi);
#line 341
        tmp___117 = fabs(vlbi - xi);
        }
#line 341
        if (tmp___116 < tmp___117) {
          {
#line 342
          tmp___108 = fabs(vubi);
#line 342
          tmp___109 = dy_prtvstat(newstati);
#line 342
          tmp___110 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 342
          tmp___111 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 342
          warn(372, rtnnme, dy_sys->nme, tmp___111, dy_lp->tot.iters, tmp___110, i,
               statbuf, tmp___109, vlbi, xi, vubi, "ub", xi - vubi, tol * ((double )1 + tmp___108));
          }
        } else {
          {
#line 347
          tmp___112 = fabs(vlbi);
#line 347
          tmp___113 = dy_prtvstat(newstati);
#line 347
          tmp___114 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 347
          tmp___115 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 347
          warn(372, rtnnme, dy_sys->nme, tmp___115, dy_lp->tot.iters, tmp___114, i,
               statbuf, tmp___113, vlbi, xi, vubi, "lb", xi - vlbi, tol * ((double )1 + tmp___112));
          }
        }
#line 351
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
        {
#line 353
        tmp___126 = fabs(vubi - xi);
#line 353
        tmp___127 = fabs(vlbi - xi);
        }
#line 353
        if (tmp___126 < tmp___127) {
          {
#line 354
          tmp___118 = fabs(vubi);
#line 354
          tmp___119 = dy_prtvstat(newstati);
#line 354
          tmp___120 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 354
          tmp___121 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 354
          errmsg(372, rtnnme, dy_sys->nme, tmp___121, dy_lp->tot.iters, tmp___120,
                 i, statbuf, tmp___119, vlbi, xi, vubi, "ub", xi - vubi, tol * ((double )1 + tmp___118));
          }
        } else {
          {
#line 359
          tmp___122 = fabs(vlbi);
#line 359
          tmp___123 = dy_prtvstat(newstati);
#line 359
          tmp___124 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 359
          tmp___125 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 359
          errmsg(372, rtnnme, dy_sys->nme, tmp___125, dy_lp->tot.iters, tmp___124,
                 i, statbuf, tmp___123, vlbi, xi, vubi, "lb", xi - vlbi, tol * ((double )1 + tmp___122));
          }
        }
#line 363
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 130
      ipos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 368
    if (ipos > dy_sys->concnt) {
#line 368
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (print >= 1) {
#line 379
    if (staterrs > 0) {
      {
#line 380
      tmp___128 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 380
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %d major status corrections",
                  tmp___128, dy_lp->tot.iters, staterrs);
      }
    }
  }
#line 385
  if (staterrs > 0) {
#line 386
    if (dy_opts->groom >= 2) {
#line 387
      retval = (bool )0;
    } else {
      {
#line 389
      dy_setpivparms(1, 0);
      }
    }
  }
#line 391
  return (retval);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_duenna.c"
dyret_enum dy_accchk(flags *checks ) 
{ 
  int xkpos ;
  int xkndx ;
  int pkndx ;
  int cndx ;
  int pfeascnt ;
  int refactorcnt ;
  double *primalerrs ;
  double normb ;
  double normc ;
  double dualresid ;
  double primalresid ;
  double cbarj ;
  double pinfeas ;
  pkvec_struct *pkcol ;
  flags results ;
  flags vstat ;
  flags factorflags ;
  bool dorefactor ;
  bool tryagain ;
  bool dualDegen ;
  dyret_enum factorresult ;
  char const   *rtnnme ;
  int print ;
  int dfeascnt ;
  double *dualerrs ;
  double avgerr ;
  double *dfeaserrs ;
  double dinfeas ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  int tmp___23 ;
  bool tmp___24 ;
  char const   *tmp___25 ;
  bool tmp___26 ;
  double tmp___27 ;
  int tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  int tmp___31 ;
  double tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  double tmp___35 ;
  char const   *tmp___36 ;
  double tmp___37 ;
  int tmp___38 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  char const   *tmp___55 ;
  double tmp___56 ;
  int tmp___57 ;
  char const   *tmp___58 ;
  double tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  bool tmp___62 ;
  double tmp___63 ;
  char *tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  int tmp___67 ;
  double tmp___68 ;
  char *tmp___69 ;
  char const   *tmp___70 ;
  char const   *tmp___71 ;
  int tmp___72 ;
  double tmp___74 ;
  int tmp___75 ;
  double tmp___76 ;
  double tmp___78 ;
  int tmp___79 ;
  double tmp___80 ;
  double tmp___82 ;
  int tmp___83 ;
  double tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  char const   *tmp___88 ;
  char *tmp___89 ;
  char const   *tmp___90 ;
  double tmp___91 ;
  double tmp___92 ;
  double tmp___94 ;
  int tmp___95 ;
  double tmp___96 ;
  double tmp___98 ;
  int tmp___99 ;
  double tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  double tmp___105 ;
  char *tmp___106 ;
  char const   *tmp___107 ;
  char const   *tmp___108 ;
  int tmp___109 ;
  double tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  char const   *tmp___119 ;
  char *tmp___120 ;
  double tmp___121 ;
  char const   *tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;

  {
#line 485
  rtnnme = "dy_accchk";
#line 491
  dualerrs = (double *)((void *)0);
#line 492
  dfeaserrs = (double *)((void *)0);
#line 493
  dfeascnt = -1;
#line 494
  dinfeas = QNaNbits.fpdbl;
  {
#line 499
  if ((unsigned int )dy_lp->phase == 2U) {
#line 499
    goto case_2;
  }
#line 502
  if ((unsigned int )dy_lp->phase == 3U) {
#line 502
    goto case_3;
  }
#line 505
  if ((unsigned int )dy_lp->phase == 4U) {
#line 505
    goto case_4;
  }
#line 508
  if ((unsigned int )dy_lp->phase == 10U) {
#line 508
    goto case_10;
  }
#line 511
  if ((unsigned int )dy_lp->phase == 7U) {
#line 511
    goto case_7;
  }
#line 514
  if ((unsigned int )dy_lp->phase == 1U) {
#line 514
    goto case_1;
  }
#line 519
  if ((unsigned int )dy_lp->phase == 13U) {
#line 519
    goto case_13;
  }
#line 519
  if ((unsigned int )dy_lp->phase == 12U) {
#line 519
    goto case_13;
  }
#line 519
  if ((unsigned int )dy_lp->phase == 11U) {
#line 519
    goto case_13;
  }
#line 522
  goto switch_default;
  case_2: /* CIL Label */ 
#line 500
  print = dy_opts->print.phase1;
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
#line 503
  print = dy_opts->print.phase2;
#line 504
  goto switch_break;
  case_4: /* CIL Label */ 
#line 506
  print = dy_opts->print.dual;
#line 507
  goto switch_break;
  case_10: /* CIL Label */ 
#line 509
  print = dy_opts->print.conmgmt;
#line 510
  goto switch_break;
  case_7: /* CIL Label */ 
#line 512
  print = dy_opts->print.varmgmt;
#line 513
  goto switch_break;
  case_1: /* CIL Label */ 
#line 515
  print = dy_opts->print.crash;
#line 516
  goto switch_break;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 520
  if (dy_opts->print.conmgmt > dy_opts->print.varmgmt) {
#line 520
    print = dy_opts->print.conmgmt;
  } else {
#line 520
    print = dy_opts->print.varmgmt;
  }
#line 521
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 523
  errmsg(1, rtnnme, 523);
  }
#line 524
  return ((dyret_enum )-10);
  switch_break: /* CIL Label */ ;
  }
#line 526
  if (print >= 2) {
    {
#line 527
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    dy_accchk: ");
    }
#line 528
    if (*checks & (unsigned int )(1 << 8)) {
#line 528
      tmp___0 = 1;
    } else {
#line 528
      tmp___0 = 0;
    }
#line 528
    if (tmp___0) {
      {
#line 529
      dyio_outfmt(dy_logchn, dy_gtxecho, "factor");
      }
#line 530
      if (*checks & (unsigned int )(1 << 9)) {
#line 530
        tmp = 1;
      } else {
#line 530
        tmp = 0;
      }
#line 530
      if (tmp) {
        {
#line 530
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'*');
        }
      }
      {
#line 531
      dyio_outchr(dy_logchn, dy_gtxecho, (char )' ');
      }
    }
#line 532
    if (*checks & (unsigned int )(1 << 1)) {
#line 532
      tmp___1 = 1;
    } else {
#line 532
      tmp___1 = 0;
    }
#line 532
    if (tmp___1) {
      {
#line 533
      dyio_outfmt(dy_logchn, dy_gtxecho, "pchk ");
      }
    }
#line 534
    if (*checks & (unsigned int )(1 << 4)) {
#line 534
      tmp___2 = 1;
    } else {
#line 534
      tmp___2 = 0;
    }
#line 534
    if (tmp___2) {
      {
#line 535
      dyio_outfmt(dy_logchn, dy_gtxecho, "dchk ");
      }
    }
#line 536
    if (*checks & 1U) {
#line 536
      tmp___4 = 1;
    } else {
#line 536
      tmp___4 = 0;
    }
#line 536
    if (tmp___4) {
      {
#line 537
      dyio_outfmt(dy_logchn, dy_gtxecho, "pfeas");
      }
#line 538
      if (*checks & (unsigned int )(1 << 2)) {
#line 538
        tmp___3 = 1;
      } else {
#line 538
        tmp___3 = 0;
      }
#line 538
      if (tmp___3) {
        {
#line 538
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'q');
        }
      }
      {
#line 539
      dyio_outchr(dy_logchn, dy_gtxecho, (char )' ');
      }
    }
#line 540
    if (*checks & (unsigned int )(1 << 3)) {
#line 540
      tmp___6 = 1;
    } else {
#line 540
      tmp___6 = 0;
    }
#line 540
    if (tmp___6) {
      {
#line 541
      dyio_outfmt(dy_logchn, dy_gtxecho, "dfeas");
      }
#line 542
      if (*checks & (unsigned int )(1 << 5)) {
#line 542
        tmp___5 = 1;
      } else {
#line 542
        tmp___5 = 0;
      }
#line 542
      if (tmp___5) {
        {
#line 542
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'q');
        }
      }
      {
#line 543
      dyio_outchr(dy_logchn, dy_gtxecho, (char )' ');
      }
    }
  }
#line 545
  if (*checks & (unsigned int )(1 << 4)) {
#line 545
    tmp___8 = 1;
  } else {
#line 545
    tmp___8 = 0;
  }
#line 545
  if (tmp___8) {
    {
#line 546
    tmp___7 = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 546
    dualerrs = (double *)tmp___7;
    }
  }
#line 547
  if (*checks & (unsigned int )(1 << 3)) {
#line 547
    tmp___10 = 1;
  } else {
#line 547
    tmp___10 = 0;
  }
#line 547
  if (tmp___10) {
    {
#line 548
    tmp___9 = calloc((size_t )(dy_sys->varcnt + 1), sizeof(double ));
#line 548
    dfeaserrs = (double *)tmp___9;
    }
  }
#line 550
  pfeascnt = -1;
#line 551
  pinfeas = QNaNbits.fpdbl;
#line 554
  if (dy_lp->degen > 0) {
#line 554
    if ((unsigned int )dy_lp->phase == 4U) {
#line 555
      dualDegen = (bool )1;
    } else {
#line 557
      dualDegen = (bool )0;
    }
  } else {
#line 557
    dualDegen = (bool )0;
  }
  {
#line 564
  tmp___11 = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 564
  primalerrs = (double *)tmp___11;
#line 565
  tryagain = (bool )1;
#line 566
  dorefactor = (bool )0;
#line 567
  results = (flags )0;
#line 568
  pkcol = (pkvec_struct *)((void *)0);
#line 569
  refactorcnt = 0;
#line 571
  factorresult = (dyret_enum )0;
  }
#line 572
  if (*checks & (unsigned int )(1 << 8)) {
#line 572
    tmp___13 = 1;
  } else {
#line 572
    tmp___13 = 0;
  }
#line 572
  if (tmp___13) {
#line 572
    if (dy_sys->concnt > 0) {
#line 573
      dorefactor = (bool )1;
    } else {
#line 572
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 575
  if (dy_lp->degen > 0) {
#line 575
    if ((unsigned int )dy_lp->phase == 2U) {
#line 575
      goto _L;
    } else
#line 575
    if ((unsigned int )dy_lp->phase == 3U) {
      _L: /* CIL Label */ 
      {
#line 577
      tmp___12 = dy_calcprimals();
      }
#line 577
      if ((int )tmp___12 == 0) {
        {
#line 578
        errmsg(316, rtnnme, dy_sys->nme);
        }
#line 579
        return ((dyret_enum )-10);
      }
    }
  }
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! ((int )tryagain == 1)) {
#line 585
      goto while_break;
    }
#line 586
    tryagain = (bool )0;
#line 594
    if ((int )dorefactor == 1) {
#line 595
      if (refactorcnt != 0) {
#line 595
        goto _L___1;
      } else {
#line 595
        if (*checks & (unsigned int )(1 << 8)) {
#line 595
          tmp___15 = 0;
        } else {
#line 595
          tmp___15 = 1;
        }
#line 595
        if (tmp___15) {
          _L___1: /* CIL Label */ 
          {
#line 596
          tmp___14 = dy_setpivparms(1, 0);
          }
#line 596
          if ((int )tmp___14 == 0) {
#line 596
            goto while_continue;
          }
        }
      }
#line 598
      if (print >= 2) {
        {
#line 599
        tmp___16 = dy_prtpivparms(-1);
#line 599
        tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 599
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s] refactoring at (%s)%d, %s, ",
                    dy_sys->nme, tmp___17, dy_lp->tot.iters, tmp___16);
#line 603
        dyio_outfmt(dy_logchn, dy_gtxecho, "%d pivots since last refactor.", dy_lp->basis.etas);
        }
      } else
#line 598
      if (print >= 1) {
#line 598
        if (results != 0U) {
          {
#line 599
          tmp___16 = dy_prtpivparms(-1);
#line 599
          tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 599
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s] refactoring at (%s)%d, %s, ",
                      dy_sys->nme, tmp___17, dy_lp->tot.iters, tmp___16);
#line 603
          dyio_outfmt(dy_logchn, dy_gtxecho, "%d pivots since last refactor.", dy_lp->basis.etas);
          }
        }
      }
#line 606
      factorflags = (flags )((1 << 7) | (1 << 6));
#line 607
      if (refactorcnt == 0) {
#line 607
        if (*checks & (unsigned int )(1 << 9)) {
#line 607
          tmp___18 = 1;
        } else {
#line 607
          tmp___18 = 0;
        }
#line 607
        if (tmp___18) {
#line 608
          factorflags |= (unsigned int )(1 << 9);
        }
      }
      {
#line 609
      factorresult = dy_factor(& factorflags);
#line 610
      refactorcnt ++;
      }
#line 611
      if (! ((int )factorresult == 1)) {
#line 611
        if (! ((int )factorresult == 2)) {
#line 614
          if (print >= 2) {
#line 614
            goto _L___2;
          } else
#line 614
          if (print >= 1) {
#line 614
            if (results & (unsigned int )((1 << 1) | (1 << 4))) {
#line 614
              tmp___20 = 1;
            } else {
#line 614
              tmp___20 = 0;
            }
#line 614
            if (tmp___20) {
              _L___2: /* CIL Label */ 
#line 616
              if (print >= 6) {
#line 616
                tmp___19 = "\n\t";
              } else {
#line 616
                tmp___19 = " ";
              }
              {
#line 616
              dyio_outfmt(dy_logchn, dy_gtxecho, "%sfailed.", tmp___19);
              }
            }
          }
#line 619
          return (factorresult);
        }
      }
#line 621
      if (print >= 2) {
#line 621
        goto _L___3;
      } else
#line 621
      if (print >= 1) {
#line 621
        if (results & (unsigned int )((1 << 1) | (1 << 4))) {
#line 621
          tmp___23 = 1;
        } else {
#line 621
          tmp___23 = 0;
        }
#line 621
        if (tmp___23) {
          _L___3: /* CIL Label */ 
#line 623
          if ((int )factorresult == 1) {
#line 623
            tmp___21 = "done";
          } else {
#line 623
            tmp___21 = "patched";
          }
#line 623
          if (print >= 6) {
#line 623
            tmp___22 = "\n\t";
          } else {
#line 623
            tmp___22 = " ";
          }
          {
#line 623
          dyio_outfmt(dy_logchn, dy_gtxecho, "%s%s.", tmp___22, tmp___21);
          }
        }
      }
#line 626
      results |= (unsigned int )(1 << 8) | factorflags;
    }
    {
#line 634
    normb = (double )0;
#line 635
    primalresid = (double )0;
#line 636
    normc = (double )0;
#line 637
    dualresid = (double )0;
#line 638
    results &= (unsigned int )(~ ((((1 << 1) | 1) | (1 << 4)) | (1 << 3)));
#line 640
    tmp___24 = dy_reducerhs(primalerrs, (bool )1);
    }
#line 640
    if ((int )tmp___24 != 1) {
      {
#line 641
      errmsg(340, rtnnme, dy_sys->nme);
      }
#line 642
      return ((dyret_enum )-10);
    }
#line 644
    if (*checks & (unsigned int )((1 << 1) | (1 << 4))) {
#line 644
      tmp___38 = 1;
    } else {
#line 644
      tmp___38 = 0;
    }
#line 644
    if (tmp___38) {
#line 645
      xkpos = 1;
      {
#line 645
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 645
        if (! (xkpos <= dy_sys->concnt)) {
#line 645
          goto while_break___0;
        }
        {
#line 646
        xkndx = *(dy_basis + xkpos);
#line 647
        tmp___26 = consys_getcol_pk(dy_sys, xkndx, & pkcol);
        }
#line 647
        if ((int )tmp___26 == 0) {
          {
#line 648
          tmp___25 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 648
          errmsg(112, rtnnme, dy_sys->nme, "retrieve", "column", tmp___25, xkndx);
          }
#line 650
          return ((dyret_enum )-10);
        }
#line 652
        if (*checks & (unsigned int )(1 << 1)) {
#line 652
          tmp___28 = 1;
        } else {
#line 652
          tmp___28 = 0;
        }
#line 652
        if (tmp___28) {
          {
#line 653
          tmp___27 = fabs(*(dy_sys->rhs + xkpos));
#line 653
          normb += tmp___27;
#line 654
          pkndx = 0;
          }
          {
#line 654
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 654
            if (! (pkndx < pkcol->cnt)) {
#line 654
              goto while_break___1;
            }
#line 655
            cndx = (pkcol->coeffs + pkndx)->ndx;
#line 656
            *(primalerrs + cndx) -= (pkcol->coeffs + pkndx)->val * *(dy_x + xkndx);
#line 654
            pkndx ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 658
        if (*checks & (unsigned int )(1 << 4)) {
#line 658
          tmp___31 = 1;
        } else {
#line 658
          tmp___31 = 0;
        }
#line 658
        if (tmp___31) {
          {
#line 659
          cbarj = *(dy_sys->obj + xkndx);
#line 660
          tmp___29 = fabs(cbarj);
#line 660
          normc += tmp___29;
#line 661
          pkndx = 0;
          }
          {
#line 661
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 661
            if (! (pkndx < pkcol->cnt)) {
#line 661
              goto while_break___2;
            }
#line 662
            cndx = (pkcol->coeffs + pkndx)->ndx;
#line 663
            if ((int )dualDegen == 1) {
#line 663
              if (! (*(dy_ddegenset + cndx) > 0)) {
#line 666
                cbarj -= (pkcol->coeffs + pkndx)->val * *(dy_y + cndx);
              }
            } else {
#line 666
              cbarj -= (pkcol->coeffs + pkndx)->val * *(dy_y + cndx);
            }
#line 661
            pkndx ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 667
          tmp___30 = fabs(cbarj);
#line 667
          dualresid += tmp___30;
#line 669
          *(dualerrs + xkpos) = fabs(cbarj);
          }
        }
#line 645
        xkpos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 673
      if (*checks & (unsigned int )(1 << 1)) {
#line 673
        tmp___33 = 1;
      } else {
#line 673
        tmp___33 = 0;
      }
#line 673
      if (tmp___33) {
#line 674
        xkpos = 1;
        {
#line 674
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 674
          if (! (xkpos <= dy_sys->concnt)) {
#line 674
            goto while_break___3;
          }
          {
#line 675
          tmp___32 = fabs(*(primalerrs + xkpos));
#line 675
          primalresid += tmp___32;
#line 674
          xkpos ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 679
      if (normb > dy_lp->prim.norm1) {
#line 679
        normb = normb;
      } else {
#line 679
        normb = dy_lp->prim.norm1;
      }
      {
#line 680
      tmp___35 = fabs(primalresid - 0.0);
      }
#line 680
      if (! (tmp___35 <= dy_tols->pchk * ((double )1 + normb))) {
        {
#line 681
        tmp___34 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 681
        warn(341, rtnnme, dy_sys->nme, tmp___34, dy_lp->tot.iters, "primal", 'b',
             normb, primalresid, dy_tols->pchk * ((double )1 + normb));
#line 684
        results |= (unsigned int )(1 << 1);
        }
      }
#line 686
      if (normc > dy_lp->dual.norm1) {
#line 686
        normc = normc;
      } else {
#line 686
        normc = dy_lp->dual.norm1;
      }
      {
#line 687
      normc *= (double )2;
#line 688
      tmp___37 = fabs(dualresid - 0.0);
      }
#line 688
      if (! (tmp___37 <= dy_tols->dchk * ((double )1 + normc))) {
        {
#line 689
        tmp___36 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 689
        warn(341, rtnnme, dy_sys->nme, tmp___36, dy_lp->tot.iters, "dual", 'c', normc,
             dualresid, dy_tols->dchk * ((double )1 + normc));
#line 692
        results |= (unsigned int )(1 << 4);
        }
      }
    }
#line 698
    if (print >= 3) {
#line 698
      if (results & (unsigned int )(1 << 1)) {
#line 698
        tmp___45 = 1;
      } else {
#line 698
        tmp___45 = 0;
      }
#line 698
      if (tmp___45) {
#line 698
        goto _L___4;
      } else {
#line 698
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 698
    if (print >= 3) {
#line 698
      if (*checks & (unsigned int )(1 << 1)) {
#line 698
        tmp___46 = 1;
      } else {
#line 698
        tmp___46 = 0;
      }
#line 698
      if (tmp___46) {
        _L___4: /* CIL Label */ 
#line 700
        if (results & (unsigned int )(1 << 1)) {
#line 700
          tmp___41 = 1;
        } else {
#line 700
          tmp___41 = 0;
        }
#line 700
        if (tmp___41) {
#line 700
          tmp___40 = "failed";
        } else {
#line 700
          tmp___40 = "passed";
        }
        {
#line 700
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s primal accuracy check, ", tmp___40);
        }
#line 702
        if (results & (unsigned int )(1 << 1)) {
#line 702
          tmp___44 = 1;
        } else {
#line 702
          tmp___44 = 0;
        }
#line 702
        if (tmp___44) {
#line 702
          tmp___43 = '>';
        } else {
#line 702
          tmp___43 = '<';
        }
        {
#line 702
        dyio_outfmt(dy_logchn, dy_gtxecho, "residual/(1+normb) = %g/%g = %g %c %g.",
                    primalresid, (double )1 + normb, primalresid / ((double )1 + normb),
                    tmp___43, dy_tols->pchk);
#line 706
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%.2f%%)", (primalresid / (dy_tols->pchk * ((double )1 + normb))) * (double )100);
        }
      }
    }
#line 709
    if (print >= 3) {
#line 709
      if (results & (unsigned int )(1 << 4)) {
#line 709
        tmp___53 = 1;
      } else {
#line 709
        tmp___53 = 0;
      }
#line 709
      if (tmp___53) {
#line 709
        goto _L___6;
      } else {
#line 709
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 709
    if (print >= 3) {
#line 709
      if (*checks & (unsigned int )(1 << 4)) {
#line 709
        tmp___54 = 1;
      } else {
#line 709
        tmp___54 = 0;
      }
#line 709
      if (tmp___54) {
        _L___6: /* CIL Label */ 
#line 711
        if (results & (unsigned int )(1 << 4)) {
#line 711
          tmp___49 = 1;
        } else {
#line 711
          tmp___49 = 0;
        }
#line 711
        if (tmp___49) {
#line 711
          tmp___48 = "failed";
        } else {
#line 711
          tmp___48 = "passed";
        }
        {
#line 711
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s dual accuracy check, ", tmp___48);
        }
#line 713
        if (results & (unsigned int )(1 << 4)) {
#line 713
          tmp___52 = 1;
        } else {
#line 713
          tmp___52 = 0;
        }
#line 713
        if (tmp___52) {
#line 713
          tmp___51 = '>';
        } else {
#line 713
          tmp___51 = '<';
        }
        {
#line 713
        dyio_outfmt(dy_logchn, dy_gtxecho, "residual/(1+normc) = %g/%g = %g %c %g.",
                    dualresid, (double )1 + normc, dualresid / ((double )1 + normc),
                    tmp___51, dy_tols->dchk);
#line 717
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%.2f%%)", (dualresid / (dy_tols->dchk * ((double )1 + normc))) * (double )100);
        }
      }
    }
#line 720
    if (print >= 3) {
#line 721
      if (results & (unsigned int )(1 << 1)) {
#line 721
        tmp___57 = 1;
      } else {
#line 721
        tmp___57 = 0;
      }
#line 721
      if (tmp___57) {
        {
#line 722
        avgerr = (dy_tols->pchk * ((double )1 + normb)) / (double )dy_sys->concnt;
#line 723
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    rows exceeding scaled average tolerance %g:",
                    avgerr);
#line 726
        xkpos = 1;
        }
        {
#line 726
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 726
          if (! (xkpos <= dy_sys->concnt)) {
#line 726
            goto while_break___4;
          }
          {
#line 727
          tmp___56 = fabs(*(primalerrs + xkpos));
          }
#line 727
          if (tmp___56 > avgerr) {
            {
#line 728
            tmp___55 = consys_nme(dy_sys, (char )'c', xkpos, (bool )0, (char *)((void *)0));
#line 728
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trow %s (%d), residual %g.", tmp___55,
                        xkpos, *(primalerrs + xkpos));
            }
          }
#line 726
          xkpos ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 732
      if (results & (unsigned int )(1 << 4)) {
#line 732
        tmp___60 = 1;
      } else {
#line 732
        tmp___60 = 0;
      }
#line 732
      if (tmp___60) {
        {
#line 733
        avgerr = (dy_tols->dchk * ((double )1 + normc)) / (double )dy_sys->concnt;
#line 734
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    columns exceeding scaled average tolerance %g:",
                    avgerr);
#line 737
        xkpos = 1;
        }
        {
#line 737
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 737
          if (! (xkpos <= dy_sys->concnt)) {
#line 737
            goto while_break___5;
          }
          {
#line 738
          tmp___59 = fabs(*(dualerrs + xkpos));
          }
#line 738
          if (tmp___59 > avgerr) {
            {
#line 739
            xkndx = *(dy_basis + xkpos);
#line 740
            tmp___58 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 740
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpos\'n %d, column %s (%d), residual %g.",
                        xkpos, tmp___58, xkndx, *(dualerrs + xkpos));
            }
          }
#line 737
          xkpos ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 750
    if (results & (unsigned int )((1 << 1) | (1 << 4))) {
#line 750
      tmp___61 = 1;
    } else {
#line 750
      tmp___61 = 0;
    }
#line 750
    if (tmp___61) {
#line 751
      tryagain = (bool )1;
#line 752
      dorefactor = (bool )1;
#line 753
      goto while_continue;
    }
#line 758
    if ((int )factorresult != 0) {
      {
#line 759
      tmp___62 = groombasis();
      }
#line 759
      if ((int )tmp___62 == 0) {
        {
#line 760
        errmsg(373, rtnnme, dy_sys->nme);
        }
#line 761
        return ((dyret_enum )-10);
      }
    }
#line 769
    if (*checks & 1U) {
#line 769
      tmp___85 = 1;
    } else {
#line 769
      tmp___85 = 0;
    }
#line 769
    if (tmp___85) {
#line 770
      pinfeas = (double )0;
#line 771
      pfeascnt = 0;
#line 798
      xkpos = 1;
      {
#line 798
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 798
        if (! (xkpos <= dy_sys->concnt)) {
#line 798
          goto while_break___6;
        }
        {
#line 799
        xkndx = *(dy_basis + xkpos);
#line 800
        tmp___80 = fabs(*(dy_sys->vub + xkndx));
        }
#line 800
        if (tmp___80 < dy_tols->inf) {
          {
#line 800
          tmp___78 = fabs(*(dy_sys->vub + xkndx));
#line 800
          tmp___79 = *(dy_x + xkndx) - *(dy_sys->vub + xkndx) > dy_tols->pfeas * (1.0 + tmp___78);
          }
        } else {
#line 800
          tmp___79 = *(dy_x + xkndx) > *(dy_sys->vub + xkndx);
        }
#line 800
        if (tmp___79) {
          _L___8: /* CIL Label */ 
          {
#line 801
          tmp___76 = fabs(*(dy_sys->vlb + xkndx));
          }
#line 801
          if (tmp___76 < dy_tols->inf) {
            {
#line 801
            tmp___74 = fabs(*(dy_sys->vlb + xkndx));
#line 801
            tmp___75 = *(dy_sys->vlb + xkndx) - *(dy_x + xkndx) > dy_tols->pfeas * (1.0 + tmp___74);
            }
          } else {
#line 801
            tmp___75 = *(dy_x + xkndx) < *(dy_sys->vlb + xkndx);
          }
#line 801
          if (tmp___75) {
#line 802
            pinfeas += *(dy_sys->vlb + xkndx) - *(dy_x + xkndx);
#line 803
            if (*checks & (unsigned int )(1 << 2)) {
#line 803
              tmp___67 = 0;
            } else {
#line 803
              tmp___67 = 1;
            }
#line 803
            if (tmp___67) {
              {
#line 804
              tmp___63 = fabs(*(dy_sys->vlb + xkndx));
#line 804
              tmp___64 = dy_prtvstat(*(dy_status + xkndx));
#line 804
              tmp___65 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 804
              tmp___66 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 804
              warn(323, rtnnme, dy_sys->nme, tmp___66, dy_lp->tot.iters, tmp___65,
                   xkndx, tmp___64, *(dy_sys->vlb + xkndx), *(dy_x + xkndx), *(dy_sys->vub + xkndx),
                   *(dy_sys->vlb + xkndx) - *(dy_x + xkndx), dy_tols->pfeas * ((double )1 + tmp___63));
              }
            }
          } else {
#line 812
            pinfeas += *(dy_x + xkndx) - *(dy_sys->vub + xkndx);
#line 813
            if (*checks & (unsigned int )(1 << 2)) {
#line 813
              tmp___72 = 0;
            } else {
#line 813
              tmp___72 = 1;
            }
#line 813
            if (tmp___72) {
              {
#line 814
              tmp___68 = fabs(*(dy_sys->vub + xkndx));
#line 814
              tmp___69 = dy_prtvstat(*(dy_status + xkndx));
#line 814
              tmp___70 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 814
              tmp___71 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 814
              warn(323, rtnnme, dy_sys->nme, tmp___71, dy_lp->tot.iters, tmp___70,
                   xkndx, tmp___69, *(dy_sys->vlb + xkndx), *(dy_x + xkndx), *(dy_sys->vub + xkndx),
                   *(dy_x + xkndx) - *(dy_sys->vub + xkndx), dy_tols->pfeas * ((double )1 + tmp___68));
              }
            }
          }
#line 821
          pfeascnt ++;
#line 822
          results |= 1U;
        } else {
          {
#line 800
          tmp___84 = fabs(*(dy_sys->vlb + xkndx));
          }
#line 800
          if (tmp___84 < dy_tols->inf) {
            {
#line 800
            tmp___82 = fabs(*(dy_sys->vlb + xkndx));
#line 800
            tmp___83 = *(dy_sys->vlb + xkndx) - *(dy_x + xkndx) > dy_tols->pfeas * (1.0 + tmp___82);
            }
          } else {
#line 800
            tmp___83 = *(dy_x + xkndx) < *(dy_sys->vlb + xkndx);
          }
#line 800
          if (tmp___83) {
#line 800
            goto _L___8;
          }
        }
#line 798
        xkpos ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 824
      dy_lp->infeas = pinfeas;
#line 825
      dy_lp->infeascnt = pfeascnt;
    }
#line 831
    if (print >= 5) {
#line 832
      if (*checks & 1U) {
#line 832
        tmp___86 = 1;
      } else {
#line 832
        tmp___86 = 0;
      }
#line 832
      if (tmp___86) {
#line 832
        if (results & 1U) {
#line 832
          tmp___87 = 0;
        } else {
#line 832
          tmp___87 = 1;
        }
#line 832
        if (tmp___87) {
          {
#line 833
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpassed primal feasibility check.");
          }
        }
      }
    }
#line 836
    if (print >= 3) {
#line 837
      if (results & 1U) {
#line 837
        tmp___101 = 1;
      } else {
#line 837
        tmp___101 = 0;
      }
#line 837
      if (tmp___101) {
        {
#line 838
        tmp___88 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 838
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %d variables primal infeasible, pinfeas = %g:",
                    tmp___88, dy_lp->tot.iters, pfeascnt, pinfeas);
#line 842
        xkndx = 1;
        }
        {
#line 842
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 842
          if (! (xkndx <= dy_sys->varcnt)) {
#line 842
            goto while_break___7;
          }
          {
#line 843
          tmp___96 = fabs(*(dy_sys->vub + xkndx));
          }
#line 843
          if (tmp___96 < dy_tols->inf) {
            {
#line 843
            tmp___94 = fabs(*(dy_sys->vub + xkndx));
#line 843
            tmp___95 = *(dy_x + xkndx) - *(dy_sys->vub + xkndx) > dy_tols->pfeas * (1.0 + tmp___94);
            }
          } else {
#line 843
            tmp___95 = *(dy_x + xkndx) > *(dy_sys->vub + xkndx);
          }
#line 843
          if (tmp___95) {
            _L___9: /* CIL Label */ 
            {
#line 844
            tmp___89 = dy_prtvstat(*(dy_status + xkndx));
#line 844
            tmp___90 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 844
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s, lb = %g, ub = %g, ",
                        tmp___90, xkndx, *(dy_x + xkndx), tmp___89, *(dy_sys->vlb + xkndx),
                        *(dy_sys->vub + xkndx));
            }
#line 849
            if (*(dy_x + xkndx) < *(dy_sys->vlb + xkndx)) {
              {
#line 850
              tmp___91 = fabs(*(dy_sys->vlb + xkndx));
#line 850
              dyio_outfmt(dy_logchn, dy_gtxecho, "lb-x = %g, tol = %g", *(dy_sys->vlb + xkndx) - *(dy_x + xkndx),
                          dy_tols->pfeas * ((double )1 + tmp___91));
              }
            } else {
              {
#line 854
              tmp___92 = fabs(*(dy_sys->vub + xkndx));
#line 854
              dyio_outfmt(dy_logchn, dy_gtxecho, "x-ub = %g, tol = %g", *(dy_x + xkndx) - *(dy_sys->vub + xkndx),
                          dy_tols->pfeas * ((double )1 + tmp___92));
              }
            }
          } else {
            {
#line 843
            tmp___100 = fabs(*(dy_sys->vlb + xkndx));
            }
#line 843
            if (tmp___100 < dy_tols->inf) {
              {
#line 843
              tmp___98 = fabs(*(dy_sys->vlb + xkndx));
#line 843
              tmp___99 = *(dy_sys->vlb + xkndx) - *(dy_x + xkndx) > dy_tols->pfeas * (1.0 + tmp___98);
              }
            } else {
#line 843
              tmp___99 = *(dy_x + xkndx) < *(dy_sys->vlb + xkndx);
            }
#line 843
            if (tmp___99) {
#line 843
              goto _L___9;
            }
          }
#line 842
          xkndx ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 859
    if (results & 1U) {
#line 859
      tmp___102 = 1;
    } else {
#line 859
      tmp___102 = 0;
    }
#line 859
    if (tmp___102) {
#line 859
      if (*checks & (unsigned int )(1 << 2)) {
#line 859
        tmp___103 = 0;
      } else {
#line 859
        tmp___103 = 1;
      }
#line 859
      if (tmp___103) {
#line 860
        tryagain = (bool )1;
#line 861
        dorefactor = (bool )1;
#line 862
        goto while_continue;
      }
    }
#line 875
    if (*checks & (unsigned int )(1 << 3)) {
#line 875
      tmp___116 = 1;
    } else {
#line 875
      tmp___116 = 0;
    }
#line 875
    if (tmp___116) {
#line 878
      dfeascnt = 0;
#line 879
      dinfeas = (double )0;
#line 881
      xkndx = 1;
      {
#line 881
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 881
        if (! (xkndx <= dy_sys->varcnt)) {
#line 881
          goto while_break___8;
        }
#line 882
        vstat = *(dy_status + xkndx);
#line 886
        if (vstat & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 886
          tmp___104 = 1;
        } else {
#line 886
          tmp___104 = 0;
        }
#line 886
        if (tmp___104) {
#line 886
          goto __Cont;
        }
        {
#line 888
        cbarj = consys_dotcol(dy_sys, xkndx, dy_y);
        }
#line 895
        if ((int )dualDegen == 1) {
#line 895
          if (*(dy_ddegenset + xkndx) > 0) {
#line 896
            cbarj = *(dy_cbar + xkndx);
          } else {
#line 895
            goto _L___10;
          }
        } else {
          _L___10: /* CIL Label */ 
          {
#line 898
          cbarj = *(dy_sys->obj + xkndx) - cbarj;
#line 899
          tmp___105 = fabs(cbarj);
          }
#line 899
          if (tmp___105 < dy_tols->cost) {
#line 899
            cbarj = (double )0;
          }
#line 900
          *(dy_cbar + xkndx) = cbarj;
        }
#line 901
        if (vstat & (unsigned int )(1 << 7)) {
#line 901
          tmp___111 = 1;
        } else {
#line 901
          tmp___111 = 0;
        }
#line 901
        if (tmp___111) {
#line 901
          if (cbarj < - dy_tols->dfeas) {
#line 901
            goto _L___11;
          } else {
#line 901
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
#line 901
          if (vstat & (unsigned int )(1 << 6)) {
#line 901
            tmp___112 = 1;
          } else {
#line 901
            tmp___112 = 0;
          }
#line 901
          if (tmp___112) {
#line 901
            if (cbarj > dy_tols->dfeas) {
#line 901
              goto _L___11;
            } else {
#line 901
              goto _L___13;
            }
          } else {
            _L___13: /* CIL Label */ 
#line 901
            if (vstat & (unsigned int )(1 << 8)) {
#line 901
              tmp___113 = 1;
            } else {
#line 901
              tmp___113 = 0;
            }
#line 901
            if (tmp___113) {
#line 901
              if (cbarj != (double )0) {
#line 901
                goto _L___11;
              } else {
#line 901
                goto _L___12;
              }
            } else {
              _L___12: /* CIL Label */ 
#line 901
              if (vstat & (unsigned int )(1 << 9)) {
#line 901
                tmp___114 = 1;
              } else {
#line 901
                tmp___114 = 0;
              }
#line 901
              if (tmp___114) {
                _L___11: /* CIL Label */ 
#line 905
                if (*checks & (unsigned int )(1 << 5)) {
#line 905
                  tmp___109 = 0;
                } else {
#line 905
                  tmp___109 = 1;
                }
#line 905
                if (tmp___109) {
                  {
#line 906
                  tmp___106 = dy_prtvstat(vstat);
#line 906
                  tmp___107 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 906
                  tmp___108 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 906
                  warn(347, rtnnme, dy_sys->nme, tmp___108, dy_lp->tot.iters, tmp___107,
                       xkndx, tmp___106, xkndx, cbarj, dy_tols->dfeas);
                  }
                }
                {
#line 915
                tmp___110 = fabs(cbarj);
#line 915
                dinfeas += tmp___110;
#line 916
                dfeascnt ++;
#line 917
                *(dfeaserrs + xkndx) = cbarj;
#line 919
                results |= (unsigned int )(1 << 3);
                }
              }
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 881
        xkndx ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 920
      if (results & (unsigned int )(1 << 3)) {
#line 920
        tmp___115 = 1;
      } else {
#line 920
        tmp___115 = 0;
      }
#line 920
      if (tmp___115) {
#line 921
        (dy_lp->basis.dinf) ++;
      } else {
#line 923
        dy_lp->basis.dinf = 0;
      }
    }
#line 929
    if (print >= 5) {
#line 930
      if (*checks & (unsigned int )(1 << 3)) {
#line 930
        tmp___117 = 1;
      } else {
#line 930
        tmp___117 = 0;
      }
#line 930
      if (tmp___117) {
#line 930
        if (results & (unsigned int )(1 << 3)) {
#line 930
          tmp___118 = 0;
        } else {
#line 930
          tmp___118 = 1;
        }
#line 930
        if (tmp___118) {
          {
#line 931
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpassed dual feasibility check.");
          }
        }
      }
    }
#line 934
    if (print >= 3) {
#line 935
      if (results & (unsigned int )(1 << 3)) {
#line 935
        tmp___123 = 1;
      } else {
#line 935
        tmp___123 = 0;
      }
#line 935
      if (tmp___123) {
        {
#line 936
        tmp___119 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 936
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %d variables dual infeasible, dinfeas = %g:",
                    tmp___119, dy_lp->tot.iters, dfeascnt, dinfeas);
#line 940
        xkndx = 1;
        }
        {
#line 940
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 940
          if (! (xkndx <= dy_sys->varcnt)) {
#line 940
            goto while_break___9;
          }
#line 941
          if (*(dfeaserrs + xkndx) != 0.0) {
            {
#line 942
            vstat = *(dy_status + xkndx);
#line 943
            tmp___120 = dy_prtvstat(vstat);
            }
#line 943
            if (vstat == (flags )(1 << 7)) {
#line 943
              tmp___121 = *(dy_sys->vlb + xkndx);
            } else {
#line 943
              tmp___121 = *(dy_sys->vub + xkndx);
            }
            {
#line 943
            tmp___122 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 943
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s, cbarj = %g, tol %g.",
                        tmp___122, xkndx, tmp___121, tmp___120, *(dfeaserrs + xkndx),
                        dy_tols->dfeas);
            }
          }
#line 940
          xkndx ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
    }
#line 951
    if (results & (unsigned int )(1 << 3)) {
#line 951
      tmp___124 = 1;
    } else {
#line 951
      tmp___124 = 0;
    }
#line 951
    if (tmp___124) {
#line 951
      if (*checks & (unsigned int )(1 << 5)) {
#line 951
        tmp___125 = 0;
      } else {
#line 951
        tmp___125 = 1;
      }
#line 951
      if (tmp___125) {
#line 952
        tryagain = (bool )1;
#line 953
        dorefactor = (bool )1;
#line 954
        goto while_continue;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 961
  if (refactorcnt == 0) {
#line 961
    if (*checks & (unsigned int )((1 << 1) | (1 << 4))) {
#line 961
      tmp___126 = 1;
    } else {
#line 961
      tmp___126 = 0;
    }
#line 961
    if (tmp___126) {
      {
#line 962
      dy_setpivparms(-1, 0);
      }
    }
  }
  {
#line 964
  free((void *)primalerrs);
  }
#line 965
  if ((unsigned long )pkcol != (unsigned long )((void *)0)) {
    {
#line 965
    pkvec_free(pkcol);
    }
  }
#line 967
  if (*checks & (unsigned int )(1 << 4)) {
#line 967
    tmp___127 = 1;
  } else {
#line 967
    tmp___127 = 0;
  }
#line 967
  if (tmp___127) {
    {
#line 967
    free((void *)dualerrs);
    }
  }
#line 968
  if (*checks & (unsigned int )(1 << 3)) {
#line 968
    tmp___128 = 1;
  } else {
#line 968
    tmp___128 = 0;
  }
#line 968
  if (tmp___128) {
    {
#line 968
    free((void *)dfeaserrs);
    }
  }
#line 971
  *checks = results;
#line 973
  return ((dyret_enum )1);
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_duenna.c"
dyret_enum dy_duenna(dyret_enum pivresult , int xjndx , int xindx , int xjcand , int xicand ) 
{ 
  dyret_enum retval ;
  dyret_enum accchk ;
  double cbarcand ;
  bool pivok ;
  flags checkflags ;
  flags outflags ;
  flags statcand ;
  char const   *rtnnme ;
  int print ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  double tmp___29 ;

  {
#line 1082
  rtnnme = "La Duenna";
  {
#line 1090
  if ((unsigned int )dy_lp->phase == 2U) {
#line 1090
    goto case_2;
  }
#line 1093
  if ((unsigned int )dy_lp->phase == 3U) {
#line 1093
    goto case_3;
  }
#line 1096
  if ((unsigned int )dy_lp->phase == 4U) {
#line 1096
    goto case_4;
  }
#line 1099
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1091
  print = dy_opts->print.phase1;
#line 1092
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1094
  print = dy_opts->print.phase2;
#line 1095
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1097
  print = dy_opts->print.dual;
#line 1098
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1100
  errmsg(1, rtnnme, 1100);
  }
#line 1101
  return ((dyret_enum )-10);
  switch_break: /* CIL Label */ ;
  }
#line 1104
  retval = (dyret_enum )0;
#line 1105
  outflags = (flags )0;
#line 1106
  checkflags = (flags )0;
#line 1114
  pivok = dy_lp->pivok;
#line 1115
  dy_lp->prev_pivok = pivok;
#line 1116
  dy_lp->pivok = (bool )0;
#line 1117
  if ((int )pivok == 1) {
#line 1117
    if (xindx != xjndx) {
#line 1118
      (dy_lp->basis.etas) ++;
#line 1119
      (dy_lp->basis.pivs) ++;
    }
  }
#line 1120
  if ((unsigned int )dy_lp->phase == 2U) {
#line 1121
    (dy_lp->p1.iters) ++;
#line 1122
    if ((int )pivok == 1) {
#line 1122
      (dy_lp->p1.pivs) ++;
    }
#line 1123
    if (dy_opts->iterlim > 0) {
#line 1123
      if (dy_lp->p1.pivs > dy_opts->iterlim) {
#line 1124
        retval = (dyret_enum )-9;
      }
    }
  } else
#line 1126
  if ((unsigned int )dy_lp->phase == 3U) {
#line 1127
    (dy_lp->p2.iters) ++;
#line 1128
    if ((int )pivok == 1) {
#line 1128
      (dy_lp->p2.pivs) ++;
    }
#line 1129
    if (dy_opts->iterlim > 0) {
#line 1129
      if (dy_lp->p2.pivs > dy_opts->iterlim) {
#line 1130
        retval = (dyret_enum )-9;
      }
    }
  } else {
#line 1132
    (dy_lp->d2.iters) ++;
#line 1133
    if ((int )pivok == 1) {
#line 1133
      (dy_lp->d2.pivs) ++;
    }
#line 1134
    if (dy_opts->iterlim > 0) {
#line 1134
      if (dy_lp->d2.pivs > dy_opts->iterlim) {
#line 1135
        retval = (dyret_enum )-9;
      }
    }
  }
#line 1136
  if ((int )retval == -9) {
#line 1137
    if ((unsigned int )dy_opts->context != 3U) {
      {
#line 1138
      errmsg(328, rtnnme, dy_sys->nme, dy_opts->iterlim);
      }
    }
#line 1139
    return (retval);
  }
#line 1140
  (dy_lp->tot.iters) ++;
#line 1141
  if ((int )pivok == 1) {
#line 1141
    (dy_lp->tot.pivs) ++;
  }
#line 1142
  if (dy_opts->iterlim > 0) {
#line 1142
    if (dy_lp->tot.pivs > 3 * dy_opts->iterlim) {
#line 1143
      retval = (dyret_enum )-9;
#line 1144
      if ((unsigned int )dy_opts->context != 3U) {
        {
#line 1145
        errmsg(328, rtnnme, dy_sys->nme, 3 * dy_opts->iterlim);
        }
      }
#line 1146
      return (retval);
    }
  }
  {
#line 1200
  if ((int )pivresult == -2) {
#line 1200
    goto case_neg_2;
  }
#line 1200
  if ((int )pivresult == 7) {
#line 1200
    goto case_neg_2;
  }
#line 1200
  if ((int )pivresult == 1) {
#line 1200
    goto case_neg_2;
  }
#line 1204
  if ((int )pivresult == 3) {
#line 1204
    goto case_3___0;
  }
#line 1204
  if ((int )pivresult == -1) {
#line 1204
    goto case_3___0;
  }
#line 1206
  if ((int )pivresult == 6) {
#line 1206
    goto case_6;
  }
#line 1209
  if ((int )pivresult == 8) {
#line 1209
    goto case_8;
  }
#line 1211
  if ((int )pivresult == 9) {
#line 1211
    goto case_9;
  }
#line 1213
  if ((int )pivresult == 4) {
#line 1213
    goto case_4___0;
  }
#line 1227
  if ((int )pivresult == -3) {
#line 1227
    goto case_neg_3;
  }
#line 1227
  if ((int )pivresult == -4) {
#line 1227
    goto case_neg_3;
  }
#line 1244
  if ((int )pivresult == -6) {
#line 1244
    goto case_neg_6;
  }
#line 1262
  if ((int )pivresult == -7) {
#line 1262
    goto case_neg_7;
  }
#line 1279
  if ((int )pivresult == -10) {
#line 1279
    goto case_neg_10;
  }
#line 1282
  goto switch_default___0;
  case_neg_2: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1201
  retval = (dyret_enum )1;
#line 1202
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 1205
  return ((dyret_enum )3);
  case_6: /* CIL Label */ 
  {
#line 1207
  retval = dy_dealWithPunt();
  }
#line 1208
  return (retval);
  case_8: /* CIL Label */ 
#line 1210
  return ((dyret_enum )8);
  case_9: /* CIL Label */ 
#line 1212
  return ((dyret_enum )9);
  case_4___0: /* CIL Label */ 
#line 1214
  checkflags |= (unsigned int )(1 << 8);
#line 1216
  if (print >= 1) {
    {
#line 1217
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1217
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s] refactor requested at (%s)%d, ",
                dy_sys->nme, tmp, dy_lp->tot.iters);
#line 1221
    dyio_outfmt(dy_logchn, dy_gtxecho, "%d pivots since last refactor.", dy_lp->basis.etas);
    }
  }
#line 1224
  retval = (dyret_enum )4;
#line 1225
  goto switch_break___0;
  case_neg_3: /* CIL Label */ 
  case_neg_4: /* CIL Label */ 
#line 1228
  checkflags |= (unsigned int )(1 << 8);
#line 1236
  if (print >= 1) {
#line 1237
    if ((int )pivresult == -4) {
#line 1237
      tmp___0 = "primal";
    } else {
#line 1237
      tmp___0 = "dual";
    }
    {
#line 1237
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s] loss of %s feasibility at iteration %d.",
                dy_sys->nme, tmp___0, dy_lp->tot.iters);
    }
  }
#line 1242
  retval = (dyret_enum )4;
#line 1243
  goto switch_break___0;
  case_neg_6: /* CIL Label */ 
#line 1245
  checkflags |= (unsigned int )(1 << 8);
#line 1247
  if (print >= 1) {
    {
#line 1248
    tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1248
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: pivot attempt produced ",
                dy_sys->nme, tmp___1, dy_lp->tot.iters);
#line 1252
    dyio_outfmt(dy_logchn, dy_gtxecho, "singular basis; attempting recovery.");
    }
  }
#line 1255
  if ((unsigned int )dy_lp->phase == 4U) {
    {
#line 1256
    retval = dy_addtopivrej(xindx, (dyret_enum )-6, 0.0, 0.0);
    }
  } else {
    {
#line 1258
    retval = dy_addtopivrej(xjndx, (dyret_enum )-6, 0.0, 0.0);
    }
  }
#line 1259
  if ((int )retval != 1) {
#line 1259
    return (retval);
  }
#line 1260
  retval = (dyret_enum )3;
#line 1261
  goto switch_break___0;
  case_neg_7: /* CIL Label */ 
#line 1263
  checkflags |= (unsigned int )(1 << 8);
#line 1264
  if (dy_lp->basis.etas == 0) {
#line 1264
    checkflags |= (unsigned int )(1 << 9);
  }
#line 1266
  if (print >= 1) {
#line 1267
    if (checkflags & (unsigned int )(1 << 9)) {
#line 1267
      tmp___4 = 0;
    } else {
#line 1267
      tmp___4 = 1;
    }
#line 1267
    if (tmp___4) {
      {
#line 1268
      tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1268
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s]: (%s)%d: attempting to compress basis.",
                  dy_sys->nme, tmp___2, dy_lp->tot.iters);
      }
    } else {
      {
#line 1273
      tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1273
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s]: (%s)%d: forcing basis expansion.",
                  dy_sys->nme, tmp___3, dy_lp->tot.iters);
      }
    }
  }
#line 1277
  retval = (dyret_enum )1;
#line 1278
  goto switch_break___0;
  case_neg_10: /* CIL Label */ 
  {
#line 1280
  errmsg(343, rtnnme, dy_sys->nme, dy_lp->tot.iters);
  }
#line 1281
  return ((dyret_enum )-10);
  switch_default___0: /* CIL Label */ 
  {
#line 1283
  errmsg(1, rtnnme, 1283);
  }
#line 1284
  return ((dyret_enum )-10);
  switch_break___0: /* CIL Label */ ;
  }
#line 1316
  if (dy_lp->basis.etas >= dy_opts->factor) {
    {
#line 1317
    checkflags |= (unsigned int )(1 << 8);
#line 1318
    dy_checkpivtol();
    }
#line 1320
    if (print >= 2) {
      {
#line 1321
      tmp___5 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1321
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s] (%s)%d: scheduled refactor, interval %d, ",
                  dy_sys->nme, tmp___5, dy_lp->tot.iters, dy_opts->factor);
#line 1325
      dyio_outfmt(dy_logchn, dy_gtxecho, "%d pivots since last refactor,", dy_lp->basis.etas);
      }
#line 1327
      if ((unsigned int )dy_lp->phase == 4U) {
        {
#line 1328
        tmp___6 = dy_calcdualobj();
#line 1328
        dyio_outfmt(dy_logchn, dy_gtxecho, "yb = %g.", tmp___6);
        }
      } else
#line 1330
      if ((unsigned int )dy_lp->phase == 2U) {
        {
#line 1331
        tmp___7 = dy_calcpinfeas();
#line 1331
        dyio_outfmt(dy_logchn, dy_gtxecho, "infeas = %g.", tmp___7);
        }
      } else {
        {
#line 1333
        tmp___8 = dy_calcobj();
#line 1333
        dyio_outfmt(dy_logchn, dy_gtxecho, "cx = %g.", tmp___8);
        }
      }
    }
  }
#line 1336
  if (dy_lp->basis.etas % dy_opts->check == 0) {
#line 1336
    if (dy_lp->basis.etas != 0) {
#line 1336
      goto _L;
    } else {
#line 1336
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1336
    if (checkflags & (unsigned int )(1 << 8)) {
#line 1336
      tmp___10 = 1;
    } else {
#line 1336
      tmp___10 = 0;
    }
#line 1336
    if (tmp___10) {
      _L: /* CIL Label */ 
#line 1338
      if ((unsigned int )dy_lp->phase == 2U) {
#line 1339
        checkflags |= (unsigned int )(1 << 1);
      } else
#line 1341
      if ((unsigned int )dy_lp->phase == 3U) {
#line 1342
        checkflags |= (unsigned int )((((1 << 1) | 1) | (1 << 2)) | (1 << 4));
      } else
#line 1344
      if ((unsigned int )dy_lp->phase == 4U) {
#line 1345
        checkflags |= (unsigned int )((((1 << 1) | (1 << 4)) | (1 << 3)) | (1 << 5));
      }
#line 1347
      if (dy_lp->basis.etas % dy_opts->check == 0) {
#line 1347
        if (dy_lp->basis.etas != 0) {
#line 1347
          if (print >= 2) {
            {
#line 1349
            tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1349
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s] (%s)%d: scheduled check, interval %d, ",
                        dy_sys->nme, tmp___9, dy_lp->tot.iters, dy_opts->check);
#line 1353
            dyio_outfmt(dy_logchn, dy_gtxecho, "%d pivots since last refactor.", dy_lp->basis.etas);
            }
          }
        }
      }
    }
  }
#line 1368
  if (checkflags & (unsigned int )(((1 << 8) | (1 << 1)) | (1 << 4))) {
#line 1368
    tmp___27 = 1;
  } else {
#line 1368
    tmp___27 = 0;
  }
#line 1368
  if (tmp___27) {
    {
#line 1369
    accchk = dy_accchk(& checkflags);
    }
#line 1370
    if (! ((int )accchk == 1)) {
#line 1370
      if (! ((int )accchk == 2)) {
#line 1370
        return (accchk);
      }
    }
#line 1371
    if (checkflags & (unsigned int )((1 << 1) | (1 << 4))) {
#line 1371
      tmp___11 = 1;
    } else {
#line 1371
      tmp___11 = 0;
    }
#line 1371
    if (tmp___11) {
#line 1371
      return ((dyret_enum )5);
    }
#line 1372
    if ((int )pivresult != -6) {
      {
#line 1373
      tmp___12 = dy_clrpivrej((int *)((void *)0));
      }
#line 1373
      if ((int )tmp___12 != 1) {
#line 1373
        return ((dyret_enum )-10);
      }
    }
#line 1380
    if (checkflags & (unsigned int )(1 << 8)) {
#line 1380
      tmp___21 = 1;
    } else {
#line 1380
      tmp___21 = 0;
    }
#line 1380
    if (tmp___21) {
#line 1380
      if ((int )retval != 3) {
#line 1381
        if ((int )accchk == 2) {
#line 1382
          retval = (dyret_enum )3;
#line 1384
          if (print >= 1) {
            {
#line 1385
            tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1385
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s] (%s)%d: ", dy_sys->nme,
                        tmp___13, dy_lp->tot.iters);
#line 1388
            dyio_outfmt(dy_logchn, dy_gtxecho, "forcing reselect after basis patch.");
            }
          }
        } else {
#line 1393
          if ((unsigned int )dy_lp->phase == 2U) {
#line 1393
            goto _L___3;
          } else
#line 1393
          if ((unsigned int )dy_lp->phase == 3U) {
            _L___3: /* CIL Label */ 
#line 1393
            if (xjcand > 0) {
#line 1395
              statcand = *(dy_status + xjcand);
#line 1396
              cbarcand = *(dy_cbar + xjcand);
#line 1397
              if (cbarcand + dy_tols->dfeas < (double )0) {
#line 1397
                if (statcand & (unsigned int )(((1 << 7) | (1 << 8)) | (1 << 9))) {
#line 1397
                  tmp___14 = 1;
                } else {
#line 1397
                  tmp___14 = 0;
                }
#line 1397
                if (! tmp___14) {
#line 1397
                  goto _L___1;
                }
              } else
              _L___1: /* CIL Label */ 
#line 1397
              if (cbarcand - dy_tols->dfeas > (double )0) {
#line 1397
                if (statcand & (unsigned int )(((1 << 6) | (1 << 8)) | (1 << 9))) {
#line 1397
                  tmp___15 = 1;
                } else {
#line 1397
                  tmp___15 = 0;
                }
#line 1397
                if (! tmp___15) {
#line 1401
                  retval = (dyret_enum )3;
                }
              } else {
#line 1401
                retval = (dyret_enum )3;
              }
            } else {
#line 1393
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 1403
          if ((unsigned int )dy_lp->phase == 4U) {
#line 1403
            if (xicand > 0) {
#line 1404
              statcand = *(dy_status + xicand);
#line 1405
              if (statcand & (unsigned int )((1 << 11) | (1 << 10))) {
#line 1405
                tmp___16 = 0;
              } else {
#line 1405
                tmp___16 = 1;
              }
#line 1405
              if (tmp___16) {
#line 1406
                retval = (dyret_enum )3;
              }
            }
          }
#line 1408
          if (print >= 1) {
#line 1408
            if ((int )retval == 3) {
              {
#line 1409
              tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1409
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s] (%s)%d: ", dy_sys->nme,
                          tmp___17, dy_lp->tot.iters);
              }
#line 1412
              if ((unsigned int )dy_lp->phase == 4U) {
#line 1412
                tmp___18 = xicand;
              } else {
#line 1412
                tmp___18 = xjcand;
              }
#line 1412
              if ((unsigned int )dy_lp->phase == 4U) {
#line 1412
                tmp___19 = xicand;
              } else {
#line 1412
                tmp___19 = xjcand;
              }
              {
#line 1412
              tmp___20 = consys_nme(dy_sys, (char )'v', tmp___19, (bool )0, (char *)((void *)0));
#line 1412
              dyio_outfmt(dy_logchn, dy_gtxecho, "candidate %s (%d) no longer suitable; ",
                          tmp___20, tmp___18);
#line 1417
              dyio_outfmt(dy_logchn, dy_gtxecho, "forcing reselect after refactor.");
              }
            }
          }
        }
      }
    }
#line 1429
    if (checkflags & (unsigned int )(1 | (1 << 3))) {
#line 1429
      tmp___26 = 1;
    } else {
#line 1429
      tmp___26 = 0;
    }
#line 1429
    if (tmp___26) {
#line 1430
      if ((unsigned int )dy_lp->phase == 4U) {
#line 1431
        if (checkflags & (unsigned int )(1 << 3)) {
#line 1431
          tmp___23 = 1;
        } else {
#line 1431
          tmp___23 = 0;
        }
#line 1431
        if (tmp___23) {
#line 1432
          return ((dyret_enum )-3);
        } else {
#line 1434
          if (checkflags & 1U) {
#line 1434
            tmp___22 = 1;
          } else {
#line 1434
            tmp___22 = 0;
          }
#line 1434
          if (tmp___22) {
#line 1435
            return ((dyret_enum )-4);
          }
        }
      } else {
#line 1437
        if (checkflags & 1U) {
#line 1437
          tmp___25 = 1;
        } else {
#line 1437
          tmp___25 = 0;
        }
#line 1437
        if (tmp___25) {
#line 1438
          return ((dyret_enum )-4);
        } else {
#line 1440
          if (checkflags & (unsigned int )(1 << 3)) {
#line 1440
            tmp___24 = 1;
          } else {
#line 1440
            tmp___24 = 0;
          }
#line 1440
          if (tmp___24) {
#line 1441
            return ((dyret_enum )-3);
          }
        }
      }
    }
#line 1442
    if ((int )retval == 4) {
#line 1442
      retval = (dyret_enum )1;
    }
  }
#line 1459
  if ((int )pivok == 1) {
    {
#line 1460
    tmp___29 = fabs(dy_lp->z - dy_lp->lastz.piv);
    }
#line 1460
    if (tmp___29 <= dy_tols->dchk) {
#line 1461
      (dy_lp->idlecnt) ++;
#line 1462
      if (dy_lp->idlecnt > dy_opts->idlelim) {
        {
#line 1463
        tmp___28 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1463
        errmsg(339, rtnnme, dy_sys->nme, tmp___28, dy_lp->tot.iters, dy_lp->idlecnt);
        }
#line 1465
        return ((dyret_enum )-8);
      }
    } else {
#line 1467
      dy_lp->lastz.piv = dy_lp->z;
#line 1468
      dy_lp->idlecnt = 0;
    }
  }
#line 1473
  if ((int )pivresult == 7) {
#line 1473
    if ((int )retval == 1) {
#line 1473
      retval = (dyret_enum )7;
    }
  }
#line 1477
  return (retval);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 548 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
double consys_dotrow(consys_struct *consys , int rowndx , double *vec ) ;
#line 1708 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
int *dy_actvars ;
#line 1708
int *dy_actcons ;
#line 1708
int *dy_origvars ;
#line 1708
int *dy_origcons ;
#line 1723
bool dy_isscaled(void) ;
#line 1724
void dy_scaling_vectors(double const   **rscale , double const   **cscale ) ;
#line 1725
consys_struct *dy_scaled_origsys(void) ;
#line 1928
void dy_colDuals(lpprob_struct *orig_lp , double **p_cbar , bool trueDuals ) ;
#line 1930
void dy_rowDuals(lpprob_struct *orig_lp , double **p_y , bool trueDuals ) ;
#line 1933
void dy_colPrimals(lpprob_struct *orig_lp , double **p_x ) ;
#line 1934
void dy_rowPrimals(lpprob_struct *orig_lp , double **p_xB , int **p_indB ) ;
#line 1936
void dy_logPrimals(lpprob_struct *orig_lp , double **p_logx ) ;
#line 1938
void dy_colStatus(lpprob_struct *orig_lp , flags **p_colstat ) ;
#line 1939
void dy_logStatus(lpprob_struct *orig_lp , flags **p_logstat ) ;
#line 1941
bool dy_expandxopt(lpprob_struct *lp , double **p_xopt ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_colDuals(lpprob_struct *orig_lp , double **p_cbar , bool trueDuals ) 
{ 
  int i ;
  int j ;
  int m ;
  int n ;
  int i_orig ;
  int j_orig ;
  int m_orig ;
  int n_orig ;
  flags statj ;
  consys_struct *orig_sys ;
  double *orig_y ;
  consys_struct *scaled_orig_sys ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  double cbarj ;
  double *cbar ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;

  {
  {
#line 185
  scaled = dy_isscaled();
  }
#line 186
  if ((int )scaled == 1) {
    {
#line 187
    dy_scaling_vectors(& rscale, & cscale);
#line 188
    scaled_orig_sys = dy_scaled_origsys();
    }
  } else {
#line 190
    scaled_orig_sys = (consys_struct *)((void *)0);
  }
#line 192
  orig_sys = orig_lp->consys;
#line 193
  n_orig = orig_sys->varcnt;
#line 194
  m_orig = orig_sys->concnt;
#line 195
  n = dy_sys->varcnt;
#line 196
  m = dy_sys->concnt;
#line 200
  if ((unsigned long )*p_cbar != (unsigned long )((void *)0)) {
    {
#line 201
    cbar = *p_cbar;
#line 202
    memset((void *)cbar, 0, (unsigned long )(n_orig + 1) * sizeof(double ));
    }
  } else {
    {
#line 204
    tmp = calloc((size_t )(n_orig + 1), sizeof(double ));
#line 204
    cbar = (double *)tmp;
    }
  }
  {
#line 209
  tmp___0 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 209
  orig_y = (double *)tmp___0;
#line 210
  i = 1;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i <= m)) {
#line 210
      goto while_break;
    }
#line 211
    i_orig = *(dy_actcons + i);
#line 212
    *(orig_y + i_orig) = *(dy_y + i);
#line 210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  j_orig = 1;
  {
#line 220
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 220
    if (! (j_orig <= n_orig)) {
#line 220
      goto while_break___0;
    }
#line 221
    if (*(dy_origvars + j_orig) > 0) {
#line 222
      j = *(dy_origvars + j_orig);
#line 223
      statj = *(dy_status + j) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 224
      if (statj & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 224
        tmp___1 = 1;
      } else {
#line 224
        tmp___1 = 0;
      }
#line 224
      if (tmp___1) {
#line 225
        cbarj = 0.0;
      } else
#line 227
      if ((int )scaled == 1) {
#line 228
        cbarj = *(dy_cbar + j) / (double )*(cscale + j_orig);
      } else {
#line 230
        cbarj = *(dy_cbar + j);
      }
    } else {
#line 232
      statj = (flags )(- *(dy_origvars + j_orig));
#line 233
      if ((int )scaled == 1) {
        {
#line 234
        cbarj = *(scaled_orig_sys->obj + j_orig);
#line 235
        tmp___2 = consys_dotcol(scaled_orig_sys, j_orig, orig_y);
#line 235
        cbarj -= tmp___2;
#line 236
        cbarj /= (double )*(cscale + j_orig);
        }
      } else {
        {
#line 238
        cbarj = *(orig_sys->obj + j_orig);
#line 239
        tmp___3 = consys_dotcol(orig_sys, j_orig, orig_y);
#line 239
        cbarj -= tmp___3;
        }
      }
    }
    {
#line 240
    tmp___4 = fabs(cbarj);
    }
#line 240
    if (tmp___4 < dy_tols->cost) {
#line 240
      cbarj = (double )0;
    }
#line 246
    if ((int )trueDuals == 1) {
#line 247
      if (statj & (unsigned int )(1 << 6)) {
#line 247
        tmp___5 = 1;
      } else {
#line 247
        tmp___5 = 0;
      }
#line 247
      if (tmp___5) {
#line 248
        *(cbar + j_orig) = - cbarj;
      } else {
#line 250
        *(cbar + j_orig) = cbarj;
      }
    } else {
#line 252
      *(cbar + j_orig) = cbarj;
    }
#line 220
    j_orig ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 256
  if ((unsigned long )orig_y != (unsigned long )((void *)0)) {
    {
#line 256
    free((void *)orig_y);
    }
  }
#line 257
  *p_cbar = cbar;
#line 259
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_rowDuals(lpprob_struct *orig_lp , double **p_y , bool trueDuals ) 
{ 
  int i ;
  int m ;
  int n ;
  int i_orig ;
  int m_orig ;
  int n_orig ;
  double yi ;
  double *y ;
  consys_struct *orig_sys ;
  contyp_enum *ctyp ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  int j ;
  int v ;
  void *tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 322
  scaled = dy_isscaled();
  }
#line 323
  if ((int )scaled == 1) {
    {
#line 324
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 326
  orig_sys = orig_lp->consys;
#line 327
  n_orig = orig_sys->varcnt;
#line 328
  m_orig = orig_sys->concnt;
#line 329
  n = dy_sys->varcnt;
#line 330
  m = dy_sys->concnt;
#line 331
  ctyp = orig_sys->ctyp;
#line 335
  if ((unsigned long )*p_y != (unsigned long )((void *)0)) {
    {
#line 336
    y = *p_y;
#line 337
    memset((void *)y, 0, (unsigned long )(m_orig + 1) * sizeof(double ));
    }
  } else {
    {
#line 339
    tmp = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 339
    y = (double *)tmp;
    }
  }
#line 344
  i_orig = 1;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (i_orig <= m_orig)) {
#line 344
      goto while_break;
    }
#line 345
    if (*(dy_origcons + i_orig) > 0) {
#line 346
      i = *(dy_origcons + i_orig);
#line 347
      yi = *(dy_y + i);
#line 348
      if ((int )scaled == 1) {
#line 349
        yi *= (double )*(rscale + i_orig);
      }
      {
#line 350
      tmp___0 = fabs(yi);
      }
#line 350
      if (tmp___0 < dy_tols->cost) {
#line 350
        yi = (double )0;
      }
    } else {
#line 352
      yi = 0.0;
    }
#line 356
    if ((int )trueDuals == 1) {
#line 357
      *(y + i_orig) = - yi;
    } else {
#line 359
      *(y + i_orig) = yi;
    }
#line 344
    i_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if (dy_opts->print.soln >= 3) {
    {
#line 363
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\ty =");
#line 364
    v = 0;
#line 365
    i_orig = 1;
    }
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (i_orig <= m_orig)) {
#line 365
        goto while_break___0;
      }
#line 366
      if (*(y + i_orig) != (double )0) {
#line 367
        v ++;
#line 367
        if (v % 3 == 0) {
          {
#line 368
          v = 0;
#line 369
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
          }
        }
        {
#line 370
        i = *(dy_origcons + i_orig);
#line 371
        j = *(dy_basis + i);
#line 372
        tmp___1 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 372
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%d %g %s %d)", i_orig, *(y + i_orig),
                    tmp___1, j);
        }
      }
#line 365
      i_orig ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 380
  *p_y = y;
#line 382
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_colPrimals(lpprob_struct *orig_lp , double **p_x ) 
{ 
  int j ;
  int j_orig ;
  int n_orig ;
  double xj ;
  flags statj ;
  consys_struct *orig_sys ;
  double *x ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  char *rtnnme ;
  int v ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 420
  rtnnme = (char *)"dy_colPrimals";
#line 438
  scaled = dy_isscaled();
  }
#line 439
  if ((int )scaled == 1) {
    {
#line 440
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 442
  orig_sys = orig_lp->consys;
#line 443
  n_orig = orig_sys->varcnt;
#line 447
  if ((unsigned long )*p_x != (unsigned long )((void *)0)) {
    {
#line 448
    x = *p_x;
#line 449
    memset((void *)x, 0, (unsigned long )(n_orig + 1) * sizeof(double ));
    }
  } else {
    {
#line 451
    tmp = calloc((size_t )(n_orig + 1), sizeof(double ));
#line 451
    x = (double *)tmp;
    }
  }
#line 458
  j_orig = 1;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (j_orig <= n_orig)) {
#line 458
      goto while_break;
    }
#line 459
    if (*(dy_origvars + j_orig) > 0) {
#line 460
      j = *(dy_origvars + j_orig);
#line 461
      if ((int )scaled == 1) {
#line 462
        xj = (double )(*(cscale + j_orig) * (double const   )*(dy_x + j));
      } else {
#line 464
        xj = *(dy_x + j);
      }
    } else {
#line 466
      statj = (flags )(- *(dy_origvars + j_orig));
      {
#line 469
      if (statj == (flags )(1 << 7)) {
#line 469
        goto case_exp;
      }
#line 469
      if (statj == (flags )(1 << 5)) {
#line 469
        goto case_exp;
      }
#line 472
      if (statj == (flags )(1 << 6)) {
#line 472
        goto case_exp___1;
      }
#line 475
      if (statj == (flags )(1 << 8)) {
#line 475
        goto case_exp___2;
      }
#line 478
      goto switch_default;
      case_exp: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
#line 470
      xj = *(orig_sys->vlb + j_orig);
#line 471
      goto switch_break;
      case_exp___1: /* CIL Label */ 
#line 473
      xj = *(orig_sys->vub + j_orig);
#line 474
      goto switch_break;
      case_exp___2: /* CIL Label */ 
#line 476
      xj = (double )0;
#line 477
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 479
      tmp___0 = dy_prtvstat(statj);
#line 479
      tmp___1 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 479
      warn(359, rtnnme, orig_sys->nme, tmp___1, j_orig, tmp___0);
#line 482
      xj = 0.0;
      }
#line 483
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 485
    tmp___2 = fabs(xj);
    }
#line 485
    if (tmp___2 < dy_tols->zero) {
#line 485
      xj = (double )0;
    }
#line 486
    *(x + j_orig) = xj;
#line 458
    j_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if (dy_opts->print.soln >= 3) {
    {
#line 490
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tx =");
#line 491
    v = 0;
#line 492
    j_orig = 1;
    }
    {
#line 492
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 492
      if (! (j_orig <= n_orig)) {
#line 492
        goto while_break___0;
      }
#line 493
      if (*(x + j_orig) != (double )0) {
#line 494
        v ++;
#line 494
        if (v % 3 == 0) {
          {
#line 495
          v = 0;
#line 496
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
          }
        }
        {
#line 497
        tmp___3 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 497
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%d %g %s)", j_orig, *(x + j_orig), tmp___3);
        }
      }
#line 492
      j_orig ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 505
  *p_x = x;
#line 507
  return;
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_rowPrimals(lpprob_struct *orig_lp , double **p_xB , int **p_indB ) 
{ 
  int i ;
  int j ;
  int m ;
  int i_orig ;
  int j_orig ;
  int m_orig ;
  int n_orig ;
  double xj ;
  double lhs ;
  consys_struct *orig_sys ;
  double *x ;
  double *xB ;
  int *indB ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  int v ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 581
  scaled = dy_isscaled();
  }
#line 582
  if ((int )scaled == 1) {
    {
#line 583
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 585
  orig_sys = orig_lp->consys;
#line 586
  n_orig = orig_sys->varcnt;
#line 587
  m_orig = orig_sys->concnt;
#line 588
  m = dy_sys->concnt;
#line 590
  x = (double *)((void *)0);
#line 591
  if (m < m_orig) {
    {
#line 592
    dy_colPrimals(orig_lp, & x);
    }
  }
#line 597
  if ((unsigned long )*p_xB != (unsigned long )((void *)0)) {
    {
#line 598
    xB = *p_xB;
#line 599
    memset((void *)xB, 0, (unsigned long )(m_orig + 1) * sizeof(double ));
    }
  } else {
    {
#line 601
    tmp = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 601
    xB = (double *)tmp;
    }
  }
#line 602
  if ((unsigned long )*p_indB != (unsigned long )((void *)0)) {
    {
#line 603
    indB = *p_indB;
#line 604
    memset((void *)indB, 0, (unsigned long )(m_orig + 1) * sizeof(int ));
    }
  } else {
    {
#line 606
    tmp___0 = calloc((size_t )(m_orig + 1), sizeof(int ));
#line 606
    indB = (int *)tmp___0;
    }
  }
#line 615
  i_orig = 1;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i_orig <= m_orig)) {
#line 615
      goto while_break;
    }
#line 616
    if (*(dy_origcons + i_orig) > 0) {
#line 617
      i = *(dy_origcons + i_orig);
#line 618
      j = *(dy_basis + i);
#line 619
      if (j <= m) {
#line 620
        j_orig = *(dy_actcons + j);
      } else {
#line 622
        j_orig = *(dy_actvars + j);
      }
#line 623
      if ((int )scaled == 1) {
#line 624
        if (j <= m) {
#line 625
          xj = (double )(((double const   )1 / *(rscale + j_orig)) * (double const   )*(dy_xbasic + i));
        } else {
#line 627
          xj = (double )(*(cscale + j_orig) * (double const   )*(dy_xbasic + i));
        }
      } else {
#line 629
        xj = *(dy_xbasic + i);
      }
#line 630
      if (j <= m) {
#line 631
        *(indB + i_orig) = - j_orig;
      } else {
#line 633
        *(indB + i_orig) = j_orig;
      }
    } else {
      {
#line 635
      lhs = consys_dotrow(orig_sys, i_orig, x);
#line 636
      xj = *(orig_sys->rhs + i_orig) - lhs;
#line 637
      *(indB + i_orig) = - i_orig;
      }
    }
    {
#line 639
    tmp___1 = fabs(xj);
    }
#line 639
    if (tmp___1 < dy_tols->zero) {
#line 639
      xj = (double )0;
    }
#line 640
    *(xB + i_orig) = xj;
#line 615
    i_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  if ((unsigned long )x != (unsigned long )((void *)0)) {
    {
#line 642
    free((void *)x);
    }
  }
#line 645
  if (dy_opts->print.soln >= 3) {
    {
#line 646
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\txB =");
#line 647
    v = 0;
#line 648
    i_orig = 1;
    }
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 648
      if (! (i_orig <= m_orig)) {
#line 648
        goto while_break___0;
      }
#line 649
      v ++;
#line 649
      if (v % 3 == 0) {
        {
#line 650
        v = 0;
#line 651
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
        }
      }
#line 652
      j_orig = *(indB + i_orig);
#line 653
      if (j_orig < 0) {
#line 654
        j = n_orig - j_orig;
      } else {
#line 656
        j = j_orig;
      }
      {
#line 657
      tmp___2 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 657
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%d %g %s %d)", i_orig, *(xB + i_orig),
                  tmp___2, j_orig);
#line 648
      i_orig ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 665
  *p_xB = xB;
#line 666
  *p_indB = indB;
#line 668
  return;
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_logPrimals(lpprob_struct *orig_lp , double **p_logx ) 
{ 
  int j ;
  int m ;
  int i_orig ;
  int m_orig ;
  double xj ;
  double lhs ;
  consys_struct *orig_sys ;
  double *logx ;
  double *x ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  int v ;
  int n_orig ;
  void *tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 727
  scaled = dy_isscaled();
  }
#line 728
  if ((int )scaled == 1) {
    {
#line 729
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 731
  orig_sys = orig_lp->consys;
#line 732
  m_orig = orig_sys->concnt;
#line 733
  m = dy_sys->concnt;
#line 735
  x = (double *)((void *)0);
#line 736
  if (m < m_orig) {
    {
#line 737
    dy_colPrimals(orig_lp, & x);
    }
  }
#line 741
  if ((unsigned long )*p_logx != (unsigned long )((void *)0)) {
    {
#line 742
    logx = *p_logx;
#line 743
    memset((void *)logx, 0, (unsigned long )(m_orig + 1) * sizeof(double ));
    }
  } else {
    {
#line 745
    tmp = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 745
    logx = (double *)tmp;
    }
  }
#line 752
  i_orig = 1;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (i_orig <= m_orig)) {
#line 752
      goto while_break;
    }
#line 753
    if (*(dy_origcons + i_orig) > 0) {
#line 754
      j = *(dy_origcons + i_orig);
#line 755
      if ((int )scaled == 1) {
#line 756
        xj = (double )(((double const   )1 / *(rscale + i_orig)) * (double const   )*(dy_x + j));
      } else {
#line 758
        xj = *(dy_x + j);
      }
    } else {
      {
#line 760
      lhs = consys_dotrow(orig_sys, i_orig, x);
#line 761
      xj = *(orig_sys->rhs + i_orig) - lhs;
      }
    }
    {
#line 763
    tmp___0 = fabs(xj);
    }
#line 763
    if (tmp___0 < dy_tols->zero) {
#line 763
      xj = (double )0;
    }
#line 764
    *(logx + i_orig) = xj;
#line 752
    i_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  if ((unsigned long )x != (unsigned long )((void *)0)) {
    {
#line 766
    free((void *)x);
    }
  }
#line 769
  if (dy_opts->print.soln >= 3) {
    {
#line 770
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tlogx =");
#line 771
    n_orig = orig_sys->varcnt;
#line 772
    v = 0;
#line 773
    i_orig = 1;
    }
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! (i_orig <= m_orig)) {
#line 773
        goto while_break___0;
      }
#line 774
      if (*(logx + i_orig) != (double )0) {
#line 775
        v ++;
#line 775
        if (v % 3 == 0) {
          {
#line 776
          v = 0;
#line 777
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
          }
        }
        {
#line 778
        tmp___1 = consys_nme(orig_sys, (char )'v', n_orig + i_orig, (bool )0, (char *)((void *)0));
#line 778
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%d %g %s)", i_orig, *(logx + i_orig),
                    tmp___1);
        }
      }
#line 773
      i_orig ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 786
  *p_logx = logx;
#line 788
  return;
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_colStatus(lpprob_struct *orig_lp , flags **p_colstat ) 
{ 
  int j ;
  int j_orig ;
  int n_orig ;
  flags statj ;
  consys_struct *orig_sys ;
  flags *colstat ;
  int v ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 829
  orig_sys = orig_lp->consys;
#line 830
  n_orig = orig_sys->varcnt;
#line 834
  if ((unsigned long )*p_colstat != (unsigned long )((void *)0)) {
    {
#line 835
    colstat = *p_colstat;
#line 836
    memset((void *)colstat, 0, (unsigned long )(n_orig + 1) * sizeof(flags ));
    }
  } else {
    {
#line 838
    tmp = calloc((size_t )(n_orig + 1), sizeof(flags ));
#line 838
    colstat = (flags *)tmp;
    }
  }
#line 844
  j_orig = 1;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (j_orig <= n_orig)) {
#line 844
      goto while_break;
    }
#line 845
    if (*(dy_origvars + j_orig) > 0) {
#line 846
      j = *(dy_origvars + j_orig);
#line 847
      statj = *(dy_status + j);
    } else {
#line 849
      statj = (flags )(- *(dy_origvars + j_orig));
    }
#line 850
    *(colstat + j_orig) = statj;
#line 844
    j_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  if (dy_opts->print.soln >= 3) {
    {
#line 854
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tcolstat =");
#line 855
    v = 0;
#line 856
    j_orig = 1;
    }
    {
#line 856
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 856
      if (! (j_orig <= n_orig)) {
#line 856
        goto while_break___0;
      }
#line 857
      v ++;
#line 857
      if (v % 3 == 0) {
        {
#line 858
        v = 0;
#line 859
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
        }
      }
      {
#line 860
      tmp___0 = dy_prtvstat(*(colstat + j_orig));
#line 860
      tmp___1 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 860
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %s)", tmp___1, j_orig, tmp___0);
#line 856
      j_orig ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 868
  *p_colstat = colstat;
#line 870
  return;
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_logStatus(lpprob_struct *orig_lp , flags **p_logstat ) 
{ 
  int i ;
  int m ;
  int i_orig ;
  int m_orig ;
  flags stati ;
  double rhsi ;
  double rhslowi ;
  double lhsi ;
  double xi ;
  double lbi ;
  double ubi ;
  consys_struct *orig_sys ;
  flags *logstat ;
  double *x ;
  char *rtnnme ;
  int v ;
  int n_orig ;
  void *tmp ;
  double tmp___0 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;

  {
#line 906
  rtnnme = (char *)"dy_logStatus";
#line 920
  orig_sys = orig_lp->consys;
#line 921
  m_orig = orig_sys->concnt;
#line 922
  m = dy_sys->concnt;
#line 927
  x = (double *)((void *)0);
#line 928
  if (m < m_orig) {
    {
#line 929
    dy_colPrimals(orig_lp, & x);
    }
  }
#line 933
  if ((unsigned long )*p_logstat != (unsigned long )((void *)0)) {
    {
#line 934
    logstat = *p_logstat;
#line 935
    memset((void *)logstat, 0, (unsigned long )(m_orig + 1) * sizeof(flags ));
    }
  } else {
    {
#line 937
    tmp = calloc((size_t )(m_orig + 1), sizeof(flags ));
#line 937
    logstat = (flags *)tmp;
    }
  }
#line 952
  i_orig = 1;
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (i_orig <= m_orig)) {
#line 952
      goto while_break;
    }
#line 953
    if (*(dy_origcons + i_orig) > 0) {
#line 954
      i = *(dy_origcons + i_orig);
#line 955
      stati = *(dy_status + i);
    } else {
      {
#line 957
      lhsi = consys_dotrow(orig_sys, i_orig, x);
#line 958
      rhsi = *(orig_sys->rhs + i_orig);
#line 959
      xi = rhsi - lhsi;
#line 960
      tmp___0 = fabs(xi);
      }
#line 960
      if (tmp___0 < dy_tols->zero) {
#line 960
        xi = (double )0;
      }
#line 961
      lbi = - dy_tols->inf;
#line 962
      ubi = dy_tols->inf;
      {
#line 964
      if ((unsigned int )*(orig_sys->ctyp + i_orig) == 4U) {
#line 964
        goto case_4;
      }
#line 967
      if ((unsigned int )*(orig_sys->ctyp + i_orig) == 3U) {
#line 967
        goto case_3;
      }
#line 971
      if ((unsigned int )*(orig_sys->ctyp + i_orig) == 2U) {
#line 971
        goto case_2;
      }
#line 974
      if ((unsigned int )*(orig_sys->ctyp + i_orig) == 5U) {
#line 974
        goto case_5;
      }
#line 979
      if ((unsigned int )*(orig_sys->ctyp + i_orig) == 1U) {
#line 979
        goto case_1;
      }
#line 981
      goto switch_default;
      case_4: /* CIL Label */ 
#line 965
      lbi = 0.0;
#line 966
      goto switch_break;
      case_3: /* CIL Label */ 
#line 968
      lbi = 0.0;
#line 969
      ubi = 0.0;
#line 970
      goto switch_break;
      case_2: /* CIL Label */ 
#line 972
      ubi = 0.0;
#line 973
      goto switch_break;
      case_5: /* CIL Label */ 
#line 975
      rhslowi = *(orig_sys->rhslow + i_orig);
#line 976
      lbi = (double )0;
#line 977
      ubi = rhsi - rhslowi;
#line 978
      goto switch_break;
      case_1: /* CIL Label */ 
#line 980
      goto __Cont;
      switch_default: /* CIL Label */ 
      {
#line 982
      errmsg(1, rtnnme, 982);
      }
#line 983
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 984
      tmp___14 = fabs(lbi);
      }
#line 984
      if (tmp___14 < dy_tols->inf) {
        {
#line 984
        tmp___12 = fabs(lbi);
#line 984
        tmp___13 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___12);
        }
      } else {
#line 984
        tmp___13 = xi < lbi;
      }
#line 984
      if (tmp___13) {
#line 985
        stati = (flags )(1 << 11);
      } else {
        {
#line 987
        tmp___8 = fabs(lbi);
        }
#line 987
        if (tmp___8 < dy_tols->inf) {
          {
#line 987
          tmp___9 = fabs(xi - lbi);
#line 987
          tmp___10 = fabs(lbi);
          }
#line 987
          if (tmp___9 < dy_tols->pfeas * (1.0 + tmp___10)) {
#line 988
            stati = (flags )(1 << 3);
          } else {
#line 987
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 990
          tmp___5 = fabs(ubi);
          }
#line 990
          if (tmp___5 < dy_tols->inf) {
            {
#line 990
            tmp___6 = fabs(xi - ubi);
#line 990
            tmp___7 = fabs(ubi);
            }
#line 990
            if (tmp___6 < dy_tols->pfeas * (1.0 + tmp___7)) {
#line 991
              stati = (flags )(1 << 1);
            } else {
#line 990
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 993
            tmp___4 = fabs(ubi);
            }
#line 993
            if (tmp___4 < dy_tols->inf) {
              {
#line 993
              tmp___2 = fabs(ubi);
#line 993
              tmp___3 = xi - ubi > dy_tols->pfeas * (1.0 + tmp___2);
              }
            } else {
#line 993
              tmp___3 = xi > ubi;
            }
#line 993
            if (tmp___3) {
#line 994
              stati = (flags )(1 << 10);
            } else {
#line 996
              stati = (flags )(1 << 2);
            }
          }
        }
      }
    }
#line 997
    *(logstat + i_orig) = stati;
    __Cont: /* CIL Label */ 
#line 952
    i_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  if ((unsigned long )x != (unsigned long )((void *)0)) {
    {
#line 999
    free((void *)x);
    }
  }
#line 1002
  if (dy_opts->print.soln >= 3) {
    {
#line 1003
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trowstat =");
#line 1004
    n_orig = orig_sys->varcnt;
#line 1005
    v = 0;
#line 1006
    i_orig = 1;
    }
    {
#line 1006
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1006
      if (! (i_orig <= m_orig)) {
#line 1006
        goto while_break___0;
      }
#line 1007
      v ++;
#line 1007
      if (v % 3 == 0) {
        {
#line 1008
        v = 0;
#line 1009
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
        }
      }
      {
#line 1010
      tmp___15 = dy_prtvstat(*(logstat + i_orig));
#line 1010
      tmp___16 = consys_nme(orig_sys, (char )'v', i_orig + n_orig, (bool )0, (char *)((void *)0));
#line 1010
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %s)", tmp___16, i_orig, tmp___15);
#line 1006
      i_orig ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1018
  *p_logstat = logstat;
#line 1020
  return;
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
void dy_orig_soln(double *x , double *y ) 
{ 
  int i ;
  int j ;
  int i_orig ;
  int j_orig ;
  double xi ;
  double yi ;
  double const   *rscale ;
  double const   *cscale ;
  bool tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1059
  tmp = dy_isscaled();
  }
#line 1059
  if ((int )tmp == 0) {
#line 1059
    return;
  }
  {
#line 1060
  dy_scaling_vectors(& rscale, & cscale);
#line 1065
  i = 1;
  }
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1065
    if (! (i <= dy_sys->concnt)) {
#line 1065
      goto while_break;
    }
#line 1066
    i_orig = *(dy_actcons + i);
#line 1067
    j = *(dy_basis + i);
#line 1068
    xi = *(x + i);
#line 1069
    if (j <= dy_sys->concnt) {
#line 1070
      xi /= (double )*(rscale + i_orig);
    } else {
#line 1072
      j_orig = *(dy_actvars + j);
#line 1073
      xi *= (double )*(cscale + j_orig);
    }
    {
#line 1074
    tmp___0 = fabs(xi);
    }
#line 1074
    if (tmp___0 < dy_tols->zero) {
#line 1074
      xi = (double )0;
    }
    {
#line 1075
    *(x + i) = xi;
#line 1077
    yi = *(y + i);
#line 1078
    yi *= (double )*(rscale + i_orig);
#line 1079
    tmp___1 = fabs(yi);
    }
#line 1079
    if (tmp___1 < dy_tols->cost) {
#line 1079
      yi = (double )0;
    }
#line 1080
    *(y + i) = yi;
#line 1065
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1082
  return;
}
}
#line 1086 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_solutions.c"
bool dy_expandxopt(lpprob_struct *lp , double **p_xopt ) 
{ 
  int j ;
  int jpos ;
  consys_struct *consys ;
  flags *status ;
  flags jstat ;
  double *xopt ;
  char const   *rtnnme ;
  void *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1111
  rtnnme = "dy_expandxopt";
#line 1137
  consys = lp->consys;
#line 1138
  status = lp->status;
#line 1142
  if ((unsigned long )*p_xopt == (unsigned long )((void *)0)) {
    {
#line 1143
    tmp = malloc((unsigned long )(consys->varcnt + 1) * sizeof(double ));
#line 1143
    xopt = (double *)tmp;
    }
  } else {
#line 1145
    xopt = *p_xopt;
  }
#line 1147
  j = 1;
  {
#line 1147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1147
    if (! (j <= consys->varcnt)) {
#line 1147
      goto while_break;
    }
#line 1148
    if ((int )*(status + j) < 0) {
#line 1149
      jstat = (flags )(1 << 2);
#line 1150
      jpos = - ((int )*(status + j));
#line 1151
      *(xopt + j) = *(lp->x + jpos);
    } else {
#line 1153
      jstat = *(status + j);
      {
#line 1156
      if (jstat == (flags )(1 << 7)) {
#line 1156
        goto case_exp;
      }
#line 1156
      if (jstat == (flags )(1 << 5)) {
#line 1156
        goto case_exp;
      }
#line 1159
      if (jstat == (flags )(1 << 6)) {
#line 1159
        goto case_exp___1;
      }
#line 1162
      if (jstat == (flags )(1 << 8)) {
#line 1162
        goto case_exp___2;
      }
#line 1165
      goto switch_default;
      case_exp: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
#line 1157
      *(xopt + j) = *(consys->vlb + j);
#line 1158
      goto switch_break;
      case_exp___1: /* CIL Label */ 
#line 1160
      *(xopt + j) = *(consys->vub + j);
#line 1161
      goto switch_break;
      case_exp___2: /* CIL Label */ 
#line 1163
      *(xopt + j) = (double )0;
#line 1164
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1166
      tmp___0 = dy_prtvstat(jstat);
#line 1166
      tmp___1 = consys_nme(consys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1166
      errmsg(359, rtnnme, consys->nme, tmp___1, j, tmp___0);
      }
#line 1168
      if ((unsigned long )*p_xopt == (unsigned long )((void *)0)) {
        {
#line 1168
        free((void *)xopt);
        }
      }
#line 1169
      return ((bool )0);
      switch_break: /* CIL Label */ ;
      }
    }
#line 1147
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1171
  *p_xopt = xopt;
#line 1173
  return ((bool )1);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_strrtns.c"
int cistrcmp(char const   *str1 , char const   *str2 ) 
{ 
  char cnv1 ;
  char cnv2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if ((int const   )*str1 == 0) {
#line 43
      if ((int const   )*str2 == 0) {
#line 43
        goto while_break;
      }
    }
#line 44
    if ((int const   )*str1 >= 97) {
#line 44
      if ((int const   )*str1 <= 122) {
#line 45
        tmp = str1;
#line 45
        str1 ++;
#line 45
        cnv1 = (char )((int const   )*tmp - 32);
      } else {
#line 47
        tmp___0 = str1;
#line 47
        str1 ++;
#line 47
        cnv1 = (char )*tmp___0;
      }
    } else {
#line 47
      tmp___0 = str1;
#line 47
      str1 ++;
#line 47
      cnv1 = (char )*tmp___0;
    }
#line 48
    if ((int const   )*str2 >= 97) {
#line 48
      if ((int const   )*str2 <= 122) {
#line 49
        tmp___1 = str2;
#line 49
        str2 ++;
#line 49
        cnv2 = (char )((int const   )*tmp___1 - 32);
      } else {
#line 51
        tmp___2 = str2;
#line 51
        str2 ++;
#line 51
        cnv2 = (char )*tmp___2;
      }
    } else {
#line 51
      tmp___2 = str2;
#line 51
      str2 ++;
#line 51
      cnv2 = (char )*tmp___2;
    }
#line 52
    if ((int )cnv1 < (int )cnv2) {
#line 53
      return (-1);
    }
#line 54
    if ((int )cnv1 > (int )cnv2) {
#line 55
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_strrtns.c"
int cimstrcmp(char const   *str1 , char const   *str2 ) 
{ 
  char cnv1 ;
  char cnv2 ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if ((int const   )*str1 == 0) {
#line 79
      if ((int const   )*str2 == 0) {
#line 79
        goto while_break;
      }
    }
#line 80
    if ((int const   )*str1 >= 97) {
#line 80
      if ((int const   )*str1 <= 122) {
#line 81
        tmp = str1;
#line 81
        str1 ++;
#line 81
        cnv1 = (char )((int const   )*tmp - 32);
      } else {
#line 83
        tmp___0 = str1;
#line 83
        str1 ++;
#line 83
        cnv1 = (char )*tmp___0;
      }
    } else {
#line 83
      tmp___0 = str1;
#line 83
      str1 ++;
#line 83
      cnv1 = (char )*tmp___0;
    }
#line 84
    if ((int const   )*str2 >= 97) {
#line 84
      if ((int const   )*str2 <= 122) {
#line 85
        tmp___1 = str2;
#line 85
        str2 ++;
#line 85
        cnv2 = (char )((int const   )*tmp___1 - 32);
      } else {
#line 87
        tmp___2 = str2;
#line 87
        str2 ++;
#line 87
        cnv2 = (char )*tmp___2;
      }
    } else {
#line 87
      tmp___2 = str2;
#line 87
      str2 ++;
#line 87
      cnv2 = (char )*tmp___2;
    }
#line 88
    if ((int )cnv1 < (int )cnv2) {
#line 89
      if ((int )cnv1 == 0) {
#line 90
        return (0);
      } else {
#line 92
        return (-1);
      }
    }
#line 93
    if ((int )cnv1 > (int )cnv2) {
#line 94
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_strrtns.c"
int mstrcmp(char const   *str1 , char const   *str2 ) 
{ 


  {
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if ((int const   )*str1 == 0) {
#line 116
      if ((int const   )*str2 == 0) {
#line 116
        goto while_break;
      }
    }
#line 117
    if ((int const   )*str1 < (int const   )*str2) {
#line 118
      if ((int const   )*str1 == 0) {
#line 119
        return (0);
      } else {
#line 121
        return (-1);
      }
    }
#line 122
    if ((int const   )*str1 > (int const   )*str2) {
#line 123
      return (1);
    }
#line 116
    str1 ++;
#line 116
    str2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_strrtns.c"
char *strsave(char const   *original ) 
{ 
  char *copy ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 144
  tmp = strlen(original);
#line 144
  tmp___0 = malloc(tmp + 1UL);
#line 144
  copy = (char *)tmp___0;
  }
#line 145
  if ((unsigned long )copy != (unsigned long )((void *)0)) {
    {
#line 146
    strcpy((char */* __restrict  */)copy, (char const   */* __restrict  */)original);
    }
  }
#line 147
  return (copy);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 516 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_addcol_pk(consys_struct *consys , vartyp_enum vartyp , pkvec_struct *pkcol ,
                      double obj , double vlb , double vub ) ;
#line 516
bool consys_getcol_ex(consys_struct *consys , int colndx , double **vec ) ;
#line 516
bool consys_delcol(consys_struct *consys , int colndx ) ;
#line 1708 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
int *dy_var2basis ;
#line 1712
double *dy_gamma ;
#line 1713
bool *dy_frame ;
#line 1753
void dy_ftran(double *col , bool save ) ;
#line 1783
bool dy_actNBPrimArch(consys_struct *orig_sys , int ovndx ) ;
#line 1783
bool dy_actNBPrimArchList(consys_struct *orig_sys , int cnt , int *ovndxs ) ;
#line 1783
bool dy_deactBPrimArch(consys_struct *orig_sys , int j ) ;
#line 1783
bool dy_deactNBPrimArch(consys_struct *orig_sys , int j ) ;
#line 1788
int dy_deactivateVars(consys_struct *orig_sys ) ;
#line 1788
int dy_activateVars(consys_struct *orig_sys , int *preset ) ;
#line 1825
bool dy_initp1obj(void) ;
#line 1825
bool dy_swapobjs(dyphase_enum phase ) ;
#line 1871
bool dy_calccbar(void) ;
#line 1873
void dy_calcduals(void) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
static int intcompare(void const   *p_i , void const   *p_j ) 
{ 
  int i ;
  int j ;

  {
#line 95
  i = (int )*((int const   *)p_i);
#line 96
  j = (int )*((int const   *)p_j);
#line 97
  return (j - i);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
static bool prepcol_pk(consys_struct *orig_sys , int oxjndx , pkvec_struct **p_aj ) 
{ 
  int pkndx ;
  int ocndx ;
  int cndx ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 122
  rtnnme = "prepcol_pk";
#line 147
  tmp___0 = consys_getcol_pk(orig_sys, oxjndx, p_aj);
  }
#line 147
  if ((int )tmp___0 == 0) {
    {
#line 148
    tmp = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 148
    errmsg(122, rtnnme, orig_sys->nme, "column", tmp, oxjndx);
    }
#line 150
    return ((bool )0);
  }
#line 151
  aj = *p_aj;
#line 156
  pkndx = 0;
#line 156
  aij = aj->coeffs;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (pkndx < aj->cnt)) {
#line 156
      goto while_break;
    }
#line 157
    ocndx = aij->ndx;
#line 158
    if (*(dy_origcons + ocndx) <= 0) {
#line 159
      cndx = *(dy_origcons + ocndx);
#line 161
      if (dy_opts->print.varmgmt >= 4) {
        {
#line 162
        tmp___1 = consys_nme(orig_sys, (char )'c', ocndx, (bool )0, (char *)((void *)0));
#line 162
        tmp___2 = consys_prtcontyp(*(orig_sys->ctyp + ocndx));
#line 162
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tdeleting a<%d,%d> = %g; %s constraint %s inactive.",
                    ocndx, oxjndx, aij->val, tmp___2, tmp___1);
        }
      }
#line 168
      (aj->cnt) --;
#line 169
      if (pkndx < aj->cnt) {
#line 170
        aij->ndx = (aj->coeffs + aj->cnt)->ndx;
#line 171
        aij->val = (aj->coeffs + aj->cnt)->val;
      }
    } else {
#line 173
      cndx = *(dy_origcons + ocndx);
#line 175
      if (dy_opts->print.varmgmt >= 4) {
        {
#line 176
        tmp___3 = consys_nme(orig_sys, (char )'c', ocndx, (bool )0, (char *)((void *)0));
#line 176
        tmp___4 = consys_prtcontyp(*(orig_sys->ctyp + ocndx));
#line 176
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\ta<%d,%d> = %g becomes a<%d,%d>; %s constraint %s active.",
                    ocndx, oxjndx, aij->val, cndx, oxjndx, tmp___4, tmp___3);
        }
      }
#line 182
      aij->ndx = cndx;
#line 183
      pkndx ++;
#line 184
      aij ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return ((bool )1);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
bool dy_actNBPrimArch(consys_struct *orig_sys , int ovndx ) 
{ 
  int pkndx ;
  int i ;
  int j ;
  double valj ;
  double cj ;
  double lbj ;
  double ubj ;
  flags statj ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
  {
#line 220
  rtnnme = "dy_actNBPrimArch";
#line 251
  statj = (flags )(- *(dy_origvars + ovndx));
#line 268
  aj = (pkvec_struct *)((void *)0);
#line 269
  tmp___1 = prepcol_pk(orig_sys, ovndx, & aj);
  }
#line 269
  if ((int )tmp___1 == 0) {
    {
#line 270
    tmp = consys_nme(orig_sys, (char )'v', ovndx, (bool )1, (char *)((void *)0));
#line 270
    tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 270
    errmsg(432, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, tmp, ovndx);
    }
#line 273
    if ((unsigned long )aj != (unsigned long )((void *)0)) {
      {
#line 273
      pkvec_free(aj);
      }
    }
#line 274
    return ((bool )0);
  }
  {
#line 275
  cj = *(orig_sys->obj + ovndx);
#line 276
  ubj = *(orig_sys->vub + ovndx);
#line 277
  lbj = *(orig_sys->vlb + ovndx);
#line 281
  tmp___2 = consys_addcol_pk(dy_sys, (vartyp_enum )1, aj, cj, *(orig_sys->vlb + ovndx),
                             *(orig_sys->vub + ovndx));
  }
#line 281
  if ((int )tmp___2 == 0) {
    {
#line 283
    errmsg(156, rtnnme, "variable", dy_sys->nme, aj->nme);
#line 284
    pkvec_free(aj);
    }
#line 285
    return ((bool )0);
  }
#line 286
  j = aj->ndx;
#line 287
  *(dy_origvars + ovndx) = j;
#line 288
  *(dy_actvars + j) = ovndx;
#line 289
  *(dy_status + j) = statj;
#line 290
  *(dy_var2basis + j) = 0;
#line 291
  if ((int )dy_lp->p1obj.installed == 1) {
#line 292
    *(dy_lp->p1obj.p2obj + j) = cj;
#line 293
    *(dy_sys->obj + j) = 0.0;
  }
#line 299
  if (statj & (unsigned int )(1 << 7)) {
#line 299
    tmp___4 = 1;
  } else {
#line 299
    tmp___4 = 0;
  }
#line 299
  if (tmp___4) {
#line 300
    valj = lbj;
  } else {
#line 302
    if (statj & (unsigned int )(1 << 6)) {
#line 302
      tmp___3 = 1;
    } else {
#line 302
      tmp___3 = 0;
    }
#line 302
    if (tmp___3) {
#line 303
      valj = ubj;
    } else {
#line 305
      valj = 0.0;
    }
  }
#line 306
  *(dy_x + j) = valj;
#line 308
  if (valj != (double )0) {
#line 309
    pkndx = 0;
#line 309
    aij = aj->coeffs;
    {
#line 309
    while (1) {
      while_continue: /* CIL Label */ ;
#line 309
      if (! (pkndx < aj->cnt)) {
#line 309
        goto while_break;
      }
      {
#line 310
      i = aij->ndx;
#line 311
      *(dy_sys->rhs + i) += aij->val * valj;
#line 312
      tmp___5 = fabs(*(dy_sys->rhs + i));
      }
#line 312
      if (tmp___5 < dy_tols->zero) {
#line 312
        *(dy_sys->rhs + i) = (double )0;
      }
#line 313
      if ((unsigned int )*(dy_sys->ctyp + i) == 5U) {
        {
#line 314
        *(dy_sys->rhslow + i) += aij->val * valj;
#line 315
        tmp___6 = fabs(*(dy_sys->rhslow + i));
        }
#line 315
        if (tmp___6 < dy_tols->zero) {
#line 315
          *(dy_sys->rhslow + i) = (double )0;
        }
      }
#line 317
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 318
        tmp___7 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 318
        tmp___8 = consys_prtcontyp(*(dy_sys->ctyp + i));
#line 318
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tadjusting %s constraint %s (%d), ",
                    tmp___8, tmp___7, i);
#line 322
        dyio_outfmt(dy_logchn, dy_gtxecho, "a<%d,%d> = %g, x<%d> = %g, ", i, j, aij->val,
                    j, valj);
        }
#line 324
        if ((unsigned int )*(dy_sys->ctyp + i) == 5U) {
          {
#line 325
          dyio_outfmt(dy_logchn, dy_gtxecho, "rhslow & ");
          }
        }
        {
#line 326
        dyio_outfmt(dy_logchn, dy_gtxecho, "rhs += %g.", aij->val * valj);
        }
      }
#line 309
      pkndx ++;
#line 309
      aij ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 329
    dy_lp->inactzcorr -= cj * valj;
  }
  {
#line 330
  pkvec_free(aj);
#line 334
  *(dy_frame + j) = (bool )1;
#line 335
  *(dy_gamma + j) = (double )1;
#line 339
  (dy_lp->sys.vars.loadable) --;
  }
#line 342
  if (dy_opts->print.varmgmt >= 3) {
    {
#line 343
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tadjusting objective correction, ");
#line 344
    dyio_outfmt(dy_logchn, dy_gtxecho, "c<%d> = %g, x<%d> = %g, zcorr -= %g.", ovndx,
                *(orig_sys->obj + ovndx), ovndx, valj, *(orig_sys->obj + ovndx) * valj);
#line 347
    tmp___9 = dy_prtvstat(statj);
#line 347
    tmp___10 = consys_nme(orig_sys, (char )'v', ovndx, (bool )0, (char *)((void *)0));
#line 347
    tmp___11 = consys_prtvartyp(*(dy_sys->vtyp + j));
#line 347
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) = %g copied to index %d, status %s.",
                tmp___11, tmp___10, ovndx, valj, j, tmp___9);
    }
  }
#line 358
  return ((bool )1);
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
bool dy_actNBPrimArchList(consys_struct *orig_sys , int cnt , int *ovndxs ) 
{ 
  int j ;
  int k ;
  bool retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 381
  rtnnme = "dy_actNBPrimArchList";
#line 395
  retval = (bool )1;
#line 396
  k = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (k < cnt) {
#line 396
      if (! ((int )retval == 1)) {
#line 396
        goto while_break;
      }
    } else {
#line 396
      goto while_break;
    }
#line 397
    j = *(ovndxs + k);
#line 398
    if (*(dy_origvars + j) > 0) {
#line 398
      goto __Cont;
    }
#line 400
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 401
      tmp = consys_nme(orig_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 401
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating variable %s (%d)", tmp,
                  j);
      }
    }
    {
#line 404
    retval = dy_actNBPrimArch(orig_sys, j);
    }
#line 405
    if ((int )retval == 0) {
      {
#line 406
      tmp___0 = consys_nme(orig_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 406
      tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 406
      errmsg(430, rtnnme, orig_sys->nme, tmp___1, dy_lp->tot.iters, "activate", "variable",
             tmp___0, j);
      }
    }
    __Cont: /* CIL Label */ 
#line 396
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return (retval);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
bool dy_deactBPrimArch(consys_struct *orig_sys , int j ) 
{ 
  int i ;
  int k ;
  double valj ;
  flags statj ;
  flags stati ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  bool tmp___5 ;

  {
#line 454
  rtnnme = "dy_deactBPrimArch";
#line 466
  statj = *(dy_status + j);
#line 480
  i = *(dy_var2basis + j);
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (*(dy_var2basis + i) != 0)) {
#line 480
      goto while_break;
    }
#line 480
    i = *(dy_var2basis + i);
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  statj = *(dy_status + j) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
  {
#line 496
  if (statj == (flags )(1 << 11)) {
#line 496
    goto case_exp;
  }
#line 500
  if (statj == (flags )(1 << 10)) {
#line 500
    goto case_exp___0;
  }
#line 504
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 497
  statj = (flags )(1 << 7);
#line 498
  valj = *(dy_sys->vlb + j);
#line 499
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 501
  statj = (flags )(1 << 6);
#line 502
  valj = *(dy_sys->vub + j);
#line 503
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 505
  errmsg(1, rtnnme, 505);
  }
#line 506
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 507
  stati = *(dy_status + i) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
  {
#line 509
  if (stati == (flags )(1 << 7)) {
#line 509
    goto case_exp___1;
  }
#line 512
  if (stati == (flags )(1 << 6)) {
#line 512
    goto case_exp___2;
  }
#line 515
  if (stati == (flags )(1 << 5)) {
#line 515
    goto case_exp___3;
  }
#line 518
  if (stati == (flags )(1 << 8)) {
#line 518
    goto case_exp___4;
  }
#line 521
  if (stati == (flags )(1 << 9)) {
#line 521
    goto case_exp___5;
  }
#line 524
  goto switch_default___0;
  case_exp___1: /* CIL Label */ 
#line 510
  stati = (flags )(1 << 3);
#line 511
  goto switch_break___0;
  case_exp___2: /* CIL Label */ 
#line 513
  stati = (flags )(1 << 1);
#line 514
  goto switch_break___0;
  case_exp___3: /* CIL Label */ 
#line 516
  stati = (flags )1;
#line 517
  goto switch_break___0;
  case_exp___4: /* CIL Label */ 
#line 519
  stati = (flags )(1 << 4);
#line 520
  goto switch_break___0;
  case_exp___5: /* CIL Label */ 
#line 522
  stati = (flags )(1 << 2);
#line 523
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 525
  errmsg(1, rtnnme, 525);
  }
#line 526
  return ((bool )0);
  switch_break___0: /* CIL Label */ ;
  }
#line 528
  if (dy_opts->print.varmgmt >= 3) {
    {
#line 529
    tmp = dy_prtvstat(*(dy_status + j));
#line 529
    tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 529
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      swapping %s (%d) %s -> ", tmp___0,
                j, tmp);
#line 532
    tmp___1 = dy_prtvstat(statj);
#line 532
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s ", tmp___1);
#line 533
    tmp___2 = dy_prtvstat(*(dy_status + i));
#line 533
    tmp___3 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 533
    dyio_outfmt(dy_logchn, dy_gtxecho, "<=> %s (%d) %s -> ", tmp___3, i, tmp___2);
#line 536
    tmp___4 = dy_prtvstat(stati);
#line 536
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s.", tmp___4);
    }
  }
  {
#line 545
  k = *(dy_var2basis + j);
#line 546
  *(dy_basis + k) = i;
#line 547
  *(dy_xbasic + k) = *(dy_x + i);
#line 548
  *(dy_var2basis + i) = k;
#line 549
  *(dy_status + i) = stati;
#line 550
  *(dy_var2basis + j) = 0;
#line 551
  *(dy_status + j) = statj;
#line 552
  *(dy_x + j) = valj;
#line 553
  dy_lp->simplex.init_pse = (bool )1;
#line 554
  dy_lp->simplex.init_dse = (bool )1;
#line 558
  tmp___5 = dy_deactNBPrimArch(orig_sys, j);
  }
#line 558
  return (tmp___5);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
bool dy_deactNBPrimArch(consys_struct *orig_sys , int j ) 
{ 
  int ovndx ;
  int i ;
  int pkndx ;
  double valj ;
  flags statj ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 595
  rtnnme = "dy_deactNBPrimArch";
#line 608
  statj = *(dy_status + j);
#line 619
  ovndx = *(dy_actvars + j);
#line 638
  aj = (pkvec_struct *)((void *)0);
#line 639
  tmp___0 = consys_getcol_pk(dy_sys, j, & aj);
  }
#line 639
  if ((int )tmp___0 == 0) {
    {
#line 640
    tmp = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 640
    errmsg(122, rtnnme, dy_sys->nme, "variable", tmp, j);
    }
#line 642
    if ((unsigned long )aj != (unsigned long )((void *)0)) {
      {
#line 642
      pkvec_free(aj);
      }
    }
#line 643
    return ((bool )0);
  }
#line 644
  valj = *(dy_x + j);
#line 653
  statj &= ~ (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
#line 654
  if (statj == (flags )(1 << 5)) {
#line 654
    statj |= 1U << (sizeof(flags ) * 8UL - 4UL);
  }
#line 655
  *(dy_origvars + ovndx) = - ((int )statj);
#line 656
  if (valj != (double )0) {
#line 657
    pkndx = 0;
#line 657
    aij = aj->coeffs;
    {
#line 657
    while (1) {
      while_continue: /* CIL Label */ ;
#line 657
      if (! (pkndx < aj->cnt)) {
#line 657
        goto while_break;
      }
      {
#line 658
      i = aij->ndx;
#line 659
      *(dy_sys->rhs + i) -= aij->val * valj;
#line 660
      tmp___1 = fabs(*(dy_sys->rhs + i));
      }
#line 660
      if (tmp___1 < dy_tols->zero) {
#line 660
        *(dy_sys->rhs + i) = (double )0;
      }
#line 661
      if ((unsigned int )*(dy_sys->ctyp + i) == 5U) {
        {
#line 662
        *(dy_sys->rhslow + i) -= aij->val * valj;
#line 663
        tmp___2 = fabs(*(dy_sys->rhslow + i));
        }
#line 663
        if (tmp___2 < dy_tols->zero) {
#line 663
          *(dy_sys->rhslow + i) = (double )0;
        }
      }
#line 665
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 666
        tmp___3 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 666
        tmp___4 = consys_prtcontyp(*(dy_sys->ctyp + i));
#line 666
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tadjusting %s constraint %s (%d), ",
                    tmp___4, tmp___3, i);
#line 670
        dyio_outfmt(dy_logchn, dy_gtxecho, "a<%d,%d> = %g, x<%d> = %g, ", i, j, aij->val,
                    j, valj);
        }
#line 672
        if ((unsigned int )*(dy_sys->ctyp + i) == 5U) {
          {
#line 673
          dyio_outfmt(dy_logchn, dy_gtxecho, "rhslow & ");
          }
        }
        {
#line 674
        dyio_outfmt(dy_logchn, dy_gtxecho, "rhs -= %g.", aij->val * valj);
        }
      }
#line 657
      pkndx ++;
#line 657
      aij ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 677
    dy_lp->inactzcorr += *(dy_sys->obj + j) * valj;
#line 679
    if (dy_opts->print.varmgmt >= 3) {
      {
#line 680
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tadjusting objective correction, ");
#line 682
      dyio_outfmt(dy_logchn, dy_gtxecho, "c<%d> = %g, x<%d> = %g, zcorr += %g.", j,
                  *(dy_sys->obj + j), j, valj, *(dy_sys->obj + j) * valj);
      }
    }
  }
  {
#line 686
  pkvec_free(aj);
#line 691
  tmp___6 = consys_delcol(dy_sys, j);
  }
#line 691
  if ((int )tmp___6 == 0) {
    {
#line 692
    tmp___5 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 692
    errmsg(112, rtnnme, dy_sys->nme, "delete", "variable", tmp___5, j);
    }
#line 694
    return ((bool )0);
  }
#line 709
  if (j <= dy_sys->varcnt) {
#line 710
    ovndx = *(dy_actvars + j);
#line 717
    if (dy_opts->print.varmgmt >= 4) {
      {
#line 718
      tmp___7 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 718
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) shifted from column %d", tmp___7,
                  ovndx, *(dy_origvars + ovndx));
      }
    }
#line 722
    *(dy_origvars + ovndx) = j;
#line 724
    i = *(dy_var2basis + j);
#line 725
    if (i != 0) {
#line 733
      if (dy_opts->print.varmgmt >= 4) {
        {
#line 734
        dyio_outfmt(dy_logchn, dy_gtxecho, ", basis entry %d corrected", i);
        }
      }
#line 736
      *(dy_basis + i) = j;
    }
  }
#line 742
  if (statj & (unsigned int )(1 << 5)) {
#line 742
    tmp___8 = 1;
  } else {
#line 742
    tmp___8 = 0;
  }
#line 742
  if (tmp___8) {
#line 743
    (dy_lp->sys.vars.unloadable) ++;
  } else {
#line 745
    (dy_lp->sys.vars.loadable) ++;
  }
#line 747
  return ((bool )1);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
static bool deactNBPrimArchList(consys_struct *orig_sys , int cnt , int *avndxs ) 
{ 
  int k ;
  bool retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 771
  rtnnme = "deactNBPrimArchList";
#line 786
  qsort((void *)(avndxs + 0), (size_t )cnt, sizeof(int ), & intcompare);
#line 788
  retval = (bool )1;
#line 789
  k = 0;
  }
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (k < cnt) {
#line 789
      if (! ((int )retval == 1)) {
#line 789
        goto while_break;
      }
    } else {
#line 789
      goto while_break;
    }
#line 792
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 793
      tmp = consys_nme(dy_sys, (char )'v', *(avndxs + k), (bool )1, (char *)((void *)0));
#line 793
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating variable %s (%d)", tmp,
                  *(avndxs + k));
      }
    }
    {
#line 796
    retval = dy_deactNBPrimArch(orig_sys, *(avndxs + k));
    }
#line 797
    if ((int )retval == 0) {
      {
#line 798
      tmp___0 = consys_nme(dy_sys, (char )'v', *(avndxs + k), (bool )1, (char *)((void *)0));
#line 798
      tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 798
      errmsg(430, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters, "deactivate", "variable",
             tmp___0, *(avndxs + k));
      }
    }
#line 789
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return (retval);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
static int scanPrimVarStdDeact(int **p_avndxs ) 
{ 
  int j ;
  int m ;
  int n ;
  int purgecnt ;
  int *avndxs ;
  double maxpcbar ;
  double pthresh ;
  double maxncbar ;
  double nthresh ;
  double cbarj ;
  flags statj ;
  bool purge ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 852
  m = dy_sys->concnt;
#line 853
  n = dy_sys->varcnt;
#line 854
  maxpcbar = (double )0;
#line 855
  maxncbar = (double )0;
#line 856
  j = m + 1;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (! (j <= n)) {
#line 856
      goto while_break;
    }
#line 857
    if (*(dy_status + j) & (unsigned int )(1 << 7)) {
#line 857
      tmp___0 = 1;
    } else {
#line 857
      tmp___0 = 0;
    }
#line 857
    if (tmp___0) {
#line 858
      cbarj = *(dy_cbar + j);
#line 859
      if (cbarj > maxpcbar) {
#line 859
        maxpcbar = cbarj;
      }
    } else {
#line 861
      if (*(dy_status + j) & (unsigned int )(1 << 6)) {
#line 861
        tmp = 1;
      } else {
#line 861
        tmp = 0;
      }
#line 861
      if (tmp) {
#line 862
        cbarj = *(dy_cbar + j);
#line 863
        if (cbarj < maxncbar) {
#line 863
          maxncbar = cbarj;
        }
      }
    }
#line 856
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 865
  if (dy_opts->print.varmgmt >= 3) {
    {
#line 866
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %g <= cbar<k> <= %g over deactivation candidates.",
                maxncbar, maxpcbar);
    }
  }
#line 871
  purge = (bool )0;
#line 872
  if (maxpcbar > (double )0) {
#line 873
    pthresh = dy_tols->purgevar * maxpcbar;
#line 874
    if (pthresh > dy_tols->bogus * dy_tols->dfeas) {
#line 875
      purge = (bool )1;
    } else {
#line 877
      pthresh = dy_tols->inf;
    }
  } else {
#line 879
    pthresh = dy_tols->inf;
  }
#line 880
  if (maxncbar < (double )0) {
#line 881
    nthresh = dy_tols->purgevar * maxncbar;
#line 882
    if (- nthresh > dy_tols->bogus * dy_tols->dfeas) {
#line 883
      purge = (bool )1;
    } else {
#line 885
      nthresh = - dy_tols->inf;
    }
  } else {
#line 887
    nthresh = - dy_tols->inf;
  }
#line 889
  if (dy_opts->print.varmgmt >= 2) {
#line 890
    if ((int )purge == 0) {
      {
#line 891
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %g <= purge threshold <= %g; tol = %g; scan aborted.",
                  dy_tols->purgevar * maxncbar, dy_tols->purgevar * maxpcbar, dy_tols->bogus * dy_tols->dfeas);
      }
    } else {
      {
#line 896
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %g <= purge threshold <= %g; tol = %g; scanning.",
                  nthresh, pthresh, dy_tols->bogus * dy_tols->dfeas);
      }
    }
  }
#line 900
  if ((int )purge == 0) {
#line 900
    return (0);
  }
#line 905
  purgecnt = 0;
#line 906
  if ((unsigned long )*p_avndxs == (unsigned long )((void *)0)) {
    {
#line 907
    tmp___1 = malloc((unsigned long )dy_sys->archvcnt * sizeof(int ));
#line 907
    avndxs = (int *)tmp___1;
    }
  } else {
#line 909
    avndxs = *p_avndxs;
  }
#line 914
  j = m + 1;
  {
#line 914
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 914
    if (! (j <= n)) {
#line 914
      goto while_break___0;
    }
#line 915
    purge = (bool )0;
#line 916
    statj = *(dy_status + j);
#line 917
    cbarj = *(dy_cbar + j);
#line 922
    if (statj & (unsigned int )(1 << 7)) {
#line 922
      tmp___4 = 1;
    } else {
#line 922
      tmp___4 = 0;
    }
#line 922
    if (tmp___4) {
#line 922
      if (cbarj > pthresh) {
#line 922
        goto _L;
      } else {
#line 922
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 922
      if (statj & (unsigned int )(1 << 6)) {
#line 922
        tmp___5 = 1;
      } else {
#line 922
        tmp___5 = 0;
      }
#line 922
      if (tmp___5) {
#line 922
        if (cbarj < nthresh) {
#line 922
          goto _L;
        } else {
#line 922
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 922
        if (statj & (unsigned int )(1 << 5)) {
#line 922
          tmp___6 = 1;
        } else {
#line 922
          tmp___6 = 0;
        }
#line 922
        if (tmp___6) {
          _L: /* CIL Label */ 
#line 924
          purge = (bool )1;
#line 926
          if (dy_opts->print.varmgmt >= 2) {
            {
#line 927
            tmp___2 = dy_prtvstat(statj);
#line 927
            tmp___3 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 927
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queuing %s (%d) for deactivation, %s, cbar<%d> = %g",
                        tmp___3, j, tmp___2, j, cbarj);
            }
          }
        }
      }
    }
#line 933
    if ((int )purge == 1) {
#line 934
      tmp___7 = purgecnt;
#line 934
      purgecnt ++;
#line 934
      *(avndxs + tmp___7) = j;
    }
#line 914
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 939
  if ((unsigned long )*p_avndxs == (unsigned long )((void *)0)) {
#line 940
    if (purgecnt == 0) {
      {
#line 941
      free((void *)avndxs);
      }
    } else {
#line 943
      *p_avndxs = avndxs;
    }
  }
#line 946
  if (dy_opts->print.varmgmt >= 1) {
    {
#line 947
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d variables for deactivation.",
                purgecnt);
    }
  }
#line 951
  return (purgecnt);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
static int scanPrimVarStdAct(consys_struct *orig_sys , int **p_ovndxs , int *preset ) 
{ 
  int i ;
  int j ;
  int k ;
  int actcnt ;
  int cand_limit ;
  int *ovndxs ;
  int *scanvars ;
  int scan_cnt ;
  int ndx ;
  double *orig_obj ;
  double cbarj ;
  double *orig_y ;
  bool fatal ;
  bool use_all ;
  bool activate ;
  flags statj ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
#line 1001
  cbarj = (double )-1;
#line 1004
  fatal = (bool )0;
#line 1005
  orig_obj = orig_sys->obj;
#line 1006
  actcnt = 0;
#line 1013
  cand_limit = dy_lp->sys.vars.loadable;
#line 1019
  if (dy_opts->addvar > 0) {
#line 1020
    if (dy_opts->addvar > cand_limit) {
#line 1020
      cand_limit = cand_limit;
    } else {
#line 1020
      cand_limit = dy_opts->addvar;
    }
  }
#line 1021
  if ((unsigned long )*p_ovndxs == (unsigned long )((void *)0)) {
    {
#line 1022
    tmp = malloc((unsigned long )cand_limit * sizeof(int ));
#line 1022
    ovndxs = (int *)tmp;
    }
  } else {
#line 1024
    ovndxs = *p_ovndxs;
  }
  {
#line 1029
  tmp___0 = calloc((size_t )(orig_sys->concnt + 1), sizeof(double ));
#line 1029
  orig_y = (double *)tmp___0;
#line 1030
  i = 1;
  }
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! (i <= dy_sys->concnt)) {
#line 1030
      goto while_break;
    }
#line 1031
    k = *(dy_actcons + i);
#line 1032
    *(orig_y + k) = *(dy_y + i);
#line 1030
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1044
  if ((unsigned long )preset != (unsigned long )((void *)0)) {
#line 1045
    scanvars = preset;
#line 1046
    scan_cnt = *(preset + 0);
#line 1047
    if ((unsigned int )dy_lp->simplex.next == 4U) {
#line 1048
      use_all = (bool )0;
    } else {
#line 1050
      use_all = (bool )1;
    }
  } else {
    {
#line 1052
    use_all = (bool )0;
#line 1053
    scan_cnt = orig_sys->archvcnt - dy_sys->archvcnt;
#line 1054
    tmp___1 = malloc((unsigned long )(scan_cnt + 1) * sizeof(int ));
#line 1054
    scanvars = (int *)tmp___1;
#line 1055
    *(scanvars + 0) = 0;
#line 1056
    scan_cnt = 0;
#line 1057
    j = 1;
    }
    {
#line 1057
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1057
      if (! (j <= orig_sys->archvcnt)) {
#line 1057
        goto while_break___0;
      }
#line 1058
      if (*(dy_origvars + j) < 0) {
#line 1058
        if ((flags )(- *(dy_origvars + j)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 1058
          tmp___2 = 0;
        } else {
#line 1058
          tmp___2 = 1;
        }
#line 1058
        if (! tmp___2) {
#line 1058
          goto __Cont;
        }
      } else {
#line 1058
        goto __Cont;
      }
#line 1069
      scan_cnt ++;
#line 1069
      *(scanvars + scan_cnt) = j;
      __Cont: /* CIL Label */ 
#line 1057
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1070
    if ((int )fatal == 1) {
#line 1071
      if ((unsigned long )scanvars != (unsigned long )((void *)0)) {
#line 1071
        if ((unsigned long )scanvars != (unsigned long )preset) {
          {
#line 1071
          free((void *)scanvars);
          }
        }
      }
#line 1072
      if ((unsigned long )orig_y != (unsigned long )((void *)0)) {
        {
#line 1072
        free((void *)orig_y);
        }
      }
#line 1073
      return (-1);
    }
  }
#line 1078
  ndx = 1;
  {
#line 1078
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1078
    if (ndx <= scan_cnt) {
#line 1078
      if (! (actcnt < cand_limit)) {
#line 1078
        goto while_break___1;
      }
    } else {
#line 1078
      goto while_break___1;
    }
#line 1079
    j = *(scanvars + ndx);
#line 1084
    if (*(dy_origvars + j) < 0) {
#line 1084
      if ((flags )(- *(dy_origvars + j)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 1084
        tmp___5 = 0;
      } else {
#line 1084
        tmp___5 = 1;
      }
#line 1084
      if (tmp___5) {
#line 1096
        statj = (flags )(- *(dy_origvars + j));
#line 1097
        if ((unsigned int )dy_lp->simplex.next == 2U) {
#line 1098
          cbarj = (double )0;
        } else {
#line 1100
          cbarj = *(orig_obj + j);
        }
        {
#line 1101
        tmp___3 = consys_dotcol(orig_sys, j, orig_y);
#line 1101
        cbarj -= tmp___3;
#line 1102
        tmp___4 = fabs(cbarj);
        }
#line 1102
        if (tmp___4 < dy_tols->cost) {
#line 1102
          cbarj = (double )0;
        }
#line 1103
        if ((unsigned int )dy_lp->simplex.next == 4U) {
#line 1104
          cbarj = - cbarj;
        }
#line 1118
        if ((int )use_all == 1) {
#line 1119
          activate = (bool )1;
        } else
#line 1121
        if (cbarj == (double )0) {
#line 1124
          activate = (bool )0;
        } else
#line 1121
        if (cbarj > (double )0) {
#line 1121
          if (statj == (flags )(1 << 7)) {
#line 1124
            activate = (bool )0;
          } else {
#line 1121
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1121
        if (cbarj < (double )0) {
#line 1121
          if (statj == (flags )(1 << 6)) {
#line 1124
            activate = (bool )0;
          } else {
#line 1126
            activate = (bool )1;
          }
        } else {
#line 1126
          activate = (bool )1;
        }
      } else {
#line 1085
        activate = (bool )0;
      }
    } else {
#line 1085
      activate = (bool )0;
    }
#line 1129
    if ((int )activate == 0) {
#line 1130
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 1131
        statj = (flags )(- *(dy_origvars + j));
#line 1132
        tmp___6 = dy_prtvstat(statj);
#line 1132
        tmp___7 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1132
        tmp___8 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 1132
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    skipping %s %s (%d), status %s",
                    tmp___8, tmp___7, j, tmp___6);
        }
#line 1136
        if (statj & (unsigned int )(1 << 5)) {
#line 1136
          tmp___9 = 1;
        } else {
#line 1136
          tmp___9 = 0;
        }
#line 1136
        if (tmp___9) {
          {
#line 1137
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
          }
        } else {
          {
#line 1139
          dyio_outfmt(dy_logchn, dy_gtxecho, ", cbar = %g.", cbarj);
          }
        }
      }
    } else
#line 1141
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 1142
      tmp___10 = dy_prtvstat(statj);
#line 1142
      tmp___11 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1142
      tmp___12 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 1142
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d), status %s, cbar = %g.",
                  tmp___12, tmp___11, j, tmp___10, cbarj);
      }
    }
#line 1149
    if ((int )activate == 1) {
#line 1149
      tmp___13 = actcnt;
#line 1149
      actcnt ++;
#line 1149
      *(ovndxs + tmp___13) = j;
    }
#line 1078
    ndx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1150
  if ((unsigned long )orig_y != (unsigned long )((void *)0)) {
    {
#line 1150
    free((void *)orig_y);
    }
  }
#line 1151
  if ((unsigned long )scanvars != (unsigned long )((void *)0)) {
#line 1151
    if ((unsigned long )scanvars != (unsigned long )preset) {
      {
#line 1151
      free((void *)scanvars);
      }
    }
  }
#line 1155
  if ((unsigned long )*p_ovndxs == (unsigned long )((void *)0)) {
#line 1156
    if (actcnt == 0) {
      {
#line 1157
      free((void *)ovndxs);
      }
    } else {
#line 1159
      *p_ovndxs = ovndxs;
    }
  }
#line 1162
  if (dy_opts->print.varmgmt >= 1) {
    {
#line 1163
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d variables for activation.",
                actcnt);
    }
  }
#line 1167
  return (actcnt);
}
}
#line 1171 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
int dy_deactivateVars(consys_struct *orig_sys ) 
{ 
  int *candidates ;
  int candcnt ;
  int retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;

  {
  {
#line 1188
  rtnnme = "dy_deactivateVars";
#line 1190
  retval = -1;
#line 1195
  candidates = (int *)((void *)0);
#line 1196
  candcnt = scanPrimVarStdDeact(& candidates);
  }
#line 1197
  if (candcnt < 0) {
    {
#line 1198
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1198
    errmsg(434, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "variable", "normal deactivation");
    }
  } else
#line 1202
  if (candcnt > 0) {
    {
#line 1203
    tmp___0 = deactNBPrimArchList(orig_sys, candcnt, candidates);
    }
#line 1203
    if ((int )tmp___0 == 1) {
#line 1204
      retval = candcnt;
    }
  } else {
#line 1206
    retval = 0;
  }
#line 1210
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1210
    free((void *)candidates);
    }
  }
#line 1213
  if (dy_opts->print.varmgmt >= 1) {
#line 1214
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 1215
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
      }
    }
    {
#line 1216
    dyio_outfmt(dy_logchn, dy_gtxecho, " %d deactivations.", candcnt);
#line 1217
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 1223
  return (retval);
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_varmgmt.c"
int dy_activateVars(consys_struct *orig_sys , int *preset ) 
{ 
  int candcnt ;
  int candndx ;
  int j ;
  int i ;
  int bfcnt ;
  int bfndx ;
  int *candidates ;
  int *basic_frame ;
  double abarij ;
  double gammaj ;
  double *abarj ;
  flags calcflgs ;
  bool actresult ;
  bool pseresult ;
  dyret_enum factorresult ;
  int retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  char const   *tmp___3 ;
  bool tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  bool tmp___9 ;

  {
#line 1261
  rtnnme = "dy_addvars";
#line 1269
  retval = -1;
#line 1270
  actresult = (bool )1;
#line 1271
  pseresult = (bool )1;
#line 1276
  if ((unsigned int )dy_lp->simplex.next == 2U) {
#line 1276
    if ((int )dy_lp->p1obj.installed == 0) {
      {
#line 1277
      tmp___0 = dy_initp1obj();
      }
#line 1277
      if ((int )tmp___0 == 0) {
        {
#line 1278
        tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1278
        errmsg(318, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "initialise");
        }
#line 1281
        return (-1);
      }
    } else {
#line 1276
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1283
  if ((unsigned int )dy_lp->simplex.next == 3U) {
#line 1283
    if ((int )dy_lp->p1obj.installed == 1) {
      {
#line 1284
      tmp___2 = dy_swapobjs((dyphase_enum )3);
      }
#line 1284
      if ((int )tmp___2 == 0) {
        {
#line 1285
        tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1285
        errmsg(318, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters, "remove");
        }
#line 1288
        return (-1);
      }
      {
#line 1289
      dy_calcduals();
#line 1290
      tmp___4 = dy_calccbar();
      }
#line 1290
      if ((int )tmp___4 == 0) {
        {
#line 1291
        tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1291
        errmsg(384, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters);
        }
#line 1293
        return (-1);
      }
    }
  }
  {
#line 1298
  candidates = (int *)((void *)0);
#line 1299
  candcnt = scanPrimVarStdAct(orig_sys, & candidates, preset);
  }
#line 1300
  if (candcnt < 0) {
    {
#line 1301
    tmp___5 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1301
    errmsg(434, rtnnme, dy_sys->nme, tmp___5, dy_lp->tot.iters, "variable", "normal activation");
#line 1304
    actresult = (bool )0;
    }
  } else
#line 1306
  if (candcnt > 0) {
    {
#line 1307
    actresult = dy_actNBPrimArchList(orig_sys, candcnt, candidates);
    }
  } else {
#line 1309
    actresult = (bool )1;
  }
#line 1311
  if ((int )actresult == 0) {
#line 1312
    if ((unsigned long )candidates != (unsigned long )((void *)0)) {
      {
#line 1312
      free((void *)candidates);
      }
    }
#line 1313
    return (retval);
  }
#line 1326
  if (candcnt > 0) {
#line 1326
    if ((int )dy_lp->simplex.init_pse == 0) {
      {
#line 1327
      tmp___6 = malloc((unsigned long )dy_sys->concnt * sizeof(int ));
#line 1327
      basic_frame = (int *)tmp___6;
#line 1328
      bfcnt = 0;
#line 1329
      i = 1;
      }
      {
#line 1329
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1329
        if (! (i <= dy_sys->concnt)) {
#line 1329
          goto while_break;
        }
#line 1330
        j = *(dy_basis + i);
#line 1331
        if ((int )*(dy_frame + j) == 1) {
#line 1332
          tmp___7 = bfcnt;
#line 1332
          bfcnt ++;
#line 1332
          *(basic_frame + tmp___7) = i;
        }
#line 1329
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1334
      abarj = (double *)((void *)0);
#line 1335
      candndx = 0;
      {
#line 1335
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1335
        if (! (candndx < candcnt)) {
#line 1335
          goto while_break___0;
        }
        {
#line 1336
        j = *(dy_origvars + *(candidates + candndx));
#line 1337
        tmp___9 = consys_getcol_ex(dy_sys, j, & abarj);
        }
#line 1337
        if ((int )tmp___9 == 0) {
          {
#line 1338
          tmp___8 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1338
          errmsg(122, rtnnme, dy_sys->nme, "column", tmp___8, j);
#line 1340
          pseresult = (bool )0;
          }
#line 1341
          goto while_break___0;
        }
        {
#line 1342
        dy_ftran(abarj, (bool )0);
#line 1343
        gammaj = (double )1;
#line 1344
        bfndx = 0;
        }
        {
#line 1344
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1344
          if (! (bfndx < bfcnt)) {
#line 1344
            goto while_break___1;
          }
#line 1345
          i = *(basic_frame + bfndx);
#line 1346
          abarij = *(abarj + i);
#line 1347
          if (abarij != (double )0) {
#line 1348
            gammaj += abarij * abarij;
          }
#line 1344
          bfndx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1349
        *(dy_gamma + j) = gammaj;
#line 1335
        candndx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1350
      if ((unsigned long )abarj != (unsigned long )((void *)0)) {
        {
#line 1350
        free((void *)abarj);
        }
      }
#line 1351
      if ((unsigned long )basic_frame != (unsigned long )((void *)0)) {
        {
#line 1351
        free((void *)basic_frame);
        }
      }
    }
  }
#line 1353
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1353
    free((void *)candidates);
    }
  }
#line 1354
  if ((int )pseresult == 0) {
#line 1354
    return (retval);
  }
#line 1361
  retval = candcnt;
#line 1363
  if (candcnt > 0) {
    {
#line 1364
    calcflgs = (flags )((1 << 3) | (1 << 5));
#line 1365
    factorresult = dy_accchk(& calcflgs);
    }
    {
#line 1368
    if ((int )factorresult == 1) {
#line 1368
      goto case_1;
    }
#line 1394
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1371
    if (dy_opts->print.conmgmt >= 3) {
#line 1372
      if ((int )factorresult == 1) {
        {
#line 1373
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
        }
      }
    }
#line 1393
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1395
    retval = -1;
#line 1397
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 1398
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
      }
    }
#line 1400
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1405
  if (dy_opts->print.varmgmt >= 1) {
#line 1406
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 1407
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
      }
    }
    {
#line 1408
    dyio_outfmt(dy_logchn, dy_gtxecho, " %d activations.", candcnt);
#line 1409
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 1415
  return (retval);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
void dy_glp_save_pointer(void *ptr ) ;
#line 47
void *dy_glp_read_pointer(void) ;
#line 71
int dy_glp_init_lib_env(void) ;
#line 74
ENV *dy_glp_get_env_ptr(void) ;
#line 77
int dy_glp_free_lib_env(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib2.c"
int dy_glp_init_lib_env(void) 
{ 
  ENV *env ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 57
  tmp = dy_glp_read_pointer();
#line 57
  env = (ENV *)tmp;
  }
#line 59
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 59
    return (1);
  }
  {
#line 61
  tmp___0 = malloc(sizeof(ENV ));
#line 61
  env = (ENV *)tmp___0;
  }
#line 63
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 63
    return (2);
  }
  {
#line 65
  env->mem_ptr = (MEM *)((void *)0);
#line 66
  env->mem_limit = 2147483647;
#line 67
  env->mem_total = 0;
#line 68
  env->mem_tpeak = 0;
#line 69
  env->mem_count = 0;
#line 70
  env->mem_cpeak = 0;
#line 72
  dy_glp_save_pointer((void *)env);
  }
#line 74
  return (0);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib2.c"
ENV *dy_glp_get_env_ptr(void) 
{ 
  ENV *env ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 101
  tmp = dy_glp_read_pointer();
#line 101
  env = (ENV *)tmp;
  }
#line 103
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    {
#line 105
    tmp___0 = dy_glp_init_lib_env();
    }
#line 105
    if (tmp___0 != 0) {
      {
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nget_env_ptr: initialization failed\n");
#line 108
      fflush(stderr);
#line 110
      abort();
      }
    }
    {
#line 113
    tmp___1 = dy_glp_read_pointer();
#line 113
    env = (ENV *)tmp___1;
    }
  }
#line 115
  return (env);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib2.c"
int dy_glp_free_lib_env(void) 
{ 
  ENV *env ;
  void *tmp ;
  MEM *this ;

  {
  {
#line 147
  tmp = dy_glp_read_pointer();
#line 147
  env = (ENV *)tmp;
  }
#line 149
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 149
    return (1);
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
#line 151
    if (! ((unsigned long )env->mem_ptr != (unsigned long )((void *)0))) {
#line 151
      goto while_break;
    }
    {
#line 152
    this = env->mem_ptr;
#line 153
    env->mem_ptr = this->next;
#line 154
    free((void *)this);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  free((void *)env);
#line 159
  dy_glp_save_pointer((void *)0);
  }
#line 161
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
pkvec_struct *pkvec_new(int sze ) ;
#line 516 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_addrow_pk(consys_struct *consys , char class , contyp_enum contyp , pkvec_struct *pkrow ,
                      double rhs , double rhslow , conbnd_struct *cub , conbnd_struct *clb ) ;
#line 516
bool consys_delrow(consys_struct *consys , int rowndx ) ;
#line 1768 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_loadcon(consys_struct *orig_sys , int i , bool genvars , int *inactndxs ) ;
#line 1770
bool dy_deactNBLogPrimCon(consys_struct *orig_sys , int i ) ;
#line 1770
bool dy_deactBLogPrimCon(consys_struct *orig_sys , int i ) ;
#line 1770
bool dy_actBLogPrimCon(consys_struct *orig_sys , int origi , int *inactvars ) ;
#line 1770
bool dy_actBLogPrimConList(consys_struct *orig_sys , int cnt , int *ocndxs , int **p_inactvars ) ;
#line 1776
int dy_deactivateCons(consys_struct *orig_sys ) ;
#line 1776
int dy_activateCons(consys_struct *orig_sys , bool with_vars ) ;
#line 130 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
static int intcompare___0(void const   *p_i , void const   *p_j ) 
{ 
  int i ;
  int j ;

  {
#line 131
  i = (int )*((int const   *)p_i);
#line 132
  j = (int )*((int const   *)p_j);
#line 133
  return (j - i);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
bool dy_loadcon(consys_struct *orig_sys , int i , bool genvars , int *inactndxs ) 
{ 
  int ndx ;
  int act_ndx ;
  int j ;
  int act_j ;
  int act_i ;
  int inact_ndx ;
  double rhsadj ;
  double rhscorr ;
  double act_rhs ;
  double act_rhslow ;
  flags statj ;
  pkvec_struct *ai ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  bool retval ;
  char const   *rtnnme ;
  int print ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
#line 201
  rtnnme = "dy_loadcon";
  {
#line 207
  if ((unsigned int )dy_lp->phase == 1U) {
#line 207
    goto case_1;
  }
#line 211
  if ((unsigned int )dy_lp->phase == 10U) {
#line 211
    goto case_10;
  }
#line 211
  if ((unsigned int )dy_lp->phase == 13U) {
#line 211
    goto case_10;
  }
#line 214
  goto switch_default;
  case_1: /* CIL Label */ 
#line 208
  print = dy_opts->print.setup;
#line 209
  goto switch_break;
  case_10: /* CIL Label */ 
  case_13: /* CIL Label */ 
#line 212
  print = dy_opts->print.conmgmt + 1;
#line 213
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 215
  errmsg(1, rtnnme, 215);
  }
#line 216
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 258
  if ((int )genvars == 1) {
    {
#line 259
    aj = pkvec_new(0);
    }
  } else {
#line 261
    aj = (pkvec_struct *)((void *)0);
  }
  {
#line 262
  ai = (pkvec_struct *)((void *)0);
#line 263
  tmp___0 = consys_getrow_pk(orig_sys, i, & ai);
  }
#line 263
  if ((int )tmp___0 == 0) {
    {
#line 264
    tmp = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 264
    errmsg(122, rtnnme, orig_sys->nme, "row", tmp, i);
    }
#line 266
    if ((unsigned long )aj != (unsigned long )((void *)0)) {
      {
#line 266
      pkvec_free(aj);
      }
    }
#line 267
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 267
      pkvec_free(ai);
      }
    }
#line 268
    return ((bool )0);
  }
#line 269
  retval = (bool )1;
#line 278
  rhsadj = (double )0;
#line 279
  inact_ndx = 0;
#line 280
  act_ndx = 0;
#line 281
  ndx = 0;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (ndx < ai->cnt)) {
#line 281
      goto while_break;
    }
#line 282
    aij = ai->coeffs + ndx;
#line 283
    j = aij->ndx;
#line 305
    if (*(dy_origvars + j) <= 0) {
#line 306
      statj = (flags )(- *(dy_origvars + j));
#line 319
      if ((int )genvars == 1) {
#line 319
        if (*(dy_origvars + j) < 0) {
#line 319
          if ((flags )(- *(dy_origvars + j)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 319
            tmp___10 = 0;
          } else {
#line 319
            tmp___10 = 1;
          }
#line 319
          if (tmp___10) {
            {
#line 320
            retval = consys_getcol_pk(orig_sys, j, & aj);
            }
#line 321
            if ((int )retval == 0) {
              {
#line 322
              tmp___1 = consys_nme(orig_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 322
              errmsg(122, rtnnme, orig_sys->nme, "variable", tmp___1, j);
              }
#line 324
              goto while_break;
            }
            {
#line 325
            retval = consys_addcol_pk(dy_sys, (vartyp_enum )1, aj, *(orig_sys->obj + j),
                                      *(orig_sys->vlb + j), *(orig_sys->vub + j));
            }
#line 328
            if ((int )retval == 0) {
              {
#line 329
              errmsg(156, rtnnme, "variable", dy_sys->nme, aj->nme);
              }
#line 330
              goto while_break;
            }
#line 331
            act_j = aj->ndx;
#line 333
            if (print >= 6) {
#line 334
              if (statj == 0U) {
#line 334
                tmp___3 = "unspecified";
              } else {
                {
#line 334
                tmp___2 = dy_prtvstat(statj);
#line 334
                tmp___3 = (char const   *)tmp___2;
                }
              }
              {
#line 334
              tmp___4 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 334
              tmp___5 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 334
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    activating %s variable %s (%d) to index %d, status %s.",
                          tmp___5, tmp___4, j, act_j, tmp___3);
              }
            }
#line 340
            *(dy_origvars + j) = act_j;
#line 341
            *(dy_actvars + act_j) = j;
#line 342
            (dy_lp->sys.vars.loadable) --;
          } else {
#line 319
            goto _L;
          }
        } else {
#line 319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 349
        if ((unsigned long )inactndxs != (unsigned long )((void *)0)) {
#line 349
          if (*(dy_origvars + j) < 0) {
#line 349
            if ((flags )(- *(dy_origvars + j)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 349
              tmp___6 = 0;
            } else {
#line 349
              tmp___6 = 1;
            }
#line 349
            if (tmp___6) {
#line 349
              inact_ndx ++;
#line 349
              *(inactndxs + inact_ndx) = j;
            }
          }
        }
        {
#line 351
        if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 7)) {
#line 351
          goto case_exp;
        }
#line 355
        if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 5)) {
#line 355
          goto case_exp___0;
        }
#line 355
        if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 6)) {
#line 355
          goto case_exp___0;
        }
#line 358
        goto switch_default___0;
        case_exp: /* CIL Label */ 
#line 352
        rhscorr = aij->val * *(orig_sys->vlb + j);
#line 353
        goto switch_break___0;
        case_exp___0: /* CIL Label */ 
        case_exp___1: /* CIL Label */ 
#line 356
        rhscorr = aij->val * *(orig_sys->vub + j);
#line 357
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 359
        rhscorr = (double )0;
#line 360
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 361
        rhsadj -= rhscorr;
#line 363
        if (print >= 6) {
          {
#line 364
          tmp___7 = dy_prtvstat(statj);
#line 364
          tmp___8 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 364
          tmp___9 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 364
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    skipping inactive %s variable %s (%d), status %s.",
                      tmp___9, tmp___8, j, tmp___7);
#line 368
          dyio_outfmt(dy_logchn, dy_gtxecho, ", rhs += %g.", - rhscorr);
          }
        }
#line 370
        goto __Cont;
      }
    }
#line 377
    if (print >= 5) {
      {
#line 378
      tmp___11 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 378
      tmp___12 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 378
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  copying %s variable %s (%d) to index %d.",
                  tmp___12, tmp___11, j, *(dy_origvars + j));
      }
    }
#line 383
    (ai->coeffs + act_ndx)->ndx = *(dy_origvars + j);
#line 384
    (ai->coeffs + act_ndx)->val = aij->val;
#line 385
    act_ndx ++;
    __Cont: /* CIL Label */ 
#line 281
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if ((unsigned long )aj != (unsigned long )((void *)0)) {
    {
#line 387
    pkvec_free(aj);
    }
  }
#line 388
  if ((unsigned long )inactndxs != (unsigned long )((void *)0)) {
#line 388
    *(inactndxs + 0) = inact_ndx;
  }
#line 389
  if ((int )retval == 0) {
#line 390
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 390
      pkvec_free(ai);
      }
    }
#line 391
    return ((bool )0);
  }
#line 392
  ai->cnt = act_ndx;
#line 402
  act_rhs = *(orig_sys->rhs + i) + rhsadj;
#line 403
  if ((unsigned int )*(orig_sys->ctyp + i) == 5U) {
#line 404
    act_rhslow = *(orig_sys->rhslow + i) + rhsadj;
  } else {
#line 406
    act_rhslow = (double )0;
  }
  {
#line 407
  retval = consys_addrow_pk(dy_sys, (char )'a', *(orig_sys->ctyp + i), ai, act_rhs,
                            act_rhslow, (conbnd_struct *)((void *)0), (conbnd_struct *)((void *)0));
  }
#line 409
  if ((int )retval == 0) {
    {
#line 410
    errmsg(156, rtnnme, "constraint", dy_sys->nme, ai->nme);
    }
#line 411
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 411
      pkvec_free(ai);
      }
    }
#line 412
    return ((bool )0);
  }
  {
#line 413
  act_i = ai->ndx;
#line 414
  pkvec_free(ai);
#line 415
  *(dy_origcons + i) = act_i;
#line 416
  *(dy_actcons + act_i) = i;
#line 417
  *(dy_actvars + act_i) = -2147483647;
  }
#line 424
  if (dy_sys->archvcnt > 0) {
#line 425
    act_j = dy_sys->varcnt;
#line 426
    j = *(dy_actvars + act_j);
#line 432
    *(dy_origvars + j) = act_j;
#line 434
    if (print >= 6) {
      {
#line 435
      tmp___13 = consys_nme(dy_sys, (char )'v', act_j, (bool )0, (char *)((void *)0));
#line 435
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    variable %s (%d) shifted from index %d",
                  tmp___13, act_j, act_i);
      }
    }
  }
#line 442
  if (print >= 3) {
    {
#line 443
    tmp___14 = consys_nme(dy_sys, (char )'c', act_i, (bool )0, (char *)((void *)0));
#line 443
    tmp___15 = consys_prtcontyp(*(dy_sys->ctyp + act_i));
#line 443
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      %s %s (%d) copied to index %d", tmp___15,
                tmp___14, i, act_i);
    }
  }
#line 450
  (dy_lp->sys.cons.loadable) --;
#line 456
  return ((bool )1);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
bool dy_actBLogPrimCon(consys_struct *orig_sys , int origi , int *inactvars ) 
{ 
  int i ;
  int j ;
  double lhsi ;
  double rhsi ;
  double rhslowi ;
  contyp_enum ctypi ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;

  {
#line 489
  rtnnme = "dy_actBLogPrimCon";
#line 503
  ctypi = *(orig_sys->ctyp + origi);
#line 509
  if (dy_opts->print.conmgmt >= 2) {
    {
#line 510
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating ");
    }
#line 511
    if ((unsigned int )ctypi == 5U) {
      {
#line 512
      dyio_outfmt(dy_logchn, dy_gtxecho, "%g <= ", *(orig_sys->rhslow + origi));
      }
    }
    {
#line 513
    tmp = consys_prtcontyp(ctypi);
#line 513
    tmp___0 = consys_nme(orig_sys, (char )'c', origi, (bool )0, (char *)((void *)0));
#line 513
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s (%d) %s %g", tmp___0, origi, tmp, *(orig_sys->rhs + origi));
    }
  }
  {
#line 520
  tmp___3 = dy_loadcon(orig_sys, origi, (bool )0, inactvars);
  }
#line 520
  if ((int )tmp___3 == 0) {
    {
#line 521
    tmp___1 = consys_nme(orig_sys, (char )'c', origi, (bool )1, (char *)((void *)0));
#line 521
    tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 521
    errmsg(430, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters, "activate", "original constraint",
           tmp___1, origi);
    }
#line 525
    return ((bool )0);
  }
#line 533
  i = dy_sys->concnt;
#line 534
  j = dy_sys->varcnt;
#line 535
  *(dy_basis + i) = i;
#line 536
  *(dy_var2basis + i) = i;
#line 537
  *(dy_frame + i) = (bool )0;
#line 538
  *(dy_cbar + i) = 0.0;
#line 539
  if (j > dy_sys->concnt) {
#line 540
    if (*(dy_var2basis + j) != 0) {
#line 541
      *(dy_basis + *(dy_var2basis + j)) = j;
    }
  }
  {
#line 548
  rhsi = *(dy_sys->rhs + i);
#line 549
  *(dy_x + i) = (double )0;
#line 550
  lhsi = consys_dotrow(dy_sys, i, dy_x);
#line 551
  tmp___4 = fabs(lhsi);
  }
#line 551
  if (tmp___4 < dy_tols->zero) {
#line 551
    lhsi = (double )0;
  }
  {
#line 552
  tmp___18 = fabs(rhsi);
  }
#line 552
  if (tmp___18 < dy_tols->inf) {
    {
#line 552
    tmp___16 = fabs(rhsi);
#line 552
    tmp___17 = lhsi - rhsi > dy_tols->pfeas * (1.0 + tmp___16);
    }
  } else {
#line 552
    tmp___17 = lhsi > rhsi;
  }
#line 552
  if (tmp___17) {
#line 553
    *(dy_status + i) = (flags )(1 << 11);
  } else {
    {
#line 555
    tmp___12 = fabs(rhsi);
    }
#line 555
    if (tmp___12 < dy_tols->inf) {
      {
#line 555
      tmp___13 = fabs(lhsi - rhsi);
#line 555
      tmp___14 = fabs(rhsi);
      }
#line 555
      if (tmp___13 < dy_tols->pfeas * (1.0 + tmp___14)) {
#line 556
        if ((unsigned int )ctypi == 3U) {
#line 557
          *(dy_status + i) = (flags )1;
        } else {
#line 559
          *(dy_status + i) = (flags )(1 << 3);
        }
      } else {
#line 555
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 561
    if ((unsigned int )ctypi != 5U) {
#line 562
      *(dy_status + i) = (flags )(1 << 2);
    } else {
      {
#line 564
      rhslowi = *(dy_sys->rhslow + i);
#line 565
      tmp___11 = fabs(rhslowi);
      }
#line 565
      if (tmp___11 < dy_tols->inf) {
        {
#line 565
        tmp___9 = fabs(rhslowi);
#line 565
        tmp___10 = rhslowi - lhsi > dy_tols->pfeas * (1.0 + tmp___9);
        }
      } else {
#line 565
        tmp___10 = lhsi < rhslowi;
      }
#line 565
      if (tmp___10) {
#line 566
        *(dy_status + i) = (flags )(1 << 10);
      } else {
        {
#line 568
        tmp___5 = fabs(rhslowi);
        }
#line 568
        if (tmp___5 < dy_tols->inf) {
          {
#line 568
          tmp___6 = fabs(lhsi - rhslowi);
#line 568
          tmp___7 = fabs(rhslowi);
          }
#line 568
          if (tmp___6 < dy_tols->pfeas * (1.0 + tmp___7)) {
#line 569
            *(dy_status + i) = (flags )(1 << 1);
          } else {
#line 571
            *(dy_status + i) = (flags )(1 << 2);
          }
        } else {
#line 571
          *(dy_status + i) = (flags )(1 << 2);
        }
      }
    }
  }
#line 592
  return ((bool )1);
}
}
#line 595 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
bool dy_actBLogPrimConList(consys_struct *orig_sys , int cnt , int *ocndxs , int **p_inactvars ) 
{ 
  int j ;
  int k ;
  int ndx ;
  int act_n ;
  int inact_n ;
  int *onecon ;
  int onecon_cnt ;
  int *collection ;
  int coll_cnt ;
  int coll_sze ;
  bool *seen ;
  bool with_vars ;
  bool retval ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 630
  rtnnme = "dy_actBLogPrimConList";
#line 644
  retval = (bool )1;
#line 652
  if ((unsigned long )p_inactvars != (unsigned long )((void *)0)) {
    {
#line 653
    with_vars = (bool )1;
#line 654
    act_n = dy_sys->archvcnt;
#line 655
    inact_n = orig_sys->archvcnt;
#line 656
    coll_sze = (inact_n - act_n) + 1;
#line 657
    tmp = calloc((size_t )(inact_n + 1), sizeof(bool ));
#line 657
    seen = (bool *)tmp;
    }
#line 658
    if ((unsigned long )*p_inactvars == (unsigned long )((void *)0)) {
      {
#line 659
      tmp___0 = malloc((unsigned long )coll_sze * sizeof(int ));
#line 659
      collection = (int *)tmp___0;
      }
    } else {
#line 661
      collection = *p_inactvars;
#line 662
      coll_sze = *(collection + 0);
    }
    {
#line 663
    *(collection + 0) = 0;
#line 664
    coll_cnt = 0;
#line 665
    tmp___1 = malloc((unsigned long )coll_sze * sizeof(int ));
#line 665
    onecon = (int *)tmp___1;
    }
  } else {
#line 667
    with_vars = (bool )0;
#line 668
    onecon = (int *)((void *)0);
#line 669
    collection = (int *)((void *)0);
#line 670
    coll_cnt = -1;
#line 671
    seen = (bool *)((void *)0);
  }
#line 676
  k = 0;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (k < cnt) {
#line 676
      if (! ((int )retval == 1)) {
#line 676
        goto while_break;
      }
    } else {
#line 676
      goto while_break;
    }
#line 679
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 680
      tmp___2 = consys_nme(orig_sys, (char )'c', *(ocndxs + k), (bool )1, (char *)((void *)0));
#line 680
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating constraint %s (%d)", tmp___2,
                  *(ocndxs + k));
      }
#line 682
      if ((int )with_vars == 0) {
        {
#line 683
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      } else
#line 682
      if (dy_opts->print.conmgmt < 4) {
        {
#line 683
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
    {
#line 685
    retval = dy_actBLogPrimCon(orig_sys, *(ocndxs + k), onecon);
    }
#line 686
    if ((int )retval == 0) {
      {
#line 687
      tmp___3 = consys_nme(orig_sys, (char )'c', *(ocndxs + k), (bool )1, (char *)((void *)0));
#line 687
      tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 687
      errmsg(430, rtnnme, orig_sys->nme, tmp___4, dy_lp->tot.iters, "activate", "constraint",
             tmp___3, *(ocndxs + k));
      }
    }
#line 691
    if ((int )with_vars == 1) {
#line 692
      onecon_cnt = *(onecon + 0);
#line 693
      ndx = 1;
      {
#line 693
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 693
        if (! (ndx <= onecon_cnt)) {
#line 693
          goto while_break___0;
        }
#line 694
        j = *(onecon + ndx);
#line 695
        if ((int )*(seen + j) == 0) {
#line 696
          coll_cnt ++;
#line 696
          *(collection + coll_cnt) = j;
#line 697
          *(seen + j) = (bool )1;
        }
#line 693
        ndx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 699
      if (dy_opts->print.conmgmt >= 4) {
        {
#line 700
        dyio_outfmt(dy_logchn, dy_gtxecho, ", %d referenced variables queued.", coll_cnt - *(collection + 0));
#line 702
        *(collection + 0) = coll_cnt;
        }
      }
    }
#line 676
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if ((int )with_vars == 1) {
#line 709
    *(collection + 0) = coll_cnt;
#line 710
    if ((unsigned long )*p_inactvars == (unsigned long )((void *)0)) {
#line 711
      if (coll_cnt == 0) {
        {
#line 712
        free((void *)collection);
        }
      } else {
#line 714
        *p_inactvars = collection;
      }
    }
#line 715
    if ((unsigned long )onecon != (unsigned long )((void *)0)) {
      {
#line 715
      free((void *)onecon);
      }
    }
#line 716
    if ((unsigned long )seen != (unsigned long )((void *)0)) {
      {
#line 716
      free((void *)seen);
      }
    }
  }
#line 723
  return (retval);
}
}
#line 728 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
bool dy_deactNBLogPrimCon(consys_struct *orig_sys , int i ) 
{ 
  int j ;
  int m ;
  int n ;
  double lbj ;
  double ubj ;
  double valj ;
  flags stati ;
  flags statj ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  bool tmp___5 ;

  {
#line 764
  rtnnme = "dy_deactNBLogPrimCon";
#line 769
  m = dy_sys->concnt;
#line 770
  n = dy_sys->varcnt;
#line 776
  stati = *(dy_status + i) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 793
  j = *(dy_basis + i);
#line 794
  statj = *(dy_status + j) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 795
  lbj = *(dy_sys->vlb + j);
#line 796
  ubj = *(dy_sys->vub + j);
  {
#line 798
  if (statj == (flags )(1 << 2)) {
#line 798
    goto case_exp;
  }
#line 811
  if (statj == (flags )(1 << 10)) {
#line 811
    goto case_exp___0;
  }
#line 811
  if (statj == (flags )(1 << 1)) {
#line 811
    goto case_exp___0;
  }
#line 816
  if (statj == (flags )(1 << 11)) {
#line 816
    goto case_exp___2;
  }
#line 816
  if (statj == (flags )(1 << 3)) {
#line 816
    goto case_exp___2;
  }
#line 820
  if (statj == 1U) {
#line 820
    goto case_1;
  }
#line 824
  if (statj == (flags )(1 << 4)) {
#line 824
    goto case_exp___4;
  }
#line 828
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 799
  if ((unsigned int )dy_lp->simplex.active == 3U) {
#line 800
    statj = (flags )(1 << 9);
#line 801
    valj = *(dy_x + j);
  } else
#line 803
  if (lbj > - dy_tols->inf) {
#line 804
    statj = (flags )(1 << 7);
#line 805
    valj = lbj;
  } else {
#line 807
    statj = (flags )(1 << 6);
#line 808
    valj = ubj;
  }
#line 809
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  case_exp___1: /* CIL Label */ 
#line 812
  statj = (flags )(1 << 6);
#line 813
  valj = ubj;
#line 814
  goto switch_break;
  case_exp___2: /* CIL Label */ 
  case_exp___3: /* CIL Label */ 
#line 817
  statj = (flags )(1 << 7);
#line 818
  valj = lbj;
#line 819
  goto switch_break;
  case_1: /* CIL Label */ 
#line 821
  statj = (flags )(1 << 5);
#line 822
  valj = lbj;
#line 823
  goto switch_break;
  case_exp___4: /* CIL Label */ 
#line 825
  statj = (flags )(1 << 8);
#line 826
  valj = *(dy_x + j);
#line 827
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 829
  errmsg(1, rtnnme, 829);
  }
#line 830
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 832
  if (stati == (flags )(1 << 7)) {
#line 832
    goto case_exp___5;
  }
#line 835
  if (stati == (flags )(1 << 6)) {
#line 835
    goto case_exp___6;
  }
#line 838
  if (stati == (flags )(1 << 5)) {
#line 838
    goto case_exp___7;
  }
#line 841
  goto switch_default___0;
  case_exp___5: /* CIL Label */ 
#line 833
  stati = (flags )(1 << 3);
#line 834
  goto switch_break___0;
  case_exp___6: /* CIL Label */ 
#line 836
  stati = (flags )(1 << 1);
#line 837
  goto switch_break___0;
  case_exp___7: /* CIL Label */ 
#line 839
  stati = (flags )1;
#line 840
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 842
  errmsg(1, rtnnme, 842);
  }
#line 843
  return ((bool )0);
  switch_break___0: /* CIL Label */ ;
  }
#line 845
  if (dy_opts->print.conmgmt >= 3) {
    {
#line 846
    tmp = dy_prtvstat(*(dy_status + i));
#line 846
    tmp___0 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 846
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      swapping %s (%d) %s -> ", tmp___0,
                i, tmp);
#line 849
    tmp___1 = dy_prtvstat(stati);
#line 849
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s ", tmp___1);
#line 850
    tmp___2 = dy_prtvstat(*(dy_status + j));
#line 850
    tmp___3 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 850
    dyio_outfmt(dy_logchn, dy_gtxecho, "<=> %s (%d) %s -> ", tmp___3, j, tmp___2);
#line 853
    tmp___4 = dy_prtvstat(statj);
#line 853
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s.", tmp___4);
    }
  }
#line 862
  *(dy_var2basis + j) = 0;
#line 863
  *(dy_status + j) = statj;
#line 864
  if ((int )*(dy_frame + j) == 1) {
#line 864
    dy_lp->simplex.init_pse = (bool )1;
  }
  {
#line 865
  *(dy_x + j) = valj;
#line 866
  dy_lp->simplex.init_dse = (bool )1;
#line 867
  *(dy_basis + i) = i;
#line 868
  *(dy_var2basis + i) = i;
#line 869
  *(dy_status + i) = stati;
#line 873
  tmp___5 = dy_deactBLogPrimCon(orig_sys, i);
  }
#line 873
  return (tmp___5);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
bool dy_deactBLogPrimCon(consys_struct *orig_sys , int i ) 
{ 
  int j ;
  int k ;
  int m ;
  int n ;
  int bposi ;
  int origi ;
  flags stati ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 924
  rtnnme = "dy_deactBLogPrimCon";
#line 931
  m = dy_sys->concnt;
#line 932
  n = dy_sys->varcnt;
#line 940
  stati = *(dy_status + i);
#line 941
  bposi = *(dy_var2basis + i);
#line 957
  origi = *(dy_actcons + i);
#line 984
  if ((int )*(dy_frame + i) == 1) {
#line 984
    dy_lp->simplex.init_pse = (bool )1;
  }
#line 992
  if (bposi != i) {
#line 993
    k = *(dy_basis + i);
#line 994
    *(dy_basis + bposi) = k;
#line 995
    *(dy_var2basis + k) = bposi;
  }
#line 1002
  if (i < m) {
#line 1003
    k = *(dy_var2basis + m);
#line 1004
    if (k > 0) {
#line 1004
      if (k != m) {
#line 1005
        j = *(dy_basis + m);
#line 1006
        *(dy_var2basis + j) = k;
#line 1007
        *(dy_basis + k) = j;
#line 1008
        *(dy_var2basis + m) = m;
#line 1009
        *(dy_basis + m) = m;
      }
    }
  }
  {
#line 1032
  k = *(dy_actcons + i);
#line 1033
  *(dy_origcons + k) = 0;
#line 1034
  tmp___0 = consys_delrow(dy_sys, i);
  }
#line 1034
  if ((int )tmp___0 == 0) {
    {
#line 1035
    tmp = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1035
    errmsg(112, rtnnme, dy_sys->nme, "delete", "constraint", tmp, i);
    }
#line 1037
    return ((bool )0);
  }
#line 1066
  if (i <= dy_sys->concnt) {
#line 1067
    k = *(dy_actcons + i);
#line 1068
    *(dy_origcons + k) = i;
#line 1069
    k = *(dy_basis + i);
#line 1070
    if (k == m) {
#line 1071
      *(dy_basis + i) = i;
#line 1072
      *(dy_var2basis + i) = i;
    } else
#line 1074
    if (k != n) {
#line 1075
      *(dy_var2basis + k) = i;
    }
  }
#line 1084
  if (m <= dy_sys->varcnt) {
#line 1085
    k = *(dy_actvars + m);
#line 1086
    *(dy_origvars + k) = m;
#line 1087
    bposi = *(dy_var2basis + m);
#line 1088
    if (bposi != 0) {
#line 1089
      if (bposi == m) {
#line 1090
        *(dy_basis + i) = m;
#line 1091
        *(dy_var2basis + m) = i;
      } else {
#line 1093
        *(dy_basis + bposi) = m;
      }
    }
  }
#line 1097
  (dy_lp->sys.cons.loadable) ++;
#line 1103
  if (dy_opts->print.conmgmt >= 5) {
    {
#line 1104
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tactive now %d x %d (%d+%d).", dy_sys->concnt,
                dy_sys->varcnt, dy_sys->archvcnt, dy_sys->concnt);
#line 1107
    tmp___1 = consys_nme(orig_sys, (char )'c', origi, (bool )0, (char *)((void *)0));
#line 1107
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tconstraint %s (%d) and logical deleted from pos\'n %d.",
                tmp___1, origi, i);
    }
#line 1110
    if (i <= dy_sys->concnt) {
      {
#line 1111
      k = *(dy_actcons + i);
#line 1112
      tmp___2 = consys_nme(orig_sys, (char )'c', k, (bool )0, (char *)((void *)0));
#line 1112
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tconstraint %s (%d) shifted from pos\'n %d, ",
                  tmp___2, k, m);
#line 1115
      k = *(dy_basis + i);
#line 1116
      tmp___3 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 1116
      dyio_outfmt(dy_logchn, dy_gtxecho, "basis[%d] = %s (%d)", i, tmp___3, k);
#line 1118
      k = *(dy_var2basis + i);
      }
#line 1119
      if (k != 0) {
        {
#line 1120
        tmp___4 = consys_nme(dy_sys, (char )'v', *(dy_basis + k), (bool )0, (char *)((void *)0));
#line 1120
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tbasis pos\'n %d updated to %s (%d).",
                    k, tmp___4, *(dy_basis + k));
        }
      }
    }
#line 1124
    if (m <= dy_sys->varcnt) {
      {
#line 1125
      k = *(dy_actvars + m);
#line 1126
      tmp___5 = consys_nme(orig_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 1126
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tarchitectural %s (%d) shifted from pos\'n %d.",
                  tmp___5, k, n);
#line 1129
      k = *(dy_var2basis + m);
      }
#line 1130
      if (k != 0) {
        {
#line 1131
        tmp___6 = consys_nme(dy_sys, (char )'v', *(dy_basis + k), (bool )0, (char *)((void *)0));
#line 1131
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tbasis pos\'n %d updated to %s (%d).",
                    k, tmp___6, *(dy_basis + k));
        }
      }
    }
  }
#line 1137
  return ((bool )1);
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
static bool deactBLogPrimConList(consys_struct *orig_sys , int cnt , int *acndxs ) 
{ 
  int k ;
  bool retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1160
  rtnnme = "deactBLogPrimConList";
#line 1175
  qsort((void *)(acndxs + 0), (size_t )cnt, sizeof(int ), & intcompare___0);
#line 1177
  retval = (bool )1;
#line 1178
  k = 0;
  }
  {
#line 1178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1178
    if (k < cnt) {
#line 1178
      if (! ((int )retval == 1)) {
#line 1178
        goto while_break;
      }
    } else {
#line 1178
      goto while_break;
    }
#line 1181
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 1182
      tmp = consys_nme(dy_sys, (char )'c', *(acndxs + k), (bool )1, (char *)((void *)0));
#line 1182
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating constraint %s (%d)",
                  tmp, *(acndxs + k));
      }
    }
    {
#line 1186
    retval = dy_deactBLogPrimCon(orig_sys, *(acndxs + k));
    }
#line 1187
    if ((int )retval == 0) {
      {
#line 1188
      tmp___0 = consys_nme(dy_sys, (char )'c', *(acndxs + k), (bool )1, (char *)((void *)0));
#line 1188
      tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1188
      errmsg(430, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters, "deactivate", "constraint",
             tmp___0, *(acndxs + k));
      }
    }
#line 1178
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  return (retval);
}
}
#line 1202 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
static int scanPrimConStdAct(consys_struct *orig_sys , int **p_ocndxs ) 
{ 
  int i ;
  int j ;
  int k ;
  int m ;
  int n ;
  int actcnt ;
  int cand_limit ;
  int *ocndxs ;
  double *orig_x ;
  double *orig_rhs ;
  double *orig_rhslow ;
  double *orig_vub ;
  double *orig_vlb ;
  double lhsi ;
  double rhsi ;
  double rhslowi ;
  contyp_enum *orig_ctyp ;
  contyp_enum ctypi ;
  flags statj ;
  bool activate ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  double tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  double tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___27 ;
  int tmp___28 ;
  double tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;

  {
#line 1230
  rtnnme = "scanPrimConStdAct";
#line 1241
  m = orig_sys->concnt;
#line 1242
  n = orig_sys->varcnt;
#line 1250
  cand_limit = dy_lp->sys.cons.loadable;
#line 1256
  if (dy_opts->con.actlim > 0) {
#line 1257
    if (dy_opts->con.actlim > cand_limit) {
#line 1257
      cand_limit = cand_limit;
    } else {
#line 1257
      cand_limit = dy_opts->con.actlim;
    }
  }
#line 1258
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
    {
#line 1259
    tmp = malloc((unsigned long )cand_limit * sizeof(int ));
#line 1259
    ocndxs = (int *)tmp;
    }
  } else {
#line 1261
    ocndxs = *p_ocndxs;
  }
  {
#line 1266
  orig_vub = orig_sys->vub;
#line 1267
  orig_vlb = orig_sys->vlb;
#line 1268
  tmp___0 = calloc((size_t )(n + 1), sizeof(double ));
#line 1268
  orig_x = (double *)tmp___0;
#line 1269
  j = 1;
  }
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1269
    if (! (j <= n)) {
#line 1269
      goto while_break;
    }
#line 1270
    k = *(dy_origvars + j);
#line 1271
    if (k > 0) {
#line 1272
      *(orig_x + j) = *(dy_x + k);
    } else {
#line 1274
      statj = (flags )(- k);
#line 1285
      if (statj & (unsigned int )(1 << 6)) {
#line 1285
        tmp___2 = 1;
      } else {
#line 1285
        tmp___2 = 0;
      }
#line 1285
      if (tmp___2) {
#line 1286
        *(orig_x + j) = *(orig_vub + j);
      } else {
#line 1288
        if (statj & (unsigned int )((1 << 7) | (1 << 5))) {
#line 1288
          tmp___1 = 1;
        } else {
#line 1288
          tmp___1 = 0;
        }
#line 1288
        if (tmp___1) {
#line 1289
          *(orig_x + j) = *(orig_vlb + j);
        }
      }
    }
#line 1269
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1294
  orig_ctyp = orig_sys->ctyp;
#line 1295
  orig_rhs = orig_sys->rhs;
#line 1296
  orig_rhslow = orig_sys->rhslow;
#line 1297
  actcnt = 0;
#line 1298
  i = 1;
  {
#line 1298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1298
    if (i <= m) {
#line 1298
      if (! (actcnt < cand_limit)) {
#line 1298
        goto while_break___0;
      }
    } else {
#line 1298
      goto while_break___0;
    }
#line 1299
    if (! (*(dy_origcons + i) == 0)) {
#line 1299
      goto __Cont;
    }
    {
#line 1300
    ctypi = *(orig_ctyp + i);
#line 1301
    lhsi = consys_dotrow(orig_sys, i, orig_x);
#line 1302
    tmp___3 = fabs(lhsi);
    }
#line 1302
    if (tmp___3 < dy_tols->zero) {
#line 1302
      lhsi = (double )0;
    }
#line 1309
    rhsi = *(orig_rhs + i);
#line 1310
    if ((unsigned int )ctypi == 5U) {
#line 1311
      rhslowi = *(orig_rhslow + i);
    } else
#line 1313
    if ((unsigned int )ctypi == 3U) {
#line 1314
      rhslowi = rhsi;
    } else {
#line 1316
      rhslowi = - dy_tols->inf;
    }
    {
#line 1318
    if (dy_opts->con.actlvl == 0) {
#line 1318
      goto case_0;
    }
#line 1324
    if (dy_opts->con.actlvl == 1) {
#line 1324
      goto case_1;
    }
#line 1330
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1319
    tmp___7 = fabs(rhsi);
    }
#line 1319
    if (tmp___7 < dy_tols->inf) {
      {
#line 1319
      tmp___5 = fabs(rhsi);
#line 1319
      tmp___6 = lhsi - rhsi > dy_tols->pfeas * (1.0 + tmp___5);
      }
    } else {
#line 1319
      tmp___6 = lhsi > rhsi;
    }
#line 1319
    if (tmp___6) {
#line 1320
      activate = (bool )1;
    } else {
      {
#line 1319
      tmp___11 = fabs(rhslowi);
      }
#line 1319
      if (tmp___11 < dy_tols->inf) {
        {
#line 1319
        tmp___9 = fabs(rhslowi);
#line 1319
        tmp___10 = rhslowi - lhsi > dy_tols->pfeas * (1.0 + tmp___9);
        }
      } else {
#line 1319
        tmp___10 = lhsi < rhslowi;
      }
#line 1319
      if (tmp___10) {
#line 1320
        activate = (bool )1;
      } else {
#line 1322
        activate = (bool )0;
      }
    }
#line 1323
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1325
    tmp___15 = fabs(rhsi);
    }
#line 1325
    if (tmp___15 < dy_tols->inf) {
      {
#line 1325
      tmp___13 = fabs(rhsi);
#line 1325
      tmp___14 = rhsi - lhsi > dy_tols->pfeas * (1.0 + tmp___13);
      }
    } else {
#line 1325
      tmp___14 = lhsi < rhsi;
    }
#line 1325
    if (tmp___14) {
      {
#line 1325
      tmp___19 = fabs(rhslowi);
      }
#line 1325
      if (tmp___19 < dy_tols->inf) {
        {
#line 1325
        tmp___17 = fabs(rhslowi);
#line 1325
        tmp___18 = lhsi - rhslowi > dy_tols->pfeas * (1.0 + tmp___17);
        }
      } else {
#line 1325
        tmp___18 = lhsi > rhslowi;
      }
#line 1325
      if (tmp___18) {
#line 1328
        activate = (bool )0;
      } else {
#line 1326
        activate = (bool )1;
      }
    } else {
#line 1326
      activate = (bool )1;
    }
#line 1329
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1331
    errmsg(1, rtnnme, 1331);
    }
#line 1332
    if ((unsigned long )orig_x != (unsigned long )((void *)0)) {
      {
#line 1332
      free((void *)orig_x);
      }
    }
#line 1333
    if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
      {
#line 1333
      free((void *)ocndxs);
      }
    }
#line 1334
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 1336
    if ((int )activate == 0) {
#line 1337
      if (dy_opts->print.conmgmt >= 3) {
        {
#line 1338
        tmp___20 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1338
        tmp___21 = consys_prtcontyp(*(orig_ctyp + i));
#line 1338
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    skipping %s constraint %s (%d), %g <= %g <= %g.",
                    tmp___21, tmp___20, i, rhslowi, lhsi, rhsi);
        }
      }
    } else
#line 1344
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 1345
      tmp___22 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1345
      tmp___23 = consys_prtcontyp(*(orig_ctyp + i));
#line 1345
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s constraint %s (%d),", tmp___23,
                  tmp___22, i);
#line 1348
      tmp___29 = fabs(rhsi);
      }
#line 1348
      if (tmp___29 < dy_tols->inf) {
        {
#line 1348
        tmp___27 = fabs(rhsi);
#line 1348
        tmp___28 = lhsi - rhsi > dy_tols->pfeas * (1.0 + tmp___27);
        }
      } else {
#line 1348
        tmp___28 = lhsi > rhsi;
      }
#line 1348
      if (tmp___28) {
        {
#line 1349
        tmp___24 = fabs(rhsi);
#line 1349
        dyio_outfmt(dy_logchn, dy_gtxecho, " lhs - rhs = %g - %g = %g, tol %g.", lhsi,
                    rhsi, lhsi - rhsi, dy_tols->zero * ((double )1 + tmp___24));
        }
      } else {
        {
#line 1353
        tmp___25 = fabs(rhslowi);
#line 1353
        dyio_outfmt(dy_logchn, dy_gtxecho, " rhslow - lhs = %g - %g = %g, tol %g.",
                    rhslowi, lhsi, rhslowi - lhsi, dy_tols->zero * ((double )1 + tmp___25));
        }
      }
    }
#line 1359
    if ((int )activate == 1) {
#line 1359
      tmp___30 = actcnt;
#line 1359
      actcnt ++;
#line 1359
      *(ocndxs + tmp___30) = i;
    }
    __Cont: /* CIL Label */ 
#line 1298
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1360
  if ((unsigned long )orig_x != (unsigned long )((void *)0)) {
    {
#line 1360
    free((void *)orig_x);
    }
  }
#line 1364
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
#line 1365
    if (actcnt == 0) {
      {
#line 1366
      free((void *)ocndxs);
      }
    } else {
#line 1368
      *p_ocndxs = ocndxs;
    }
  }
#line 1371
  if (dy_opts->print.conmgmt >= 1) {
#line 1372
    if (dy_opts->con.actlvl == 0) {
#line 1372
      tmp___31 = "violated";
    } else {
#line 1372
      tmp___31 = "tight or violated";
    }
    {
#line 1372
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d %s constraints for activation.",
                actcnt, tmp___31);
    }
  }
#line 1377
  return (actcnt);
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
static int scanPrimConStdDeact(int **p_acndxs ) 
{ 
  int j ;
  int m ;
  int purgecnt ;
  int *acndxs ;
  flags statj ;
  bool purge ;
  char const   *rtnnme ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *strat ;

  {
#line 1430
  rtnnme = "scanPrimConStdDeact";
#line 1438
  m = dy_sys->concnt;
#line 1439
  if ((unsigned long )*p_acndxs == (unsigned long )((void *)0)) {
    {
#line 1440
    tmp = malloc((unsigned long )m * sizeof(int ));
#line 1440
    acndxs = (int *)tmp;
    }
  } else {
#line 1442
    acndxs = *p_acndxs;
  }
#line 1448
  purgecnt = 0;
#line 1449
  j = 1;
  {
#line 1449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1449
    if (! (j <= m)) {
#line 1449
      goto while_break;
    }
#line 1450
    statj = *(dy_status + j);
#line 1451
    purge = (bool )0;
#line 1452
    if (statj & (unsigned int )((((1 << 2) | (1 << 3)) | (1 << 1)) | 1)) {
#line 1452
      tmp___5 = 1;
    } else {
#line 1452
      tmp___5 = 0;
    }
#line 1452
    if (tmp___5) {
      {
#line 1454
      if (dy_opts->con.deactlvl == 0) {
#line 1454
        goto case_0;
      }
#line 1457
      if (dy_opts->con.deactlvl == 1) {
#line 1457
        goto case_1;
      }
#line 1462
      if (dy_opts->con.deactlvl == 2) {
#line 1462
        goto case_2;
      }
#line 1467
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1455
      if (statj & (unsigned int )(1 << 2)) {
#line 1455
        tmp___0 = 1;
      } else {
#line 1455
        tmp___0 = 0;
      }
#line 1455
      if (tmp___0) {
#line 1455
        purge = (bool )1;
      }
#line 1456
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1458
      if (statj & (unsigned int )(1 << 2)) {
#line 1458
        tmp___1 = 1;
      } else {
#line 1458
        tmp___1 = 0;
      }
#line 1458
      if (tmp___1) {
#line 1460
        purge = (bool )1;
      } else {
#line 1458
        if (statj & (unsigned int )((1 << 3) | (1 << 1))) {
#line 1458
          tmp___2 = 1;
        } else {
#line 1458
          tmp___2 = 0;
        }
#line 1458
        if (tmp___2) {
#line 1458
          if (*(dy_y + j) == (double )0) {
#line 1460
            purge = (bool )1;
          }
        }
      }
#line 1461
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1463
      if (statj & (unsigned int )(1 << 2)) {
#line 1463
        tmp___3 = 1;
      } else {
#line 1463
        tmp___3 = 0;
      }
#line 1463
      if (tmp___3) {
#line 1465
        purge = (bool )1;
      } else {
#line 1463
        if (statj & (unsigned int )(((1 << 3) | (1 << 1)) | 1)) {
#line 1463
          tmp___4 = 1;
        } else {
#line 1463
          tmp___4 = 0;
        }
#line 1463
        if (tmp___4) {
#line 1463
          if (*(dy_y + j) == (double )0) {
#line 1465
            purge = (bool )1;
          }
        }
      }
#line 1466
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1468
      errmsg(1, rtnnme, 1468);
      }
#line 1469
      if ((unsigned long )*p_acndxs == (unsigned long )((void *)0)) {
#line 1469
        if ((unsigned long )acndxs != (unsigned long )((void *)0)) {
          {
#line 1469
          free((void *)acndxs);
          }
        }
      }
#line 1470
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 1473
    if ((int )purge == 0) {
#line 1474
      if (dy_opts->print.conmgmt >= 3) {
        {
#line 1475
        tmp___6 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 1475
        tmp___7 = consys_prtcontyp(*(dy_sys->ctyp + j));
#line 1475
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    skipped %s %s (%d), ", tmp___7,
                    tmp___6, j);
#line 1478
        tmp___8 = dy_prtvstat(statj);
#line 1478
        tmp___9 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1478
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s (%d) = %g, status %s, basis pos\'n %d.",
                    tmp___9, j, *(dy_x + j), tmp___8, *(dy_basis + j));
        }
      }
    } else
#line 1483
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 1484
      tmp___10 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 1484
      tmp___11 = consys_prtcontyp(*(dy_sys->ctyp + j));
#line 1484
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s %s (%d), ", tmp___11, tmp___10,
                  j);
#line 1487
      tmp___12 = dy_prtvstat(statj);
#line 1487
      tmp___13 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1487
      dyio_outfmt(dy_logchn, dy_gtxecho, "%s (%d) = %g, status %s, basis pos\'n %d.",
                  tmp___13, j, *(dy_x + j), tmp___12, *(dy_basis + j));
      }
    }
#line 1493
    if ((int )purge == 1) {
#line 1494
      tmp___14 = purgecnt;
#line 1494
      purgecnt ++;
#line 1494
      *(acndxs + tmp___14) = j;
    }
#line 1449
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1496
  if ((unsigned long )*p_acndxs == (unsigned long )((void *)0)) {
#line 1497
    if (purgecnt <= 0) {
      {
#line 1498
      free((void *)acndxs);
      }
    } else {
#line 1500
      *p_acndxs = acndxs;
    }
  }
#line 1503
  if (dy_opts->print.varmgmt >= 1) {
    {
#line 1506
    if (dy_opts->con.deactlvl == 0) {
#line 1506
      goto case_0___0;
    }
#line 1509
    if (dy_opts->con.deactlvl == 1) {
#line 1509
      goto case_1___0;
    }
#line 1512
    if (dy_opts->con.deactlvl == 2) {
#line 1512
      goto case_2___0;
    }
#line 1515
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 1507
    strat = "normal";
#line 1508
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1510
    strat = "aggressive";
#line 1511
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1513
    strat = "fanatic";
#line 1514
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1516
    strat = "invalid";
#line 1517
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1518
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %s scan queued %d constraints for deactivation.",
                strat, purgecnt);
    }
  }
#line 1523
  return (purgecnt);
}
}
#line 1527 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
int dy_deactivateCons(consys_struct *orig_sys ) 
{ 
  int *candidates ;
  int cand_cnt ;
  dyret_enum factorresult ;
  flags factorflags ;
  int retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;

  {
  {
#line 1553
  rtnnme = "dy_deactivateCons";
#line 1555
  retval = -1;
#line 1560
  candidates = (int *)((void *)0);
#line 1561
  cand_cnt = scanPrimConStdDeact(& candidates);
  }
#line 1562
  if (cand_cnt < 0) {
    {
#line 1563
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1563
    errmsg(434, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "constraint", "normal deactivation");
    }
  } else
#line 1567
  if (cand_cnt > 0) {
    {
#line 1568
    tmp___0 = deactBLogPrimConList(orig_sys, cand_cnt, candidates);
    }
#line 1568
    if ((int )tmp___0 == 1) {
#line 1578
      if (dy_sys->concnt > 0) {
#line 1579
        factorflags = (flags )((1 << 6) | (1 << 7));
#line 1581
        if (dy_opts->print.conmgmt >= 3) {
          {
#line 1582
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      refactoring ...");
          }
        }
        {
#line 1584
        factorresult = dy_factor(& factorflags);
        }
        {
#line 1587
        if ((int )factorresult == 2) {
#line 1587
          goto case_2;
        }
#line 1587
        if ((int )factorresult == 1) {
#line 1587
          goto case_2;
        }
#line 1597
        goto switch_default;
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
#line 1588
        retval = cand_cnt;
#line 1590
        if (dy_opts->print.conmgmt >= 3) {
#line 1591
          if ((int )factorresult == 1) {
            {
#line 1592
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
            }
          } else {
            {
#line 1594
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
            }
          }
        }
#line 1596
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1598
        retval = -1;
#line 1600
        if (dy_opts->print.conmgmt >= 3) {
          {
#line 1601
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
          }
        }
#line 1603
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 1605
        retval = cand_cnt;
      }
    } else {
#line 1607
      retval = -1;
    }
  } else {
#line 1609
    retval = cand_cnt;
  }
#line 1611
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1611
    free((void *)candidates);
    }
  }
#line 1614
  if (dy_opts->print.conmgmt >= 1) {
    {
#line 1615
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %d constraints deactivated.", cand_cnt);
#line 1617
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 1623
  return (retval);
}
}
#line 1627 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_conmgmt.c"
int dy_activateCons(consys_struct *orig_sys , bool with_vars ) 
{ 
  int *candidates ;
  int cand_cnt ;
  int *inactvars ;
  int inact_cnt ;
  int retval ;
  int var_retval ;
  bool actresult ;
  flags calcflgs ;
  dyret_enum factorresult ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 1654
  rtnnme = "dy_activateCons";
#line 1656
  retval = -1;
#line 1664
  candidates = (int *)((void *)0);
#line 1665
  inactvars = (int *)((void *)0);
#line 1666
  inact_cnt = 0;
#line 1667
  cand_cnt = scanPrimConStdAct(orig_sys, & candidates);
  }
#line 1668
  if (cand_cnt < 0) {
    {
#line 1669
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1669
    errmsg(434, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "constraint", "normal activation");
#line 1672
    actresult = (bool )0;
    }
  } else
#line 1674
  if (cand_cnt > 0) {
#line 1675
    if ((int )with_vars == 1) {
      {
#line 1676
      actresult = dy_actBLogPrimConList(orig_sys, cand_cnt, candidates, & inactvars);
      }
#line 1678
      if ((unsigned long )inactvars != (unsigned long )((void *)0)) {
#line 1679
        inact_cnt = *(inactvars + 0);
      }
    } else {
      {
#line 1681
      actresult = dy_actBLogPrimConList(orig_sys, cand_cnt, candidates, (int **)((void *)0));
      }
    }
  } else {
#line 1684
    actresult = (bool )1;
  }
#line 1685
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1685
    free((void *)candidates);
    }
  }
#line 1686
  if ((int )actresult == 0) {
#line 1687
    if ((unsigned long )inactvars != (unsigned long )((void *)0)) {
      {
#line 1687
      free((void *)inactvars);
      }
    }
#line 1688
    return (retval);
  }
#line 1694
  retval = cand_cnt;
#line 1695
  if (cand_cnt > 0) {
#line 1696
    dy_lp->simplex.init_dse = (bool )1;
#line 1698
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 1699
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      factoring, calculating variables, ");
#line 1701
      dyio_outfmt(dy_logchn, dy_gtxecho, "and checking feasibility ...");
      }
    }
    {
#line 1703
    calcflgs = (flags )(((((1 << 8) | 1) | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 1704
    factorresult = dy_accchk(& calcflgs);
    }
    {
#line 1707
    if ((int )factorresult == 2) {
#line 1707
      goto case_2;
    }
#line 1707
    if ((int )factorresult == 1) {
#line 1707
      goto case_2;
    }
#line 1724
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1708
    retval = cand_cnt;
#line 1710
    if (dy_opts->print.conmgmt >= 3) {
#line 1711
      if ((int )factorresult == 1) {
        {
#line 1712
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
        }
      } else {
        {
#line 1714
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
        }
      }
    }
#line 1716
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 1716
      tmp___1 = 0;
    } else {
#line 1716
      tmp___1 = 1;
    }
#line 1716
    if (tmp___1) {
#line 1717
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 1719
      if (calcflgs & 1U) {
#line 1719
        tmp___0 = 0;
      } else {
#line 1719
        tmp___0 = 1;
      }
#line 1719
      if (tmp___0) {
#line 1720
        dy_lp->simplex.next = (dyphase_enum )3;
      } else {
#line 1722
        dy_lp->simplex.next = (dyphase_enum )2;
      }
    }
#line 1723
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1725
    retval = -1;
#line 1727
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 1728
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
      }
    }
#line 1730
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1735
    if ((int )with_vars == 1) {
#line 1735
      if (inact_cnt > 0) {
        {
#line 1736
        var_retval = dy_activateVars(orig_sys, inactvars);
        }
#line 1737
        if (var_retval < 0) {
          {
#line 1738
          tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1738
          errmsg(440, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters);
#line 1740
          retval = var_retval;
          }
        }
      }
    }
  }
#line 1741
  if ((unsigned long )inactvars != (unsigned long )((void *)0)) {
    {
#line 1741
    free((void *)inactvars);
    }
  }
#line 1745
  if (dy_opts->print.conmgmt >= 1) {
    {
#line 1746
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  activated %d constraints", cand_cnt);
    }
#line 1747
    if ((int )with_vars == 1) {
      {
#line 1748
      dyio_outfmt(dy_logchn, dy_gtxecho, " with %d referenced variables", inact_cnt);
      }
    }
    {
#line 1750
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
#line 1751
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 1757
  return (retval);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
long dyio_mark(ioid id ) ;
#line 92
bool dyio_backup(ioid id , long there ) ;
#line 95
lex_struct *dyio_scanlex(ioid id ) ;
#line 95
lex_struct *dyio_scanstr(ioid id , lexclass stype , int fslen , char qschr , char qechr ) ;
#line 714 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
void rdrinit(void) ;
#line 714
void rdrclear(void) ;
#line 715
bool parse(ioid chn , struct bnfref_type3 *bnfid , parse_any *result ) ;
#line 723
void bnfdbgctl(ioid dbgchn_p , bool dbgecho_p , bool warnzlbl_p , bool numlvl_p ,
               bool tablvl_p ) ;
#line 733
void prtbnfref(ioid chn , bool echo , bnfref_struct *bnfref ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static void *curnde  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static void *newnde  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static int cndesze  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static char *curtxt  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static char *newtxt  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static ioid bnfchn  ;
#line 66 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static char const   *savedtxt[11]  ;
#line 82
void printtab(ioid chn , bool echo , int nestlvl___0 , bool numlvl___0 , bool tablvl___0 ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static int debug  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static ioid dbgchn  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool dbgecho  =    (bool )1;
#line 88 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static int nestlvl  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool warnzlbl  =    (bool )1;
#line 89 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool numlvl  =    (bool )1;
#line 89 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool tablvl  =    (bool )1;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static deflbl_struct *blbllst  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static deflbl_struct *flbllst  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static udeflbl_struct *ublbllst  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static udeflbl_struct *uflbllst  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static void strenter(int ndx , char const   *txt ) 
{ 
  char const   *rtnnme ;

  {
#line 160
  rtnnme = "strenter";
#line 165
  if (ndx < 0) {
    {
#line 166
    errmsg(40, rtnnme, ndx, 10);
    }
#line 167
    return;
  } else
#line 165
  if (ndx > 10) {
    {
#line 166
    errmsg(40, rtnnme, ndx, 10);
    }
#line 167
    return;
  }
#line 168
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
    {
#line 169
    errmsg(2, rtnnme, "txt");
    }
#line 170
    return;
  }
#line 174
  if ((unsigned long )savedtxt[ndx] != (unsigned long )((void *)0)) {
    {
#line 174
    strfree(savedtxt[ndx]);
    }
  }
  {
#line 175
  savedtxt[ndx] = stralloc(txt);
  }
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static char const   *strretrv(int ndx ) 
{ 
  char const   *rtnnme ;

  {
#line 192
  rtnnme = "strretrv";
#line 197
  if (ndx < 0) {
    {
#line 198
    errmsg(40, rtnnme, ndx, 10);
    }
#line 199
    return ((char const   *)((void *)0));
  } else
#line 197
  if (ndx > 10) {
    {
#line 198
    errmsg(40, rtnnme, ndx, 10);
    }
#line 199
    return ((char const   *)((void *)0));
  }
#line 203
  if ((unsigned long )savedtxt[ndx] == (unsigned long )((void *)0)) {
    {
#line 203
    errmsg(51, rtnnme, ndx);
    }
  }
#line 205
  return (savedtxt[ndx]);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static deflbl_struct *finddlbl(deflbl_struct **lst , char const   *txt ) 
{ 
  deflbl_struct *lblent ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 247
  rtnnme = "finddlbl";
#line 252
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
    {
#line 253
    errmsg(2, rtnnme, "label list");
    }
#line 254
    return ((deflbl_struct *)((void *)0));
  }
#line 255
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
    {
#line 256
    errmsg(2, rtnnme, "label name");
    }
#line 257
    return ((deflbl_struct *)((void *)0));
  }
#line 261
  lblent = *lst;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! ((unsigned long )lblent != (unsigned long )((void *)0))) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp = cistrcmp(lblent->lblnmtxt, txt);
    }
#line 262
    if (tmp == 0) {
#line 262
      return (lblent);
    }
#line 261
    lblent = lblent->lblnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return ((deflbl_struct *)((void *)0));
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static void lblresolve(udeflbl_struct **lst , deflbl_struct *dlbl ) 
{ 
  udeflbl_struct **ulbl2 ;
  udeflbl_struct *ulbl1 ;
  char const   *nmtxt ;
  void **socket ;
  char const   *rtnnme ;

  {
#line 286
  rtnnme = "lblresolve";
#line 291
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
    {
#line 292
    errmsg(2, rtnnme, "label list");
    }
#line 293
    return;
  }
#line 294
  if ((unsigned long )dlbl == (unsigned long )((void *)0)) {
    {
#line 295
    errmsg(2, rtnnme, "defined label");
    }
#line 296
    return;
  }
#line 300
  nmtxt = dlbl->lblnmtxt;
#line 301
  ulbl2 = lst;
#line 301
  ulbl1 = *ulbl2;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )ulbl1 != (unsigned long )((void *)0))) {
#line 301
      goto while_break;
    }
#line 304
    if ((unsigned long )ulbl1->lblnmtxt == (unsigned long )nmtxt) {
#line 305
      *ulbl2 = ulbl1->lblnxt;
#line 306
      if ((unsigned long )lst == (unsigned long )(& uflbllst)) {
#line 307
        socket = (void **)((ptrdiff_t )dlbl->lblval);
#line 308
        *socket = ulbl1->lblval;
      } else {
        {
#line 310
        socket = (void **)((ptrdiff_t )ulbl1->lblval);
#line 311
        *socket = dlbl->lblval;
#line 312
        free((void *)((char *)ulbl1));
        }
      }
    }
#line 301
    ulbl2 = & ulbl1->lblnxt;
#line 301
    ulbl1 = *ulbl2;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
void rdrinit(void) 
{ 
  int ndx ;

  {
#line 332
  curnde = (void *)0;
#line 333
  cndesze = 0;
#line 334
  newnde = (void *)0;
#line 335
  curtxt = (char *)((void *)0);
#line 336
  newtxt = (char *)((void *)0);
#line 337
  ndx = 0;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! (ndx < 10)) {
#line 337
      goto while_break;
    }
#line 337
    savedtxt[ndx] = (char const   *)((void *)0);
#line 337
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  flbllst = (deflbl_struct *)((void *)0);
#line 339
  blbllst = (deflbl_struct *)((void *)0);
#line 340
  uflbllst = (udeflbl_struct *)((void *)0);
#line 341
  ublbllst = (udeflbl_struct *)((void *)0);
#line 343
  return;
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
void rdrclear(void) 
{ 
  int ndx ;
  deflbl_struct *dlbl ;
  deflbl_struct *nxtdlbl ;
  udeflbl_struct *udlbl ;
  udeflbl_struct *nxtudlbl ;
  char const   *rtnnme ;

  {
#line 362
  rtnnme = "rdrclear";
#line 364
  dlbl = blbllst;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! ((unsigned long )dlbl != (unsigned long )((void *)0))) {
#line 364
      goto while_break;
    }
    {
#line 365
    nxtdlbl = dlbl->lblnxt;
#line 366
    strfree(dlbl->lblnmtxt);
#line 367
    free((void *)((char *)dlbl));
#line 364
    dlbl = nxtdlbl;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  blbllst = (deflbl_struct *)((void *)0);
#line 369
  dlbl = flbllst;
  {
#line 369
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 369
    if (! ((unsigned long )dlbl != (unsigned long )((void *)0))) {
#line 369
      goto while_break___0;
    }
    {
#line 370
    nxtdlbl = dlbl->lblnxt;
#line 371
    strfree(dlbl->lblnmtxt);
#line 372
    free((void *)((char *)dlbl));
#line 369
    dlbl = nxtdlbl;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 373
  flbllst = (deflbl_struct *)((void *)0);
#line 374
  udlbl = ublbllst;
  {
#line 374
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 374
    if (! ((unsigned long )udlbl != (unsigned long )((void *)0))) {
#line 374
      goto while_break___1;
    }
    {
#line 375
    nxtudlbl = udlbl->lblnxt;
#line 376
    strfree(udlbl->lblnmtxt);
#line 377
    free((void *)((char *)udlbl));
#line 374
    udlbl = nxtudlbl;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 378
  ublbllst = (udeflbl_struct *)((void *)0);
#line 379
  udlbl = uflbllst;
  {
#line 379
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 379
    if (! ((unsigned long )udlbl != (unsigned long )((void *)0))) {
#line 379
      goto while_break___2;
    }
    {
#line 380
    nxtudlbl = udlbl->lblnxt;
#line 381
    strfree(udlbl->lblnmtxt);
#line 382
    free((void *)((char *)udlbl));
#line 379
    udlbl = nxtudlbl;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 383
  uflbllst = (udeflbl_struct *)((void *)0);
#line 385
  ndx = 0;
  {
#line 385
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 385
    if (! (ndx < 10)) {
#line 385
      goto while_break___3;
    }
#line 386
    if ((unsigned long )savedtxt[ndx] != (unsigned long )((void *)0)) {
      {
#line 386
      strfree(savedtxt[ndx]);
      }
    }
#line 387
    savedtxt[ndx] = (char const   *)((void *)0);
#line 385
    ndx ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 389
  if ((unsigned long )newtxt != (unsigned long )((void *)0)) {
    {
#line 390
    free((void *)newtxt);
#line 391
    newtxt = (char *)((void *)0);
    }
  }
#line 393
  if ((unsigned long )curnde != (unsigned long )((void *)0)) {
    {
#line 393
    warn(71, rtnnme, "curnde");
    }
  }
#line 394
  if ((unsigned long )curtxt != (unsigned long )((void *)0)) {
    {
#line 394
    warn(71, rtnnme, "curtxt");
    }
  }
#line 396
  return;
}
}
#line 406
static bool dogenerator(bnfGref_struct *ref ) ;
#line 406
static bool dononprimitive(bnfNPref_struct *ref ) ;
#line 406
static bool doprimitive(bnfNPref_struct *ref ) ;
#line 406
static bool doterminal(bnfTref_struct *ref ) ;
#line 406
static bool doimmediate(bnfIref_struct *ref ) ;
#line 406
static bool doliteral(bnfLref_struct *ref ) ;
#line 406
static bool dolabel(bnfLBref_struct *ref ) ;
#line 406
static bool doreference(bnfLBref_struct *ref ) ;
#line 406
static bool dolist(bnfref_any ref ) ;
#line 418 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool dogenerator(bnfGref_struct *ref ) 
{ 
  void *savcnde ;
  void **socket ;
  int savcndesze ;
  int compnum ;
  int compndx ;
  bnfGdef_struct *def ;
  bnfref_struct **comprefs ;
  bnfref_any compref ;
  bool success ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  bnfref_struct **tmp___5 ;
  bnfref_struct **tmp___6 ;
  bnfref_struct **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 439
  rtnnme = "dogenerator";
#line 444
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 445
    errmsg(2, rtnnme, "bnf ref");
    }
#line 446
    return ((bool )0);
  }
#line 447
  def = (bnfGdef_struct *)ref->defn;
#line 448
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 449
    errmsg(33, rtnnme);
    }
#line 450
    return ((bool )0);
  }
#line 451
  if ((unsigned int )def->type != 0U) {
    {
#line 452
    errmsg(36, rtnnme);
    }
#line 453
    return ((bool )0);
  }
#line 456
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 456
    tmp___0 = 1;
  } else {
#line 456
    tmp___0 = 0;
  }
#line 456
  if (tmp___0) {
#line 457
    tmp = debug;
#line 457
    debug ++;
#line 457
    if (tmp == 0) {
      {
#line 458
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
#line 459
      nestlvl = 0;
      }
    }
  }
#line 460
  if (debug > 0) {
    {
#line 461
    nestlvl ++;
#line 462
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 463
    prtbnfref(dbgchn, dbgecho, (bnfref_struct *)ref);
#line 464
    dyio_outfmt(dbgchn, dbgecho, " ::=\n");
    }
  }
#line 473
  if (ref->uflgs & (unsigned int )(1 << 1)) {
#line 473
    tmp___2 = 1;
  } else {
#line 473
    tmp___2 = 0;
  }
#line 473
  if (tmp___2 == 1) {
#line 473
    if (ref->uflgs & 1U) {
#line 473
      tmp___3 = 0;
    } else {
#line 473
      tmp___3 = 1;
    }
#line 473
    if (tmp___3 == 1) {
#line 474
      if ((unsigned long )curnde == (unsigned long )((void *)0)) {
        {
#line 475
        errmsg(68, rtnnme);
        }
#line 476
        return ((bool )0);
      }
#line 477
      if (ref->offset >= 0) {
#line 477
        if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(void *)) {
#line 477
          tmp___1 = 1;
        } else {
#line 477
          tmp___1 = 0;
        }
      } else {
#line 477
        tmp___1 = 0;
      }
#line 477
      if (tmp___1 == 0) {
        {
#line 478
        errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(void *));
        }
#line 479
        return ((bool )0);
      }
#line 480
      socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )ref->offset);
    } else {
#line 482
      socket = (void **)((void *)0);
    }
  } else {
#line 482
    socket = (void **)((void *)0);
  }
#line 489
  if (def->size <= 0) {
    {
#line 490
    errmsg(31, rtnnme, def->size);
    }
#line 491
    return ((bool )0);
  }
  {
#line 492
  savcnde = curnde;
#line 493
  savcndesze = cndesze;
#line 494
  cndesze = def->size;
#line 495
  tmp___4 = malloc((size_t )cndesze);
#line 495
  curnde = tmp___4;
#line 496
  memset(curnde, 0, (size_t )cndesze);
#line 501
  comprefs = def->comps;
  }
#line 502
  if ((unsigned long )comprefs != (unsigned long )((void *)0)) {
#line 503
    tmp___5 = comprefs;
#line 503
    comprefs ++;
#line 503
    compnum = (int )((char *)*tmp___5 - (char *)0);
#line 504
    tmp___6 = comprefs;
#line 504
    comprefs ++;
#line 504
    compref.com = *tmp___6;
  } else {
#line 506
    compnum = 0;
  }
#line 510
  compndx = 0;
#line 510
  success = (bool )1;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (compndx < compnum) {
#line 510
      if (! ((int )success == 1)) {
#line 510
        goto while_break;
      }
    } else {
#line 510
      goto while_break;
    }
#line 513
    if ((unsigned long )compref.com == (unsigned long )((void *)0)) {
      {
#line 514
      errmsg(32, rtnnme, compndx + 1, compnum);
#line 515
      success = (bool )0;
      }
#line 516
      goto while_break;
    }
    {
#line 518
    if ((unsigned int )(compref.com)->type == 0U) {
#line 518
      goto case_0;
    }
#line 524
    if ((unsigned int )(compref.com)->type == 1U) {
#line 524
      goto case_1;
    }
#line 530
    if ((unsigned int )(compref.com)->type == 2U) {
#line 530
      goto case_2;
    }
#line 536
    if ((unsigned int )(compref.com)->type == 3U) {
#line 536
      goto case_3;
    }
#line 539
    if ((unsigned int )(compref.com)->type == 8U) {
#line 539
      goto case_8;
    }
#line 542
    if ((unsigned int )(compref.com)->type == 9U) {
#line 542
      goto case_9;
    }
#line 547
    if ((unsigned int )(compref.com)->type == 5U) {
#line 547
      goto case_5;
    }
#line 547
    if ((unsigned int )(compref.com)->type == 4U) {
#line 547
      goto case_5;
    }
#line 551
    if ((unsigned int )(compref.com)->type == 7U) {
#line 551
      goto case_7;
    }
#line 551
    if ((unsigned int )(compref.com)->type == 6U) {
#line 551
      goto case_7;
    }
#line 554
    goto switch_default;
    case_0: /* CIL Label */ 
#line 519
    if ((compref.G)->uflgs & 1U) {
#line 519
      tmp___8 = 1;
    } else {
#line 519
      tmp___8 = 0;
    }
#line 519
    if (tmp___8 == 1) {
      {
#line 520
      success = dolist(compref);
      }
    } else {
      {
#line 522
      success = dogenerator(compref.G);
      }
    }
#line 523
    goto switch_break;
    case_1: /* CIL Label */ 
#line 525
    if ((compref.NP)->uflgs & 1U) {
#line 525
      tmp___9 = 1;
    } else {
#line 525
      tmp___9 = 0;
    }
#line 525
    if (tmp___9 == 1) {
      {
#line 526
      success = dolist(compref);
      }
    } else {
      {
#line 528
      success = dononprimitive(compref.NP);
      }
    }
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
#line 531
    if ((compref.P)->uflgs & 1U) {
#line 531
      tmp___10 = 1;
    } else {
#line 531
      tmp___10 = 0;
    }
#line 531
    if (tmp___10 == 1) {
      {
#line 532
      success = dolist(compref);
      }
    } else {
      {
#line 534
      success = doprimitive(compref.P);
      }
    }
#line 535
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 537
    success = doterminal(compref.T);
    }
#line 538
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 540
    success = doimmediate(compref.I);
    }
#line 541
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 543
    errmsg(34, rtnnme, "literal", "generator");
#line 544
    success = (bool )0;
    }
#line 545
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 548
    success = dolabel(compref.LB);
    }
#line 549
    goto switch_break;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    {
#line 552
    success = doreference(compref.LB);
    }
#line 553
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 555
    errmsg(35, rtnnme, (unsigned int )(compref.com)->type);
#line 556
    success = (bool )0;
    }
#line 557
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 510
    compndx ++;
#line 510
    tmp___7 = comprefs;
#line 510
    comprefs ++;
#line 510
    compref.com = *tmp___7;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  if (debug > 0) {
#line 561
    if ((int )success == 0) {
      {
#line 562
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 563
      dyio_outfmt(dbgchn, dbgecho, "-- fail @ %d of %d --", compndx, compnum);
      }
    }
    {
#line 564
    dyio_outchr(dbgchn, dbgecho, (char )'\n');
#line 565
    nestlvl --;
    }
#line 566
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 566
      tmp___11 = 1;
    } else {
#line 566
      tmp___11 = 0;
    }
#line 566
    if (tmp___11) {
#line 567
      debug --;
#line 567
      if (debug == 0) {
        {
#line 568
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 575
  if ((int )success == 1) {
#line 576
    if ((unsigned long )socket != (unsigned long )((void *)0)) {
#line 576
      *socket = curnde;
    }
#line 577
    newnde = curnde;
  }
#line 581
  curnde = savcnde;
#line 582
  cndesze = savcndesze;
#line 584
  return (success);
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool dononprimitive(bnfNPref_struct *ref ) 
{ 
  void *savcnde ;
  bnfNPdef_struct *def ;
  bnfref_struct ***altrefs ;
  bnfref_struct **comprefs ;
  bnfref_any compref ;
  int altnum ;
  int altndx ;
  int compnum ;
  int compndx ;
  long marker ;
  bool success ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  bnfref_struct ***tmp___2 ;
  bnfref_struct ***tmp___3 ;
  bnfref_struct ***tmp___4 ;
  bnfref_struct **tmp___5 ;
  bnfref_struct **tmp___6 ;
  bnfref_struct **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 604
  savcnde = (void *)0;
#line 611
  rtnnme = "dononprimitive";
#line 616
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 617
    errmsg(2, rtnnme, "bnf ref");
    }
#line 618
    return ((bool )0);
  }
#line 619
  def = (bnfNPdef_struct *)ref->defn;
#line 620
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 621
    errmsg(33, rtnnme);
    }
#line 622
    return ((bool )0);
  }
#line 623
  if ((unsigned int )def->type != 1U) {
    {
#line 624
    errmsg(38, rtnnme);
    }
#line 625
    return ((bool )0);
  }
#line 628
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 628
    tmp___0 = 1;
  } else {
#line 628
    tmp___0 = 0;
  }
#line 628
  if (tmp___0) {
#line 629
    tmp = debug;
#line 629
    debug ++;
#line 629
    if (tmp == 0) {
      {
#line 630
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
#line 631
      nestlvl = 0;
      }
    }
  }
#line 632
  if (debug > 0) {
    {
#line 633
    nestlvl ++;
#line 634
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 635
    prtbnfref(dbgchn, dbgecho, (bnfref_struct *)ref);
#line 636
    dyio_outfmt(dbgchn, dbgecho, " ::=\n");
    }
  }
  {
#line 643
  marker = dyio_mark(bnfchn);
  }
#line 644
  if ((unsigned long )curnde != (unsigned long )((void *)0)) {
#line 645
    if (cndesze <= 0) {
      {
#line 646
      errmsg(1, rtnnme, 646);
      }
#line 647
      return ((bool )0);
    }
    {
#line 648
    tmp___1 = malloc((size_t )cndesze);
#line 648
    savcnde = tmp___1;
#line 649
    memcpy((void */* __restrict  */)savcnde, (void const   */* __restrict  */)curnde,
           (size_t )cndesze);
    }
  }
#line 654
  altrefs = def->alts;
#line 655
  if ((unsigned long )altrefs != (unsigned long )((void *)0)) {
#line 656
    tmp___2 = altrefs;
#line 656
    altrefs ++;
#line 656
    altnum = (int )((char *)*tmp___2 - (char *)0);
#line 657
    tmp___3 = altrefs;
#line 657
    altrefs ++;
#line 657
    comprefs = *tmp___3;
  } else {
#line 659
    altnum = 0;
#line 660
    comprefs = (bnfref_struct **)((void *)0);
  }
#line 664
  altndx = 0;
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
#line 664
    if (! (altndx < altnum)) {
#line 664
      goto while_break;
    }
#line 674
    if (debug > 0) {
      {
#line 675
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 676
      dyio_outfmt(dbgchn, dbgecho, "[ alternative %d of %d ]\n", altndx + 1, altnum);
      }
    }
#line 680
    if ((unsigned long )comprefs == (unsigned long )((void *)0)) {
      {
#line 681
      errmsg(37, rtnnme, altndx + 1, altnum);
      }
#line 682
      goto while_break;
    } else {
#line 684
      tmp___5 = comprefs;
#line 684
      comprefs ++;
#line 684
      compnum = (int )((char *)*tmp___5 - (char *)0);
#line 685
      tmp___6 = comprefs;
#line 685
      comprefs ++;
#line 685
      compref.com = *tmp___6;
    }
#line 689
    compndx = 0;
#line 689
    success = (bool )1;
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 689
      if (compndx < compnum) {
#line 689
        if (! ((int )success == 1)) {
#line 689
          goto while_break___0;
        }
      } else {
#line 689
        goto while_break___0;
      }
#line 692
      if ((unsigned long )compref.com == (unsigned long )((void *)0)) {
        {
#line 693
        errmsg(32, rtnnme, compndx + 1, compnum);
#line 694
        success = (bool )0;
        }
#line 695
        goto while_break___0;
      }
      {
#line 697
      if ((unsigned int )(compref.com)->type == 0U) {
#line 697
        goto case_0;
      }
#line 703
      if ((unsigned int )(compref.com)->type == 1U) {
#line 703
        goto case_1;
      }
#line 709
      if ((unsigned int )(compref.com)->type == 2U) {
#line 709
        goto case_2;
      }
#line 715
      if ((unsigned int )(compref.com)->type == 3U) {
#line 715
        goto case_3;
      }
#line 718
      if ((unsigned int )(compref.com)->type == 8U) {
#line 718
        goto case_8;
      }
#line 721
      if ((unsigned int )(compref.com)->type == 9U) {
#line 721
        goto case_9;
      }
#line 726
      if ((unsigned int )(compref.com)->type == 5U) {
#line 726
        goto case_5;
      }
#line 726
      if ((unsigned int )(compref.com)->type == 4U) {
#line 726
        goto case_5;
      }
#line 730
      if ((unsigned int )(compref.com)->type == 7U) {
#line 730
        goto case_7;
      }
#line 730
      if ((unsigned int )(compref.com)->type == 6U) {
#line 730
        goto case_7;
      }
#line 733
      goto switch_default;
      case_0: /* CIL Label */ 
#line 698
      if ((compref.G)->uflgs & 1U) {
#line 698
        tmp___8 = 1;
      } else {
#line 698
        tmp___8 = 0;
      }
#line 698
      if (tmp___8 == 1) {
        {
#line 699
        success = dolist(compref);
        }
      } else {
        {
#line 701
        success = dogenerator(compref.G);
        }
      }
#line 702
      goto switch_break;
      case_1: /* CIL Label */ 
#line 704
      if ((compref.NP)->uflgs & 1U) {
#line 704
        tmp___9 = 1;
      } else {
#line 704
        tmp___9 = 0;
      }
#line 704
      if (tmp___9 == 1) {
        {
#line 705
        success = dolist(compref);
        }
      } else {
        {
#line 707
        success = dononprimitive(compref.NP);
        }
      }
#line 708
      goto switch_break;
      case_2: /* CIL Label */ 
#line 710
      if ((compref.P)->uflgs & 1U) {
#line 710
        tmp___10 = 1;
      } else {
#line 710
        tmp___10 = 0;
      }
#line 710
      if (tmp___10 == 1) {
        {
#line 711
        success = dolist(compref);
        }
      } else {
        {
#line 713
        success = doprimitive(compref.P);
        }
      }
#line 714
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 716
      success = doterminal(compref.T);
      }
#line 717
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 719
      success = doimmediate(compref.I);
      }
#line 720
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 722
      errmsg(34, rtnnme, "literal", "non-primitive");
#line 723
      success = (bool )0;
      }
#line 724
      goto switch_break;
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 727
      success = dolabel(compref.LB);
      }
#line 728
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 731
      success = doreference(compref.LB);
      }
#line 732
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 734
      errmsg(35, rtnnme, (unsigned int )(compref.com)->type);
#line 735
      success = (bool )0;
      }
#line 736
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 689
      compndx ++;
#line 689
      tmp___7 = comprefs;
#line 689
      comprefs ++;
#line 689
      compref.com = *tmp___7;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 739
    if (debug > 0) {
      {
#line 740
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
      }
#line 741
      if ((int )success == 1) {
        {
#line 742
        dyio_outfmt(dbgchn, dbgecho, "[ pass %d ]", altndx + 1);
#line 743
        nestlvl --;
        }
#line 744
        if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 744
          tmp___11 = 1;
        } else {
#line 744
          tmp___11 = 0;
        }
#line 744
        if (tmp___11) {
#line 745
          debug --;
#line 745
          if (debug == 0) {
            {
#line 746
            dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
            }
          }
        }
      } else {
        {
#line 748
        dyio_outfmt(dbgchn, dbgecho, "[ fail %d @ %d of %d ]", altndx + 1, compndx,
                    compnum);
        }
      }
      {
#line 750
      dyio_outchr(dbgchn, dbgecho, (char )'\n');
      }
    }
#line 758
    if ((int )success == 1) {
#line 759
      if ((unsigned long )curnde != (unsigned long )((void *)0)) {
        {
#line 759
        free((void *)((char *)savcnde));
        }
      }
#line 760
      return ((bool )1);
    } else {
#line 762
      if ((unsigned long )curnde != (unsigned long )((void *)0)) {
        {
#line 762
        memcpy((void */* __restrict  */)curnde, (void const   */* __restrict  */)savcnde,
               (size_t )cndesze);
        }
      }
      {
#line 763
      dyio_backup(bnfchn, marker);
      }
    }
#line 664
    altndx ++;
#line 664
    tmp___4 = altrefs;
#line 664
    altrefs ++;
#line 664
    comprefs = *tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  if ((unsigned long )curnde != (unsigned long )((void *)0)) {
    {
#line 769
    memcpy((void */* __restrict  */)curnde, (void const   */* __restrict  */)savcnde,
           (size_t )cndesze);
#line 770
    free(savcnde);
    }
  }
#line 772
  if (debug > 0) {
#line 773
    nestlvl --;
#line 774
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 774
      tmp___12 = 1;
    } else {
#line 774
      tmp___12 = 0;
    }
#line 774
    if (tmp___12) {
#line 775
      debug --;
#line 775
      if (debug == 0) {
        {
#line 776
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 779
  return ((bool )0);
}
}
#line 783 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool doprimitive(bnfNPref_struct *ref ) 
{ 
  void *savcnde ;
  void **socket ;
  char *savctxt ;
  char *lcltxt ;
  bnfPdef_struct *def ;
  bnfref_struct ***altrefs ;
  bnfref_struct **comprefs ;
  bnfref_any compref ;
  int altnum ;
  int altndx ;
  int compnum ;
  int compndx ;
  long marker ;
  bool success ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  bnfref_struct ***tmp___3 ;
  bnfref_struct ***tmp___4 ;
  bnfref_struct ***tmp___5 ;
  bnfref_struct **tmp___6 ;
  bnfref_struct **tmp___7 ;
  bnfref_struct **tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;

  {
#line 803
  savcnde = (void *)0;
#line 812
  rtnnme = "doprimitive";
#line 817
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 818
    errmsg(2, rtnnme, "bnf ref");
    }
#line 819
    return ((bool )0);
  }
#line 820
  def = (bnfPdef_struct *)ref->defn;
#line 821
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 822
    errmsg(33, rtnnme);
    }
#line 823
    return ((bool )0);
  }
#line 824
  if ((unsigned int )def->type != 2U) {
    {
#line 825
    errmsg(39, rtnnme);
    }
#line 826
    return ((bool )0);
  }
#line 829
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 829
    tmp___0 = 1;
  } else {
#line 829
    tmp___0 = 0;
  }
#line 829
  if (tmp___0) {
#line 830
    tmp = debug;
#line 830
    debug ++;
#line 830
    if (tmp == 0) {
      {
#line 831
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
#line 832
      nestlvl = 0;
      }
    }
  }
#line 833
  if (debug > 0) {
    {
#line 834
    nestlvl ++;
#line 835
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 836
    prtbnfref(dbgchn, dbgecho, (bnfref_struct *)ref);
#line 837
    dyio_outfmt(dbgchn, dbgecho, " ::=\n");
    }
  }
  {
#line 847
  marker = dyio_mark(bnfchn);
  }
#line 848
  if ((unsigned long )curnde != (unsigned long )((void *)0)) {
#line 849
    if (cndesze <= 0) {
      {
#line 850
      errmsg(1, rtnnme, 850);
      }
#line 851
      return ((bool )0);
    }
    {
#line 852
    tmp___1 = malloc((size_t )cndesze);
#line 852
    savcnde = tmp___1;
#line 853
    memcpy((void */* __restrict  */)savcnde, (void const   */* __restrict  */)curnde,
           (size_t )cndesze);
    }
  }
  {
#line 854
  savctxt = curtxt;
#line 855
  curtxt = (char *)((void *)0);
#line 856
  tmp___2 = malloc(sizeof(char ));
#line 856
  lcltxt = (char *)tmp___2;
#line 857
  *lcltxt = (char )'\000';
#line 862
  altrefs = def->alts;
  }
#line 863
  if ((unsigned long )altrefs != (unsigned long )((void *)0)) {
#line 864
    tmp___3 = altrefs;
#line 864
    altrefs ++;
#line 864
    altnum = (int )((char *)*tmp___3 - (char *)0);
#line 865
    tmp___4 = altrefs;
#line 865
    altrefs ++;
#line 865
    comprefs = *tmp___4;
  } else {
#line 867
    altnum = 0;
#line 868
    comprefs = (bnfref_struct **)((void *)0);
  }
#line 872
  altndx = 0;
  {
#line 872
  while (1) {
    while_continue: /* CIL Label */ ;
#line 872
    if (! (altndx < altnum)) {
#line 872
      goto while_break;
    }
#line 882
    if (debug > 0) {
      {
#line 883
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 884
      dyio_outfmt(dbgchn, dbgecho, "[ alternative %d of %d ]\n", altndx + 1, altnum);
      }
    }
#line 888
    if ((unsigned long )comprefs == (unsigned long )((void *)0)) {
      {
#line 889
      errmsg(37, rtnnme, altndx + 1, altnum);
      }
#line 890
      goto while_break;
    } else {
#line 892
      tmp___6 = comprefs;
#line 892
      comprefs ++;
#line 892
      compnum = (int )((char *)*tmp___6 - (char *)0);
#line 893
      tmp___7 = comprefs;
#line 893
      comprefs ++;
#line 893
      compref.com = *tmp___7;
    }
#line 897
    compndx = 0;
#line 897
    success = (bool )1;
    {
#line 897
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 897
      if (compndx < compnum) {
#line 897
        if (! ((int )success == 1)) {
#line 897
          goto while_break___0;
        }
      } else {
#line 897
        goto while_break___0;
      }
#line 900
      if ((unsigned long )compref.com == (unsigned long )((void *)0)) {
        {
#line 901
        errmsg(32, rtnnme, compndx + 1, compnum);
#line 902
        success = (bool )0;
        }
#line 903
        goto while_break___0;
      }
      {
#line 905
      if ((unsigned int )(compref.com)->type == 0U) {
#line 905
        goto case_0;
      }
#line 911
      if ((unsigned int )(compref.com)->type == 1U) {
#line 911
        goto case_1;
      }
#line 917
      if ((unsigned int )(compref.com)->type == 2U) {
#line 917
        goto case_2;
      }
#line 926
      if ((unsigned int )(compref.com)->type == 3U) {
#line 926
        goto case_3;
      }
#line 932
      if ((unsigned int )(compref.com)->type == 8U) {
#line 932
        goto case_8;
      }
#line 935
      if ((unsigned int )(compref.com)->type == 9U) {
#line 935
        goto case_9;
      }
#line 942
      if ((unsigned int )(compref.com)->type == 5U) {
#line 942
        goto case_5;
      }
#line 942
      if ((unsigned int )(compref.com)->type == 4U) {
#line 942
        goto case_5;
      }
#line 946
      if ((unsigned int )(compref.com)->type == 7U) {
#line 946
        goto case_7;
      }
#line 946
      if ((unsigned int )(compref.com)->type == 6U) {
#line 946
        goto case_7;
      }
#line 949
      goto switch_default;
      case_0: /* CIL Label */ 
#line 906
      if ((compref.G)->uflgs & 1U) {
#line 906
        tmp___9 = 1;
      } else {
#line 906
        tmp___9 = 0;
      }
#line 906
      if (tmp___9 == 1) {
        {
#line 907
        success = dolist(compref);
        }
      } else {
        {
#line 909
        success = dogenerator(compref.G);
        }
      }
#line 910
      goto switch_break;
      case_1: /* CIL Label */ 
#line 912
      if ((compref.NP)->uflgs & 1U) {
#line 912
        tmp___10 = 1;
      } else {
#line 912
        tmp___10 = 0;
      }
#line 912
      if (tmp___10 == 1) {
        {
#line 913
        success = dolist(compref);
        }
      } else {
        {
#line 915
        success = dononprimitive(compref.NP);
        }
      }
#line 916
      goto switch_break;
      case_2: /* CIL Label */ 
#line 918
      curtxt = lcltxt;
#line 919
      if ((compref.P)->uflgs & 1U) {
#line 919
        tmp___11 = 1;
      } else {
#line 919
        tmp___11 = 0;
      }
#line 919
      if (tmp___11 == 1) {
        {
#line 920
        success = dolist(compref);
        }
      } else {
        {
#line 922
        success = doprimitive(compref.P);
        }
      }
#line 923
      lcltxt = curtxt;
#line 924
      curtxt = (char *)((void *)0);
#line 925
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 927
      curtxt = lcltxt;
#line 928
      success = doterminal(compref.T);
#line 929
      lcltxt = curtxt;
#line 930
      curtxt = (char *)((void *)0);
      }
#line 931
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 933
      success = doimmediate(compref.I);
      }
#line 934
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 936
      curtxt = lcltxt;
#line 937
      success = doliteral(compref.L);
#line 938
      lcltxt = curtxt;
#line 939
      curtxt = (char *)((void *)0);
      }
#line 940
      goto switch_break;
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 943
      success = dolabel(compref.LB);
      }
#line 944
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      {
#line 947
      success = doreference(compref.LB);
      }
#line 948
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 950
      errmsg(35, rtnnme, (unsigned int )(compref.com)->type);
#line 951
      success = (bool )0;
      }
#line 952
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 897
      compndx ++;
#line 897
      tmp___8 = comprefs;
#line 897
      comprefs ++;
#line 897
      compref.com = *tmp___8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 955
    if (debug > 0) {
      {
#line 956
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
      }
#line 957
      if ((int )success == 1) {
        {
#line 958
        dyio_outfmt(dbgchn, dbgecho, "[ pass %d ]", altndx + 1);
#line 959
        nestlvl --;
        }
#line 960
        if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 960
          tmp___12 = 1;
        } else {
#line 960
          tmp___12 = 0;
        }
#line 960
        if (tmp___12) {
#line 961
          debug --;
#line 961
          if (debug == 0) {
            {
#line 962
            dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
            }
          }
        }
      } else {
        {
#line 964
        dyio_outfmt(dbgchn, dbgecho, "[ fail %d @ %d of %d ]", altndx + 1, compndx,
                    compnum);
        }
      }
      {
#line 966
      dyio_outchr(dbgchn, dbgecho, (char )'\n');
      }
    }
#line 978
    if ((int )success == 1) {
#line 979
      if ((unsigned long )newtxt != (unsigned long )((void *)0)) {
        {
#line 979
        free((void *)newtxt);
        }
      }
#line 980
      newtxt = lcltxt;
#line 981
      curtxt = savctxt;
#line 982
      if (ref->uflgs & (unsigned int )(1 << 1)) {
#line 982
        tmp___20 = 1;
      } else {
#line 982
        tmp___20 = 0;
      }
#line 982
      if (tmp___20 == 1) {
#line 982
        if (ref->uflgs & 1U) {
#line 982
          tmp___21 = 0;
        } else {
#line 982
          tmp___21 = 1;
        }
#line 982
        if (tmp___21 == 1) {
#line 984
          if (ref->uflgs & (unsigned int )(1 << 7)) {
#line 984
            tmp___19 = 1;
          } else {
#line 984
            tmp___19 = 0;
          }
#line 984
          if (tmp___19 == 1) {
            {
#line 985
            strenter(ref->offset, (char const   *)newtxt);
            }
          } else {
#line 987
            if ((unsigned long )curnde == (unsigned long )((void *)0)) {
              {
#line 988
              errmsg(68, rtnnme);
#line 989
              newtxt = (char *)((void *)0);
              }
#line 990
              goto while_break;
            }
#line 991
            socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )ref->offset);
#line 992
            if (ref->uflgs & (unsigned int )(1 << 2)) {
#line 992
              tmp___18 = 1;
            } else {
#line 992
              tmp___18 = 0;
            }
#line 992
            if (tmp___18 == 1) {
#line 993
              if (ref->offset >= 0) {
#line 993
                if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(char *)) {
#line 993
                  tmp___13 = 1;
                } else {
#line 993
                  tmp___13 = 0;
                }
              } else {
#line 993
                tmp___13 = 0;
              }
#line 993
              if (tmp___13 == 0) {
                {
#line 994
                errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(char *));
#line 995
                newtxt = (char *)((void *)0);
                }
#line 996
                goto while_break;
              }
              {
#line 997
              *((char const   **)socket) = stralloc((char const   *)newtxt);
              }
            } else {
#line 999
              if (ref->offset >= 0) {
                {
#line 999
                tmp___17 = strlen((char const   *)newtxt);
                }
#line 999
                if ((size_t )ref->offset <= (size_t )cndesze - (tmp___17 + 1UL)) {
#line 999
                  tmp___16 = 1;
                } else {
#line 999
                  tmp___16 = 0;
                }
              } else {
#line 999
                tmp___16 = 0;
              }
#line 999
              if (tmp___16 == 0) {
                {
#line 1000
                tmp___14 = strlen((char const   *)newtxt);
#line 1000
                errmsg(30, rtnnme, ref->offset, (size_t )cndesze - (tmp___14 + 1UL));
#line 1001
                newtxt = (char *)((void *)0);
                }
#line 1002
                goto while_break;
              }
              {
#line 1003
              strcpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)newtxt);
              }
            }
          }
        }
      }
#line 1004
      if ((unsigned long )curtxt != (unsigned long )((void *)0)) {
        {
#line 1004
        tmp___25 = strlen((char const   *)newtxt);
        }
#line 1004
        if (tmp___25 > 0UL) {
          {
#line 1005
          tmp___22 = strlen((char const   *)curtxt);
#line 1005
          tmp___23 = strlen((char const   *)newtxt);
#line 1005
          tmp___24 = malloc((tmp___22 + tmp___23) + 1UL);
#line 1005
          savctxt = (char *)tmp___24;
#line 1006
          strcpy((char */* __restrict  */)savctxt, (char const   */* __restrict  */)curtxt);
#line 1007
          strcat((char */* __restrict  */)savctxt, (char const   */* __restrict  */)newtxt);
#line 1008
          free((void *)curtxt);
#line 1009
          curtxt = savctxt;
          }
        }
      }
#line 1010
      if ((unsigned long )curnde != (unsigned long )((void *)0)) {
        {
#line 1010
        free((void *)((char *)savcnde));
        }
      }
#line 1011
      return ((bool )1);
    } else {
#line 1013
      if ((unsigned long )curnde != (unsigned long )((void *)0)) {
        {
#line 1013
        memcpy((void */* __restrict  */)curnde, (void const   */* __restrict  */)savcnde,
               (size_t )cndesze);
        }
      }
      {
#line 1014
      *lcltxt = (char )'\000';
#line 1015
      dyio_backup(bnfchn, marker);
      }
    }
#line 872
    altndx ++;
#line 872
    tmp___5 = altrefs;
#line 872
    altrefs ++;
#line 872
    comprefs = *tmp___5;
  }
  while_break: /* CIL Label */ ;
  }
#line 1021
  if ((unsigned long )curnde != (unsigned long )((void *)0)) {
    {
#line 1022
    memcpy((void */* __restrict  */)curnde, (void const   */* __restrict  */)savcnde,
           (size_t )cndesze);
#line 1023
    free(savcnde);
    }
  }
  {
#line 1024
  free((void *)lcltxt);
#line 1025
  curtxt = savctxt;
  }
#line 1028
  if (debug > 0) {
#line 1029
    nestlvl --;
#line 1030
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1030
      tmp___26 = 1;
    } else {
#line 1030
      tmp___26 = 0;
    }
#line 1030
    if (tmp___26) {
#line 1031
      debug --;
#line 1031
      if (debug == 0) {
        {
#line 1032
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1035
  return ((bool )0);
}
}
#line 1039 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static int scanbinary(char const   *string , int *intp ) 
{ 
  char const   *ptr ;
  int val ;

  {
#line 1055
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 1055
    return (0);
  }
#line 1057
  val = 0;
#line 1058
  ptr = string;
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1058
    if (! ((int const   )*ptr != 0)) {
#line 1058
      goto while_break;
    }
#line 1059
    if ((int const   )*ptr != 48) {
#line 1059
      if ((int const   )*ptr != 49) {
#line 1060
        return (0);
      }
    }
#line 1061
    val = ((val << 1) + (int )*ptr) - 48;
#line 1058
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1063
  *intp = val;
#line 1064
  return (1);
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static lex_struct lex_nil  =    {(lexclass )0, (char *)((void *)0)};
#line 1096
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 1068 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool doterminal(bnfTref_struct *ref ) 
{ 
  bnfTdef_struct *def ;
  lex_struct *lex___1 ;
  void **socket ;
  char *lcltxt ;
  int cnt ;
  bool success ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  int tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  void *tmp___37 ;

  {
#line 1085
  lex___1 = (lex_struct *)((void *)0);
#line 1090
  rtnnme = "doterminal";
#line 1103
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 1104
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1105
    return ((bool )0);
  }
#line 1106
  def = (bnfTdef_struct *)ref->defn;
#line 1107
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 1108
    errmsg(33, rtnnme);
    }
#line 1109
    return ((bool )0);
  }
#line 1110
  if ((unsigned int )def->type != 3U) {
    {
#line 1111
    errmsg(41, rtnnme);
    }
#line 1112
    return ((bool )0);
  }
#line 1115
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1115
    tmp___0 = 1;
  } else {
#line 1115
    tmp___0 = 0;
  }
#line 1115
  if (tmp___0) {
#line 1116
    tmp = debug;
#line 1116
    debug ++;
#line 1116
    if (tmp == 0) {
      {
#line 1117
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
      }
    }
  }
#line 1118
  if (debug > 0) {
    {
#line 1119
    nestlvl ++;
#line 1120
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1121
    prtbnfref(dbgchn, dbgecho, (bnfref_struct *)ref);
#line 1122
    nestlvl --;
    }
  }
#line 1130
  success = (bool )1;
  {
#line 1132
  if ((unsigned int )def->ttype == 0U) {
#line 1132
    goto case_0;
  }
#line 1135
  if ((unsigned int )def->ttype == 1U) {
#line 1135
    goto case_1;
  }
#line 1139
  if ((unsigned int )def->ttype == 2U) {
#line 1139
    goto case_2;
  }
#line 1143
  if ((unsigned int )def->ttype == 3U) {
#line 1143
    goto case_3;
  }
#line 1147
  if ((unsigned int )def->ttype == 4U) {
#line 1147
    goto case_4;
  }
#line 1151
  if ((unsigned int )def->ttype == 5U) {
#line 1151
    goto case_5;
  }
#line 1155
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1133
  lex___1 = & lex_nil;
#line 1134
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1136
  lex___1 = dyio_scanlex(bnfchn);
  }
#line 1137
  if ((unsigned int )lex___1->class != 1U) {
#line 1137
    success = (bool )0;
  }
#line 1138
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1140
  lex___1 = dyio_scanlex(bnfchn);
  }
#line 1141
  if ((unsigned int )lex___1->class != 2U) {
#line 1141
    success = (bool )0;
  }
#line 1142
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1144
  lex___1 = dyio_scanlex(bnfchn);
  }
#line 1145
  if ((unsigned int )lex___1->class != 3U) {
#line 1145
    success = (bool )0;
  }
#line 1146
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1148
  lex___1 = dyio_scanstr(bnfchn, (lexclass )4, def->parm1, (char )'\000', (char )'\000');
  }
#line 1149
  if ((unsigned int )lex___1->class != 4U) {
#line 1149
    success = (bool )0;
  }
#line 1150
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1152
  lex___1 = dyio_scanstr(bnfchn, (lexclass )5, 0, def->qschr, def->qechr);
  }
#line 1153
  if ((unsigned int )lex___1->class != 5U) {
#line 1153
    if ((unsigned int )lex___1->class != 0U) {
#line 1153
      success = (bool )0;
    }
  }
#line 1154
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1156
  errmsg(42, rtnnme, (unsigned int )def->ttype);
#line 1157
  success = (bool )0;
  }
#line 1158
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1161
  if (debug > 0) {
#line 1162
    if ((unsigned long )lex___1->string != (unsigned long )((void *)0)) {
      {
#line 1163
      dyio_outfmt(dbgchn, dbgecho, " = \"%s\"\n", lex___1->string);
      }
    } else {
      {
#line 1165
      dyio_outfmt(dbgchn, dbgecho, " = nil\n");
      }
    }
#line 1166
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1166
      tmp___1 = 1;
    } else {
#line 1166
      tmp___1 = 0;
    }
#line 1166
    if (tmp___1) {
#line 1167
      debug --;
#line 1167
      if (debug == 0) {
        {
#line 1168
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1171
  if ((int )success == 0) {
#line 1171
    return ((bool )0);
  }
#line 1172
  if ((unsigned long )def->val != (unsigned long )((void *)0)) {
#line 1173
    if ((unsigned int )lex___1->class == 0U) {
#line 1173
      return ((bool )0);
    }
#line 1174
    if (ref->uflgs & (unsigned int )(1 << 5)) {
#line 1174
      tmp___8 = 1;
    } else {
#line 1174
      tmp___8 = 0;
    }
#line 1174
    if (tmp___8 == 1) {
#line 1175
      if (ref->uflgs & (unsigned int )(1 << 6)) {
#line 1175
        tmp___4 = 1;
      } else {
#line 1175
        tmp___4 = 0;
      }
#line 1175
      if (tmp___4 == 1) {
        {
#line 1176
        tmp___2 = mstrcmp((char const   *)lex___1->string, def->val);
        }
#line 1176
        if (tmp___2 != 0) {
#line 1176
          return ((bool )0);
        }
      } else {
        {
#line 1178
        tmp___3 = strcmp((char const   *)lex___1->string, def->val);
        }
#line 1178
        if (tmp___3 != 0) {
#line 1178
          return ((bool )0);
        }
      }
    } else {
#line 1180
      if (ref->uflgs & (unsigned int )(1 << 6)) {
#line 1180
        tmp___7 = 1;
      } else {
#line 1180
        tmp___7 = 0;
      }
#line 1180
      if (tmp___7 == 1) {
        {
#line 1181
        tmp___5 = cimstrcmp((char const   *)lex___1->string, def->val);
        }
#line 1181
        if (tmp___5 != 0) {
#line 1181
          return ((bool )0);
        }
      } else {
        {
#line 1183
        tmp___6 = cistrcmp((char const   *)lex___1->string, def->val);
        }
#line 1183
        if (tmp___6 != 0) {
#line 1183
          return ((bool )0);
        }
      }
    }
  }
#line 1191
  if (ref->uflgs & (unsigned int )(1 << 1)) {
#line 1191
    tmp___34 = 1;
  } else {
#line 1191
    tmp___34 = 0;
  }
#line 1191
  if (tmp___34 == 1) {
#line 1192
    socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )ref->offset);
#line 1193
    if (ref->uflgs & (unsigned int )(1 << 2)) {
#line 1193
      tmp___33 = 1;
    } else {
#line 1193
      tmp___33 = 0;
    }
#line 1193
    if (tmp___33 == 1) {
#line 1194
      if (ref->offset >= 0) {
#line 1194
        if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(char *)) {
#line 1194
          tmp___9 = 1;
        } else {
#line 1194
          tmp___9 = 0;
        }
      } else {
#line 1194
        tmp___9 = 0;
      }
#line 1194
      if (tmp___9 == 0) {
        {
#line 1195
        errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(char *));
        }
#line 1196
        return ((bool )0);
      }
#line 1197
      if ((unsigned int )lex___1->class != 0U) {
        {
#line 1198
        *((char const   **)socket) = stralloc((char const   *)lex___1->string);
        }
      }
    } else {
      {
#line 1201
      if ((unsigned int )def->ttype == 0U) {
#line 1201
        goto case_0___0;
      }
#line 1203
      if ((unsigned int )def->ttype == 1U) {
#line 1203
        goto case_1___0;
      }
#line 1245
      if ((unsigned int )def->ttype == 2U) {
#line 1245
        goto case_2___1;
      }
#line 1251
      if ((unsigned int )def->ttype == 3U) {
#line 1251
        goto case_3___0;
      }
#line 1257
      if ((unsigned int )def->ttype == 4U) {
#line 1257
        goto case_4___0;
      }
#line 1269
      if ((unsigned int )def->ttype == 5U) {
#line 1269
        goto case_5___0;
      }
#line 1200
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1202
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1204
      if (ref->uflgs & (unsigned int )(1 << 4)) {
#line 1204
        tmp___14 = 1;
      } else {
#line 1204
        tmp___14 = 0;
      }
#line 1204
      if (tmp___14 == 1) {
#line 1205
        if (ref->offset >= 0) {
#line 1205
          if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(float )) {
#line 1205
            tmp___10 = 1;
          } else {
#line 1205
            tmp___10 = 0;
          }
        } else {
#line 1205
          tmp___10 = 0;
        }
#line 1205
        if (tmp___10 == 0) {
          {
#line 1206
          errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(float ));
          }
#line 1207
          return ((bool )0);
        }
#line 1208
        if (def->parm1 != 10) {
          {
#line 1209
          errmsg(46, rtnnme, def->parm1, "float");
          }
#line 1210
          return ((bool )0);
        }
        {
#line 1211
        cnt = sscanf((char const   *)lex___1->string, "%f", (float *)socket);
        }
      } else {
#line 1213
        if (ref->uflgs & (unsigned int )(1 << 10)) {
#line 1213
          tmp___13 = 1;
        } else {
#line 1213
          tmp___13 = 0;
        }
#line 1213
        if (tmp___13 == 1) {
#line 1214
          if (ref->offset >= 0) {
#line 1214
            if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(double )) {
#line 1214
              tmp___11 = 1;
            } else {
#line 1214
              tmp___11 = 0;
            }
          } else {
#line 1214
            tmp___11 = 0;
          }
#line 1214
          if (tmp___11 == 0) {
            {
#line 1215
            errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(double ));
            }
#line 1216
            return ((bool )0);
          }
#line 1217
          if (def->parm1 != 10) {
            {
#line 1218
            errmsg(46, rtnnme, def->parm1, "double");
            }
#line 1219
            return ((bool )0);
          }
          {
#line 1220
          cnt = sscanf((char const   *)lex___1->string, "%lf", (double *)socket);
          }
        } else {
#line 1222
          if (ref->offset >= 0) {
#line 1222
            if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(int )) {
#line 1222
              tmp___12 = 1;
            } else {
#line 1222
              tmp___12 = 0;
            }
          } else {
#line 1222
            tmp___12 = 0;
          }
#line 1222
          if (tmp___12 == 0) {
            {
#line 1223
            errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(int ));
            }
#line 1224
            return ((bool )0);
          }
          {
#line 1226
          if (def->parm1 == 10) {
#line 1226
            goto case_10;
          }
#line 1229
          if (def->parm1 == 8) {
#line 1229
            goto case_8;
          }
#line 1235
          if (def->parm1 == 2) {
#line 1235
            goto case_2___0;
          }
#line 1238
          goto switch_default___0;
          case_10: /* CIL Label */ 
          {
#line 1227
          cnt = sscanf((char const   *)lex___1->string, "%d", (int *)socket);
          }
#line 1228
          goto switch_break___1;
          case_8: /* CIL Label */ 
#line 1230
          if ((int )*(lex___1->string) == 35) {
            {
#line 1231
            cnt = sscanf((char const   *)(lex___1->string + 1), "%o", (unsigned int *)socket);
            }
          } else {
            {
#line 1233
            cnt = sscanf((char const   *)lex___1->string, "%o", (unsigned int *)socket);
            }
          }
#line 1234
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
          {
#line 1236
          cnt = scanbinary((char const   *)lex___1->string, (int *)socket);
          }
#line 1237
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
          {
#line 1239
          errmsg(46, rtnnme, def->parm1, "int");
          }
#line 1240
          return ((bool )0);
          switch_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1241
      if (cnt != 1) {
        {
#line 1242
        errmsg(45, rtnnme, lex___1->string);
        }
#line 1243
        return ((bool )0);
      }
#line 1244
      goto switch_break___0;
      case_2___1: /* CIL Label */ 
#line 1246
      if (ref->offset >= 0) {
        {
#line 1246
        tmp___18 = strlen((char const   *)lex___1->string);
        }
#line 1246
        if ((size_t )ref->offset <= (size_t )cndesze - (tmp___18 + 1UL)) {
#line 1246
          tmp___17 = 1;
        } else {
#line 1246
          tmp___17 = 0;
        }
      } else {
#line 1246
        tmp___17 = 0;
      }
#line 1246
      if (tmp___17 == 0) {
        {
#line 1247
        tmp___15 = strlen((char const   *)lex___1->string);
#line 1247
        errmsg(30, rtnnme, ref->offset, (size_t )cndesze - (tmp___15 + 1UL));
        }
#line 1248
        return ((bool )0);
      }
      {
#line 1249
      strcpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)lex___1->string);
      }
#line 1250
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 1252
      if (ref->offset >= 0) {
#line 1252
        if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(char )) {
#line 1252
          tmp___19 = 1;
        } else {
#line 1252
          tmp___19 = 0;
        }
      } else {
#line 1252
        tmp___19 = 0;
      }
#line 1252
      if (tmp___19 == 0) {
        {
#line 1253
        errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(char ));
        }
#line 1254
        return ((bool )0);
      }
#line 1255
      *((char *)socket) = *(lex___1->string);
#line 1256
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
#line 1258
      if (ref->uflgs & (unsigned int )(1 << 8)) {
#line 1258
        tmp___28 = 1;
      } else {
#line 1258
        tmp___28 = 0;
      }
#line 1258
      if (tmp___28 == 1) {
#line 1259
        if (ref->offset >= 0) {
          {
#line 1259
          tmp___23 = strlen((char const   *)lex___1->string);
          }
#line 1259
          if ((size_t )ref->offset <= (size_t )cndesze - tmp___23) {
#line 1259
            tmp___22 = 1;
          } else {
#line 1259
            tmp___22 = 0;
          }
        } else {
#line 1259
          tmp___22 = 0;
        }
#line 1259
        if (tmp___22 == 0) {
          {
#line 1260
          tmp___20 = strlen((char const   *)lex___1->string);
#line 1260
          errmsg(30, rtnnme, ref->offset, (size_t )cndesze - tmp___20);
          }
#line 1261
          return ((bool )0);
        }
        {
#line 1262
        strncpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)lex___1->string,
                (size_t )def->parm1);
        }
      } else {
#line 1264
        if (ref->offset >= 0) {
          {
#line 1264
          tmp___27 = strlen((char const   *)lex___1->string);
          }
#line 1264
          if ((size_t )ref->offset <= (size_t )cndesze - (tmp___27 + 1UL)) {
#line 1264
            tmp___26 = 1;
          } else {
#line 1264
            tmp___26 = 0;
          }
        } else {
#line 1264
          tmp___26 = 0;
        }
#line 1264
        if (tmp___26 == 0) {
          {
#line 1265
          tmp___24 = strlen((char const   *)lex___1->string);
#line 1265
          errmsg(30, rtnnme, ref->offset, (size_t )cndesze - (tmp___24 + 1UL));
          }
#line 1266
          return ((bool )0);
        }
        {
#line 1267
        strcpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)lex___1->string);
        }
      }
#line 1268
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
#line 1270
      if (ref->offset >= 0) {
        {
#line 1270
        tmp___32 = strlen((char const   *)lex___1->string);
        }
#line 1270
        if ((size_t )ref->offset <= (size_t )cndesze - (tmp___32 + 1UL)) {
#line 1270
          tmp___31 = 1;
        } else {
#line 1270
          tmp___31 = 0;
        }
      } else {
#line 1270
        tmp___31 = 0;
      }
#line 1270
      if (tmp___31 == 0) {
        {
#line 1271
        tmp___29 = strlen((char const   *)lex___1->string);
#line 1271
        errmsg(30, rtnnme, ref->offset, (size_t )cndesze - (tmp___29 + 1UL));
        }
#line 1272
        return ((bool )0);
      }
#line 1273
      if ((unsigned int )lex___1->class != 0U) {
        {
#line 1273
        strcpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)lex___1->string);
        }
      }
#line 1274
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1279
  if ((unsigned long )curtxt != (unsigned long )((void *)0)) {
#line 1279
    if ((unsigned int )lex___1->class != 0U) {
      {
#line 1280
      tmp___35 = strlen((char const   *)curtxt);
#line 1280
      tmp___36 = strlen((char const   *)lex___1->string);
#line 1280
      tmp___37 = malloc((tmp___35 + tmp___36) + 1UL);
#line 1280
      lcltxt = (char *)tmp___37;
#line 1281
      strcpy((char */* __restrict  */)lcltxt, (char const   */* __restrict  */)curtxt);
#line 1282
      strcat((char */* __restrict  */)lcltxt, (char const   */* __restrict  */)lex___1->string);
#line 1283
      free((void *)curtxt);
#line 1284
      curtxt = lcltxt;
      }
    }
  }
#line 1286
  return ((bool )1);
}
}
#line 1290 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool doimmediate(bnfIref_struct *ref ) 
{ 
  void **socket ;
  bnfIdef_struct *def ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1305
  rtnnme = "doimmediate";
#line 1311
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 1312
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1313
    return ((bool )0);
  }
#line 1314
  def = (bnfIdef_struct *)ref->defn;
#line 1315
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 1316
    errmsg(33, rtnnme);
    }
#line 1317
    return ((bool )0);
  }
#line 1318
  if ((unsigned int )def->type != 8U) {
    {
#line 1319
    errmsg(47, rtnnme);
    }
#line 1320
    return ((bool )0);
  }
#line 1323
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1323
    tmp___0 = 1;
  } else {
#line 1323
    tmp___0 = 0;
  }
#line 1323
  if (tmp___0) {
#line 1324
    tmp = debug;
#line 1324
    debug ++;
#line 1324
    if (tmp == 0) {
      {
#line 1325
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
      }
    }
  }
#line 1326
  if (debug > 0) {
    {
#line 1327
    nestlvl ++;
#line 1328
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1329
    prtbnfref(dbgchn, dbgecho, (bnfref_struct *)ref);
#line 1330
    dyio_outfmt(dbgchn, dbgecho, "\n");
#line 1331
    nestlvl --;
    }
#line 1332
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1332
      tmp___1 = 1;
    } else {
#line 1332
      tmp___1 = 0;
    }
#line 1332
    if (tmp___1) {
#line 1333
      debug --;
#line 1333
      if (debug == 0) {
        {
#line 1334
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1337
  if (ref->offset >= 0) {
#line 1337
    if ((unsigned long )ref->offset <= (unsigned long )cndesze - sizeof(int )) {
#line 1337
      tmp___2 = 1;
    } else {
#line 1337
      tmp___2 = 0;
    }
  } else {
#line 1337
    tmp___2 = 0;
  }
#line 1337
  if (tmp___2 == 0) {
    {
#line 1338
    errmsg(30, rtnnme, ref->offset, (unsigned long )cndesze - sizeof(int ));
    }
#line 1339
    return ((bool )0);
  }
#line 1343
  socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )ref->offset);
#line 1344
  *((int *)socket) = def->ival;
#line 1346
  return ((bool )1);
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool doliteral(bnfLref_struct *ref ) 
{ 
  bnfLdef_struct *def ;
  char const   *txt ;
  char *txt2 ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 1366
  rtnnme = "doliteral";
#line 1373
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 1374
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1375
    return ((bool )0);
  }
#line 1376
  def = (bnfLdef_struct *)ref->defn;
#line 1377
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 1378
    errmsg(33, rtnnme);
    }
#line 1379
    return ((bool )0);
  }
#line 1380
  if ((unsigned int )def->type != 9U) {
    {
#line 1381
    errmsg(48, rtnnme);
    }
#line 1382
    return ((bool )0);
  }
#line 1385
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1385
    tmp___0 = 1;
  } else {
#line 1385
    tmp___0 = 0;
  }
#line 1385
  if (tmp___0) {
#line 1386
    tmp = debug;
#line 1386
    debug ++;
#line 1386
    if (tmp == 0) {
      {
#line 1387
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
      }
    }
  }
#line 1388
  if (debug > 0) {
    {
#line 1389
    nestlvl ++;
#line 1390
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1391
    prtbnfref(dbgchn, dbgecho, ref);
#line 1392
    nestlvl --;
    }
  }
#line 1395
  if (def->dflgs & (unsigned int )(1 << 2)) {
#line 1395
    tmp___1 = 1;
  } else {
#line 1395
    tmp___1 = 0;
  }
#line 1395
  if (tmp___1 == 1) {
    {
#line 1396
    txt = strretrv((int )(def->txt - (char *)0));
    }
  } else {
#line 1398
    txt = (char const   *)def->txt;
  }
#line 1401
  if (debug > 0) {
#line 1402
    if ((unsigned long )txt != (unsigned long )((void *)0)) {
      {
#line 1403
      dyio_outfmt(dbgchn, dbgecho, " = \"%s\"\n", txt);
      }
    } else {
      {
#line 1405
      dyio_outfmt(dbgchn, dbgecho, " = nil\n");
      }
    }
#line 1406
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1406
      tmp___2 = 1;
    } else {
#line 1406
      tmp___2 = 0;
    }
#line 1406
    if (tmp___2) {
#line 1407
      debug --;
#line 1407
      if (debug == 0) {
        {
#line 1408
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1411
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
    {
#line 1412
    errmsg(49, rtnnme);
    }
#line 1413
    return ((bool )0);
  }
#line 1414
  if ((unsigned long )curtxt == (unsigned long )((void *)0)) {
    {
#line 1415
    errmsg(50, rtnnme);
    }
#line 1416
    return ((bool )0);
  }
  {
#line 1420
  tmp___3 = strlen((char const   *)curtxt);
#line 1420
  tmp___4 = strlen(txt);
#line 1420
  tmp___5 = malloc((tmp___3 + tmp___4) + 1UL);
#line 1420
  txt2 = (char *)tmp___5;
#line 1421
  strcpy((char */* __restrict  */)txt2, (char const   */* __restrict  */)curtxt);
#line 1422
  strcat((char */* __restrict  */)txt2, (char const   */* __restrict  */)txt);
#line 1423
  free((void *)curtxt);
#line 1424
  curtxt = txt2;
  }
#line 1426
  return ((bool )1);
}
}
#line 1430 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool dolabel(bnfLBref_struct *ref ) 
{ 
  bnfLBdef_struct *def ;
  char const   *nmtxt ;
  char const   *ndtxt ;
  deflbl_struct *lblnde ;
  void *lblval ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1459
  rtnnme = "dolabel";
#line 1464
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 1465
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1466
    return ((bool )0);
  }
#line 1467
  def = (bnfLBdef_struct *)ref->defn;
#line 1468
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 1469
    errmsg(33, rtnnme);
    }
#line 1470
    return ((bool )0);
  }
#line 1471
  if ((unsigned int )def->type != 4U) {
#line 1471
    if ((unsigned int )def->type != 5U) {
      {
#line 1472
      errmsg(52, rtnnme);
      }
#line 1473
      return ((bool )0);
    }
  }
#line 1476
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1476
    tmp___0 = 1;
  } else {
#line 1476
    tmp___0 = 0;
  }
#line 1476
  if (tmp___0) {
#line 1477
    tmp = debug;
#line 1477
    debug ++;
#line 1477
    if (tmp == 0) {
      {
#line 1478
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
      }
    }
  }
#line 1479
  if (debug > 0) {
    {
#line 1480
    nestlvl ++;
#line 1481
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1482
    prtbnfref(dbgchn, dbgecho, ref);
#line 1483
    dyio_outchr(dbgchn, dbgecho, (char )'\n');
#line 1484
    nestlvl ++;
#line 1485
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1486
    dyio_outfmt(dbgchn, dbgecho, "[ name ]");
    }
  }
  {
#line 1493
  if ((unsigned int )def->nmcd == 0U) {
#line 1493
    goto case_0;
  }
#line 1503
  if ((unsigned int )def->nmcd == 1U) {
#line 1503
    goto case_1;
  }
#line 1506
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1494
  if ((unsigned long )def->nmsrc == (unsigned long )((void *)0)) {
    {
#line 1495
    errmsg(53, rtnnme, "name");
    }
#line 1496
    return ((bool )0);
  }
  {
#line 1497
  tmp___1 = doprimitive((bnfPref_struct *)def->nmsrc);
  }
#line 1497
  if ((int )tmp___1 == 0) {
    {
#line 1498
    errmsg(56, rtnnme, "name");
    }
#line 1499
    return ((bool )0);
  }
#line 1500
  nmtxt = (char const   *)newtxt;
#line 1501
  if (def->dflgs & (unsigned int )(1 << 2)) {
#line 1501
    tmp___2 = 1;
  } else {
#line 1501
    tmp___2 = 0;
  }
#line 1501
  if (tmp___2 == 1) {
    {
#line 1501
    strenter(def->savnm, nmtxt);
    }
  }
#line 1502
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1504
  nmtxt = strretrv((int )((char *)def->nmsrc - (char *)0));
  }
#line 1505
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1507
  errmsg(55, rtnnme, (unsigned int )def->nmcd, "name");
  }
#line 1508
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 1509
  if ((unsigned long )nmtxt == (unsigned long )((void *)0)) {
    {
#line 1510
    errmsg(57, rtnnme, "name");
    }
#line 1511
    return ((bool )0);
  }
  {
#line 1512
  nmtxt = stralloc(nmtxt);
  }
#line 1515
  if (debug > 0) {
    {
#line 1516
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1517
    dyio_outfmt(dbgchn, dbgecho, "[ \"%s\" ]\n", nmtxt);
#line 1518
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1519
    dyio_outfmt(dbgchn, dbgecho, "[ value ]\n");
#line 1520
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
    }
  }
  {
#line 1527
  if ((unsigned int )def->ndcd == 0U) {
#line 1527
    goto case_0___0;
  }
#line 1548
  if ((unsigned int )def->ndcd == 2U) {
#line 1548
    goto case_2;
  }
#line 1551
  if ((unsigned int )def->ndcd == 3U) {
#line 1551
    goto case_3;
  }
#line 1554
  if ((unsigned int )def->ndcd == 1U) {
#line 1554
    goto case_1___0;
  }
#line 1566
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 1528
  if ((unsigned long )def->ndsrc == (unsigned long )((void *)0)) {
    {
#line 1529
    errmsg(53, rtnnme, "value");
#line 1530
    strfree(nmtxt);
    }
#line 1531
    return ((bool )0);
  }
  {
#line 1532
  tmp___3 = doprimitive((bnfPref_struct *)def->ndsrc);
  }
#line 1532
  if ((int )tmp___3 == 0) {
    {
#line 1533
    errmsg(56, rtnnme, "value");
#line 1534
    strfree(nmtxt);
    }
#line 1535
    return ((bool )0);
  }
  {
#line 1536
  ndtxt = (char const   *)newtxt;
#line 1537
  lblnde = finddlbl(& blbllst, ndtxt);
  }
#line 1538
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1539
    if ((unsigned long )ndtxt == (unsigned long )((void *)0)) {
      {
#line 1540
      errmsg(57, rtnnme, "value");
      }
    } else {
      {
#line 1542
      errmsg(54, rtnnme, ndtxt);
      }
    }
    {
#line 1543
    strfree(nmtxt);
    }
#line 1544
    return ((bool )0);
  }
#line 1545
  if (def->dflgs & (unsigned int )(1 << 1)) {
#line 1545
    tmp___4 = 1;
  } else {
#line 1545
    tmp___4 = 0;
  }
#line 1545
  if (tmp___4 == 1) {
    {
#line 1545
    strenter(def->savnd, ndtxt);
    }
  }
#line 1546
  lblval = lblnde->lblval;
#line 1547
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 1549
  lblval = curnde;
#line 1550
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 1552
  lblval = newnde;
#line 1553
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1555
  ndtxt = strretrv((int )((char *)def->ndsrc - (char *)0));
#line 1556
  lblnde = finddlbl(& blbllst, ndtxt);
  }
#line 1557
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1558
    if ((unsigned long )ndtxt == (unsigned long )((void *)0)) {
      {
#line 1559
      errmsg(57, rtnnme, "value");
      }
    } else {
      {
#line 1561
      errmsg(54, rtnnme, ndtxt);
      }
    }
    {
#line 1562
    strfree(nmtxt);
    }
#line 1563
    return ((bool )0);
  }
#line 1564
  lblval = lblnde->lblval;
#line 1565
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1567
  errmsg(55, rtnnme, (unsigned int )def->nmcd, "value");
#line 1568
  strfree(nmtxt);
  }
#line 1569
  return ((bool )0);
  switch_break___0: /* CIL Label */ ;
  }
#line 1574
  lblval = (void *)((ptrdiff_t )lblval + (ptrdiff_t )def->offset);
#line 1577
  if ((unsigned long )lblval == (unsigned long )((void *)0)) {
#line 1577
    if ((int )warnzlbl == 1) {
      {
#line 1578
      warn(58, rtnnme, nmtxt);
      }
    }
  }
#line 1579
  if (debug > 0) {
    {
#line 1580
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1581
    dyio_outfmt(dbgchn, dbgecho, "[ value: %#1x ]\n", nmtxt);
#line 1582
    nestlvl -= 2;
    }
#line 1583
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1583
      tmp___5 = 1;
    } else {
#line 1583
      tmp___5 = 0;
    }
#line 1583
    if (tmp___5) {
#line 1584
      debug --;
#line 1584
      if (debug == 0) {
        {
#line 1585
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1591
  if ((unsigned int )def->type == 4U) {
    {
#line 1592
    lblnde = finddlbl(& flbllst, nmtxt);
    }
  } else {
    {
#line 1594
    lblnde = finddlbl(& blbllst, nmtxt);
    }
  }
#line 1600
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
    {
#line 1601
    tmp___6 = malloc(sizeof(deflbl_struct ));
#line 1601
    lblnde = (deflbl_struct *)tmp___6;
    }
#line 1602
    if ((unsigned int )def->type == 4U) {
#line 1603
      lblnde->lblnxt = flbllst;
#line 1604
      flbllst = lblnde;
    } else {
#line 1606
      lblnde->lblnxt = blbllst;
#line 1607
      blbllst = lblnde;
    }
#line 1608
    if (def->dflgs & 1U) {
#line 1608
      lblnde->lbladv = (bool )1;
    } else {
#line 1608
      lblnde->lbladv = (bool )0;
    }
#line 1609
    lblnde->lblnmtxt = nmtxt;
#line 1610
    lblnde->lblval = lblval;
  } else {
#line 1612
    if (def->dflgs & 1U) {
#line 1612
      tmp___7 = 1;
    } else {
#line 1612
      tmp___7 = 0;
    }
#line 1612
    if (tmp___7 == 1) {
#line 1612
      goto _L;
    } else
#line 1612
    if ((int )lblnde->lbladv == 0) {
      _L: /* CIL Label */ 
#line 1613
      lblnde->lblval = lblval;
#line 1614
      if (def->dflgs & 1U) {
#line 1614
        lblnde->lbladv = (bool )1;
      } else {
#line 1614
        lblnde->lbladv = (bool )0;
      }
    }
  }
#line 1619
  if (def->dflgs & 1U) {
#line 1619
    tmp___8 = 0;
  } else {
#line 1619
    tmp___8 = 1;
  }
#line 1619
  if (tmp___8 == 1) {
#line 1620
    if ((unsigned int )def->type == 4U) {
      {
#line 1621
      lblresolve(& uflbllst, lblnde);
      }
    } else {
      {
#line 1623
      lblresolve(& ublbllst, lblnde);
      }
    }
  }
#line 1625
  return ((bool )1);
}
}
#line 1629 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool doreference(bnfLBref_struct *ref ) 
{ 
  bnfLBdef_struct *def ;
  char const   *nmtxt ;
  char const   *ndtxt ;
  deflbl_struct *lblnde ;
  udeflbl_struct *ulblnde ;
  void *val ;
  void **socket ;
  bool socket_valid ;
  bool val_valid ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 1650
  nmtxt = (char const   *)((void *)0);
#line 1651
  ndtxt = (char const   *)((void *)0);
#line 1656
  rtnnme = "doreference";
#line 1661
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 1662
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1663
    return ((bool )0);
  }
#line 1664
  def = (bnfLBdef_struct *)ref->defn;
#line 1665
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 1666
    errmsg(33, rtnnme);
    }
#line 1667
    return ((bool )0);
  }
#line 1668
  if ((unsigned int )def->type != 6U) {
#line 1668
    if ((unsigned int )def->type != 7U) {
      {
#line 1669
      errmsg(52, rtnnme);
      }
#line 1670
      return ((bool )0);
    }
  }
#line 1673
  if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1673
    tmp___0 = 1;
  } else {
#line 1673
    tmp___0 = 0;
  }
#line 1673
  if (tmp___0) {
#line 1674
    tmp = debug;
#line 1674
    debug ++;
#line 1674
    if (tmp == 0) {
      {
#line 1675
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
      }
    }
  }
#line 1676
  if (debug > 0) {
    {
#line 1677
    nestlvl ++;
#line 1678
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1679
    prtbnfref(dbgchn, dbgecho, ref);
#line 1680
    dyio_outchr(dbgchn, dbgecho, (char )'\n');
#line 1681
    nestlvl ++;
#line 1682
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1683
    dyio_outfmt(dbgchn, dbgecho, "[ socket ]");
    }
  }
#line 1689
  socket_valid = (bool )1;
  {
#line 1691
  if ((unsigned int )def->nmcd == 0U) {
#line 1691
    goto case_0;
  }
#line 1710
  if ((unsigned int )def->nmcd == 2U) {
#line 1710
    goto case_2;
  }
#line 1713
  if ((unsigned int )def->nmcd == 3U) {
#line 1713
    goto case_3;
  }
#line 1716
  if ((unsigned int )def->nmcd == 1U) {
#line 1716
    goto case_1;
  }
#line 1728
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1692
  if ((unsigned long )def->nmsrc == (unsigned long )((void *)0)) {
    {
#line 1693
    errmsg(59, rtnnme, "socket");
    }
#line 1694
    return ((bool )0);
  }
  {
#line 1695
  tmp___1 = doprimitive((bnfPref_struct *)def->nmsrc);
  }
#line 1695
  if ((int )tmp___1 == 0) {
    {
#line 1696
    errmsg(60, rtnnme, "socket");
    }
#line 1697
    return ((bool )0);
  }
#line 1698
  nmtxt = (char const   *)newtxt;
#line 1699
  if ((unsigned long )nmtxt == (unsigned long )((void *)0)) {
    {
#line 1700
    errmsg(61, rtnnme, "socket");
    }
#line 1701
    return ((bool )0);
  }
  {
#line 1702
  lblnde = finddlbl(& flbllst, nmtxt);
  }
#line 1703
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1704
    socket = (void **)((void *)0);
#line 1705
    socket_valid = (bool )0;
  } else {
#line 1707
    socket = (void **)((ptrdiff_t )lblnde->lblval);
  }
#line 1708
  if (def->dflgs & (unsigned int )(1 << 2)) {
#line 1708
    tmp___2 = 1;
  } else {
#line 1708
    tmp___2 = 0;
  }
#line 1708
  if (tmp___2 == 1) {
    {
#line 1708
    strenter(def->savnm, nmtxt);
    }
  }
#line 1709
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1711
  socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )def->offset);
#line 1712
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1714
  socket = (void **)((ptrdiff_t )newnde + (ptrdiff_t )def->offset);
#line 1715
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1717
  nmtxt = strretrv((int )((char *)def->nmsrc - (char *)0));
  }
#line 1718
  if ((unsigned long )nmtxt == (unsigned long )((void *)0)) {
    {
#line 1719
    errmsg(61, rtnnme, "socket");
    }
#line 1720
    return ((bool )0);
  }
  {
#line 1721
  lblnde = finddlbl(& flbllst, nmtxt);
  }
#line 1722
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1723
    socket = (void **)((void *)0);
#line 1724
    socket_valid = (bool )0;
  } else {
#line 1726
    socket = (void **)((ptrdiff_t )lblnde->lblval);
  }
#line 1727
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1729
  errmsg(64, rtnnme, (unsigned int )def->nmcd, "socket");
  }
#line 1730
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 1731
  if ((int )socket_valid == 1) {
#line 1731
    if ((unsigned long )socket == (unsigned long )((void *)0)) {
      {
#line 1732
      errmsg(62, rtnnme);
      }
#line 1733
      return ((bool )0);
    }
  }
#line 1736
  if (debug > 0) {
    {
#line 1737
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1738
    dyio_outfmt(dbgchn, dbgecho, "[ \"%s\" = %#1x ]\n", nmtxt);
#line 1739
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1740
    dyio_outfmt(dbgchn, dbgecho, "[ label ]\n");
#line 1741
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
    }
  }
#line 1748
  val_valid = (bool )1;
  {
#line 1750
  if ((unsigned int )def->ndcd == 0U) {
#line 1750
    goto case_0___0;
  }
#line 1769
  if ((unsigned int )def->ndcd == 2U) {
#line 1769
    goto case_2___0;
  }
#line 1772
  if ((unsigned int )def->ndcd == 3U) {
#line 1772
    goto case_3___0;
  }
#line 1775
  if ((unsigned int )def->ndcd == 1U) {
#line 1775
    goto case_1___0;
  }
#line 1787
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 1751
  if ((unsigned long )def->ndsrc == (unsigned long )((void *)0)) {
    {
#line 1752
    errmsg(59, rtnnme, "value");
    }
#line 1753
    return ((bool )0);
  }
  {
#line 1754
  tmp___3 = doprimitive((bnfPref_struct *)def->ndsrc);
  }
#line 1754
  if ((int )tmp___3 == 0) {
    {
#line 1755
    errmsg(60, rtnnme, "value");
    }
#line 1756
    return ((bool )0);
  }
#line 1757
  ndtxt = (char const   *)newtxt;
#line 1758
  if ((unsigned long )ndtxt == (unsigned long )((void *)0)) {
    {
#line 1759
    errmsg(61, rtnnme, "value");
    }
#line 1760
    return ((bool )0);
  }
  {
#line 1761
  lblnde = finddlbl(& blbllst, ndtxt);
  }
#line 1762
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1763
    val = (void *)0;
#line 1764
    val_valid = (bool )0;
  } else {
#line 1766
    val = (void *)((ptrdiff_t )lblnde->lblval);
  }
#line 1767
  if (def->dflgs & (unsigned int )(1 << 1)) {
#line 1767
    tmp___4 = 1;
  } else {
#line 1767
    tmp___4 = 0;
  }
#line 1767
  if (tmp___4 == 1) {
    {
#line 1767
    strenter(def->savnd, ndtxt);
    }
  }
#line 1768
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 1770
  val = (void *)((ptrdiff_t )curnde + (ptrdiff_t )def->offset2);
#line 1771
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 1773
  val = (void *)((ptrdiff_t )newnde + (ptrdiff_t )def->offset2);
#line 1774
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 1776
  ndtxt = strretrv((int )((char *)def->ndsrc - (char *)0));
  }
#line 1777
  if ((unsigned long )ndtxt == (unsigned long )((void *)0)) {
    {
#line 1778
    errmsg(61, rtnnme, "value");
    }
#line 1779
    return ((bool )0);
  }
  {
#line 1780
  lblnde = finddlbl(& blbllst, ndtxt);
  }
#line 1781
  if ((unsigned long )lblnde == (unsigned long )((void *)0)) {
#line 1782
    val = (void *)0;
#line 1783
    val_valid = (bool )0;
  } else {
#line 1785
    val = (void *)((ptrdiff_t )lblnde->lblval);
  }
#line 1786
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1788
  errmsg(64, rtnnme, (unsigned int )def->ndcd, "value");
  }
#line 1789
  return ((bool )0);
  switch_break___0: /* CIL Label */ ;
  }
#line 1792
  if ((int )warnzlbl == 1) {
#line 1792
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1792
      if ((int )val_valid == 1) {
        {
#line 1793
        warn(65, rtnnme);
        }
      }
    }
  }
#line 1794
  if (debug > 0) {
    {
#line 1795
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1796
    dyio_outfmt(dbgchn, dbgecho, "[ \"%s\" = %#1x ]\n", nmtxt);
#line 1797
    nestlvl -= 2;
    }
#line 1798
    if (ref->uflgs & (unsigned int )(1 << 9)) {
#line 1798
      tmp___5 = 1;
    } else {
#line 1798
      tmp___5 = 0;
    }
#line 1798
    if (tmp___5) {
#line 1799
      debug --;
#line 1799
      if (debug == 0) {
        {
#line 1800
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 1807
  if ((unsigned int )def->type == 6U) {
#line 1808
    if ((int )val_valid == 0) {
      {
#line 1809
      errmsg(63, rtnnme);
      }
#line 1810
      return ((bool )0);
    }
#line 1811
    if ((int )socket_valid == 1) {
#line 1812
      *socket = val;
    } else {
      {
#line 1814
      tmp___6 = malloc(sizeof(udeflbl_struct ));
#line 1814
      ulblnde = (udeflbl_struct *)tmp___6;
#line 1815
      ulblnde->lblnxt = uflbllst;
#line 1816
      uflbllst = ulblnde;
#line 1817
      ulblnde->lblnmtxt = stralloc(nmtxt);
#line 1818
      ulblnde->lblval = val;
      }
    }
  } else {
#line 1820
    if ((int )socket_valid == 0) {
      {
#line 1821
      errmsg(66, rtnnme);
      }
#line 1822
      return ((bool )0);
    }
#line 1823
    if ((int )val_valid == 1) {
#line 1824
      *socket = val;
    } else {
      {
#line 1826
      tmp___7 = malloc(sizeof(udeflbl_struct ));
#line 1826
      ulblnde = (udeflbl_struct *)tmp___7;
#line 1827
      ulblnde->lblnxt = ublbllst;
#line 1828
      ublbllst = ulblnde;
#line 1829
      ulblnde->lblnmtxt = stralloc(ndtxt);
#line 1830
      ulblnde->lblval = (void *)socket;
      }
    }
  }
#line 1832
  return ((bool )1);
}
}
#line 1836 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
static bool dolist(bnfref_any ref ) 
{ 
  bnfref_struct *sepref ;
  bnfdef_any def ;
  void **socket ;
  bool firsttime ;
  bool success ;
  bool sepsuccess ;
  void *savcnde ;
  void *firstnde ;
  char *savctxt ;
  char *lclsavtxt ;
  long marker ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;

  {
#line 1857
  savcnde = (void *)0;
#line 1858
  firstnde = (void *)0;
#line 1859
  savctxt = (char *)((void *)0);
#line 1860
  lclsavtxt = (char *)((void *)0);
#line 1862
  rtnnme = "dolist";
#line 1869
  if ((unsigned long )ref.t3 == (unsigned long )((void *)0)) {
    {
#line 1870
    errmsg(2, rtnnme, "bnf ref");
    }
#line 1871
    return ((bool )0);
  }
#line 1872
  sepref = (ref.t3)->sep;
#line 1873
  if ((unsigned int )sepref->type != 2U) {
#line 1873
    if ((unsigned int )sepref->type != 3U) {
      {
#line 1874
      errmsg(67, rtnnme);
      }
#line 1875
      return ((bool )0);
    }
  }
#line 1878
  if ((ref.t3)->uflgs & (unsigned int )(1 << 9)) {
#line 1878
    tmp___0 = 1;
  } else {
#line 1878
    tmp___0 = 0;
  }
#line 1878
  if (tmp___0) {
#line 1879
    tmp = debug;
#line 1879
    debug ++;
#line 1879
    if (tmp == 0) {
      {
#line 1880
      dyio_outfmt(dbgchn, dbgecho, "\n\n>>>>>> trace begins >>>>>>\n");
#line 1881
      nestlvl = 0;
      }
    }
  }
#line 1882
  if (debug > 0) {
    {
#line 1883
    nestlvl ++;
#line 1884
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1885
    dyio_outfmt(dbgchn, dbgecho, "[ begin list ]\n");
    }
  }
#line 1898
  def.com = (ref.t3)->defn;
  {
#line 1900
  if ((unsigned int )(def.com)->type == 0U) {
#line 1900
    goto case_0;
  }
#line 1914
  if ((unsigned int )(def.com)->type == 2U) {
#line 1914
    goto case_2;
  }
#line 1927
  if ((unsigned int )(def.com)->type == 1U) {
#line 1927
    goto case_1;
  }
#line 1929
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1901
  if ((ref.G)->uflgs & (unsigned int )(1 << 1)) {
#line 1901
    tmp___2 = 1;
  } else {
#line 1901
    tmp___2 = 0;
  }
#line 1901
  if (tmp___2 == 1) {
#line 1902
    if ((unsigned long )curnde == (unsigned long )((void *)0)) {
      {
#line 1903
      errmsg(68, rtnnme);
      }
#line 1904
      return ((bool )0);
    }
#line 1905
    if ((ref.G)->offset >= 0) {
#line 1905
      if ((unsigned long )(ref.G)->offset <= (unsigned long )cndesze - sizeof(void *)) {
#line 1905
        tmp___1 = 1;
      } else {
#line 1905
        tmp___1 = 0;
      }
    } else {
#line 1905
      tmp___1 = 0;
    }
#line 1905
    if (tmp___1 == 0) {
      {
#line 1906
      errmsg(30, rtnnme, (ref.G)->offset, (unsigned long )cndesze - sizeof(void *));
      }
#line 1907
      return ((bool )0);
    }
  }
#line 1908
  if ((def.G)->link < 0) {
    {
#line 1910
    errmsg(69, rtnnme, (def.G)->link, (unsigned long )(def.G)->size - sizeof(void *));
    }
#line 1911
    return ((bool )0);
  } else
#line 1908
  if ((unsigned long )(def.G)->link > (unsigned long )(def.G)->size - sizeof(void *)) {
    {
#line 1910
    errmsg(69, rtnnme, (def.G)->link, (unsigned long )(def.G)->size - sizeof(void *));
    }
#line 1911
    return ((bool )0);
  }
#line 1912
  savcnde = curnde;
#line 1913
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1915
  if ((ref.P)->uflgs & (unsigned int )(1 << 1)) {
#line 1915
    tmp___5 = 1;
  } else {
#line 1915
    tmp___5 = 0;
  }
#line 1915
  if (tmp___5 == 1) {
#line 1916
    if ((unsigned long )curnde == (unsigned long )((void *)0)) {
      {
#line 1917
      errmsg(68, rtnnme);
      }
#line 1918
      return ((bool )0);
    }
#line 1919
    if ((ref.P)->uflgs & (unsigned int )(1 << 2)) {
#line 1919
      tmp___4 = 1;
    } else {
#line 1919
      tmp___4 = 0;
    }
#line 1919
    if (tmp___4 == 1) {
#line 1920
      if ((ref.P)->offset >= 0) {
#line 1920
        if ((unsigned long )(ref.P)->offset <= (unsigned long )cndesze - sizeof(char *)) {
#line 1920
          tmp___3 = 1;
        } else {
#line 1920
          tmp___3 = 0;
        }
      } else {
#line 1920
        tmp___3 = 0;
      }
#line 1920
      if (tmp___3 == 0) {
        {
#line 1921
        errmsg(30, rtnnme, (ref.P)->offset, (unsigned long )cndesze - sizeof(char *));
        }
#line 1922
        return ((bool )0);
      }
    }
  }
  {
#line 1923
  savctxt = curtxt;
#line 1924
  tmp___6 = malloc(sizeof(char ));
#line 1924
  curtxt = (char *)tmp___6;
#line 1925
  *curtxt = (char )'\000';
  }
#line 1926
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1928
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1930
  errmsg(70, rtnnme, (unsigned int )(def.com)->type);
  }
#line 1931
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 1940
  firsttime = (bool )1;
  {
#line 1941
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1945
    if (debug > 0) {
      {
#line 1946
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1947
      dyio_outfmt(dbgchn, dbgecho, "[ body ]\n");
      }
    }
    {
#line 1951
    if ((unsigned int )(def.com)->type == 0U) {
#line 1951
      goto case_0___0;
    }
#line 1954
    if ((unsigned int )(def.com)->type == 1U) {
#line 1954
      goto case_1___0;
    }
#line 1957
    if ((unsigned int )(def.com)->type == 2U) {
#line 1957
      goto case_2___0;
    }
#line 1960
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 1952
    success = dogenerator(ref.G);
    }
#line 1953
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 1955
    success = dononprimitive(ref.NP);
    }
#line 1956
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 1958
    success = doprimitive(ref.P);
    }
#line 1959
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1961
    errmsg(1, rtnnme, 1961);
    }
#line 1962
    return ((bool )0);
    switch_break___0: /* CIL Label */ ;
    }
#line 1963
    if ((int )success == 0) {
#line 1963
      goto while_break;
    }
#line 1965
    if ((unsigned int )(def.com)->type == 0U) {
#line 1966
      if ((int )firsttime == 1) {
#line 1967
        firstnde = newnde;
#line 1968
        firsttime = (bool )0;
      } else {
#line 1970
        socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )(def.G)->link);
#line 1971
        *socket = newnde;
      }
#line 1972
      curnde = newnde;
    }
    {
#line 1974
    marker = dyio_mark(bnfchn);
    }
#line 1975
    if ((ref.t3)->uflgs & (unsigned int )(1 << 3)) {
#line 1975
      tmp___7 = 1;
    } else {
#line 1975
      tmp___7 = 0;
    }
#line 1975
    if (tmp___7 == 1) {
#line 1975
      if ((unsigned int )(def.com)->type == 2U) {
#line 1976
        lclsavtxt = curtxt;
#line 1977
        curtxt = (char *)((void *)0);
      }
    }
#line 1980
    if (debug > 0) {
      {
#line 1981
      printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 1982
      dyio_outfmt(dbgchn, dbgecho, "[ separator ]\n");
      }
    }
#line 1985
    if ((unsigned int )sepref->type == 2U) {
      {
#line 1986
      sepsuccess = doprimitive((bnfPref_struct *)sepref);
      }
    } else {
      {
#line 1988
      sepsuccess = doterminal((bnfTref_struct *)sepref);
      }
    }
#line 1989
    if ((int )sepsuccess == 0) {
#line 1990
      if ((unsigned int )sepref->type == 3U) {
        {
#line 1990
        dyio_backup(bnfchn, marker);
        }
      }
#line 1991
      if ((ref.t3)->uflgs & (unsigned int )(1 << 3)) {
#line 1991
        tmp___8 = 1;
      } else {
#line 1991
        tmp___8 = 0;
      }
#line 1991
      if (tmp___8 == 1) {
#line 1991
        if ((unsigned int )(def.com)->type == 2U) {
#line 1992
          curtxt = lclsavtxt;
        }
      }
#line 1993
      goto while_break;
    }
#line 1995
    if ((ref.t3)->uflgs & (unsigned int )(1 << 3)) {
#line 1995
      tmp___9 = 1;
    } else {
#line 1995
      tmp___9 = 0;
    }
#line 1995
    if (tmp___9 == 1) {
      {
#line 1996
      dyio_backup(bnfchn, marker);
      }
#line 1997
      if ((unsigned int )(def.com)->type == 2U) {
#line 1997
        curtxt = lclsavtxt;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2005
  if ((unsigned int )(def.com)->type == 0U) {
#line 2005
    goto case_0___1;
  }
#line 2015
  if ((unsigned int )(def.com)->type == 2U) {
#line 2015
    goto case_2___1;
  }
#line 2044
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 2006
  if ((int )success == 1) {
#line 2007
    newnde = firstnde;
#line 2008
    curnde = savcnde;
#line 2009
    if ((ref.G)->uflgs & (unsigned int )(1 << 1)) {
#line 2009
      tmp___10 = 1;
    } else {
#line 2009
      tmp___10 = 0;
    }
#line 2009
    if (tmp___10 == 1) {
#line 2010
      socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )(ref.G)->offset);
#line 2011
      *socket = firstnde;
    }
  } else {
#line 2013
    curnde = savcnde;
  }
#line 2014
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 2016
  if ((int )success == 1) {
#line 2017
    if ((unsigned long )newtxt != (unsigned long )((void *)0)) {
      {
#line 2017
      free((void *)newtxt);
      }
    }
#line 2018
    newtxt = curtxt;
#line 2019
    curtxt = savctxt;
#line 2020
    if ((ref.P)->uflgs & (unsigned int )(1 << 1)) {
#line 2020
      tmp___17 = 1;
    } else {
#line 2020
      tmp___17 = 0;
    }
#line 2020
    if (tmp___17 == 1) {
#line 2021
      if ((ref.P)->uflgs & (unsigned int )(1 << 7)) {
#line 2021
        tmp___16 = 1;
      } else {
#line 2021
        tmp___16 = 0;
      }
#line 2021
      if (tmp___16 == 1) {
        {
#line 2022
        strenter((ref.P)->offset, (char const   *)newtxt);
        }
      } else {
#line 2024
        socket = (void **)((ptrdiff_t )curnde + (ptrdiff_t )(ref.P)->offset);
#line 2025
        if ((ref.P)->uflgs & (unsigned int )(1 << 2)) {
#line 2025
          tmp___15 = 1;
        } else {
#line 2025
          tmp___15 = 0;
        }
#line 2025
        if (tmp___15 == 1) {
          {
#line 2026
          *((char const   **)socket) = stralloc((char const   *)newtxt);
          }
        } else {
#line 2028
          if ((ref.P)->offset >= 0) {
            {
#line 2028
            tmp___14 = strlen((char const   *)newtxt);
            }
#line 2028
            if ((size_t )(ref.P)->offset <= (size_t )cndesze - (tmp___14 + 1UL)) {
#line 2028
              tmp___13 = 1;
            } else {
#line 2028
              tmp___13 = 0;
            }
          } else {
#line 2028
            tmp___13 = 0;
          }
#line 2028
          if (tmp___13 == 0) {
            {
#line 2029
            tmp___11 = strlen((char const   *)newtxt);
#line 2029
            errmsg(30, rtnnme, (ref.P)->offset, (size_t )cndesze - (tmp___11 + 1UL));
#line 2030
            free((void *)newtxt);
#line 2031
            newtxt = (char *)((void *)0);
            }
#line 2032
            return ((bool )0);
          }
          {
#line 2033
          strcpy((char */* __restrict  */)((char *)socket), (char const   */* __restrict  */)newtxt);
          }
        }
      }
    }
#line 2034
    if ((unsigned long )curtxt != (unsigned long )((void *)0)) {
      {
#line 2035
      tmp___18 = strlen((char const   *)curtxt);
#line 2035
      tmp___19 = strlen((char const   *)newtxt);
#line 2035
      tmp___20 = malloc((tmp___18 + tmp___19) + 1UL);
#line 2035
      lclsavtxt = (char *)tmp___20;
#line 2036
      strcpy((char */* __restrict  */)lclsavtxt, (char const   */* __restrict  */)curtxt);
#line 2037
      strcat((char */* __restrict  */)lclsavtxt, (char const   */* __restrict  */)newtxt);
#line 2038
      free((void *)curtxt);
#line 2039
      curtxt = lclsavtxt;
      }
    }
  } else {
    {
#line 2041
    free((void *)curtxt);
#line 2042
    curtxt = savctxt;
    }
  }
#line 2043
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 2045
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 2048
  if (debug > 0) {
    {
#line 2049
    printtab(dbgchn, dbgecho, nestlvl, numlvl, tablvl);
#line 2050
    dyio_outfmt(dbgchn, dbgecho, "[ end list ]\n");
#line 2051
    nestlvl --;
    }
#line 2052
    if ((ref.t3)->uflgs & (unsigned int )(1 << 9)) {
#line 2052
      tmp___21 = 1;
    } else {
#line 2052
      tmp___21 = 0;
    }
#line 2052
    if (tmp___21) {
#line 2053
      debug --;
#line 2053
      if (debug == 0) {
        {
#line 2054
        dyio_outfmt(dbgchn, dbgecho, "<<<<<< trace ends <<<<<<\n\n");
        }
      }
    }
  }
#line 2057
  return (success);
}
}
#line 2061 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
bool parse(ioid chn , struct bnfref_type3 *bnfid , parse_any *result ) 
{ 
  bool success ;
  bnfref_any ref ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2081
  rtnnme = "parse";
#line 2087
  if ((unsigned long )bnfid == (unsigned long )((void *)0)) {
    {
#line 2088
    errmsg(2, rtnnme, "bnf");
    }
#line 2089
    return ((bool )0);
  }
#line 2090
  ref.t3 = bnfid;
#line 2091
  if ((unsigned int )(ref.com)->type != 0U) {
#line 2091
    if ((unsigned int )(ref.com)->type != 1U) {
#line 2091
      if ((unsigned int )(ref.com)->type != 2U) {
        {
#line 2094
        errmsg(43, rtnnme);
        }
#line 2095
        return ((bool )0);
      }
    }
  }
#line 2096
  if ((unsigned int )(ref.com)->type != 1U) {
#line 2097
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 2098
      errmsg(2, rtnnme, "result");
      }
#line 2099
      return ((bool )0);
    }
  }
#line 2104
  bnfchn = chn;
  {
#line 2106
  if ((unsigned int )(ref.com)->type == 0U) {
#line 2106
    goto case_0;
  }
#line 2113
  if ((unsigned int )(ref.com)->type == 1U) {
#line 2113
    goto case_1;
  }
#line 2119
  if ((unsigned int )(ref.com)->type == 2U) {
#line 2119
    goto case_2;
  }
#line 2126
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2107
  if ((ref.G)->uflgs & 1U) {
#line 2107
    tmp = 1;
  } else {
#line 2107
    tmp = 0;
  }
#line 2107
  if (tmp == 1) {
    {
#line 2108
    success = dolist(ref);
    }
  } else {
    {
#line 2110
    success = dogenerator(ref.G);
    }
  }
#line 2111
  if ((int )success == 1) {
#line 2111
    result->g = newnde;
  }
#line 2112
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2114
  if ((ref.NP)->uflgs & 1U) {
#line 2114
    tmp___0 = 1;
  } else {
#line 2114
    tmp___0 = 0;
  }
#line 2114
  if (tmp___0 == 1) {
    {
#line 2115
    success = dolist(ref);
    }
  } else {
    {
#line 2117
    success = dononprimitive(ref.NP);
    }
  }
#line 2118
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2120
  if ((ref.P)->uflgs & 1U) {
#line 2120
    tmp___1 = 1;
  } else {
#line 2120
    tmp___1 = 0;
  }
#line 2120
  if (tmp___1 == 1) {
    {
#line 2121
    success = dolist(ref);
    }
  } else {
    {
#line 2123
    success = doprimitive(ref.P);
    }
  }
#line 2124
  if ((int )success == 1) {
#line 2124
    result->c = newtxt;
  }
#line 2125
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2127
  errmsg(1, rtnnme, 2127);
#line 2128
  success = (bool )0;
  }
#line 2129
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2131
  return (success);
}
}
#line 2136 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.c"
void bnfdbgctl(ioid dbgchn_p , bool dbgecho_p , bool warnzlbl_p , bool numlvl_p ,
               bool tablvl_p ) 
{ 


  {
#line 2155
  dbgchn = dbgchn_p;
#line 2156
  dbgecho = dbgecho_p;
#line 2157
  warnzlbl = warnzlbl_p;
#line 2158
  numlvl = numlvl_p;
#line 2159
  tablvl = tablvl_p;
#line 2159
  return;
}
}
#line 1744 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
dyret_enum dy_hotstart(lpprob_struct *orig_lp ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_hotstart.c"
void dy_setfinalstatus(void) 
{ 
  int aindx ;
  int xkndx ;
  double xk ;
  double lbk ;
  double ubk ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___14 ;
  int tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  double tmp___24 ;

  {
#line 90
  if (dy_opts->print.crash >= 2) {
    {
#line 91
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\testablishing final status ...");
    }
  }
#line 94
  dy_lp->infeas = 0.0;
#line 95
  dy_lp->infeascnt = 0;
#line 105
  aindx = 1;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (aindx <= dy_sys->concnt)) {
#line 105
      goto while_break;
    }
#line 106
    xkndx = *(dy_basis + aindx);
#line 107
    xk = *(dy_xbasic + aindx);
#line 108
    lbk = *(dy_sys->vlb + xkndx);
#line 109
    ubk = *(dy_sys->vub + xkndx);
    {
#line 116
    if (*(dy_status + xkndx) == (flags )(1 << 2)) {
#line 116
      goto case_exp;
    }
#line 133
    if (*(dy_status + xkndx) == 1U) {
#line 133
      goto case_1;
    }
#line 115
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 117
    tmp___10 = fabs(lbk);
    }
#line 117
    if (tmp___10 < dy_tols->inf) {
      {
#line 117
      tmp___11 = fabs(xk - lbk);
#line 117
      tmp___12 = fabs(lbk);
      }
#line 117
      if (tmp___11 < dy_tols->pfeas * (1.0 + tmp___12)) {
#line 118
        *(dy_status + xkndx) = (flags )(1 << 3);
      } else {
#line 117
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 120
      tmp___9 = fabs(lbk);
      }
#line 120
      if (tmp___9 < dy_tols->inf) {
        {
#line 120
        tmp___7 = fabs(lbk);
#line 120
        tmp___8 = lbk - xk > dy_tols->pfeas * (1.0 + tmp___7);
        }
      } else {
#line 120
        tmp___8 = xk < lbk;
      }
#line 120
      if (tmp___8) {
#line 121
        (dy_lp->infeascnt) ++;
#line 122
        dy_lp->infeas += lbk - xk;
#line 123
        *(dy_status + xkndx) = (flags )(1 << 11);
      } else {
        {
#line 125
        tmp___3 = fabs(ubk);
        }
#line 125
        if (tmp___3 < dy_tols->inf) {
          {
#line 125
          tmp___4 = fabs(xk - ubk);
#line 125
          tmp___5 = fabs(ubk);
          }
#line 125
          if (tmp___4 < dy_tols->pfeas * (1.0 + tmp___5)) {
#line 126
            *(dy_status + xkndx) = (flags )(1 << 1);
          } else {
#line 125
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 128
          tmp___2 = fabs(ubk);
          }
#line 128
          if (tmp___2 < dy_tols->inf) {
            {
#line 128
            tmp___0 = fabs(ubk);
#line 128
            tmp___1 = xk - ubk > dy_tols->pfeas * (1.0 + tmp___0);
            }
          } else {
#line 128
            tmp___1 = xk > ubk;
          }
#line 128
          if (tmp___1) {
#line 129
            (dy_lp->infeascnt) ++;
#line 130
            dy_lp->infeas += xk - ubk;
#line 131
            *(dy_status + xkndx) = (flags )(1 << 10);
          }
        }
      }
    }
#line 132
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 134
    tmp___17 = fabs(lbk);
    }
#line 134
    if (tmp___17 < dy_tols->inf) {
      {
#line 134
      tmp___18 = fabs(xk - lbk);
#line 134
      tmp___19 = fabs(lbk);
      }
#line 134
      if (! (tmp___18 < dy_tols->pfeas * (1.0 + tmp___19))) {
#line 134
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 135
      tmp___16 = fabs(lbk);
      }
#line 135
      if (tmp___16 < dy_tols->inf) {
        {
#line 135
        tmp___14 = fabs(lbk);
#line 135
        tmp___15 = lbk - xk > dy_tols->pfeas * (1.0 + tmp___14);
        }
      } else {
#line 135
        tmp___15 = xk < lbk;
      }
#line 135
      if (tmp___15) {
#line 136
        (dy_lp->infeascnt) ++;
#line 137
        dy_lp->infeas += lbk - xk;
#line 138
        *(dy_status + xkndx) = (flags )(1 << 11);
      } else {
#line 140
        (dy_lp->infeascnt) ++;
#line 141
        dy_lp->infeas += xk - ubk;
#line 142
        *(dy_status + xkndx) = (flags )(1 << 10);
      }
    }
#line 143
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 145
    if (dy_opts->print.crash >= 4) {
      {
#line 146
      tmp___20 = dy_prtvstat(*(dy_status + xkndx));
#line 146
      tmp___21 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 146
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s", tmp___21, xkndx, tmp___20);
      }
#line 149
      if (lbk > - dy_tols->inf) {
        {
#line 150
        dyio_outfmt(dy_logchn, dy_gtxecho, ", lb = %g", lbk);
        }
      }
      {
#line 151
      dyio_outfmt(dy_logchn, dy_gtxecho, ", val = %g", xk);
      }
#line 152
      if (ubk < dy_tols->inf) {
        {
#line 153
        dyio_outfmt(dy_logchn, dy_gtxecho, ", ub = %g", ubk);
        }
      }
#line 154
      if (*(dy_status + xkndx) & (unsigned int )((1 << 11) | (1 << 10))) {
#line 154
        tmp___23 = 1;
      } else {
#line 154
        tmp___23 = 0;
      }
#line 154
      if (tmp___23) {
        {
#line 155
        dyio_outfmt(dy_logchn, dy_gtxecho, ", infeasibility = ");
        }
#line 156
        if (*(dy_status + xkndx) & (unsigned int )(1 << 11)) {
#line 156
          tmp___22 = 1;
        } else {
#line 156
          tmp___22 = 0;
        }
#line 156
        if (tmp___22) {
          {
#line 157
          dyio_outfmt(dy_logchn, dy_gtxecho, "%g", lbk - xk);
          }
        } else {
          {
#line 159
          dyio_outfmt(dy_logchn, dy_gtxecho, "%g", xk - ubk);
          }
        }
      }
      {
#line 160
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
#line 105
    aindx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 163
  tmp___24 = fabs(dy_lp->infeas);
  }
#line 163
  if (tmp___24 < dy_tols->zero) {
#line 163
    dy_lp->infeas = (double )0;
  }
#line 165
  return;
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_hotstart.c"
static void hot_updateMiscState(lpret_enum lpret ) 
{ 


  {
#line 180
  dy_lp->lpret = lpret;
#line 181
  dy_lp->tot.iters = 0;
#line 182
  dy_lp->tot.pivs = 0;
#line 183
  dy_lp->prev_pivok = dy_lp->pivok;
#line 184
  dy_lp->pivok = (bool )0;
#line 185
  dy_lp->degenpivcnt = 0;
#line 186
  dy_lp->idlecnt = 0;
#line 188
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_hotstart.c"
static bool process_inactive(lpprob_struct *orig_lp , int oxkndx ) 
{ 
  int oaindx ;
  int aindx ;
  int ndx ;
  double xk ;
  double lk ;
  double uk ;
  double ck ;
  pkvec_struct *ak ;
  pkcoeff_struct *aik ;
  consys_struct *orig_sys ;
  flags xkstatus ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 215
  rtnnme = "process_inactive";
#line 217
  orig_sys = orig_lp->consys;
#line 219
  xkstatus = *(orig_lp->status + oxkndx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 243
  lk = *(orig_sys->vlb + oxkndx);
#line 244
  uk = *(orig_sys->vub + oxkndx);
#line 245
  ck = *(orig_sys->obj + oxkndx);
#line 251
  if (lk > - dy_tols->inf) {
#line 251
    if (uk < dy_tols->inf) {
      {
#line 252
      tmp___3 = fabs(uk);
      }
#line 252
      if (tmp___3 < dy_tols->inf) {
        {
#line 252
        tmp___4 = fabs(lk - uk);
#line 252
        tmp___5 = fabs(uk);
        }
#line 252
        if (tmp___4 < dy_tols->pfeas * (1.0 + tmp___5)) {
#line 252
          if (lk != uk) {
#line 253
            if (xkstatus & (unsigned int )((1 << 7) | (1 << 6))) {
#line 253
              tmp = 1;
            } else {
#line 253
              tmp = 0;
            }
#line 253
            if (tmp) {
#line 254
              xkstatus |= 1U << (sizeof(flags ) * 8UL - 4UL);
            } else
#line 256
            if (ck < (double )0) {
#line 257
              xkstatus = (unsigned int )(1 << 6) | (1U << (sizeof(flags ) * 8UL - 4UL));
            } else {
#line 259
              xkstatus = (unsigned int )(1 << 7) | (1U << (sizeof(flags ) * 8UL - 4UL));
            }
#line 261
            if (dy_opts->print.setup >= 3) {
              {
#line 262
              tmp___0 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )0, (char *)0);
#line 262
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tDirty fixed variable %s (%d)",
                          tmp___0, oxkndx);
#line 264
              tmp___1 = dy_prtvstat(xkstatus);
#line 264
              dyio_outfmt(dy_logchn, dy_gtxecho, " assigned status %s.", tmp___1);
#line 266
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  original lb = %g, ub = %g, diff = %g, tol = %g",
                          lk, uk, uk - lk, dy_tols->pfeas);
              }
            }
          } else {
#line 252
            goto _L___0;
          }
        } else {
#line 252
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 272
      if (lk == uk) {
#line 273
        xkstatus = (unsigned int )(1 << 5) | (1U << (sizeof(flags ) * 8UL - 4UL));
      } else {
#line 275
        if (xkstatus & (unsigned int )((1 << 7) | (1 << 6))) {
#line 275
          tmp___2 = 1;
        } else {
#line 275
          tmp___2 = 0;
        }
#line 275
        if (tmp___2) {
#line 276
          xkstatus = *(orig_lp->status + oxkndx);
        } else
#line 278
        if (ck < (double )0) {
#line 279
          xkstatus = (flags )(1 << 6);
        } else {
#line 281
          xkstatus = (flags )(1 << 7);
        }
      }
    } else {
#line 251
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 286
  if (lk > - dy_tols->inf) {
#line 287
    xkstatus = (flags )(1 << 7);
  } else
#line 289
  if (uk < dy_tols->inf) {
#line 290
    xkstatus = (flags )(1 << 6);
  } else {
#line 292
    xkstatus = (flags )(1 << 8);
  }
  {
#line 303
  if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 5)) {
#line 303
    goto case_exp;
  }
#line 303
  if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 7)) {
#line 303
    goto case_exp;
  }
#line 306
  if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 6)) {
#line 306
    goto case_exp___1;
  }
#line 309
  if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 8)) {
#line 309
    goto case_exp___2;
  }
#line 312
  goto switch_default;
  case_exp: /* CIL Label */ 
  case_exp___0: /* CIL Label */ 
#line 304
  xk = lk;
#line 305
  goto switch_break;
  case_exp___1: /* CIL Label */ 
#line 307
  xk = uk;
#line 308
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 310
  xk = (double )0;
#line 311
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 313
  xk = (double )0;
#line 314
  errmsg(1, rtnnme, 314);
  }
#line 315
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 316
  *(orig_lp->status + oxkndx) = xkstatus;
#line 317
  *(dy_origvars + oxkndx) = - ((int )xkstatus);
#line 321
  dy_lp->inactzcorr += xk * *(orig_sys->obj + oxkndx);
#line 322
  if (orig_lp->ctlopts & (unsigned int )(((1 << 4) | (1 << 3)) | (1 << 2))) {
#line 322
    tmp___8 = 1;
  } else {
#line 322
    tmp___8 = 0;
  }
#line 322
  if (tmp___8) {
    {
#line 323
    ak = (pkvec_struct *)((void *)0);
#line 324
    tmp___7 = consys_getcol_pk(orig_sys, oxkndx, & ak);
    }
#line 324
    if ((int )tmp___7 == 0) {
      {
#line 325
      tmp___6 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 325
      errmsg(122, rtnnme, orig_sys->nme, "variable", tmp___6, oxkndx);
      }
#line 327
      if ((unsigned long )ak != (unsigned long )((void *)0)) {
        {
#line 327
        pkvec_free(ak);
        }
      }
#line 328
      return ((bool )0);
    }
#line 329
    ndx = 0;
#line 329
    aik = ak->coeffs + 0;
    {
#line 329
    while (1) {
      while_continue: /* CIL Label */ ;
#line 329
      if (! (ndx < ak->cnt)) {
#line 329
        goto while_break;
      }
#line 330
      oaindx = aik->ndx;
#line 331
      if (*(dy_origcons + oaindx) > 0) {
#line 332
        aindx = *(dy_origcons + oaindx);
#line 333
        *(dy_sys->rhs + aindx) -= aik->val * xk;
#line 334
        if ((unsigned int )*(dy_sys->ctyp + aindx) == 5U) {
#line 335
          *(dy_sys->rhslow + aindx) -= aik->val * xk;
        }
      }
#line 329
      ndx ++;
#line 329
      aik ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 336
    pkvec_free(ak);
    }
  }
#line 342
  if (dy_opts->print.crash >= 4) {
    {
#line 343
    tmp___9 = dy_prtvstat(xkstatus);
#line 343
    tmp___10 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )0, (char *)((void *)0));
#line 343
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s inactive with value ", tmp___10,
                oxkndx, tmp___9);
    }
    {
#line 350
    if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 8)) {
#line 350
      goto case_exp___3;
    }
#line 350
    if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 6)) {
#line 350
      goto case_exp___3;
    }
#line 350
    if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 7)) {
#line 350
      goto case_exp___3;
    }
#line 350
    if ((xkstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 5)) {
#line 350
      goto case_exp___3;
    }
#line 353
    goto switch_default___0;
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
    {
#line 351
    dyio_outfmt(dy_logchn, dy_gtxecho, "%g.", xk);
    }
#line 352
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 354
    dyio_outfmt(dy_logchn, dy_gtxecho, "??.");
    }
#line 355
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 358
  return ((bool )1);
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_hotstart.c"
static void process_active(lpprob_struct *orig_lp , int oxkndx ) 
{ 
  int xkndx ;
  double lk ;
  double uk ;
  double xk ;
  flags xkstatus ;
  consys_struct *orig_sys ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
#line 391
  orig_sys = orig_lp->consys;
#line 397
  xkndx = *(dy_origvars + oxkndx);
#line 398
  xkstatus = *(dy_status + xkndx);
#line 417
  lk = *(orig_sys->vlb + oxkndx);
#line 418
  *(dy_sys->vlb + xkndx) = lk;
#line 419
  uk = *(orig_sys->vub + oxkndx);
#line 420
  *(dy_sys->vub + xkndx) = uk;
#line 421
  *(dy_sys->obj + xkndx) = *(orig_sys->obj + oxkndx);
#line 434
  if (*(dy_status + xkndx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 434
    tmp = 1;
  } else {
#line 434
    tmp = 0;
  }
#line 434
  if (tmp) {
#line 435
    if (lk > - dy_tols->inf) {
#line 435
      if (uk < dy_tols->inf) {
#line 436
        if (lk == uk) {
#line 437
          xkstatus = (flags )(1 << 5);
#line 438
          xk = lk;
        } else
#line 440
        if (*(dy_x + xkndx) - lk < uk - *(dy_x + xkndx)) {
#line 441
          xkstatus = (flags )(1 << 7);
#line 442
          xk = lk;
        } else {
#line 444
          xkstatus = (flags )(1 << 6);
#line 445
          xk = uk;
        }
      } else {
#line 435
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 447
    if (lk > - dy_tols->inf) {
#line 448
      xkstatus = (flags )(1 << 7);
#line 449
      xk = lk;
    } else
#line 451
    if (uk < dy_tols->inf) {
#line 452
      xkstatus = (flags )(1 << 6);
#line 453
      xk = uk;
    } else {
#line 455
      xkstatus = (flags )(1 << 8);
#line 456
      xk = (double )0;
    }
#line 457
    *(dy_x + xkndx) = xk;
  } else
#line 459
  if (lk == uk) {
#line 460
    xkstatus = (flags )1;
  } else
#line 462
  if (lk <= - dy_tols->inf) {
#line 462
    if (uk >= dy_tols->inf) {
#line 463
      xkstatus = (flags )(1 << 4);
    } else {
#line 465
      xkstatus = (flags )(1 << 2);
    }
  } else {
#line 465
    xkstatus = (flags )(1 << 2);
  }
#line 466
  *(dy_status + xkndx) = xkstatus;
#line 471
  if (dy_opts->print.crash >= 4) {
    {
#line 472
    tmp___0 = dy_prtvstat(*(dy_status + xkndx));
#line 472
    tmp___1 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 472
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s active", tmp___1, xkndx,
                tmp___0);
    }
#line 475
    if (xkstatus & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 475
      tmp___2 = 1;
    } else {
#line 475
      tmp___2 = 0;
    }
#line 475
    if (tmp___2) {
      {
#line 476
      dyio_outfmt(dy_logchn, dy_gtxecho, " with value %g.", *(dy_x + xkndx));
      }
    } else {
      {
#line 478
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
  }
#line 481
  return;
}
}
#line 532
void dy_refreshlclsystem(flags what ) ;
#line 535
dyphase_enum dy_forceFull(consys_struct *orig_sys ) ;
#line 486 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_hotstart.c"
dyret_enum dy_hotstart(lpprob_struct *orig_lp ) 
{ 
  int oxkndx ;
  int xkndx ;
  int oaindx ;
  int aindx ;
  double *ogvlb ;
  double *dyvlb ;
  double *ogvub ;
  double *dyvub ;
  double *ogobj ;
  double *dyobj ;
  double *dyrhs ;
  double *ogrhs ;
  double lbj ;
  double ubj ;
  consys_struct *orig_sys ;
  flags *ogstatus ;
  flags calcflgs ;
  flags statk ;
  dyret_enum retval ;
  lpret_enum lpret ;
  dyphase_enum phase ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  int tmp___7 ;
  bool tmp___8 ;
  char const   *tmp___9 ;
  bool tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 529
  rtnnme = "dy_hotstart";
#line 541
  if (orig_lp->ctlopts & (unsigned int )((((1 << 3) | (1 << 2)) | (1 << 5)) | (1 << 4))) {
#line 541
    tmp = 0;
  } else {
#line 541
    tmp = 1;
  }
#line 541
  if (tmp) {
#line 545
    if (dy_opts->print.crash >= 1) {
      {
#line 546
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  no data structure changes at hot start.");
      }
    }
    {
#line 549
    hot_updateMiscState((lpret_enum )0);
    }
#line 550
    return ((dyret_enum )1);
  }
#line 555
  if (dy_opts->print.crash >= 1) {
    {
#line 556
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  updating data structures at hot start ...");
    }
#line 558
    if (dy_opts->print.crash >= 2) {
      {
#line 559
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    scanning changes to");
      }
#line 560
      if (orig_lp->ctlopts & (unsigned int )(1 << 4)) {
#line 560
        tmp___0 = 1;
      } else {
#line 560
        tmp___0 = 0;
      }
#line 560
      if (tmp___0) {
        {
#line 561
        dyio_outfmt(dy_logchn, dy_gtxecho, " rhs");
        }
      }
#line 562
      if (orig_lp->ctlopts & (unsigned int )(1 << 3)) {
#line 562
        tmp___1 = 1;
      } else {
#line 562
        tmp___1 = 0;
      }
#line 562
      if (tmp___1) {
        {
#line 563
        dyio_outfmt(dy_logchn, dy_gtxecho, " vlb");
        }
      }
#line 564
      if (orig_lp->ctlopts & (unsigned int )(1 << 2)) {
#line 564
        tmp___2 = 1;
      } else {
#line 564
        tmp___2 = 0;
      }
#line 564
      if (tmp___2) {
        {
#line 565
        dyio_outfmt(dy_logchn, dy_gtxecho, " vub");
        }
      }
#line 566
      if (orig_lp->ctlopts & (unsigned int )(1 << 5)) {
#line 566
        tmp___3 = 1;
      } else {
#line 566
        tmp___3 = 0;
      }
#line 566
      if (tmp___3) {
        {
#line 567
        dyio_outfmt(dy_logchn, dy_gtxecho, " obj");
        }
      }
      {
#line 568
      dyio_outfmt(dy_logchn, dy_gtxecho, " ...");
      }
    }
  }
  {
#line 575
  dy_refreshlclsystem(orig_lp->ctlopts);
#line 577
  orig_sys = orig_lp->consys;
#line 578
  dyrhs = dy_sys->rhs;
#line 579
  ogrhs = orig_sys->rhs;
#line 580
  ogvlb = orig_sys->vlb;
#line 581
  dyvlb = dy_sys->vlb;
#line 582
  ogvub = orig_sys->vub;
#line 583
  dyvub = dy_sys->vub;
#line 584
  ogobj = orig_sys->obj;
#line 585
  dyobj = dy_sys->obj;
#line 586
  ogstatus = orig_lp->status;
  }
#line 593
  if (orig_lp->ctlopts & (unsigned int )(((1 << 3) | (1 << 2)) | (1 << 4))) {
#line 593
    tmp___4 = 1;
  } else {
#line 593
    tmp___4 = 0;
  }
#line 593
  if (tmp___4) {
#line 595
    aindx = 1;
    {
#line 595
    while (1) {
      while_continue: /* CIL Label */ ;
#line 595
      if (! (aindx <= dy_sys->concnt)) {
#line 595
        goto while_break;
      }
#line 596
      oaindx = *(dy_actcons + aindx);
#line 597
      if (oaindx > 0) {
#line 598
        *(dyrhs + aindx) = *(ogrhs + oaindx);
#line 599
        if ((unsigned int )*(dy_sys->ctyp + aindx) == 5U) {
#line 600
          *(dy_sys->rhslow + aindx) = *(orig_sys->rhslow + oaindx);
#line 601
          *(dyvub + aindx) = *(dyrhs + aindx) - *(dy_sys->rhslow + aindx);
        }
      }
#line 595
      aindx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 613
  dy_lp->inactzcorr = (double )0;
#line 614
  lpret = (lpret_enum )0;
#line 615
  dy_lp->sys.vars.loadable = 0;
#line 616
  dy_lp->sys.vars.unloadable = 0;
#line 617
  oxkndx = 1;
  {
#line 617
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 617
    if (! (oxkndx <= orig_sys->varcnt)) {
#line 617
      goto while_break___0;
    }
#line 618
    xkndx = *(dy_origvars + oxkndx);
#line 619
    lbj = *(ogvlb + oxkndx);
#line 620
    ubj = *(ogvub + oxkndx);
#line 621
    if (*(ogvlb + oxkndx) > *(ogvub + oxkndx)) {
#line 622
      lpret = (lpret_enum )4;
#line 624
      if (dy_opts->print.setup >= 1) {
        {
#line 625
        tmp___5 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )0, (char *)0);
#line 625
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tTrivial infeasibility for %s (%d), lb = %g > ub = %g.",
                    tmp___5, oxkndx, *(ogvlb + oxkndx), *(ogvub + oxkndx));
        }
      }
    }
#line 640
    if (xkndx < 0) {
      {
#line 641
      tmp___6 = process_inactive(orig_lp, oxkndx);
      }
#line 641
      if ((int )tmp___6 == 0) {
#line 641
        return ((dyret_enum )-10);
      }
#line 642
      statk = (flags )(- *(dy_origvars + oxkndx));
#line 643
      if (statk & (1U << (sizeof(flags ) * 8UL - 4UL))) {
#line 643
        tmp___7 = 1;
      } else {
#line 643
        tmp___7 = 0;
      }
#line 643
      if (tmp___7) {
#line 644
        (dy_lp->sys.vars.unloadable) ++;
      } else {
#line 646
        (dy_lp->sys.vars.loadable) ++;
      }
    } else {
      {
#line 648
      process_active(orig_lp, oxkndx);
      }
    }
#line 617
    oxkndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 656
  tmp___8 = dy_calcprimals();
  }
#line 656
  if ((int )tmp___8 == 0) {
    {
#line 657
    errmsg(316, rtnnme, dy_sys->nme);
    }
#line 658
    return ((dyret_enum )-10);
  }
#line 659
  xkndx = 1;
  {
#line 659
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 659
    if (! (xkndx <= dy_sys->concnt)) {
#line 659
      goto while_break___1;
    }
#line 660
    if (*(dy_var2basis + xkndx) != 0) {
#line 661
      if (*(dyvub + xkndx) == *(dyvlb + xkndx)) {
#line 662
        *(dy_status + xkndx) = (flags )1;
      } else {
#line 664
        *(dy_status + xkndx) = (flags )(1 << 2);
      }
    }
#line 659
    xkndx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 665
  dy_setfinalstatus();
  }
#line 672
  if ((int )dy_lp->p1obj.installed == 1) {
    {
#line 673
    tmp___10 = dy_swapobjs((dyphase_enum )3);
    }
#line 673
    if ((int )tmp___10 == 0) {
      {
#line 674
      tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 674
      errmsg(318, rtnnme, dy_sys->nme, tmp___9, dy_lp->tot.iters, "remove");
      }
#line 676
      return ((dyret_enum )-10);
    }
  }
  {
#line 681
  dy_calcduals();
#line 682
  tmp___12 = dy_calccbar();
  }
#line 682
  if ((int )tmp___12 == 0) {
    {
#line 683
    tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 683
    errmsg(384, rtnnme, dy_sys->nme, tmp___11, dy_lp->tot.iters);
    }
#line 685
    return ((dyret_enum )-10);
  }
  {
#line 686
  dy_lp->z = dy_calcobj();
#line 688
  calcflgs = (flags )(((1 | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 689
  retval = dy_accchk(& calcflgs);
  }
#line 690
  if ((int )retval != 1) {
    {
#line 691
    tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 691
    errmsg(304, rtnnme, dy_sys->nme, tmp___13, dy_lp->tot.iters);
    }
#line 693
    return (retval);
  }
#line 694
  if (calcflgs & 1U) {
#line 694
    tmp___15 = 0;
  } else {
#line 694
    tmp___15 = 1;
  }
#line 694
  if (tmp___15) {
#line 695
    dy_lp->simplex.next = (dyphase_enum )3;
  } else {
#line 697
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 697
      tmp___14 = 0;
    } else {
#line 697
      tmp___14 = 1;
    }
#line 697
    if (tmp___14) {
#line 698
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 700
      dy_lp->simplex.next = (dyphase_enum )2;
    }
  }
  {
#line 704
  hot_updateMiscState(lpret);
  }
#line 727
  if ((int )dy_opts->fullsys == 1) {
#line 727
    if (dy_lp->sys.cons.loadable > 0) {
#line 727
      goto _L;
    } else
#line 727
    if (dy_lp->sys.vars.loadable > 0) {
      _L: /* CIL Label */ 
#line 731
      if (dy_opts->print.force >= 1) {
        {
#line 732
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  Forcing full system.");
        }
      }
      {
#line 734
      dy_lp->lpret = (lpret_enum )11;
#line 735
      dy_lp->phase = (dyphase_enum )13;
#line 736
      phase = dy_forceFull(orig_sys);
      }
#line 737
      if ((unsigned int )phase == 0U) {
#line 738
        retval = (dyret_enum )-10;
      } else {
#line 740
        dy_lp->lpret = (lpret_enum )0;
#line 741
        dy_lp->phase = (dyphase_enum )1;
#line 742
        retval = (dyret_enum )1;
      }
    } else {
#line 744
      retval = (dyret_enum )1;
    }
  } else {
#line 744
    retval = (dyret_enum )1;
  }
#line 746
  return (retval);
}
}
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___0  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 563 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_mulaccumcol(consys_struct *consys , int colndx , double scalar , double *vec ) ;
#line 1752 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
double dy_chkpiv(double abarij , double maxabar ) ;
#line 1870
dyret_enum dy_updateprimals(int j , double deltaj , double *p_abarj ) ;
#line 1953
char const   *dy_prtdyret(dyret_enum retcode ) ;
#line 158 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
static int dualcand_cmp(void const   *p_dualcand1 , void const   *p_dualcand2 ) 
{ 
  double delta1 ;
  double delta2 ;
  double ratio1 ;
  double ratio2 ;
  bool flip1 ;
  bool flip2 ;
  bool mad1 ;
  bool mad2 ;
  dualcand_struct const   *dualcand1 ;
  dualcand_struct const   *dualcand2 ;

  {
#line 181
  dualcand1 = (dualcand_struct const   *)p_dualcand1;
#line 182
  dualcand2 = (dualcand_struct const   *)p_dualcand2;
#line 184
  delta1 = (double )dualcand1->ddelta;
#line 185
  delta2 = (double )dualcand2->ddelta;
#line 186
  mad1 = (bool )dualcand1->madpiv;
#line 187
  mad2 = (bool )dualcand2->madpiv;
#line 192
  if (delta1 < delta2) {
#line 193
    return (-1);
  } else
#line 195
  if (delta1 > delta2) {
#line 196
    return (1);
  }
#line 201
  if ((int )mad1 != (int )mad2) {
#line 202
    if ((int )mad1 == 1) {
#line 203
      return (1);
    } else {
#line 205
      return (-1);
    }
  }
#line 210
  flip1 = (bool )dualcand1->flippable;
#line 211
  flip2 = (bool )dualcand2->flippable;
#line 212
  if (delta1 == (double )0) {
#line 213
    if ((int )flip1 != (int )flip2) {
#line 214
      if ((int )flip1 == 1) {
#line 215
        return (-1);
      } else {
#line 217
        return (1);
      }
    }
  } else
#line 219
  if ((int )flip1 != (int )flip2) {
#line 220
    if ((int )flip1 == 0) {
#line 221
      return (-1);
    } else {
#line 223
      return (1);
    }
  }
#line 228
  ratio1 = (double )dualcand1->ratioik;
#line 229
  ratio2 = (double )dualcand2->ratioik;
#line 230
  if (ratio1 > ratio2) {
#line 231
    return (-1);
  } else
#line 233
  if (ratio1 < ratio2) {
#line 234
    return (1);
  } else {
#line 236
    return (0);
  }
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
static void promoteSanePivot(dualcand_struct *incands ) 
{ 
  int ndx ;
  int candcnt ;
  int firstnoflip ;
  int firstsane ;
  double tol ;
  dualcand_struct sane ;
  dualcand_struct insane ;
  double tmp ;
  double tmp___0 ;
  int j ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 269
  candcnt = (incands + 0)->ndx;
#line 270
  firstnoflip = -1;
#line 271
  firstsane = -1;
#line 272
  ndx = 1;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (ndx <= candcnt)) {
#line 272
      goto while_break;
    }
#line 273
    if ((int )(incands + ndx)->madpiv == 0) {
#line 274
      firstsane = ndx;
#line 275
      goto while_break;
    }
#line 276
    if (firstnoflip < 0) {
#line 276
      if ((int )(incands + ndx)->flippable == 0) {
#line 276
        if ((int )(incands + ndx)->rev == 0) {
#line 278
          firstnoflip = ndx;
        }
      }
    }
#line 272
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (firstsane < 0) {
#line 280
    return;
  } else
#line 280
  if (firstnoflip < 0) {
#line 280
    if (firstsane > 0) {
#line 280
      return;
    }
  }
  {
#line 290
  tmp = log10(dy_tols->dfeas / dy_tols->cost);
#line 290
  tol = tmp / (double )2;
#line 291
  tmp___0 = pow(10.0, tol);
#line 291
  tol = dy_tols->cost * tmp___0;
#line 292
  ndx = firstsane;
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! (ndx > firstnoflip)) {
#line 292
      goto while_break___0;
    }
#line 293
    sane = *(incands + ndx);
#line 294
    insane = *(incands + (ndx - 1));
#line 295
    if ((int )insane.rev == 1) {
#line 297
      *(incands + (ndx - 1)) = sane;
#line 298
      *(incands + ndx) = insane;
    } else
#line 295
    if ((sane.ddelta - insane.ddelta) * insane.abarik < tol) {
#line 297
      *(incands + (ndx - 1)) = sane;
#line 298
      *(incands + ndx) = insane;
    } else {
#line 300
      goto while_break___0;
    }
#line 292
    ndx --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 306
  if (dy_opts->print.pivoting >= 2) {
#line 306
    if (ndx == firstnoflip) {
#line 306
      goto _L;
    } else {
#line 306
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 306
  if (dy_opts->print.pivoting >= 3) {
    _L: /* CIL Label */ 
    {
#line 309
    j = (incands + firstnoflip)->ndx;
#line 310
    tmp___1 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 310
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      first no-flip %s (%d) at %d, ",
                tmp___1, j, firstnoflip);
#line 312
    j = (incands + firstsane)->ndx;
#line 313
    tmp___2 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 313
    dyio_outfmt(dy_logchn, dy_gtxecho, "first sane %s (%d) at %d", tmp___2, j, firstsane);
#line 315
    dyio_outfmt(dy_logchn, dy_gtxecho, ", promoted to %d.  ", ndx);
    }
  }
#line 322
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
static dyret_enum scanForDualInCands(dualcand_struct *incands , int outdir , double *abari ,
                                     double maxabari ) 
{ 
  int n ;
  int k ;
  int reject ;
  int candcnt ;
  int dirk ;
  double abarik ;
  double cbark ;
  double deltak ;
  double ratioik ;
  double *vub ;
  double *vlb ;
  flags statk ;
  bool rev ;
  dyret_enum retval ;
  int print ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;

  {
#line 379
  print = dy_opts->print.pivoting;
#line 380
  dy_opts->print.pivoting = 0;
#line 389
  n = dy_sys->varcnt;
#line 390
  vub = dy_sys->vub;
#line 391
  vlb = dy_sys->vlb;
#line 392
  (incands + 0)->ndx = -1;
#line 395
  if (print >= 1) {
    {
#line 396
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    gathering candidates to enter ... ");
    }
#line 398
    if (print >= 4) {
      {
#line 399
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tVariable\t  cbar<k>\tabar<i,k>\t  delta\tDisp");
      }
    }
  }
#line 410
  candcnt = 0;
#line 411
  k = 1;
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (k <= n)) {
#line 411
      goto while_break;
    }
#line 412
    if (dy_lp->degen > 0) {
#line 412
      if (*(dy_ddegenset + k) != dy_lp->degen) {
#line 412
        goto __Cont;
      }
    }
#line 453
    statk = *(dy_status + k);
#line 454
    cbark = *(dy_cbar + k);
#line 455
    if (statk & (unsigned int )(1 << 6)) {
#line 455
      tmp = 1;
    } else {
#line 455
      tmp = 0;
    }
#line 455
    if (tmp) {
#line 455
      if (cbark > (double )0) {
#line 457
        statk ^= (unsigned int )((1 << 6) | (1 << 7));
#line 458
        rev = (bool )1;
      } else {
#line 455
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 455
      if (statk & (unsigned int )(1 << 7)) {
#line 455
        tmp___0 = 1;
      } else {
#line 455
        tmp___0 = 0;
      }
#line 455
      if (tmp___0) {
#line 455
        if (cbark < (double )0) {
#line 457
          statk ^= (unsigned int )((1 << 6) | (1 << 7));
#line 458
          rev = (bool )1;
        } else {
#line 460
          rev = (bool )0;
        }
      } else {
#line 460
        rev = (bool )0;
      }
    }
#line 461
    reject = 0;
#line 462
    abarik = *(abari + k);
#line 463
    if (statk & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 463
      tmp___6 = 1;
    } else {
#line 463
      tmp___6 = 0;
    }
#line 463
    if (tmp___6) {
#line 464
      reject = -1;
    } else {
      {
#line 466
      tmp___5 = fabs(abarik - 0.0);
      }
#line 466
      if (tmp___5 <= dy_tols->zero) {
#line 467
        reject = -2;
      } else
#line 469
      if (outdir == -1) {
#line 470
        if (statk & (unsigned int )(1 << 6)) {
#line 470
          tmp___1 = 1;
        } else {
#line 470
          tmp___1 = 0;
        }
#line 470
        if (tmp___1) {
#line 470
          if (abarik > (double )0) {
#line 472
            reject = -3;
          } else {
#line 470
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 470
          if (statk & (unsigned int )(1 << 7)) {
#line 470
            tmp___2 = 1;
          } else {
#line 470
            tmp___2 = 0;
          }
#line 470
          if (tmp___2) {
#line 470
            if (abarik < (double )0) {
#line 472
              reject = -3;
            }
          }
        }
      } else {
#line 474
        if (statk & (unsigned int )(1 << 6)) {
#line 474
          tmp___3 = 1;
        } else {
#line 474
          tmp___3 = 0;
        }
#line 474
        if (tmp___3) {
#line 474
          if (abarik < (double )0) {
#line 476
            reject = -3;
          } else {
#line 474
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 474
          if (statk & (unsigned int )(1 << 7)) {
#line 474
            tmp___4 = 1;
          } else {
#line 474
            tmp___4 = 0;
          }
#line 474
          if (tmp___4) {
#line 474
            if (abarik > (double )0) {
#line 476
              reject = -3;
            }
          }
        }
      }
    }
#line 477
    if ((int )rev == 1) {
#line 477
      if (reject == -3) {
#line 478
        cbark = (double )0;
#line 479
        rev = (bool )0;
#line 480
        statk ^= (unsigned int )((1 << 6) | (1 << 7));
#line 481
        reject = 0;
      }
    }
#line 482
    if (reject >= 0) {
      {
#line 483
      ratioik = dy_chkpiv(abarik, maxabari);
      }
#line 484
      if (ratioik < 1.0) {
#line 485
        reject = 1;
      }
    } else {
#line 487
      ratioik = QNaNbits___0.fpdbl;
    }
#line 490
    if (print >= 5) {
#line 490
      goto _L___2;
    } else
#line 490
    if (print >= 4) {
#line 490
      if (reject >= 0) {
        _L___2: /* CIL Label */ 
        {
#line 491
        tmp___7 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 491
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___7, k);
#line 493
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", cbark, abarik);
        }
#line 494
        if (print >= 5) {
          {
#line 496
          if (reject == -1) {
#line 496
            goto case_neg_1;
          }
#line 500
          if (reject == -2) {
#line 500
            goto case_neg_2;
          }
#line 503
          if (reject == -3) {
#line 503
            goto case_neg_3;
          }
#line 495
          goto switch_break;
          case_neg_1: /* CIL Label */ 
          {
#line 497
          tmp___8 = dy_prtvstat(statk);
#line 497
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- status %s", tmp___8);
          }
#line 499
          goto switch_break;
          case_neg_2: /* CIL Label */ 
          {
#line 501
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- zero pivot");
          }
#line 502
          goto switch_break;
          case_neg_3: /* CIL Label */ 
          {
#line 504
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- wrong sign abar<ik>");
          }
#line 506
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 509
    if (reject < 0) {
#line 509
      goto __Cont;
    }
    {
#line 515
    candcnt ++;
#line 515
    (incands + candcnt)->ndx = k;
#line 516
    (incands + candcnt)->abarik = fabs(abarik);
#line 517
    (incands + candcnt)->ratioik = ratioik;
    }
#line 518
    if (reject == 1) {
#line 519
      (incands + candcnt)->madpiv = (bool )1;
    } else {
#line 521
      (incands + candcnt)->madpiv = (bool )0;
    }
    {
#line 522
    deltak = fabs(cbark / abarik);
    }
#line 523
    if ((int )rev == 1) {
#line 524
      (incands + candcnt)->rev = (bool )1;
#line 525
      (incands + candcnt)->ddelta = - deltak;
#line 526
      statk ^= (unsigned int )((1 << 7) | (1 << 6));
    } else {
#line 528
      (incands + candcnt)->rev = (bool )0;
#line 529
      (incands + candcnt)->ddelta = deltak;
    }
#line 530
    if (outdir == -1) {
#line 531
      if (abarik > (double )0) {
#line 532
        dirk = 1;
      } else {
#line 534
        dirk = -1;
      }
    } else
#line 536
    if (abarik > (double )0) {
#line 537
      dirk = -1;
    } else {
#line 539
      dirk = 1;
    }
#line 540
    if ((int )rev == 0) {
#line 541
      (incands + candcnt)->pivdir = dirk;
    } else {
#line 543
      (incands + candcnt)->pivdir = - dirk;
    }
#line 544
    if (statk & (unsigned int )(1 << 6)) {
#line 544
      tmp___9 = 1;
    } else {
#line 544
      tmp___9 = 0;
    }
#line 544
    if (tmp___9) {
#line 545
      if (*(vlb + k) > - dy_tols->inf) {
#line 546
        (incands + candcnt)->flippable = (bool )1;
#line 547
        (incands + candcnt)->flip.delta = *(vlb + k) - *(vub + k);
      } else {
#line 549
        (incands + candcnt)->flippable = (bool )0;
      }
    } else
#line 551
    if (*(vub + k) < dy_tols->inf) {
#line 552
      (incands + candcnt)->flippable = (bool )1;
#line 553
      (incands + candcnt)->flip.delta = *(vub + k) - *(vlb + k);
    } else {
#line 555
      (incands + candcnt)->flippable = (bool )0;
    }
#line 558
    if (print >= 4) {
      {
#line 559
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t accepted", deltak);
      }
#line 560
      if (reject == 1) {
        {
#line 561
        dyio_outfmt(dy_logchn, dy_gtxecho, " (mad)");
        }
      }
#line 562
      if (deltak == (double )0) {
        {
#line 563
        dyio_outfmt(dy_logchn, dy_gtxecho, " (degen)");
        }
      }
#line 564
      if ((int )(incands + candcnt)->flippable == 1) {
        {
#line 565
        dyio_outfmt(dy_logchn, dy_gtxecho, " (flip)");
        }
      }
#line 566
      if ((int )rev == 1) {
        {
#line 567
        dyio_outfmt(dy_logchn, dy_gtxecho, " (rev)");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 411
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  (incands + 0)->ndx = candcnt;
#line 579
  (incands + 0)->ddelta = - dy_tols->inf;
#line 580
  (incands + 0)->madpiv = (bool )0;
#line 581
  if (candcnt > 0) {
#line 582
    if (candcnt > 1) {
      {
#line 583
      qsort((void *)(incands + 1), (size_t )candcnt, sizeof(dualcand_struct ), & dualcand_cmp);
      }
    }
#line 584
    retval = (dyret_enum )1;
  } else {
#line 586
    retval = (dyret_enum )8;
  }
  {
#line 592
  dy_opts->print.pivoting = print;
#line 595
  promoteSanePivot(incands);
  }
#line 598
  if (print >= 1) {
#line 599
    if (print >= 3) {
      {
#line 600
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n   ");
#line 601
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tVariable\tratio<ik>\tdelta<k>");
#line 603
      n = 1;
      }
      {
#line 603
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 603
        if (! (n <= candcnt)) {
#line 603
          goto while_break___0;
        }
        {
#line 604
        k = (incands + n)->ndx;
#line 605
        ratioik = (incands + n)->ratioik;
#line 606
        deltak = (incands + n)->ddelta;
#line 607
        tmp___10 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 607
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___10, k);
#line 609
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", ratioik, deltak);
        }
#line 610
        if ((int )(incands + n)->madpiv == 1) {
          {
#line 611
          dyio_outfmt(dy_logchn, dy_gtxecho, " (mad)");
          }
        }
#line 612
        if (deltak == (double )0) {
          {
#line 613
          dyio_outfmt(dy_logchn, dy_gtxecho, " (degen)");
          }
        }
#line 614
        if ((int )(incands + n)->flippable == 1) {
          {
#line 615
          dyio_outfmt(dy_logchn, dy_gtxecho, " (flip)");
          }
        }
#line 616
        statk = *(dy_status + k);
#line 617
        if (statk & (unsigned int )(1 << 6)) {
#line 617
          tmp___11 = 1;
        } else {
#line 617
          tmp___11 = 0;
        }
#line 617
        if (tmp___11) {
#line 617
          if ((incands + n)->pivdir == 1) {
            {
#line 619
            dyio_outfmt(dy_logchn, dy_gtxecho, " (rev)");
            }
          } else {
#line 617
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 617
          if (statk & (unsigned int )(1 << 7)) {
#line 617
            tmp___12 = 1;
          } else {
#line 617
            tmp___12 = 0;
          }
#line 617
          if (tmp___12) {
#line 617
            if ((incands + n)->pivdir == -1) {
              {
#line 619
              dyio_outfmt(dy_logchn, dy_gtxecho, " (rev)");
              }
            }
          }
        }
#line 620
        if (n > 1) {
          {
#line 621
          dyio_outfmt(dy_logchn, dy_gtxecho, " (%g)", deltak - (incands + (n - 1))->ddelta);
          }
        }
#line 603
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 623
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n   ");
      }
    }
    {
#line 624
    dyio_outfmt(dy_logchn, dy_gtxecho, "%d candidates.", candcnt);
    }
#line 625
    if ((int )retval != 1) {
      {
#line 626
      tmp___13 = dy_prtdyret(retval);
#line 626
      dyio_outfmt(dy_logchn, dy_gtxecho, " Returning %s.", tmp___13);
      }
    }
  }
#line 628
  dy_opts->print.pivoting = print;
#line 631
  return (retval);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
static int calcInfChange(dualcand_struct *candk , int i , double *xbasic ) 
{ 
  int m ;
  int ipos ;
  flags stati ;
  double *vlb ;
  double *vub ;
  double xi ;
  double lbi ;
  double ubi ;
  double deltai ;
  int k ;
  double newxk ;
  double lbk ;
  double ubk ;
  double pivdeltak ;
  double flipdeltak ;
  double pivinf ;
  double maxpivinf ;
  double flipinf ;
  double maxflipinf ;
  double *abark ;
  double abarik ;
  bool flippable ;
  flags statk ;
  int l ;
  int lpos ;
  double xl ;
  double newxl ;
  double lbl ;
  double ubl ;
  double abarlk ;
  double curinf ;
  double infl ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  double tmp___2 ;
  double tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  double tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  double tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  double tmp___20 ;
  int tmp___21 ;
  double tmp___22 ;
  double tmp___24 ;
  int tmp___25 ;
  double tmp___26 ;
  double tmp___28 ;
  int tmp___29 ;
  double tmp___30 ;
  double tmp___32 ;
  int tmp___33 ;
  double tmp___34 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  double tmp___38 ;
  int tmp___39 ;
  double tmp___40 ;
  int tmp___41 ;
  double tmp___43 ;
  int tmp___44 ;
  double tmp___45 ;

  {
#line 672
  rtnnme = "calcInfChange";
#line 678
  m = dy_sys->concnt;
#line 679
  vub = dy_sys->vub;
#line 680
  vlb = dy_sys->vlb;
#line 684
  ipos = *(dy_var2basis + i);
#line 685
  xi = *(xbasic + ipos);
#line 686
  stati = *(dy_status + i);
#line 687
  ubi = *(vub + i);
#line 688
  lbi = *(vlb + i);
#line 689
  if (stati & (unsigned int )(1 << 10)) {
#line 689
    tmp = 1;
  } else {
#line 689
    tmp = 0;
  }
#line 689
  if (tmp) {
#line 690
    deltai = ubi - xi;
  } else {
#line 692
    deltai = lbi - xi;
  }
#line 696
  k = candk->ndx;
#line 697
  statk = *(dy_status + k);
#line 698
  lbk = *(vlb + k);
#line 699
  ubk = *(vub + k);
#line 700
  if ((int )candk->flippable == 1) {
#line 701
    flippable = (bool )1;
#line 702
    flipdeltak = candk->flip.delta;
  } else {
#line 704
    flippable = (bool )0;
#line 705
    flipdeltak = QNaNbits___0.fpdbl;
  }
  {
#line 710
  abark = (double *)((void *)0);
#line 711
  tmp___1 = consys_getcol_ex(dy_sys, k, & abark);
  }
#line 711
  if ((int )tmp___1 == 0) {
    {
#line 712
    tmp___0 = consys_nme(dy_sys, (char )'v', k, (bool )1, (char *)((void *)0));
#line 712
    errmsg(122, rtnnme, dy_sys->nme, "column", tmp___0, k);
    }
#line 714
    if ((unsigned long )abark != (unsigned long )((void *)0)) {
      {
#line 714
      free((void *)abark);
      }
    }
#line 715
    return (-1);
  }
  {
#line 716
  dy_ftran(abark, (bool )0);
#line 717
  abarik = *(abark + ipos);
#line 718
  pivdeltak = - deltai / abarik;
#line 719
  tmp___2 = fabs(pivdeltak);
  }
#line 719
  if (tmp___2 < dy_tols->zero) {
#line 719
    pivdeltak = (double )0;
  }
#line 720
  candk->piv.delta = pivdeltak;
#line 721
  pivinf = (double )0;
#line 722
  if (pivdeltak < (double )0) {
    {
#line 724
    newxk = ubk + pivdeltak;
#line 725
    tmp___6 = fabs(lbk);
    }
#line 725
    if (tmp___6 < dy_tols->inf) {
      {
#line 725
      tmp___4 = fabs(lbk);
#line 725
      tmp___5 = lbk - newxk > dy_tols->pfeas * (1.0 + tmp___4);
      }
    } else {
#line 725
      tmp___5 = newxk < lbk;
    }
#line 725
    if (tmp___5) {
#line 726
      pivinf = lbk - newxk;
    }
  } else {
    {
#line 729
    newxk = lbk + pivdeltak;
#line 730
    tmp___10 = fabs(ubk);
    }
#line 730
    if (tmp___10 < dy_tols->inf) {
      {
#line 730
      tmp___8 = fabs(ubk);
#line 730
      tmp___9 = newxk - ubk > dy_tols->pfeas * (1.0 + tmp___8);
      }
    } else {
#line 730
      tmp___9 = newxk > ubk;
    }
#line 730
    if (tmp___9) {
#line 731
      pivinf = newxk - ubk;
    }
  }
#line 732
  maxpivinf = pivinf;
#line 742
  curinf = (double )0;
#line 743
  flipinf = (double )0;
#line 744
  maxflipinf = (double )0;
#line 745
  lpos = 1;
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
#line 745
    if (! (lpos <= m)) {
#line 745
      goto while_break;
    }
    {
#line 746
    l = *(dy_basis + lpos);
#line 747
    xl = *(xbasic + lpos);
#line 748
    lbl = *(vlb + l);
#line 749
    ubl = *(vub + l);
#line 750
    tmp___18 = fabs(ubl);
    }
#line 750
    if (tmp___18 < dy_tols->inf) {
      {
#line 750
      tmp___16 = fabs(ubl);
#line 750
      tmp___17 = xl - ubl > dy_tols->pfeas * (1.0 + tmp___16);
      }
    } else {
#line 750
      tmp___17 = xl > ubl;
    }
#line 750
    if (tmp___17) {
#line 751
      infl = xl - ubl;
    } else {
      {
#line 753
      tmp___14 = fabs(lbl);
      }
#line 753
      if (tmp___14 < dy_tols->inf) {
        {
#line 753
        tmp___12 = fabs(lbl);
#line 753
        tmp___13 = lbl - xl > dy_tols->pfeas * (1.0 + tmp___12);
        }
      } else {
#line 753
        tmp___13 = xl < lbl;
      }
#line 753
      if (tmp___13) {
#line 754
        infl = lbl - xl;
      } else {
#line 756
        infl = (double )0;
      }
    }
#line 757
    abarlk = *(abark + lpos);
#line 758
    if (abarlk == (double )0) {
#line 759
      if (infl > maxpivinf) {
#line 759
        maxpivinf = infl;
      }
#line 760
      if (infl > maxflipinf) {
#line 760
        maxflipinf = infl;
      }
#line 761
      goto __Cont;
    }
    {
#line 762
    curinf += infl;
#line 764
    newxl = xl - abarlk * pivdeltak;
#line 765
    tmp___26 = fabs(ubl);
    }
#line 765
    if (tmp___26 < dy_tols->inf) {
      {
#line 765
      tmp___24 = fabs(ubl);
#line 765
      tmp___25 = newxl - ubl > dy_tols->pfeas * (1.0 + tmp___24);
      }
    } else {
#line 765
      tmp___25 = newxl > ubl;
    }
#line 765
    if (tmp___25) {
#line 766
      infl = newxl - ubl;
    } else {
      {
#line 768
      tmp___22 = fabs(lbl);
      }
#line 768
      if (tmp___22 < dy_tols->inf) {
        {
#line 768
        tmp___20 = fabs(lbl);
#line 768
        tmp___21 = lbl - newxl > dy_tols->pfeas * (1.0 + tmp___20);
        }
      } else {
#line 768
        tmp___21 = newxl < lbl;
      }
#line 768
      if (tmp___21) {
#line 769
        infl = lbl - newxl;
      } else {
#line 771
        infl = (double )0;
      }
    }
#line 772
    pivinf += infl;
#line 773
    if (infl > maxpivinf) {
#line 773
      maxpivinf = infl;
    }
#line 775
    if ((int )flippable == 1) {
      {
#line 776
      newxl = xl - abarlk * flipdeltak;
#line 777
      tmp___34 = fabs(ubl);
      }
#line 777
      if (tmp___34 < dy_tols->inf) {
        {
#line 777
        tmp___32 = fabs(ubl);
#line 777
        tmp___33 = newxl - ubl > dy_tols->pfeas * (1.0 + tmp___32);
        }
      } else {
#line 777
        tmp___33 = newxl > ubl;
      }
#line 777
      if (tmp___33) {
#line 778
        infl = newxl - ubl;
      } else {
        {
#line 780
        tmp___30 = fabs(lbl);
        }
#line 780
        if (tmp___30 < dy_tols->inf) {
          {
#line 780
          tmp___28 = fabs(lbl);
#line 780
          tmp___29 = lbl - newxl > dy_tols->pfeas * (1.0 + tmp___28);
          }
        } else {
#line 780
          tmp___29 = newxl < lbl;
        }
#line 780
        if (tmp___29) {
#line 781
          infl = lbl - newxl;
        } else {
#line 783
          infl = (double )0;
        }
      }
#line 784
      *(xbasic + lpos) = newxl;
#line 785
      flipinf += infl;
#line 786
      if (infl > maxflipinf) {
#line 786
        maxflipinf = infl;
      }
    }
    __Cont: /* CIL Label */ 
#line 745
    lpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  candk->piv.inf = - curinf + pivinf;
#line 789
  candk->piv.maxinf = maxpivinf;
#line 790
  if ((int )flippable == 1) {
#line 791
    candk->flip.inf = - curinf + flipinf;
#line 792
    candk->flip.maxinf = maxflipinf;
  }
#line 795
  if (dy_opts->print.pivoting >= 3) {
    {
#line 796
    tmp___35 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 796
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) piv = %g, pivmax = %g", tmp___35,
                k, candk->piv.inf, candk->piv.maxinf);
    }
#line 799
    if ((int )flippable == 1) {
      {
#line 800
      dyio_outfmt(dy_logchn, dy_gtxecho, " flip = %g, flipmax = %g", candk->flip.inf,
                  candk->flip.maxinf);
      }
    }
    {
#line 802
    dyio_outfmt(dy_logchn, dy_gtxecho, " pivdelta = %g", pivdeltak);
    }
#line 803
    if ((int )flippable == 1) {
      {
#line 804
      dyio_outfmt(dy_logchn, dy_gtxecho, " flipdelta = %g", flipdeltak);
      }
    }
  }
  {
#line 811
  free((void *)abark);
#line 813
  xi = *(xbasic + ipos);
  }
#line 814
  if (stati & (unsigned int )(1 << 10)) {
#line 814
    tmp___36 = 1;
  } else {
#line 814
    tmp___36 = 0;
  }
#line 814
  if (tmp___36) {
    {
#line 814
    tmp___40 = fabs(ubi);
    }
#line 814
    if (tmp___40 < dy_tols->inf) {
      {
#line 814
      tmp___38 = fabs(ubi);
#line 814
      tmp___39 = xi - ubi > dy_tols->pfeas * (1.0 + tmp___38);
      }
    } else {
#line 814
      tmp___39 = xi > ubi;
    }
#line 814
    if (tmp___39) {
#line 814
      goto _L;
    } else {
#line 816
      return (0);
    }
  } else {
    _L: /* CIL Label */ 
#line 814
    if (stati & (unsigned int )(1 << 11)) {
#line 814
      tmp___41 = 1;
    } else {
#line 814
      tmp___41 = 0;
    }
#line 814
    if (tmp___41) {
      {
#line 814
      tmp___45 = fabs(lbi);
      }
#line 814
      if (tmp___45 < dy_tols->inf) {
        {
#line 814
        tmp___43 = fabs(lbi);
#line 814
        tmp___44 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___43);
        }
      } else {
#line 814
        tmp___44 = xi < lbi;
      }
#line 814
      if (tmp___44) {
#line 818
        return (1);
      } else {
#line 816
        return (0);
      }
    } else {
#line 818
      return (1);
    }
  }
}
}
#line 822 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
bool selectWithInf(int i , dualcand_struct *incands , int *indices , double *candinf ,
                   double *startinf ) 
{ 
  int m ;
  int j ;
  int jpos ;
  double xj ;
  double lbj ;
  double ubj ;
  double infj ;
  double *vlb ;
  double *vub ;
  double starttotinf ;
  double startmaxinf ;
  double *xbasic ;
  int ndx ;
  int candcnt ;
  int price_retval ;
  double flipinfk ;
  double pivinfk ;
  double totinfk ;
  int bestflipcand ;
  int bestpivcand ;
  int lastpivcand ;
  double bestflipinf ;
  double bestpivinf ;
  double lastpivinf ;
  bool pivEndsScan ;
  bool flipEndsScan ;
  dualcand_struct *candk ;
  char const   *rtnnme ;
  int lastdegen ;
  void *tmp ;
  double tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
  {
#line 877
  rtnnme = "selectWithInf";
#line 880
  lastdegen = 0;
#line 883
  m = dy_sys->concnt;
#line 884
  vlb = dy_sys->vlb;
#line 885
  vub = dy_sys->vub;
#line 893
  tmp = malloc((unsigned long )(m + 1) * sizeof(double ));
#line 893
  xbasic = (double *)tmp;
#line 894
  starttotinf = (double )0;
#line 895
  startmaxinf = (double )0;
#line 896
  jpos = 1;
  }
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    if (! (jpos <= m)) {
#line 896
      goto while_break;
    }
    {
#line 897
    *(xbasic + jpos) = *(dy_xbasic + jpos);
#line 898
    xj = *(xbasic + jpos);
#line 899
    j = *(dy_basis + jpos);
#line 900
    lbj = *(vlb + j);
#line 901
    ubj = *(vub + j);
#line 902
    infj = (double )0;
#line 903
    tmp___7 = fabs(lbj);
    }
#line 903
    if (tmp___7 < dy_tols->inf) {
      {
#line 903
      tmp___5 = fabs(lbj);
#line 903
      tmp___6 = lbj - xj > dy_tols->pfeas * (1.0 + tmp___5);
      }
    } else {
#line 903
      tmp___6 = xj < lbj;
    }
#line 903
    if (tmp___6) {
#line 904
      infj = lbj - xj;
    } else {
      {
#line 906
      tmp___3 = fabs(ubj);
      }
#line 906
      if (tmp___3 < dy_tols->inf) {
        {
#line 906
        tmp___1 = fabs(ubj);
#line 906
        tmp___2 = xj - ubj > dy_tols->pfeas * (1.0 + tmp___1);
        }
      } else {
#line 906
        tmp___2 = xj > ubj;
      }
#line 906
      if (tmp___2) {
#line 907
        infj = xj - ubj;
      }
    }
#line 908
    if (infj > startmaxinf) {
#line 908
      startmaxinf = infj;
    }
#line 909
    starttotinf += infj;
#line 896
    jpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  *(startinf + 0) = starttotinf;
#line 911
  *(startinf + 1) = startmaxinf;
#line 914
  if (dy_opts->print.pivoting >= 1) {
    {
#line 915
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      starting inf tot = %g, max = %g",
                starttotinf, startmaxinf);
    }
  }
#line 955
  bestpivcand = -1;
#line 956
  bestflipcand = -1;
#line 957
  lastpivcand = -1;
#line 958
  bestpivinf = dy_tols->inf;
#line 959
  bestflipinf = dy_tols->inf;
#line 960
  lastpivinf = QNaNbits___0.fpdbl;
#line 961
  pivEndsScan = (bool )0;
#line 962
  flipEndsScan = (bool )0;
#line 963
  candcnt = (incands + 0)->ndx;
#line 964
  totinfk = (double )0;
#line 974
  ndx = 1;
#line 974
  candk = incands + 1;
  {
#line 974
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 974
    if (candk->ddelta <= (double )0) {
#line 974
      if (! (ndx <= candcnt)) {
#line 974
        goto while_break___0;
      }
    } else {
#line 974
      goto while_break___0;
    }
#line 977
    if ((int )candk->rev == 0) {
      {
#line 978
      price_retval = calcInfChange(candk, i, xbasic);
      }
    } else {
#line 980
      price_retval = 1;
    }
#line 981
    if (price_retval < 0) {
      {
#line 982
      free((void *)xbasic);
#line 983
      tmp___8 = consys_nme(dy_sys, (char )'v', candk->ndx, (bool )0, (char *)((void *)0));
#line 983
      tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 983
      errmsg(348, rtnnme, dy_sys->nme, tmp___9, dy_lp->tot.iters + 1, tmp___8, candk->ndx);
      }
#line 986
      return ((bool )0);
    }
#line 987
    flipinfk = candk->flip.maxinf;
#line 988
    pivinfk = candk->piv.maxinf;
#line 989
    totinfk += candk->flip.inf;
#line 1009
    if ((int )candk->madpiv == 0) {
#line 1010
      lastpivcand = ndx;
#line 1011
      lastpivinf = pivinfk;
#line 1012
      if (pivinfk < bestpivinf) {
#line 1013
        bestpivcand = ndx;
#line 1014
        bestpivinf = pivinfk;
      }
    }
#line 1015
    if ((int )candk->flippable == 0) {
#line 1015
      if ((int )candk->rev == 0) {
#line 1016
        pivEndsScan = (bool )1;
#line 1017
        goto while_break___0;
      }
    }
#line 1018
    if (flipinfk < bestflipinf) {
#line 1019
      bestflipcand = ndx;
#line 1020
      bestflipinf = flipinfk;
    }
#line 1021
    if (price_retval == 0) {
#line 1022
      flipEndsScan = (bool )1;
#line 1023
      if ((int )candk->madpiv == 0) {
#line 1024
        lastpivcand = ndx;
#line 1025
        lastpivinf = pivinfk;
      }
#line 1026
      goto while_break___0;
    }
#line 974
    ndx ++;
#line 974
    candk ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1029
  if (dy_opts->print.pivoting >= 2) {
#line 1029
    if (ndx > 1) {
#line 1030
      if ((int )pivEndsScan == 1) {
#line 1031
        jpos = ndx;
      } else
#line 1030
      if ((int )flipEndsScan == 1) {
#line 1031
        jpos = ndx;
      } else {
#line 1033
        jpos = ndx - 1;
      }
      {
#line 1034
      lastdegen = jpos;
#line 1035
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      after %d degen", jpos);
      }
#line 1036
      if (bestflipcand > 0) {
        {
#line 1037
        j = (incands + bestflipcand)->ndx;
#line 1038
        tmp___10 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1038
        dyio_outfmt(dy_logchn, dy_gtxecho, ", best flip #%d, %s (%d) = %g", bestflipcand,
                    tmp___10, j, bestflipinf);
        }
      }
#line 1041
      if (bestpivcand > 0) {
        {
#line 1042
        j = (incands + bestpivcand)->ndx;
#line 1043
        tmp___11 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1043
        dyio_outfmt(dy_logchn, dy_gtxecho, ", best piv #%d, %s (%d) = %g", bestpivcand,
                    tmp___11, j, bestpivinf);
        }
      }
#line 1046
      if (lastpivcand > 0) {
        {
#line 1047
        j = (incands + lastpivcand)->ndx;
#line 1048
        tmp___12 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1048
        dyio_outfmt(dy_logchn, dy_gtxecho, ", last piv #%d, %s (%d) = %g", lastpivcand,
                    tmp___12, j, lastpivinf);
        }
      }
#line 1051
      if (bestflipcand < 0) {
#line 1051
        if (bestpivcand < 0) {
#line 1051
          if (lastpivcand < 0) {
            {
#line 1052
            dyio_outfmt(dy_logchn, dy_gtxecho, ", nothing");
            }
          }
        }
      }
      {
#line 1053
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
  }
#line 1062
  if ((int )pivEndsScan == 0) {
#line 1062
    if ((int )flipEndsScan == 0) {
      {
#line 1063
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1063
        if (! (ndx <= candcnt)) {
#line 1063
          goto while_break___1;
        }
        {
#line 1064
        price_retval = calcInfChange(candk, i, xbasic);
        }
#line 1065
        if (price_retval < 0) {
          {
#line 1066
          free((void *)xbasic);
#line 1067
          tmp___13 = consys_nme(dy_sys, (char )'v', candk->ndx, (bool )0, (char *)((void *)0));
#line 1067
          tmp___14 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1067
          errmsg(348, rtnnme, dy_sys->nme, tmp___14, dy_lp->tot.iters + 1, tmp___13,
                 candk->ndx);
          }
#line 1070
          return ((bool )0);
        }
#line 1071
        flipinfk = candk->flip.maxinf;
#line 1072
        pivinfk = candk->piv.maxinf;
#line 1073
        totinfk += candk->flip.inf;
#line 1093
        if ((int )candk->madpiv == 0) {
#line 1094
          lastpivcand = ndx;
#line 1095
          lastpivinf = pivinfk;
#line 1096
          if (pivinfk < bestpivinf) {
#line 1097
            bestpivcand = ndx;
#line 1098
            bestpivinf = pivinfk;
          }
        }
#line 1099
        if ((int )candk->flippable == 0) {
#line 1099
          goto _L;
        } else
#line 1099
        if (price_retval == 0) {
          _L: /* CIL Label */ 
#line 1100
          pivEndsScan = (bool )1;
#line 1101
          if ((int )candk->madpiv == 0) {
#line 1102
            lastpivcand = ndx;
#line 1103
            lastpivinf = pivinfk;
          }
#line 1104
          goto while_break___1;
        }
#line 1063
        ndx ++;
#line 1063
        candk ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1107
      if (dy_opts->print.pivoting >= 2) {
#line 1108
        if ((int )pivEndsScan == 1) {
#line 1109
          jpos = ndx;
        } else
#line 1108
        if ((int )flipEndsScan == 1) {
#line 1109
          jpos = ndx;
        } else {
#line 1111
          jpos = ndx - 1;
        }
        {
#line 1112
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      after %d nondegen", jpos - lastdegen);
        }
#line 1114
        if (bestflipcand > 0) {
          {
#line 1115
          j = (incands + bestflipcand)->ndx;
#line 1116
          tmp___15 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1116
          dyio_outfmt(dy_logchn, dy_gtxecho, ", best flip #%d, %s (%d) = %g", bestflipcand,
                      tmp___15, j, bestflipinf);
          }
        }
#line 1119
        if (bestpivcand > 0) {
          {
#line 1120
          j = (incands + bestpivcand)->ndx;
#line 1121
          tmp___16 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1121
          dyio_outfmt(dy_logchn, dy_gtxecho, ", best piv #%d, %s (%d) = %g", bestpivcand,
                      tmp___16, j, bestpivinf);
          }
        }
#line 1124
        if (lastpivcand > 0) {
          {
#line 1125
          j = (incands + lastpivcand)->ndx;
#line 1126
          tmp___17 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1126
          dyio_outfmt(dy_logchn, dy_gtxecho, ", last piv #%d, %s (%d) = %g", lastpivcand,
                      tmp___17, j, lastpivinf);
          }
        }
#line 1129
        if (bestflipcand < 0) {
#line 1129
          if (bestpivcand < 0) {
#line 1129
            if (lastpivcand < 0) {
              {
#line 1130
              dyio_outfmt(dy_logchn, dy_gtxecho, ", nothing");
              }
            }
          }
        }
        {
#line 1131
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
  }
  {
#line 1135
  free((void *)xbasic);
#line 1147
  *(indices + 0) = bestflipcand;
#line 1148
  *(indices + 1) = bestpivcand;
#line 1149
  *(indices + 2) = lastpivcand;
  }
#line 1151
  if (bestflipcand > 0) {
#line 1152
    *(candinf + 0) = bestflipinf;
  } else {
#line 1154
    *(candinf + 0) = QNaNbits___0.fpdbl;
  }
#line 1155
  if (bestpivcand > 0) {
#line 1156
    *(candinf + 1) = bestpivinf;
  } else {
#line 1158
    *(candinf + 0) = QNaNbits___0.fpdbl;
  }
#line 1159
  if (lastpivcand > 0) {
#line 1160
    *(candinf + 2) = lastpivinf;
  } else {
#line 1162
    *(candinf + 0) = QNaNbits___0.fpdbl;
  }
#line 1164
  return ((bool )1);
}
}
#line 1168 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
bool selectWithoutInf(int i , double *abari , dualcand_struct *incands , int *indices ) 
{ 
  int m ;
  double *vlb ;
  double *vub ;
  int ipos ;
  double xi ;
  double lbi ;
  double ubi ;
  flags stati ;
  int k ;
  double lbk ;
  double ubk ;
  double deltak ;
  double abarik ;
  flags statk ;
  double startinf ;
  int ndx ;
  int candcnt ;
  int lastflipcand ;
  int lastpivcand ;
  bool pivEndsScan ;
  bool flipEndsScan ;
  bool flipsOnly ;
  dualcand_struct *candk ;
  int j ;
  int jndx ;
  int lastdegen ;
  int tmp ;
  int tmp___0 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  double tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  double tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  double tmp___24 ;
  int tmp___25 ;
  double tmp___26 ;
  int tmp___27 ;
  double tmp___29 ;
  int tmp___30 ;
  double tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;

  {
#line 1224
  lastdegen = 0;
#line 1232
  m = dy_sys->concnt;
#line 1233
  vlb = dy_sys->vlb;
#line 1234
  vub = dy_sys->vub;
#line 1240
  ipos = *(dy_var2basis + i);
#line 1241
  stati = *(dy_status + i);
#line 1242
  xi = *(dy_x + i);
#line 1243
  ubi = *(vub + i);
#line 1244
  lbi = *(vlb + i);
#line 1245
  if (stati & (unsigned int )(1 << 10)) {
#line 1245
    tmp = 1;
  } else {
#line 1245
    tmp = 0;
  }
#line 1245
  if (tmp) {
#line 1246
    startinf = xi - ubi;
  } else {
#line 1248
    startinf = lbi - xi;
  }
#line 1251
  if (dy_opts->print.pivoting >= 1) {
    {
#line 1252
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      starting inf<%d> = %g", i, startinf);
    }
  }
#line 1278
  lastflipcand = -1;
#line 1279
  lastpivcand = -1;
#line 1280
  pivEndsScan = (bool )0;
#line 1281
  flipEndsScan = (bool )0;
#line 1282
  candcnt = (incands + 0)->ndx;
#line 1299
  ndx = 1;
#line 1299
  candk = incands + 1;
  {
#line 1299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1299
    if (ndx <= candcnt) {
#line 1299
      if (! (candk->ddelta <= (double )0)) {
#line 1299
        goto while_break;
      }
    } else {
#line 1299
      goto while_break;
    }
#line 1302
    k = candk->ndx;
#line 1303
    if ((int )candk->madpiv == 0) {
#line 1304
      lastpivcand = ndx;
    }
#line 1305
    if ((int )candk->flippable == 0) {
#line 1305
      if ((int )candk->rev == 0) {
#line 1306
        pivEndsScan = (bool )1;
#line 1307
        goto while_break;
      }
    }
#line 1308
    if ((int )candk->rev == 1) {
#line 1308
      goto __Cont;
    }
#line 1309
    statk = *(dy_status + k);
#line 1310
    lbk = *(vlb + k);
#line 1311
    ubk = *(vub + k);
#line 1312
    if (statk & (unsigned int )(1 << 7)) {
#line 1312
      tmp___0 = 1;
    } else {
#line 1312
      tmp___0 = 0;
    }
#line 1312
    if (tmp___0) {
#line 1313
      deltak = ubk - lbk;
    } else {
#line 1315
      deltak = lbk - ubk;
    }
#line 1316
    abarik = *(abari + k);
#line 1317
    xi -= abarik * deltak;
#line 1318
    if (stati & (unsigned int )(1 << 10)) {
#line 1318
      tmp___9 = 1;
    } else {
#line 1318
      tmp___9 = 0;
    }
#line 1318
    if (tmp___9) {
      {
#line 1318
      tmp___13 = fabs(ubi);
      }
#line 1318
      if (tmp___13 < dy_tols->inf) {
        {
#line 1318
        tmp___11 = fabs(ubi);
#line 1318
        tmp___12 = xi - ubi > dy_tols->pfeas * (1.0 + tmp___11);
        }
      } else {
#line 1318
        tmp___12 = xi > ubi;
      }
#line 1318
      if (tmp___12) {
#line 1318
        goto _L___0;
      } else {
#line 1318
        goto _L;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1318
      if (stati & (unsigned int )(1 << 11)) {
#line 1318
        tmp___14 = 1;
      } else {
#line 1318
        tmp___14 = 0;
      }
#line 1318
      if (tmp___14) {
        {
#line 1318
        tmp___18 = fabs(lbi);
        }
#line 1318
        if (tmp___18 < dy_tols->inf) {
          {
#line 1318
          tmp___16 = fabs(lbi);
#line 1318
          tmp___17 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___16);
          }
        } else {
#line 1318
          tmp___17 = xi < lbi;
        }
#line 1318
        if (! tmp___17) {
          _L: /* CIL Label */ 
          {
#line 1320
          tmp___4 = fabs(ubi);
          }
#line 1320
          if (tmp___4 < dy_tols->inf) {
            {
#line 1320
            tmp___2 = fabs(ubi);
#line 1320
            tmp___3 = xi - ubi > dy_tols->pfeas * (1.0 + tmp___2);
            }
          } else {
#line 1320
            tmp___3 = xi > ubi;
          }
#line 1320
          if (! tmp___3) {
            {
#line 1320
            tmp___8 = fabs(lbi);
            }
#line 1320
            if (tmp___8 < dy_tols->inf) {
              {
#line 1320
              tmp___6 = fabs(lbi);
#line 1320
              tmp___7 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___6);
              }
            } else {
#line 1320
              tmp___7 = xi < lbi;
            }
#line 1320
            if (! tmp___7) {
#line 1321
              lastflipcand = ndx;
            }
          }
#line 1322
          flipEndsScan = (bool )1;
#line 1323
          goto while_break;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1299
    ndx ++;
#line 1299
    candk ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1335
  if ((int )flipEndsScan == 1) {
#line 1335
    if (lastflipcand > 0) {
#line 1336
      flipsOnly = (bool )1;
    } else {
#line 1338
      flipsOnly = (bool )0;
    }
  } else {
#line 1338
    flipsOnly = (bool )0;
  }
#line 1341
  if (dy_opts->print.pivoting >= 2) {
#line 1341
    if (ndx >= 1) {
#line 1342
      if ((int )pivEndsScan == 1) {
#line 1343
        jndx = ndx;
      } else
#line 1342
      if ((int )flipEndsScan == 1) {
#line 1343
        jndx = ndx;
      } else {
#line 1345
        jndx = ndx - 1;
      }
#line 1346
      lastdegen = jndx;
#line 1347
      if (jndx > 0) {
        {
#line 1348
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      after %d degen", jndx);
        }
#line 1349
        if (lastflipcand > 0) {
          {
#line 1350
          j = (incands + lastflipcand)->ndx;
#line 1351
          tmp___19 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1351
          dyio_outfmt(dy_logchn, dy_gtxecho, ", last flip #%d, %s (%d)", lastflipcand,
                      tmp___19, j);
          }
        }
#line 1354
        if (lastpivcand > 0) {
          {
#line 1355
          j = (incands + lastpivcand)->ndx;
#line 1356
          tmp___20 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1356
          dyio_outfmt(dy_logchn, dy_gtxecho, ", last piv #%d, %s (%d)", lastpivcand,
                      tmp___20, j);
          }
        }
#line 1358
        if (lastflipcand < 0) {
#line 1358
          if (lastpivcand < 0) {
            {
#line 1359
            dyio_outfmt(dy_logchn, dy_gtxecho, ", nothing");
            }
          }
        }
        {
#line 1360
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
  }
#line 1368
  if ((int )pivEndsScan == 0) {
#line 1368
    if ((int )flipEndsScan == 0) {
      {
#line 1369
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1369
        if (! (ndx <= candcnt)) {
#line 1369
          goto while_break___0;
        }
#line 1370
        k = candk->ndx;
#line 1371
        if ((int )candk->madpiv == 0) {
#line 1372
          lastpivcand = ndx;
        }
#line 1373
        if ((int )candk->flippable == 0) {
#line 1374
          pivEndsScan = (bool )1;
#line 1375
          goto while_break___0;
        }
#line 1376
        statk = *(dy_status + k);
#line 1377
        lbk = *(vlb + k);
#line 1378
        ubk = *(vub + k);
#line 1379
        if (statk & (unsigned int )(1 << 7)) {
#line 1379
          tmp___21 = 1;
        } else {
#line 1379
          tmp___21 = 0;
        }
#line 1379
        if (tmp___21) {
#line 1380
          deltak = ubk - lbk;
        } else {
#line 1382
          deltak = lbk - ubk;
        }
#line 1383
        abarik = *(abari + k);
#line 1384
        xi -= abarik * deltak;
#line 1385
        if (stati & (unsigned int )(1 << 10)) {
#line 1385
          tmp___22 = 1;
        } else {
#line 1385
          tmp___22 = 0;
        }
#line 1385
        if (tmp___22) {
          {
#line 1385
          tmp___26 = fabs(ubi);
          }
#line 1385
          if (tmp___26 < dy_tols->inf) {
            {
#line 1385
            tmp___24 = fabs(ubi);
#line 1385
            tmp___25 = xi - ubi > dy_tols->pfeas * (1.0 + tmp___24);
            }
          } else {
#line 1385
            tmp___25 = xi > ubi;
          }
#line 1385
          if (tmp___25) {
#line 1385
            goto _L___1;
          } else {
#line 1387
            flipEndsScan = (bool )1;
#line 1388
            goto while_break___0;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 1385
          if (stati & (unsigned int )(1 << 11)) {
#line 1385
            tmp___27 = 1;
          } else {
#line 1385
            tmp___27 = 0;
          }
#line 1385
          if (tmp___27) {
            {
#line 1385
            tmp___31 = fabs(lbi);
            }
#line 1385
            if (tmp___31 < dy_tols->inf) {
              {
#line 1385
              tmp___29 = fabs(lbi);
#line 1385
              tmp___30 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___29);
              }
            } else {
#line 1385
              tmp___30 = xi < lbi;
            }
#line 1385
            if (! tmp___30) {
#line 1387
              flipEndsScan = (bool )1;
#line 1388
              goto while_break___0;
            }
          }
        }
#line 1369
        ndx ++;
#line 1369
        candk ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1391
      if (dy_opts->print.pivoting >= 2) {
#line 1392
        if ((int )pivEndsScan == 1) {
#line 1393
          jndx = ndx;
        } else
#line 1392
        if ((int )flipEndsScan == 1) {
#line 1393
          jndx = ndx;
        } else {
#line 1395
          jndx = ndx - 1;
        }
        {
#line 1396
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      after %d nondegen", jndx - lastdegen);
        }
#line 1398
        if (lastflipcand > 0) {
          {
#line 1399
          j = (incands + lastflipcand)->ndx;
#line 1400
          tmp___32 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1400
          dyio_outfmt(dy_logchn, dy_gtxecho, ", last flip #%d, %s (%d)", lastflipcand,
                      tmp___32, j);
          }
        }
#line 1403
        if (lastpivcand > 0) {
          {
#line 1404
          j = (incands + lastpivcand)->ndx;
#line 1405
          tmp___33 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1405
          dyio_outfmt(dy_logchn, dy_gtxecho, ", last piv #%d, %s (%d)", lastpivcand,
                      tmp___33, j);
          }
        }
#line 1407
        if (lastflipcand < 0) {
#line 1407
          if (lastpivcand < 0) {
            {
#line 1408
            dyio_outfmt(dy_logchn, dy_gtxecho, ", nothing");
            }
          }
        }
        {
#line 1409
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
  }
#line 1417
  if ((int )flipsOnly == 1) {
#line 1418
    *(indices + 0) = lastflipcand;
  } else {
#line 1420
    *(indices + 0) = -1;
  }
#line 1421
  *(indices + 1) = -1;
#line 1422
  *(indices + 2) = lastpivcand;
#line 1424
  return ((bool )1);
}
}
#line 1480
dyret_enum dy_confirmDualPivot(int i , int j , double *abari , double maxabari , double **p_abarj ) ;
#line 1429 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualmultipivot.c"
dyret_enum dualmultiin(int i , int outdir , int *p_xjndx , int *p_indir , double *abari ,
                       double maxabari , double **p_abarj ) 
{ 
  int n ;
  int m ;
  int candcnt ;
  double *vub ;
  double *vlb ;
  double *accumj ;
  dyret_enum retval ;
  dyret_enum upd_retval ;
  dyret_enum confirm ;
  bool swing ;
  bool reqchk ;
  bool flipOnly ;
  bool sel_retval ;
  int j ;
  double xj ;
  double deltaj ;
  double starttotinf ;
  double startmaxinf ;
  flags statj ;
  int dpstrat ;
  int candndx[4] ;
  double candinf[4] ;
  double startinf[2] ;
  int ndx ;
  int bestpivcand ;
  int bestflipcand ;
  int lastpivcand ;
  int bestcand ;
  double bestpivinf ;
  double lastpivinf ;
  double bestflipinf ;
  double bestinf ;
  dualcand_struct *incands ;
  dualcand_struct *candk ;
  char const   *rtnnme ;
  double infj ;
  void *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;

  {
  {
#line 1477
  rtnnme = "dualmultiin";
#line 1489
  retval = (dyret_enum )0;
#line 1490
  *p_xjndx = 0;
#line 1491
  *p_indir = 0;
#line 1492
  n = dy_sys->varcnt;
#line 1493
  m = dy_sys->concnt;
#line 1494
  vub = dy_sys->vub;
#line 1495
  vlb = dy_sys->vlb;
#line 1496
  tmp = malloc((unsigned long )((n - m) + 1) * sizeof(dualcand_struct ));
#line 1496
  incands = (dualcand_struct *)tmp;
  }
#line 1508
  if ((int )dy_opts->dpsel.flex == 1) {
#line 1509
    if (dy_lp->prim.max > dy_tols->toobig / (double )100) {
#line 1510
      dy_opts->dpsel.strat = 2;
    } else
#line 1512
    if (dy_lp->prim.max > dy_tols->toobig / (double )1000) {
#line 1513
      dy_opts->dpsel.strat = 3;
    } else {
#line 1515
      dy_opts->dpsel.strat = 1;
    }
  }
#line 1516
  dpstrat = dy_opts->dpsel.strat;
#line 1519
  if (dy_opts->print.pivoting >= 1) {
    {
#line 1520
    tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1520
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: selecting entering variable, strategy %d",
                tmp___0, dy_lp->tot.iters + 1, dpstrat);
    }
  }
  {
#line 1533
  retval = scanForDualInCands(incands, outdir, abari, maxabari);
  }
#line 1534
  if ((int )retval != 1) {
    {
#line 1535
    *p_xjndx = -1;
#line 1536
    free((void *)incands);
    }
#line 1537
    return (retval);
  }
#line 1538
  candk = incands + 0;
#line 1539
  candcnt = candk->ndx;
#line 1540
  candk ++;
#line 1549
  if (candcnt == 1) {
#line 1549
    goto _L;
  } else
#line 1549
  if ((int )candk->flippable == 0) {
#line 1549
    if ((int )candk->rev == 0) {
      _L: /* CIL Label */ 
#line 1550
      *p_xjndx = candk->ndx;
#line 1551
      *p_indir = candk->pivdir;
#line 1552
      if ((int )candk->madpiv == 1) {
#line 1553
        retval = (dyret_enum )-1;
      } else
#line 1555
      if (candk->ddelta == (double )0) {
#line 1556
        retval = (dyret_enum )-2;
      } else {
#line 1558
        retval = (dyret_enum )1;
      }
      {
#line 1559
      confirm = dy_confirmDualPivot(i, candk->ndx, abari, maxabari, p_abarj);
      }
#line 1560
      if ((int )confirm != 1) {
#line 1561
        retval = confirm;
      }
      {
#line 1562
      free((void *)incands);
      }
#line 1563
      return (retval);
    }
  }
#line 1579
  if (dpstrat == 1) {
    {
#line 1580
    sel_retval = selectWithoutInf(i, abari, incands, candndx);
    }
  } else {
    {
#line 1582
    sel_retval = selectWithInf(i, incands, candndx, candinf, startinf);
    }
  }
#line 1583
  if ((int )sel_retval == 0) {
    {
#line 1584
    free((void *)incands);
    }
#line 1585
    return ((dyret_enum )-10);
  }
#line 1586
  bestflipcand = candndx[0];
#line 1587
  bestpivcand = candndx[1];
#line 1588
  lastpivcand = candndx[2];
#line 1589
  if (dpstrat != 1) {
#line 1590
    bestflipinf = candinf[0];
#line 1591
    bestpivinf = candinf[1];
#line 1592
    lastpivinf = candinf[2];
#line 1593
    starttotinf = startinf[0];
#line 1594
    startmaxinf = startinf[1];
  } else {
#line 1596
    bestflipinf = QNaNbits___0.fpdbl;
#line 1597
    bestpivinf = QNaNbits___0.fpdbl;
#line 1598
    lastpivinf = QNaNbits___0.fpdbl;
#line 1599
    starttotinf = QNaNbits___0.fpdbl;
#line 1600
    startmaxinf = QNaNbits___0.fpdbl;
  }
#line 1602
  if (dpstrat == 1) {
#line 1603
    if (*(dy_status + i) & (unsigned int )(1 << 11)) {
#line 1603
      tmp___1 = 1;
    } else {
#line 1603
      tmp___1 = 0;
    }
#line 1603
    if (tmp___1) {
#line 1604
      starttotinf = *(vlb + i) - *(dy_x + i);
    } else {
#line 1606
      starttotinf = *(dy_x + i) - *(vub + i);
    }
  }
  {
#line 1624
  if (dpstrat == 1) {
#line 1624
    goto case_1;
  }
#line 1628
  if (dpstrat == 2) {
#line 1628
    goto case_2;
  }
#line 1632
  if (dpstrat == 3) {
#line 1632
    goto case_3;
  }
#line 1648
  goto switch_default;
  case_1: /* CIL Label */ 
#line 1625
  bestcand = lastpivcand;
#line 1626
  bestinf = lastpivinf;
#line 1627
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1629
  bestcand = bestpivcand;
#line 1630
  bestinf = bestpivinf;
#line 1631
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1633
  if (bestpivcand > 0) {
#line 1634
    if (bestpivinf < startmaxinf) {
#line 1635
      bestcand = bestpivcand;
#line 1636
      bestinf = bestpivinf;
    } else
#line 1638
    if ((incands + lastpivcand)->ddelta > (double )0) {
#line 1639
      bestcand = lastpivcand;
#line 1640
      bestinf = lastpivinf;
    } else {
#line 1642
      bestcand = bestpivcand;
#line 1643
      bestinf = bestpivinf;
    }
  } else {
#line 1645
    bestcand = -1;
#line 1646
    bestinf = QNaNbits___0.fpdbl;
  }
#line 1647
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1649
  errmsg(1, rtnnme, 1649);
#line 1650
  free((void *)incands);
  }
#line 1651
  return ((dyret_enum )-10);
  switch_break: /* CIL Label */ ;
  }
#line 1653
  flipOnly = (bool )0;
#line 1654
  if (bestcand <= 0) {
#line 1655
    if ((int )dy_opts->dpsel.allownopiv == 1) {
#line 1655
      if (bestflipcand > 0) {
#line 1655
        if (dpstrat == 1) {
#line 1657
          flipOnly = (bool )1;
#line 1658
          bestcand = bestflipcand;
#line 1659
          bestinf = bestflipinf;
        } else
#line 1655
        if (bestflipinf < startmaxinf) {
#line 1657
          flipOnly = (bool )1;
#line 1658
          bestcand = bestflipcand;
#line 1659
          bestinf = bestflipinf;
        } else {
#line 1661
          bestcand = 1;
        }
      } else {
#line 1661
        bestcand = 1;
      }
    } else {
#line 1661
      bestcand = 1;
    }
  }
#line 1662
  candk = incands + bestcand;
#line 1671
  if (dy_opts->print.pivoting >= 1) {
#line 1672
    j = candk->ndx;
#line 1673
    infj = starttotinf;
#line 1674
    if (dpstrat > 1) {
#line 1675
      ndx = 1;
      {
#line 1675
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1675
        if (! (ndx < bestcand)) {
#line 1675
          goto while_break;
        }
#line 1676
        infj += (incands + ndx)->flip.inf;
#line 1675
        ndx ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1677
      if ((int )flipOnly == 1) {
#line 1678
        infj += candk->flip.inf;
      } else {
#line 1680
        infj += candk->piv.inf;
      }
    }
    {
#line 1681
    tmp___2 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
    }
#line 1681
    if ((int )flipOnly == 1) {
#line 1681
      tmp___3 = "flip";
    } else {
#line 1681
      tmp___3 = "pivot";
    }
    {
#line 1681
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  selected %s #%d, %s (%d), est. maxinf =  %g, totinf = %g",
                tmp___3, bestcand, tmp___2, j, bestinf, infj);
    }
  }
#line 1705
  if (candk->ddelta == (double )0) {
#line 1706
    if ((int )dy_opts->degen == 1) {
#line 1706
      if (dy_opts->degenpivlim < dy_lp->degenpivcnt) {
        {
#line 1707
        *p_xjndx = candk->ndx;
#line 1708
        *p_indir = candk->pivdir;
#line 1709
        retval = (dyret_enum )-2;
#line 1710
        free((void *)incands);
        }
#line 1711
        return (retval);
      }
    }
  }
  {
#line 1716
  confirm = dy_confirmDualPivot(i, candk->ndx, abari, maxabari, p_abarj);
  }
#line 1717
  if ((int )confirm != 1) {
    {
#line 1718
    *p_xjndx = candk->ndx;
#line 1719
    *p_indir = candk->pivdir;
#line 1720
    free((void *)incands);
    }
#line 1721
    return (confirm);
  }
#line 1735
  swing = (bool )0;
#line 1736
  reqchk = (bool )0;
#line 1737
  if (bestcand > 1) {
#line 1737
    goto _L___0;
  } else
#line 1737
  if ((int )flipOnly == 1) {
    _L___0: /* CIL Label */ 
#line 1738
    if ((int )flipOnly == 1) {
#line 1738
      bestcand ++;
    }
    {
#line 1739
    tmp___4 = calloc((size_t )(m + 1), sizeof(double ));
#line 1739
    accumj = (double *)tmp___4;
#line 1740
    ndx = 1;
    }
    {
#line 1740
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1740
      if (! (ndx < bestcand)) {
#line 1740
        goto while_break___0;
      }
#line 1741
      candk = incands + ndx;
#line 1742
      j = candk->ndx;
#line 1743
      statj = *(dy_status + j);
#line 1744
      if ((int )candk->rev == 1) {
#line 1747
        if (dy_opts->print.pivoting >= 3) {
          {
#line 1748
          tmp___5 = dy_prtvstat(statj);
#line 1748
          tmp___6 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1748
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpassing reverse %s (%d) %s = %g.",
                      tmp___6, j, tmp___5, *(dy_x + j));
          }
        }
#line 1753
        goto __Cont;
      }
#line 1755
      if (dy_opts->print.pivoting >= 3) {
        {
#line 1756
        tmp___7 = dy_prtvstat(statj);
#line 1756
        tmp___8 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1756
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tflipping %s (%d) %s = %g to ", tmp___8,
                    j, tmp___7, *(dy_x + j));
        }
      }
#line 1760
      statj ^= (unsigned int )((1 << 6) | (1 << 7));
#line 1761
      if (statj & (unsigned int )(1 << 7)) {
#line 1761
        tmp___9 = 1;
      } else {
#line 1761
        tmp___9 = 0;
      }
#line 1761
      if (tmp___9) {
#line 1762
        xj = *(vlb + j);
      } else {
#line 1764
        xj = *(vub + j);
      }
#line 1765
      *(dy_status + j) = statj;
#line 1766
      *(dy_x + j) = xj;
#line 1768
      if (dy_opts->print.pivoting >= 3) {
        {
#line 1769
        tmp___10 = dy_prtvstat(*(dy_status + j));
#line 1769
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s = %g.", tmp___10, *(dy_x + j));
        }
      }
#line 1776
      deltaj = candk->flip.delta;
#line 1777
      if (*(dy_ddegenset + j) == 0) {
#line 1778
        dy_lp->z += *(dy_cbar + j) * deltaj;
      }
      {
#line 1779
      tmp___12 = consys_mulaccumcol(dy_sys, j, deltaj, accumj);
      }
#line 1779
      if ((int )tmp___12 == 0) {
        {
#line 1780
        tmp___11 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1780
        errmsg(122, rtnnme, dy_sys->nme, "column", tmp___11, j);
#line 1782
        retval = (dyret_enum )-10;
        }
#line 1783
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 1740
      ndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1784
    if ((int )retval == -10) {
#line 1785
      if ((unsigned long )accumj != (unsigned long )((void *)0)) {
        {
#line 1785
        free((void *)accumj);
        }
      }
      {
#line 1786
      free((void *)incands);
      }
#line 1787
      return (retval);
    }
#line 1788
    if ((int )flipOnly == 1) {
#line 1788
      bestcand --;
    }
    {
#line 1793
    dy_ftran(accumj, (bool )0);
#line 1794
    upd_retval = dy_updateprimals(candk->ndx, 1.0, accumj);
    }
    {
#line 1796
    if ((int )upd_retval == 1) {
#line 1796
      goto case_1___0;
    }
#line 1798
    if ((int )upd_retval == 9) {
#line 1798
      goto case_9;
    }
#line 1801
    if ((int )upd_retval == 4) {
#line 1801
      goto case_4;
    }
#line 1804
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
#line 1797
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 1799
    swing = (bool )1;
#line 1800
    goto switch_break___0;
    case_4: /* CIL Label */ 
#line 1802
    reqchk = (bool )1;
#line 1803
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1805
    retval = (dyret_enum )-10;
#line 1806
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1807
    free((void *)accumj);
    }
#line 1813
    if (*(dy_status + i) & (unsigned int )((1 << 10) | (1 << 11))) {
#line 1813
      tmp___15 = 0;
    } else {
#line 1813
      tmp___15 = 1;
    }
#line 1813
    if (tmp___15) {
#line 1814
      flipOnly = (bool )1;
#line 1816
      if (dy_opts->print.pivoting >= 1) {
        {
#line 1817
        tmp___13 = dy_prtvstat(*(dy_status + i));
#line 1817
        tmp___14 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 1817
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  whoa! %s (%d) = %g %s after flips; cancelling pivot.",
                    tmp___14, i, *(dy_x + i), tmp___13);
        }
      }
    }
#line 1823
    if ((int )retval == -10) {
      {
#line 1824
      free((void *)incands);
      }
#line 1825
      return (retval);
    }
  }
#line 1836
  if ((int )flipOnly == 0) {
#line 1837
    candk = incands + bestcand;
#line 1838
    *p_xjndx = candk->ndx;
#line 1839
    *p_indir = candk->pivdir;
#line 1840
    if ((int )candk->madpiv == 1) {
#line 1841
      retval = (dyret_enum )-1;
    } else
#line 1843
    if (candk->ddelta == (double )0) {
#line 1844
      retval = (dyret_enum )-2;
    } else {
#line 1846
      retval = (dyret_enum )1;
    }
  } else {
#line 1848
    retval = (dyret_enum )3;
  }
  {
#line 1850
  free((void *)incands);
  }
#line 1851
  return (retval);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 1817 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
void dy_initpivrej(int sze ) ;
#line 1817
void dy_freepivrej(void) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
static pivrej_struct *pivrejlst  =    (pivrej_struct *)((void *)0);
#line 101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
static pivrejctl_struct pivrej_ctl  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
void dy_initpivrej(int sze ) 
{ 
  void *tmp ;

  {
#line 111
  if (sze > 5) {
#line 111
    pivrej_ctl.sze = sze;
  } else {
#line 111
    pivrej_ctl.sze = 5;
  }
  {
#line 112
  tmp = malloc((unsigned long )pivrej_ctl.sze * sizeof(pivrej_struct ));
#line 112
  pivrejlst = (pivrej_struct *)tmp;
#line 114
  pivrej_ctl.cnt = 0;
#line 115
  pivrej_ctl.mad = 0;
#line 116
  pivrej_ctl.sing = 0;
#line 117
  pivrej_ctl.iter_reduced = -1;
#line 118
  pivrej_ctl.savedtol = dy_tols->pivot;
#line 119
  pivrej_ctl.pivmul = 1000.0;
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
void dy_freepivrej(void) 
{ 


  {
#line 132
  if ((unsigned long )pivrejlst != (unsigned long )((void *)0)) {
    {
#line 133
    free((void *)pivrejlst);
#line 134
    pivrejlst = (pivrej_struct *)((void *)0);
    }
  }
#line 136
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
void dy_checkpivtol(void) 
{ 


  {
#line 147
  if (pivrej_ctl.iter_reduced > 0) {
#line 147
    if (dy_lp->basis.pivs - pivrej_ctl.iter_reduced > dy_opts->factor) {
#line 149
      dy_tols->pivot = pivrej_ctl.savedtol;
#line 150
      pivrej_ctl.iter_reduced = -1;
    }
  }
#line 152
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
static int int_nonincreasing(void const   *p_i , void const   *p_j ) 
{ 
  int i ;
  int j ;

  {
#line 166
  i = (int )*((int const   *)p_i);
#line 167
  j = (int )*((int const   *)p_j);
#line 169
  return (j - i);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
bool dy_clrpivrej(int *entries ) 
{ 
  int n ;
  int j ;
  int ndx ;
  int last ;
  int endx ;
  int elast ;
  flags statj ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 194
  rtnnme = "dy_clrpivrej";
#line 217
  if ((unsigned long )entries == (unsigned long )((void *)0)) {
#line 218
    dy_tols->pivot = pivrej_ctl.savedtol;
#line 219
    pivrej_ctl.iter_reduced = -1;
  }
#line 220
  if (pivrej_ctl.cnt == 0) {
#line 220
    return ((bool )1);
  }
#line 223
  if (dy_opts->print.pivreject >= 1) {
#line 224
    if ((unsigned long )entries == (unsigned long )((void *)0)) {
#line 224
      tmp = "clearing";
    } else {
#line 224
      tmp = "winnowing";
    }
    {
#line 224
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s pivot reject list ... ", tmp);
    }
  }
#line 228
  n = dy_sys->varcnt;
#line 229
  last = pivrej_ctl.cnt - 1;
#line 234
  if ((unsigned long )entries == (unsigned long )((void *)0)) {
#line 236
    ndx = 0;
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;
#line 236
      if (! (ndx <= last)) {
#line 236
        goto while_break;
      }
#line 237
      j = (pivrejlst + ndx)->ndx;
#line 238
      statj = *(dy_status + j);
#line 251
      if (dy_opts->print.pivreject >= 2) {
        {
#line 252
        tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 252
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trestoring %s (%d) as eligible for pivoting.",
                    tmp___0, j);
        }
      }
#line 256
      *(dy_status + j) &= ~ (1U << (sizeof(flags ) * 8UL - 2UL));
#line 236
      ndx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 258
    last = -1;
#line 259
    pivrej_ctl.mad = 0;
#line 260
    pivrej_ctl.sing = 0;
  } else {
#line 267
    elast = *(entries + 0);
#line 268
    if (elast > 1) {
      {
#line 269
      qsort((void *)(entries + 1), (size_t )elast, sizeof(int ), & int_nonincreasing);
      }
    }
#line 270
    endx = 1;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! (endx <= elast)) {
#line 270
        goto while_break___0;
      }
#line 271
      ndx = *(entries + endx);
#line 278
      j = (pivrejlst + ndx)->ndx;
#line 279
      statj = *(dy_status + j);
#line 291
      *(dy_status + j) &= ~ (1U << (sizeof(flags ) * 8UL - 2UL));
#line 293
      if (dy_opts->print.pivreject >= 2) {
        {
#line 294
        tmp___1 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 294
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trestoring %s (%d) as eligible for pivoting.",
                    tmp___1, j);
        }
      }
#line 298
      if (ndx < last) {
#line 299
        *(pivrejlst + ndx) = *(pivrejlst + last);
        {
#line 301
        if ((int )(pivrejlst + ndx)->why == -6) {
#line 301
          goto case_neg_6;
        }
#line 304
        if ((int )(pivrejlst + ndx)->why == -1) {
#line 304
          goto case_neg_1;
        }
#line 307
        goto switch_default;
        case_neg_6: /* CIL Label */ 
#line 302
        (pivrej_ctl.sing) --;
#line 303
        goto switch_break;
        case_neg_1: /* CIL Label */ 
#line 305
        (pivrej_ctl.mad) --;
#line 306
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 308
        errmsg(1, rtnnme, 308);
        }
#line 309
        return ((bool )0);
        switch_break: /* CIL Label */ ;
        }
      }
#line 310
      last --;
#line 270
      endx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 312
  last ++;
#line 314
  if (dy_opts->print.pivreject >= 1) {
#line 315
    if (dy_opts->print.pivreject >= 2) {
      {
#line 316
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      ");
      }
    }
    {
#line 317
    dyio_outfmt(dy_logchn, dy_gtxecho, "restored %d variables.", pivrej_ctl.cnt - last);
    }
  }
#line 320
  pivrej_ctl.cnt = last;
#line 322
  return ((bool )1);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
dyret_enum dy_addtopivrej(int j , dyret_enum why , double abarij , double maxabarij ) 
{ 
  int n ;
  int ndx ;
  int newsze ;
  double ratio ;
  char const   *rtnnme ;
  int saveprint ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 348
  rtnnme = "dy_addtopivrej";
#line 353
  saveprint = dy_opts->print.pivoting;
#line 354
  dy_opts->print.pivoting = 0;
#line 362
  ratio = dy_chkpiv(abarij, maxabarij);
#line 363
  n = dy_sys->varcnt;
#line 366
  dy_opts->print.pivoting = saveprint;
  }
#line 381
  if (dy_opts->print.pivreject >= 2) {
    {
#line 382
    tmp = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 382
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  marking %s (%d) ineligible for pivoting ",
                tmp, j);
    }
    {
#line 386
    if ((int )why == -6) {
#line 386
      goto case_neg_6;
    }
#line 389
    if ((int )why == -1) {
#line 389
      goto case_neg_1;
    }
#line 392
    goto switch_default;
    case_neg_6: /* CIL Label */ 
    {
#line 387
    tmp___0 = dy_prtdyret(why);
#line 387
    dyio_outfmt(dy_logchn, dy_gtxecho, "(%s).", tmp___0);
    }
#line 388
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 390
    tmp___1 = dy_prtdyret(why);
#line 390
    dyio_outfmt(dy_logchn, dy_gtxecho, "(%s = %g).", tmp___1, ratio);
    }
#line 391
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 393
    errmsg(1, rtnnme, 393);
    }
#line 394
    return ((dyret_enum )-10);
    switch_break: /* CIL Label */ ;
    }
  }
#line 402
  *(dy_status + j) |= 1U << (sizeof(flags ) * 8UL - 2UL);
#line 403
  tmp___2 = pivrej_ctl.cnt;
#line 403
  (pivrej_ctl.cnt) ++;
#line 403
  ndx = tmp___2;
#line 404
  if (ndx >= pivrej_ctl.sze) {
#line 405
    if (2 * pivrej_ctl.sze > n + 1) {
#line 405
      newsze = n + 1;
    } else {
#line 405
      newsze = 2 * pivrej_ctl.sze;
    }
#line 407
    if (dy_opts->print.pivreject >= 3) {
      {
#line 408
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: expanding pivot reject list from %d to %d entries.",
                  rtnnme, pivrej_ctl.sze, newsze);
      }
    }
    {
#line 412
    tmp___3 = realloc((void *)pivrejlst, (unsigned long )newsze * sizeof(pivrej_struct ));
#line 412
    pivrejlst = (pivrej_struct *)tmp___3;
    }
#line 414
    if ((unsigned long )pivrejlst == (unsigned long )((void *)0)) {
      {
#line 415
      errmsg(337, rtnnme, dy_sys->nme, pivrej_ctl.sze, newsze);
      }
#line 416
      return ((dyret_enum )-10);
    }
#line 417
    pivrej_ctl.sze = newsze;
  }
#line 418
  (pivrejlst + ndx)->ndx = j;
#line 419
  (pivrejlst + ndx)->iter = dy_lp->basis.pivs;
#line 420
  (pivrejlst + ndx)->why = why;
  {
#line 422
  if ((int )why == -6) {
#line 422
    goto case_neg_6___0;
  }
#line 425
  if ((int )why == -1) {
#line 425
    goto case_neg_1___0;
  }
#line 430
  goto switch_default___0;
  case_neg_6___0: /* CIL Label */ 
#line 423
  (pivrej_ctl.sing) ++;
#line 424
  goto switch_break___0;
  case_neg_1___0: /* CIL Label */ 
  {
#line 426
  (pivrej_ctl.mad) ++;
#line 427
  ratio = dy_chkpiv(abarij, maxabarij);
#line 428
  (pivrejlst + ndx)->ratio = ratio * dy_tols->pivot;
  }
#line 429
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 431
  errmsg(1, rtnnme, 431);
  }
#line 432
  return ((dyret_enum )-10);
  switch_break___0: /* CIL Label */ ;
  }
#line 450
  return ((dyret_enum )1);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_pivreject.c"
dyret_enum dy_dealWithPunt(void) 
{ 
  int j ;
  int ndx ;
  int last ;
  int oldcnt ;
  int curcnt ;
  int curmad ;
  int brk ;
  double maxratio ;
  double pivmul ;
  bool clr_retval ;
  dyret_enum retval ;
  int *old ;
  int *current ;
  pivrej_struct *pivrej ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 488
  rtnnme = "dy_dealWithPunt";
#line 495
  retval = (dyret_enum )0;
#line 499
  if (pivrej_ctl.cnt == 0) {
#line 504
    return ((dyret_enum )6);
  }
  {
#line 508
  last = pivrej_ctl.cnt;
#line 509
  brk = dy_lp->basis.pivs;
#line 510
  tmp = malloc((unsigned long )(last + 1) * sizeof(int ));
#line 510
  old = (int *)tmp;
#line 511
  tmp___0 = malloc((unsigned long )(last + 1) * sizeof(int ));
#line 511
  current = (int *)tmp___0;
#line 512
  oldcnt = 0;
#line 513
  curcnt = 0;
#line 514
  curmad = 0;
#line 515
  maxratio = (double )0;
#line 517
  ndx = 0;
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! (ndx < last)) {
#line 517
      goto while_break;
    }
#line 518
    pivrej = pivrejlst + ndx;
#line 519
    if (pivrej->iter != brk) {
#line 520
      oldcnt ++;
#line 520
      *(old + oldcnt) = ndx;
    } else {
#line 522
      curcnt ++;
#line 522
      *(current + curcnt) = ndx;
#line 523
      if ((int )pivrej->why == -1) {
#line 524
        curmad ++;
#line 525
        if (maxratio < pivrej->ratio) {
#line 525
          maxratio = pivrej->ratio;
        }
      }
    }
#line 517
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  if (oldcnt > 0) {
    {
#line 531
    *(old + 0) = oldcnt;
#line 532
    clr_retval = dy_clrpivrej(old);
    }
#line 533
    if ((int )clr_retval == 1) {
#line 534
      retval = (dyret_enum )3;
    } else {
#line 536
      retval = (dyret_enum )-10;
    }
#line 538
    if (dy_opts->print.pivreject >= 1) {
      {
#line 539
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  restored %d entries queued before iter = %d.",
                  *(old + 0), brk);
      }
    }
  } else
#line 549
  if (curmad > 0) {
#line 549
    if (maxratio > dy_tols->zero) {
#line 550
      pivmul = (double )1 / dy_tols->pivot;
      {
#line 551
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 551
        if (! (maxratio * pivmul < 1.0)) {
#line 551
          goto while_break___0;
        }
#line 551
        pivmul *= pivrej_ctl.pivmul;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 552
      if ((double )1 / pivmul >= dy_tols->zero * (double )100) {
#line 555
        if (dy_opts->print.pivreject >= 1) {
          {
#line 556
          tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 556
          warn(376, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters, dy_tols->pivot,
               (double )1 / pivmul);
          }
        }
#line 560
        dy_tols->pivot = (double )1 / pivmul;
#line 567
        j = 0;
#line 568
        ndx = 1;
        {
#line 568
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 568
          if (! (ndx <= curcnt)) {
#line 568
            goto while_break___1;
          }
#line 569
          pivrej = pivrejlst + *(current + ndx);
#line 570
          if (pivrej->ratio * pivmul > 1.0) {
#line 571
            j ++;
#line 571
            *(current + j) = *(current + ndx);
          }
#line 568
          ndx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 572
        *(current + 0) = j;
#line 573
        clr_retval = dy_clrpivrej(current);
        }
#line 574
        if ((int )clr_retval == 1) {
#line 575
          retval = (dyret_enum )3;
        } else {
#line 577
          retval = (dyret_enum )-10;
        }
#line 579
        if (dy_opts->print.pivreject >= 1) {
          {
#line 580
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  restored %d entries queued at iter = %d at piv. tol = %g",
                      *(current + 0), brk, dy_tols->pivot);
          }
        }
      } else {
#line 588
        if (dy_opts->print.pivreject >= 1) {
          {
#line 589
          tmp___2 = dy_prtdyret((dyret_enum )6);
#line 589
          tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 589
          warn(383, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, dy_tols->zero,
               tmp___2);
          }
        }
#line 593
        retval = (dyret_enum )6;
      }
    } else {
#line 595
      retval = (dyret_enum )6;
    }
  } else {
#line 595
    retval = (dyret_enum )6;
  }
  {
#line 599
  free((void *)old);
#line 600
  free((void *)current);
  }
#line 603
  if ((int )retval == 6) {
#line 603
    if (dy_opts->print.pivreject >= 1) {
      {
#line 604
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  PUNT! mad = %d, singular = %d.", pivrej_ctl.mad,
                  pivrej_ctl.sing);
      }
    }
  }
#line 611
  return (retval);
}
}
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 178
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___1  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 250
double exvec_infnorm(double *vec , int len , int *p_jmax ) ;
#line 550 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
double consys_2normrow(consys_struct *consys , int rowndx ) ;
#line 1708 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
int *dy_brkout ;
#line 1750
dyret_enum dy_pivot(int xipos , double abarij , double maxabarj ) ;
#line 1753
void dy_btran(double *col ) ;
#line 1795
dyret_enum dy_primalin(int startcol , int scan , int *xjndx , int *nextcol ) ;
#line 1795
dyret_enum dy_primalpivot(int xjndx , int indir , int *p_xindx , int *p_outdir , double *p_abarij ,
                          double *p_delta , int *p_xjcand ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static degenstats_struct degenstats  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static int degen_cyclecnt  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
dyret_enum dy_degenout(int level___0 ) 
{ 
  int xkpos ;
  int xkndx ;
  double val ;
  double *vub ;
  double *vlb ;
  flags statk ;
  flags qualk ;
  dyret_enum retval ;
  char const   *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  char const   *tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;

  {
#line 183
  if (dy_opts->print.degen >= 1) {
    {
#line 184
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 184
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: antidegeneracy dropping to level %d after %d pivots.",
                tmp, dy_lp->tot.iters, level___0, dy_lp->tot.pivs - degenstats.iterin[dy_lp->degen]);
    }
  }
#line 207
  retval = (dyret_enum )1;
#line 208
  vub = dy_sys->vub;
#line 209
  vlb = dy_sys->vlb;
#line 216
  xkpos = 1;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (xkpos <= dy_sys->concnt)) {
#line 216
      goto while_break;
    }
#line 217
    xkndx = *(dy_basis + xkpos);
#line 218
    val = *(dy_x + xkndx);
#line 219
    if (*(dy_degenset + xkpos) > level___0) {
#line 220
      *(dy_degenset + xkpos) = level___0;
#line 221
      if (level___0 == 0) {
#line 221
        *(dy_status + xkndx) &= ~ (1U << (sizeof(flags ) * 8UL - 3UL));
      }
#line 222
      statk = *(dy_status + xkndx);
#line 223
      if (statk & (unsigned int )(1 << 4)) {
#line 223
        tmp___7 = 1;
      } else {
#line 223
        tmp___7 = 0;
      }
#line 223
      if (tmp___7) {
#line 224
        *(dy_xbasic + xkpos) = *(dy_x + xkndx);
      } else {
#line 226
        if (statk & 1U) {
#line 226
          tmp___6 = 1;
        } else {
#line 226
          tmp___6 = 0;
        }
#line 226
        if (tmp___6) {
#line 227
          *(dy_xbasic + xkpos) = *(vub + xkndx);
        } else {
          {
#line 229
          qualk = *(dy_status + xkndx) & (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
#line 230
          tmp___3 = fabs(*(vub + xkndx));
          }
#line 230
          if (tmp___3 < dy_tols->inf) {
            {
#line 230
            tmp___4 = fabs(val - *(vub + xkndx));
#line 230
            tmp___5 = fabs(*(vub + xkndx));
            }
#line 230
            if (tmp___4 < dy_tols->pfeas * (1.0 + tmp___5)) {
#line 231
              statk = (flags )(1 << 1);
#line 232
              val = *(vub + xkndx);
#line 233
              *(dy_x + xkndx) = val;
            } else {
#line 230
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 235
            tmp___0 = fabs(*(vlb + xkndx));
            }
#line 235
            if (tmp___0 < dy_tols->inf) {
              {
#line 235
              tmp___1 = fabs(val - *(vlb + xkndx));
#line 235
              tmp___2 = fabs(*(vlb + xkndx));
              }
#line 235
              if (tmp___1 < dy_tols->pfeas * (1.0 + tmp___2)) {
#line 236
                statk = (flags )(1 << 3);
#line 237
                val = *(vlb + xkndx);
#line 238
                *(dy_x + xkndx) = val;
              } else {
#line 235
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 240
              retval = (dyret_enum )4;
#line 241
              if (val < *(vlb + xkndx)) {
#line 242
                statk = (flags )(1 << 11);
              } else
#line 244
              if (val > *(vub + xkndx)) {
#line 245
                statk = (flags )(1 << 10);
              } else {
#line 247
                statk = (flags )(1 << 2);
              }
            }
          }
#line 275
          statk |= qualk;
#line 276
          *(dy_status + xkndx) = statk;
#line 277
          *(dy_xbasic + xkpos) = val;
        }
      }
#line 279
      if (dy_opts->print.degen >= 4) {
#line 279
        if (*(dy_status + xkndx) & (unsigned int )(((1 << 3) | 1) | (1 << 1))) {
#line 279
          tmp___17 = 0;
        } else {
#line 279
          tmp___17 = 1;
        }
#line 279
        if (tmp___17) {
#line 279
          goto _L___1;
        } else {
#line 279
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 279
      if (dy_opts->print.degen >= 5) {
        _L___1: /* CIL Label */ 
        {
#line 282
        tmp___8 = dy_prtvstat(*(dy_status + xkndx));
#line 282
        tmp___9 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 282
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) restored to %g, status %s",
                    tmp___9, xkndx, val, tmp___8);
        }
#line 286
        if (*(dy_status + xkndx) & (unsigned int )((((1 << 3) | 1) | (1 << 1)) | (1 << 4))) {
#line 286
          tmp___16 = 0;
        } else {
#line 286
          tmp___16 = 1;
        }
#line 286
        if (tmp___16) {
          {
#line 287
          tmp___14 = fabs(val - *(vlb + xkndx));
#line 287
          tmp___15 = fabs(val - *(vub + xkndx));
          }
#line 287
          if (tmp___14 < tmp___15) {
            {
#line 288
            tmp___10 = fabs(*(vlb + xkndx));
#line 288
            tmp___11 = fabs(val - *(vlb + xkndx));
#line 288
            dyio_outfmt(dy_logchn, dy_gtxecho, ", accum. error %g (tol. %g)", tmp___11,
                        dy_tols->zero * (1.0 + tmp___10));
            }
          } else {
            {
#line 292
            tmp___12 = fabs(*(vub + xkndx));
#line 292
            tmp___13 = fabs(val - *(vub + xkndx));
#line 292
            dyio_outfmt(dy_logchn, dy_gtxecho, ", accum. error %g (tol. %g)", tmp___13,
                        dy_tols->zero * (1.0 + tmp___12));
            }
          }
        }
      }
    } else
#line 298
    if (level___0 == 0) {
      {
#line 299
      tmp___21 = fabs(*(dy_xbasic + xkpos));
      }
#line 299
      if (tmp___21 < dy_tols->inf) {
        {
#line 299
        tmp___22 = fabs(val - *(dy_xbasic + xkpos));
#line 299
        tmp___23 = fabs(*(dy_xbasic + xkpos));
        }
#line 299
        if (! (tmp___22 < dy_tols->pfeas * (1.0 + tmp___23))) {
#line 299
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 300
        retval = (dyret_enum )4;
#line 302
        if (dy_opts->print.degen >= 4) {
          {
#line 303
          tmp___18 = fabs(*(dy_xbasic + xkpos));
#line 303
          tmp___19 = fabs(val - *(dy_xbasic + xkpos));
#line 303
          tmp___20 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 303
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) unperturbed, accum. error %g (tol. %g)",
                      tmp___20, xkndx, tmp___19, dy_tols->zero * (1.0 + tmp___18));
          }
        }
      }
#line 310
      *(dy_xbasic + xkpos) = val;
    }
#line 216
    xkpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  dy_lp->degen = level___0;
#line 314
  return (retval);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static void dy_degenin(void) 
{ 
  int xkpos ;
  int xkndx ;
  int oldlvl ;
  double base ;
  double perturb ;
  double xk ;
  double ubk ;
  double lbk ;
  double toobig ;
  flags xkstatus ;
  int degencnt ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;

  {
  {
#line 357
  degencnt = 0;
#line 368
  tmp = log10((double )dy_sys->concnt);
#line 368
  tmp___0 = ceil(tmp);
#line 368
  base = pow(10.0, ((double )-3 - tmp___0) - (double )degen_cyclecnt);
  }
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (base <= dy_tols->pfeas)) {
#line 369
      goto while_break;
    }
#line 369
    base *= (double )10;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  tmp___1 = dy_lp->degen;
#line 370
  (dy_lp->degen) ++;
#line 370
  oldlvl = tmp___1;
#line 373
  if (dy_opts->print.degen >= 1) {
    {
#line 374
    tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 374
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: antidegeneracy increasing to level %d",
                tmp___2, dy_lp->tot.iters, dy_lp->degen);
    }
#line 378
    if (degen_cyclecnt > 0) {
      {
#line 379
      dyio_outfmt(dy_logchn, dy_gtxecho, ", cycle %d", degen_cyclecnt);
      }
    }
#line 380
    if (dy_opts->print.degen >= 4) {
#line 380
      tmp___3 = ":";
    } else {
#line 380
      tmp___3 = ".";
    }
    {
#line 380
    dyio_outfmt(dy_logchn, dy_gtxecho, ", base perturbation %g%s", base, tmp___3);
    }
  }
#line 384
  if (dy_lp->degen < 25) {
#line 385
    degenstats.iterin[dy_lp->degen] = dy_lp->tot.pivs;
  }
#line 394
  xkpos = 1;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! (xkpos <= dy_sys->concnt)) {
#line 394
      goto while_break___0;
    }
#line 395
    if (*(dy_degenset + xkpos) != oldlvl) {
#line 395
      goto __Cont;
    }
#line 396
    xkndx = *(dy_basis + xkpos);
#line 397
    xkstatus = *(dy_status + xkndx);
#line 398
    if (xkstatus & (unsigned int )(((1 << 3) | 1) | (1 << 1))) {
#line 398
      tmp___4 = 0;
    } else {
#line 398
      tmp___4 = 1;
    }
#line 398
    if (tmp___4) {
#line 398
      goto __Cont;
    }
#line 399
    ubk = *(dy_sys->vub + xkndx);
#line 400
    lbk = *(dy_sys->vlb + xkndx);
#line 401
    xk = *(dy_xbasic + xkpos);
#line 402
    toobig = .001 * (ubk - lbk);
#line 403
    *(dy_degenset + xkpos) = dy_lp->degen;
    {
#line 405
    if (xkstatus == (flags )(1 << 3)) {
#line 405
      goto case_exp;
    }
#line 415
    if (xkstatus == (flags )(1 << 1)) {
#line 415
      goto case_exp___0;
    }
#line 425
    if (xkstatus == 1U) {
#line 425
      goto case_1;
    }
#line 404
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 406
    *(dy_brkout + xkpos) = 1;
#line 407
    tmp___5 = fabs(lbk);
#line 407
    perturb = (base * (double )xkpos) * ((double )1 + tmp___5);
#line 408
    xk += perturb;
    }
#line 409
    if (perturb < toobig) {
      {
#line 409
      tmp___6 = fabs(lbk);
      }
#line 409
      if (tmp___6 < dy_tols->inf) {
        {
#line 409
        tmp___7 = fabs(xk - lbk);
#line 409
        tmp___8 = fabs(lbk);
        }
#line 409
        if (tmp___7 < dy_tols->pfeas * (1.0 + tmp___8)) {
#line 413
          *(dy_status + xkndx) |= 1U << (sizeof(flags ) * 8UL - 3UL);
        } else {
#line 410
          *(dy_xbasic + xkpos) = xk;
#line 411
          *(dy_status + xkndx) = (flags )(1 << 2);
        }
      } else {
#line 410
        *(dy_xbasic + xkpos) = xk;
#line 411
        *(dy_status + xkndx) = (flags )(1 << 2);
      }
    } else {
#line 413
      *(dy_status + xkndx) |= 1U << (sizeof(flags ) * 8UL - 3UL);
    }
#line 414
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 416
    *(dy_brkout + xkpos) = -1;
#line 417
    tmp___9 = fabs(ubk);
#line 417
    perturb = (base * (double )xkpos) * ((double )1 + tmp___9);
#line 418
    xk -= perturb;
    }
#line 419
    if (perturb < toobig) {
      {
#line 419
      tmp___10 = fabs(ubk);
      }
#line 419
      if (tmp___10 < dy_tols->inf) {
        {
#line 419
        tmp___11 = fabs(xk - ubk);
#line 419
        tmp___12 = fabs(ubk);
        }
#line 419
        if (tmp___11 < dy_tols->pfeas * (1.0 + tmp___12)) {
#line 423
          *(dy_status + xkndx) |= 1U << (sizeof(flags ) * 8UL - 3UL);
        } else {
#line 420
          *(dy_xbasic + xkpos) = xk;
#line 421
          *(dy_status + xkndx) = (flags )(1 << 2);
        }
      } else {
#line 420
        *(dy_xbasic + xkpos) = xk;
#line 421
        *(dy_status + xkndx) = (flags )(1 << 2);
      }
    } else {
#line 423
      *(dy_status + xkndx) |= 1U << (sizeof(flags ) * 8UL - 3UL);
    }
#line 424
    goto switch_break;
    case_1: /* CIL Label */ 
#line 426
    *(dy_brkout + xkpos) = 0;
#line 427
    *(dy_status + xkndx) |= 1U << (sizeof(flags ) * 8UL - 3UL);
#line 428
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 433
    if (dy_opts->print.degen >= 5) {
#line 433
      goto _L;
    } else
#line 433
    if (dy_opts->print.degen >= 4) {
#line 433
      if (*(dy_status + xkndx) & (1U << (sizeof(flags ) * 8UL - 3UL))) {
#line 433
        tmp___18 = 1;
      } else {
#line 433
        tmp___18 = 0;
      }
#line 433
      if (tmp___18) {
#line 433
        if (*(dy_status + xkndx) & 1U) {
#line 433
          tmp___19 = 0;
        } else {
#line 433
          tmp___19 = 1;
        }
#line 433
        if (tmp___19) {
          _L: /* CIL Label */ 
          {
#line 437
          tmp___13 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 437
          tmp___14 = dy_prtvstat(*(dy_status + xkndx));
#line 437
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) in pos\'n %d ", tmp___14,
                      tmp___13, xkndx, xkpos);
          }
#line 440
          if (*(dy_status + xkndx) & (1U << (sizeof(flags ) * 8UL - 3UL))) {
#line 440
            tmp___17 = 1;
          } else {
#line 440
            tmp___17 = 0;
          }
#line 440
          if (tmp___17) {
            {
#line 441
            dyio_outfmt(dy_logchn, dy_gtxecho, "unperturbed.");
            }
          } else {
            {
#line 443
            tmp___15 = dy_prtvstat(xkstatus);
#line 443
            dyio_outfmt(dy_logchn, dy_gtxecho, "perturbed from %g (%s) to %g", *(dy_x + xkndx),
                        tmp___15, *(dy_xbasic + xkpos));
            }
#line 445
            if (*(dy_brkout + xkpos) == 1) {
#line 445
              tmp___16 = "up";
            } else {
#line 445
              tmp___16 = "down";
            }
            {
#line 445
            dyio_outfmt(dy_logchn, dy_gtxecho, ", breakout %s.", tmp___16);
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 394
    xkpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 456
  if (dy_opts->print.degen >= 1) {
#line 457
    if (dy_opts->print.degen <= 4) {
#line 457
      tmp___20 = ", ";
    } else {
#line 457
      tmp___20 = "\n\ttotal ";
    }
    {
#line 457
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s%d variables.", tmp___20, degencnt);
    }
  }
#line 470
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static bool pricexk(int k , int *p_j , double *p_ncbarj , bool *p_pivreject ) 
{ 
  int j ;
  double ncbarj ;
  double cbark ;
  double ncbark ;
  flags statk ;
  flags statj ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 520
  j = *p_j;
#line 521
  ncbarj = *p_ncbarj;
#line 522
  if (j != 0) {
#line 523
    statj = *(dy_status + j);
  } else {
#line 525
    statj = (flags )0;
  }
#line 527
  statk = *(dy_status + k);
#line 530
  if (dy_opts->print.pricing >= 3) {
    {
#line 531
    tmp = dy_prtvstat(statk);
#line 531
    tmp___0 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 531
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; ", tmp___0,
                k, tmp);
    }
  }
#line 540
  if (statk & (unsigned int )(1 << 9)) {
#line 540
    tmp___1 = 0;
  } else {
#line 540
    tmp___1 = 1;
  }
#line 540
  if (tmp___1) {
#line 540
    if (statj & (unsigned int )(1 << 9)) {
#line 540
      tmp___2 = 1;
    } else {
#line 540
      tmp___2 = 0;
    }
#line 540
    if (tmp___2) {
#line 543
      if (dy_opts->print.pricing >= 3) {
        {
#line 544
        dyio_outfmt(dy_logchn, dy_gtxecho, " << reject (vstatSB) >>");
        }
      }
#line 546
      return ((bool )0);
    }
  }
#line 553
  cbark = *(dy_cbar + k);
#line 554
  if (cbark < (double )0) {
#line 554
    if (statk & (unsigned int )(1 << 6)) {
#line 554
      tmp___3 = 1;
    } else {
#line 554
      tmp___3 = 0;
    }
#line 554
    if (tmp___3) {
#line 554
      goto _L;
    } else {
#line 554
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 554
  if (cbark > (double )0) {
#line 554
    if (statk & (unsigned int )(1 << 7)) {
#line 554
      tmp___4 = 1;
    } else {
#line 554
      tmp___4 = 0;
    }
#line 554
    if (tmp___4) {
      _L: /* CIL Label */ 
#line 558
      if (dy_opts->print.pricing >= 3) {
        {
#line 559
        dyio_outfmt(dy_logchn, dy_gtxecho, " << reject (incompatible status) >>");
        }
      }
#line 561
      return ((bool )0);
    }
  }
#line 562
  if (statk & (unsigned int )(1 << 9)) {
#line 562
    tmp___6 = 0;
  } else {
#line 562
    tmp___6 = 1;
  }
#line 562
  if (tmp___6) {
    {
#line 563
    tmp___5 = fabs(cbark - (double )0);
    }
#line 563
    if (tmp___5 <= dy_tols->dfeas) {
#line 566
      if (dy_opts->print.pricing >= 3) {
        {
#line 567
        dyio_outfmt(dy_logchn, dy_gtxecho, " << reject (zero) >>");
        }
      }
#line 569
      return ((bool )0);
    }
  }
  {
#line 570
  tmp___7 = fabs(cbark);
#line 570
  tmp___8 = sqrt(*(dy_gamma + k));
#line 570
  ncbark = tmp___7 / tmp___8;
#line 571
  tmp___9 = fabs(ncbark);
  }
#line 571
  if (tmp___9 < dy_tols->cost) {
#line 571
    ncbark = (double )0;
  }
#line 573
  if (dy_opts->print.pricing >= 3) {
    {
#line 574
    tmp___10 = sqrt(*(dy_gamma + k));
#line 574
    dyio_outfmt(dy_logchn, dy_gtxecho, "cbar<k> = %g, ||h<k>|| = %g, |cbar<k>|/||h<k>|| = %g.",
                cbark, tmp___10, ncbark);
    }
  }
#line 582
  if (statk & (1U << (sizeof(flags ) * 8UL - 2UL))) {
#line 582
    tmp___11 = 1;
  } else {
#line 582
    tmp___11 = 0;
  }
#line 582
  if (tmp___11) {
#line 583
    *p_pivreject = (bool )1;
#line 585
    if (dy_opts->print.pricing >= 3) {
      {
#line 586
      dyio_outfmt(dy_logchn, dy_gtxecho, " << reject (vstatNOPIVOT) >>");
      }
    }
#line 588
    return ((bool )0);
  }
#line 596
  if (statk & (unsigned int )(1 << 9)) {
#line 596
    tmp___15 = 1;
  } else {
#line 596
    tmp___15 = 0;
  }
#line 596
  if (tmp___15) {
#line 596
    if (statj & (unsigned int )(1 << 9)) {
#line 596
      tmp___16 = 0;
    } else {
#line 596
      tmp___16 = 1;
    }
#line 596
    if (tmp___16) {
#line 597
      j = k;
#line 599
      if (dy_opts->print.pricing >= 3) {
        {
#line 600
        dyio_outfmt(dy_logchn, dy_gtxecho, " << accept (vstatSB) >>");
        }
      }
    } else {
#line 596
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 604
  if (ncbark > ncbarj) {
#line 605
    j = k;
#line 607
    if (dy_opts->print.pricing >= 3) {
      {
#line 608
      dyio_outfmt(dy_logchn, dy_gtxecho, " << accept (ncbar) >>");
      }
    }
  } else {
    {
#line 612
    tmp___12 = fabs(ncbark - ncbarj);
    }
#line 612
    if (tmp___12 <= dy_tols->dfeas) {
#line 612
      if (statk & (unsigned int )(1 << 8)) {
#line 612
        tmp___13 = 1;
      } else {
#line 612
        tmp___13 = 0;
      }
#line 612
      if (tmp___13) {
#line 612
        if (statj & (unsigned int )(1 << 8)) {
#line 612
          tmp___14 = 0;
        } else {
#line 612
          tmp___14 = 1;
        }
#line 612
        if (tmp___14) {
#line 614
          j = k;
#line 616
          if (dy_opts->print.pricing >= 3) {
            {
#line 617
            dyio_outfmt(dy_logchn, dy_gtxecho, " << accept (vstatNBFR) >>");
            }
          }
        } else {
#line 612
          goto _L___2;
        }
      } else {
#line 612
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 623
    if (dy_opts->print.pricing >= 3) {
      {
#line 624
      dyio_outfmt(dy_logchn, dy_gtxecho, " << reject (inferior) >>");
      }
    }
  }
#line 628
  if (j != *p_j) {
#line 629
    *p_j = j;
#line 630
    *p_ncbarj = ncbark;
#line 631
    return ((bool )1);
  } else {
#line 633
    return ((bool )0);
  }
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
dyret_enum dy_primalin(int startcol , int scan , int *xjndx , int *nextcol ) 
{ 
  int xkndx ;
  int scanned ;
  int total_scanned ;
  int scan_blk ;
  int this_blk ;
  flags xkstatus ;
  bool pivreject ;
  double ncbarj ;
  dyret_enum retval ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
#line 687
  rtnnme = "dy_primalin";
#line 702
  *xjndx = 0;
#line 703
  ncbarj = - dy_tols->inf;
#line 704
  xkndx = startcol;
#line 705
  if (scan > dy_sys->varcnt) {
#line 705
    scan_blk = dy_sys->varcnt;
  } else {
#line 705
    scan_blk = scan;
  }
#line 706
  retval = (dyret_enum )0;
#line 708
  if (dy_opts->print.pricing >= 1) {
    {
#line 709
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: pricing %d columns from %d for %d candidate.",
                rtnnme, scan_blk, xkndx, 1);
    }
  }
#line 720
  pivreject = (bool )0;
#line 721
  total_scanned = 0;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (total_scanned < scan_blk)) {
#line 721
      if (total_scanned < dy_sys->varcnt) {
#line 721
        if (! (*xjndx == 0)) {
#line 721
          goto while_break;
        }
      } else {
#line 721
        goto while_break;
      }
    }
#line 725
    if (scan_blk > dy_sys->varcnt - total_scanned) {
#line 725
      this_blk = dy_sys->varcnt - total_scanned;
    } else {
#line 725
      this_blk = scan_blk;
    }
#line 726
    if (this_blk > (dy_sys->varcnt - xkndx) + 1) {
#line 726
      this_blk = (dy_sys->varcnt - xkndx) + 1;
    } else {
#line 726
      this_blk = this_blk;
    }
#line 727
    scanned = 0;
    {
#line 727
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 727
      if (! (scanned < this_blk)) {
#line 727
        goto while_break___0;
      }
#line 728
      xkstatus = *(dy_status + xkndx);
#line 738
      if (xkstatus & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 738
        tmp___1 = 1;
      } else {
#line 738
        tmp___1 = 0;
      }
#line 738
      if (tmp___1) {
#line 741
        if (dy_opts->print.pricing >= 3) {
          {
#line 742
          tmp = dy_prtvstat(xkstatus);
#line 742
          tmp___0 = consys_nme(dy_sys, (char )'v', xkndx, (bool )1, (char *)((void *)0));
#line 742
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; << status >>",
                      tmp___0, xkndx, tmp);
          }
        }
#line 747
        goto __Cont;
      }
      {
#line 751
      pricexk(xkndx, xjndx, & ncbarj, & pivreject);
      }
      __Cont: /* CIL Label */ 
#line 727
      scanned ++;
#line 727
      xkndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 757
    if (xkndx > dy_sys->varcnt) {
#line 757
      xkndx = 1;
    }
#line 721
    total_scanned += scanned;
  }
  while_break: /* CIL Label */ ;
  }
#line 782
  if (*xjndx == 0) {
#line 783
    if ((int )pivreject == 1) {
#line 784
      retval = (dyret_enum )6;
    } else {
#line 786
      retval = (dyret_enum )7;
    }
  } else {
#line 788
    retval = (dyret_enum )1;
  }
#line 791
  if (dy_opts->print.pricing >= 1) {
#line 792
    if (*xjndx == 0) {
#line 792
      tmp___2 = 0;
    } else {
#line 792
      tmp___2 = 1;
    }
#line 792
    if (xkndx - 1 < 1) {
#line 792
      tmp___3 = dy_sys->varcnt;
    } else {
#line 792
      tmp___3 = xkndx - 1;
    }
    {
#line 792
    tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 792
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: (%s)%d: scanned %d columns %d to %d, selected %d",
                rtnnme, tmp___4, dy_lp->tot.iters, total_scanned, startcol, tmp___3,
                tmp___2);
    }
#line 797
    if (dy_opts->print.pricing >= 2) {
#line 797
      if (*xjndx != 0) {
        {
#line 798
        dyio_outchr(dy_logchn, dy_gtxecho, (char )':');
#line 799
        tmp___5 = consys_nme(dy_sys, (char )'v', *xjndx, (bool )1, (char *)((void *)0));
#line 799
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) scaled reduced cost %g.",
                    tmp___5, *xjndx, ncbarj);
        }
      } else {
#line 797
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 802
    if ((int )retval == 6) {
      {
#line 803
      dyio_outfmt(dy_logchn, dy_gtxecho, ",\n\tall suitable x<j> on rejected pivot list.");
      }
    } else {
      {
#line 806
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
  }
#line 812
  *nextcol = xkndx;
#line 814
  return (retval);
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static double cdothyper(int xkndx , int dirk ) 
{ 
  double dotprod ;
  double tmp ;
  double tmp___0 ;

  {
#line 847
  if (xkndx <= dy_sys->concnt) {
    {
#line 848
    dotprod = consys_dotrow(dy_sys, xkndx, dy_sys->obj);
#line 849
    tmp = consys_2normrow(dy_sys, xkndx);
#line 849
    dotprod = ((double )dirk * dotprod) / tmp;
    }
  } else {
#line 855
    dotprod = (double )dirk * - *(dy_sys->obj + xkndx);
  }
  {
#line 857
  tmp___0 = fabs(dotprod);
  }
#line 857
  if (tmp___0 < dy_tols->zero) {
#line 857
    dotprod = (double )0;
  }
#line 859
  return (dotprod);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static double pdirdothyper(int xjndx , double *abarj , int dirj , int xkndx , int dirk ) 
{ 
  double dotprod ;
  double normak ;
  double abarkj ;
  double tmp ;

  {
#line 939
  abarkj = *(abarj + *(dy_var2basis + xkndx));
#line 944
  if (xkndx <= dy_sys->concnt) {
    {
#line 982
    normak = consys_2normrow(dy_sys, xkndx);
#line 983
    dotprod = ((double )(dirj * - dirk) * - abarkj) / (normak + (double )1);
    }
  } else {
#line 990
    dotprod = (double )(dirj * dirk) * - abarkj;
  }
  {
#line 992
  tmp = fabs(dotprod);
  }
#line 992
  if (tmp < dy_tols->zero) {
#line 992
    dotprod = (double )0;
  }
#line 993
  return (dotprod);
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static dyret_enum primalout(int xjndx , int indir , double *abarj , double maxabarj ,
                            int *xindx , int *outdir , double *deltaj ) 
{ 
  int xkpos ;
  int xkndx ;
  int outk ;
  int degencnt ;
  flags xkstatus ;
  double abarij ;
  double ratioij ;
  double aligni ;
  double deltak ;
  double abarkj ;
  double ratiokj ;
  double bndk ;
  double alignk ;
  bool newxi ;
  dyret_enum retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char const   *tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  double tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  double tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  double tmp___35 ;
  char const   *tmp___36 ;
  double tmp___37 ;
  char const   *tmp___38 ;
  double tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  double tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char *tmp___45 ;
  char const   *tmp___46 ;
  char const   *tmp___47 ;

  {
#line 1075
  rtnnme = "primalout";
#line 1077
  retval = (dyret_enum )0;
#line 1079
  if (dy_opts->print.pivoting >= 1) {
    {
#line 1080
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: selecting leaving variable, iteration %d",
                rtnnme, dy_lp->tot.iters + 1);
    }
#line 1083
    if (dy_opts->print.pivoting >= 3) {
#line 1084
      if (indir > 0) {
#line 1084
        tmp = "increasing";
      } else {
#line 1084
        tmp = "decreasing";
      }
      {
#line 1084
      tmp___0 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 1084
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tentering variable %s (%d) %s", tmp___0,
                  xjndx, tmp);
#line 1087
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tPos\'n\tVariable\tValue\tabar<k,j>\tbound\tdelta\tDisp");
      }
    }
  }
#line 1104
  *xindx = xjndx;
#line 1105
  *outdir = indir;
#line 1106
  abarij = 1.0;
#line 1107
  if (indir == -1) {
#line 1108
    *deltaj = *(dy_x + xjndx) - *(dy_sys->vlb + xjndx);
  } else {
#line 1110
    *deltaj = *(dy_sys->vub + xjndx) - *(dy_x + xjndx);
  }
#line 1126
  if (dy_opts->print.pivoting >= 3) {
#line 1126
    if (*deltaj < dy_tols->inf) {
#line 1127
      if (*outdir > 0) {
#line 1127
        tmp___1 = "ub";
      } else {
#line 1127
        tmp___1 = "lb";
      }
#line 1127
      if (indir > 0) {
#line 1127
        tmp___2 = *(dy_sys->vub + xjndx);
      } else {
#line 1127
        tmp___2 = *(dy_sys->vlb + xjndx);
      }
#line 1127
      if (indir > 0) {
#line 1127
        tmp___3 = *(dy_sys->vlb + xjndx);
      } else {
#line 1127
        tmp___3 = *(dy_sys->vub + xjndx);
      }
      {
#line 1127
      tmp___4 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 1127
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  n/a\t%-8s (%d)\t%7g\t%9g\t%7g\t%7g\tleaving at %s",
                  tmp___4, xjndx, tmp___3, 1.0, tmp___2, *deltaj, tmp___1);
      }
    }
  }
#line 1146
  newxi = (bool )0;
#line 1147
  ratioij = QNaNbits___1.fpdbl;
#line 1148
  aligni = QNaNbits___1.fpdbl;
#line 1149
  degencnt = 0;
#line 1150
  alignk = (double )0;
#line 1151
  bndk = QNaNbits___1.fpdbl;
#line 1152
  xkpos = 1;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (xkpos <= dy_sys->concnt) {
#line 1152
      if (! ((int )retval == 0)) {
#line 1152
        goto while_break;
      }
    } else {
#line 1152
      goto while_break;
    }
#line 1153
    if (dy_lp->degen > 0) {
#line 1153
      if (*(dy_degenset + xkpos) != dy_lp->degen) {
#line 1153
        goto __Cont;
      }
    }
    {
#line 1154
    abarkj = *(abarj + xkpos);
#line 1155
    tmp___5 = fabs(abarkj - (double )0);
    }
#line 1155
    if (tmp___5 <= dy_tols->zero) {
#line 1155
      goto __Cont;
    }
#line 1156
    xkndx = *(dy_basis + xkpos);
#line 1157
    xkstatus = *(dy_status + xkndx);
#line 1158
    if (xkstatus & (unsigned int )(1 << 4)) {
#line 1158
      tmp___6 = 1;
    } else {
#line 1158
      tmp___6 = 0;
    }
#line 1158
    if (tmp___6) {
#line 1158
      goto __Cont;
    }
#line 1159
    if (indir < 0) {
#line 1159
      abarkj = - abarkj;
    }
#line 1161
    if (dy_opts->print.pivoting >= 3) {
#line 1162
      if (indir < 0) {
#line 1162
        tmp___7 = - abarkj;
      } else {
#line 1162
        tmp___7 = abarkj;
      }
      {
#line 1162
      tmp___8 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1162
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%5d\t%-8s (%d)\t%g\t%g\t", xkpos, tmp___8,
                  xkndx, *(dy_xbasic + xkpos), tmp___7);
      }
    }
#line 1175
    if (abarkj > 0.0) {
#line 1176
      if (xkstatus & (unsigned int )(1 << 11)) {
#line 1176
        tmp___9 = 1;
      } else {
#line 1176
        tmp___9 = 0;
      }
#line 1176
      if (tmp___9) {
#line 1176
        goto __Cont;
      }
#line 1177
      outk = -1;
#line 1178
      if (xkstatus & (unsigned int )(1 | (1 << 3))) {
#line 1178
        tmp___11 = 1;
      } else {
#line 1178
        tmp___11 = 0;
      }
#line 1178
      if (tmp___11) {
#line 1179
        deltak = 0.0;
#line 1181
        bndk = *(dy_sys->vlb + xkndx);
      } else {
#line 1185
        bndk = *(dy_sys->vlb + xkndx);
#line 1186
        if (bndk <= - dy_tols->inf) {
#line 1187
          if ((unsigned int )dy_lp->phase == 2U) {
#line 1187
            if (xkstatus & (unsigned int )(1 << 10)) {
#line 1187
              tmp___10 = 1;
            } else {
#line 1187
              tmp___10 = 0;
            }
#line 1187
            if (tmp___10) {
#line 1188
              bndk = *(dy_sys->vub + xkndx);
            } else {
#line 1190
              goto __Cont;
            }
          } else {
#line 1190
            goto __Cont;
          }
        }
#line 1191
        deltak = *(dy_xbasic + xkpos) - bndk;
      }
    } else {
#line 1193
      if (xkstatus & (unsigned int )(1 << 10)) {
#line 1193
        tmp___12 = 1;
      } else {
#line 1193
        tmp___12 = 0;
      }
#line 1193
      if (tmp___12) {
#line 1193
        goto __Cont;
      }
#line 1194
      outk = 1;
#line 1195
      if (xkstatus & (unsigned int )(1 | (1 << 1))) {
#line 1195
        tmp___14 = 1;
      } else {
#line 1195
        tmp___14 = 0;
      }
#line 1195
      if (tmp___14) {
#line 1196
        deltak = 0.0;
#line 1198
        bndk = *(dy_sys->vlb + xkndx);
      } else {
#line 1202
        bndk = *(dy_sys->vub + xkndx);
#line 1203
        if (bndk >= dy_tols->inf) {
#line 1204
          if ((unsigned int )dy_lp->phase == 2U) {
#line 1204
            if (xkstatus & (unsigned int )(1 << 11)) {
#line 1204
              tmp___13 = 1;
            } else {
#line 1204
              tmp___13 = 0;
            }
#line 1204
            if (tmp___13) {
#line 1205
              bndk = *(dy_sys->vlb + xkndx);
            } else {
#line 1207
              goto __Cont;
            }
          } else {
#line 1207
            goto __Cont;
          }
        }
#line 1208
        deltak = bndk - *(dy_xbasic + xkpos);
      }
    }
    {
#line 1217
    tmp___15 = fabs(deltak);
    }
#line 1217
    if (tmp___15 < dy_tols->zero) {
#line 1217
      deltak = (double )0;
    }
#line 1218
    if (deltak < 0.0) {
      {
#line 1219
      tmp___20 = fabs(bndk);
      }
#line 1219
      if (deltak < - dy_tols->pfeas * ((double )1 + tmp___20)) {
#line 1222
        if (dy_opts->print.phase2 >= 1) {
          {
#line 1223
          tmp___16 = fabs(bndk);
#line 1223
          tmp___17 = dy_prtvstat(xkstatus);
#line 1223
          tmp___18 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1223
          tmp___19 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1223
          warn(323, rtnnme, dy_sys->nme, tmp___19, dy_lp->tot.iters + 1, tmp___18,
               xkndx, tmp___17, *(dy_sys->vlb + xkndx), *(dy_xbasic + xkpos), *(dy_sys->vub + xkndx),
               - deltak, dy_tols->pfeas * ((double )1 + tmp___16));
          }
        } else
#line 1222
        if (dy_opts->print.phase1 >= 1) {
          {
#line 1223
          tmp___16 = fabs(bndk);
#line 1223
          tmp___17 = dy_prtvstat(xkstatus);
#line 1223
          tmp___18 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1223
          tmp___19 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1223
          warn(323, rtnnme, dy_sys->nme, tmp___19, dy_lp->tot.iters + 1, tmp___18,
               xkndx, tmp___17, *(dy_sys->vlb + xkndx), *(dy_xbasic + xkpos), *(dy_sys->vub + xkndx),
               - deltak, dy_tols->pfeas * ((double )1 + tmp___16));
          }
        }
#line 1229
        retval = (dyret_enum )-4;
#line 1230
        *xindx = xkndx;
#line 1231
        *outdir = outk;
#line 1232
        *deltaj = deltak;
#line 1233
        goto __Cont;
      }
#line 1234
      deltak = 0.0;
    }
    {
#line 1240
    deltak = fabs(deltak / abarkj);
#line 1241
    tmp___21 = fabs(deltak);
    }
#line 1241
    if (tmp___21 < dy_tols->zero) {
#line 1241
      deltak = (double )0;
    }
#line 1243
    if (dy_opts->print.pivoting >= 3) {
      {
#line 1244
      dyio_outfmt(dy_logchn, dy_gtxecho, "%g\t%g\t", bndk, deltak);
      }
    }
#line 1250
    ratiokj = QNaNbits___1.fpdbl;
#line 1251
    if (deltak < *deltaj) {
      {
#line 1252
      newxi = (bool )1;
#line 1253
      ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 1254
      degencnt = 0;
      }
    } else
#line 1273
    if (deltak == *deltaj) {
#line 1273
      if (*xindx != xjndx) {
        {
#line 1274
        ratiokj = dy_chkpiv(abarkj, maxabarj);
        }
#line 1275
        if (ratiokj >= 1.0) {
#line 1276
          if (xkstatus & 1U) {
#line 1276
            tmp___27 = 1;
          } else {
#line 1276
            tmp___27 = 0;
          }
#line 1276
          if (tmp___27) {
#line 1277
            if (*(dy_status + *xindx) & 1U) {
#line 1277
              tmp___22 = 1;
            } else {
#line 1277
              tmp___22 = 0;
            }
#line 1277
            if (tmp___22) {
              {
#line 1277
              tmp___23 = fabs(abarij);
#line 1277
              tmp___24 = fabs(abarkj);
              }
#line 1277
              if (! (tmp___23 >= tmp___24)) {
#line 1279
                newxi = (bool )1;
              }
            } else {
#line 1279
              newxi = (bool )1;
            }
          } else {
            {
#line 1282
            if (dy_opts->degenlite == 0) {
#line 1282
              goto case_0;
            }
#line 1285
            if (dy_opts->degenlite == 1) {
#line 1285
              goto case_1;
            }
#line 1290
            if (dy_opts->degenlite == 3) {
#line 1290
              goto case_3;
            }
#line 1290
            if (dy_opts->degenlite == 2) {
#line 1290
              goto case_3;
            }
#line 1312
            if (dy_opts->degenlite == 5) {
#line 1312
              goto case_5;
            }
#line 1312
            if (dy_opts->degenlite == 4) {
#line 1312
              goto case_5;
            }
#line 1281
            goto switch_break;
            case_0: /* CIL Label */ 
#line 1283
            if (ratiokj > ratioij) {
#line 1283
              newxi = (bool )1;
            }
#line 1284
            goto switch_break;
            case_1: /* CIL Label */ 
#line 1286
            if (ratiokj > ratioij) {
#line 1286
              newxi = (bool )1;
            }
#line 1287
            degencnt ++;
#line 1288
            goto switch_break;
            case_3: /* CIL Label */ 
            case_2: /* CIL Label */ 
#line 1291
            if (dy_opts->degenlite == 2) {
#line 1292
              if (degencnt == 0) {
                {
#line 1292
                aligni = cdothyper(*xindx, *outdir);
                }
              }
              {
#line 1293
              alignk = cdothyper(xkndx, outk);
              }
            } else {
#line 1295
              if (degencnt == 0) {
                {
#line 1296
                aligni = pdirdothyper(xjndx, abarj, indir, *xindx, *outdir);
                }
              }
              {
#line 1297
              alignk = pdirdothyper(xjndx, abarj, indir, xkndx, outk);
              }
            }
#line 1298
            degencnt ++;
#line 1299
            if (aligni > (double )0) {
#line 1299
              if (! (alignk <= (double )0)) {
#line 1299
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 1302
            if (aligni <= (double )0) {
#line 1302
              if (alignk > (double )0) {
#line 1303
                newxi = (bool )1;
              } else {
#line 1302
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 1305
              tmp___25 = fabs(aligni);
#line 1305
              tmp___26 = fabs(alignk);
              }
#line 1305
              if (tmp___25 > tmp___26) {
#line 1306
                newxi = (bool )1;
              } else
#line 1308
              if (aligni == alignk) {
#line 1309
                if (ratiokj > ratioij) {
#line 1309
                  newxi = (bool )1;
                }
              }
            }
#line 1310
            goto switch_break;
            case_5: /* CIL Label */ 
            case_4: /* CIL Label */ 
#line 1313
            if (dy_opts->degenlite == 4) {
#line 1314
              if (degencnt == 0) {
                {
#line 1314
                aligni = cdothyper(*xindx, *outdir);
                }
              }
              {
#line 1315
              alignk = cdothyper(xkndx, outk);
              }
            } else {
#line 1317
              if (degencnt == 0) {
                {
#line 1318
                aligni = pdirdothyper(xjndx, abarj, indir, *xindx, *outdir);
                }
              }
              {
#line 1319
              alignk = pdirdothyper(xjndx, abarj, indir, xkndx, outk);
              }
            }
#line 1320
            degencnt ++;
#line 1321
            if (alignk > aligni) {
#line 1321
              newxi = (bool )1;
            }
#line 1322
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
#line 1329
    if ((int )newxi == 1) {
#line 1330
      *deltaj = deltak;
#line 1331
      *xindx = xkndx;
#line 1332
      *outdir = outk;
#line 1333
      abarij = (double )indir * abarkj;
#line 1334
      ratioij = ratiokj;
#line 1335
      aligni = alignk;
#line 1336
      newxi = (bool )0;
#line 1338
      if (dy_opts->print.pivoting >= 3) {
#line 1339
        if (*xindx == xkndx) {
#line 1340
          if (bndk == *(dy_sys->vub + xkndx)) {
#line 1340
            tmp___28 = "ub";
          } else {
#line 1340
            tmp___28 = "lb";
          }
          {
#line 1340
          dyio_outfmt(dy_logchn, dy_gtxecho, "\tleaving at %s", tmp___28);
          }
        }
      }
#line 1343
      if (dy_opts->degenlite == 0) {
#line 1343
        if (deltak == (double )0) {
#line 1343
          if (ratioij >= 1.0) {
#line 1343
            goto while_break;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1152
    xkpos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1364
  if ((int )retval == 0) {
#line 1364
    goto case_0___0;
  }
#line 1398
  if ((int )retval == -4) {
#line 1398
    goto case_neg_4;
  }
#line 1400
  goto switch_default;
  case_0___0: /* CIL Label */ 
#line 1365
  if (*deltaj < dy_tols->inf) {
#line 1366
    if (*xindx != xjndx) {
#line 1367
      if (ratioij >= 1.0) {
#line 1368
        if (dy_lp->basis.etas > 1) {
          {
#line 1368
          tmp___32 = fabs(abarij - (double )0);
          }
#line 1368
          if (tmp___32 <= dy_tols->bogus * dy_tols->zero) {
            {
#line 1370
            retval = (dyret_enum )4;
#line 1372
            tmp___29 = fabs(abarij);
#line 1372
            tmp___30 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1372
            warn(381, rtnnme, dy_sys->nme, tmp___30, dy_lp->tot.iters + 1, "abar",
                 *xindx, xjndx, abarij, dy_tols->bogus * dy_tols->zero, dy_tols->bogus * dy_tols->zero - tmp___29);
            }
          } else {
#line 1368
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1379
        if (*deltaj == (double )0) {
#line 1379
          if (degencnt > 0) {
#line 1379
            if (*(dy_status + *xindx) & (unsigned int )(((1 << 1) | (1 << 3)) | 1)) {
#line 1379
              tmp___31 = 1;
            } else {
#line 1379
              tmp___31 = 0;
            }
#line 1379
            if (tmp___31) {
#line 1381
              retval = (dyret_enum )-2;
            } else {
#line 1383
              retval = (dyret_enum )1;
            }
          } else {
#line 1383
            retval = (dyret_enum )1;
          }
        } else {
#line 1383
          retval = (dyret_enum )1;
        }
      } else {
#line 1385
        retval = (dyret_enum )-1;
      }
    } else {
#line 1387
      retval = (dyret_enum )1;
    }
  } else {
#line 1389
    *xindx = -1;
#line 1391
    if (dy_lp->degen == 0) {
#line 1391
      if (dy_opts->print.phase1 >= 2) {
        {
#line 1393
        tmp___33 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1393
        warn(324, rtnnme, dy_sys->nme, tmp___33, dy_lp->tot.iters + 1);
        }
      } else
#line 1391
      if (dy_opts->print.phase2 >= 2) {
        {
#line 1393
        tmp___33 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1393
        warn(324, rtnnme, dy_sys->nme, tmp___33, dy_lp->tot.iters + 1);
        }
      }
    }
#line 1396
    retval = (dyret_enum )8;
  }
#line 1397
  goto switch_break___0;
  case_neg_4: /* CIL Label */ 
#line 1399
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 1401
  errmsg(1, rtnnme, 1401);
  }
#line 1402
  return ((dyret_enum )-10);
  switch_break___0: /* CIL Label */ ;
  }
#line 1407
  if (dy_opts->print.pivoting == 1) {
    {
#line 1408
    dyio_outfmt(dy_logchn, dy_gtxecho, "...");
    }
  }
#line 1409
  if ((int )retval == 1) {
#line 1409
    goto _L___2;
  } else
#line 1409
  if ((int )retval == -2) {
    _L___2: /* CIL Label */ 
#line 1409
    if (dy_opts->print.pivoting >= 1) {
#line 1410
      if (xjndx != *xindx) {
        {
#line 1411
        xkpos = *(dy_var2basis + *xindx);
#line 1412
        tmp___34 = consys_nme(dy_sys, (char )'v', *xindx, (bool )0, (char *)((void *)0));
#line 1412
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    selected %s (%d) = %g to leave pos\'n %d at",
                    tmp___34, *xindx, *(dy_xbasic + xkpos), xkpos);
        }
#line 1416
        if (*outdir > 0) {
#line 1417
          if (*(dy_status + *xindx) != (flags )(1 << 11)) {
#line 1417
            tmp___35 = *(dy_sys->vub + *xindx);
          } else {
#line 1417
            tmp___35 = *(dy_sys->vlb + *xindx);
          }
#line 1417
          if (*(dy_status + *xindx) != (flags )(1 << 11)) {
#line 1417
            tmp___36 = "ub";
          } else {
#line 1417
            tmp___36 = "lb";
          }
          {
#line 1417
          dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", tmp___36, tmp___35);
          }
        } else {
#line 1422
          if (*(dy_status + *xindx) != (flags )(1 << 10)) {
#line 1422
            tmp___37 = *(dy_sys->vlb + *xindx);
          } else {
#line 1422
            tmp___37 = *(dy_sys->vub + *xindx);
          }
#line 1422
          if (*(dy_status + *xindx) != (flags )(1 << 10)) {
#line 1422
            tmp___38 = "lb";
          } else {
#line 1422
            tmp___38 = "ub";
          }
          {
#line 1422
          dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", tmp___38, tmp___37);
          }
        }
        {
#line 1426
        dyio_outfmt(dy_logchn, dy_gtxecho, "abar<%d,%d> = %g, ", xjndx, *xindx, abarij);
        }
      } else {
#line 1429
        if (*outdir > 0) {
#line 1429
          tmp___39 = *(dy_sys->vub + *xindx);
        } else {
#line 1429
          tmp___39 = *(dy_sys->vlb + *xindx);
        }
#line 1429
        if (*outdir > 0) {
#line 1429
          tmp___40 = "ub";
        } else {
#line 1429
          tmp___40 = "lb";
        }
        {
#line 1429
        tmp___41 = consys_nme(dy_sys, (char )'v', *xindx, (bool )0, (char *)((void *)0));
#line 1429
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    selected %s (%d) = %g to change to %s = %g, ",
                    tmp___41, *xindx, *(dy_x + *xindx), tmp___40, tmp___39);
        }
      }
#line 1434
      if ((int )retval == 1) {
        {
#line 1435
        dyio_outfmt(dy_logchn, dy_gtxecho, "delta = %g.", *deltaj);
        }
      } else {
        {
#line 1437
        dyio_outfmt(dy_logchn, dy_gtxecho, "degenerate.");
        }
      }
    }
  }
#line 1438
  if ((int )retval == -2) {
#line 1438
    if (dy_opts->print.phase1 >= 3) {
#line 1438
      goto _L___3;
    } else
#line 1438
    if (dy_opts->print.phase2 >= 3) {
      _L___3: /* CIL Label */ 
#line 1440
      xkpos = *(dy_var2basis + *xindx);
#line 1441
      xkstatus = *(dy_status + *xindx);
#line 1442
      if (*outdir > 0) {
#line 1442
        tmp___42 = *(dy_sys->vub + *xindx);
      } else {
#line 1442
        tmp___42 = *(dy_sys->vlb + *xindx);
      }
#line 1442
      if (*outdir > 0) {
#line 1442
        tmp___43 = "ub";
      } else {
#line 1442
        tmp___43 = "lb";
      }
      {
#line 1442
      tmp___44 = consys_nme(dy_sys, (char )'v', *xindx, (bool )0, (char *)((void *)0));
#line 1442
      tmp___45 = dy_prtvstat(xkstatus);
#line 1442
      tmp___46 = dy_prtdyret(retval);
#line 1442
      tmp___47 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1442
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n   (%s)%d %s pos\'n %d, %s %s (%d) = %g = %s = %g",
                  tmp___47, dy_lp->tot.iters, tmp___46, xkpos, tmp___45, tmp___44,
                  *xindx, *(dy_xbasic + xkpos), tmp___43, tmp___42);
      }
#line 1449
      if (dy_opts->degenlite >= 2) {
#line 1449
        if (dy_opts->degenlite <= 5) {
#line 1450
          if (degencnt > 0) {
            {
#line 1451
            dyio_outfmt(dy_logchn, dy_gtxecho, ", align = %g, deg = %d.", aligni,
                        degencnt);
            }
          }
        } else {
          {
#line 1454
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
          }
        }
      } else {
        {
#line 1454
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
  }
#line 1457
  return (retval);
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static dyret_enum primalupdate(int xjndx , int indir , int xindx , int outdir , double *abarj ,
                               double delta , double *betai ) 
{ 
  int xkpos ;
  int xkndx ;
  int xipos ;
  flags xkstatus ;
  flags quals ;
  dyret_enum retval ;
  double val ;
  double deltak ;
  double ubk ;
  double lbk ;
  double eps0 ;
  double epsu ;
  double epsl ;
  double cbarj ;
  double abarij ;
  bool dirtyz ;
  bool swing ;
  double swingratio ;
  double maxswing ;
  int swingndx ;
  char const   *rtnnme ;
  int print ;
  double tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___5 ;
  int tmp___6 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  double tmp___11 ;
  int tmp___12 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  char const   *tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___31 ;
  int tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  double tmp___35 ;
  double tmp___36 ;
  double tmp___38 ;
  int tmp___39 ;
  double tmp___40 ;
  double tmp___42 ;
  int tmp___43 ;
  double tmp___44 ;
  double tmp___45 ;
  double tmp___46 ;
  double tmp___47 ;
  double tmp___49 ;
  int tmp___50 ;
  double tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  double tmp___54 ;
  double tmp___55 ;
  int tmp___56 ;
  double tmp___57 ;
  double tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  char const   *tmp___63 ;
  int tmp___64 ;
  char const   *tmp___65 ;
  char *tmp___66 ;
  char const   *tmp___67 ;
  int tmp___68 ;
  double tmp___69 ;
  double tmp___70 ;
  double tmp___71 ;
  double tmp___72 ;
  double tmp___73 ;
  double tmp___74 ;
  double tmp___75 ;
  double tmp___76 ;
  double tmp___77 ;
  double tmp___78 ;
  double tmp___79 ;
  double tmp___80 ;
  char const   *tmp___81 ;
  double tmp___82 ;
  double tmp___83 ;
  char const   *tmp___84 ;
  bool first ;
  bool all ;
  char const   *tmp___85 ;
  char *tmp___86 ;
  char const   *tmp___87 ;
  char const   *tmp___88 ;

  {
#line 1516
  rtnnme = "primalupdate";
#line 1522
  retval = (dyret_enum )1;
#line 1523
  dirtyz = (bool )0;
#line 1524
  swing = (bool )0;
#line 1525
  maxswing = (double )0;
#line 1526
  swingndx = -1;
#line 1527
  xipos = *(dy_var2basis + xindx);
#line 1528
  abarij = *(abarj + xipos);
#line 1529
  cbarj = *(dy_cbar + xjndx);
#line 1532
  if ((unsigned int )dy_lp->phase == 2U) {
#line 1533
    print = dy_opts->print.phase1;
  } else {
#line 1535
    print = dy_opts->print.phase2;
  }
#line 1537
  if (print >= 5) {
    {
#line 1538
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: updating at iteration %d:", rtnnme,
                dy_lp->tot.iters + 1);
    }
#line 1540
    if (indir == 1) {
#line 1540
      tmp = delta;
    } else {
#line 1540
      tmp = - delta;
    }
#line 1540
    if (*(dy_status + xjndx) == (flags )(1 << 9)) {
#line 1540
      tmp___1 = "";
    } else {
#line 1540
      if (indir == 1) {
#line 1540
        tmp___0 = "lb ";
      } else {
#line 1540
        tmp___0 = "ub ";
      }
#line 1540
      tmp___1 = tmp___0;
    }
    {
#line 1540
    tmp___2 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 1540
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) entering pos\'n %d from %s%g, delta %g, cbarj %g.",
                tmp___2, xjndx, xipos, tmp___1, *(dy_x + xjndx), tmp, *(dy_cbar + xjndx));
#line 1545
    tmp___3 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1545
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g leaving at ", tmp___3, xindx,
                *(dy_xbasic + xipos));
    }
#line 1548
    if (outdir == 1) {
#line 1549
      if (*(dy_status + xindx) & (unsigned int )(1 << 11)) {
#line 1549
        tmp___6 = 1;
      } else {
#line 1549
        tmp___6 = 0;
      }
#line 1549
      if (tmp___6) {
#line 1549
        tmp___5 = *(dy_sys->vlb + xindx);
      } else {
#line 1549
        tmp___5 = *(dy_sys->vub + xindx);
      }
#line 1549
      if (*(dy_status + xindx) & (unsigned int )(1 << 11)) {
#line 1549
        tmp___9 = 1;
      } else {
#line 1549
        tmp___9 = 0;
      }
#line 1549
      if (tmp___9) {
#line 1549
        tmp___8 = "lb";
      } else {
#line 1549
        tmp___8 = "ub";
      }
      {
#line 1549
      dyio_outfmt(dy_logchn, dy_gtxecho, "%s %g, pivot %g.", tmp___8, tmp___5, abarij);
      }
    } else {
#line 1554
      if (*(dy_status + xindx) & (unsigned int )(1 << 10)) {
#line 1554
        tmp___12 = 1;
      } else {
#line 1554
        tmp___12 = 0;
      }
#line 1554
      if (tmp___12) {
#line 1554
        tmp___11 = *(dy_sys->vub + xindx);
      } else {
#line 1554
        tmp___11 = *(dy_sys->vlb + xindx);
      }
#line 1554
      if (*(dy_status + xindx) & (unsigned int )(1 << 10)) {
#line 1554
        tmp___15 = 1;
      } else {
#line 1554
        tmp___15 = 0;
      }
#line 1554
      if (tmp___15) {
#line 1554
        tmp___14 = "ub";
      } else {
#line 1554
        tmp___14 = "lb";
      }
      {
#line 1554
      dyio_outfmt(dy_logchn, dy_gtxecho, "%s %g, pivot %g.", tmp___14, tmp___11, abarij);
      }
    }
  }
#line 1583
  if (delta > 0.0) {
#line 1584
    if (indir == -1) {
#line 1584
      delta = - delta;
    }
#line 1585
    if (dy_lp->degen == 0) {
      {
#line 1586
      dy_lp->z += cbarj * delta;
#line 1587
      tmp___16 = fabs(dy_lp->z);
      }
#line 1587
      if (tmp___16 < dy_tols->zero) {
#line 1587
        dy_lp->z = (double )0;
      }
    }
#line 1588
    xkpos = 1;
    {
#line 1588
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1588
      if (! (xkpos <= dy_sys->concnt)) {
#line 1588
        goto while_break;
      }
#line 1589
      if (*(abarj + xkpos) != (double )0) {
#line 1589
        if (*(dy_degenset + xkpos) == dy_lp->degen) {
          {
#line 1590
          deltak = *(abarj + xkpos) * delta;
#line 1591
          tmp___17 = fabs(deltak - (double )0);
          }
#line 1591
          if (tmp___17 <= dy_tols->zero) {
#line 1591
            goto __Cont;
          }
#line 1592
          xkndx = *(dy_basis + xkpos);
#line 1593
          xkstatus = *(dy_status + xkndx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 1594
          quals = *(dy_status + xkndx) & (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
#line 1595
          eps0 = dy_tols->zero;
#line 1596
          ubk = *(dy_sys->vub + xkndx);
#line 1597
          if (ubk < dy_tols->inf) {
            {
#line 1598
            tmp___18 = fabs(ubk);
#line 1598
            epsu = dy_tols->pfeas * (1.0 + tmp___18);
            }
          } else {
#line 1600
            epsu = (double )0;
          }
#line 1601
          lbk = *(dy_sys->vlb + xkndx);
#line 1602
          if (- dy_tols->inf < lbk) {
            {
#line 1603
            tmp___19 = fabs(lbk);
#line 1603
            epsl = dy_tols->pfeas * (1.0 + tmp___19);
            }
          } else {
#line 1605
            epsl = (double )0;
          }
          {
#line 1606
          val = *(dy_xbasic + xkpos) - deltak;
#line 1607
          tmp___20 = fabs(val);
          }
#line 1607
          if (tmp___20 < eps0) {
#line 1607
            val = (double )0;
          }
#line 1608
          if (val != 0.0) {
            {
#line 1608
            tmp___23 = fabs(val);
            }
#line 1608
            if (tmp___23 < eps0 * dy_tols->bogus) {
#line 1608
              if (dy_lp->basis.etas > 1) {
#line 1610
                retval = (dyret_enum )4;
#line 1612
                if (dy_opts->print.pivoting >= 1) {
                  {
#line 1613
                  tmp___21 = fabs(val);
#line 1613
                  tmp___22 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1613
                  warn(374, rtnnme, dy_sys->nme, tmp___22, dy_lp->tot.iters, "x",
                       xkndx, tmp___21, eps0 * dy_tols->bogus, eps0 * dy_tols->bogus - val);
                  }
                }
              }
            }
          }
          {
#line 1667
          if (xkstatus == (flags )(1 << 1)) {
#line 1667
            goto case_exp;
          }
#line 1667
          if (xkstatus == (flags )(1 << 3)) {
#line 1667
            goto case_exp;
          }
#line 1667
          if (xkstatus == (flags )(1 << 2)) {
#line 1667
            goto case_exp;
          }
#line 1676
          if (xkstatus == (flags )(1 << 11)) {
#line 1676
            goto case_exp___2;
          }
#line 1691
          if (xkstatus == (flags )(1 << 10)) {
#line 1691
            goto case_exp___3;
          }
#line 1707
          if (xkstatus == 1U) {
#line 1707
            goto case_1;
          }
#line 1707
          if (xkstatus == (flags )(1 << 4)) {
#line 1707
            goto case_1;
          }
#line 1709
          goto switch_default;
          case_exp: /* CIL Label */ 
          case_exp___0: /* CIL Label */ 
          case_exp___1: /* CIL Label */ 
          {
#line 1668
          tmp___27 = fabs(ubk);
          }
#line 1668
          if (tmp___27 < dy_tols->inf) {
            {
#line 1668
            tmp___28 = fabs(val - ubk);
#line 1668
            tmp___29 = fabs(ubk);
            }
#line 1668
            if (tmp___28 < dy_tols->pfeas * (1.0 + tmp___29)) {
#line 1669
              *(dy_status + xkndx) = (flags )(1 << 1);
            } else {
#line 1668
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1671
            tmp___24 = fabs(lbk);
            }
#line 1671
            if (tmp___24 < dy_tols->inf) {
              {
#line 1671
              tmp___25 = fabs(val - lbk);
#line 1671
              tmp___26 = fabs(lbk);
              }
#line 1671
              if (tmp___25 < dy_tols->pfeas * (1.0 + tmp___26)) {
#line 1672
                *(dy_status + xkndx) = (flags )(1 << 3);
              } else {
#line 1674
                *(dy_status + xkndx) = (flags )(1 << 2);
              }
            } else {
#line 1674
              *(dy_status + xkndx) = (flags )(1 << 2);
            }
          }
#line 1675
          goto switch_break;
          case_exp___2: /* CIL Label */ 
          {
#line 1677
          tmp___40 = fabs(lbk);
          }
#line 1677
          if (tmp___40 < dy_tols->inf) {
            {
#line 1677
            tmp___38 = fabs(lbk);
#line 1677
            tmp___39 = lbk - val > dy_tols->pfeas * (1.0 + tmp___38);
            }
          } else {
#line 1677
            tmp___39 = val < lbk;
          }
#line 1677
          if (! tmp___39) {
            {
#line 1680
            tmp___34 = fabs(lbk);
            }
#line 1680
            if (tmp___34 < dy_tols->inf) {
              {
#line 1680
              tmp___35 = fabs(val - lbk);
#line 1680
              tmp___36 = fabs(lbk);
              }
#line 1680
              if (tmp___35 < dy_tols->pfeas * (1.0 + tmp___36)) {
#line 1681
                if (lbk == ubk) {
#line 1682
                  *(dy_status + xkndx) = (flags )1;
                } else {
#line 1684
                  *(dy_status + xkndx) = (flags )(1 << 3);
                }
              } else {
#line 1680
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 1686
              tmp___33 = fabs(ubk);
              }
#line 1686
              if (tmp___33 < dy_tols->inf) {
                {
#line 1686
                tmp___31 = fabs(ubk);
#line 1686
                tmp___32 = ubk - val > dy_tols->pfeas * (1.0 + tmp___31);
                }
              } else {
#line 1686
                tmp___32 = val < ubk;
              }
#line 1686
              if (tmp___32) {
#line 1687
                *(dy_status + xkndx) = (flags )(1 << 2);
              } else {
#line 1689
                *(dy_status + xkndx) = (flags )(1 << 1);
              }
            }
          }
#line 1690
          goto switch_break;
          case_exp___3: /* CIL Label */ 
          {
#line 1692
          tmp___51 = fabs(ubk);
          }
#line 1692
          if (tmp___51 < dy_tols->inf) {
            {
#line 1692
            tmp___49 = fabs(ubk);
#line 1692
            tmp___50 = val - ubk > dy_tols->pfeas * (1.0 + tmp___49);
            }
          } else {
#line 1692
            tmp___50 = val > ubk;
          }
#line 1692
          if (! tmp___50) {
            {
#line 1695
            tmp___45 = fabs(ubk);
            }
#line 1695
            if (tmp___45 < dy_tols->inf) {
              {
#line 1695
              tmp___46 = fabs(val - ubk);
#line 1695
              tmp___47 = fabs(ubk);
              }
#line 1695
              if (tmp___46 < dy_tols->pfeas * (1.0 + tmp___47)) {
#line 1696
                if (lbk == ubk) {
#line 1697
                  *(dy_status + xkndx) = (flags )1;
                } else {
#line 1699
                  *(dy_status + xkndx) = (flags )(1 << 1);
                }
              } else {
#line 1695
                goto _L___1;
              }
            } else {
              _L___1: /* CIL Label */ 
              {
#line 1701
              tmp___44 = fabs(lbk);
              }
#line 1701
              if (tmp___44 < dy_tols->inf) {
                {
#line 1701
                tmp___42 = fabs(lbk);
#line 1701
                tmp___43 = val - lbk > dy_tols->pfeas * (1.0 + tmp___42);
                }
              } else {
#line 1701
                tmp___43 = val > lbk;
              }
#line 1701
              if (tmp___43) {
#line 1702
                *(dy_status + xkndx) = (flags )(1 << 2);
              } else {
#line 1704
                *(dy_status + xkndx) = (flags )(1 << 3);
              }
            }
          }
#line 1705
          goto switch_break;
          case_1: /* CIL Label */ 
          case_exp___4: /* CIL Label */ 
#line 1708
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 1710
          errmsg(1, rtnnme, 1710);
          }
#line 1711
          return ((dyret_enum )-10);
          switch_break: /* CIL Label */ ;
          }
#line 1712
          *(dy_status + xkndx) |= quals;
#line 1717
          if (*(dy_status + xkndx) & (unsigned int )((1 | (1 << 3)) | (1 << 1))) {
#line 1717
            tmp___56 = 0;
          } else {
#line 1717
            tmp___56 = 1;
          }
#line 1717
          if (tmp___56) {
            {
#line 1718
            tmp___55 = fabs(val - lbk);
            }
#line 1718
            if (tmp___55 < epsl * dy_tols->bogus) {
#line 1718
              if (dy_lp->basis.etas > 1) {
#line 1719
                retval = (dyret_enum )4;
#line 1721
                if (dy_opts->print.pivoting >= 1) {
                  {
#line 1722
                  tmp___52 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1722
                  warn(375, rtnnme, dy_sys->nme, tmp___52, dy_lp->tot.iters, "x",
                       xkndx, "lb", xkndx, val, lbk, val - lbk, epsl * dy_tols->bogus,
                       epsl * dy_tols->bogus - (val - lbk));
                  }
                }
              } else {
#line 1718
                goto _L___2;
              }
            } else {
              _L___2: /* CIL Label */ 
              {
#line 1729
              tmp___54 = fabs(ubk - val);
              }
#line 1729
              if (tmp___54 < epsu * dy_tols->bogus) {
#line 1729
                if (dy_lp->basis.etas > 1) {
#line 1730
                  retval = (dyret_enum )4;
#line 1732
                  if (dy_opts->print.pivoting >= 1) {
                    {
#line 1733
                    tmp___53 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1733
                    warn(375, rtnnme, dy_sys->nme, tmp___53, dy_lp->tot.iters, "ub",
                         xkndx, "x", xkndx, ubk, val, ubk - val, epsu * dy_tols->bogus,
                         epsu * dy_tols->bogus - (ubk - val));
                    }
                  }
                }
              }
            }
          }
          {
#line 1739
          tmp___57 = fabs(val);
#line 1739
          tmp___58 = fabs(*(dy_xbasic + xkpos));
#line 1739
          swingratio = (tmp___57 + (double )1) / (tmp___58 + (double )1);
          }
#line 1740
          if (swingratio > dy_tols->swing) {
#line 1741
            swing = (bool )1;
#line 1742
            if (swingratio > maxswing) {
#line 1743
              maxswing = swingratio;
#line 1744
              swingndx = xkndx;
            }
          }
#line 1745
          *(dy_xbasic + xkpos) = val;
#line 1746
          if (dy_lp->degen == 0) {
#line 1746
            *(dy_x + xkndx) = val;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1588
      xkpos ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1785
  if (xjndx != xindx) {
#line 1785
    if (*(dy_status + xindx) & (unsigned int )((1 | (1 << 3)) | (1 << 1))) {
#line 1785
      tmp___68 = 0;
    } else {
#line 1785
      tmp___68 = 1;
    }
#line 1785
    if (tmp___68) {
#line 1786
      if (dy_lp->degen == 0) {
#line 1786
        dirtyz = (bool )1;
      }
#line 1787
      xkstatus = *(dy_status + xindx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 1788
      lbk = *(dy_sys->vlb + xindx);
#line 1789
      ubk = *(dy_sys->vub + xindx);
#line 1790
      if (lbk == ubk) {
#line 1791
        val = lbk;
#line 1792
        xkstatus = (flags )1;
      } else
#line 1794
      if (outdir < 0) {
#line 1795
        val = lbk;
#line 1796
        if (val <= - dy_tols->inf) {
#line 1797
          if ((unsigned int )dy_lp->phase == 2U) {
#line 1797
            if (xkstatus & (unsigned int )(1 << 10)) {
#line 1797
              tmp___61 = 1;
            } else {
#line 1797
              tmp___61 = 0;
            }
#line 1797
            if (tmp___61) {
#line 1798
              val = ubk;
#line 1799
              xkstatus = (flags )(1 << 1);
            } else {
              {
#line 1801
              tmp___59 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1801
              tmp___60 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1801
              errmsg(382, rtnnme, dy_sys->nme, tmp___60, dy_lp->tot.iters, tmp___59,
                     xindx, "lb", val);
              }
#line 1804
              return ((dyret_enum )-10);
            }
          } else {
            {
#line 1801
            tmp___59 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1801
            tmp___60 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1801
            errmsg(382, rtnnme, dy_sys->nme, tmp___60, dy_lp->tot.iters, tmp___59,
                   xindx, "lb", val);
            }
#line 1804
            return ((dyret_enum )-10);
          }
        } else {
#line 1806
          xkstatus = (flags )(1 << 3);
        }
      } else {
#line 1808
        val = ubk;
#line 1809
        if (val >= dy_tols->inf) {
#line 1810
          if ((unsigned int )dy_lp->phase == 2U) {
#line 1810
            if (xkstatus & (unsigned int )(1 << 11)) {
#line 1810
              tmp___64 = 1;
            } else {
#line 1810
              tmp___64 = 0;
            }
#line 1810
            if (tmp___64) {
#line 1811
              val = lbk;
#line 1812
              xkstatus = (flags )(1 << 3);
            } else {
              {
#line 1814
              tmp___62 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1814
              tmp___63 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1814
              errmsg(382, rtnnme, dy_sys->nme, tmp___63, dy_lp->tot.iters, tmp___62,
                     xindx, "ub", val);
              }
#line 1817
              return ((dyret_enum )-10);
            }
          } else {
            {
#line 1814
            tmp___62 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1814
            tmp___63 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1814
            errmsg(382, rtnnme, dy_sys->nme, tmp___63, dy_lp->tot.iters, tmp___62,
                   xindx, "ub", val);
            }
#line 1817
            return ((dyret_enum )-10);
          }
        } else {
#line 1819
          xkstatus = (flags )(1 << 1);
        }
      }
#line 1821
      *(dy_xbasic + xipos) = val;
#line 1822
      *(dy_status + xindx) = (flags )0;
#line 1823
      *(dy_status + xindx) |= xkstatus;
#line 1824
      if (dy_lp->degen == 0) {
#line 1824
        *(dy_x + xindx) = val;
      }
#line 1826
      retval = (dyret_enum )4;
#line 1829
      if (dy_opts->print.pivoting >= 1) {
#line 1830
        if (outdir < 0) {
#line 1830
          tmp___65 = "lb";
        } else {
#line 1830
          tmp___65 = "ub";
        }
        {
#line 1830
        tmp___66 = dy_prtvstat(*(dy_status + xindx));
#line 1830
        tmp___67 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1830
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      %s (%d) = %g, %s, leaving at %s, dirty degenerate pivot.",
                    tmp___67, xindx, *(dy_xbasic + xipos), tmp___66, tmp___65);
        }
      }
    }
  }
#line 1866
  if (xjndx != xindx) {
#line 1867
    *(dy_var2basis + xjndx) = xipos;
#line 1868
    *(dy_var2basis + xindx) = 0;
#line 1869
    *(dy_basis + xipos) = xjndx;
#line 1870
    xkstatus = *(dy_status + xindx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 1871
    if (xkstatus == (flags )(1 << 3)) {
#line 1872
      *(dy_status + xindx) = (flags )(1 << 7);
#line 1873
      *(dy_x + xindx) = *(dy_sys->vlb + xindx);
    } else
#line 1875
    if (xkstatus == (flags )(1 << 1)) {
#line 1876
      *(dy_status + xindx) = (flags )(1 << 6);
#line 1877
      *(dy_x + xindx) = *(dy_sys->vub + xindx);
    } else {
#line 1879
      *(dy_status + xindx) = (flags )(1 << 5);
#line 1880
      *(dy_x + xindx) = *(dy_sys->vlb + xindx);
    }
#line 1881
    if (delta != (double )0) {
      {
#line 1882
      val = *(dy_x + xjndx) + delta;
#line 1883
      tmp___69 = fabs(val);
#line 1883
      tmp___70 = fabs(*(dy_x + xjndx));
#line 1883
      swingratio = (tmp___69 + (double )1) / (tmp___70 + (double )1);
      }
#line 1884
      if (swingratio > dy_tols->swing) {
#line 1885
        swing = (bool )1;
#line 1886
        if (swingratio > maxswing) {
#line 1887
          maxswing = swingratio;
#line 1888
          swingndx = xjndx;
        }
      }
      {
#line 1889
      tmp___71 = fabs(val);
#line 1889
      tmp___72 = fabs(delta);
      }
#line 1889
      if (tmp___71 < dy_tols->zero * (1.0 + tmp___72)) {
#line 1889
        val = (double )0;
      }
      {
#line 1893
      if (*(dy_status + xjndx) == (flags )(1 << 9)) {
#line 1893
        goto case_exp___5;
      }
#line 1893
      if (*(dy_status + xjndx) == (flags )(1 << 6)) {
#line 1893
        goto case_exp___5;
      }
#line 1893
      if (*(dy_status + xjndx) == (flags )(1 << 7)) {
#line 1893
        goto case_exp___5;
      }
#line 1902
      if (*(dy_status + xjndx) == (flags )(1 << 8)) {
#line 1902
        goto case_exp___8;
      }
#line 1890
      goto switch_break___0;
      case_exp___5: /* CIL Label */ 
      case_exp___6: /* CIL Label */ 
      case_exp___7: /* CIL Label */ 
      {
#line 1894
      tmp___76 = fabs(*(dy_sys->vub + xjndx));
      }
#line 1894
      if (tmp___76 < dy_tols->inf) {
        {
#line 1894
        tmp___77 = fabs(val - *(dy_sys->vub + xjndx));
#line 1894
        tmp___78 = fabs(*(dy_sys->vub + xjndx));
        }
#line 1894
        if (tmp___77 < dy_tols->pfeas * (1.0 + tmp___78)) {
#line 1895
          *(dy_status + xjndx) = (flags )(1 << 1);
        } else {
#line 1894
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
#line 1897
        tmp___73 = fabs(*(dy_sys->vlb + xjndx));
        }
#line 1897
        if (tmp___73 < dy_tols->inf) {
          {
#line 1897
          tmp___74 = fabs(val - *(dy_sys->vlb + xjndx));
#line 1897
          tmp___75 = fabs(*(dy_sys->vlb + xjndx));
          }
#line 1897
          if (tmp___74 < dy_tols->pfeas * (1.0 + tmp___75)) {
#line 1898
            *(dy_status + xjndx) = (flags )(1 << 3);
          } else {
#line 1900
            *(dy_status + xjndx) = (flags )(1 << 2);
          }
        } else {
#line 1900
          *(dy_status + xjndx) = (flags )(1 << 2);
        }
      }
#line 1901
      goto switch_break___0;
      case_exp___8: /* CIL Label */ 
#line 1903
      *(dy_status + xjndx) = (flags )(1 << 4);
#line 1904
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 1912
      val = *(dy_x + xjndx);
      {
#line 1914
      if (*(dy_status + xjndx) == (flags )(1 << 7)) {
#line 1914
        goto case_exp___9;
      }
#line 1917
      if (*(dy_status + xjndx) == (flags )(1 << 6)) {
#line 1917
        goto case_exp___10;
      }
#line 1920
      if (*(dy_status + xjndx) == (flags )(1 << 9)) {
#line 1920
        goto case_exp___11;
      }
#line 1923
      if (*(dy_status + xjndx) == (flags )(1 << 8)) {
#line 1923
        goto case_exp___12;
      }
#line 1913
      goto switch_break___1;
      case_exp___9: /* CIL Label */ 
#line 1915
      *(dy_status + xjndx) = (flags )(1 << 3);
#line 1916
      goto switch_break___1;
      case_exp___10: /* CIL Label */ 
#line 1918
      *(dy_status + xjndx) = (flags )(1 << 1);
#line 1919
      goto switch_break___1;
      case_exp___11: /* CIL Label */ 
#line 1921
      *(dy_status + xjndx) = (flags )(1 << 2);
#line 1922
      goto switch_break___1;
      case_exp___12: /* CIL Label */ 
#line 1924
      *(dy_status + xjndx) = (flags )(1 << 4);
#line 1925
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 1932
    if (dy_lp->degen > 0) {
#line 1933
      *(dy_brkout + xipos) = indir;
    } else {
#line 1935
      *(dy_x + xjndx) = val;
    }
#line 1936
    *(dy_xbasic + xipos) = val;
  } else
#line 1938
  if (outdir == 1) {
#line 1939
    *(dy_status + xindx) = (flags )(1 << 6);
#line 1940
    *(dy_x + xindx) = *(dy_sys->vub + xindx);
  } else {
#line 1942
    *(dy_status + xindx) = (flags )(1 << 7);
#line 1943
    *(dy_x + xindx) = *(dy_sys->vlb + xindx);
  }
#line 1947
  if ((int )dirtyz == 1) {
    {
#line 1948
    dy_lp->z = dy_calcobj();
    }
  }
#line 1964
  if (xjndx != xindx) {
    {
#line 1965
    tmp___83 = fabs(cbarj);
    }
#line 1965
    if (tmp___83 > dy_tols->cost) {
#line 1966
      xkpos = 1;
      {
#line 1966
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1966
        if (! (xkpos <= dy_sys->concnt)) {
#line 1966
          goto while_break___0;
        }
        {
#line 1967
        deltak = cbarj * *(betai + xkpos);
#line 1968
        deltak /= abarij;
#line 1969
        val = *(dy_y + xkpos) + deltak;
#line 1970
        tmp___79 = fabs(val);
        }
#line 1970
        if (tmp___79 < dy_tols->cost) {
#line 1970
          val = (double )0;
        }
#line 1971
        if (val != 0.0) {
#line 1971
          if (dy_lp->basis.etas > 1) {
            {
#line 1971
            tmp___82 = fabs(val);
            }
#line 1971
            if (tmp___82 < dy_tols->cost * dy_tols->bogus) {
#line 1973
              retval = (dyret_enum )4;
#line 1975
              if (dy_opts->print.pivoting >= 1) {
                {
#line 1976
                tmp___80 = fabs(val);
#line 1976
                tmp___81 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1976
                warn(374, rtnnme, dy_sys->nme, tmp___81, dy_lp->tot.iters, "y", xkpos,
                     tmp___80, dy_tols->cost * dy_tols->bogus, dy_tols->cost * dy_tols->bogus - val);
                }
              }
            }
          }
        }
#line 1982
        *(dy_y + xkpos) = val;
#line 1966
        xkpos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1988
  if ((int )swing == 1) {
#line 1989
    if (dy_lp->sys.cons.loadable > 0) {
#line 1990
      retval = (dyret_enum )9;
    }
#line 1991
    dy_lp->ubnd.ndx = swingndx;
#line 1992
    dy_lp->ubnd.ratio = maxswing;
#line 1994
    if (print >= 2) {
      {
#line 1995
      tmp___84 = consys_nme(dy_sys, (char )'v', dy_lp->ubnd.ndx, (bool )0, (char *)((void *)0));
#line 1995
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    Pseudo-unbounded: growth %e for %s (%d)",
                  dy_lp->ubnd.ratio, tmp___84, dy_lp->ubnd.ndx);
      }
    }
  }
#line 2006
  if (print >= 5) {
    {
#line 2009
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trevised objective %g.", dy_lp->z);
    }
#line 2018
    if (print >= 6) {
#line 2019
      all = (bool )1;
    } else {
#line 2021
      all = (bool )0;
    }
#line 2022
    first = (bool )1;
#line 2023
    xkpos = 1;
    {
#line 2023
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2023
      if (! (xkpos <= dy_sys->concnt)) {
#line 2023
        goto while_break___1;
      }
#line 2024
      if (*(abarj + xkpos) != (double )0) {
#line 2024
        goto _L___4;
      } else
#line 2024
      if ((int )all == 1) {
        _L___4: /* CIL Label */ 
#line 2025
        if ((int )first == 1) {
#line 2026
          if ((int )all == 1) {
#line 2026
            tmp___85 = "";
          } else {
#line 2026
            tmp___85 = "revised ";
          }
          {
#line 2026
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%sprimal variables:", tmp___85);
#line 2028
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s%16s%16s %s", "pos\'n",
                      "var (ndx)", "lb", "val", "ub", "status");
#line 2031
          first = (bool )0;
          }
        }
        {
#line 2032
        xkndx = *(dy_basis + xkpos);
#line 2033
        tmp___86 = dy_prtvstat(*(dy_status + xkndx));
#line 2033
        tmp___87 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 2033
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%14s (%3d)%16.8g%16.8g%16.8g %s",
                    xkpos, tmp___87, xkndx, *(dy_sys->vlb + xkndx), *(dy_xbasic + xkpos),
                    *(dy_sys->vub + xkndx), tmp___86);
        }
      }
#line 2023
      xkpos ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2038
    if ((int )first == 1) {
      {
#line 2039
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tno change to primal variables.");
      }
    }
#line 2040
    if (print >= 7) {
#line 2041
      if (xindx != xjndx) {
        {
#line 2042
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    dual variables, cbar tolerance %g",
                    dy_tols->dfeas);
#line 2045
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s", "pos\'n", "constraint",
                    "val");
#line 2047
        xkpos = 1;
        }
        {
#line 2047
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2047
          if (! (xkpos <= dy_sys->concnt)) {
#line 2047
            goto while_break___2;
          }
          {
#line 2048
          tmp___88 = consys_nme(dy_sys, (char )'c', xkpos, (bool )0, (char *)((void *)0));
#line 2048
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%20s%16.8g", xkpos, tmp___88, *(dy_y + xkpos));
#line 2047
          xkpos ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 2051
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    no change to dual variables.");
        }
      }
    }
  }
#line 2055
  return (retval);
}
}
#line 2162 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
static dyret_enum pseupdate(int xjndx , int xindx , int *candxj , double *abarj ,
                            double *v , double *betai ) 
{ 
  int xkpos ;
  int xkndx ;
  int xipos ;
  double abarij ;
  double cbarj ;
  double gammaj ;
  double abarik ;
  double alphak ;
  double cbark ;
  double gammak ;
  double akdotv ;
  double candcbarj ;
  flags xkstatus ;
  bool reset ;
  bool pivreject ;
  dyret_enum retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;

  {
#line 2232
  rtnnme = "pseupdate";
#line 2240
  xipos = *(dy_var2basis + xjndx);
#line 2241
  abarij = *(abarj + xipos);
#line 2242
  cbarj = *(dy_cbar + xjndx);
#line 2243
  *(dy_cbar + xjndx) = (double )0;
#line 2244
  retval = (dyret_enum )0;
#line 2245
  candcbarj = - dy_tols->inf;
#line 2246
  *candxj = 0;
#line 2256
  *(dy_basis + xipos) = xindx;
#line 2257
  gammaj = (double )1;
#line 2258
  xkpos = 1;
  {
#line 2258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2258
    if (! (xkpos <= dy_sys->concnt)) {
#line 2258
      goto while_break;
    }
#line 2259
    if ((int )*(dy_frame + *(dy_basis + xkpos)) == 1) {
#line 2259
      gammaj += *(abarj + xkpos) * *(abarj + xkpos);
    }
#line 2258
    xkpos ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2260
  tmp___2 = fabs(*(dy_gamma + xjndx) - gammaj);
  }
#line 2260
  if (tmp___2 <= dy_tols->reframe * gammaj) {
#line 2275
    reset = (bool )0;
  } else {
#line 2261
    reset = (bool )1;
#line 2263
    if (dy_opts->print.pivoting >= 1) {
      {
#line 2264
      tmp = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2264
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2264
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %s: (%s)%d: resetting reference frame; trigger %s (%d)",
                  dy_sys->nme, tmp___0, dy_lp->tot.iters, tmp, xjndx);
#line 2268
      tmp___1 = fabs(gammaj - *(dy_gamma + xjndx));
#line 2268
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\texact gamma<j> = %g, approx = %g, error = %g, tol = %g.",
                  gammaj, *(dy_gamma + xjndx), tmp___1, dy_tols->reframe * gammaj);
      }
    }
  }
#line 2276
  *(dy_basis + xipos) = xjndx;
#line 2277
  *(dy_gamma + xjndx) = gammaj;
#line 2286
  pivreject = (bool )0;
#line 2287
  xkndx = 1;
  {
#line 2287
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2287
    if (! (xkndx <= dy_sys->varcnt)) {
#line 2287
      goto while_break___0;
    }
#line 2288
    xkstatus = *(dy_status + xkndx);
#line 2289
    if (xkstatus & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 2289
      tmp___3 = 1;
    } else {
#line 2289
      tmp___3 = 0;
    }
#line 2289
    if (tmp___3) {
#line 2295
      goto __Cont;
    }
    {
#line 2296
    abarik = consys_dotcol(dy_sys, xkndx, betai);
#line 2303
    alphak = abarik / abarij;
#line 2304
    tmp___4 = fabs(alphak);
    }
#line 2304
    if (tmp___4 < dy_tols->zero) {
#line 2304
      alphak = (double )0;
    }
#line 2346
    if (alphak != (double )0) {
#line 2347
      if (xkndx != xindx) {
        {
#line 2348
        cbark = *(dy_cbar + xkndx) - cbarj * alphak;
#line 2349
        akdotv = consys_dotcol(dy_sys, xkndx, v);
#line 2356
        gammak = *(dy_gamma + xkndx) - alphak * ((double )2 * akdotv - alphak * gammaj);
        }
      } else {
#line 2358
        cbark = - cbarj / abarij;
#line 2359
        gammak = gammaj / (abarij * abarij);
#line 2360
        if ((int )*(dy_frame + xkndx) != 1) {
#line 2361
          *(dy_frame + xkndx) = (bool )1;
#line 2362
          gammak += (double )1;
        }
      }
      {
#line 2363
      tmp___5 = fabs(cbark);
      }
#line 2363
      if (tmp___5 < dy_tols->cost) {
#line 2363
        cbark = (double )0;
      }
#line 2364
      *(dy_cbar + xkndx) = cbark;
#line 2365
      if (gammak < 1.0) {
#line 2365
        gammak = 1.0;
      }
#line 2366
      *(dy_gamma + xkndx) = gammak;
    }
    {
#line 2376
    pricexk(xkndx, candxj, & candcbarj, & pivreject);
    }
    __Cont: /* CIL Label */ 
#line 2287
    xkndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2382
  if ((int )reset == 1) {
    {
#line 2383
    memset((void *)dy_frame, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(bool ));
#line 2384
    memset((void *)dy_gamma, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(double ));
#line 2385
    xkndx = 1;
    }
    {
#line 2385
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2385
      if (! (xkndx <= dy_sys->varcnt)) {
#line 2385
        goto while_break___1;
      }
#line 2386
      if (*(dy_status + xkndx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | ((1 << 9) | (1 << 8)))) {
#line 2386
        tmp___6 = 1;
      } else {
#line 2386
        tmp___6 = 0;
      }
#line 2386
      if (tmp___6) {
#line 2387
        *(dy_frame + xkndx) = (bool )1;
#line 2388
        *(dy_gamma + xkndx) = 1.0;
      }
#line 2385
      xkndx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2403
  if (*candxj == 0) {
#line 2404
    if ((int )pivreject == 1) {
#line 2405
      retval = (dyret_enum )6;
    } else {
#line 2407
      retval = (dyret_enum )7;
    }
  } else {
#line 2409
    retval = (dyret_enum )1;
  }
#line 2412
  if (dy_opts->print.pricing >= 2) {
#line 2413
    if (*candxj != 0) {
      {
#line 2414
      tmp___7 = consys_nme(dy_sys, (char )'v', *candxj, (bool )1, (char *)((void *)0));
#line 2414
      tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2414
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: (%s)%d: selected %s (%d), PSE price %g.",
                  rtnnme, tmp___8, dy_lp->tot.iters, tmp___7, *candxj, candcbarj);
      }
    } else {
      {
#line 2420
      tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2420
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: (%s)%d: no suitable candidates.",
                  rtnnme, tmp___9, dy_lp->tot.iters);
      }
    }
  }
#line 2423
  if (dy_opts->print.pricing >= 1) {
#line 2424
    if ((int )retval == 6) {
      {
#line 2425
      tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2425
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: (%s)%d: all suitable x<j> on rejected pivot list.",
                  rtnnme, tmp___10, dy_lp->tot.iters);
      }
    }
  }
#line 2431
  return (retval);
}
}
#line 2523
dyret_enum primmultiout(int j , int indir , double *abarj , double maxabarj , int *p_xindx ,
                        int *p_outdir , double *p_deltaj ) ;
#line 2435 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalpivot.c"
dyret_enum dy_primalpivot(int xjndx , int indir , int *p_xindx , int *p_outdir , double *p_abarij ,
                          double *p_delta , int *p_xjcand ) 
{ 
  int xipos ;
  int xindx ;
  int xkpos ;
  int outdir ;
  double *abarj ;
  double *v ;
  double *betai ;
  double maxabarj ;
  double abarij ;
  double delta ;
  dyret_enum retval ;
  dyret_enum outretval ;
  dyret_enum pseretval ;
  bool reselect ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  dyret_enum tmp___7 ;
  char const   *tmp___8 ;
  dyret_enum tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  char const   *tmp___28 ;
  bool tmp___29 ;

  {
  {
#line 2521
  rtnnme = "dy_primalpivot";
#line 2531
  retval = (dyret_enum )0;
#line 2532
  *p_xindx = -1;
#line 2533
  *p_outdir = 0;
#line 2534
  *p_xjcand = -1;
#line 2535
  *p_abarij = QNaNbits___1.fpdbl;
#line 2536
  *p_delta = QNaNbits___1.fpdbl;
#line 2541
  abarj = (double *)((void *)0);
#line 2542
  tmp___0 = consys_getcol_ex(dy_sys, xjndx, & abarj);
  }
#line 2542
  if ((int )tmp___0 == 0) {
    {
#line 2543
    tmp = consys_nme(dy_sys, (char )'v', xjndx, (bool )1, (char *)((void *)0));
#line 2543
    errmsg(122, rtnnme, dy_sys->nme, "column", tmp, xjndx);
    }
#line 2545
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 2545
      free((void *)abarj);
      }
    }
#line 2546
    return ((dyret_enum )-10);
  }
#line 2553
  if (dy_opts->print.pivoting >= 1) {
#line 2554
    if (indir < 0) {
#line 2554
      tmp___1 = "decreasing";
    } else {
#line 2554
      tmp___1 = "increasing";
    }
    {
#line 2554
    tmp___2 = dy_prtvstat(*(dy_status + xjndx));
#line 2554
    tmp___3 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2554
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: x<%d> (%s) entering, status %s, %s from %g, ",
                rtnnme, xjndx, tmp___3, tmp___2, tmp___1, *(dy_x + xjndx));
#line 2559
    dyio_outfmt(dy_logchn, dy_gtxecho, "lb<j> = %g, ub<j> = %g.", *(dy_sys->vlb + xjndx),
                *(dy_sys->vub + xjndx));
    }
#line 2561
    if (dy_opts->print.pivoting >= 3) {
      {
#line 2562
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    entering column a<%d>:", xjndx);
#line 2563
      xkpos = 1;
#line 2564
      xipos = 1;
      }
      {
#line 2564
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2564
        if (! (xipos <= dy_sys->concnt)) {
#line 2564
          goto while_break;
        }
#line 2565
        if (*(abarj + xipos) == (double )0) {
#line 2565
          goto __Cont;
        }
#line 2566
        xkpos = (xkpos + 1) % 2;
#line 2567
        if (xkpos == 0) {
          {
#line 2567
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
          }
        }
#line 2568
        xindx = *(dy_basis + xipos);
#line 2569
        if (dy_lp->degen > 0) {
#line 2569
          if (dy_lp->degen == *(dy_degenset + xindx)) {
#line 2569
            tmp___4 = '*';
          } else {
#line 2569
            tmp___4 = '\000';
          }
        } else {
#line 2569
          tmp___4 = '\000';
        }
        {
#line 2569
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%ca<%d,%d> = %g", tmp___4, xipos, xjndx,
                    *(abarj + xipos));
        }
        __Cont: /* CIL Label */ 
#line 2564
        xipos ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 2574
  dy_ftran(abarj, (bool )1);
#line 2575
  maxabarj = exvec_infnorm(abarj, dy_sys->concnt, (int *)((void *)0));
  }
#line 2581
  if (dy_opts->print.pivoting >= 3) {
    {
#line 2582
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    entering column abar<%d> = inv(B)a<%d>, max %g:",
                xjndx, xjndx, maxabarj);
#line 2585
    xkpos = 1;
#line 2586
    xipos = 1;
    }
    {
#line 2586
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2586
      if (! (xipos <= dy_sys->concnt)) {
#line 2586
        goto while_break___0;
      }
#line 2587
      if (*(abarj + xipos) == (double )0) {
#line 2587
        goto __Cont___0;
      }
#line 2588
      xkpos = (xkpos + 1) % 2;
#line 2589
      if (xkpos == 0) {
        {
#line 2589
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
        }
      }
#line 2590
      xindx = *(dy_basis + xipos);
#line 2591
      if (dy_lp->degen > 0) {
#line 2591
        if (dy_lp->degen == *(dy_degenset + xindx)) {
#line 2591
          tmp___5 = '*';
        } else {
#line 2591
          tmp___5 = '\000';
        }
      } else {
#line 2591
        tmp___5 = '\000';
      }
      {
#line 2591
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t%ca<%d,%d> = %g", tmp___5, xipos, xjndx,
                  *(abarj + xipos));
      }
      __Cont___0: /* CIL Label */ 
#line 2586
      xipos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2607
  reselect = (bool )1;
#line 2608
  degen_cyclecnt = 0;
#line 2609
  xipos = -1;
  {
#line 2610
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2610
    if (! reselect) {
#line 2610
      goto while_break___1;
    }
#line 2611
    if (dy_opts->ppsel.strat == 0) {
      {
#line 2612
      outretval = primalout(xjndx, indir, abarj, maxabarj, & xindx, & outdir, & delta);
      }
    } else {
      {
#line 2615
      outretval = primmultiout(xjndx, indir, abarj, maxabarj, & xindx, & outdir, & delta);
      }
    }
    {
#line 2634
    if ((int )outretval == 8) {
#line 2634
      goto case_8;
    }
#line 2674
    if ((int )outretval == 1) {
#line 2674
      goto case_1;
    }
#line 2723
    if ((int )outretval == -2) {
#line 2723
      goto case_neg_2;
    }
#line 2784
    if ((int )outretval == -1) {
#line 2784
      goto case_neg_1;
    }
#line 2791
    if ((int )outretval == -4) {
#line 2791
      goto case_neg_4;
    }
#line 2791
    if ((int )outretval == 4) {
#line 2791
      goto case_neg_4;
    }
#line 2795
    if ((int )outretval == -10) {
#line 2795
      goto case_neg_10;
    }
#line 2798
    goto switch_default;
    case_8: /* CIL Label */ 
#line 2635
    if (dy_lp->degen <= 0) {
      {
#line 2636
      free((void *)abarj);
      }
#line 2637
      return ((dyret_enum )8);
    }
#line 2639
    if (dy_opts->print.pivoting >= 1) {
      {
#line 2640
      tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2640
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, unbounded.",
                  tmp___6, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats.iterin[dy_lp->degen]);
      }
    } else
#line 2639
    if (dy_opts->print.degen >= 1) {
      {
#line 2640
      tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2640
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, unbounded.",
                  tmp___6, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats.iterin[dy_lp->degen]);
      }
    }
    {
#line 2645
    tmp___7 = dy_degenout(dy_lp->degen - 1);
    }
#line 2645
    if ((int )tmp___7 != 1) {
#line 2646
      outretval = (dyret_enum )4;
#line 2647
      reselect = (bool )0;
    }
#line 2648
    goto switch_break;
    case_1: /* CIL Label */ 
#line 2675
    if (xjndx != xindx) {
#line 2675
      xipos = *(dy_var2basis + xindx);
    }
#line 2676
    if (dy_lp->degen > 0) {
#line 2676
      if (xjndx == xindx) {
#line 2676
        goto _L;
      } else
#line 2676
      if (outdir == *(dy_brkout + xipos)) {
        _L: /* CIL Label */ 
#line 2679
        if (dy_opts->print.pivoting >= 1) {
          {
#line 2680
          tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2680
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, ",
                      tmp___8, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats.iterin[dy_lp->degen]);
#line 2685
          dyio_outfmt(dy_logchn, dy_gtxecho, "nondegenerate pivot.");
          }
        } else
#line 2679
        if (dy_opts->print.degen >= 1) {
          {
#line 2680
          tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2680
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, ",
                      tmp___8, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats.iterin[dy_lp->degen]);
#line 2685
          dyio_outfmt(dy_logchn, dy_gtxecho, "nondegenerate pivot.");
          }
        }
        {
#line 2687
        tmp___9 = dy_degenout(dy_lp->degen - 1);
        }
#line 2687
        if ((int )tmp___9 != 1) {
#line 2688
          outretval = (dyret_enum )4;
#line 2689
          reselect = (bool )0;
        }
      } else {
#line 2691
        reselect = (bool )0;
      }
    } else {
#line 2691
      reselect = (bool )0;
    }
#line 2692
    goto switch_break;
    case_neg_2: /* CIL Label */ 
#line 2724
    if (*(dy_status + xindx) & (1U | (1U << (sizeof(flags ) * 8UL - 3UL)))) {
#line 2724
      tmp___22 = 1;
    } else {
#line 2724
      tmp___22 = 0;
    }
#line 2724
    if (tmp___22) {
#line 2724
      goto _L___3;
    } else {
#line 2724
      if (*(dy_status + xjndx) & (unsigned int )((1 << 8) | (1 << 9))) {
#line 2724
        tmp___23 = 1;
      } else {
#line 2724
        tmp___23 = 0;
      }
#line 2724
      if (tmp___23) {
        _L___3: /* CIL Label */ 
#line 2726
        reselect = (bool )0;
#line 2727
        xipos = *(dy_var2basis + xindx);
#line 2729
        if (dy_opts->print.degen >= 3) {
          {
#line 2730
          tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2730
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      (%s)%d: constructive degenerate pivot.",
                      tmp___10, dy_lp->tot.iters);
#line 2733
          tmp___11 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2733
          tmp___12 = dy_prtvstat(*(dy_status + xindx));
#line 2733
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) leaving,", tmp___12,
                      tmp___11, xindx);
#line 2736
          tmp___13 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2736
          tmp___14 = dy_prtvstat(*(dy_status + xjndx));
#line 2736
          dyio_outfmt(dy_logchn, dy_gtxecho, " %s %s (%d) entering.", tmp___14, tmp___13,
                      xjndx);
          }
        }
      } else
#line 2742
      if ((int )dy_opts->degen == 1) {
#line 2742
        if (dy_opts->degenpivlim < dy_lp->degenpivcnt) {
#line 2742
          if (degen_cyclecnt < 3) {
#line 2747
            if (dy_opts->print.pivoting >= 1) {
              {
#line 2748
              tmp___15 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2748
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: antidegeneracy increasing to level %d.",
                          tmp___15, dy_lp->tot.iters, dy_lp->degen + 1);
              }
            } else
#line 2747
            if (dy_opts->print.degen >= 1) {
              {
#line 2748
              tmp___15 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2748
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: antidegeneracy increasing to level %d.",
                          tmp___15, dy_lp->tot.iters, dy_lp->degen + 1);
              }
            }
            {
#line 2753
            dy_degenin();
#line 2754
            degen_cyclecnt ++;
            }
          } else {
#line 2742
            goto _L___2;
          }
        } else {
#line 2742
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 2756
        reselect = (bool )0;
#line 2757
        xipos = *(dy_var2basis + xindx);
#line 2759
        if (dy_opts->print.degen >= 2) {
#line 2759
          if (degen_cyclecnt >= 3) {
            {
#line 2760
            tmp___16 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2760
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: forced degenerate pivot after %d cycles;",
                        tmp___16, dy_lp->tot.iters, degen_cyclecnt);
#line 2764
            tmp___17 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2764
            tmp___18 = dy_prtvstat(*(dy_status + xindx));
#line 2764
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) leaving.", tmp___18,
                        tmp___17, xindx);
            }
          } else {
#line 2759
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2768
        if (dy_opts->print.degen >= 3) {
          {
#line 2769
          tmp___19 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2769
          tmp___20 = dy_prtvstat(*(dy_status + xindx));
#line 2769
          tmp___21 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2769
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      (%s)%d: degenerate pivot, %s %s (%d) leaving.",
                      tmp___21, dy_lp->tot.iters, tmp___20, tmp___19, xindx);
          }
        }
      }
    }
#line 2776
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 2785
    xipos = *(dy_var2basis + xindx);
#line 2786
    abarij = *(abarj + xipos);
#line 2787
    dy_addtopivrej(xjndx, (dyret_enum )-1, abarij, maxabarj);
#line 2788
    reselect = (bool )0;
    }
#line 2789
    goto switch_break;
    case_neg_4: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 2792
    xipos = *(dy_var2basis + xindx);
#line 2793
    reselect = (bool )0;
#line 2794
    goto switch_break;
    case_neg_10: /* CIL Label */ 
    {
#line 2796
    free((void *)abarj);
    }
#line 2797
    return (outretval);
    switch_default: /* CIL Label */ 
    {
#line 2799
    errmsg(1, rtnnme, 2799);
#line 2800
    free((void *)abarj);
    }
#line 2801
    return (outretval);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2811
  *p_xindx = xindx;
#line 2812
  *p_outdir = outdir;
#line 2813
  *p_delta = delta;
#line 2814
  abarij = QNaNbits___1.fpdbl;
#line 2815
  if (xjndx != xindx) {
#line 2816
    if (xindx > 0) {
#line 2817
      abarij = *(abarj + xipos);
#line 2818
      *p_abarij = abarij;
    }
  } else {
#line 2820
    *p_abarij = 1.0;
  }
#line 2821
  if (! ((int )outretval == 1)) {
#line 2821
    if (! ((int )outretval == -2)) {
      {
#line 2822
      free((void *)abarj);
      }
#line 2823
      return (outretval);
    }
  }
#line 2828
  if ((int )outretval == 1) {
#line 2829
    dy_lp->degenpivcnt = 0;
  } else {
#line 2831
    if (*(dy_status + xindx) & (1U | (1U << (sizeof(flags ) * 8UL - 3UL)))) {
#line 2831
      tmp___24 = 1;
    } else {
#line 2831
      tmp___24 = 0;
    }
#line 2831
    if (tmp___24) {
#line 2833
      dy_lp->degenpivcnt = 0;
    } else {
#line 2831
      if (*(dy_status + xjndx) & (unsigned int )((1 << 8) | (1 << 9))) {
#line 2831
        tmp___25 = 1;
      } else {
#line 2831
        tmp___25 = 0;
      }
#line 2831
      if (tmp___25) {
#line 2833
        dy_lp->degenpivcnt = 0;
      } else {
#line 2835
        (dy_lp->degenpivcnt) ++;
      }
    }
  }
#line 2854
  if (xjndx != xindx) {
#line 2855
    xkpos = 1;
    {
#line 2855
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2855
      if (! (xkpos <= dy_sys->concnt)) {
#line 2855
        goto while_break___2;
      }
#line 2856
      if ((int )*(dy_frame + *(dy_basis + xkpos)) == 0) {
#line 2856
        *(abarj + xkpos) = (double )0;
      }
#line 2855
      xkpos ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2857
    dy_btran(abarj);
#line 2858
    tmp___26 = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 2858
    v = (double *)tmp___26;
#line 2859
    memcpy((void */* __restrict  */)v, (void const   */* __restrict  */)abarj, (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 2860
    tmp___27 = calloc((size_t )(dy_sys->concnt + 1), sizeof(double ));
#line 2860
    betai = (double *)tmp___27;
#line 2861
    *(betai + xipos) = 1.0;
#line 2862
    dy_btran(betai);
#line 2863
    tmp___29 = consys_getcol_ex(dy_sys, xjndx, & abarj);
    }
#line 2863
    if ((int )tmp___29 == 0) {
      {
#line 2864
      tmp___28 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2864
      errmsg(122, rtnnme, dy_sys->nme, "column", tmp___28, xjndx);
#line 2866
      retval = (dyret_enum )-10;
      }
    } else {
      {
#line 2868
      dy_ftran(abarj, (bool )1);
#line 2869
      retval = dy_pivot(xipos, abarij, maxabarj);
      }
    }
  } else {
#line 2871
    v = (double *)((void *)0);
#line 2872
    betai = (double *)((void *)0);
#line 2873
    retval = (dyret_enum )1;
  }
#line 2887
  if ((int )retval == 1) {
    {
#line 2888
    dy_lp->pivok = (bool )1;
#line 2889
    retval = primalupdate(xjndx, indir, xindx, outdir, abarj, delta, betai);
    }
#line 2890
    if ((int )retval == 1) {
#line 2890
      goto _L___4;
    } else
#line 2890
    if ((int )retval == 4) {
#line 2890
      goto _L___4;
    } else
#line 2890
    if ((int )retval == 9) {
      _L___4: /* CIL Label */ 
#line 2891
      if (xjndx != xindx) {
        {
#line 2892
        pseretval = pseupdate(xjndx, xindx, p_xjcand, abarj, v, betai);
        }
      } else {
#line 2894
        pseretval = (dyret_enum )1;
#line 2895
        *p_xjcand = 0;
      }
    } else {
#line 2897
      pseretval = (dyret_enum )1;
    }
#line 2898
    if ((int )pseretval != 1) {
#line 2899
      retval = pseretval;
    } else
#line 2901
    if ((int )retval == 1) {
#line 2902
      if ((int )outretval == -2) {
#line 2902
        retval = (dyret_enum )-2;
      }
    }
  } else
#line 2904
  if ((int )retval == -5) {
#line 2905
    retval = (dyret_enum )-6;
  }
  {
#line 2909
  free((void *)abarj);
  }
#line 2910
  if ((unsigned long )v != (unsigned long )((void *)0)) {
    {
#line 2910
    free((void *)v);
    }
  }
#line 2911
  if ((unsigned long )betai != (unsigned long )((void *)0)) {
    {
#line 2911
    free((void *)betai);
    }
  }
#line 2913
  return (retval);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___2  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 250
double exvec_ssq(double *vec , int len ) ;
#line 550 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
double consys_ssqcol(consys_struct *consys , int colndx ) ;
#line 550
double consys_2normcol(consys_struct *consys , int colndx ) ;
#line 1712 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
double *dy_rho ;
#line 1831
dyret_enum dy_dualout(int *xindx ) ;
#line 1831
dyret_enum dy_dualpivot(int xindx , int outdir , int *p_xjndx , int *p_indir , double *p_cbarj ,
                        double *p_abarij , double *p_delta , int *p_xicand ) ;
#line 1831
dyret_enum dy_dualdegenout(int level___0 ) ;
#line 1873
void dy_dseinit(void) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static degenstats_struct degenstats___0  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
dyret_enum dy_confirmDualPivot(int i , int j , double *abari , double maxabari , double **p_abarj ) 
{ 
  int xipos ;
  double *abarj ;
  double abari_j ;
  double abarj_i ;
  double tol ;
  double err ;
  double pivRating ;
  dyret_enum retval ;
  double pctErr ;
  char const   *rtnnme ;
  int cnt ;
  int xkpos ;
  int printtmp ;
  char const   *tmp ;
  bool tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 200
  pctErr = 1.0e-10;
#line 202
  rtnnme = "confirmDualPivot";
#line 208
  retval = (dyret_enum )0;
#line 210
  *p_abarj = (double *)((void *)0);
#line 211
  xipos = *(dy_var2basis + i);
#line 212
  abari_j = *(abari + j);
#line 217
  abarj = (double *)((void *)0);
#line 218
  tmp___0 = consys_getcol_ex(dy_sys, j, & abarj);
  }
#line 218
  if ((int )tmp___0 == 0) {
    {
#line 219
    tmp = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 219
    errmsg(122, rtnnme, dy_sys->nme, "column", tmp, j);
    }
#line 221
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 221
      free((void *)abarj);
      }
    }
#line 222
    return ((dyret_enum )-10);
  }
#line 225
  if (dy_opts->print.pivoting >= 4) {
    {
#line 226
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tentering column a<%d>:", j);
#line 227
    cnt = 1;
#line 228
    xkpos = 1;
    }
    {
#line 228
    while (1) {
      while_continue: /* CIL Label */ ;
#line 228
      if (! (xkpos <= dy_sys->concnt)) {
#line 228
        goto while_break;
      }
#line 229
      if (*(abarj + xkpos) == (double )0) {
#line 229
        goto __Cont;
      }
#line 230
      cnt = (cnt + 1) % 2;
#line 231
      if (cnt == 0) {
        {
#line 231
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
        }
      }
      {
#line 232
      dyio_outfmt(dy_logchn, dy_gtxecho, "\ta<%d,%d> = %g", xkpos, j, *(abarj + xkpos));
      }
      __Cont: /* CIL Label */ 
#line 228
      xkpos ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 236
  dy_ftran(abarj, (bool )1);
#line 237
  abarj_i = *(abarj + xipos);
  }
#line 240
  if (dy_opts->print.pivoting >= 4) {
    {
#line 241
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tentering column abar<%d> = inv(B)a<%d>:",
                j, j);
#line 243
    cnt = 1;
#line 244
    xkpos = 1;
    }
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (! (xkpos <= dy_sys->concnt)) {
#line 244
        goto while_break___0;
      }
#line 245
      if (*(abarj + xkpos) == (double )0) {
#line 245
        goto __Cont___0;
      }
#line 246
      cnt = (cnt + 1) % 2;
#line 247
      if (cnt == 0) {
        {
#line 247
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
        }
      }
      {
#line 248
      dyio_outfmt(dy_logchn, dy_gtxecho, "\ta<%d,%d> = %g", xkpos, j, *(abarj + xkpos));
      }
      __Cont___0: /* CIL Label */ 
#line 244
      xkpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 253
  printtmp = dy_opts->print.pivoting;
#line 254
  dy_opts->print.pivoting = 0;
#line 257
  pivRating = dy_chkpiv(abarj_i, maxabari);
#line 260
  dy_opts->print.pivoting = printtmp;
#line 266
  err = fabs(abarj_i - abari_j);
#line 267
  tmp___1 = fabs(abarj_i);
#line 267
  tol = pctErr * ((double )1 + tmp___1);
  }
#line 268
  if (err < tol) {
#line 269
    if (pivRating < 1.0) {
#line 270
      retval = (dyret_enum )-1;
    } else {
#line 272
      retval = (dyret_enum )1;
    }
  } else {
#line 289
    if (dy_lp->basis.etas >= 2) {
#line 290
      retval = (dyret_enum )4;
    } else
#line 292
    if (pivRating < 1.0) {
#line 293
      retval = (dyret_enum )-1;
    } else {
#line 295
      retval = (dyret_enum )1;
    }
#line 298
    if (dy_opts->print.dual >= 3) {
      {
#line 299
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      dual pivot numeric drift: ");
#line 300
      tmp___2 = fabs(abari_j - abarj_i);
#line 300
      dyio_outfmt(dy_logchn, dy_gtxecho, "abari<j> = %g, abarj<i> = %g, diff = %g",
                  abari_j, abarj_i, tmp___2);
#line 303
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%g%%); ", tol * (double )100);
#line 304
      tmp___3 = dy_prtdyret(retval);
#line 304
      dyio_outfmt(dy_logchn, dy_gtxecho, "returning %s.", tmp___3);
      }
    }
  }
#line 308
  *p_abarj = abarj;
#line 309
  return (retval);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
bool dualpivrow(int xipos , double *betai , double *abari , double *maxabari ) 
{ 
  int xkndx ;
  flags xkstatus ;
  double abarik ;
  char const   *rtnnme ;
  pkvec_struct *ai ;
  int ndx ;
  int cnt ;
  char const   *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int cnt___0 ;
  double tmp___4 ;

  {
  {
#line 474
  rtnnme = "dualpivrow";
#line 484
  *(betai + xipos) = 1.0;
#line 485
  dy_btran(betai);
  }
#line 492
  if ((unsigned int )dy_lp->phase != 7U) {
#line 492
    if (dy_opts->print.pivoting >= 4) {
      {
#line 494
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    nonbasic coefficients of leaving row a<%d>:",
                  xipos);
#line 496
      ai = (pkvec_struct *)((void *)0);
#line 497
      tmp___0 = consys_getrow_pk(dy_sys, xipos, & ai);
      }
#line 497
      if ((int )tmp___0 == 0) {
        {
#line 498
        tmp = consys_nme(dy_sys, (char )'c', xipos, (bool )1, (char *)((void *)0));
#line 498
        errmsg(122, rtnnme, dy_sys->nme, "row", tmp, xipos);
        }
#line 500
        if ((unsigned long )ai != (unsigned long )((void *)0)) {
          {
#line 500
          pkvec_free(ai);
          }
        }
#line 501
        return ((bool )0);
      }
#line 502
      cnt = 1;
#line 503
      ndx = 0;
      {
#line 503
      while (1) {
        while_continue: /* CIL Label */ ;
#line 503
        if (! (ndx < ai->cnt)) {
#line 503
          goto while_break;
        }
#line 504
        xkndx = (ai->coeffs + ndx)->ndx;
#line 505
        if (*(dy_var2basis + xkndx) == 0) {
#line 506
          cnt = (cnt + 1) % 2;
#line 507
          if (cnt == 0) {
            {
#line 507
            dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
            }
          }
          {
#line 508
          dyio_outfmt(dy_logchn, dy_gtxecho, "\ta<%d,%d> = %g", xipos, xkndx, (ai->coeffs + ndx)->val);
          }
        }
#line 503
        ndx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 510
      pkvec_free(ai);
      }
    }
  }
#line 521
  *maxabari = (double )0;
#line 522
  xkndx = 1;
  {
#line 522
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 522
    if (! (xkndx <= dy_sys->varcnt)) {
#line 522
      goto while_break___0;
    }
#line 523
    xkstatus = *(dy_status + xkndx);
#line 527
    if (xkstatus & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 527
      tmp___1 = 1;
    } else {
#line 527
      tmp___1 = 0;
    }
#line 527
    if (tmp___1) {
#line 527
      goto __Cont;
    }
    {
#line 529
    abarik = consys_dotcol(dy_sys, xkndx, betai);
#line 530
    tmp___3 = fabs(abarik - (double )0);
    }
#line 530
    if (! (tmp___3 <= dy_tols->zero)) {
      {
#line 531
      *(abari + xkndx) = abarik;
#line 532
      tmp___2 = fabs(abarik);
      }
#line 532
      if (tmp___2 > *maxabari) {
        {
#line 532
        *maxabari = fabs(abarik);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 522
    xkndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 538
  if ((unsigned int )dy_lp->phase != 7U) {
#line 538
    if (dy_opts->print.pivoting >= 4) {
#line 538
      goto _L;
    } else {
#line 538
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 538
  if ((unsigned int )dy_lp->phase == 7U) {
#line 538
    if (dy_opts->print.varmgmt >= 3) {
      _L: /* CIL Label */ 
      {
#line 541
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    nonbasic coefficients of transformed row abar<%d>, max %g:",
                  xipos, *maxabari);
#line 544
      cnt___0 = 1;
#line 545
      xkndx = 1;
      }
      {
#line 545
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 545
        if (! (xkndx <= dy_sys->varcnt)) {
#line 545
          goto while_break___1;
        }
        {
#line 546
        tmp___4 = fabs(*(abari + xkndx));
        }
#line 546
        if (tmp___4 < .001 * dy_tols->zero) {
#line 546
          goto __Cont___0;
        }
#line 547
        cnt___0 = (cnt___0 + 1) % 2;
#line 548
        if (cnt___0 == 0) {
          {
#line 548
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
          }
        }
        {
#line 549
        dyio_outfmt(dy_logchn, dy_gtxecho, "\ta<%d,%d> = %g", xipos, xkndx, *(abari + xkndx));
        }
        __Cont___0: /* CIL Label */ 
#line 545
        xkndx ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 564
  return ((bool )1);
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static void dualdegenin(void) 
{ 
  int j ;
  int oldlvl ;
  flags statj ;
  double base ;
  double perturb ;
  char const   *rtnnme ;
  int degencnt ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;

  {
  {
#line 592
  rtnnme = "dualdegenin";
#line 596
  degencnt = 0;
#line 606
  tmp = log10((double )dy_sys->concnt);
#line 606
  tmp___0 = ceil(tmp);
#line 606
  base = pow(10.0, (double )-6 - tmp___0);
  }
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! (base <= dy_tols->cost)) {
#line 607
      goto while_break;
    }
#line 607
    base *= (double )10;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  tmp___1 = dy_lp->degen;
#line 608
  (dy_lp->degen) ++;
#line 608
  oldlvl = tmp___1;
#line 611
  if (dy_opts->print.degen >= 1) {
    {
#line 612
    tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 612
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: antidegeneracy increasing to level %d",
                tmp___2, dy_lp->tot.iters, dy_lp->degen);
#line 616
    dyio_outfmt(dy_logchn, dy_gtxecho, ", base perturbation %g", base);
    }
#line 617
    if (dy_opts->print.degen >= 5) {
      {
#line 617
      dyio_outchr(dy_logchn, dy_gtxecho, (char )':');
      }
    }
  }
#line 620
  if (dy_lp->degen < 25) {
#line 621
    degenstats___0.iterin[dy_lp->degen] = dy_lp->tot.pivs;
  }
#line 649
  j = 1;
  {
#line 649
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 649
    if (! (j <= dy_sys->varcnt)) {
#line 649
      goto while_break___0;
    }
#line 650
    if (*(dy_ddegenset + j) != oldlvl) {
#line 650
      goto __Cont;
    }
#line 651
    statj = *(dy_status + j);
#line 652
    if (statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5)) | (1 << 8))) {
#line 652
      tmp___3 = 1;
    } else {
#line 652
      tmp___3 = 0;
    }
#line 652
    if (tmp___3) {
#line 652
      goto __Cont;
    }
#line 653
    if (*(dy_cbar + j) != 0.0) {
#line 653
      goto __Cont;
    }
#line 662
    *(dy_ddegenset + j) = dy_lp->degen;
    {
#line 664
    if (statj == (flags )(1 << 7)) {
#line 664
      goto case_exp;
    }
#line 667
    if (statj == (flags )(1 << 6)) {
#line 667
      goto case_exp___0;
    }
#line 671
    if (statj == (flags )(1 << 9)) {
#line 671
      goto case_exp___1;
    }
#line 671
    if (statj == (flags )(1 << 8)) {
#line 671
      goto case_exp___1;
    }
#line 676
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 665
    perturb = base * (double )j;
#line 666
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 668
    perturb = - base * (double )j;
#line 669
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
    {
#line 672
    tmp___4 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 672
    tmp___5 = dy_prtvstat(statj);
#line 672
    tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 672
    errmsg(346, rtnnme, dy_sys->nme, tmp___6, dy_lp->tot.iters, tmp___5, tmp___4,
           j);
    }
#line 675
    return;
    switch_default: /* CIL Label */ 
    {
#line 677
    errmsg(1, rtnnme, 677);
    }
#line 678
    return;
    switch_break: /* CIL Label */ ;
    }
#line 679
    *(dy_cbar + j) = perturb;
#line 684
    if (dy_opts->print.degen >= 5) {
      {
#line 685
      tmp___7 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 685
      tmp___8 = dy_prtvstat(statj);
#line 685
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tcbar<%d> perturbed to %g (%s %s).",
                  j, *(dy_cbar + j), tmp___8, tmp___7);
      }
    }
    __Cont: /* CIL Label */ 
#line 649
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 697
  if (dy_opts->print.degen >= 1) {
#line 698
    if (dy_opts->print.degen < 5) {
#line 698
      tmp___9 = ", ";
    } else {
#line 698
      tmp___9 = "\n\ttotal ";
    }
    {
#line 698
    dyio_outfmt(dy_logchn, dy_gtxecho, "%s%d variables.", tmp___9, degencnt);
    }
  }
#line 711
  return;
}
}
#line 715 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
dyret_enum dy_dualdegenout(int level___0 ) 
{ 
  int j ;
  dyret_enum retval ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 744
  if (dy_opts->print.degen >= 1) {
    {
#line 745
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 745
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: antidegeneracy dropping to level %d after %d pivots.",
                tmp, dy_lp->tot.iters, level___0, dy_lp->tot.pivs - degenstats___0.iterin[dy_lp->degen]);
    }
  }
#line 768
  retval = (dyret_enum )1;
#line 774
  j = 1;
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
#line 774
    if (! (j <= dy_sys->varcnt)) {
#line 774
      goto while_break;
    }
#line 776
    if (*(dy_ddegenset + j) > level___0) {
#line 777
      *(dy_ddegenset + j) = level___0;
#line 778
      *(dy_cbar + j) = (double )0;
#line 779
      if (j <= dy_sys->concnt) {
#line 780
        *(dy_y + j) = (double )0;
      }
#line 782
      if (dy_opts->print.degen >= 5) {
        {
#line 783
        tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 783
        tmp___1 = dy_prtvstat(*(dy_status + j));
#line 783
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tcbar<%d> restored to %g, (%s %s)",
                    j, 0.0, tmp___1, tmp___0);
        }
      }
    }
#line 774
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  dy_lp->degen = level___0;
#line 792
  return (retval);
}
}
#line 893 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static void dualpricexk(int xkndx , int *xindx , double *nbbari , bool *pivreject ) 
{ 
  int xkpos ;
  double deltak ;
  double nbbark ;
  flags xkstatus ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;

  {
#line 927
  rtnnme = "dualpricexk";
#line 933
  xkpos = *(dy_var2basis + xkndx);
#line 934
  xkstatus = *(dy_status + xkndx);
#line 937
  if (dy_opts->print.pricing >= 3) {
    {
#line 938
    tmp = dy_prtvstat(xkstatus);
#line 938
    tmp___0 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 938
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; ", tmp___0,
                xkndx, tmp);
    }
  }
#line 949
  if (xkstatus & (unsigned int )(1 << 11)) {
#line 949
    tmp___1 = 1;
  } else {
#line 949
    tmp___1 = 0;
  }
#line 949
  if (tmp___1) {
#line 950
    deltak = *(dy_sys->vlb + xkndx) - *(dy_x + xkndx);
  } else {
#line 952
    deltak = *(dy_x + xkndx) - *(dy_sys->vub + xkndx);
  }
  {
#line 953
  tmp___2 = sqrt(*(dy_rho + xkpos));
#line 953
  nbbark = deltak / tmp___2;
  }
#line 955
  if (dy_opts->print.pricing >= 3) {
    {
#line 956
    tmp___3 = sqrt(*(dy_rho + xkpos));
#line 956
    dyio_outfmt(dy_logchn, dy_gtxecho, "bbar<k> = %g, ||beta<k>|| = %g, |bbar<k>|/||beta<k>|| = %g.",
                deltak, tmp___3, nbbark);
    }
  }
  {
#line 960
  tmp___5 = fabs(deltak - (double )0);
  }
#line 960
  if (tmp___5 <= dy_tols->pfeas * dy_tols->bogus) {
    {
#line 961
    tmp___4 = fabs(deltak - (double )0);
    }
#line 961
    if (tmp___4 <= dy_tols->pfeas) {
#line 964
      if (dy_opts->print.pricing >= 3) {
        {
#line 965
        dyio_outfmt(dy_logchn, dy_gtxecho, " << zero!? >>");
#line 966
        errmsg(1, rtnnme, 966);
        }
      }
#line 968
      return;
    } else
#line 970
    if (dy_lp->basis.etas > 1) {
#line 973
      if (dy_opts->print.pricing >= 3) {
        {
#line 974
        dyio_outfmt(dy_logchn, dy_gtxecho, " << bogus >>");
        }
      }
#line 976
      return;
    }
  }
#line 977
  if (xkstatus & (1U << (sizeof(flags ) * 8UL - 2UL))) {
#line 977
    tmp___6 = 1;
  } else {
#line 977
    tmp___6 = 0;
  }
#line 977
  if (tmp___6) {
#line 978
    *pivreject = (bool )1;
#line 980
    if (dy_opts->print.pricing >= 3) {
      {
#line 981
      dyio_outfmt(dy_logchn, dy_gtxecho, " << reject >>");
      }
    }
#line 983
    return;
  }
#line 988
  if (nbbark > *nbbari) {
#line 989
    *nbbari = nbbark;
#line 990
    *xindx = xkndx;
#line 992
    if (dy_opts->print.pricing >= 3) {
      {
#line 993
      dyio_outfmt(dy_logchn, dy_gtxecho, " << supplant >>");
      }
    }
#line 995
    return;
  } else {
#line 999
    if (dy_opts->print.pricing >= 3) {
      {
#line 1000
      dyio_outfmt(dy_logchn, dy_gtxecho, " << inferior >>");
      }
    }
#line 1002
    return;
  }
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
dyret_enum dy_dualout(int *xindx ) 
{ 
  int xkndx ;
  int xkpos ;
  flags xkstatus ;
  bool pivreject ;
  double candbbari ;
  dyret_enum retval ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 1043
  rtnnme = "dy_dualout";
#line 1046
  retval = (dyret_enum )0;
#line 1049
  if (dy_opts->print.pricing >= 1) {
    {
#line 1050
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: pricing %d rows from %d for %d candidate.",
                rtnnme, dy_sys->concnt, 1, 1);
    }
  }
#line 1055
  candbbari = (double )0;
#line 1056
  *xindx = 0;
#line 1057
  pivreject = (bool )0;
#line 1062
  xkpos = 1;
  {
#line 1062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1062
    if (! (xkpos <= dy_sys->concnt)) {
#line 1062
      goto while_break;
    }
#line 1063
    xkndx = *(dy_basis + xkpos);
#line 1064
    xkstatus = *(dy_status + xkndx);
#line 1065
    if (xkstatus & (unsigned int )((1 << 11) | (1 << 10))) {
#line 1065
      tmp___1 = 0;
    } else {
#line 1065
      tmp___1 = 1;
    }
#line 1065
    if (tmp___1) {
#line 1068
      if (dy_opts->print.pricing >= 3) {
        {
#line 1069
        tmp = dy_prtvstat(xkstatus);
#line 1069
        tmp___0 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1069
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; << status >>",
                    tmp___0, xkndx, tmp);
        }
      }
#line 1074
      goto __Cont;
    }
    {
#line 1075
    dualpricexk(xkndx, xindx, & candbbari, & pivreject);
    }
    __Cont: /* CIL Label */ 
#line 1062
    xkpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1090
  if (*xindx == 0) {
#line 1091
    if ((int )pivreject == 1) {
#line 1092
      retval = (dyret_enum )6;
    } else {
#line 1094
      retval = (dyret_enum )7;
    }
  } else {
#line 1096
    retval = (dyret_enum )1;
  }
#line 1099
  if (dy_opts->print.pricing >= 2) {
#line 1100
    if (*xindx != 0) {
      {
#line 1101
      tmp___2 = dy_prtvstat(*(dy_status + *xindx));
#line 1101
      tmp___3 = consys_nme(dy_sys, (char )'v', *xindx, (bool )1, (char *)((void *)0));
#line 1101
      tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1101
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: selected %s (%d) %s to leave, DSE price %g.",
                  tmp___4, dy_lp->tot.iters, tmp___3, *xindx, tmp___2, candbbari);
      }
    } else {
      {
#line 1107
      tmp___5 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1107
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: no suitable candidates.",
                  tmp___5, dy_lp->tot.iters);
      }
    }
  }
#line 1109
  if (dy_opts->print.pricing >= 1) {
#line 1110
    if ((int )retval == 6) {
      {
#line 1111
      tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1111
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: all suitable x<i> on rejected pivot list.",
                  tmp___6, dy_lp->tot.iters);
      }
    }
  }
#line 1116
  return (retval);
}
}
#line 1120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static double ddirdothyper(int xindx , double *abari , int diri , int xqndx , int dirq ) 
{ 
  double normaq ;
  double abariq ;
  double dotprod ;
  double tmp ;

  {
  {
#line 1161
  abariq = *(abari + xqndx);
#line 1162
  normaq = consys_2normcol(dy_sys, xqndx);
#line 1163
  dotprod = ((double )(- dirq * diri) * abariq) / (normaq + (double )1);
#line 1164
  tmp = fabs(dotprod);
  }
#line 1164
  if (tmp < dy_tols->zero) {
#line 1164
    dotprod = (double )0;
  }
#line 1166
  return (dotprod);
}
}
#line 1170 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static double bdothyper(int xqndx , int dirq ) 
{ 
  double dotprod ;
  double normq ;
  double tmp ;
  double tmp___0 ;

  {
#line 1209
  if (xqndx <= dy_sys->concnt) {
#line 1210
    dotprod = *(dy_sys->rhs + xqndx);
  } else {
    {
#line 1216
    dotprod = consys_dotcol(dy_sys, xqndx, dy_sys->rhs);
#line 1217
    tmp = consys_ssqcol(dy_sys, xqndx);
#line 1217
    normq = sqrt(tmp + (double )1);
    }
#line 1218
    if (dirq > 0) {
#line 1219
      dotprod += *(dy_sys->vlb + xqndx);
    } else {
#line 1221
      dotprod += *(dy_sys->vub + xqndx);
    }
#line 1222
    dotprod /= normq;
  }
  {
#line 1224
  dotprod = (double )dirq * dotprod;
#line 1225
  tmp___0 = fabs(dotprod);
  }
#line 1225
  if (tmp___0 < dy_tols->zero) {
#line 1225
    dotprod = (double )0;
  }
#line 1227
  return (dotprod);
}
}
#line 1231 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static dyret_enum dualin(int xindx , int outdir , int *xjndx , int *indir , double *abari ,
                         double maxabari , double **p_abarj ) 
{ 
  int reject ;
  int xkndx ;
  int degencnt ;
  int dirk ;
  flags xkstatus ;
  double deltak ;
  double abarik ;
  double ratioik ;
  double deltamax ;
  double abarij ;
  double ratioij ;
  double bdotaj ;
  double bdotak ;
  bool newxj ;
  dyret_enum retval ;
  dyret_enum confirm ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  double tmp___16 ;
  char const   *tmp___17 ;
  double tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;

  {
#line 1297
  rtnnme = "dualin";
#line 1299
  retval = (dyret_enum )0;
#line 1302
  if (dy_opts->print.pivoting >= 1) {
    {
#line 1303
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1303
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: selecting entering variable",
                tmp, dy_lp->tot.iters + 1);
    }
#line 1305
    if (dy_opts->print.pivoting >= 2) {
#line 1306
      if (outdir > 0) {
#line 1306
        tmp___0 = "increasing";
      } else {
#line 1306
        tmp___0 = "decreasing";
      }
      {
#line 1306
      tmp___1 = consys_nme(dy_sys, (char )'c', *(dy_var2basis + xindx), (bool )0,
                           (char *)((void *)0));
#line 1306
      tmp___2 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1306
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s (%d) leaving %s (%d) %s", tmp___2,
                  xindx, tmp___1, *(dy_var2basis + xindx), tmp___0);
#line 1310
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tVariable\tcbar<k>\tabar<i,k>\tdelta\tDisp");
      }
    }
  }
#line 1314
  deltamax = dy_tols->inf;
#line 1315
  *xjndx = 0;
#line 1316
  *indir = 0;
#line 1317
  abarij = (double )0;
#line 1318
  ratioij = QNaNbits___2.fpdbl;
#line 1319
  bdotaj = QNaNbits___2.fpdbl;
#line 1320
  dirk = 0;
#line 1332
  newxj = (bool )0;
#line 1333
  degencnt = 0;
#line 1334
  bdotak = (double )0;
#line 1335
  xkndx = 1;
  {
#line 1335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1335
    if (! (xkndx <= dy_sys->varcnt)) {
#line 1335
      goto while_break;
    }
#line 1336
    if (dy_lp->degen > 0) {
#line 1336
      if (*(dy_ddegenset + xkndx) != dy_lp->degen) {
#line 1336
        goto __Cont;
      }
    }
#line 1337
    xkstatus = *(dy_status + xkndx);
#line 1355
    reject = 0;
#line 1356
    abarik = *(abari + xkndx);
#line 1357
    if (xkstatus & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 1357
      tmp___8 = 1;
    } else {
#line 1357
      tmp___8 = 0;
    }
#line 1357
    if (tmp___8) {
#line 1358
      reject = -1;
    } else {
      {
#line 1360
      tmp___7 = fabs(abarik - 0.0);
      }
#line 1360
      if (tmp___7 <= dy_tols->zero) {
#line 1361
        reject = -2;
      } else
#line 1363
      if (outdir == -1) {
#line 1364
        if (xkstatus & (unsigned int )(1 << 6)) {
#line 1364
          tmp___3 = 1;
        } else {
#line 1364
          tmp___3 = 0;
        }
#line 1364
        if (tmp___3) {
#line 1364
          if (abarik > (double )0) {
#line 1366
            reject = -3;
          } else {
#line 1364
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 1364
          if (xkstatus & (unsigned int )(1 << 7)) {
#line 1364
            tmp___4 = 1;
          } else {
#line 1364
            tmp___4 = 0;
          }
#line 1364
          if (tmp___4) {
#line 1364
            if (abarik < (double )0) {
#line 1366
              reject = -3;
            }
          }
        }
      } else {
#line 1368
        if (xkstatus & (unsigned int )(1 << 6)) {
#line 1368
          tmp___5 = 1;
        } else {
#line 1368
          tmp___5 = 0;
        }
#line 1368
        if (tmp___5) {
#line 1368
          if (abarik < (double )0) {
#line 1370
            reject = -3;
          } else {
#line 1368
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 1368
          if (xkstatus & (unsigned int )(1 << 7)) {
#line 1368
            tmp___6 = 1;
          } else {
#line 1368
            tmp___6 = 0;
          }
#line 1368
          if (tmp___6) {
#line 1368
            if (abarik > (double )0) {
#line 1370
              reject = -3;
            }
          }
        }
      }
    }
#line 1373
    if (dy_opts->print.pivoting >= 3) {
      {
#line 1375
      tmp___9 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1375
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___9, xkndx);
#line 1377
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t%g\t%g", *(dy_cbar + xkndx), abarik);
      }
    } else
#line 1373
    if (dy_opts->print.pivoting >= 2) {
#line 1373
      if (reject >= 0) {
        {
#line 1375
        tmp___9 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1375
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___9, xkndx);
#line 1377
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%g\t%g", *(dy_cbar + xkndx), abarik);
        }
      }
    }
#line 1378
    if (dy_opts->print.pivoting >= 3) {
      {
#line 1380
      if (reject == -1) {
#line 1380
        goto case_neg_1;
      }
#line 1384
      if (reject == -2) {
#line 1384
        goto case_neg_2;
      }
#line 1387
      if (reject == -3) {
#line 1387
        goto case_neg_3;
      }
#line 1379
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 1381
      tmp___10 = dy_prtvstat(xkstatus);
#line 1381
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- status %s", tmp___10);
      }
#line 1383
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 1385
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- zero pivot");
      }
#line 1386
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 1388
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- wrong sign");
      }
#line 1389
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1395
    if (reject < 0) {
#line 1395
      goto __Cont;
    }
#line 1396
    if (outdir == -1) {
#line 1397
      if (abarik > (double )0) {
#line 1398
        dirk = 1;
      } else {
#line 1400
        dirk = -1;
      }
    } else
#line 1402
    if (abarik > (double )0) {
#line 1403
      dirk = -1;
    } else {
#line 1405
      dirk = 1;
    }
    {
#line 1410
    deltak = fabs(*(dy_cbar + xkndx) / abarik);
    }
#line 1412
    if (dy_opts->print.pivoting >= 2) {
      {
#line 1413
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t%g", deltak);
      }
    }
#line 1423
    ratioik = QNaNbits___2.fpdbl;
#line 1424
    if (deltak < deltamax) {
      {
#line 1425
      newxj = (bool )1;
#line 1426
      ratioik = dy_chkpiv(abarik, maxabari);
      }
#line 1428
      if (dy_opts->print.pivoting >= 2) {
        {
#line 1429
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%g)", deltamax - deltak);
        }
      }
#line 1431
      degencnt = 0;
    } else
#line 1439
    if (deltak == deltamax) {
      {
#line 1440
      ratioik = dy_chkpiv(abarik, maxabari);
      }
#line 1441
      if (ratioik >= 1.0) {
        {
#line 1443
        if (dy_opts->degenlite == 0) {
#line 1443
          goto case_0;
        }
#line 1446
        if (dy_opts->degenlite == 1) {
#line 1446
          goto case_1;
        }
#line 1451
        if (dy_opts->degenlite == 3) {
#line 1451
          goto case_3;
        }
#line 1451
        if (dy_opts->degenlite == 2) {
#line 1451
          goto case_3;
        }
#line 1473
        if (dy_opts->degenlite == 5) {
#line 1473
          goto case_5;
        }
#line 1473
        if (dy_opts->degenlite == 4) {
#line 1473
          goto case_5;
        }
#line 1442
        goto switch_break___0;
        case_0: /* CIL Label */ 
#line 1444
        if (ratioik > ratioij) {
#line 1444
          newxj = (bool )1;
        }
#line 1445
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 1447
        if (ratioik > ratioij) {
#line 1447
          newxj = (bool )1;
        }
#line 1448
        degencnt ++;
#line 1449
        goto switch_break___0;
        case_3: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 1452
        if (dy_opts->degenlite == 2) {
#line 1453
          if (degencnt == 0) {
            {
#line 1453
            bdotaj = bdothyper(*xjndx, *indir);
            }
          }
          {
#line 1454
          bdotak = bdothyper(xkndx, dirk);
          }
        } else {
#line 1456
          if (degencnt == 0) {
            {
#line 1457
            bdotaj = ddirdothyper(xindx, abari, outdir, *xjndx, *indir);
            }
          }
          {
#line 1458
          bdotak = ddirdothyper(xindx, abari, outdir, xkndx, dirk);
          }
        }
#line 1459
        degencnt ++;
#line 1460
        if (bdotaj > (double )0) {
#line 1460
          if (! (bdotak <= (double )0)) {
#line 1460
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1463
        if (bdotaj <= (double )0) {
#line 1463
          if (bdotak > (double )0) {
#line 1464
            newxj = (bool )1;
          } else {
#line 1463
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 1466
          tmp___11 = fabs(bdotaj);
#line 1466
          tmp___12 = fabs(bdotak);
          }
#line 1466
          if (tmp___11 > tmp___12) {
#line 1467
            newxj = (bool )1;
          } else
#line 1469
          if (bdotaj == bdotak) {
#line 1470
            if (ratioik > ratioij) {
#line 1470
              newxj = (bool )1;
            }
          }
        }
#line 1471
        goto switch_break___0;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 1474
        if (dy_opts->degenlite == 4) {
#line 1475
          if (degencnt == 0) {
            {
#line 1475
            bdotaj = bdothyper(*xjndx, *indir);
            }
          }
          {
#line 1476
          bdotak = bdothyper(xkndx, dirk);
          }
        } else {
#line 1478
          if (degencnt == 0) {
            {
#line 1479
            bdotaj = ddirdothyper(xindx, abari, outdir, *xjndx, *indir);
            }
          }
          {
#line 1480
          bdotak = ddirdothyper(xindx, abari, outdir, xkndx, dirk);
          }
        }
#line 1481
        degencnt ++;
#line 1482
        if (bdotak > bdotaj) {
#line 1482
          newxj = (bool )1;
        }
#line 1483
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 1487
    if (dy_opts->print.pivoting >= 2) {
      {
#line 1488
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%g)", deltamax - deltak);
      }
    }
#line 1495
    if ((int )newxj == 1) {
#line 1496
      deltamax = deltak;
#line 1497
      *xjndx = xkndx;
#line 1498
      *indir = dirk;
#line 1499
      abarij = abarik;
#line 1500
      ratioij = ratioik;
#line 1501
      bdotaj = bdotak;
#line 1502
      newxj = (bool )0;
#line 1504
      if (dy_opts->print.pivoting >= 2) {
#line 1505
        if (xkstatus & (unsigned int )(1 << 6)) {
#line 1505
          tmp___15 = 1;
        } else {
#line 1505
          tmp___15 = 0;
        }
#line 1505
        if (tmp___15) {
#line 1505
          tmp___14 = "ub";
        } else {
#line 1505
          tmp___14 = "lb";
        }
        {
#line 1505
        dyio_outfmt(dy_logchn, dy_gtxecho, "\tentering from %s", tmp___14);
        }
      }
#line 1508
      if (dy_opts->degenlite == 0) {
#line 1508
        if (deltak == (double )0) {
#line 1508
          if (ratioij >= 1.0) {
#line 1508
            goto while_break;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1335
    xkndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1515
  if ((int )retval == 0) {
#line 1515
    goto case_0___0;
  }
#line 1539
  goto switch_default;
  case_0___0: /* CIL Label */ 
#line 1516
  if (deltamax < dy_tols->inf) {
#line 1517
    if (ratioij >= 1.0) {
#line 1518
      if (dy_lp->basis.etas > 1) {
        {
#line 1518
        tmp___18 = fabs(abarij - (double )0);
        }
#line 1518
        if (tmp___18 <= dy_tols->bogus * dy_tols->zero) {
          {
#line 1520
          retval = (dyret_enum )4;
#line 1522
          tmp___16 = fabs(abarij);
#line 1522
          tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1522
          warn(381, rtnnme, dy_sys->nme, tmp___17, dy_lp->tot.iters + 1, "abar", xindx,
               *xjndx, abarij, dy_tols->bogus * dy_tols->zero, dy_tols->bogus * dy_tols->zero - tmp___16);
          }
        } else {
#line 1518
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1529
      if (deltamax == (double )0) {
#line 1530
        retval = (dyret_enum )-2;
      } else {
#line 1532
        retval = (dyret_enum )1;
      }
    } else {
#line 1534
      retval = (dyret_enum )-1;
    }
  } else {
#line 1536
    *xjndx = -1;
#line 1537
    retval = (dyret_enum )8;
  }
#line 1538
  goto switch_break___1;
  switch_default: /* CIL Label */ 
  {
#line 1540
  errmsg(1, rtnnme, 1540);
  }
#line 1541
  return ((dyret_enum )-10);
  switch_break___1: /* CIL Label */ ;
  }
#line 1545
  if ((int )retval == 1) {
#line 1545
    goto _L___4;
  } else
#line 1545
  if ((int )retval == -2) {
    _L___4: /* CIL Label */ 
    {
#line 1546
    confirm = dy_confirmDualPivot(xindx, *xjndx, abari, maxabari, p_abarj);
    }
#line 1547
    if ((int )confirm != 1) {
#line 1548
      retval = confirm;
    }
  }
#line 1553
  if (dy_opts->print.pivoting == 1) {
    {
#line 1554
    dyio_outfmt(dy_logchn, dy_gtxecho, "...");
    }
  }
#line 1555
  if ((int )retval == 1) {
#line 1555
    goto _L___5;
  } else
#line 1555
  if ((int )retval == -2) {
    _L___5: /* CIL Label */ 
#line 1555
    if (dy_opts->print.pivoting >= 1) {
      {
#line 1556
      tmp___19 = consys_nme(dy_sys, (char )'v', *xjndx, (bool )0, (char *)((void *)0));
#line 1556
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    selected %s (%d) to enter from ",
                  tmp___19, *xjndx);
      }
#line 1558
      if (*indir > 0) {
        {
#line 1559
        dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", "lb", *(dy_sys->vlb + *xjndx));
        }
      } else {
        {
#line 1562
        dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", "ub", *(dy_sys->vub + *xjndx));
        }
      }
      {
#line 1564
      dyio_outfmt(dy_logchn, dy_gtxecho, "abar<%d,%d> = %g, cbar<%d> = %g, delta = %g.",
                  xindx, *xjndx, abarij, *xjndx, *(dy_cbar + *xjndx), deltamax);
      }
    }
  }
#line 1567
  if ((int )retval == -2) {
#line 1567
    if (dy_opts->print.dual >= 3) {
      {
#line 1568
      tmp___20 = consys_nme(dy_sys, (char )'v', *xjndx, (bool )0, (char *)((void *)0));
#line 1568
      tmp___21 = dy_prtvstat(*(dy_status + *xjndx));
#line 1568
      tmp___22 = dy_prtdyret(retval);
#line 1568
      tmp___23 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1568
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n   (%s)%d: %s %s %s (%d), cbar<%d> = %g",
                  tmp___23, dy_lp->tot.iters + 1, tmp___22, tmp___21, tmp___20, *xjndx,
                  *xjndx, *(dy_cbar + *xjndx));
      }
#line 1574
      if (dy_opts->degenlite >= 2) {
#line 1574
        if (dy_opts->degenlite <= 5) {
#line 1575
          if (degencnt > 0) {
            {
#line 1576
            dyio_outfmt(dy_logchn, dy_gtxecho, ", align = %g, deg = %d.", bdotaj,
                        degencnt);
            }
          }
        } else {
          {
#line 1579
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
          }
        }
      } else {
        {
#line 1579
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
  }
#line 1582
  return (retval);
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static dyret_enum dseupdate(int xindx , int xjndx , int *candxi , double *tau , double *betai ,
                            double *abari , double *abarj ) 
{ 
  int xipos ;
  int xkndx ;
  int xkpos ;
  double abarij ;
  double abarkj ;
  double cbarj ;
  double abarik ;
  double cbark ;
  double rhoi ;
  double rhok ;
  double alphak ;
  double candbbari ;
  double deltak ;
  double *betak ;
  flags xjstatus ;
  flags xkstatus ;
  bool pivreject ;
  bool recalc ;
  dyret_enum retval ;
  bool accurate ;
  bool badguess ;
  char const   *tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  void *tmp___7 ;
  double tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;

  {
  {
#line 1660
  *candxi = 0;
#line 1661
  candbbari = (double )0;
#line 1662
  pivreject = (bool )0;
#line 1663
  retval = (dyret_enum )0;
#line 1665
  xipos = *(dy_var2basis + xjndx);
#line 1666
  abarij = *(abari + xjndx);
#line 1667
  cbarj = *(dy_cbar + xjndx);
#line 1668
  xjstatus = *(dy_status + xjndx);
#line 1669
  rhoi = *(tau + xipos);
#line 1691
  tmp___13 = fabs(*(dy_rho + xipos) - rhoi);
  }
#line 1691
  if (tmp___13 <= dy_tols->reframe * ((double )1 + rhoi)) {
#line 1728
    *(dy_rho + xipos) = rhoi;
#line 1729
    betak = (double *)((void *)0);
#line 1730
    xkpos = 1;
    {
#line 1730
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1730
      if (! (xkpos <= dy_sys->concnt)) {
#line 1730
        goto while_break;
      }
#line 1731
      recalc = (bool )0;
#line 1732
      xkndx = *(dy_basis + xkpos);
#line 1733
      if (xkpos == xipos) {
        {
#line 1734
        rhok = rhoi / (abarij * abarij);
#line 1735
        tmp___5 = fabs(abarij);
        }
#line 1735
        if (tmp___5 < 1.0e-5) {
#line 1735
          recalc = (bool )1;
        }
      } else {
#line 1737
        abarkj = *(abarj + xkpos);
#line 1738
        if (abarkj != 0.0) {
          {
#line 1739
          rhok = (double )0;
#line 1740
          tmp___6 = fabs(abarkj / abarij);
          }
#line 1740
          if (tmp___6 > 1.0e5) {
#line 1740
            recalc = (bool )1;
          }
#line 1741
          alphak = - (((double )2 * *(tau + xkpos)) * abarkj) / abarij;
#line 1742
          rhok += alphak;
#line 1743
          alphak = ((rhoi * abarkj) * abarkj) / (abarij * abarij);
#line 1744
          rhok += alphak;
#line 1745
          if (*(dy_rho + xkpos) > 1.0e8) {
#line 1745
            if (rhok < - 1.0e8) {
#line 1745
              recalc = (bool )1;
            }
          }
#line 1746
          rhok += *(dy_rho + xkpos);
        } else {
#line 1748
          rhok = *(dy_rho + xkpos);
        }
      }
#line 1763
      if ((int )recalc == 1) {
#line 1763
        goto _L___0;
      } else
#line 1763
      if (rhok < 0.0) {
        _L___0: /* CIL Label */ 
#line 1764
        if ((unsigned long )betak == (unsigned long )((void *)0)) {
          {
#line 1765
          tmp___7 = calloc((size_t )(dy_sys->concnt + 1), sizeof(double ));
#line 1765
          betak = (double *)tmp___7;
          }
        } else {
          {
#line 1767
          memset((void *)betak, 0, (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
          }
        }
        {
#line 1768
        *(betak + xkpos) = 1.0;
#line 1769
        dy_btran(betak);
#line 1770
        cbark = exvec_ssq(betak, dy_sys->concnt);
#line 1772
        tmp___8 = fabs(rhok - cbark);
        }
#line 1772
        if (tmp___8 <= dy_tols->cost * ((double )1 + cbark)) {
#line 1773
          accurate = (bool )1;
        } else {
#line 1775
          accurate = (bool )0;
        }
#line 1776
        if ((int )accurate == (int )recalc) {
#line 1777
          badguess = (bool )1;
        } else {
#line 1779
          badguess = (bool )0;
        }
#line 1780
        if (dy_opts->print.dual >= 5) {
#line 1780
          goto _L;
        } else
#line 1780
        if (dy_opts->print.dual >= 3) {
#line 1780
          if ((int )accurate == 0) {
#line 1780
            if ((int )badguess == 1) {
              _L: /* CIL Label */ 
              {
#line 1782
              tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1782
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t(%s)%d: recalculated rho<%d>; ",
                          tmp___9, dy_lp->tot.iters, xkpos);
#line 1786
              dyio_outfmt(dy_logchn, dy_gtxecho, "original %g, updated %g, correct %g, error %g;",
                          *(dy_rho + xkpos), rhok, cbark, rhok - cbark);
              }
#line 1789
              if ((int )badguess == 1) {
                {
#line 1790
                dyio_outfmt(dy_logchn, dy_gtxecho, " bad guess.");
                }
              } else {
                {
#line 1792
                dyio_outfmt(dy_logchn, dy_gtxecho, " good guess.");
                }
              }
            }
          }
        }
#line 1794
        *(dy_rho + xkpos) = cbark;
      } else {
#line 1796
        *(dy_rho + xkpos) = rhok;
      }
#line 1802
      xkstatus = *(dy_status + xkndx);
#line 1803
      if (xkstatus & (unsigned int )((1 << 11) | (1 << 10))) {
#line 1803
        tmp___12 = 0;
      } else {
#line 1803
        tmp___12 = 1;
      }
#line 1803
      if (tmp___12) {
#line 1806
        if (dy_opts->print.pricing >= 3) {
          {
#line 1807
          tmp___10 = dy_prtvstat(xkstatus);
#line 1807
          tmp___11 = consys_nme(dy_sys, (char )'v', xkndx, (bool )1, (char *)((void *)0));
#line 1807
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; << status >>",
                      tmp___11, xkndx, tmp___10);
          }
        }
#line 1812
        goto __Cont___0;
      }
      {
#line 1813
      dualpricexk(xkndx, candxi, & candbbari, & pivreject);
      }
      __Cont___0: /* CIL Label */ 
#line 1730
      xkpos ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1814
    if ((unsigned long )betak != (unsigned long )((void *)0)) {
      {
#line 1814
      free((void *)betak);
      }
    }
  } else {
#line 1694
    if (dy_opts->print.pivoting >= 1) {
      {
#line 1695
      tmp = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1695
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1695
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %s: (%s)%d: resetting DSE norms; trigger %s (%d), pos\'n %d",
                  dy_sys->nme, tmp___0, dy_lp->tot.iters, tmp, xindx, xipos);
#line 1699
      tmp___1 = fabs(rhoi - *(dy_rho + xipos));
#line 1699
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\texact rho<i> = %g, approx = %g, error = %g, tol = %g.",
                  rhoi, *(dy_rho + xipos), tmp___1, dy_tols->reframe * rhoi);
      }
    } else
#line 1694
    if (dy_opts->print.dual >= 1) {
      {
#line 1695
      tmp = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1695
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1695
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %s: (%s)%d: resetting DSE norms; trigger %s (%d), pos\'n %d",
                  dy_sys->nme, tmp___0, dy_lp->tot.iters, tmp, xindx, xipos);
#line 1699
      tmp___1 = fabs(rhoi - *(dy_rho + xipos));
#line 1699
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\texact rho<i> = %g, approx = %g, error = %g, tol = %g.",
                  rhoi, *(dy_rho + xipos), tmp___1, dy_tols->reframe * rhoi);
      }
    }
    {
#line 1704
    dy_dseinit();
#line 1705
    xkpos = 1;
    }
    {
#line 1705
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1705
      if (! (xkpos <= dy_sys->concnt)) {
#line 1705
        goto while_break___0;
      }
#line 1706
      xkndx = *(dy_basis + xkpos);
#line 1707
      xkstatus = *(dy_status + xkndx);
#line 1708
      if (xkstatus & (unsigned int )((1 << 11) | (1 << 10))) {
#line 1708
        tmp___4 = 0;
      } else {
#line 1708
        tmp___4 = 1;
      }
#line 1708
      if (tmp___4) {
#line 1711
        if (dy_opts->print.pricing >= 3) {
          {
#line 1712
          tmp___2 = dy_prtvstat(xkstatus);
#line 1712
          tmp___3 = consys_nme(dy_sys, (char )'v', xkndx, (bool )1, (char *)((void *)0));
#line 1712
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tpricing %s (%d), status %s; << status >>",
                      tmp___3, xkndx, tmp___2);
          }
        }
#line 1717
        goto __Cont;
      }
      {
#line 1718
      dualpricexk(xkndx, candxi, & candbbari, & pivreject);
      }
      __Cont: /* CIL Label */ 
#line 1705
      xkpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1838
  *(dy_cbar + xjndx) = 0.0;
#line 1839
  *(abari + xindx) = 1.0;
#line 1840
  *(dy_cbar + xindx) = 0.0;
#line 1841
  xkndx = 1;
  {
#line 1841
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1841
    if (! (xkndx <= dy_sys->varcnt)) {
#line 1841
      goto while_break___1;
    }
#line 1842
    if (dy_lp->degen > 0) {
#line 1842
      if (*(dy_ddegenset + xkndx) != dy_lp->degen) {
#line 1842
        goto __Cont___1;
      }
    }
#line 1843
    xkstatus = *(dy_status + xkndx);
#line 1847
    if (xkstatus & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 1847
      tmp___14 = 1;
    } else {
#line 1847
      tmp___14 = 0;
    }
#line 1847
    if (tmp___14) {
#line 1847
      goto __Cont___1;
    }
#line 1849
    abarik = *(abari + xkndx);
#line 1850
    deltak = (cbarj * abarik) / abarij;
#line 1851
    if (deltak != (double )0) {
#line 1852
      cbark = *(dy_cbar + xkndx) - deltak;
#line 1853
      if (xkstatus & (unsigned int )(1 << 7)) {
#line 1853
        tmp___17 = 1;
      } else {
#line 1853
        tmp___17 = 0;
      }
#line 1853
      if (tmp___17) {
#line 1853
        if (cbark < - dy_tols->dfeas) {
#line 1853
          goto _L___1;
        } else {
#line 1853
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 1853
        if (xkstatus & (unsigned int )(1 << 6)) {
#line 1853
          tmp___18 = 1;
        } else {
#line 1853
          tmp___18 = 0;
        }
#line 1853
        if (tmp___18) {
#line 1853
          if (cbark > dy_tols->dfeas) {
            _L___1: /* CIL Label */ 
#line 1855
            retval = (dyret_enum )-3;
#line 1857
            if (dy_opts->print.dual >= 5) {
              {
#line 1858
              tmp___15 = dy_prtvstat(xkstatus);
#line 1858
              tmp___16 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 1858
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n      lost dual feasibility, %s (%d) %s,",
                          tmp___16, xkndx, tmp___15);
#line 1862
              dyio_outfmt(dy_logchn, dy_gtxecho, " old = %g, new = %g, abarij =  %g, delta = %g, tol = %g .",
                          *(dy_cbar + xkndx), cbark, abarij, deltak, dy_tols->dfeas);
              }
            }
          }
        }
      }
#line 1867
      *(dy_cbar + xkndx) = cbark;
    }
    __Cont___1: /* CIL Label */ 
#line 1841
    xkndx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1892
  if ((int )retval == -3) {
#line 1893
    if (dy_opts->dpsel.strat > 0) {
#line 1893
      retval = (dyret_enum )0;
    }
  }
#line 1894
  if ((int )retval == 0) {
#line 1895
    if (*candxi == 0) {
#line 1896
      if ((int )pivreject == 1) {
#line 1897
        retval = (dyret_enum )6;
      } else {
#line 1899
        retval = (dyret_enum )7;
      }
    } else {
#line 1901
      retval = (dyret_enum )1;
    }
  }
#line 1904
  if (dy_opts->print.pricing >= 2) {
#line 1905
    if (*candxi != 0) {
      {
#line 1906
      tmp___19 = dy_prtvstat(*(dy_status + *candxi));
#line 1906
      tmp___20 = consys_nme(dy_sys, (char )'v', *candxi, (bool )1, (char *)((void *)0));
#line 1906
      tmp___21 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1906
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: selected %s (%d) %s to leave, DSE price %g.",
                  tmp___21, dy_lp->tot.iters, tmp___20, *candxi, tmp___19, candbbari);
      }
    } else {
      {
#line 1912
      tmp___22 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1912
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: no suitable candidates.",
                  tmp___22, dy_lp->tot.iters);
      }
    }
  }
#line 1914
  if (dy_opts->print.pricing >= 1) {
#line 1915
    if ((int )retval == 6) {
      {
#line 1916
      tmp___23 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1916
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: all suitable x<i> on rejected pivot list.",
                  tmp___23, dy_lp->tot.iters);
      }
    }
  }
#line 1921
  return (retval);
}
}
#line 1925 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
static dyret_enum dualupdate(int xjndx , int indir , int xindx , int outdir , double *abarj ,
                             double *p_delta , double *betai ) 
{ 
  int xkpos ;
  int xkndx ;
  int xipos ;
  double deltai ;
  double xi ;
  double lbi ;
  double ubi ;
  double xj ;
  double cbarj ;
  double deltaj ;
  double abarij ;
  double ubj ;
  double lbj ;
  double deltak ;
  double yk ;
  flags stati ;
  flags statj ;
  dyret_enum retval ;
  dyret_enum upd_retval ;
  bool swing ;
  int swingndx ;
  double swingratio ;
  double maxswing ;
  char const   *rtnnme ;
  flags statk ;
  double tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  double tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  double tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  double tmp___25 ;
  int tmp___26 ;
  double tmp___27 ;
  double tmp___29 ;
  int tmp___30 ;
  double tmp___31 ;
  double tmp___33 ;
  int tmp___34 ;
  double tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  double tmp___38 ;
  char const   *tmp___39 ;
  double tmp___40 ;
  int tmp___41 ;
  double tmp___42 ;
  double tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  double tmp___46 ;
  char *tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;

  {
#line 1971
  rtnnme = "dualupdate";
#line 1980
  retval = (dyret_enum )1;
#line 1981
  swing = (bool )0;
#line 1982
  maxswing = (double )0;
#line 1983
  swingndx = -1;
#line 1985
  statj = *(dy_status + xjndx);
#line 1986
  xj = *(dy_x + xjndx);
#line 1987
  lbj = *(dy_sys->vlb + xjndx);
#line 1988
  ubj = *(dy_sys->vub + xjndx);
#line 1989
  cbarj = *(dy_cbar + xjndx);
#line 1991
  xipos = *(dy_var2basis + xindx);
#line 1992
  stati = *(dy_status + xindx);
#line 1993
  xi = *(dy_xbasic + xipos);
#line 1994
  lbi = *(dy_sys->vlb + xindx);
#line 1995
  ubi = *(dy_sys->vub + xindx);
#line 1996
  abarij = *(abarj + xipos);
#line 2030
  if (outdir > 0) {
#line 2031
    deltai = lbi - xi;
  } else {
#line 2033
    deltai = ubi - xi;
  }
  {
#line 2034
  tmp = fabs(deltai);
  }
#line 2034
  if (tmp < dy_tols->zero) {
#line 2034
    deltai = (double )0;
  }
#line 2035
  if (deltai != (double )0) {
    {
#line 2036
    deltaj = - deltai / abarij;
#line 2037
    tmp___0 = fabs(deltaj);
    }
#line 2037
    if (tmp___0 < dy_tols->zero) {
#line 2037
      deltaj = (double )0;
    }
#line 2039
    if (deltaj == (double )0) {
#line 2039
      if (dy_opts->print.pivoting >= 1) {
#line 2040
        if (outdir < 0) {
#line 2040
          tmp___1 = "ub";
        } else {
#line 2040
          tmp___1 = "lb";
        }
        {
#line 2040
        tmp___2 = dy_prtvstat(stati);
#line 2040
        tmp___3 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2040
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      %s (%d) = %g, %s, leaving at %s, dirty degenerate pivot.",
                    tmp___3, xindx, xi, tmp___2, tmp___1);
        }
      }
    }
  } else {
#line 2047
    deltaj = (double )0;
  }
  {
#line 2048
  *p_delta = fabs(deltaj);
  }
#line 2051
  if (dy_opts->print.dual >= 5) {
    {
#line 2052
    tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2052
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: dual update:", tmp___4, dy_lp->tot.iters + 1);
    }
#line 2054
    if (indir == 1) {
#line 2054
      tmp___5 = "lb ";
    } else {
#line 2054
      tmp___5 = "ub ";
    }
    {
#line 2054
    tmp___6 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2054
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) entering pos\'n %d from %s %g, delta %g, cbarj %g.",
                tmp___6, xjndx, xipos, tmp___5, xj, deltaj, cbarj);
#line 2058
    tmp___7 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2058
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g leaving at ", tmp___7, xindx,
                xi);
    }
#line 2060
    if (outdir == 1) {
      {
#line 2061
      dyio_outfmt(dy_logchn, dy_gtxecho, "lb %g, pivot %g.", lbi, abarij);
      }
    } else {
      {
#line 2063
      dyio_outfmt(dy_logchn, dy_gtxecho, "ub %g, pivot %g.", ubi, abarij);
      }
    }
  }
#line 2079
  if (deltaj != (double )0) {
#line 2080
    if (*(dy_ddegenset + xjndx) == 0) {
#line 2081
      dy_lp->z += cbarj * deltaj;
    }
    {
#line 2082
    upd_retval = dy_updateprimals(xjndx, deltaj, abarj);
    }
    {
#line 2084
    if ((int )upd_retval == 1) {
#line 2084
      goto case_1;
    }
#line 2086
    if ((int )upd_retval == 9) {
#line 2086
      goto case_9;
    }
#line 2091
    if ((int )upd_retval == 4) {
#line 2091
      goto case_4;
    }
#line 2094
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2085
    goto switch_break;
    case_9: /* CIL Label */ 
#line 2087
    swing = (bool )1;
#line 2088
    swingndx = dy_lp->ubnd.ndx;
#line 2089
    maxswing = dy_lp->ubnd.ratio;
#line 2090
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2092
    retval = (dyret_enum )4;
#line 2093
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2095
    errmsg(1, rtnnme, 2095);
#line 2096
    retval = (dyret_enum )-10;
    }
#line 2097
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2098
    stati = *(dy_status + xindx);
#line 2099
    xi = *(dy_x + xindx);
  } else {
#line 2136
    if (lbi == ubi) {
#line 2137
      stati = (flags )1;
    } else
#line 2139
    if (outdir > 0) {
#line 2140
      stati = (flags )(1 << 3);
    } else {
#line 2142
      stati = (flags )(1 << 1);
    }
#line 2143
    *(dy_status + xindx) = stati;
  }
#line 2145
  if ((int )retval == -10) {
#line 2145
    return ((dyret_enum )-10);
  }
#line 2156
  *(dy_var2basis + xjndx) = xipos;
#line 2157
  *(dy_var2basis + xindx) = 0;
#line 2158
  *(dy_basis + xipos) = xjndx;
#line 2160
  if (*(dy_status + xindx) & 1U) {
#line 2160
    tmp___16 = 1;
  } else {
#line 2160
    tmp___16 = 0;
  }
#line 2160
  if (tmp___16) {
#line 2161
    stati = (flags )(1 << 5);
#line 2162
    xi = lbi;
  } else {
#line 2164
    if (*(dy_status + xindx) & (unsigned int )(1 << 3)) {
#line 2164
      tmp___15 = 1;
    } else {
#line 2164
      tmp___15 = 0;
    }
#line 2164
    if (tmp___15) {
#line 2165
      stati = (flags )(1 << 7);
#line 2166
      xi = lbi;
    } else {
#line 2168
      if (*(dy_status + xindx) & (unsigned int )(1 << 1)) {
#line 2168
        tmp___14 = 1;
      } else {
#line 2168
        tmp___14 = 0;
      }
#line 2168
      if (tmp___14) {
#line 2169
        stati = (flags )(1 << 6);
#line 2170
        xi = ubi;
      } else {
#line 2172
        if (lbi == ubi) {
#line 2173
          stati = (flags )(1 << 5);
#line 2174
          xi = lbi;
        } else {
          {
#line 2176
          tmp___8 = fabs(xi - lbi);
#line 2176
          tmp___9 = fabs(xi - ubi);
          }
#line 2176
          if (tmp___8 < tmp___9) {
#line 2177
            stati = (flags )(1 << 7);
#line 2178
            xi = lbi;
          } else {
#line 2180
            stati = (flags )(1 << 6);
#line 2181
            xi = ubi;
          }
        }
#line 2182
        retval = (dyret_enum )4;
#line 2184
        if (dy_opts->print.dual >= 3) {
          {
#line 2185
          tmp___10 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2185
          tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2185
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      (%s)%d: Forced leaving variable %s (%d) = %g",
                      tmp___11, dy_lp->tot.iters, tmp___10, xindx, *(dy_x + xindx));
#line 2189
          tmp___12 = fabs(*(dy_x + xindx) - xi);
          }
#line 2189
          if (stati == (flags )(1 << 6)) {
#line 2189
            tmp___13 = "upper";
          } else {
#line 2189
            tmp___13 = "lower";
          }
          {
#line 2189
          dyio_outfmt(dy_logchn, dy_gtxecho, " to %s bound %g, error %g;", tmp___13,
                      xi, tmp___12);
#line 2192
          dyio_outfmt(dy_logchn, dy_gtxecho, " recommending request refactor.");
          }
        }
      }
    }
  }
#line 2195
  *(dy_status + xindx) = stati;
#line 2196
  *(dy_x + xindx) = xi;
#line 2203
  if (deltaj != (double )0) {
#line 2204
    if (statj & (unsigned int )(1 << 7)) {
#line 2204
      tmp___18 = 1;
    } else {
#line 2204
      tmp___18 = 0;
    }
#line 2204
    if (tmp___18) {
#line 2205
      xj = lbj + deltaj;
    } else {
#line 2207
      if (statj & (unsigned int )(1 << 6)) {
#line 2207
        tmp___17 = 1;
      } else {
#line 2207
        tmp___17 = 0;
      }
#line 2207
      if (tmp___17) {
#line 2208
        xj = ubj + deltaj;
      } else {
#line 2210
        xj = deltaj;
      }
    }
    {
#line 2211
    tmp___19 = fabs(xj);
    }
#line 2211
    if (tmp___19 < dy_tols->zero) {
#line 2211
      xj = (double )0;
    }
#line 2216
    if (statj & (unsigned int )(1 << 8)) {
#line 2216
      tmp___37 = 1;
    } else {
#line 2216
      tmp___37 = 0;
    }
#line 2216
    if (tmp___37) {
#line 2217
      statj = (flags )(1 << 4);
    } else {
      {
#line 2219
      tmp___35 = fabs(ubj);
      }
#line 2219
      if (tmp___35 < dy_tols->inf) {
        {
#line 2219
        tmp___33 = fabs(ubj);
#line 2219
        tmp___34 = ubj - xj > dy_tols->pfeas * (1.0 + tmp___33);
        }
      } else {
#line 2219
        tmp___34 = xj < ubj;
      }
#line 2219
      if (tmp___34) {
        {
#line 2220
        tmp___27 = fabs(lbj);
        }
#line 2220
        if (tmp___27 < dy_tols->inf) {
          {
#line 2220
          tmp___25 = fabs(lbj);
#line 2220
          tmp___26 = xj - lbj > dy_tols->pfeas * (1.0 + tmp___25);
          }
        } else {
#line 2220
          tmp___26 = xj > lbj;
        }
#line 2220
        if (tmp___26) {
#line 2221
          statj = (flags )(1 << 2);
        } else {
          {
#line 2223
          tmp___23 = fabs(lbj);
          }
#line 2223
          if (tmp___23 < dy_tols->inf) {
            {
#line 2223
            tmp___21 = fabs(lbj);
#line 2223
            tmp___22 = lbj - xj > dy_tols->pfeas * (1.0 + tmp___21);
            }
          } else {
#line 2223
            tmp___22 = xj < lbj;
          }
#line 2223
          if (tmp___22) {
#line 2224
            statj = (flags )(1 << 11);
          } else {
#line 2226
            statj = (flags )(1 << 3);
          }
        }
      } else {
        {
#line 2228
        tmp___31 = fabs(ubj);
        }
#line 2228
        if (tmp___31 < dy_tols->inf) {
          {
#line 2228
          tmp___29 = fabs(ubj);
#line 2228
          tmp___30 = xj - ubj > dy_tols->pfeas * (1.0 + tmp___29);
          }
        } else {
#line 2228
          tmp___30 = xj > ubj;
        }
#line 2228
        if (tmp___30) {
#line 2229
          statj = (flags )(1 << 10);
        } else {
#line 2231
          statj = (flags )(1 << 1);
        }
      }
#line 2232
      if (statj & (unsigned int )((1 << 3) | (1 << 1))) {
#line 2232
        tmp___36 = 1;
      } else {
#line 2232
        tmp___36 = 0;
      }
#line 2232
      if (tmp___36) {
#line 2232
        if (lbj == ubj) {
#line 2233
          statj = (flags )1;
        }
      }
    }
#line 2234
    if (dy_lp->basis.etas > 1) {
#line 2234
      if (dy_tols->bogus > 1.0) {
#line 2234
        if (xj != 0.0) {
#line 2234
          if (statj & (unsigned int )(((1 << 3) | 1) | (1 << 1))) {
#line 2234
            tmp___41 = 0;
          } else {
#line 2234
            tmp___41 = 1;
          }
#line 2234
          if (tmp___41) {
            {
#line 2236
            tmp___40 = fabs(xj);
            }
#line 2236
            if (tmp___40 < dy_tols->zero * dy_tols->bogus) {
#line 2237
              retval = (dyret_enum )4;
#line 2239
              if (dy_opts->print.pivoting >= 1) {
                {
#line 2240
                tmp___38 = fabs(xj);
#line 2240
                tmp___39 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2240
                warn(374, rtnnme, dy_sys->nme, tmp___39, dy_lp->tot.iters, "x", xjndx,
                     tmp___38, dy_tols->zero * dy_tols->bogus, dy_tols->zero * dy_tols->bogus - xj);
                }
              }
            }
          }
        }
      }
    }
#line 2245
    if (statj & (unsigned int )((1 << 11) | (1 << 10))) {
#line 2245
      tmp___44 = 1;
    } else {
#line 2245
      tmp___44 = 0;
    }
#line 2245
    if (tmp___44) {
      {
#line 2246
      tmp___42 = fabs(xj);
#line 2246
      tmp___43 = fabs(*(dy_x + xjndx));
#line 2246
      swingratio = (tmp___42 + (double )1) / (tmp___43 + (double )1);
      }
#line 2247
      if (swingratio > dy_tols->swing) {
#line 2248
        swing = (bool )1;
#line 2249
        if (swingratio > maxswing) {
#line 2250
          maxswing = swingratio;
#line 2251
          swingndx = xjndx;
        }
      }
    }
  } else {
#line 2257
    if (statj & (unsigned int )(1 << 7)) {
#line 2257
      tmp___45 = 1;
    } else {
#line 2257
      tmp___45 = 0;
    }
#line 2257
    if (tmp___45) {
#line 2258
      statj = (flags )(1 << 3);
#line 2259
      xj = lbj;
    } else {
#line 2261
      statj = (flags )(1 << 1);
#line 2262
      xj = ubj;
    }
  }
#line 2264
  *(dy_status + xjndx) = statj;
#line 2265
  *(dy_x + xjndx) = xj;
#line 2266
  *(dy_xbasic + xipos) = xj;
#line 2289
  if (dy_lp->degen > 0) {
#line 2290
    xkpos = *(dy_ddegenset + xindx);
#line 2291
    *(dy_ddegenset + xindx) = *(dy_ddegenset + xjndx);
#line 2292
    *(dy_ddegenset + xjndx) = xkpos;
  }
  {
#line 2294
  tmp___46 = fabs(cbarj);
  }
#line 2294
  if (tmp___46 > dy_tols->cost) {
#line 2295
    xkpos = 1;
    {
#line 2295
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2295
      if (! (xkpos <= dy_sys->concnt)) {
#line 2295
        goto while_break;
      }
#line 2296
      xkndx = *(dy_basis + xkpos);
#line 2297
      if (dy_lp->degen > 0) {
#line 2297
        if (*(dy_ddegenset + xkndx) < dy_lp->degen) {
#line 2297
          goto __Cont;
        }
      }
#line 2298
      deltak = cbarj * *(betai + xkpos);
#line 2299
      deltak /= abarij;
#line 2300
      yk = *(dy_y + xkpos) + deltak;
#line 2301
      *(dy_y + xkpos) = yk;
      __Cont: /* CIL Label */ 
#line 2295
      xkpos ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2307
  if ((int )swing == 1) {
#line 2308
    if (dy_lp->sys.cons.loadable > 0) {
#line 2309
      retval = (dyret_enum )9;
    } else
#line 2308
    if (dy_lp->sys.vars.loadable > 0) {
#line 2309
      retval = (dyret_enum )9;
    }
#line 2310
    dy_lp->ubnd.ndx = swingndx;
#line 2311
    dy_lp->ubnd.ratio = maxswing;
#line 2313
    if (dy_opts->print.dual >= 2) {
      {
#line 2314
      xkndx = dy_lp->ubnd.ndx;
#line 2315
      statk = *(dy_status + xkndx);
#line 2316
      tmp___47 = dy_prtvstat(statk);
#line 2316
      tmp___48 = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 2316
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    Pseudo-unbounded: growth %e for %s (%d) %s = %g",
                  dy_lp->ubnd.ratio, tmp___48, xkndx, tmp___47, *(dy_x + xkndx));
      }
#line 2321
      if (statk & (unsigned int )(1 << 10)) {
#line 2321
        tmp___49 = 1;
      } else {
#line 2321
        tmp___49 = 0;
      }
#line 2321
      if (tmp___49) {
        {
#line 2322
        dyio_outfmt(dy_logchn, dy_gtxecho, " > %g.", *(dy_sys->vub + xkndx));
        }
      } else {
        {
#line 2324
        dyio_outfmt(dy_logchn, dy_gtxecho, " < %g.", *(dy_sys->vlb + xkndx));
        }
      }
    }
  }
#line 2332
  if (dy_opts->print.dual >= 5) {
    {
#line 2335
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trevised objective %g.", dy_lp->z);
    }
#line 2344
    if (deltaj != (double )0) {
      {
#line 2345
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    revised dual variables, cbar tolerance %g",
                  dy_tols->dfeas);
#line 2348
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s", "pos\'n", "constraint",
                  "val");
#line 2350
      xkpos = 1;
      }
      {
#line 2350
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2350
        if (! (xkpos <= dy_sys->concnt)) {
#line 2350
          goto while_break___0;
        }
#line 2351
        if (*(betai + xkpos) != (double )0) {
          {
#line 2352
          tmp___50 = consys_nme(dy_sys, (char )'c', xkpos, (bool )0, (char *)((void *)0));
#line 2352
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%20s%16.8g", xkpos, tmp___50, *(dy_y + xkpos));
          }
        }
#line 2350
        xkpos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 2358
  return (retval);
}
}
#line 2363 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dualpivot.c"
dyret_enum dy_dualpivot(int xindx , int outdir , int *p_xjndx , int *p_indir , double *p_cbarj ,
                        double *p_abarij , double *p_delta , int *p_xicand ) 
{ 
  int xipos ;
  int xjndx ;
  int indir ;
  int degen_cyclecnt___0 ;
  double *betai ;
  double *abari ;
  double *tau ;
  double maxabari ;
  double *abarj ;
  dyret_enum retval ;
  dyret_enum inretval ;
  dyret_enum dseretval ;
  dyret_enum confirm ;
  bool validxj ;
  bool reselect ;
  bool patch ;
  flags factorflgs ;
  char const   *rtnnme ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  char const   *tmp___31 ;
  void *tmp___32 ;

  {
#line 2439
  rtnnme = "dy_dualpivot";
#line 2457
  retval = (dyret_enum )0;
#line 2458
  if (*p_xjndx <= 0) {
#line 2459
    *p_xjndx = -1;
#line 2460
    *p_indir = 0;
#line 2461
    validxj = (bool )0;
  } else {
#line 2463
    validxj = (bool )1;
  }
#line 2464
  *p_cbarj = (double )0;
#line 2465
  *p_abarij = QNaNbits___2.fpdbl;
#line 2466
  *p_delta = QNaNbits___2.fpdbl;
#line 2467
  *p_xicand = -1;
#line 2469
  abarj = (double *)((void *)0);
#line 2471
  xipos = *(dy_var2basis + xindx);
#line 2477
  if (dy_opts->print.pivoting >= 1) {
#line 2478
    if (outdir < 0) {
#line 2478
      tmp = "decreasing";
    } else {
#line 2478
      tmp = "increasing";
    }
    {
#line 2478
    tmp___0 = dy_prtvstat(*(dy_status + xindx));
#line 2478
    tmp___1 = consys_nme(dy_sys, (char )'c', xipos, (bool )0, (char *)((void *)0));
#line 2478
    tmp___2 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2478
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: x<%d> (%s) leaving pos\'n %d (%s), status %s, %s from %g, ",
                rtnnme, xindx, tmp___2, xipos, tmp___1, tmp___0, tmp, *(dy_x + xindx));
#line 2484
    dyio_outfmt(dy_logchn, dy_gtxecho, "lb<i> = %g, ub<i> = %g.", *(dy_sys->vlb + xindx),
                *(dy_sys->vub + xindx));
    }
  }
  {
#line 2491
  tmp___3 = calloc((size_t )(dy_sys->concnt + 1), sizeof(double ));
#line 2491
  betai = (double *)tmp___3;
#line 2492
  tmp___4 = calloc((size_t )(dy_sys->varcnt + 1), sizeof(double ));
#line 2492
  abari = (double *)tmp___4;
#line 2493
  tmp___7 = dualpivrow(xipos, betai, abari, & maxabari);
  }
#line 2493
  if ((int )tmp___7 == 0) {
    {
#line 2494
    tmp___5 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2494
    tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2494
    errmsg(392, rtnnme, dy_sys->nme, tmp___6, dy_lp->tot.iters, xipos, xipos, tmp___5,
           xindx);
#line 2497
    free((void *)betai);
#line 2498
    free((void *)abari);
    }
#line 2499
    return ((dyret_enum )-10);
  }
#line 2525
  if ((int )validxj == 0) {
#line 2526
    reselect = (bool )1;
#line 2527
    degen_cyclecnt___0 = 0;
    {
#line 2528
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2528
      if (! reselect) {
#line 2528
        goto while_break;
      }
#line 2529
      if ((unsigned long )abarj != (unsigned long )((void *)0)) {
        {
#line 2530
        free((void *)abarj);
#line 2531
        abarj = (double *)((void *)0);
        }
      }
#line 2532
      if (dy_opts->dpsel.strat > 0) {
        {
#line 2533
        inretval = dualmultiin(xindx, outdir, & xjndx, & indir, abari, maxabari, & abarj);
        }
      } else {
        {
#line 2536
        inretval = dualin(xindx, outdir, & xjndx, & indir, abari, maxabari, & abarj);
        }
      }
      {
#line 2545
      if ((int )inretval == 1) {
#line 2545
        goto case_1;
      }
#line 2568
      if ((int )inretval == -2) {
#line 2568
        goto case_neg_2;
      }
#line 2637
      if ((int )inretval == 8) {
#line 2637
        goto case_8;
      }
#line 2663
      if ((int )inretval == -10) {
#line 2663
        goto case_neg_10;
      }
#line 2663
      if ((int )inretval == 4) {
#line 2663
        goto case_neg_10;
      }
#line 2663
      if ((int )inretval == -1) {
#line 2663
        goto case_neg_10;
      }
#line 2663
      if ((int )inretval == 3) {
#line 2663
        goto case_neg_10;
      }
#line 2666
      goto switch_default;
      case_1: /* CIL Label */ 
#line 2546
      reselect = (bool )0;
#line 2547
      goto switch_break;
      case_neg_2: /* CIL Label */ 
#line 2569
      if (*(dy_status + xindx) & 1U) {
#line 2569
        tmp___20 = 1;
      } else {
#line 2569
        tmp___20 = 0;
      }
#line 2569
      if (tmp___20) {
#line 2569
        goto _L___2;
      } else {
#line 2569
        if (*(dy_status + xjndx) & (unsigned int )(1 << 8)) {
#line 2569
          tmp___21 = 1;
        } else {
#line 2569
          tmp___21 = 0;
        }
#line 2569
        if (tmp___21) {
          _L___2: /* CIL Label */ 
#line 2571
          reselect = (bool )0;
#line 2573
          if (dy_opts->print.degen >= 3) {
            {
#line 2574
            tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2574
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n      (%s)%d: constructive degenerate pivot.",
                        tmp___8, dy_lp->tot.iters);
#line 2577
            tmp___9 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 2577
            tmp___10 = dy_prtvstat(*(dy_status + xindx));
#line 2577
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) leaving,", tmp___10,
                        tmp___9, xindx);
#line 2580
            tmp___11 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2580
            tmp___12 = dy_prtvstat(*(dy_status + xjndx));
#line 2580
            dyio_outfmt(dy_logchn, dy_gtxecho, " %s %s (%d) entering %d.", tmp___12,
                        tmp___11, xjndx);
            }
          }
        } else
#line 2586
        if ((int )dy_opts->degen == 1) {
#line 2586
          if (degen_cyclecnt___0 == 0) {
#line 2586
            if (dy_opts->degenpivlim < dy_lp->degenpivcnt) {
#line 2590
              if (dy_opts->print.pivoting >= 1) {
                {
#line 2591
                tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2591
                dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: antidegeneracy increasing to level %d.",
                            tmp___13, dy_lp->tot.iters, dy_lp->degen + 1);
                }
              } else
#line 2590
              if (dy_opts->print.degen >= 1) {
                {
#line 2591
                tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2591
                dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: antidegeneracy increasing to level %d.",
                            tmp___13, dy_lp->tot.iters, dy_lp->degen + 1);
                }
              }
              {
#line 2596
              dualdegenin();
#line 2597
              degen_cyclecnt___0 ++;
              }
            } else {
#line 2586
              goto _L___1;
            }
          } else {
#line 2586
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 2599
          reselect = (bool )0;
#line 2600
          if ((unsigned long )abarj == (unsigned long )((void *)0)) {
            {
#line 2601
            confirm = dy_confirmDualPivot(xindx, xjndx, abari, maxabari, & abarj);
            }
#line 2603
            if ((int )confirm == 1) {
#line 2604
              inretval = (dyret_enum )-2;
            } else {
#line 2606
              inretval = confirm;
            }
          }
#line 2608
          if (dy_opts->print.degen >= 2) {
#line 2608
            if (degen_cyclecnt___0 > 0) {
              {
#line 2609
              tmp___14 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2609
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: forced degenerate pivot after %d cycles;",
                          tmp___14, dy_lp->tot.iters, degen_cyclecnt___0);
#line 2613
              tmp___15 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2613
              tmp___16 = dy_prtvstat(*(dy_status + xjndx));
#line 2613
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s %s (%d) entering.", tmp___16,
                          tmp___15, xjndx);
              }
            } else {
#line 2608
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 2617
          if (dy_opts->print.degen >= 3) {
            {
#line 2618
            tmp___17 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2618
            tmp___18 = dy_prtvstat(*(dy_status + xjndx));
#line 2618
            tmp___19 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2618
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: degenerate pivot; %s %s (%d) entering.",
                        tmp___19, dy_lp->tot.iters, tmp___18, tmp___17, xjndx);
            }
          }
        }
      }
#line 2625
      goto switch_break;
      case_8: /* CIL Label */ 
#line 2638
      if (dy_lp->degen > 0) {
#line 2641
        if (dy_opts->print.pivoting >= 1) {
          {
#line 2642
          tmp___22 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2642
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, unbounded.",
                      tmp___22, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats___0.iterin[dy_lp->degen]);
          }
        } else
#line 2641
        if (dy_opts->print.degen >= 1) {
          {
#line 2642
          tmp___22 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2642
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: backing out level %d after %d pivots, unbounded.",
                      tmp___22, dy_lp->tot.iters, dy_lp->degen, dy_lp->tot.pivs - degenstats___0.iterin[dy_lp->degen]);
          }
        }
        {
#line 2648
        dy_dualdegenout(dy_lp->degen - 1);
#line 2649
        reselect = (bool )1;
        }
      } else {
#line 2651
        reselect = (bool )0;
      }
#line 2652
      goto switch_break;
      case_neg_10: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_neg_1: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 2664
      reselect = (bool )0;
#line 2665
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2667
      errmsg(1, rtnnme, 2667);
#line 2668
      reselect = (bool )0;
      }
#line 2669
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 2675
    if ((int )inretval == 1) {
#line 2678
      *p_xjndx = xjndx;
#line 2679
      *p_indir = indir;
#line 2680
      *p_cbarj = *(dy_cbar + xjndx);
#line 2681
      *p_abarij = *(abari + xjndx);
#line 2682
      *p_delta = QNaNbits___2.fpdbl;
    } else
#line 2675
    if ((int )inretval == -2) {
#line 2678
      *p_xjndx = xjndx;
#line 2679
      *p_indir = indir;
#line 2680
      *p_cbarj = *(dy_cbar + xjndx);
#line 2681
      *p_abarij = *(abari + xjndx);
#line 2682
      *p_delta = QNaNbits___2.fpdbl;
    } else
#line 2675
    if ((int )inretval == 4) {
#line 2678
      *p_xjndx = xjndx;
#line 2679
      *p_indir = indir;
#line 2680
      *p_cbarj = *(dy_cbar + xjndx);
#line 2681
      *p_abarij = *(abari + xjndx);
#line 2682
      *p_delta = QNaNbits___2.fpdbl;
    } else
#line 2675
    if ((int )inretval == -1) {
#line 2678
      *p_xjndx = xjndx;
#line 2679
      *p_indir = indir;
#line 2680
      *p_cbarj = *(dy_cbar + xjndx);
#line 2681
      *p_abarij = *(abari + xjndx);
#line 2682
      *p_delta = QNaNbits___2.fpdbl;
    } else
#line 2675
    if ((int )inretval == 3) {
#line 2678
      *p_xjndx = xjndx;
#line 2679
      *p_indir = indir;
#line 2680
      *p_cbarj = *(dy_cbar + xjndx);
#line 2681
      *p_abarij = *(abari + xjndx);
#line 2682
      *p_delta = QNaNbits___2.fpdbl;
    }
  } else {
    {
#line 2689
    xjndx = *p_xjndx;
#line 2690
    indir = *p_indir;
#line 2691
    *p_cbarj = *(dy_cbar + xjndx);
#line 2692
    *p_abarij = *(abari + xjndx);
#line 2693
    inretval = dy_confirmDualPivot(xindx, xjndx, abari, maxabari, & abarj);
    }
#line 2694
    if ((int )inretval == 1) {
#line 2694
      if (*(dy_cbar + xjndx) == (double )0) {
#line 2695
        inretval = (dyret_enum )-2;
      }
    }
#line 2696
    *p_delta = QNaNbits___2.fpdbl;
  }
#line 2700
  if (! ((int )inretval == 1)) {
#line 2700
    if (! ((int )inretval == -2)) {
#line 2701
      if ((int )inretval == -1) {
        {
#line 2702
        dy_addtopivrej(xindx, (dyret_enum )-1, *p_abarij, maxabari);
        }
      }
      {
#line 2703
      free((void *)betai);
#line 2704
      free((void *)abari);
      }
#line 2705
      if ((unsigned long )abarj != (unsigned long )((void *)0)) {
        {
#line 2705
        free((void *)abarj);
        }
      }
#line 2706
      return (inretval);
    }
  }
#line 2715
  if ((int )inretval == 1) {
#line 2716
    dy_lp->degenpivcnt = 0;
  } else {
#line 2718
    (dy_lp->degenpivcnt) ++;
  }
#line 2721
  if (dy_opts->print.pivoting >= 1) {
#line 2722
    if (*(dy_status + xjndx) & (unsigned int )(1 << 6)) {
#line 2722
      tmp___28 = 1;
    } else {
#line 2722
      tmp___28 = 0;
    }
#line 2722
    if (tmp___28) {
#line 2722
      tmp___27 = "ub";
    } else {
#line 2722
      if (*(dy_status + xjndx) & (unsigned int )(1 << 7)) {
#line 2722
        tmp___26 = 1;
      } else {
#line 2722
        tmp___26 = 0;
      }
#line 2722
      if (tmp___26) {
#line 2722
        tmp___25 = "lb";
      } else {
#line 2722
        tmp___25 = "x";
      }
#line 2722
      tmp___27 = tmp___25;
    }
#line 2722
    if (indir < 0) {
#line 2722
      tmp___29 = "decreasing";
    } else {
#line 2722
      tmp___29 = "increasing";
    }
    {
#line 2722
    tmp___30 = dy_prtvstat(*(dy_status + xjndx));
#line 2722
    tmp___31 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2722
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    x<%d> (%s) entering, status %s, %s from %s = %g, ",
                xjndx, tmp___31, tmp___30, tmp___29, tmp___27, *(dy_x + xjndx));
    }
  }
  {
#line 2736
  tmp___32 = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 2736
  tau = (double *)tmp___32;
#line 2737
  memcpy((void */* __restrict  */)tau, (void const   */* __restrict  */)betai, (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 2738
  dy_ftran(tau, (bool )0);
#line 2756
  retval = dy_pivot(xipos, *(abarj + xipos), maxabari);
  }
#line 2757
  if ((int )retval == -7) {
#line 2757
    goto _L___3;
  } else
#line 2757
  if ((int )retval == -5) {
    _L___3: /* CIL Label */ 
    {
#line 2758
    factorflgs = (flags )((1 << 7) | (1 << 6));
#line 2759
    patch = dy_opts->patch;
#line 2760
    dy_opts->patch = (bool )0;
#line 2761
    dseretval = dy_factor(& factorflgs);
#line 2762
    dy_opts->patch = patch;
    }
#line 2763
    if ((int )dseretval == 1) {
      {
#line 2764
      free((void *)abarj);
#line 2765
      abarj = (double *)((void *)0);
#line 2766
      consys_getcol_ex(dy_sys, xjndx, & abarj);
#line 2767
      dy_ftran(abarj, (bool )1);
#line 2768
      retval = dy_pivot(xipos, *(abarj + xipos), maxabari);
      }
#line 2769
      if ((int )retval == -5) {
#line 2769
        retval = (dyret_enum )-6;
      }
    } else
#line 2771
    if ((int )dseretval == -5) {
#line 2772
      retval = (dyret_enum )-6;
    } else {
#line 2774
      retval = dseretval;
    }
  }
#line 2790
  if ((int )retval == 1) {
    {
#line 2791
    dy_lp->pivok = (bool )1;
#line 2792
    retval = dualupdate(xjndx, indir, xindx, outdir, abarj, p_delta, betai);
    }
#line 2793
    if ((int )retval == 1) {
#line 2793
      goto _L___4;
    } else
#line 2793
    if ((int )retval == 4) {
#line 2793
      goto _L___4;
    } else
#line 2793
    if ((int )retval == 9) {
      _L___4: /* CIL Label */ 
      {
#line 2794
      dseretval = dseupdate(xindx, xjndx, p_xicand, tau, betai, abari, abarj);
      }
#line 2795
      if ((int )dseretval != 1) {
#line 2795
        retval = dseretval;
      }
    }
#line 2796
    if ((int )retval == 1) {
#line 2796
      retval = inretval;
    }
  }
  {
#line 2806
  free((void *)abarj);
#line 2807
  free((void *)abari);
#line 2808
  free((void *)betai);
#line 2809
  free((void *)tau);
  }
#line 2811
  return (retval);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static FILE *emsgchn  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static FILE *elogchn  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static char *emsgname  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static char *elogname  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static bool errecho  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static char errtxt[253]  = 
#line 67
  {      (char )'\n',      (char )'%',      (char )'s',      (char )' ', 
        (char )'(',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )')',      (char )':', 
        (char )' ',      (char )'\000'};
#line 71 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static char warntxt[255]  = 
#line 71
  {      (char )'\n',      (char )'%',      (char )'s',      (char )' ', 
        (char )'(',      (char )'w',      (char )'a',      (char )'r', 
        (char )'n',      (char )'i',      (char )'n',      (char )'g', 
        (char )')',      (char )':',      (char )' ',      (char )'\000'};
#line 88 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
void errinit(char const   *emsgpath , char *elogpath , bool echo ) 
{ 
  char const   *rtnnme ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 104
  rtnnme = "errinit";
#line 110
  if ((unsigned long )emsgpath == (unsigned long )((void *)0)) {
    {
#line 111
    tmp = getenv("ERRMSGTXT");
#line 111
    emsgpath = (char const   *)tmp;
    }
#line 112
    if ((unsigned long )emsgpath == (unsigned long )((void *)0)) {
#line 112
      emsgpath = "dy_errmsgs.txt";
    }
  }
  {
#line 113
  tmp___0 = strlen(emsgpath);
#line 113
  tmp___1 = malloc(tmp___0 + 1UL);
#line 113
  emsgname = (char *)tmp___1;
#line 114
  strcpy((char */* __restrict  */)emsgname, (char const   */* __restrict  */)emsgpath);
#line 115
  emsgchn = fopen((char const   */* __restrict  */)emsgname, (char const   */* __restrict  */)"r");
  }
#line 116
  if ((unsigned long )emsgchn == (unsigned long )((void *)0)) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t open error message text file \"%s\".\n",
            rtnnme, emsgname);
#line 119
    perror(rtnnme);
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: only numeric error codes will be reported.\n",
            rtnnme);
    }
  }
#line 126
  if ((unsigned long )elogpath == (unsigned long )((void *)0)) {
#line 127
    elogchn = (FILE *)((void *)0);
#line 128
    elogname = (char *)((void *)0);
  } else {
    {
#line 130
    tmp___2 = strlen((char const   *)elogpath);
#line 130
    tmp___3 = malloc(tmp___2 + 1UL);
#line 130
    elogname = (char *)tmp___3;
#line 131
    strcpy((char */* __restrict  */)elogname, (char const   */* __restrict  */)elogpath);
#line 132
    elogchn = fopen((char const   */* __restrict  */)elogname, (char const   */* __restrict  */)"w");
    }
#line 133
    if ((unsigned long )elogchn == (unsigned long )((void *)0)) {
      {
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t open error logging file \"%s\".\n",
              rtnnme, elogname);
#line 136
      perror(rtnnme);
      }
    }
  }
#line 138
  errecho = echo;
#line 153
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
void errterm(void) 
{ 
  char *rtnnme ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 173
  rtnnme = (char *)"errterm";
#line 175
  if ((unsigned long )emsgchn != (unsigned long )((void *)0)) {
#line 175
    if ((unsigned long )emsgchn != (unsigned long )stdin) {
      {
#line 175
      tmp___0 = ftell(emsgchn);
      }
#line 175
      if (tmp___0 >= 0L) {
        {
#line 176
        tmp = fclose(emsgchn);
        }
#line 176
        if (tmp < 0) {
          {
#line 177
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t close error message file \"%s\".\n",
                  emsgname, rtnnme);
#line 179
          perror((char const   *)rtnnme);
          }
        }
#line 180
        emsgchn = (FILE *)((void *)0);
      }
    }
  }
#line 181
  if ((unsigned long )emsgname != (unsigned long )((void *)0)) {
    {
#line 182
    free((void *)emsgname);
#line 183
    emsgname = (char *)((void *)0);
    }
  }
#line 185
  if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
#line 185
    if ((unsigned long )elogchn != (unsigned long )stdout) {
#line 185
      if ((unsigned long )elogchn != (unsigned long )stderr) {
        {
#line 185
        tmp___2 = ftell(elogchn);
        }
#line 185
        if (tmp___2 >= 0L) {
          {
#line 187
          tmp___1 = fclose(elogchn);
          }
#line 187
          if (tmp___1 < 0) {
            {
#line 188
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t close error log file \"%s\".\n",
                    elogname, rtnnme);
#line 190
            perror((char const   *)rtnnme);
            }
          }
#line 191
          elogchn = (FILE *)((void *)0);
        }
      }
    }
  }
#line 192
  if ((unsigned long )elogname != (unsigned long )((void *)0)) {
    {
#line 193
    free((void *)elogname);
#line 194
    elogname = (char *)((void *)0);
    }
  }
#line 196
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
FILE *errlogq(char **elogpath ) 
{ 


  {
#line 220
  *elogpath = elogname;
#line 221
  return (elogchn);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
bool reseterrlogchn(char const   *newpath , FILE *newchn , bool echo , bool close ) 
{ 
  bool success ;
  char const   *rtnnme ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 242
  rtnnme = "reseterrlogchn";
#line 250
  success = (bool )1;
#line 251
  if ((unsigned long )newpath != (unsigned long )((void *)0)) {
#line 252
    if ((unsigned long )newchn == (unsigned long )((void *)0)) {
      {
#line 253
      newchn = fopen((char const   */* __restrict  */)newpath, (char const   */* __restrict  */)"w");
      }
#line 254
      if ((unsigned long )newchn == (unsigned long )((void *)0)) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t open error logging file \"%s\".\n",
                rtnnme, newpath);
#line 257
        perror(rtnnme);
#line 258
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: retaining previous file \"%s\".\n",
                rtnnme, elogname);
#line 260
        success = (bool )0;
        }
      }
    }
#line 262
    if ((int )success == 1) {
#line 263
      if ((int )close == 1) {
        {
#line 264
        tmp = fclose(elogchn);
        }
#line 264
        if (tmp == -1) {
          {
#line 265
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t close previous error logging file \"%s\".\n",
                  rtnnme, elogname);
#line 268
          perror(rtnnme);
          }
        }
      }
#line 269
      elogchn = newchn;
#line 270
      if ((unsigned long )elogname != (unsigned long )((void *)0)) {
        {
#line 270
        free((void *)elogname);
        }
      }
      {
#line 271
      tmp___0 = strlen(newpath);
#line 271
      tmp___1 = malloc(tmp___0 + 1UL);
#line 271
      elogname = (char *)tmp___1;
#line 272
      strcpy((char */* __restrict  */)elogname, (char const   */* __restrict  */)newpath);
      }
    }
  }
#line 274
  errecho = echo;
#line 276
  return (success);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
static char *finderrmsg(int errid , char *buffer___1 ) 
{ 
  int argcnt ;
  int chrcnt ;
  int id ;
  int id2 ;
  int chr ;
  bool sync ;
  char *txtptr ;
  char const   *rtnnme ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 314
  rtnnme = "finderrmsg";
#line 325
  rewind(emsgchn);
#line 326
  id = 0;
#line 327
  sync = (bool )0;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 328
    tmp = fgets((char */* __restrict  */)buffer___1, 240, (FILE */* __restrict  */)emsgchn);
    }
#line 328
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 328
      goto while_break;
    }
#line 329
    if ((int )*(buffer___1 + 0) != 64) {
#line 329
      goto while_continue;
    }
    {
#line 330
    argcnt = sscanf((char const   */* __restrict  */)buffer___1, (char const   */* __restrict  */)"@%d%n:%d%n",
                    & id, & chrcnt, & id2, & chrcnt);
    }
#line 331
    if (argcnt == 1) {
#line 331
      goto _L___0;
    } else
#line 331
    if (argcnt == 2) {
      _L___0: /* CIL Label */ 
#line 331
      if ((int )*(buffer___1 + chrcnt) == 64) {
#line 332
        if (argcnt == 1) {
#line 332
          if (id == errid) {
#line 334
            sync = (bool )1;
#line 335
            goto while_break;
          } else {
#line 332
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 332
        if (argcnt == 2) {
#line 332
          if (id <= errid) {
#line 332
            if (errid <= id2) {
#line 334
              sync = (bool )1;
#line 335
              goto while_break;
            }
          }
        }
      } else {
        {
#line 337
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad error message id format; line is:\n%s\n",
                rtnnme, buffer___1);
#line 339
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tskipping to start of next message.\n");
        }
      }
    } else {
      {
#line 337
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: bad error message id format; line is:\n%s\n",
              rtnnme, buffer___1);
#line 339
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tskipping to start of next message.\n");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  if ((int )sync == 0) {
    {
#line 342
    tmp___1 = feof(emsgchn);
    }
#line 342
    if (tmp___1) {
      {
#line 343
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t find error message %d.\n",
              rtnnme, errid);
      }
    } else {
      {
#line 344
      tmp___0 = ferror(emsgchn);
      }
#line 344
      if (tmp___0) {
        {
#line 345
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: i/o error.\n",
                rtnnme);
#line 346
        perror(rtnnme);
        }
      } else {
        {
#line 348
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: internal confusion at line %d.\n",
                rtnnme, 349);
        }
      }
    }
#line 350
    return ((char *)((void *)0));
  }
#line 357
  txtptr = buffer___1 + (chrcnt + 1);
#line 358
  if ((int )*txtptr != 10) {
#line 359
    chrcnt = 0;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (! ((int )*txtptr != 0)) {
#line 360
        goto while_break___0;
      }
#line 361
      tmp___2 = txtptr;
#line 361
      txtptr ++;
#line 361
      chr = (int )*tmp___2;
#line 362
      if (chr == 92) {
#line 362
        tmp___3 = txtptr;
#line 362
        txtptr ++;
#line 362
        chr = (int )*tmp___3;
      }
#line 363
      tmp___4 = chrcnt;
#line 363
      chrcnt ++;
#line 363
      *(buffer___1 + tmp___4) = (char )chr;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 364
    *(buffer___1 + chrcnt) = (char )'\000';
#line 365
    tmp___5 = strlen((char const   *)buffer___1);
#line 365
    txtptr = buffer___1 + (tmp___5 - 1UL);
    }
#line 366
    if ((int )*txtptr == 10) {
#line 366
      if ((int )*(txtptr - 1) == 64) {
#line 366
        if ((int )*(txtptr - 2) != 92) {
#line 367
          *(txtptr - 1) = (char )'\000';
#line 368
          return (buffer___1);
        } else {
#line 370
          txtptr ++;
        }
      } else {
#line 370
        txtptr ++;
      }
    } else {
#line 370
      txtptr ++;
    }
  } else {
#line 372
    txtptr = buffer___1;
  }
  {
#line 373
  chr = _IO_getc(emsgchn);
  }
  {
#line 373
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 373
    if (! (chr != -1)) {
#line 373
      goto while_break___1;
    }
#line 374
    if (chr == 64) {
#line 374
      goto while_break___1;
    }
#line 375
    if (chr == 92) {
      {
#line 376
      chr = _IO_getc(emsgchn);
      }
#line 377
      if (chr == -1) {
        {
#line 378
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: sync error - EOF following \"\\\" in message %d.\n",
                rtnnme, errid);
        }
#line 381
        return ((char *)((void *)0));
      }
    }
    {
#line 382
    tmp___6 = txtptr;
#line 382
    txtptr ++;
#line 382
    *tmp___6 = (char )chr;
#line 373
    chr = _IO_getc(emsgchn);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 383
  if (chr == -1) {
    {
#line 384
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: sync error - EOF collecting text for message %d.\n",
            rtnnme, errid);
    }
#line 386
    return ((char *)((void *)0));
  }
#line 387
  *txtptr = (char )'\000';
#line 389
  return (buffer___1);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
void errmsg(int errid  , ...) 
{ 
  char *ident ;
  va_list varargs ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 424
  fflush(stdout);
  }
#line 425
  if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
    {
#line 425
    fflush(elogchn);
    }
  }
  {
#line 431
  __builtin_va_start(varargs, errid);
  }
#line 432
  if ((unsigned long )emsgchn == (unsigned long )((void *)0)) {
#line 432
    goto _L;
  } else {
    {
#line 432
    tmp___0 = finderrmsg(errid, & errtxt[13]);
    }
#line 432
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 433
      tmp = __builtin_va_arg(varargs, char *);
#line 433
      ident = tmp;
      }
#line 434
      if ((int )errecho == 1) {
        {
#line 435
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: error %d.\n",
                ident, errid);
        }
      }
#line 436
      if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
        {
#line 437
        fprintf((FILE */* __restrict  */)elogchn, (char const   */* __restrict  */)"\n%s: error %d.\n",
                ident, errid);
        }
      }
    } else {
#line 439
      if ((int )errecho == 1) {
        {
#line 440
        vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(errtxt),
                 varargs);
#line 441
        _IO_putc('\n', stderr);
        }
      }
#line 442
      if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
        {
#line 443
        vfprintf((FILE */* __restrict  */)elogchn, (char const   */* __restrict  */)(errtxt),
                 varargs);
#line 444
        _IO_putc('\n', elogchn);
        }
      }
    }
  }
  {
#line 445
  __builtin_va_end(varargs);
  }
#line 449
  if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
    {
#line 449
    fflush(elogchn);
    }
  }
#line 451
  return;
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_errs.c"
void warn(int errid  , ...) 
{ 
  char *ident ;
  va_list varargs ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 488
  fflush(stdout);
  }
#line 489
  if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
    {
#line 489
    fflush(elogchn);
    }
  }
  {
#line 495
  __builtin_va_start(varargs, errid);
  }
#line 496
  if ((unsigned long )emsgchn == (unsigned long )((void *)0)) {
#line 496
    goto _L;
  } else {
    {
#line 496
    tmp___0 = finderrmsg(errid, & warntxt[15]);
    }
#line 496
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 497
      tmp = __builtin_va_arg(varargs, char *);
#line 497
      ident = tmp;
      }
#line 498
      if ((int )errecho == 1) {
        {
#line 499
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: error %d.\n",
                ident, errid);
        }
      }
#line 500
      if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
        {
#line 501
        fprintf((FILE */* __restrict  */)elogchn, (char const   */* __restrict  */)"\n%s: error %d.\n",
                ident, errid);
        }
      }
    } else {
#line 503
      if ((int )errecho == 1) {
        {
#line 504
        vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(warntxt),
                 varargs);
#line 505
        _IO_putc('\n', stderr);
        }
      }
#line 506
      if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
        {
#line 507
        vfprintf((FILE */* __restrict  */)elogchn, (char const   */* __restrict  */)(warntxt),
                 varargs);
#line 508
        _IO_putc('\n', elogchn);
        }
      }
    }
  }
  {
#line 509
  __builtin_va_end(varargs);
  }
#line 513
  if ((unsigned long )elogchn != (unsigned long )((void *)0)) {
    {
#line 513
    fflush(elogchn);
    }
  }
#line 515
  return;
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 310 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
LUF *dy_glp_luf_create(int n , int sv_size ) ;
#line 313
void dy_glp_luf_defrag_sva(LUF *luf ) ;
#line 316
int dy_glp_luf_enlarge_row(LUF *luf , int i , int cap ) ;
#line 319
int dy_glp_luf_enlarge_col(LUF *luf , int j , int cap ) ;
#line 328
int dy_glp_luf_decomp(LUF *luf , void *info , int (*col)(void *info , int j , int *rn ,
                                                         double *aj ) , LUF_WA *_wa ) ;
#line 333
void dy_glp_luf_f_solve(LUF *luf , int tr , double *x ) ;
#line 336
void dy_glp_luf_v_solve(LUF *luf , int tr , double *x ) ;
#line 342
void dy_glp_luf_delete(LUF *luf ) ;
#line 153 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.h"
INV *dy_glp_inv_create(int m , int max_upd ) ;
#line 156
int dy_glp_inv_decomp(INV *inv , void *info , int (*col)(void *info , int j , int *rn ,
                                                         double *bj ) ) ;
#line 160
void dy_glp_inv_h_solve(INV *inv , int tr , double *x ) ;
#line 163
void dy_glp_inv_ftran(INV *inv , double *x , int save ) ;
#line 166
void dy_glp_inv_btran(INV *inv , double *x ) ;
#line 169
int dy_glp_inv_update(INV *inv , int j ) ;
#line 172
void dy_glp_inv_delete(INV *inv ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
void dy_glp_fault(char const   *fmt  , ...) ;
#line 89
void dy_glp_insist(char const   *expr , char const   *file , int line ) ;
#line 119
void *dy_glp_umalloc(int size ) ;
#line 122
void *dy_glp_ucalloc(int nmemb , int size ) ;
#line 125
void dy_glp_ufree(void *ptr ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
INV *dy_glp_inv_create(int m , int max_upd ) 
{ 
  INV *inv ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 59
  if (m < 1) {
    {
#line 60
    dy_glp_fault("inv_create: m = %d; invalid parameter", m);
    }
  }
#line 61
  if (max_upd < 0) {
    {
#line 62
    dy_glp_fault("inv_create: max_upd = %d; invalid parameter", max_upd);
    }
  }
  {
#line 63
  tmp = dy_glp_umalloc((int )sizeof(INV ));
#line 63
  inv = (INV *)tmp;
#line 64
  inv->m = m;
#line 65
  inv->valid = 1;
#line 66
  inv->luf = dy_glp_luf_create(m, 0);
#line 67
  inv->hh_max = max_upd;
#line 68
  inv->hh_nfs = 0;
#line 69
  tmp___0 = dy_glp_ucalloc(1 + max_upd, (int )sizeof(int ));
#line 69
  inv->hh_ndx = (int *)tmp___0;
#line 70
  tmp___1 = dy_glp_ucalloc(1 + max_upd, (int )sizeof(int ));
#line 70
  inv->hh_ptr = (int *)tmp___1;
#line 71
  tmp___2 = dy_glp_ucalloc(1 + max_upd, (int )sizeof(int ));
#line 71
  inv->hh_len = (int *)tmp___2;
#line 72
  tmp___3 = dy_glp_ucalloc(1 + m, (int )sizeof(int ));
#line 72
  inv->p0_row = (int *)tmp___3;
#line 73
  tmp___4 = dy_glp_ucalloc(1 + m, (int )sizeof(int ));
#line 73
  inv->p0_col = (int *)tmp___4;
#line 74
  k = 1;
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (k <= m)) {
#line 74
      goto while_break;
    }
#line 75
    tmp___5 = k;
#line 75
    *(inv->p0_col + k) = tmp___5;
#line 75
    *(inv->p0_row + k) = tmp___5;
#line 74
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  inv->cc_len = -1;
#line 77
  tmp___6 = dy_glp_ucalloc(1 + m, (int )sizeof(int ));
#line 77
  inv->cc_ndx = (int *)tmp___6;
#line 78
  tmp___7 = dy_glp_ucalloc(1 + m, (int )sizeof(double ));
#line 78
  inv->cc_val = (double *)tmp___7;
#line 82
  inv->upd_tol = 1e-6;
#line 84
  inv->nnz_h = 0;
  }
#line 85
  return (inv);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
int dy_glp_inv_decomp(INV *inv , void *info , int (*col)(void *info , int j , int *rn ,
                                                         double *bj ) ) 
{ 
  int *pp_row ;
  int *pp_col ;
  int *p0_row ;
  int *p0_col ;
  int m ;
  int ret ;

  {
  {
#line 164
  pp_row = (inv->luf)->pp_row;
#line 165
  pp_col = (inv->luf)->pp_col;
#line 166
  p0_row = inv->p0_row;
#line 167
  p0_col = inv->p0_col;
#line 168
  m = inv->m;
#line 169
  ret = dy_glp_luf_decomp(inv->luf, info, col, (LUF_WA *)((void *)0));
  }
#line 170
  if (ret == 0) {
    {
#line 172
    inv->valid = 1;
#line 174
    inv->hh_nfs = 0;
#line 176
    memcpy((void */* __restrict  */)(p0_row + 1), (void const   */* __restrict  */)(pp_row + 1),
           sizeof(int ) * (unsigned long )m);
#line 177
    memcpy((void */* __restrict  */)(p0_col + 1), (void const   */* __restrict  */)(pp_col + 1),
           sizeof(int ) * (unsigned long )m);
#line 179
    inv->cc_len = -1;
#line 181
    inv->nnz_h = 0;
#line 184
    inv->min_vrratio = ((inv->luf)->max_gro * (inv->luf)->max_a) / (inv->luf)->big_v;
    }
  } else {
#line 188
    inv->valid = 0;
  }
#line 190
  return (ret);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
void dy_glp_inv_h_solve(INV *inv , int tr , double *x ) 
{ 
  int nfs ;
  int *hh_ndx ;
  int *hh_ptr ;
  int *hh_len ;
  int *sv_ndx ;
  double *sv_val ;
  int i ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;

  {
#line 214
  nfs = inv->hh_nfs;
#line 215
  hh_ndx = inv->hh_ndx;
#line 216
  hh_ptr = inv->hh_ptr;
#line 217
  hh_len = inv->hh_len;
#line 218
  sv_ndx = (inv->luf)->sv_ndx;
#line 219
  sv_val = (inv->luf)->sv_val;
#line 222
  if (! inv->valid) {
    {
#line 223
    dy_glp_fault("inv_h_solve: the factorization is not valid");
    }
  }
#line 224
  if (! tr) {
#line 226
    k = 1;
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (! (k <= nfs)) {
#line 226
        goto while_break;
      }
#line 227
      i = *(hh_ndx + k);
#line 228
      temp = *(x + i);
#line 229
      beg = *(hh_ptr + k);
#line 230
      end = (beg + *(hh_len + k)) - 1;
#line 231
      ptr = beg;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 231
        if (! (ptr <= end)) {
#line 231
          goto while_break___0;
        }
#line 232
        temp -= *(sv_val + ptr) * *(x + *(sv_ndx + ptr));
#line 231
        ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 233
      *(x + i) = temp;
#line 226
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 238
    k = nfs;
    {
#line 238
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 238
      if (! (k >= 1)) {
#line 238
        goto while_break___1;
      }
#line 239
      i = *(hh_ndx + k);
#line 240
      temp = *(x + i);
#line 241
      if (temp == 0.0) {
#line 241
        goto __Cont;
      }
#line 242
      beg = *(hh_ptr + k);
#line 243
      end = (beg + *(hh_len + k)) - 1;
#line 244
      ptr = beg;
      {
#line 244
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 244
        if (! (ptr <= end)) {
#line 244
          goto while_break___2;
        }
#line 245
        *(x + *(sv_ndx + ptr)) -= *(sv_val + ptr) * temp;
#line 244
        ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 238
      k --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 248
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
void dy_glp_inv_ftran(INV *inv , double *x , int save ) 
{ 
  int m ;
  int *pp_row ;
  int *pp_col ;
  double eps_tol ;
  int *p0_row ;
  int *p0_col ;
  int *cc_ndx ;
  double *cc_val ;
  int i ;
  int len ;
  double temp ;
  double tmp ;

  {
#line 284
  m = inv->m;
#line 285
  pp_row = (inv->luf)->pp_row;
#line 286
  pp_col = (inv->luf)->pp_col;
#line 287
  eps_tol = (inv->luf)->eps_tol;
#line 288
  p0_row = inv->p0_row;
#line 289
  p0_col = inv->p0_col;
#line 290
  cc_ndx = inv->cc_ndx;
#line 291
  cc_val = inv->cc_val;
#line 294
  if (! inv->valid) {
    {
#line 295
    dy_glp_fault("inv_ftran: the factorization is not valid");
    }
  }
  {
#line 297
  (inv->luf)->pp_row = p0_row;
#line 298
  (inv->luf)->pp_col = p0_col;
#line 299
  dy_glp_luf_f_solve(inv->luf, 0, x);
#line 300
  (inv->luf)->pp_row = pp_row;
#line 301
  (inv->luf)->pp_col = pp_col;
#line 302
  dy_glp_inv_h_solve(inv, 0, x);
  }
#line 304
  if (save) {
#line 305
    len = 0;
#line 306
    i = 1;
    {
#line 306
    while (1) {
      while_continue: /* CIL Label */ ;
#line 306
      if (! (i <= m)) {
#line 306
        goto while_break;
      }
#line 307
      temp = *(x + i);
#line 308
      if (temp == 0.0) {
#line 308
        goto __Cont;
      } else {
        {
#line 308
        tmp = fabs(temp);
        }
#line 308
        if (tmp < eps_tol) {
#line 308
          goto __Cont;
        }
      }
#line 309
      len ++;
#line 310
      *(cc_ndx + len) = i;
#line 311
      *(cc_val + len) = temp;
      __Cont: /* CIL Label */ 
#line 306
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 313
    inv->cc_len = len;
  }
  {
#line 315
  dy_glp_luf_v_solve(inv->luf, 0, x);
  }
#line 316
  return;
}
}
#line 342 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
void dy_glp_inv_btran(INV *inv , double *x ) 
{ 
  int *pp_row ;
  int *pp_col ;
  int *p0_row ;
  int *p0_col ;

  {
#line 343
  pp_row = (inv->luf)->pp_row;
#line 344
  pp_col = (inv->luf)->pp_col;
#line 345
  p0_row = inv->p0_row;
#line 346
  p0_col = inv->p0_col;
#line 348
  if (! inv->valid) {
    {
#line 349
    dy_glp_fault("inv_btran: the factorization is not valid");
    }
  }
  {
#line 350
  dy_glp_luf_v_solve(inv->luf, 1, x);
#line 351
  dy_glp_inv_h_solve(inv, 1, x);
#line 352
  (inv->luf)->pp_row = p0_row;
#line 353
  (inv->luf)->pp_col = p0_col;
#line 354
  dy_glp_luf_f_solve(inv->luf, 1, x);
#line 355
  (inv->luf)->pp_row = pp_row;
#line 356
  (inv->luf)->pp_col = pp_col;
  }
#line 357
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
int dy_glp_inv_update(INV *inv , int j ) 
{ 
  int m ;
  LUF *luf ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  int *sv_ndx ;
  double *sv_val ;
  double *work ;
  double eps_tol ;
  int *hh_ndx ;
  int *hh_ptr ;
  int *hh_len ;
  int cc_len ;
  int *cc_ndx ;
  double *cc_val ;
  double upd_tol ;
  int ret ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int k ;
  int k1 ;
  int k2 ;
  int p ;
  int q ;
  int p_beg ;
  int p_end ;
  int p_ptr ;
  int ptr ;
  double f ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  int tmp___16 ;
  double tmp___17 ;

  {
#line 463
  m = inv->m;
#line 464
  luf = inv->luf;
#line 465
  vr_ptr = luf->vr_ptr;
#line 466
  vr_len = luf->vr_len;
#line 467
  vr_cap = luf->vr_cap;
#line 468
  vr_piv = luf->vr_piv;
#line 469
  vc_ptr = luf->vc_ptr;
#line 470
  vc_len = luf->vc_len;
#line 471
  vc_cap = luf->vc_cap;
#line 472
  pp_row = luf->pp_row;
#line 473
  pp_col = luf->pp_col;
#line 474
  qq_row = luf->qq_row;
#line 475
  qq_col = luf->qq_col;
#line 476
  sv_ndx = luf->sv_ndx;
#line 477
  sv_val = luf->sv_val;
#line 478
  work = luf->work;
#line 479
  eps_tol = luf->eps_tol;
#line 480
  hh_ndx = inv->hh_ndx;
#line 481
  hh_ptr = inv->hh_ptr;
#line 482
  hh_len = inv->hh_len;
#line 483
  cc_len = inv->cc_len;
#line 484
  cc_ndx = inv->cc_ndx;
#line 485
  cc_val = inv->cc_val;
#line 486
  upd_tol = inv->upd_tol;
#line 487
  ret = 0;
#line 491
  if (! inv->valid) {
    {
#line 492
    dy_glp_fault("inv_update: the factorization is not valid");
    }
  }
#line 493
  if (inv->cc_len < 0) {
    {
#line 494
    dy_glp_fault("inv_update: new column has not been prepared");
    }
  }
#line 495
  if (1 <= j) {
#line 495
    if (! (j <= m)) {
      {
#line 496
      dy_glp_fault("inv_update: j = %d; invalid column number", j);
      }
    }
  } else {
    {
#line 496
    dy_glp_fault("inv_update: j = %d; invalid column number", j);
    }
  }
#line 498
  if (inv->hh_nfs == inv->hh_max) {
#line 500
    tmp = 0;
#line 500
    luf->valid = tmp;
#line 500
    inv->valid = tmp;
#line 501
    ret = 3;
#line 502
    goto done;
  }
#line 505
  j_beg = *(vc_ptr + j);
#line 506
  j_end = (j_beg + *(vc_len + j)) - 1;
#line 507
  j_ptr = j_beg;
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (! (j_ptr <= j_end)) {
#line 507
      goto while_break;
    }
#line 509
    i = *(sv_ndx + j_ptr);
#line 511
    i_beg = *(vr_ptr + i);
#line 512
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 513
    i_ptr = i_beg;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      if (! (*(sv_ndx + i_ptr) != j)) {
#line 513
        goto while_break___0;
      }
#line 513
      i_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 514
    if (i_ptr <= i_end) {
#line 514
      tmp___0 = 1;
    } else {
      {
#line 514
      dy_glp_insist("i_ptr <= i_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c",
                    514);
#line 514
      tmp___0 = 1;
      }
    }
#line 516
    *(sv_ndx + i_ptr) = *(sv_ndx + i_end);
#line 517
    *(sv_val + i_ptr) = *(sv_val + i_end);
#line 518
    (*(vr_len + i)) --;
#line 507
    j_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 521
  luf->nnz_v -= *(vc_len + j);
#line 522
  *(vc_len + j) = 0;
#line 525
  k1 = *(qq_row + j);
#line 526
  k2 = 0;
#line 527
  ptr = 1;
  {
#line 527
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 527
    if (! (ptr <= cc_len)) {
#line 527
      goto while_break___1;
    }
#line 529
    i = *(cc_ndx + ptr);
#line 531
    if (*(vr_len + i) + 1 > *(vr_cap + i)) {
      {
#line 532
      tmp___2 = dy_glp_luf_enlarge_row(luf, i, *(vr_len + i) + 10);
      }
#line 532
      if (tmp___2) {
#line 534
        tmp___1 = 0;
#line 534
        luf->valid = tmp___1;
#line 534
        inv->valid = tmp___1;
#line 535
        luf->new_sva = luf->sv_size + luf->sv_size;
#line 536
        ret = 4;
#line 537
        goto done;
      }
    }
#line 541
    i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 542
    *(sv_ndx + i_ptr) = j;
#line 543
    *(sv_val + i_ptr) = *(cc_val + ptr);
#line 544
    (*(vr_len + i)) ++;
#line 546
    if (k2 < *(pp_col + i)) {
#line 546
      k2 = *(pp_col + i);
    }
#line 527
    ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 550
  if (*(vc_cap + j) < cc_len) {
    {
#line 551
    tmp___4 = dy_glp_luf_enlarge_col(luf, j, cc_len);
    }
#line 551
    if (tmp___4) {
#line 553
      tmp___3 = 0;
#line 553
      luf->valid = tmp___3;
#line 553
      inv->valid = tmp___3;
#line 554
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 555
      ret = 4;
#line 556
      goto done;
    }
  }
  {
#line 560
  j_ptr = *(vc_ptr + j);
#line 561
  memmove((void *)(sv_ndx + j_ptr), (void const   *)(cc_ndx + 1), (unsigned long )cc_len * sizeof(int ));
#line 562
  memmove((void *)(sv_val + j_ptr), (void const   *)(cc_val + 1), (unsigned long )cc_len * sizeof(double ));
#line 563
  *(vc_len + j) = cc_len;
#line 564
  luf->nnz_v += cc_len;
  }
#line 567
  if (k1 > k2) {
#line 568
    tmp___5 = 0;
#line 568
    luf->valid = tmp___5;
#line 568
    inv->valid = tmp___5;
#line 569
    ret = 1;
#line 570
    goto done;
  }
#line 574
  i = *(pp_row + k1);
#line 574
  j = *(qq_col + k1);
#line 575
  k = k1;
  {
#line 575
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 575
    if (! (k < k2)) {
#line 575
      goto while_break___2;
    }
#line 576
    *(pp_row + k) = *(pp_row + (k + 1));
#line 576
    *(pp_col + *(pp_row + k)) = k;
#line 577
    *(qq_col + k) = *(qq_col + (k + 1));
#line 577
    *(qq_row + *(qq_col + k)) = k;
#line 575
    k ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 579
  *(pp_row + k2) = i;
#line 579
  *(pp_col + i) = k2;
#line 580
  *(qq_col + k2) = j;
#line 580
  *(qq_row + j) = k2;
#line 586
  j = 1;
  {
#line 586
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 586
    if (! (j <= m)) {
#line 586
      goto while_break___3;
    }
#line 586
    *(work + j) = 0.0;
#line 586
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 587
  i_beg = *(vr_ptr + i);
#line 588
  i_end = (i_beg + *(vr_len + i)) - 1;
#line 589
  i_ptr = i_beg;
  {
#line 589
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 589
    if (! (i_ptr <= i_end)) {
#line 589
      goto while_break___4;
    }
#line 591
    j = *(sv_ndx + i_ptr);
#line 593
    *(work + j) = *(sv_val + i_ptr);
#line 595
    j_beg = *(vc_ptr + j);
#line 596
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 597
    j_ptr = j_beg;
    {
#line 597
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 597
      if (! (*(sv_ndx + j_ptr) != i)) {
#line 597
        goto while_break___5;
      }
#line 597
      j_ptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 598
    if (j_ptr <= j_end) {
#line 598
      tmp___6 = 1;
    } else {
      {
#line 598
      dy_glp_insist("j_ptr <= j_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c",
                    598);
#line 598
      tmp___6 = 1;
      }
    }
#line 600
    *(sv_ndx + j_ptr) = *(sv_ndx + j_end);
#line 601
    *(sv_val + j_ptr) = *(sv_val + j_end);
#line 602
    (*(vc_len + j)) --;
#line 589
    i_ptr ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 605
  luf->nnz_v -= *(vr_len + i);
#line 606
  *(vr_len + i) = 0;
#line 609
  (inv->hh_nfs) ++;
#line 610
  *(hh_ndx + inv->hh_nfs) = i;
#line 612
  *(hh_len + inv->hh_nfs) = 0;
#line 615
  if (luf->sv_end - luf->sv_beg < k2 - k1) {
    {
#line 616
    dy_glp_luf_defrag_sva(luf);
    }
#line 617
    if (luf->sv_end - luf->sv_beg < k2 - k1) {
#line 619
      tmp___7 = 0;
#line 619
      luf->valid = tmp___7;
#line 619
      inv->valid = tmp___7;
#line 620
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 621
      ret = 4;
#line 622
      goto done;
    }
  }
#line 626
  k = k1;
  {
#line 626
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 626
    if (! (k < k2)) {
#line 626
      goto while_break___6;
    }
#line 628
    p = *(pp_row + k);
#line 628
    q = *(qq_col + k);
#line 631
    if (*(work + q) == 0.0) {
#line 631
      goto __Cont;
    }
#line 633
    f = *(work + q) / *(vr_piv + p);
#line 637
    p_beg = *(vr_ptr + p);
#line 638
    p_end = (p_beg + *(vr_len + p)) - 1;
#line 639
    p_ptr = p_beg;
    {
#line 639
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 639
      if (! (p_ptr <= p_end)) {
#line 639
        goto while_break___7;
      }
#line 640
      *(work + *(sv_ndx + p_ptr)) -= f * *(sv_val + p_ptr);
#line 639
      p_ptr ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 643
    (luf->sv_end) --;
#line 644
    *(sv_ndx + luf->sv_end) = p;
#line 645
    *(sv_val + luf->sv_end) = f;
#line 646
    (*(hh_len + inv->hh_nfs)) ++;
    __Cont: /* CIL Label */ 
#line 626
    k ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 651
  if (*(hh_len + inv->hh_nfs) == 0) {
#line 652
    (inv->hh_nfs) --;
  } else {
#line 654
    *(hh_ptr + inv->hh_nfs) = luf->sv_end;
#line 655
    inv->nnz_h += *(hh_len + inv->hh_nfs);
  }
#line 658
  *(vr_piv + i) = *(work + *(qq_col + k2));
#line 675
  cc_len = 0;
#line 676
  k = k2 + 1;
  {
#line 676
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 676
    if (! (k <= m)) {
#line 676
      goto while_break___8;
    }
    {
#line 678
    j = *(qq_col + k);
#line 679
    temp = *(work + j);
#line 681
    tmp___8 = fabs(temp);
    }
#line 681
    if (tmp___8 < eps_tol) {
#line 681
      goto __Cont___0;
    }
#line 683
    if (*(vc_len + j) + 1 > *(vc_cap + j)) {
      {
#line 684
      tmp___10 = dy_glp_luf_enlarge_col(luf, j, *(vc_len + j) + 10);
      }
#line 684
      if (tmp___10) {
#line 686
        tmp___9 = 0;
#line 686
        luf->valid = tmp___9;
#line 686
        inv->valid = tmp___9;
#line 687
        luf->new_sva = luf->sv_size + luf->sv_size;
#line 688
        ret = 4;
#line 689
        goto done;
      }
    }
#line 693
    j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 694
    *(sv_ndx + j_ptr) = i;
#line 695
    *(sv_val + j_ptr) = temp;
#line 696
    (*(vc_len + j)) ++;
#line 698
    cc_len ++;
#line 699
    *(cc_ndx + cc_len) = j;
#line 700
    *(cc_val + cc_len) = temp;
    __Cont___0: /* CIL Label */ 
#line 676
    k ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 704
  if (*(vr_cap + i) < cc_len) {
    {
#line 705
    tmp___12 = dy_glp_luf_enlarge_row(luf, i, cc_len);
    }
#line 705
    if (tmp___12) {
#line 707
      tmp___11 = 0;
#line 707
      luf->valid = tmp___11;
#line 707
      inv->valid = tmp___11;
#line 708
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 709
      ret = 4;
#line 710
      goto done;
    }
  }
  {
#line 714
  i_ptr = *(vr_ptr + i);
#line 715
  memmove((void *)(sv_ndx + i_ptr), (void const   *)(cc_ndx + 1), (unsigned long )cc_len * sizeof(int ));
#line 716
  memmove((void *)(sv_val + i_ptr), (void const   *)(cc_val + 1), (unsigned long )cc_len * sizeof(double ));
#line 717
  *(vr_len + i) = cc_len;
#line 718
  luf->nnz_v += cc_len;
#line 724
  temp = 0.0;
#line 726
  i = *(pp_row + k2);
#line 727
  i_beg = *(vr_ptr + i);
#line 728
  i_end = (i_beg + *(vr_len + i)) - 1;
#line 729
  i_ptr = i_beg;
  }
  {
#line 729
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 729
    if (! (i_ptr <= i_end)) {
#line 729
      goto while_break___9;
    }
    {
#line 730
    tmp___13 = fabs(*(sv_val + i_ptr));
    }
#line 730
    if (temp < tmp___13) {
      {
#line 730
      temp = fabs(*(sv_val + i_ptr));
      }
    }
#line 729
    i_ptr ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 732
  j = *(qq_col + k2);
#line 733
  j_beg = *(vc_ptr + j);
#line 734
  j_end = (j_beg + *(vc_len + j)) - 1;
#line 735
  j_ptr = j_beg;
  {
#line 735
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 735
    if (! (j_ptr <= j_end)) {
#line 735
      goto while_break___10;
    }
    {
#line 736
    tmp___14 = fabs(*(sv_val + j_ptr));
    }
#line 736
    if (temp < tmp___14) {
      {
#line 736
      temp = fabs(*(sv_val + j_ptr));
      }
    }
#line 735
    j_ptr ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 738
  tmp___15 = fabs(*(vr_piv + i));
#line 738
  inv->min_vrratio = tmp___15 / (upd_tol * temp);
#line 739
  tmp___17 = fabs(*(vr_piv + i));
  }
#line 739
  if (tmp___17 < upd_tol * temp) {
#line 742
    tmp___16 = 0;
#line 742
    luf->valid = tmp___16;
#line 742
    inv->valid = tmp___16;
#line 743
    ret = 2;
#line 744
    goto done;
  }
#line 748
  inv->cc_len = -1;
  done: 
#line 750
  return (ret);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpinv.c"
void dy_glp_inv_delete(INV *inv ) 
{ 


  {
  {
#line 768
  dy_glp_luf_delete(inv->luf);
#line 769
  dy_glp_ufree((void *)inv->hh_ndx);
#line 770
  dy_glp_ufree((void *)inv->hh_ptr);
#line 771
  dy_glp_ufree((void *)inv->hh_len);
#line 772
  dy_glp_ufree((void *)inv->p0_row);
#line 773
  dy_glp_ufree((void *)inv->p0_col);
#line 774
  dy_glp_ufree((void *)inv->cc_ndx);
#line 775
  dy_glp_ufree((void *)inv->cc_val);
#line 776
  dy_glp_ufree((void *)inv);
  }
#line 777
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_keytab.h"
int find(char *word , keytab_entry *keytab , int numkeys ) ;
#line 42
int ambig(char *word , keytab_entry *keytab , int numkeys ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_binsrch.c"
int find(char *word , keytab_entry *keytab , int numkeys ) 
{ 
  int high ;
  int low ;
  int mid ;
  int place ;

  {
#line 43
  low = 0;
#line 44
  high = numkeys - 1;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (low <= high)) {
#line 45
      goto while_break;
    }
    {
#line 46
    mid = (high + low) / 2;
#line 47
    place = cistrcmp((char const   *)word, (keytab + mid)->keyword);
    }
    {
#line 49
    if (place == -1) {
#line 49
      goto case_neg_1;
    }
#line 52
    if (place == 0) {
#line 52
      goto case_0;
    }
#line 54
    if (place == 1) {
#line 54
      goto case_1;
    }
#line 48
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 50
    high = mid - 1;
#line 51
    goto switch_break;
    case_0: /* CIL Label */ 
#line 53
    return ((keytab + mid)->token);
    case_1: /* CIL Label */ 
#line 55
    low = mid + 1;
#line 56
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (-1);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_binsrch.c"
int ambig(char *word , keytab_entry *keytab , int numkeys ) 
{ 
  int high ;
  int low ;
  int mid ;
  int place ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 82
  low = 0;
#line 83
  high = numkeys - 1;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (low <= high)) {
#line 84
      goto while_break;
    }
    {
#line 85
    mid = (high + low) / 2;
#line 86
    place = cimstrcmp((char const   *)word, (keytab + mid)->keyword);
    }
    {
#line 88
    if (place == -1) {
#line 88
      goto case_neg_1;
    }
#line 91
    if (place == 0) {
#line 91
      goto case_0;
    }
#line 100
    if (place == 1) {
#line 100
      goto case_1;
    }
#line 87
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 89
    high = mid - 1;
#line 90
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 92
    tmp___2 = strlen((char const   *)word);
    }
#line 92
    if (tmp___2 < (size_t )((keytab + mid)->min - 1)) {
#line 93
      return (-2);
    } else {
      {
#line 95
      tmp___1 = strlen((keytab + mid)->keyword);
      }
#line 95
      if (tmp___1 >= (size_t )(keytab + mid)->min) {
#line 96
        return ((keytab + mid)->token);
      } else {
        {
#line 98
        tmp = strlen((keytab + mid)->keyword);
#line 98
        tmp___0 = strlen((char const   *)word);
        }
#line 98
        if (tmp == tmp___0) {
#line 99
          return ((keytab + mid)->token);
        }
      }
    }
    case_1: /* CIL Label */ 
#line 101
    low = mid + 1;
#line 102
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (-1);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.h"
void *lookup(char const   *key , hel **hashtab , int size ) ;
#line 43
void *search(char const   *key , hel **hashtab , int size , bool init ) ;
#line 43
void *enter(char const   *key , hel **hashtab , int size , void *entry ) ;
#line 43
void *erase(char const   *key , hel **hashtab , int size ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
static int hash(char const   *key , int size ) 
{ 
  int hashval ;
  char const   *tmp ;

  {
#line 49
  hashval = 0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((int const   )*key != 0)) {
#line 49
      goto while_break;
    }
#line 49
    tmp = key;
#line 49
    key ++;
#line 49
    hashval += (int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (hashval % size);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
void *lookup(char const   *key , hel **hashtab , int size ) 
{ 
  hel *hshel___0 ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;

  {
#line 73
  rtnnme = "lookup";
#line 75
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null key!\n",
            rtnnme);
    }
#line 77
    return ((void *)0);
  }
#line 78
  if ((unsigned long )hashtab == (unsigned long )((void *)0)) {
    {
#line 79
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null hashtab!\n",
            rtnnme);
    }
#line 80
    return ((void *)0);
  }
#line 81
  if (size <= 0) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: hashtab size violates 0 < %d!\n",
            rtnnme, size);
    }
#line 83
    return ((void *)0);
  }
  {
#line 85
  tmp = hash(key, size);
#line 85
  hshel___0 = *(hashtab + tmp);
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )hshel___0 != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp___0 = strcmp(key, hshel___0->key);
    }
#line 86
    if (tmp___0 == 0) {
#line 87
      return (hshel___0->ent);
    }
#line 85
    hshel___0 = hshel___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return ((void *)0);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
static hel *hshel  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
static bool search_hshel_is_valid  =    (bool )0;
#line 93 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
void *search(char const   *key , hel **hashtab , int size , bool init ) 
{ 
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;

  {
#line 116
  rtnnme = "search";
#line 118
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null key!\n",
            rtnnme);
#line 120
    search_hshel_is_valid = (bool )0;
    }
#line 121
    return ((void *)0);
  }
#line 122
  if ((unsigned long )hashtab == (unsigned long )((void *)0)) {
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null hashtab!\n",
            rtnnme);
#line 124
    search_hshel_is_valid = (bool )0;
    }
#line 125
    return ((void *)0);
  }
#line 126
  if (size <= 0) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: hashtab size violates 0 < %d!\n",
            rtnnme, size);
#line 128
    search_hshel_is_valid = (bool )0;
    }
#line 129
    return ((void *)0);
  }
#line 131
  if ((int )init == 1) {
    {
#line 132
    tmp = hash(key, size);
#line 132
    hshel = *(hashtab + tmp);
#line 133
    search_hshel_is_valid = (bool )1;
    }
  } else {
#line 135
    if ((int )search_hshel_is_valid != 1) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: attempt to continue before an init!\n",
              rtnnme);
      }
#line 137
      return ((void *)0);
    }
#line 138
    if ((unsigned long )hshel != (unsigned long )((void *)0)) {
#line 138
      hshel = hshel->next;
    }
  }
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )hshel != (unsigned long )((void *)0))) {
#line 140
      goto while_break;
    }
    {
#line 141
    tmp___0 = strcmp(key, hshel->key);
    }
#line 141
    if (tmp___0 == 0) {
#line 141
      return (hshel->ent);
    }
#line 140
    hshel = hshel->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  search_hshel_is_valid = (bool )0;
#line 144
  return ((void *)0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
void *enter(char const   *key , hel **hashtab , int size , void *entry ) 
{ 
  hel *new ;
  int hashval ;
  char const   *rtnnme ;
  void *tmp ;

  {
#line 167
  rtnnme = "enter";
#line 169
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null key!\n",
            rtnnme);
    }
#line 171
    return ((void *)0);
  }
#line 172
  if ((unsigned long )hashtab == (unsigned long )((void *)0)) {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null hashtab!\n",
            rtnnme);
    }
#line 174
    return ((void *)0);
  }
#line 175
  if (size <= 0) {
    {
#line 176
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: hashtab size violates 0 < %d!\n",
            rtnnme, size);
    }
#line 177
    return ((void *)0);
  }
  {
#line 179
  tmp = malloc(sizeof(hel ));
#line 179
  new = (hel *)tmp;
#line 180
  hashval = hash(key, size);
#line 181
  new->next = *(hashtab + hashval);
#line 182
  new->key = key;
#line 183
  new->ent = entry;
#line 184
  *(hashtab + hashval) = new;
  }
#line 185
  return (entry);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_hash.c"
void *erase(char const   *key , hel **hashtab , int size ) 
{ 
  int hashval ;
  hel *hshel1 ;
  hel **hshel2 ;
  void *entry ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 210
  rtnnme = "erase";
#line 212
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null key!\n",
            rtnnme);
    }
#line 214
    return ((void *)0);
  }
#line 215
  if ((unsigned long )hashtab == (unsigned long )((void *)0)) {
    {
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null hashtab!\n",
            rtnnme);
    }
#line 217
    return ((void *)0);
  }
#line 218
  if (size <= 0) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: hashtab size violates 0 < %d!\n",
            rtnnme, size);
    }
#line 220
    return ((void *)0);
  }
  {
#line 222
  hashval = hash(key, size);
#line 223
  hshel2 = hashtab + hashval;
#line 223
  hshel1 = *hshel2;
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )hshel1 != (unsigned long )((void *)0))) {
#line 223
      goto while_break;
    }
    {
#line 226
    tmp = strcmp(key, hshel1->key);
    }
#line 226
    if (tmp == 0) {
      {
#line 227
      *hshel2 = hshel1->next;
#line 228
      entry = hshel1->ent;
#line 229
      free((void *)hshel1);
      }
#line 230
      return (entry);
    }
#line 223
    hshel2 = & hshel1->next;
#line 223
    hshel1 = *hshel2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 232
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: can\'t locate key %s.\n",
          rtnnme, key);
  }
#line 233
  return ((void *)0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int fdcandcompare(void const   *p_fdcand1 , void const   *p_fdcand2 ) 
{ 
  int i ;
  int j ;
  fdcand_struct const   *fdcand1 ;
  fdcand_struct const   *fdcand2 ;

  {
#line 123
  fdcand1 = (fdcand_struct const   *)p_fdcand1;
#line 124
  fdcand2 = (fdcand_struct const   *)p_fdcand2;
#line 126
  i = (int )fdcand1->ndx;
#line 127
  j = (int )fdcand2->ndx;
#line 129
  return (j - i);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int intcompare___1(void const   *p_i , void const   *p_j ) 
{ 
  int i ;
  int j ;

  {
#line 140
  i = (int )*((int const   *)p_i);
#line 141
  j = (int )*((int const   *)p_j);
#line 143
  return (j - i);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int scanPrimVarDualInfeas(fdcand_struct **p_fdcands ) 
{ 
  int j ;
  int n ;
  int purgecnt ;
  int flipcnt ;
  fdcand_struct *fdcands ;
  double cbarj ;
  double lbj ;
  double ubj ;
  double *vlb ;
  double *vub ;
  flags statj ;
  bool purge ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 187
  n = dy_sys->varcnt;
#line 188
  vlb = dy_sys->vlb;
#line 189
  vub = dy_sys->vub;
#line 190
  purgecnt = 0;
#line 191
  if ((unsigned long )*p_fdcands == (unsigned long )((void *)0)) {
    {
#line 192
    tmp = malloc((unsigned long )(dy_sys->archvcnt + 1) * sizeof(fdcand_struct ));
#line 192
    fdcands = (fdcand_struct *)tmp;
    }
  } else {
#line 195
    fdcands = *p_fdcands;
  }
#line 200
  flipcnt = 0;
#line 201
  j = 1;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (j <= n)) {
#line 201
      goto while_break;
    }
#line 202
    purge = (bool )0;
#line 203
    statj = *(dy_status + j);
#line 204
    cbarj = *(dy_cbar + j);
#line 205
    if (statj & (unsigned int )(1 << 7)) {
#line 205
      tmp___4 = 1;
    } else {
#line 205
      tmp___4 = 0;
    }
#line 205
    if (tmp___4) {
#line 205
      if (cbarj < - dy_tols->dfeas) {
#line 205
        goto _L;
      } else {
#line 205
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 205
      if (statj & (unsigned int )(1 << 6)) {
#line 205
        tmp___5 = 1;
      } else {
#line 205
        tmp___5 = 0;
      }
#line 205
      if (tmp___5) {
#line 205
        if (cbarj > dy_tols->dfeas) {
          _L: /* CIL Label */ 
#line 207
          purgecnt ++;
#line 207
          (fdcands + purgecnt)->ndx = j;
#line 208
          (fdcands + purgecnt)->flippable = (bool )0;
#line 209
          lbj = *(vlb + j);
#line 210
          ubj = *(vub + j);
#line 211
          if (statj & (unsigned int )(1 << 7)) {
#line 211
            tmp___0 = 1;
          } else {
#line 211
            tmp___0 = 0;
          }
#line 211
          if (tmp___0) {
#line 212
            if (ubj < dy_tols->inf) {
#line 213
              (fdcands + purgecnt)->flippable = (bool )1;
#line 214
              flipcnt ++;
#line 215
              (fdcands + purgecnt)->delta = ubj - lbj;
            }
          } else
#line 217
          if (lbj > - dy_tols->inf) {
#line 218
            (fdcands + purgecnt)->flippable = (bool )1;
#line 219
            flipcnt ++;
#line 220
            (fdcands + purgecnt)->delta = lbj - ubj;
          }
#line 222
          if (dy_opts->print.force >= 3) {
            {
#line 223
            tmp___1 = dy_prtvstat(statj);
            }
#line 223
            if ((int )(fdcands + purgecnt)->flippable == 1) {
#line 223
              tmp___2 = "flip";
            } else {
#line 223
              tmp___2 = "deactivation";
            }
            {
#line 223
            tmp___3 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 223
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n      queuing %s (%d) for %s, %s, cbar<%d> = %g",
                        tmp___3, j, tmp___2, tmp___1, j, cbarj);
            }
          }
        }
      }
    }
#line 201
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  if (purgecnt == 0) {
#line 236
    if ((unsigned long )*p_fdcands == (unsigned long )((void *)0)) {
      {
#line 237
      free((void *)fdcands);
      }
    }
  } else {
#line 239
    if (flipcnt > 0) {
#line 240
      (fdcands + 0)->flippable = (bool )1;
    } else {
#line 242
      (fdcands + 0)->flippable = (bool )0;
    }
#line 243
    if ((unsigned long )*p_fdcands == (unsigned long )((void *)0)) {
#line 244
      *p_fdcands = fdcands;
    }
  }
#line 247
  if (dy_opts->print.force >= 2) {
    {
#line 248
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %d variables, %d deactivate, %d flip.",
                purgecnt, purgecnt - flipcnt, flipcnt);
    }
  }
#line 253
  return (purgecnt);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
dyphase_enum dy_forcePrimal2Dual(consys_struct *orig_sys ) 
{ 
  int j ;
  int m ;
  int cand_cnt ;
  int ndx ;
  int varcnt ;
  int concnt ;
  int suppressed ;
  fdcand_struct *candidates ;
  double *vlb ;
  double *vub ;
  dyret_enum factorresult ;
  flags calcflgs ;
  flags statj ;
  bool retval ;
  dyret_enum upd_retval ;
  dyphase_enum next_phase ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;

  {
#line 337
  rtnnme = "dy_forcePrimal2Dual";
#line 339
  next_phase = (dyphase_enum )0;
#line 361
  if ((int )dy_lp->p1obj.installed == 1) {
    {
#line 362
    tmp___0 = dy_swapobjs((dyphase_enum )3);
    }
#line 362
    if ((int )tmp___0 == 0) {
      {
#line 363
      tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 363
      errmsg(318, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "remove");
      }
#line 366
      return ((dyphase_enum )0);
    }
    {
#line 367
    dy_calcduals();
#line 368
    tmp___2 = dy_calccbar();
    }
#line 368
    if ((int )tmp___2 == 0) {
      {
#line 369
      tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 369
      errmsg(384, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters);
      }
#line 371
      return ((dyphase_enum )0);
    }
  }
  {
#line 375
  candidates = (fdcand_struct *)((void *)0);
#line 376
  cand_cnt = scanPrimVarDualInfeas(& candidates);
  }
#line 377
  if (cand_cnt < 0) {
    {
#line 378
    tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 378
    errmsg(434, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, "variable", "forced primal -> dual transition");
    }
#line 381
    if ((unsigned long )candidates != (unsigned long )((void *)0)) {
      {
#line 381
      free((void *)candidates);
      }
    }
#line 382
    return ((dyphase_enum )0);
  }
  {
#line 397
  qsort((void *)(candidates + 1), (size_t )cand_cnt, sizeof(fdcand_struct ), & fdcandcompare);
#line 398
  m = dy_sys->concnt;
#line 399
  vlb = dy_sys->vlb;
#line 400
  vub = dy_sys->vub;
#line 401
  varcnt = 0;
#line 402
  concnt = 0;
#line 403
  suppressed = 0;
#line 404
  retval = (bool )1;
#line 405
  ndx = 1;
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (ndx <= cand_cnt) {
#line 405
      if (! ((int )retval == 1)) {
#line 405
        goto while_break;
      }
    } else {
#line 405
      goto while_break;
    }
#line 406
    j = (candidates + ndx)->ndx;
#line 418
    if ((int )(candidates + ndx)->flippable == 1) {
#line 418
      if ((int )dy_opts->heroics.flips == 1) {
#line 419
        varcnt ++;
#line 421
        if (dy_opts->print.force >= 2) {
          {
#line 422
          tmp___4 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 422
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    flipping variable %s (%d)", tmp___4,
                      j);
          }
        }
        {
#line 425
        upd_retval = dy_updateprimals(j, (candidates + ndx)->delta, (double *)((void *)0));
        }
#line 426
        if ((int )upd_retval == -10) {
#line 427
          retval = (bool )0;
#line 428
          goto while_break;
        }
#line 429
        statj = *(dy_status + j);
#line 430
        if (statj & (unsigned int )(1 << 7)) {
#line 430
          tmp___5 = 1;
        } else {
#line 430
          tmp___5 = 0;
        }
#line 430
        if (tmp___5) {
#line 431
          *(dy_x + j) = *(vub + j);
        } else {
#line 433
          *(dy_x + j) = *(vlb + j);
        }
#line 434
        *(dy_status + j) ^= (unsigned int )((1 << 7) | (1 << 6));
      } else {
#line 418
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 440
    if (j > m) {
#line 441
      varcnt ++;
#line 443
      if (dy_opts->print.force >= 2) {
        {
#line 444
        tmp___6 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 444
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating variable %s (%d)",
                    tmp___6, j);
        }
      }
      {
#line 447
      retval = dy_deactNBPrimArch(orig_sys, j);
      }
#line 448
      if ((int )retval == 0) {
        {
#line 449
        tmp___7 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 449
        tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 449
        errmsg(430, rtnnme, dy_sys->nme, tmp___8, dy_lp->tot.iters, "deactivate",
               "variable", tmp___7, j);
        }
      }
    } else
#line 460
    if ((int )dy_opts->heroics.p2d == 1) {
#line 461
      concnt ++;
#line 463
      if (dy_opts->print.force >= 2) {
        {
#line 464
        tmp___9 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 464
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating constraint %s (%d)",
                    tmp___9, j);
        }
      }
      {
#line 468
      retval = dy_deactNBLogPrimCon(orig_sys, j);
      }
#line 469
      if ((int )retval == 0) {
        {
#line 470
        tmp___10 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 470
        tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 470
        errmsg(430, rtnnme, dy_sys->nme, tmp___11, dy_lp->tot.iters, "deactivate",
               "constraint", tmp___10, j);
        }
      }
    } else {
#line 475
      suppressed ++;
    }
#line 405
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  free((void *)candidates);
  }
#line 478
  if ((int )retval == 0) {
#line 478
    return ((dyphase_enum )0);
  }
#line 481
  if (dy_opts->print.force >= 1) {
#line 482
    if (dy_opts->print.force >= 2) {
      {
#line 483
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
      }
    }
    {
#line 484
    dyio_outfmt(dy_logchn, dy_gtxecho, " %d+%d deletions.", concnt, varcnt);
#line 485
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 501
  if (dy_opts->print.force >= 2) {
    {
#line 502
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      factoring, checking accuracy and feasibility ...");
    }
  }
  {
#line 505
  calcflgs = (flags )(((((((1 << 8) | (1 << 1)) | (1 << 4)) | 1) | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 507
  factorresult = dy_accchk(& calcflgs);
  }
  {
#line 510
  if ((int )factorresult == 2) {
#line 510
    goto case_2;
  }
#line 510
  if ((int )factorresult == 1) {
#line 510
    goto case_2;
  }
#line 527
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 513
  if (dy_opts->print.force >= 2) {
#line 514
    if ((int )factorresult == 1) {
      {
#line 515
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
      }
    } else {
      {
#line 517
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
      }
    }
    {
#line 518
    dyio_outfmt(dy_logchn, dy_gtxecho, " Feasibility:");
    }
#line 519
    if (calcflgs & 1U) {
#line 519
      tmp___12 = 0;
    } else {
#line 519
      tmp___12 = 1;
    }
#line 519
    if (tmp___12) {
      {
#line 520
      dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
      }
    }
#line 521
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 521
      tmp___13 = 0;
    } else {
#line 521
      tmp___13 = 1;
    }
#line 521
    if (tmp___13) {
      {
#line 522
      dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
      }
    }
#line 523
    if ((calcflgs & (unsigned int )(1 | (1 << 3))) == (unsigned int )(1 | (1 << 3))) {
#line 523
      tmp___14 = 1;
    } else {
#line 523
      tmp___14 = 0;
    }
#line 523
    if (tmp___14) {
      {
#line 524
      dyio_outfmt(dy_logchn, dy_gtxecho, " none");
      }
    }
  }
#line 526
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 528
  next_phase = (dyphase_enum )0;
#line 530
  if (dy_opts->print.force >= 2) {
    {
#line 531
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
    }
  }
#line 533
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 568
  if ((unsigned int )dy_lp->simplex.active == 4U) {
#line 569
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 569
      tmp___16 = 0;
    } else {
#line 569
      tmp___16 = 1;
    }
#line 569
    if (tmp___16) {
#line 570
      dy_lp->simplex.next = (dyphase_enum )4;
#line 571
      if (concnt != 0) {
#line 571
        dy_lp->simplex.init_dse = (bool )1;
      }
#line 572
      next_phase = (dyphase_enum )7;
    } else {
#line 574
      dy_lp->simplex.init_pse = (bool )1;
#line 575
      if (calcflgs & 1U) {
#line 575
        tmp___15 = 0;
      } else {
#line 575
        tmp___15 = 1;
      }
#line 575
      if (tmp___15) {
#line 576
        dy_lp->simplex.next = (dyphase_enum )3;
      } else {
#line 578
        dy_lp->simplex.next = (dyphase_enum )2;
      }
#line 579
      next_phase = (dyphase_enum )7;
    }
  } else {
#line 586
    dy_lp->lpret = (lpret_enum )11;
#line 587
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 587
      tmp___17 = 0;
    } else {
#line 587
      tmp___17 = 1;
    }
#line 587
    if (tmp___17) {
#line 588
      dy_lp->simplex.next = (dyphase_enum )4;
#line 589
      dy_lp->simplex.init_dse = (bool )1;
#line 590
      next_phase = (dyphase_enum )9;
    } else {
#line 592
      next_phase = (dyphase_enum )13;
    }
  }
#line 595
  if (dy_opts->print.force >= 1) {
    {
#line 596
    tmp___18 = dy_prtlpphase(dy_lp->simplex.next, (bool )0);
#line 596
    tmp___19 = dy_prtlpphase(next_phase, (bool )0);
#line 596
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   next phase %s, next simplex %s.", tmp___19,
                tmp___18);
    }
  }
#line 601
  return (next_phase);
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int scanPrimConForceDeact(int **p_acndxs ) 
{ 
  int bpos ;
  int j ;
  int m ;
  int purgecnt ;
  int *acndxs ;
  flags statj ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 637
  m = dy_sys->concnt;
#line 638
  if ((unsigned long )*p_acndxs == (unsigned long )((void *)0)) {
    {
#line 639
    tmp = malloc((unsigned long )m * sizeof(int ));
#line 639
    acndxs = (int *)tmp;
    }
  } else {
#line 641
    acndxs = *p_acndxs;
  }
#line 647
  purgecnt = 0;
#line 648
  bpos = 1;
  {
#line 648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 648
    if (! (bpos <= m)) {
#line 648
      goto while_break;
    }
#line 649
    j = *(dy_basis + bpos);
#line 650
    statj = *(dy_status + j);
#line 651
    if (statj & (unsigned int )((1 << 11) | (1 << 10))) {
#line 651
      tmp___7 = 1;
    } else {
#line 651
      tmp___7 = 0;
    }
#line 651
    if (tmp___7) {
#line 652
      tmp___0 = purgecnt;
#line 652
      purgecnt ++;
#line 652
      *(acndxs + tmp___0) = j;
#line 654
      if (dy_opts->print.force >= 3) {
#line 655
        if (j <= m) {
          {
#line 656
          tmp___1 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 656
          tmp___2 = consys_prtcontyp(*(dy_sys->ctyp + j));
#line 656
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s %s (%d) for deactivation, ",
                      tmp___2, tmp___1, j);
#line 660
          tmp___3 = dy_prtvstat(statj);
#line 660
          tmp___4 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 660
          dyio_outfmt(dy_logchn, dy_gtxecho, "%s (%d) = %g, status %s, basis pos\'n %d.",
                      tmp___4, j, *(dy_x + j), tmp___3, bpos);
          }
        } else {
          {
#line 665
          tmp___5 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 665
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s (%d) = %g for deactivation, ",
                      tmp___5, j, *(dy_x + j));
#line 668
          tmp___6 = dy_prtvstat(statj);
#line 668
          dyio_outfmt(dy_logchn, dy_gtxecho, "status %s, basis pos\'n %d.", tmp___6,
                      bpos);
          }
        }
      }
    }
#line 648
    bpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 674
  if ((unsigned long )*p_acndxs == (unsigned long )((void *)0)) {
#line 675
    if (purgecnt <= 0) {
      {
#line 676
      free((void *)acndxs);
      }
    } else {
#line 678
      *p_acndxs = acndxs;
    }
  }
#line 681
  if (dy_opts->print.force >= 2) {
    {
#line 682
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %d constraints for deactivation.",
                purgecnt);
    }
  }
#line 686
  return (purgecnt);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
dyphase_enum dy_forceDual2Primal(consys_struct *orig_sys ) 
{ 
  int j ;
  int m ;
  int *candidates ;
  int cand_cnt ;
  int ndx ;
  int varcnt ;
  int concnt ;
  int suppressed ;
  dyret_enum factorresult ;
  flags calcflgs ;
  bool retval ;
  dyphase_enum next_phase ;
  char const   *rtnnme ;
  double tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
  {
#line 737
  rtnnme = "dy_forceDual2Primal";
#line 751
  next_phase = (dyphase_enum )0;
#line 758
  tmp = fabs(dy_lp->z);
  }
#line 758
  if (dy_lp->z - dy_lp->lastz.fp < dy_tols->purge * (1.0 + tmp)) {
#line 759
    dy_lp->simplex.next = (dyphase_enum )2;
#line 760
    dy_lp->simplex.init_pse = (bool )1;
#line 761
    return ((dyphase_enum )2);
  }
  {
#line 762
  dy_lp->lastz.fp = dy_lp->z;
#line 766
  candidates = (int *)((void *)0);
#line 767
  cand_cnt = scanPrimConForceDeact(& candidates);
  }
#line 768
  if (cand_cnt < 0) {
    {
#line 769
    tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 769
    errmsg(434, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, "constraint", "forced dual -> primal transition");
    }
#line 772
    if ((unsigned long )candidates != (unsigned long )((void *)0)) {
      {
#line 772
      free((void *)candidates);
      }
    }
#line 773
    return ((dyphase_enum )0);
  }
  {
#line 790
  qsort((void *)(candidates + 0), (size_t )cand_cnt, sizeof(int ), & intcompare___1);
#line 791
  m = dy_sys->concnt;
#line 792
  varcnt = 0;
#line 793
  concnt = 0;
#line 794
  suppressed = 0;
#line 795
  retval = (bool )1;
#line 796
  ndx = 0;
  }
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if (ndx < cand_cnt) {
#line 796
      if (! ((int )retval == 1)) {
#line 796
        goto while_break;
      }
    } else {
#line 796
      goto while_break;
    }
#line 797
    j = *(candidates + ndx);
#line 808
    if (j <= m) {
#line 809
      concnt ++;
#line 811
      if (dy_opts->print.force >= 2) {
        {
#line 812
        tmp___1 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 812
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating constraint %s (%d)",
                    tmp___1, j);
        }
      }
      {
#line 816
      retval = dy_deactBLogPrimCon(orig_sys, j);
      }
#line 817
      if ((int )retval == 0) {
        {
#line 818
        tmp___2 = consys_nme(dy_sys, (char )'c', j, (bool )1, (char *)((void *)0));
#line 818
        tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 818
        errmsg(430, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, "deactivate",
               "constraint", tmp___2, j);
        }
      }
    } else
#line 827
    if ((int )dy_opts->heroics.d2p == 1) {
#line 828
      varcnt ++;
#line 830
      if (dy_opts->print.force >= 2) {
        {
#line 831
        tmp___4 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 831
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    deactivating variable %s (%d)",
                    tmp___4, j);
        }
      }
      {
#line 834
      retval = dy_deactBPrimArch(orig_sys, j);
      }
#line 835
      if ((int )retval == 0) {
        {
#line 836
        tmp___5 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 836
        tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 836
        errmsg(430, rtnnme, dy_sys->nme, tmp___6, dy_lp->tot.iters, "deactivate",
               "variable", tmp___5, j);
        }
      }
    } else {
#line 841
      suppressed ++;
    }
#line 796
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 843
  free((void *)candidates);
  }
#line 844
  if ((int )retval == 0) {
#line 844
    return ((dyphase_enum )0);
  }
#line 847
  if (dy_opts->print.force >= 1) {
#line 848
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 849
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
      }
    }
    {
#line 850
    dyio_outfmt(dy_logchn, dy_gtxecho, " %d+%d deletions.", concnt, varcnt);
#line 851
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 867
  if (dy_opts->print.force >= 2) {
    {
#line 868
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      factoring, checking accuracy and feasibility.");
    }
  }
  {
#line 871
  calcflgs = (flags )(((((((1 << 8) | (1 << 1)) | (1 << 4)) | 1) | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 873
  factorresult = dy_accchk(& calcflgs);
  }
  {
#line 876
  if ((int )factorresult == 2) {
#line 876
    goto case_2;
  }
#line 876
  if ((int )factorresult == 1) {
#line 876
    goto case_2;
  }
#line 893
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 879
  if (dy_opts->print.force >= 2) {
#line 880
    if ((int )factorresult == 1) {
      {
#line 881
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
      }
    } else {
      {
#line 883
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
      }
    }
    {
#line 884
    dyio_outfmt(dy_logchn, dy_gtxecho, " Feasibility:");
    }
#line 885
    if (calcflgs & 1U) {
#line 885
      tmp___7 = 0;
    } else {
#line 885
      tmp___7 = 1;
    }
#line 885
    if (tmp___7) {
      {
#line 886
      dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
      }
    }
#line 887
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 887
      tmp___8 = 0;
    } else {
#line 887
      tmp___8 = 1;
    }
#line 887
    if (tmp___8) {
      {
#line 888
      dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
      }
    }
#line 889
    if ((calcflgs & (unsigned int )(1 | (1 << 3))) == (unsigned int )(1 | (1 << 3))) {
#line 889
      tmp___9 = 1;
    } else {
#line 889
      tmp___9 = 0;
    }
#line 889
    if (tmp___9) {
      {
#line 890
      dyio_outfmt(dy_logchn, dy_gtxecho, " none");
      }
    }
  }
#line 892
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 896
  if (dy_opts->print.force >= 2) {
    {
#line 897
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
    }
  }
#line 899
  return ((dyphase_enum )0);
  switch_break: /* CIL Label */ ;
  }
#line 926
  dy_lp->lpret = (lpret_enum )12;
#line 927
  if (calcflgs & 1U) {
#line 927
    tmp___10 = 0;
  } else {
#line 927
    tmp___10 = 1;
  }
#line 927
  if (tmp___10) {
#line 928
    dy_lp->simplex.next = (dyphase_enum )3;
#line 929
    next_phase = (dyphase_enum )7;
  } else {
#line 931
    dy_lp->simplex.next = (dyphase_enum )2;
#line 932
    next_phase = (dyphase_enum )7;
  }
#line 933
  dy_lp->simplex.init_pse = (bool )1;
#line 936
  if (dy_opts->print.force >= 1) {
    {
#line 937
    tmp___11 = dy_prtlpphase(dy_lp->simplex.next, (bool )0);
#line 937
    tmp___12 = dy_prtlpphase(next_phase, (bool )0);
#line 937
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   next phase %s, next simplex %s.", tmp___12,
                tmp___11);
    }
  }
#line 942
  return (next_phase);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int scanPrimVarForceAct(consys_struct *orig_sys , int **p_ovndxs ) 
{ 
  int j ;
  int n ;
  int actcnt ;
  int *ovndxs ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 980
  n = orig_sys->varcnt;
#line 985
  actcnt = n - dy_sys->archvcnt;
#line 986
  if ((unsigned long )*p_ovndxs == (unsigned long )((void *)0)) {
    {
#line 987
    tmp = malloc((unsigned long )actcnt * sizeof(int ));
#line 987
    ovndxs = (int *)tmp;
    }
  } else {
#line 989
    ovndxs = *p_ovndxs;
  }
#line 994
  actcnt = 0;
#line 995
  j = 1;
  {
#line 995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 995
    if (! (j <= n)) {
#line 995
      goto while_break;
    }
#line 996
    if (*(dy_origvars + j) < 0) {
#line 996
      if ((flags )(- *(dy_origvars + j)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 996
        tmp___0 = 0;
      } else {
#line 996
        tmp___0 = 1;
      }
#line 996
      if (! tmp___0) {
#line 996
        goto __Cont;
      }
    } else {
#line 996
      goto __Cont;
    }
#line 997
    tmp___1 = actcnt;
#line 997
    actcnt ++;
#line 997
    *(ovndxs + tmp___1) = j;
#line 999
    if (dy_opts->print.force >= 3) {
      {
#line 1000
      tmp___2 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1000
      tmp___3 = consys_prtvartyp(*(orig_sys->vtyp + j));
#line 1000
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s variable %s (%d),", tmp___3,
                  tmp___2, j);
      }
    }
    __Cont: /* CIL Label */ 
#line 995
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  if ((unsigned long )*p_ovndxs == (unsigned long )((void *)0)) {
#line 1009
    if (actcnt == 0) {
      {
#line 1010
      free((void *)ovndxs);
      }
    } else {
#line 1012
      *p_ovndxs = ovndxs;
    }
  }
#line 1015
  if (dy_opts->print.force >= 2) {
    {
#line 1016
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d variables for activation.",
                actcnt);
    }
  }
#line 1020
  return (actcnt);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
static int scanPrimConForceAct(consys_struct *orig_sys , int **p_ocndxs ) 
{ 
  int i ;
  int m ;
  int actcnt ;
  int *ocndxs ;
  void *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1056
  m = orig_sys->concnt;
#line 1061
  actcnt = m - dy_sys->concnt;
#line 1062
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
    {
#line 1063
    tmp = malloc((unsigned long )actcnt * sizeof(int ));
#line 1063
    ocndxs = (int *)tmp;
    }
  } else {
#line 1065
    ocndxs = *p_ocndxs;
  }
#line 1069
  actcnt = 0;
#line 1070
  i = 1;
  {
#line 1070
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1070
    if (! (i <= m)) {
#line 1070
      goto while_break;
    }
#line 1071
    if (! (*(dy_origcons + i) == 0)) {
#line 1071
      goto __Cont;
    }
#line 1072
    tmp___0 = actcnt;
#line 1072
    actcnt ++;
#line 1072
    *(ocndxs + tmp___0) = i;
#line 1074
    if (dy_opts->print.force >= 3) {
      {
#line 1075
      tmp___1 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1075
      tmp___2 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 1075
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s constraint %s (%d),", tmp___2,
                  tmp___1, i);
      }
    }
    __Cont: /* CIL Label */ 
#line 1070
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1083
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
#line 1084
    if (actcnt == 0) {
      {
#line 1085
      free((void *)ocndxs);
      }
    } else {
#line 1087
      *p_ocndxs = ocndxs;
    }
  }
#line 1090
  if (dy_opts->print.force >= 2) {
    {
#line 1091
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d constraints for activation.",
                actcnt);
    }
  }
#line 1095
  return (actcnt);
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_force.c"
dyphase_enum dy_forceFull(consys_struct *orig_sys ) 
{ 
  int *candidates ;
  int varcnt ;
  int concnt ;
  dyret_enum factorresult ;
  flags calcflgs ;
  bool retval ;
  dyphase_enum next_phase ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 1119
  rtnnme = "dy_forceFull";
#line 1121
  next_phase = (dyphase_enum )0;
#line 1134
  candidates = (int *)((void *)0);
#line 1135
  concnt = scanPrimConForceAct(orig_sys, & candidates);
  }
#line 1136
  if (concnt < 0) {
    {
#line 1137
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1137
    errmsg(434, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "constraint", "forced full activation");
#line 1140
    retval = (bool )0;
    }
  } else
#line 1142
  if (concnt > 0) {
    {
#line 1143
    retval = dy_actBLogPrimConList(orig_sys, concnt, candidates, (int **)((void *)0));
    }
  } else {
#line 1145
    retval = (bool )1;
  }
#line 1146
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1146
    free((void *)candidates);
    }
  }
#line 1147
  if ((int )retval == 0) {
#line 1148
    return ((dyphase_enum )0);
  }
  {
#line 1152
  candidates = (int *)((void *)0);
#line 1153
  varcnt = scanPrimVarForceAct(orig_sys, & candidates);
  }
#line 1154
  if (varcnt < 0) {
    {
#line 1155
    tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1155
    errmsg(434, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, "variable", "forced full activation");
    }
  } else
#line 1159
  if (varcnt > 0) {
    {
#line 1160
    retval = dy_actNBPrimArchList(orig_sys, varcnt, candidates);
    }
  } else {
#line 1162
    retval = (bool )1;
  }
#line 1163
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 1163
    free((void *)candidates);
    }
  }
#line 1164
  if (concnt < 0) {
#line 1165
    return ((dyphase_enum )0);
  } else
#line 1164
  if ((int )retval == 0) {
#line 1165
    return ((dyphase_enum )0);
  }
#line 1179
  if (dy_opts->print.force >= 1) {
    {
#line 1180
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %d+%d activations.", concnt, varcnt);
#line 1181
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 1192
  if (dy_opts->print.force >= 2) {
    {
#line 1193
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      factoring, checking accuracy and feasibility ...");
    }
  }
  {
#line 1196
  calcflgs = (flags )(((((((1 << 8) | (1 << 1)) | (1 << 4)) | 1) | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 1198
  factorresult = dy_accchk(& calcflgs);
  }
  {
#line 1201
  if ((int )factorresult == 2) {
#line 1201
    goto case_2;
  }
#line 1201
  if ((int )factorresult == 1) {
#line 1201
    goto case_2;
  }
#line 1218
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1204
  if (dy_opts->print.force >= 2) {
#line 1205
    if ((int )factorresult == 1) {
      {
#line 1206
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
      }
    } else {
      {
#line 1208
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
      }
    }
    {
#line 1209
    dyio_outfmt(dy_logchn, dy_gtxecho, " Feasibility:");
    }
#line 1210
    if (calcflgs & 1U) {
#line 1210
      tmp___1 = 0;
    } else {
#line 1210
      tmp___1 = 1;
    }
#line 1210
    if (tmp___1) {
      {
#line 1211
      dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
      }
    }
#line 1212
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 1212
      tmp___2 = 0;
    } else {
#line 1212
      tmp___2 = 1;
    }
#line 1212
    if (tmp___2) {
      {
#line 1213
      dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
      }
    }
#line 1214
    if ((calcflgs & (unsigned int )(1 | (1 << 3))) == (unsigned int )(1 | (1 << 3))) {
#line 1214
      tmp___3 = 1;
    } else {
#line 1214
      tmp___3 = 0;
    }
#line 1214
    if (tmp___3) {
      {
#line 1215
      dyio_outfmt(dy_logchn, dy_gtxecho, " none");
      }
    }
  }
#line 1217
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1219
  next_phase = (dyphase_enum )0;
#line 1221
  if (dy_opts->print.force >= 2) {
    {
#line 1222
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
    }
  }
#line 1224
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1229
  dy_lp->lpret = (lpret_enum )13;
#line 1230
  if (calcflgs & 1U) {
#line 1230
    tmp___5 = 0;
  } else {
#line 1230
    tmp___5 = 1;
  }
#line 1230
  if (tmp___5) {
#line 1231
    dy_lp->simplex.next = (dyphase_enum )3;
#line 1232
    dy_lp->simplex.init_pse = (bool )1;
#line 1233
    next_phase = (dyphase_enum )3;
  } else {
#line 1235
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 1235
      tmp___4 = 0;
    } else {
#line 1235
      tmp___4 = 1;
    }
#line 1235
    if (tmp___4) {
#line 1235
      if ((int )dy_opts->usedual == 1) {
#line 1236
        dy_lp->simplex.next = (dyphase_enum )4;
#line 1237
        dy_lp->simplex.init_dse = (bool )1;
#line 1238
        next_phase = (dyphase_enum )4;
      } else {
#line 1240
        dy_lp->simplex.next = (dyphase_enum )2;
#line 1241
        dy_lp->simplex.init_pse = (bool )1;
#line 1242
        next_phase = (dyphase_enum )2;
      }
    } else {
#line 1240
      dy_lp->simplex.next = (dyphase_enum )2;
#line 1241
      dy_lp->simplex.init_pse = (bool )1;
#line 1242
      next_phase = (dyphase_enum )2;
    }
  }
#line 1245
  if (dy_opts->print.force >= 1) {
    {
#line 1246
    tmp___6 = dy_prtlpphase(dy_lp->simplex.next, (bool )0);
#line 1246
    tmp___7 = dy_prtlpphase(next_phase, (bool )0);
#line 1246
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   next phase %s, next simplex %s.", tmp___7,
                tmp___6);
    }
  }
#line 1251
  return (next_phase);
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
consys_struct *consys_create(char const   *nme , flags parts , flags opts , int concnt ,
                             int varcnt , double infinity ) ;
#line 510
bool consys_attach(consys_struct *consys , flags what , int elsze , void **pvec ) ;
#line 1738 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
dyret_enum dy_warmstart(lpprob_struct *orig_lp ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_warmstart.c"
static void correct_for_patch(void) 
{ 
  int j ;
  int cnt ;
  flags statj ;
  double *vlb ;
  double *vub ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 44
  vlb = dy_sys->vlb;
#line 45
  vub = dy_sys->vub;
#line 57
  if (dy_opts->print.crash >= 3) {
    {
#line 58
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tcorrecting status due to basis patch ...");
    }
  }
#line 62
  cnt = 0;
#line 63
  j = dy_sys->concnt + 1;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (j <= dy_sys->varcnt)) {
#line 63
      goto while_break;
    }
#line 64
    statj = *(dy_status + j);
#line 65
    if (statj & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 65
      tmp___1 = 1;
    } else {
#line 65
      tmp___1 = 0;
    }
#line 65
    if (tmp___1) {
#line 65
      if (*(dy_var2basis + j) == 0) {
#line 66
        if (*(vlb + j) > - dy_tols->inf) {
#line 66
          if (*(vub + j) < dy_tols->inf) {
#line 67
            if (*(vub + j) == *(vlb + j)) {
#line 68
              *(dy_status + j) = (flags )(1 << 5);
#line 69
              *(dy_x + j) = *(vub + j);
            } else
#line 71
            if (*(dy_sys->obj + j) >= (double )0) {
#line 72
              *(dy_status + j) = (flags )(1 << 7);
#line 73
              *(dy_x + j) = *(vlb + j);
            } else {
#line 75
              *(dy_status + j) = (flags )(1 << 6);
#line 76
              *(dy_x + j) = *(vub + j);
            }
          } else {
#line 66
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 78
        if (*(vlb + j) > - dy_tols->inf) {
#line 79
          *(dy_status + j) = (flags )(1 << 7);
#line 80
          *(dy_x + j) = *(vlb + j);
        } else
#line 82
        if (*(vub + j) < dy_tols->inf) {
#line 83
          *(dy_status + j) = (flags )(1 << 6);
#line 84
          *(dy_x + j) = *(vub + j);
        } else {
#line 86
          *(dy_status + j) = (flags )(1 << 8);
#line 87
          *(dy_x + j) = (double )0;
        }
#line 89
        if (dy_opts->print.crash >= 4) {
          {
#line 90
          tmp = dy_prtvstat(*(dy_status + j));
#line 90
          tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 90
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  changing status for %s (%d) to %s,",
                      tmp___0, j, tmp);
#line 94
          dyio_outfmt(dy_logchn, dy_gtxecho, " value %g.", *(dy_x + j));
          }
        }
#line 96
        cnt ++;
      }
    }
#line 63
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (cnt == 0) {
#line 106
    if (dy_opts->print.crash >= 4) {
      {
#line 107
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  no architecturals corrected.");
      }
    }
  }
#line 110
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_warmstart.c"
dyret_enum dy_warmstart(lpprob_struct *orig_lp ) 
{ 
  int vndx ;
  int dyvndx ;
  int bpos ;
  int cndx ;
  int dycndx ;
  int dycsze ;
  int dyvsze ;
  int nbfxcnt ;
  double *vlb ;
  double *vub ;
  double vlbj ;
  double vubj ;
  double obj ;
  consys_struct *orig_sys ;
  flags *orig_status ;
  flags vstat ;
  flags calcflgs ;
  dyret_enum retval ;
  basisel_struct *orig_basis ;
  bool *orig_actvars ;
  bool rngseen ;
  bool noactvarspec ;
  pkvec_struct *pkcol ;
  char nmebuf[50] ;
  flags parts ;
  flags opts ;
  char const   *rtnnme ;
  double xi ;
  int tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;
  char const   *tmp___15 ;
  bool tmp___16 ;
  bool tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  bool tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  bool tmp___30 ;
  char *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  char const   *tmp___35 ;
  bool tmp___36 ;
  bool tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  bool tmp___40 ;
  bool tmp___41 ;
  bool tmp___42 ;
  bool tmp___43 ;
  bool tmp___44 ;
  char const   *tmp___45 ;
  bool tmp___46 ;
  char *tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  char const   *tmp___51 ;
  int tmp___52 ;
  bool tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;

  {
#line 148
  parts = ((((((1U << 3) | (1U << 4)) | (1U << 5)) | (1U << 6)) | (1U << 9)) | (1U << 10)) | (1U << 11);
#line 148
  opts = 1U | (1U << 2);
#line 152
  rtnnme = "dy_warmstart";
#line 160
  retval = (dyret_enum )0;
#line 161
  nbfxcnt = -1;
#line 166
  orig_sys = orig_lp->consys;
#line 167
  orig_status = orig_lp->status;
#line 168
  orig_basis = (orig_lp->basis)->el;
#line 169
  if (orig_lp->ctlopts & (unsigned int )(1 << 6)) {
#line 169
    tmp = 1;
  } else {
#line 169
    tmp = 0;
  }
#line 169
  if (tmp) {
#line 169
    if ((int )dy_opts->fullsys == 0) {
#line 170
      orig_actvars = orig_lp->actvars;
#line 171
      noactvarspec = (bool )0;
    } else {
#line 173
      orig_actvars = (bool *)((void *)0);
#line 174
      noactvarspec = (bool )1;
    }
  } else {
#line 173
    orig_actvars = (bool *)((void *)0);
#line 174
    noactvarspec = (bool )1;
  }
  {
#line 178
  dy_lp->sys.forcedfull = (bool )0;
#line 179
  dy_lp->sys.vars.loadable = orig_sys->varcnt;
#line 180
  dy_lp->sys.vars.unloadable = 0;
#line 181
  dy_lp->sys.cons.loadable = orig_sys->concnt;
#line 182
  dy_lp->sys.cons.unloadable = 0;
#line 205
  vub = orig_sys->vub;
#line 206
  vlb = orig_sys->vlb;
#line 207
  dyio_outfxd(nmebuf, - ((int )(sizeof(nmebuf) - 1UL)), (char )'l', "%s[actv]", orig_sys->nme);
  }
#line 209
  if ((int )noactvarspec == 0) {
#line 210
    dyvsze = 0;
#line 211
    vndx = 1;
    {
#line 211
    while (1) {
      while_continue: /* CIL Label */ ;
#line 211
      if (! (vndx <= orig_sys->varcnt)) {
#line 211
        goto while_break;
      }
      {
#line 212
      vlbj = *(vlb + vndx);
#line 213
      vubj = *(vub + vndx);
#line 214
      tmp___1 = fabs(vubj);
      }
#line 214
      if (tmp___1 < dy_tols->inf) {
        {
#line 214
        tmp___2 = fabs(vlbj - vubj);
#line 214
        tmp___3 = fabs(vubj);
        }
#line 214
        if (tmp___2 < dy_tols->pfeas * (1.0 + tmp___3)) {
#line 215
          if (vlbj != vubj) {
#line 218
            if (dy_opts->print.setup >= 3) {
              {
#line 219
              tmp___0 = consys_nme(orig_sys, (char )'v', vndx, (bool )0, (char *)0);
#line 219
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tForcing equal bound %g for %s (%d)",
                          (vlbj + vubj) / (double )2, tmp___0, vndx);
#line 222
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  original lb = %g, ub = %g, diff = %g, tol = %g",
                          vlbj, vubj, vubj - vlbj, dy_tols->pfeas);
              }
            }
#line 226
            *(vlb + vndx) = (vlbj + vubj) / (double )2;
#line 227
            *(vub + vndx) = *(vlb + vndx);
          }
#line 228
          if ((int )*(orig_status + vndx) > 0) {
#line 229
            *(orig_status + vndx) = (flags )(1 << 5);
#line 230
            *(orig_actvars + vndx) = (bool )0;
          }
        }
      }
#line 231
      if (*(vlb + vndx) > *(vub + vndx)) {
#line 232
        dy_lp->lpret = (lpret_enum )4;
#line 234
        if (dy_opts->print.setup >= 1) {
          {
#line 235
          tmp___4 = consys_nme(orig_sys, (char )'v', vndx, (bool )0, (char *)0);
#line 235
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tTrivial infeasibility for %s (%d), lb = %g > ub = %g.",
                      tmp___4, vndx, *(vlb + vndx), *(vub + vndx));
          }
        }
      }
#line 240
      if ((int )*(orig_actvars + vndx) == 1) {
#line 240
        dyvsze ++;
      }
#line 211
      vndx ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 242
    nbfxcnt = 0;
#line 243
    vndx = 1;
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 243
      if (! (vndx <= orig_sys->varcnt)) {
#line 243
        goto while_break___0;
      }
      {
#line 244
      vlbj = *(vlb + vndx);
#line 245
      vubj = *(vub + vndx);
#line 246
      tmp___6 = fabs(vubj);
      }
#line 246
      if (tmp___6 < dy_tols->inf) {
        {
#line 246
        tmp___7 = fabs(vlbj - vubj);
#line 246
        tmp___8 = fabs(vubj);
        }
#line 246
        if (tmp___7 < dy_tols->pfeas * (1.0 + tmp___8)) {
#line 247
          if (vlbj != vubj) {
#line 250
            if (dy_opts->print.setup >= 3) {
              {
#line 251
              tmp___5 = consys_nme(orig_sys, (char )'v', vndx, (bool )0, (char *)0);
#line 251
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tForcing equal bound %g for %s (g)",
                          (vlbj + vubj) / (double )2, tmp___5, vndx);
#line 254
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  original lb = %g, ub = %g, diff = %g, tol = %g",
                          vlbj, vubj, vubj - vlbj, dy_tols->pfeas);
              }
            }
#line 258
            *(vlb + vndx) = (vlbj + vubj) / (double )2;
#line 259
            *(vub + vndx) = *(vlb + vndx);
          }
#line 260
          if ((int )*(orig_status + vndx) > 0) {
#line 261
            *(orig_status + vndx) = (flags )(1 << 5);
          }
        }
      }
#line 262
      if (*(vlb + vndx) > *(vub + vndx)) {
#line 263
        dy_lp->lpret = (lpret_enum )4;
      }
#line 264
      if ((int )*(orig_status + vndx) > 0) {
#line 264
        if (*(orig_status + vndx) & (unsigned int )(1 << 5)) {
#line 264
          tmp___9 = 1;
        } else {
#line 264
          tmp___9 = 0;
        }
#line 264
        if (tmp___9) {
#line 266
          nbfxcnt ++;
        }
      }
#line 243
      vndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 267
    dyvsze = orig_sys->varcnt - nbfxcnt;
  }
#line 268
  if ((int )dy_opts->fullsys == 1) {
#line 269
    dycsze = orig_sys->concnt;
  } else {
#line 271
    dycsze = (orig_lp->basis)->len;
  }
#line 272
  dyvsze += dycsze;
#line 274
  if (dy_opts->print.setup >= 1) {
    {
#line 275
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  creating constraint system %s (%d x %d+%d)",
                nmebuf, dycsze, dyvsze - dycsze, dycsze);
    }
#line 278
    if (dy_opts->print.setup >= 3) {
#line 279
      if (orig_lp->ctlopts & (unsigned int )(1 << 6)) {
#line 279
        tmp___10 = 0;
      } else {
#line 279
        tmp___10 = 1;
      }
#line 279
      if (tmp___10) {
        {
#line 280
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      %d nonbasic fixed variables excluded.",
                    nbfxcnt);
        }
      }
    }
  }
  {
#line 284
  dy_sys = consys_create((char const   *)(nmebuf), parts, opts, dycsze, dyvsze, dy_tols->inf);
  }
#line 285
  if ((unsigned long )dy_sys == (unsigned long )((void *)0)) {
    {
#line 286
    errmsg(152, rtnnme, nmebuf);
    }
#line 287
    return ((dyret_enum )-10);
  }
  {
#line 292
  tmp___11 = consys_attach(dy_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_actvars));
  }
#line 292
  if ((int )tmp___11 == 0) {
    {
#line 294
    errmsg(100, rtnnme, dy_sys->nme, "active -> original variable map");
    }
#line 295
    return ((dyret_enum )-10);
  }
  {
#line 296
  tmp___12 = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_actcons));
  }
#line 296
  if ((int )tmp___12 == 0) {
    {
#line 298
    errmsg(100, rtnnme, dy_sys->nme, "active -> original constraint map");
    }
#line 299
    return ((dyret_enum )-10);
  }
  {
#line 300
  tmp___13 = consys_attach(orig_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_origvars));
  }
#line 300
  if ((int )tmp___13 == 0) {
    {
#line 302
    errmsg(100, rtnnme, orig_sys->nme, "original -> active variable map");
    }
#line 303
    return ((dyret_enum )-10);
  }
  {
#line 304
  tmp___14 = consys_attach(orig_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_origcons));
  }
#line 304
  if ((int )tmp___14 == 0) {
    {
#line 306
    errmsg(100, rtnnme, orig_sys->nme, "original -> active constraint map");
    }
#line 307
    return ((dyret_enum )-10);
  }
#line 326
  if ((int )noactvarspec == 0) {
#line 329
    if (dy_opts->print.setup >= 1) {
      {
#line 330
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  processing active variable list ...");
      }
    }
    {
#line 333
    pkcol = pkvec_new(0);
#line 334
    vndx = 1;
    }
    {
#line 334
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 334
      if (! (vndx <= orig_sys->varcnt)) {
#line 334
        goto while_break___1;
      }
#line 335
      if ((int )*(orig_status + vndx) > 0) {
#line 336
        vstat = *(orig_status + vndx);
      } else {
#line 338
        vstat = (flags )(1 << 2);
      }
#line 339
      if ((int )*(orig_actvars + vndx) == 1) {
#line 339
        if (vstat & (unsigned int )(1 << 5)) {
#line 339
          tmp___20 = 0;
        } else {
#line 339
          tmp___20 = 1;
        }
#line 339
        if (tmp___20) {
          {
#line 340
          tmp___16 = consys_getcol_pk(orig_sys, vndx, & pkcol);
          }
#line 340
          if ((int )tmp___16 == 0) {
            {
#line 341
            tmp___15 = consys_nme(orig_sys, (char )'v', vndx, (bool )1, (char *)((void *)0));
#line 341
            errmsg(122, rtnnme, orig_sys->nme, "variable", tmp___15, vndx);
#line 343
            retval = (dyret_enum )-10;
            }
#line 344
            goto while_break___1;
          }
          {
#line 345
          tmp___17 = consys_addcol_pk(dy_sys, (vartyp_enum )1, pkcol, *(orig_sys->obj + vndx),
                                      *(vlb + vndx), *(vub + vndx));
          }
#line 345
          if ((int )tmp___17 == 0) {
            {
#line 347
            errmsg(156, rtnnme, "variable", dy_sys->nme, pkcol->nme);
#line 348
            retval = (dyret_enum )-10;
            }
#line 349
            goto while_break___1;
          }
#line 350
          dyvndx = pkcol->ndx;
#line 351
          *(dy_origvars + vndx) = dyvndx;
#line 352
          *(dy_actvars + dyvndx) = vndx;
#line 354
          if (dy_opts->print.setup >= 3) {
            {
#line 355
            tmp___18 = consys_nme(orig_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 355
            tmp___19 = consys_prtvartyp(*(orig_sys->vtyp + vndx));
#line 355
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tactivating %s variable %s (%d) to index %d.",
                        tmp___19, tmp___18, vndx, dyvndx);
            }
          }
        } else {
#line 371
          *(dy_origvars + vndx) = - ((int )vstat);
        }
      } else {
#line 371
        *(dy_origvars + vndx) = - ((int )vstat);
      }
#line 334
      vndx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 372
    pkvec_free(pkcol);
    }
#line 373
    if ((int )retval != 0) {
#line 373
      return (retval);
    }
  } else {
#line 375
    vndx = 1;
    {
#line 375
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 375
      if (! (vndx <= orig_sys->varcnt)) {
#line 375
        goto while_break___2;
      }
#line 376
      if ((int )*(orig_status + vndx) > 0) {
#line 377
        vstat = *(orig_status + vndx);
      } else {
#line 379
        vstat = (flags )(1 << 9);
      }
#line 380
      *(dy_origvars + vndx) = - ((int )vstat);
#line 375
      vndx ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 388
  rngseen = (bool )0;
#line 389
  bpos = 1;
  {
#line 389
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 389
    if (! (bpos <= (orig_lp->basis)->len)) {
#line 389
      goto while_break___3;
    }
#line 390
    cndx = (orig_basis + bpos)->cndx;
#line 392
    if (dy_opts->print.setup >= 2) {
      {
#line 393
      tmp___21 = consys_nme(orig_sys, (char )'c', cndx, (bool )0, (char *)((void *)0));
#line 393
      tmp___22 = consys_prtcontyp(*(orig_sys->ctyp + cndx));
#line 393
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) in pos\'n %d",
                  tmp___22, tmp___21, cndx, bpos);
      }
    }
    {
#line 401
    tmp___25 = dy_loadcon(orig_sys, cndx, noactvarspec, (int *)((void *)0));
    }
#line 401
    if ((int )tmp___25 == 0) {
      {
#line 402
      tmp___23 = consys_nme(orig_sys, (char )'c', cndx, (bool )1, (char *)((void *)0));
#line 402
      tmp___24 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 402
      errmsg(430, rtnnme, dy_sys->nme, tmp___24, dy_lp->tot.iters, "activate", "constraint",
             tmp___23, cndx);
      }
#line 406
      return ((dyret_enum )-10);
    }
#line 407
    if ((unsigned int )*(orig_sys->ctyp + cndx) == 5U) {
#line 407
      rngseen = (bool )1;
    }
#line 389
    bpos ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 412
  if ((int )dy_opts->fullsys == 1) {
#line 413
    cndx = (orig_lp->basis)->len + 1;
    {
#line 413
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 413
      if (! (cndx <= orig_sys->concnt)) {
#line 413
        goto while_break___4;
      }
#line 416
      if (dy_opts->print.setup >= 2) {
        {
#line 417
        tmp___26 = consys_nme(orig_sys, (char )'c', cndx, (bool )0, (char *)((void *)0));
#line 417
        tmp___27 = consys_prtcontyp(*(orig_sys->ctyp + cndx));
#line 417
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) in pos\'n %d",
                    tmp___27, tmp___26, cndx, cndx);
        }
      }
      {
#line 425
      tmp___30 = dy_loadcon(orig_sys, cndx, noactvarspec, (int *)((void *)0));
      }
#line 425
      if ((int )tmp___30 == 0) {
        {
#line 426
        tmp___28 = consys_nme(orig_sys, (char )'c', cndx, (bool )1, (char *)((void *)0));
#line 426
        tmp___29 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 426
        errmsg(430, rtnnme, dy_sys->nme, tmp___29, dy_lp->tot.iters, "activate", "constraint",
               tmp___28, cndx);
        }
#line 430
        return ((dyret_enum )-10);
      }
#line 431
      if ((unsigned int )*(orig_sys->ctyp + cndx) == 5U) {
#line 431
        rngseen = (bool )1;
      }
#line 413
      cndx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 439
  if (dy_opts->print.setup >= 1) {
    {
#line 440
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    system %s has %d constraints, %d+%d variables",
                dy_sys->nme, dy_sys->concnt, dy_sys->archvcnt, dy_sys->logvcnt);
#line 443
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %d constraints, %d variables remain inactive in system %s.",
                orig_sys->concnt - dy_sys->concnt, orig_sys->archvcnt - dy_sys->archvcnt,
                orig_sys->nme);
    }
#line 447
    if (dy_opts->print.setup >= 4) {
#line 448
      nbfxcnt = 0;
#line 449
      vndx = 1;
      {
#line 449
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 449
        if (! (vndx <= orig_sys->varcnt)) {
#line 449
          goto while_break___5;
        }
#line 450
        if (*(dy_origvars + vndx) <= 0) {
#line 451
          vstat = (flags )(- *(dy_origvars + vndx));
          {
#line 453
          if ((vstat & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 6)) {
#line 453
            goto case_exp;
          }
#line 457
          if ((vstat & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 5)) {
#line 457
            goto case_exp___0;
          }
#line 457
          if ((vstat & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 7)) {
#line 457
            goto case_exp___0;
          }
#line 460
          if ((vstat & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 8)) {
#line 460
            goto case_exp___2;
          }
#line 463
          goto switch_default;
          case_exp: /* CIL Label */ 
#line 454
          xi = *(orig_sys->vub + vndx);
#line 455
          goto switch_break;
          case_exp___0: /* CIL Label */ 
          case_exp___1: /* CIL Label */ 
#line 458
          xi = *(orig_sys->vlb + vndx);
#line 459
          goto switch_break;
          case_exp___2: /* CIL Label */ 
#line 461
          xi = (double )0;
#line 462
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 464
          tmp___31 = dy_prtvstat(vstat);
#line 464
          tmp___32 = consys_nme(orig_sys, (char )'v', vndx, (bool )1, (char *)((void *)0));
#line 464
          tmp___33 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 464
          errmsg(433, rtnnme, dy_sys->nme, tmp___33, dy_lp->tot.iters, "inactive",
                 tmp___32, vndx, tmp___31);
          }
#line 468
          return ((dyret_enum )0);
          switch_break: /* CIL Label */ ;
          }
#line 469
          if (xi != (double )0) {
#line 470
            if (nbfxcnt == 0) {
              {
#line 471
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tinactive variables with nonzero values:");
              }
            }
            {
#line 473
            nbfxcnt ++;
#line 474
            tmp___34 = dy_prtvstat(vstat);
#line 474
            tmp___35 = consys_nme(orig_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 474
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s", tmp___35,
                        vndx, xi, tmp___34);
            }
          }
        }
#line 449
        vndx ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 477
      if (nbfxcnt == 0) {
        {
#line 478
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tall inactive variables are zero.");
        }
      }
    }
  }
  {
#line 485
  tmp___36 = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_basis));
  }
#line 485
  if ((int )tmp___36 == 0) {
    {
#line 487
    errmsg(100, rtnnme, dy_sys->nme, "basis vector");
    }
#line 488
    return ((dyret_enum )-10);
  }
  {
#line 489
  tmp___37 = consys_attach(dy_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_var2basis));
  }
#line 489
  if ((int )tmp___37 == 0) {
    {
#line 491
    errmsg(100, rtnnme, dy_sys->nme, "inverse basis vector");
    }
#line 492
    return ((dyret_enum )-10);
  }
#line 494
  if (dy_opts->print.crash >= 1) {
#line 495
    if (dy_opts->print.setup == 0) {
      {
#line 496
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n %s: regenerating the basis ...", rtnnme);
      }
    } else {
      {
#line 499
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  regenerating the basis.", rtnnme);
      }
    }
  }
#line 524
  bpos = 1;
  {
#line 524
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 524
    if (! (bpos <= (orig_lp->basis)->len)) {
#line 524
      goto while_break___6;
    }
#line 525
    cndx = (orig_basis + bpos)->cndx;
#line 526
    dycndx = *(dy_origcons + cndx);
#line 527
    vndx = (orig_basis + bpos)->vndx;
#line 528
    if (vndx < 0) {
#line 529
      dyvndx = *(dy_origcons + - vndx);
    } else {
#line 531
      dyvndx = *(dy_origvars + vndx);
    }
#line 574
    *(dy_basis + dycndx) = dyvndx;
#line 575
    *(dy_var2basis + dyvndx) = dycndx;
#line 524
    bpos ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 580
  if ((int )dy_opts->fullsys == 1) {
    {
#line 581
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 581
      if (! (bpos <= dy_sys->concnt)) {
#line 581
        goto while_break___7;
      }
#line 582
      *(dy_basis + bpos) = bpos;
#line 583
      *(dy_var2basis + bpos) = bpos;
#line 581
      bpos ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 591
  if (dy_opts->print.crash >= 4) {
    {
#line 592
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    Pos\'n Variable           Constraint");
#line 594
    bpos = 1;
    }
    {
#line 594
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 594
      if (! (bpos <= (orig_lp->basis)->len)) {
#line 594
        goto while_break___8;
      }
      {
#line 595
      vndx = *(dy_basis + bpos);
#line 596
      tmp___38 = consys_nme(dy_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 596
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t     %3d  (%3d) %-15s", bpos, vndx,
                  tmp___38);
#line 598
      tmp___39 = consys_nme(dy_sys, (char )'c', bpos, (bool )0, (char *)((void *)0));
#line 598
      dyio_outfmt(dy_logchn, dy_gtxecho, "%-15s", tmp___39);
#line 594
      bpos ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 607
  if (dy_sys->concnt > 0) {
#line 610
    if (dy_opts->print.crash >= 2) {
      {
#line 611
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    factoring ...");
      }
    }
    {
#line 613
    calcflgs = (flags )0;
#line 614
    retval = dy_factor(& calcflgs);
    }
    {
#line 617
    if ((int )retval == 2) {
#line 617
      goto case_2;
    }
#line 617
    if ((int )retval == 1) {
#line 617
      goto case_2;
    }
#line 619
    goto switch_default___0;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 618
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 620
    errmsg(309, rtnnme, dy_sys->nme);
    }
#line 621
    return (retval);
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 626
  tmp___40 = consys_attach(dy_sys, 1U << 1, (int )sizeof(flags ), (void **)(& dy_status));
  }
#line 626
  if ((int )tmp___40 == 0) {
    {
#line 628
    errmsg(100, rtnnme, dy_sys->nme, "status vector");
    }
#line 629
    return ((dyret_enum )-10);
  }
  {
#line 630
  tmp___41 = consys_attach(dy_sys, 1U << 2, (int )sizeof(double ), (void **)(& dy_xbasic));
  }
#line 630
  if ((int )tmp___41 == 0) {
    {
#line 632
    errmsg(100, rtnnme, dy_sys->nme, "basic variable vector");
    }
#line 633
    return ((dyret_enum )-10);
  }
  {
#line 634
  tmp___42 = consys_attach(dy_sys, 1U << 1, (int )sizeof(double ), (void **)(& dy_x));
  }
#line 634
  if ((int )tmp___42 == 0) {
    {
#line 636
    errmsg(100, rtnnme, dy_sys->nme, "primal variable vector");
    }
#line 637
    return ((dyret_enum )-10);
  }
  {
#line 638
  tmp___43 = consys_attach(dy_sys, 1U << 2, (int )sizeof(double ), (void **)(& dy_y));
  }
#line 638
  if ((int )tmp___43 == 0) {
    {
#line 640
    errmsg(100, rtnnme, dy_sys->nme, "dual variable vector");
    }
#line 641
    return ((dyret_enum )-10);
  }
  {
#line 642
  tmp___44 = consys_attach(dy_sys, 1U << 1, (int )sizeof(double ), (void **)(& dy_cbar));
  }
#line 642
  if ((int )tmp___44 == 0) {
    {
#line 644
    errmsg(100, rtnnme, dy_sys->nme, "reduced cost vector");
    }
#line 645
    return ((dyret_enum )-10);
  }
#line 651
  if (dy_opts->print.crash >= 2) {
    {
#line 652
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    calculating dual values ...");
    }
  }
  {
#line 654
  dy_calcduals();
#line 655
  tmp___46 = dy_calccbar();
  }
#line 655
  if ((int )tmp___46 == 0) {
    {
#line 656
    tmp___45 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 656
    errmsg(384, rtnnme, dy_sys->nme, tmp___45, dy_lp->tot.iters);
    }
#line 658
    return ((dyret_enum )-10);
  }
#line 668
  vlb = dy_sys->vlb;
#line 669
  vub = dy_sys->vub;
#line 671
  if (dy_opts->print.crash >= 2) {
    {
#line 672
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    establishing initial status and reference frame ...");
#line 674
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      logicals ...");
    }
  }
#line 676
  dyvndx = 1;
  {
#line 676
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 676
    if (! (dyvndx <= dy_sys->concnt)) {
#line 676
      goto while_break___9;
    }
#line 677
    if (*(dy_var2basis + dyvndx) != 0) {
#line 678
      if (*(vub + dyvndx) == *(vlb + dyvndx)) {
#line 679
        *(dy_status + dyvndx) = (flags )1;
      } else {
#line 681
        *(dy_status + dyvndx) = (flags )(1 << 2);
      }
    } else {
      {
#line 685
      if ((unsigned int )*(dy_sys->ctyp + dyvndx) == 2U) {
#line 685
        goto case_2___0;
      }
#line 685
      if ((unsigned int )*(dy_sys->ctyp + dyvndx) == 4U) {
#line 685
        goto case_2___0;
      }
#line 689
      if ((unsigned int )*(dy_sys->ctyp + dyvndx) == 3U) {
#line 689
        goto case_3;
      }
#line 693
      if ((unsigned int )*(dy_sys->ctyp + dyvndx) == 5U) {
#line 693
        goto case_5;
      }
#line 705
      goto switch_default___1;
      case_2___0: /* CIL Label */ 
      case_4: /* CIL Label */ 
#line 686
      *(dy_status + dyvndx) = (flags )(1 << 7);
#line 687
      *(dy_x + dyvndx) = (double )0;
#line 688
      goto switch_break___1;
      case_3: /* CIL Label */ 
#line 690
      *(dy_status + dyvndx) = (flags )(1 << 5);
#line 691
      *(dy_x + dyvndx) = (double )0;
#line 692
      goto switch_break___1;
      case_5: /* CIL Label */ 
#line 694
      if (*(vub + dyvndx) == *(vlb + dyvndx)) {
#line 695
        *(dy_status + dyvndx) = (flags )(1 << 5);
#line 696
        *(dy_x + dyvndx) = *(vub + dyvndx);
      } else
#line 698
      if (*(dy_cbar + dyvndx) < (double )0) {
#line 699
        *(dy_status + dyvndx) = (flags )(1 << 6);
#line 700
        *(dy_x + dyvndx) = *(vub + dyvndx);
      } else {
#line 702
        *(dy_status + dyvndx) = (flags )(1 << 7);
#line 703
        *(dy_x + dyvndx) = *(vlb + dyvndx);
      }
#line 704
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 706
      errmsg(1, rtnnme, 706);
      }
#line 707
      return ((dyret_enum )-10);
      switch_break___1: /* CIL Label */ ;
      }
    }
#line 709
    if (dy_opts->print.crash >= 4) {
      {
#line 710
      tmp___47 = dy_prtvstat(*(dy_status + dyvndx));
#line 710
      tmp___48 = consys_nme(dy_sys, (char )'v', dyvndx, (bool )0, (char *)((void *)0));
#line 710
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s", tmp___48, dyvndx, tmp___47);
      }
#line 713
      if (*(dy_status + dyvndx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 713
        tmp___49 = 1;
      } else {
#line 713
        tmp___49 = 0;
      }
#line 713
      if (tmp___49) {
        {
#line 714
        dyio_outfmt(dy_logchn, dy_gtxecho, " with value %g.", *(dy_x + dyvndx));
        }
      } else {
        {
#line 716
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
#line 676
    dyvndx ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 731
  if (dy_opts->print.crash >= 2) {
    {
#line 732
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      architecturals ...");
    }
  }
#line 734
  dy_lp->inactzcorr = (double )0;
#line 735
  vndx = 1;
  {
#line 735
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 735
    if (! (vndx <= orig_sys->varcnt)) {
#line 735
      goto while_break___10;
    }
#line 736
    dyvndx = *(dy_origvars + vndx);
#line 737
    if (dyvndx < 0) {
#line 738
      obj = *(orig_sys->obj + vndx);
      {
#line 741
      if ((flags )(- dyvndx) == (flags )(1 << 7)) {
#line 741
        goto case_exp___3;
      }
#line 741
      if ((flags )(- dyvndx) == (flags )(1 << 5)) {
#line 741
        goto case_exp___3;
      }
#line 744
      if ((flags )(- dyvndx) == (flags )(1 << 6)) {
#line 744
        goto case_exp___5;
      }
#line 739
      goto switch_break___2;
      case_exp___3: /* CIL Label */ 
      case_exp___4: /* CIL Label */ 
#line 742
      dy_lp->inactzcorr += obj * *(orig_sys->vlb + vndx);
#line 743
      goto switch_break___2;
      case_exp___5: /* CIL Label */ 
#line 745
      dy_lp->inactzcorr += obj * *(orig_sys->vub + vndx);
#line 746
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
    } else {
#line 756
      if ((int )*(orig_status + vndx) < 0) {
#line 757
        if (*(vlb + dyvndx) == *(vub + dyvndx)) {
#line 758
          *(dy_status + dyvndx) = (flags )1;
        } else
#line 760
        if (*(vlb + dyvndx) <= - dy_tols->inf) {
#line 760
          if (*(vub + dyvndx) >= dy_tols->inf) {
#line 761
            *(dy_status + dyvndx) = (flags )(1 << 4);
          } else {
#line 763
            *(dy_status + dyvndx) = (flags )(1 << 2);
          }
        } else {
#line 763
          *(dy_status + dyvndx) = (flags )(1 << 2);
        }
      } else {
#line 765
        *(dy_status + dyvndx) = *(orig_status + vndx);
        {
#line 767
        if (*(dy_status + dyvndx) == (flags )(1 << 7)) {
#line 767
          goto case_exp___6;
        }
#line 770
        if (*(dy_status + dyvndx) == (flags )(1 << 6)) {
#line 770
          goto case_exp___7;
        }
#line 773
        if (*(dy_status + dyvndx) == (flags )(1 << 8)) {
#line 773
          goto case_exp___8;
        }
#line 766
        goto switch_break___3;
        case_exp___6: /* CIL Label */ 
#line 768
        *(dy_x + dyvndx) = *(vlb + dyvndx);
#line 769
        goto switch_break___3;
        case_exp___7: /* CIL Label */ 
#line 771
        *(dy_x + dyvndx) = *(vub + dyvndx);
#line 772
        goto switch_break___3;
        case_exp___8: /* CIL Label */ 
#line 774
        *(dy_x + dyvndx) = (double )0;
#line 775
        goto switch_break___3;
        switch_break___3: /* CIL Label */ ;
        }
      }
#line 783
      if (dy_opts->print.crash >= 4) {
        {
#line 784
        tmp___50 = dy_prtvstat(*(dy_status + dyvndx));
#line 784
        tmp___51 = consys_nme(dy_sys, (char )'v', dyvndx, (bool )0, (char *)((void *)0));
#line 784
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s", tmp___51, dyvndx, tmp___50);
        }
#line 787
        if (*(dy_status + dyvndx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 787
          tmp___52 = 1;
        } else {
#line 787
          tmp___52 = 0;
        }
#line 787
        if (tmp___52) {
          {
#line 788
          dyio_outfmt(dy_logchn, dy_gtxecho, " with value %g.", *(dy_x + dyvndx));
          }
        } else {
          {
#line 790
          dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
          }
        }
      }
    }
#line 735
    vndx ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 798
  if ((int )retval == 2) {
    {
#line 798
    correct_for_patch();
    }
  }
#line 807
  if (dy_opts->print.crash >= 2) {
    {
#line 808
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    calculating primal values ...");
    }
  }
  {
#line 810
  tmp___53 = dy_calcprimals();
  }
#line 810
  if ((int )tmp___53 == 0) {
    {
#line 811
    errmsg(316, rtnnme, dy_sys->nme);
    }
#line 812
    return ((dyret_enum )-10);
  }
  {
#line 813
  dy_lp->z = dy_calcobj();
#line 814
  dy_setfinalstatus();
#line 819
  calcflgs = (flags )(((1 | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 820
  retval = dy_accchk(& calcflgs);
  }
#line 821
  if ((int )retval != 1) {
    {
#line 822
    tmp___54 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 822
    errmsg(304, rtnnme, dy_sys->nme, tmp___54, dy_lp->tot.iters);
    }
#line 824
    return (retval);
  }
#line 825
  if (calcflgs & 1U) {
#line 825
    tmp___56 = 0;
  } else {
#line 825
    tmp___56 = 1;
  }
#line 825
  if (tmp___56) {
#line 826
    dy_lp->simplex.next = (dyphase_enum )3;
  } else {
#line 828
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 828
      tmp___55 = 0;
    } else {
#line 828
      tmp___55 = 1;
    }
#line 828
    if (tmp___55) {
#line 829
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 831
      dy_lp->simplex.next = (dyphase_enum )2;
    }
  }
#line 834
  if (dy_opts->print.crash >= 2) {
    {
#line 835
    tmp___57 = dy_prtlpphase(dy_lp->simplex.next, (bool )0);
#line 835
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    phase %s, initial objective %g", tmp___57,
                dy_lp->z);
    }
#line 837
    if (dy_lp->infeascnt != 0) {
      {
#line 838
      dyio_outfmt(dy_logchn, dy_gtxecho, ", %d infeasible vars, infeas = %g", dy_lp->infeascnt,
                  dy_lp->infeas);
      }
    }
    {
#line 840
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
    }
  }
#line 841
  if (dy_opts->print.crash >= 3) {
    {
#line 842
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\nPos\'n\tConstraint\tDual\t\tPrimal\n");
#line 844
    bpos = 1;
    }
    {
#line 844
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 844
      if (! (bpos <= dy_sys->concnt)) {
#line 844
        goto while_break___11;
      }
#line 845
      cndx = *(dy_actcons + bpos);
#line 846
      dyvndx = *(dy_basis + bpos);
#line 847
      if (dyvndx <= dy_sys->concnt) {
#line 848
        vndx = orig_sys->varcnt + dyvndx;
      } else {
#line 850
        vndx = *(dy_actvars + dyvndx);
      }
      {
#line 851
      tmp___58 = consys_nme(dy_sys, (char )'v', dyvndx, (bool )0, (char *)((void *)0));
#line 851
      tmp___59 = consys_nme(dy_sys, (char )'c', bpos, (bool )0, (char *)((void *)0));
#line 851
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%5d\t(%4d) %-8s\t%12.4g\t(%4d) %-8s %12.4g",
                  bpos, cndx, tmp___59, *(dy_y + bpos), vndx, tmp___58, *(dy_x + dyvndx));
#line 844
      bpos ++;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 858
  return ((dyret_enum )1);
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib4.c"
void *dy_glp_umalloc(int size ) 
{ 
  ENV *env ;
  ENV *tmp ;
  MEM *desc ;
  int size_of_desc ;
  void *tmp___0 ;

  {
  {
#line 55
  tmp = dy_glp_get_env_ptr();
#line 55
  env = tmp;
#line 57
  size_of_desc = (int )(((sizeof(MEM ) + (sizeof(double ) - 1UL)) / sizeof(double )) * sizeof(double ));
  }
#line 58
  if (size < 1) {
    {
#line 59
    dy_glp_fault("umalloc: invalid size");
    }
  }
#line 60
  if (size > 2147483647 - size_of_desc) {
    {
#line 61
    dy_glp_fault("umalloc: size too big");
    }
  }
#line 62
  size += size_of_desc;
#line 63
  if (size > env->mem_limit - env->mem_total) {
    {
#line 64
    dy_glp_fault("umalloc: no memory available");
    }
  }
  {
#line 65
  tmp___0 = malloc((size_t )size);
#line 65
  desc = (MEM *)tmp___0;
  }
#line 66
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
    {
#line 67
    dy_glp_fault("umalloc: malloc failed");
    }
  }
  {
#line 69
  memset((void *)desc, '?', (size_t )size);
#line 71
  desc->size = size;
#line 72
  desc->flag = 537925984;
#line 73
  desc->prev = (MEM *)((void *)0);
#line 74
  desc->next = env->mem_ptr;
  }
#line 75
  if ((unsigned long )desc->next != (unsigned long )((void *)0)) {
#line 75
    (desc->next)->prev = desc;
  }
#line 76
  env->mem_ptr = desc;
#line 77
  env->mem_total += size;
#line 78
  if (env->mem_tpeak < env->mem_total) {
#line 79
    env->mem_tpeak = env->mem_total;
  }
#line 80
  (env->mem_count) ++;
#line 81
  if (env->mem_cpeak < env->mem_count) {
#line 82
    env->mem_cpeak = env->mem_count;
  }
#line 83
  return ((void *)((char *)desc + size_of_desc));
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib4.c"
void *dy_glp_ucalloc(int nmemb , int size ) 
{ 
  void *tmp ;

  {
#line 108
  if (nmemb < 1) {
    {
#line 109
    dy_glp_fault("ucalloc: invalid nmemb");
    }
  }
#line 110
  if (size < 1) {
    {
#line 111
    dy_glp_fault("ucalloc: invalid size");
    }
  }
#line 112
  if (nmemb > 2147483647 / size) {
    {
#line 113
    dy_glp_fault("ucalloc: array too big");
    }
  }
  {
#line 114
  tmp = dy_glp_umalloc(nmemb * size);
  }
#line 114
  return (tmp);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib4.c"
void dy_glp_ufree(void *ptr ) 
{ 
  ENV *env ;
  ENV *tmp ;
  MEM *desc ;
  int size_of_desc ;

  {
  {
#line 131
  tmp = dy_glp_get_env_ptr();
#line 131
  env = tmp;
#line 133
  size_of_desc = (int )(((sizeof(MEM ) + (sizeof(double ) - 1UL)) / sizeof(double )) * sizeof(double ));
  }
#line 134
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 135
    dy_glp_fault("ufree: null pointer");
    }
  }
#line 136
  desc = (MEM *)((void *)((char *)ptr - size_of_desc));
#line 137
  if (desc->flag != 537925984) {
    {
#line 138
    dy_glp_fault("ufree: invalid pointer");
    }
  }
#line 139
  if (env->mem_total < desc->size) {
    {
#line 140
    dy_glp_fault("ufree: memory allocation error");
    }
  } else
#line 139
  if (env->mem_count == 0) {
    {
#line 140
    dy_glp_fault("ufree: memory allocation error");
    }
  }
#line 141
  if ((unsigned long )desc->prev == (unsigned long )((void *)0)) {
#line 142
    env->mem_ptr = desc->next;
  } else {
#line 144
    (desc->prev)->next = desc->next;
  }
#line 145
  if (! ((unsigned long )desc->next == (unsigned long )((void *)0))) {
#line 148
    (desc->next)->prev = desc->prev;
  }
  {
#line 149
  env->mem_total -= desc->size;
#line 150
  (env->mem_count) --;
#line 151
  memset((void *)desc, '?', (size_t )size_of_desc);
#line 152
  free((void *)desc);
  }
#line 153
  return;
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_dupsys(consys_struct *src , consys_struct **p_dst , flags dstvecs ) ;
#line 509
void consys_free(consys_struct *consys ) ;
#line 570
bool consys_evalsys(consys_struct *consys , double *p_scm , int *p_gecnt ) ;
#line 571
bool consys_geomscale(consys_struct *consys , double **p_rowscale , double **p_colscale ) ;
#line 571
bool consys_equiscale(consys_struct *consys , double **p_rowscale , double **p_colscale ) ;
#line 571
bool consys_applyscale(consys_struct *consys , bool convctyp , double *rowscale ,
                       double *colscale ) ;
#line 1721 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_initlclsystem(lpprob_struct *orig_lp , bool hotstart ) ;
#line 1722
void dy_freelclsystem(lpprob_struct *orig_lp , bool freesys ) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
static consys_struct *local_sys  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
static consys_struct *client_sys  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
static double *lcl_rowscale  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
static double *lcl_colscale  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
bool dy_isscaled(void) 
{ 
  int tmp ;

  {
#line 100
  if ((unsigned long )lcl_rowscale == (unsigned long )((void *)0)) {
#line 100
    if ((unsigned long )lcl_colscale == (unsigned long )((void *)0)) {
#line 100
      tmp = 0;
    } else {
#line 100
      tmp = 1;
    }
  } else {
#line 100
    tmp = 1;
  }
#line 100
  return ((bool )tmp);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
void dy_scaling_vectors(double const   **rscale , double const   **cscale ) 
{ 


  {
#line 114
  *rscale = (double const   *)lcl_rowscale;
#line 115
  *cscale = (double const   *)lcl_colscale;
#line 117
  return;
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
consys_struct *dy_scaled_origsys(void) 
{ 


  {
#line 129
  return (local_sys);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
bool dy_initlclsystem(lpprob_struct *orig_lp , bool hotstart ) 
{ 
  int i ;
  int scalefactor ;
  int orig_gecnt ;
  bool localcopy ;
  bool scale ;
  bool pmone ;
  flags scaled_vecs ;
  double orig_scm ;
  double scaled_scm ;
  consys_struct *orig_sys ;
  char const   *rtnnme ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  char *tmp___3 ;
  bool tmp___4 ;
  char *tmp___5 ;
  bool tmp___6 ;
  char *tmp___7 ;
  bool tmp___8 ;
  char *tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;

  {
#line 173
  rtnnme = "dy_initlclsystem";
#line 189
  if ((int )hotstart == 1) {
#line 190
    if ((unsigned long )local_sys != (unsigned long )((void *)0)) {
#line 191
      client_sys = orig_lp->consys;
#line 192
      orig_lp->consys = local_sys;
    }
#line 193
    return ((bool )1);
  }
  {
#line 198
  orig_sys = orig_lp->consys;
#line 199
  tmp = consys_evalsys(orig_sys, & orig_scm, & orig_gecnt);
  }
#line 199
  if ((int )tmp == 0) {
    {
#line 200
    errmsg(138, rtnnme, orig_sys->nme);
    }
#line 201
    return ((bool )0);
  }
#line 202
  if (orig_gecnt > 0) {
#line 203
    pmone = (bool )1;
  } else {
#line 205
    pmone = (bool )0;
  }
#line 208
  if (dy_opts->print.scaling >= 2) {
#line 208
    if ((int )pmone == 1) {
      {
#line 209
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: found %d \'>=\' inequalities; at least +/-1 scaling.",
                  orig_sys->nme, orig_gecnt);
      }
    }
  }
#line 218
  local_sys = (consys_struct *)((void *)0);
#line 219
  client_sys = (consys_struct *)((void *)0);
#line 220
  lcl_rowscale = (double *)((void *)0);
#line 221
  lcl_colscale = (double *)((void *)0);
#line 223
  localcopy = dy_opts->copyorigsys;
  {
#line 226
  if (dy_opts->scaling == 0) {
#line 226
    goto case_0;
  }
#line 229
  if (dy_opts->scaling == 1) {
#line 229
    goto case_1;
  }
#line 247
  if (dy_opts->scaling == 2) {
#line 247
    goto case_2;
  }
#line 267
  goto switch_default;
  case_0: /* CIL Label */ 
#line 227
  scale = (bool )0;
#line 228
  goto switch_break;
  case_1: /* CIL Label */ 
#line 230
  localcopy = (bool )1;
#line 231
  scale = (bool )1;
#line 241
  if (dy_opts->print.scaling >= 2) {
    {
#line 242
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: scaling with client vectors",
                orig_sys->nme);
    }
  }
#line 246
  goto switch_break;
  case_2: /* CIL Label */ 
#line 248
  if (orig_sys->minaij >= .5) {
#line 248
    if (orig_sys->maxaij <= (double )2) {
#line 249
      scale = (bool )0;
    } else {
#line 251
      localcopy = (bool )1;
#line 252
      scale = (bool )1;
    }
  } else {
#line 251
    localcopy = (bool )1;
#line 252
    scale = (bool )1;
  }
#line 254
  if (dy_opts->print.scaling >= 2) {
#line 255
    if ((int )scale == 1) {
      {
#line 256
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: system will be scaled;", orig_sys->nme);
      }
    } else {
      {
#line 260
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: scaling for numeric accuracy not required;",
                  orig_sys->nme);
      }
    }
    {
#line 263
    dyio_outfmt(dy_logchn, dy_gtxecho, " %g <= |a<ij>| <= %g, metric = %g.", orig_sys->minaij,
                orig_sys->maxaij, orig_scm);
    }
  }
#line 266
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 268
  errmsg(7, rtnnme, 268, "scaling option code", dy_opts->scaling);
  }
#line 269
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 275
  if ((int )pmone == 1) {
#line 276
    localcopy = (bool )1;
  }
#line 281
  if ((int )localcopy == 1) {
    {
#line 282
    scaled_vecs = ((((((((1U << 3) | (1U << 11)) | (1U << 6)) | (1U << 9)) | (1U << 14)) | (1U << 10)) | (1U << 5)) | (1U << 4)) | (1U << 15);
#line 285
    tmp___0 = consys_dupsys(orig_sys, & local_sys, scaled_vecs);
    }
#line 285
    if ((int )tmp___0 == 0) {
      {
#line 286
      errmsg(137, rtnnme, orig_sys->nme);
      }
#line 287
      return ((bool )0);
    }
#line 288
    client_sys = orig_lp->consys;
#line 289
    orig_lp->consys = local_sys;
  }
#line 296
  if ((int )scale == 1) {
#line 298
    if (dy_opts->scaling == 1) {
#line 299
      if ((int )localcopy == 1) {
        {
#line 300
        memcpy((void */* __restrict  */)local_sys->rowscale, (void const   */* __restrict  */)client_sys->rowscale,
               (size_t )(local_sys->concnt + 1) * sizeof(double ));
#line 302
        memcpy((void */* __restrict  */)local_sys->colscale, (void const   */* __restrict  */)client_sys->colscale,
               (size_t )(local_sys->varcnt + 1) * sizeof(double ));
#line 304
        lcl_rowscale = local_sys->rowscale;
#line 305
        lcl_colscale = local_sys->colscale;
        }
      } else {
#line 307
        lcl_rowscale = client_sys->rowscale;
#line 308
        lcl_colscale = client_sys->colscale;
      }
    } else {
      {
#line 315
      tmp___1 = consys_geomscale(local_sys, & local_sys->rowscale, & local_sys->colscale);
      }
#line 315
      if ((int )tmp___1 == 0) {
        {
#line 317
        errmsg(135, rtnnme, local_sys->nme);
        }
#line 318
        return ((bool )0);
      }
#line 320
      if (dy_opts->print.scaling >= 2) {
        {
#line 321
        scaled_scm = sqrt(local_sys->maxaij / local_sys->minaij);
#line 322
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: after geometric scaling",
                    local_sys->nme);
#line 325
        dyio_outfmt(dy_logchn, dy_gtxecho, " %g <= |a<ij>| <= %g, geom = %g.", local_sys->minaij,
                    local_sys->maxaij, scaled_scm);
        }
      }
      {
#line 328
      tmp___2 = consys_equiscale(local_sys, & local_sys->rowscale, & local_sys->colscale);
      }
#line 328
      if ((int )tmp___2 == 0) {
        {
#line 330
        errmsg(135, rtnnme, local_sys->nme);
        }
#line 331
        return ((bool )0);
      }
#line 333
      if (dy_opts->print.scaling >= 2) {
        {
#line 334
        scaled_scm = sqrt(local_sys->maxaij / local_sys->minaij);
#line 335
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: after equilibration scaling",
                    local_sys->nme);
#line 338
        dyio_outfmt(dy_logchn, dy_gtxecho, " %g <= |a<ij>| <= %g, geom = %g.", local_sys->minaij,
                    local_sys->maxaij, scaled_scm);
        }
      }
#line 341
      lcl_rowscale = local_sys->rowscale;
#line 342
      lcl_colscale = local_sys->colscale;
    }
#line 346
    if ((int )localcopy == 1) {
      {
#line 347
      tmp___4 = consys_attach(local_sys, 1U << 14, (int )sizeof(double ), (void **)(& lcl_rowscale));
      }
#line 347
      if ((int )tmp___4 == 0) {
        {
#line 349
        tmp___3 = consys_assocnme((consys_struct *)((void *)0), 1U << 14);
#line 349
        errmsg(100, rtnnme, local_sys->nme, tmp___3);
        }
#line 351
        return ((bool )0);
      }
      {
#line 352
      tmp___6 = consys_attach(local_sys, 1U << 15, (int )sizeof(double ), (void **)(& lcl_colscale));
      }
#line 352
      if ((int )tmp___6 == 0) {
        {
#line 354
        tmp___5 = consys_assocnme((consys_struct *)((void *)0), 1U << 15);
#line 354
        errmsg(100, rtnnme, local_sys->nme, tmp___5);
        }
#line 356
        return ((bool )0);
      }
    }
  }
#line 363
  if ((int )pmone == 1) {
#line 364
    if ((int )scale == 0) {
#line 365
      if ((unsigned long )lcl_rowscale == (unsigned long )((void *)0)) {
        {
#line 366
        tmp___8 = consys_attach(local_sys, 1U << 14, (int )sizeof(double ), (void **)(& lcl_rowscale));
        }
#line 366
        if ((int )tmp___8 == 0) {
          {
#line 368
          tmp___7 = consys_assocnme((consys_struct *)((void *)0), 1U << 14);
#line 368
          errmsg(100, rtnnme, local_sys->nme, tmp___7);
          }
#line 370
          return ((bool )0);
        }
#line 371
        local_sys->rowscale = lcl_rowscale;
      }
#line 372
      if ((unsigned long )lcl_colscale == (unsigned long )((void *)0)) {
        {
#line 373
        tmp___10 = consys_attach(local_sys, 1U << 15, (int )sizeof(double ), (void **)(& lcl_colscale));
        }
#line 373
        if ((int )tmp___10 == 0) {
          {
#line 375
          tmp___9 = consys_assocnme((consys_struct *)((void *)0), 1U << 15);
#line 375
          errmsg(100, rtnnme, local_sys->nme, tmp___9);
          }
#line 377
          return ((bool )0);
        }
#line 378
        local_sys->colscale = lcl_colscale;
      }
    }
#line 379
    i = 1;
    {
#line 379
    while (1) {
      while_continue: /* CIL Label */ ;
#line 379
      if (! (i <= orig_sys->concnt)) {
#line 379
        goto while_break;
      }
#line 380
      if ((unsigned int )*(orig_sys->ctyp + i) == 2U) {
#line 381
        *(lcl_rowscale + i) *= - 1.0;
      }
#line 379
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 386
  if ((int )scale == 1) {
#line 386
    goto _L;
  } else
#line 386
  if ((int )pmone == 1) {
    _L: /* CIL Label */ 
    {
#line 387
    tmp___11 = consys_applyscale(local_sys, pmone, lcl_rowscale, lcl_colscale);
    }
#line 387
    if ((int )tmp___11 == 0) {
      {
#line 388
      errmsg(135, rtnnme, local_sys->nme);
      }
#line 389
      return ((bool )0);
    }
    {
#line 390
    scaled_scm = sqrt(local_sys->maxaij / local_sys->minaij);
    }
#line 392
    if (dy_opts->print.scaling >= 1) {
      {
#line 393
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      [%s]: after scaling", local_sys->nme);
#line 395
      dyio_outfmt(dy_logchn, dy_gtxecho, " %g <= |a<ij>| <= %g, geom = %g.", local_sys->minaij,
                  local_sys->maxaij, scaled_scm);
      }
    }
  } else {
#line 400
    scaled_scm = orig_scm;
  }
  {
#line 406
  tmp___12 = log10(orig_scm / scaled_scm);
#line 406
  scalefactor = (int )(tmp___12 + .5) - 1;
  }
#line 407
  if (scalefactor > 1) {
    {
#line 408
    tmp___13 = pow(10.0, (double )scalefactor);
#line 408
    dy_tols->pfeas_scale *= tmp___13;
#line 409
    tmp___14 = pow(10.0, (double )scalefactor);
#line 409
    dy_tols->dfeas_scale *= tmp___14;
    }
#line 411
    if (dy_opts->print.scaling >= 2) {
      {
#line 412
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s]: adjusting pfeas scale by 1.0e+%d to %g.",
                  local_sys->nme, scalefactor, dy_tols->pfeas_scale);
#line 415
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s]: adjusting dfeas scale by 1.0e+%d to %g.",
                  local_sys->nme, scalefactor, dy_tols->dfeas_scale);
      }
    }
  }
#line 420
  if (scalefactor > 2) {
    {
#line 421
    scalefactor -= 2;
#line 422
    tmp___15 = pow(10.0, (double )scalefactor);
#line 422
    dy_tols->zero /= tmp___15;
#line 423
    tmp___16 = pow(10.0, (double )scalefactor);
#line 423
    dy_tols->cost /= tmp___16;
    }
#line 425
    if (dy_opts->print.scaling >= 2) {
      {
#line 426
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s]: adjusting primal zero by 1.0e-%d to %g.",
                  local_sys->nme, scalefactor, dy_tols->zero);
#line 429
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s]: adjusting dual zero by 1.0e-%d to %g.",
                  local_sys->nme, scalefactor, dy_tols->cost);
      }
    }
  }
#line 435
  return ((bool )1);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
void dy_refreshlclsystem(flags what ) 
{ 
  int i ;
  int j ;
  int m ;
  int n ;
  double infinity ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 462
  if ((unsigned long )local_sys == (unsigned long )((void *)0)) {
#line 462
    return;
  }
#line 475
  m = client_sys->concnt;
#line 476
  n = client_sys->varcnt;
#line 477
  infinity = client_sys->inf;
#line 479
  if (what & (unsigned int )(1 << 5)) {
#line 479
    tmp = 1;
  } else {
#line 479
    tmp = 0;
  }
#line 479
  if (tmp) {
#line 480
    j = 1;
    {
#line 480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 480
      if (! (j <= n)) {
#line 480
        goto while_break;
      }
#line 481
      *(local_sys->obj + j) = *(client_sys->obj + j) * *(lcl_colscale + j);
#line 480
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 483
  if (what & (unsigned int )(1 << 4)) {
#line 483
    tmp___0 = 1;
  } else {
#line 483
    tmp___0 = 0;
  }
#line 483
  if (tmp___0) {
#line 484
    i = 1;
    {
#line 484
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 484
      if (! (i <= m)) {
#line 484
        goto while_break___0;
      }
#line 485
      *(local_sys->rhs + i) = *(client_sys->rhs + i) * *(lcl_rowscale + i);
#line 486
      *(local_sys->rhslow + i) = *(client_sys->rhslow + i) * *(lcl_rowscale + i);
#line 484
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 488
  if (what & (unsigned int )(1 << 3)) {
#line 488
    tmp___2 = 1;
  } else {
#line 488
    tmp___2 = 0;
  }
#line 488
  if (tmp___2) {
#line 489
    if (client_sys->opts & (1U << 3)) {
#line 489
      tmp___1 = 1;
    } else {
#line 489
      tmp___1 = 0;
    }
#line 489
    if (tmp___1) {
#line 490
      j = 1;
      {
#line 490
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 490
        if (! (j <= n)) {
#line 490
          goto while_break___1;
        }
#line 491
        if (*(client_sys->vlb + j) > - infinity) {
#line 492
          *(local_sys->vlb + j) = *(client_sys->vlb + j) / *(lcl_colscale + j);
        } else {
#line 494
          *(local_sys->vlb + j) = - infinity;
        }
#line 490
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 496
      j = 1;
      {
#line 496
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 496
        if (! (j <= n)) {
#line 496
          goto while_break___2;
        }
#line 497
        *(local_sys->vlb + j) = *(client_sys->vlb + j) / *(lcl_colscale + j);
#line 496
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 499
  if (what & (unsigned int )(1 << 2)) {
#line 499
    tmp___4 = 1;
  } else {
#line 499
    tmp___4 = 0;
  }
#line 499
  if (tmp___4) {
#line 500
    if (client_sys->opts & (1U << 3)) {
#line 500
      tmp___3 = 1;
    } else {
#line 500
      tmp___3 = 0;
    }
#line 500
    if (tmp___3) {
#line 501
      j = 1;
      {
#line 501
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 501
        if (! (j <= n)) {
#line 501
          goto while_break___3;
        }
#line 502
        if (*(client_sys->vub + j) < infinity) {
#line 503
          *(local_sys->vub + j) = *(client_sys->vub + j) / *(lcl_colscale + j);
        } else {
#line 505
          *(local_sys->vub + j) = infinity;
        }
#line 501
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 507
      j = 1;
      {
#line 507
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 507
        if (! (j <= n)) {
#line 507
          goto while_break___4;
        }
#line 508
        *(local_sys->vub + j) = *(client_sys->vub + j) / *(lcl_colscale + j);
#line 507
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 510
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_scaling.c"
void dy_freelclsystem(lpprob_struct *orig_lp , bool freesys ) 
{ 


  {
#line 536
  if ((unsigned long )local_sys == (unsigned long )((void *)0)) {
#line 536
    return;
  }
#line 541
  orig_lp->consys = client_sys;
#line 542
  client_sys = (consys_struct *)((void *)0);
#line 543
  if ((int )freesys == 0) {
#line 543
    return;
  }
#line 549
  lcl_rowscale = (double *)((void *)0);
#line 550
  lcl_colscale = (double *)((void *)0);
#line 551
  if ((unsigned long )local_sys != (unsigned long )((void *)0)) {
    {
#line 552
    consys_free(local_sys);
#line 553
    local_sys = (consys_struct *)((void *)0);
    }
  }
#line 555
  return;
}
}
#line 1761 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
int dy_activateBndCons(consys_struct *orig_sys ) ;
#line 1762
int dy_dualaddvars(consys_struct *orig_sys ) ;
#line 1873
void dy_setbasicstatus(void) ;
#line 1951
void dy_logpivot(dyret_enum result , int xjndx , int indir , double cbarj , int xindx ,
                 int outdir , double abarij , double delta ) ;
#line 321 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static int scanPrimConBndAct(consys_struct *orig_sys , int act_j , int **p_ocndxs ) 
{ 
  int i ;
  int j ;
  int k ;
  int bpos ;
  int m ;
  int n ;
  int act_m ;
  int actcnt ;
  int cand_limit ;
  int dir ;
  int retval ;
  int *ocndxs ;
  double *abarj ;
  double *orig_x ;
  double *orig_rhs ;
  double *orig_rhslow ;
  double *orig_vub ;
  double *orig_vlb ;
  double *orig_etaj ;
  double idotj ;
  double lhsi ;
  double rhsi ;
  double rhslowi ;
  contyp_enum *orig_ctyp ;
  contyp_enum ctypi ;
  flags statj ;
  bool activate ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  double tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  double tmp___15 ;
  double tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  double tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___31 ;
  int tmp___32 ;
  double tmp___33 ;
  int tmp___34 ;

  {
#line 361
  rtnnme = "scanPrimConBndAct";
#line 376
  if (act_j < 0) {
#line 377
    dir = 1;
#line 378
    act_j = - act_j;
  } else {
#line 380
    dir = -1;
  }
  {
#line 391
  abarj = (double *)((void *)0);
#line 392
  tmp___0 = consys_getcol_ex(dy_sys, act_j, & abarj);
  }
#line 392
  if ((int )tmp___0 == 0) {
    {
#line 393
    tmp = consys_nme(dy_sys, (char )'v', act_j, (bool )1, (char *)((void *)0));
#line 393
    errmsg(122, rtnnme, dy_sys->nme, "column", tmp, act_j);
    }
#line 395
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 395
      free((void *)abarj);
      }
    }
#line 396
    return (-1);
  }
  {
#line 397
  dy_ftran(abarj, (bool )0);
  }
#line 399
  if (dy_opts->print.conmgmt >= 4) {
#line 400
    if (dir < 0) {
#line 400
      tmp___1 = "increasing";
    } else {
#line 400
      tmp___1 = "decreasing";
    }
    {
#line 400
    tmp___2 = consys_nme(dy_sys, (char )'v', act_j, (bool )0, (char *)((void *)0));
#line 400
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    eta<j> for %s (%d) %s:", tmp___2, act_j,
                tmp___1);
#line 403
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s", "pos\'n", "var (ndx)", "eta<ij>");
#line 405
    bpos = 1;
    }
    {
#line 405
    while (1) {
      while_continue: /* CIL Label */ ;
#line 405
      if (! (bpos <= dy_sys->concnt)) {
#line 405
        goto while_break;
      }
#line 406
      if (*(abarj + bpos) != (double )0) {
        {
#line 407
        tmp___3 = consys_nme(dy_sys, (char )'v', *(dy_basis + bpos), (bool )0, (char *)((void *)0));
#line 407
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%14s (%3d)%16.8g", bpos, tmp___3,
                    *(dy_basis + bpos), - *(abarj + bpos));
        }
      }
#line 405
      bpos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 410
    tmp___4 = consys_nme(dy_sys, (char )'v', act_j, (bool )0, (char *)((void *)0));
#line 410
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%14s (%3d)%16.8g", "n/a", tmp___4, act_j,
                1.0);
    }
  }
  {
#line 419
  retval = 0;
#line 420
  m = orig_sys->concnt;
#line 421
  n = orig_sys->varcnt;
#line 422
  act_m = dy_sys->concnt;
#line 423
  tmp___5 = calloc((size_t )(n + 1), sizeof(double ));
#line 423
  orig_etaj = (double *)tmp___5;
#line 424
  bpos = 1;
  }
  {
#line 424
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 424
    if (! (bpos <= act_m)) {
#line 424
      goto while_break___0;
    }
#line 425
    k = *(dy_basis + bpos);
#line 426
    if (k > act_m) {
#line 427
      j = *(dy_actvars + k);
#line 434
      *(orig_etaj + j) = (double )dir * *(abarj + bpos);
    }
#line 424
    bpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 435
  if (act_j > act_m) {
#line 436
    j = *(dy_actvars + act_j);
#line 437
    *(orig_etaj + j) = - 1.0 * (double )dir;
  }
#line 438
  if ((unsigned long )abarj != (unsigned long )((void *)0)) {
    {
#line 438
    free((void *)abarj);
    }
  }
  {
#line 450
  orig_vub = orig_sys->vub;
#line 451
  orig_vlb = orig_sys->vlb;
#line 452
  tmp___6 = calloc((size_t )(n + 1), sizeof(double ));
#line 452
  orig_x = (double *)tmp___6;
#line 453
  j = 1;
  }
  {
#line 453
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 453
    if (! (j <= n)) {
#line 453
      goto while_break___1;
    }
#line 454
    k = *(dy_origvars + j);
#line 455
    if (k > 0) {
#line 463
      *(orig_x + j) = *(dy_x + k);
    } else {
#line 465
      statj = (flags )(- k);
#line 475
      if (statj & (unsigned int )(1 << 6)) {
#line 475
        tmp___8 = 1;
      } else {
#line 475
        tmp___8 = 0;
      }
#line 475
      if (tmp___8) {
#line 476
        *(orig_x + j) = *(orig_vub + j);
      } else {
#line 478
        if (statj & (unsigned int )((1 << 7) | (1 << 5))) {
#line 478
          tmp___7 = 1;
        } else {
#line 478
          tmp___7 = 0;
        }
#line 478
        if (tmp___7) {
#line 479
          *(orig_x + j) = *(orig_vlb + j);
        }
      }
    }
#line 453
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 489
  cand_limit = m - act_m;
#line 490
  if (dy_opts->con.actlim > 0) {
#line 491
    if (dy_opts->con.actlim > cand_limit) {
#line 491
      cand_limit = cand_limit;
    } else {
#line 491
      cand_limit = dy_opts->con.actlim;
    }
  }
#line 492
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
    {
#line 493
    tmp___9 = malloc((unsigned long )cand_limit * sizeof(int ));
#line 493
    ocndxs = (int *)tmp___9;
    }
  } else {
#line 495
    ocndxs = *p_ocndxs;
  }
#line 502
  orig_ctyp = orig_sys->ctyp;
#line 503
  orig_rhs = orig_sys->rhs;
#line 504
  orig_rhslow = orig_sys->rhslow;
#line 505
  actcnt = 0;
#line 506
  i = 1;
  {
#line 506
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 506
    if (i <= m) {
#line 506
      if (! (actcnt <= cand_limit)) {
#line 506
        goto while_break___2;
      }
    } else {
#line 506
      goto while_break___2;
    }
#line 507
    if (! (*(dy_origcons + i) == 0)) {
#line 507
      goto __Cont;
    }
    {
#line 508
    ctypi = *(orig_ctyp + i);
#line 509
    idotj = consys_dotrow(orig_sys, i, orig_etaj);
#line 510
    tmp___10 = fabs(idotj);
    }
#line 510
    if (tmp___10 < dy_tols->zero) {
#line 510
      idotj = (double )0;
    }
#line 511
    if (idotj == (double )0) {
#line 511
      goto _L;
    } else
#line 511
    if ((unsigned int )ctypi == 4U) {
#line 511
      if (idotj < (double )0) {
        _L: /* CIL Label */ 
#line 514
        if (dy_opts->print.conmgmt >= 3) {
          {
#line 515
          tmp___11 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 515
          tmp___12 = consys_prtcontyp(ctypi);
#line 515
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    skipping %s %s (%d), dot(a<i>,eta<j>) = %g, ",
                      tmp___12, tmp___11, i, idotj);
          }
        }
#line 520
        goto __Cont;
      }
    }
#line 522
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 523
      tmp___13 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 523
      tmp___14 = consys_prtcontyp(ctypi);
#line 523
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    considering %s %s (%d), dot(a<i>,eta<j>) = %g, ",
                  tmp___14, tmp___13, i, idotj);
      }
    }
    {
#line 531
    lhsi = consys_dotrow(orig_sys, i, orig_x);
#line 532
    tmp___15 = fabs(lhsi);
    }
#line 532
    if (tmp___15 < dy_tols->zero) {
#line 532
      lhsi = (double )0;
    }
#line 533
    rhsi = *(orig_rhs + i);
#line 534
    if ((unsigned int )ctypi == 5U) {
#line 535
      rhslowi = *(orig_rhslow + i);
    } else
#line 537
    if ((unsigned int )ctypi == 3U) {
#line 538
      rhslowi = rhsi;
    } else {
#line 540
      rhslowi = - dy_tols->inf;
    }
    {
#line 541
    tmp___19 = fabs(rhsi);
    }
#line 541
    if (tmp___19 < dy_tols->inf) {
      {
#line 541
      tmp___17 = fabs(rhsi);
#line 541
      tmp___18 = lhsi - rhsi > dy_tols->pfeas * (1.0 + tmp___17);
      }
    } else {
#line 541
      tmp___18 = lhsi > rhsi;
    }
#line 541
    if (tmp___18) {
#line 542
      activate = (bool )0;
    } else {
      {
#line 541
      tmp___23 = fabs(rhslowi);
      }
#line 541
      if (tmp___23 < dy_tols->inf) {
        {
#line 541
        tmp___21 = fabs(rhslowi);
#line 541
        tmp___22 = rhslowi - lhsi > dy_tols->pfeas * (1.0 + tmp___21);
        }
      } else {
#line 541
        tmp___22 = lhsi < rhslowi;
      }
#line 541
      if (tmp___22) {
#line 542
        activate = (bool )0;
      } else {
#line 544
        activate = (bool )1;
      }
    }
#line 547
    if ((int )activate == 1) {
#line 548
      if (dy_opts->print.conmgmt >= 3) {
        {
#line 549
        tmp___24 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 549
        tmp___25 = consys_prtcontyp(*(orig_ctyp + i));
#line 549
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    queued %s %s (%d), %g <= %g <= %g.",
                    tmp___25, tmp___24, i, rhslowi, lhsi, rhsi);
        }
      }
    } else
#line 555
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 556
      tmp___26 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 556
      tmp___27 = consys_prtcontyp(*(orig_ctyp + i));
#line 556
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    skipping %s constraint %s (%d),",
                  tmp___27, tmp___26, i);
#line 560
      tmp___33 = fabs(rhsi);
      }
#line 560
      if (tmp___33 < dy_tols->inf) {
        {
#line 560
        tmp___31 = fabs(rhsi);
#line 560
        tmp___32 = lhsi - rhsi > dy_tols->pfeas * (1.0 + tmp___31);
        }
      } else {
#line 560
        tmp___32 = lhsi > rhsi;
      }
#line 560
      if (tmp___32) {
        {
#line 561
        tmp___28 = fabs(rhsi);
#line 561
        dyio_outfmt(dy_logchn, dy_gtxecho, " lhs - rhs = %g - %g = %g, tol %g.", lhsi,
                    rhsi, lhsi - rhsi, dy_tols->zero * ((double )1 + tmp___28));
        }
      } else {
        {
#line 565
        tmp___29 = fabs(rhslowi);
#line 565
        dyio_outfmt(dy_logchn, dy_gtxecho, " rhslow - lhs = %g - %g = %g, tol %g.",
                    rhslowi, lhsi, rhslowi - lhsi, dy_tols->zero * ((double )1 + tmp___29));
        }
      }
    }
#line 571
    if ((int )activate == 1) {
#line 571
      tmp___34 = actcnt;
#line 571
      actcnt ++;
#line 571
      *(ocndxs + tmp___34) = i;
    }
    __Cont: /* CIL Label */ 
#line 506
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 572
  if ((unsigned long )orig_etaj != (unsigned long )((void *)0)) {
    {
#line 572
    free((void *)orig_etaj);
    }
  }
#line 573
  if ((unsigned long )orig_x != (unsigned long )((void *)0)) {
    {
#line 573
    free((void *)orig_x);
    }
  }
#line 577
  if ((unsigned long )*p_ocndxs == (unsigned long )((void *)0)) {
#line 578
    if (actcnt == 0) {
      {
#line 579
      free((void *)ocndxs);
      }
    } else {
#line 581
      *p_ocndxs = ocndxs;
    }
  }
#line 584
  if (dy_opts->print.conmgmt >= 1) {
    {
#line 585
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  queued %d constraints for activation.",
                actcnt);
    }
  }
#line 589
  return (actcnt);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
int dy_activateBndCons(consys_struct *orig_sys ) 
{ 
  int *candidates ;
  int cand_cnt ;
  int act_j ;
  int retval ;
  bool actresult ;
  flags calcflgs ;
  dyret_enum factorresult ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 621
  rtnnme = "dy_activateBndCons";
#line 623
  retval = -1;
#line 629
  candidates = (int *)((void *)0);
#line 630
  act_j = dy_lp->ubnd.ndx;
#line 631
  cand_cnt = scanPrimConBndAct(orig_sys, act_j, & candidates);
  }
#line 632
  if (cand_cnt < 0) {
    {
#line 633
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 633
    errmsg(434, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "constraint", "bounding activation");
#line 636
    actresult = (bool )0;
    }
  } else
#line 638
  if (cand_cnt > 0) {
    {
#line 639
    actresult = dy_actBLogPrimConList(orig_sys, cand_cnt, candidates, (int **)((void *)0));
    }
  } else {
#line 641
    actresult = (bool )1;
  }
#line 642
  if ((unsigned long )candidates != (unsigned long )((void *)0)) {
    {
#line 642
    free((void *)candidates);
    }
  }
#line 643
  if ((int )actresult == 0) {
#line 643
    return (retval);
  }
#line 649
  if (cand_cnt > 0) {
#line 650
    dy_lp->simplex.init_dse = (bool )1;
#line 652
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 653
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      factoring, calculating variables, ");
#line 655
      dyio_outfmt(dy_logchn, dy_gtxecho, "and checking feasibility ...");
      }
    }
    {
#line 657
    calcflgs = (flags )(((((1 << 8) | 1) | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 658
    factorresult = dy_accchk(& calcflgs);
    }
    {
#line 661
    if ((int )factorresult == 2) {
#line 661
      goto case_2;
    }
#line 661
    if ((int )factorresult == 1) {
#line 661
      goto case_2;
    }
#line 685
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 662
    retval = cand_cnt;
#line 664
    if (dy_opts->print.conmgmt >= 3) {
#line 665
      if ((int )factorresult == 1) {
        {
#line 666
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    done.");
        }
      } else {
        {
#line 668
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    patched.");
        }
      }
    }
#line 677
    if (calcflgs & 1U) {
#line 677
      tmp___1 = 0;
    } else {
#line 677
      tmp___1 = 1;
    }
#line 677
    if (tmp___1) {
#line 678
      dy_lp->simplex.next = (dyphase_enum )3;
    } else {
#line 680
      if (calcflgs & (unsigned int )(1 << 3)) {
#line 680
        tmp___0 = 0;
      } else {
#line 680
        tmp___0 = 1;
      }
#line 680
      if (tmp___0) {
#line 681
        dy_lp->simplex.next = (dyphase_enum )4;
      } else {
#line 683
        dy_lp->simplex.next = (dyphase_enum )2;
      }
    }
#line 684
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 686
    retval = -1;
#line 688
    if (dy_opts->print.conmgmt >= 3) {
      {
#line 689
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    failed.");
      }
    }
#line 691
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 693
    retval = cand_cnt;
  }
#line 696
  if (dy_opts->print.conmgmt >= 1) {
#line 697
    if (dy_opts->print.conmgmt >= 2) {
      {
#line 698
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
      }
    }
    {
#line 699
    dyio_outfmt(dy_logchn, dy_gtxecho, " %d activations.", cand_cnt);
#line 700
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    constraint system %s now %d x %d (%d + %d).",
                dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
    }
  }
#line 706
  return (retval);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static int type1var(consys_struct *orig_sys , int xindx , int diri , int oxkndx ,
                    flags xkstatus , double abarik , double cbark ) 
{ 
  int xkndx ;
  char const   *rtnnme ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;

  {
#line 740
  rtnnme = "type1var";
#line 747
  if (xkstatus & (unsigned int )(1 << 7)) {
#line 747
    tmp___1 = 1;
  } else {
#line 747
    tmp___1 = 0;
  }
#line 747
  if (tmp___1) {
#line 747
    if (cbark < (double )0) {
#line 747
      goto _L;
    } else {
#line 747
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 747
    if (xkstatus & (unsigned int )(1 << 6)) {
#line 747
      tmp___2 = 1;
    } else {
#line 747
      tmp___2 = 0;
    }
#line 747
    if (tmp___2) {
#line 747
      if (cbark > (double )0) {
        _L: /* CIL Label */ 
#line 751
        if (dy_opts->print.varmgmt >= 4) {
          {
#line 752
          tmp = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 752
          tmp___0 = dy_prtvstat(xkstatus);
#line 752
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tt1eval: %s %s (%d) not dual feasible; cbar<k> = %g.",
                      tmp___0, tmp, oxkndx, cbark);
          }
        }
#line 757
        return (0);
      }
    }
  }
#line 763
  if (dy_opts->print.varmgmt >= 2) {
    {
#line 764
    tmp___3 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 764
    tmp___4 = dy_prtvstat(xkstatus);
#line 764
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    type 1 activation %s %s (%d), ", tmp___4,
                tmp___3, oxkndx);
#line 767
    dyio_outfmt(dy_logchn, dy_gtxecho, "cbar<k> = %g, abar<ik> = %g.", cbark, abarik);
    }
  }
  {
#line 771
  tmp___7 = dy_actNBPrimArch(orig_sys, oxkndx);
  }
#line 771
  if ((int )tmp___7 == 0) {
    {
#line 772
    tmp___5 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 772
    tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 772
    errmsg(430, rtnnme, orig_sys->nme, tmp___6, dy_lp->tot.iters, "activate", "variable",
           tmp___5, oxkndx);
    }
#line 776
    return (-1);
  }
#line 777
  xkndx = *(dy_origvars + oxkndx);
#line 778
  *(dy_cbar + xkndx) = cbark;
#line 780
  return (1);
}
}
#line 784 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static void type2eval(consys_struct *orig_sys , int xindx , int diri , int oxkndx ,
                      flags xkstatus , double abarik , double cbark , int *oxjndx ,
                      double *deltaj , double *cbarj , int *dirj ) 
{ 
  double deltak ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
#line 829
  if (xkstatus & (unsigned int )(1 << 7)) {
#line 829
    tmp___1 = 1;
  } else {
#line 829
    tmp___1 = 0;
  }
#line 829
  if (tmp___1) {
#line 829
    if (cbark > (double )0) {
#line 829
      goto _L;
    } else {
#line 829
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 829
    if (xkstatus & (unsigned int )(1 << 6)) {
#line 829
      tmp___2 = 1;
    } else {
#line 829
      tmp___2 = 0;
    }
#line 829
    if (tmp___2) {
#line 829
      if (cbark < (double )0) {
#line 829
        goto _L;
      } else {
#line 829
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 829
      if (xkstatus & (unsigned int )(1 << 8)) {
#line 829
        tmp___3 = 1;
      } else {
#line 829
        tmp___3 = 0;
      }
#line 829
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 833
        if (dy_opts->print.varmgmt >= 4) {
          {
#line 834
          tmp = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 834
          tmp___0 = dy_prtvstat(xkstatus);
#line 834
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tt2eval: %s %s (%d) dual feasible; cbar<k> = %g.",
                      tmp___0, tmp, oxkndx, cbark);
          }
        }
#line 839
        return;
      }
    }
  }
  {
#line 846
  deltak = fabs(cbark / abarik);
  }
#line 847
  if (deltak < *deltaj) {
#line 848
    *oxjndx = oxkndx;
#line 849
    *deltaj = deltak;
#line 850
    *cbarj = cbark;
#line 851
    if (xkstatus & (unsigned int )(1 << 7)) {
#line 851
      tmp___5 = 1;
    } else {
#line 851
      tmp___5 = 0;
    }
#line 851
    if (tmp___5) {
#line 852
      *dirj = -1;
    } else {
#line 854
      if (xkstatus & (unsigned int )(1 << 6)) {
#line 854
        tmp___4 = 1;
      } else {
#line 854
        tmp___4 = 0;
      }
#line 854
      if (tmp___4) {
#line 855
        *dirj = 1;
      } else
#line 857
      if (diri > 0) {
#line 858
        if (abarik > (double )0) {
#line 859
          *dirj = 1;
        } else {
#line 861
          *dirj = -1;
        }
      } else
#line 863
      if (abarik > (double )0) {
#line 864
        *dirj = -1;
      } else {
#line 866
        *dirj = 1;
      }
    }
#line 868
    if (dy_opts->print.varmgmt >= 3) {
      {
#line 869
      tmp___6 = consys_nme(orig_sys, (char )'v', *oxjndx, (bool )1, (char *)((void *)0));
#line 869
      tmp___7 = dy_prtvstat(xkstatus);
#line 869
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t2eval: choosing %s %s (%d), delta %g,",
                  tmp___7, tmp___6, *oxjndx, *deltaj);
#line 873
      dyio_outfmt(dy_logchn, dy_gtxecho, "cbar<j> = %g, abar<ij> = %g.", *cbarj, abarik);
      }
    }
  } else
#line 879
  if (dy_opts->print.varmgmt >= 3) {
    {
#line 880
    tmp___8 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 880
    tmp___9 = dy_prtvstat(xkstatus);
#line 880
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t2eval: skipping %s %s (%d), delta %g,",
                tmp___9, tmp___8, oxkndx, deltak);
#line 884
    dyio_outfmt(dy_logchn, dy_gtxecho, "cbar<k> = %g, abar<ik> = %g.", cbark, abarik);
    }
  }
#line 888
  return;
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static void type3eval(consys_struct *orig_sys , int xindx , int diri , int oxkndx ,
                      flags xkstatus , double abarik , double cbark , int *oxjndx ,
                      double *distj , double *cbarj , int *dirj , double *abarij ) 
{ 
  int dirk ;
  double lbk ;
  double ubk ;
  double deltak ;
  double distk ;
  double bndi ;
  double xival ;
  bool newxj ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  double tmp___13 ;
  int tmp___14 ;
  double tmp___15 ;
  double tmp___17 ;
  int tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  char const   *tmp___23 ;
  char *tmp___24 ;

  {
#line 939
  lbk = *(orig_sys->vlb + oxkndx);
#line 940
  ubk = *(orig_sys->vub + oxkndx);
#line 941
  if (lbk <= - dy_tols->inf) {
#line 941
    goto _L;
  } else
#line 941
  if (ubk >= dy_tols->inf) {
    _L: /* CIL Label */ 
#line 944
    if (dy_opts->print.varmgmt >= 3) {
      {
#line 945
      tmp = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 945
      tmp___0 = dy_prtvstat(xkstatus);
#line 945
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: skipping %s %s (%d)", tmp___0,
                  tmp, oxkndx);
      }
#line 948
      if (lbk <= - dy_tols->inf) {
        {
#line 949
        dyio_outfmt(dy_logchn, dy_gtxecho, ", lb = %g", lbk);
        }
      }
#line 950
      if (ubk >= dy_tols->inf) {
        {
#line 951
        dyio_outfmt(dy_logchn, dy_gtxecho, ", ub = %g", ubk);
        }
      }
      {
#line 952
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
#line 954
    return;
  }
#line 959
  if (xkstatus & (unsigned int )(1 << 7)) {
#line 959
    tmp___5 = 1;
  } else {
#line 959
    tmp___5 = 0;
  }
#line 959
  if (tmp___5) {
#line 960
    if (cbark > (double )0) {
#line 963
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 964
        tmp___1 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 964
        tmp___2 = dy_prtvstat(xkstatus);
#line 964
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: skipping %s %s (%d), cbar = %g, can\'t flip.",
                    tmp___2, tmp___1, oxkndx, cbark);
        }
      }
#line 969
      return;
    }
#line 970
    dirk = 1;
#line 971
    deltak = - abarik * (ubk - lbk);
  } else {
#line 973
    if (cbark < (double )0) {
#line 976
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 977
        tmp___3 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 977
        tmp___4 = dy_prtvstat(xkstatus);
#line 977
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: skipping %s %s (%d), cbar = %g, can\'t flip.",
                    tmp___4, tmp___3, oxkndx, cbark);
        }
      }
#line 982
      return;
    }
#line 983
    dirk = -1;
#line 984
    deltak = - abarik * (lbk - ubk);
  }
  {
#line 985
  tmp___6 = fabs(deltak);
  }
#line 985
  if (tmp___6 < dy_tols->zero) {
#line 985
    deltak = (double )0;
  }
#line 989
  if (deltak == (double )0) {
#line 992
    if (dy_opts->print.varmgmt >= 3) {
      {
#line 993
      tmp___7 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 993
      tmp___8 = dy_prtvstat(xkstatus);
#line 993
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: skipping %s %s (%d), delta = 0.",
                  tmp___8, tmp___7, oxkndx);
      }
    }
#line 998
    return;
  }
#line 999
  if (diri > 0) {
#line 999
    if (deltak < (double )0) {
#line 999
      goto _L___0;
    } else {
#line 999
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 999
  if (diri < 0) {
#line 999
    if (deltak > (double )0) {
      _L___0: /* CIL Label */ 
#line 1002
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 1003
        tmp___9 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1003
        tmp___10 = dy_prtvstat(xkstatus);
#line 1003
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: skipping %s %s (%d), direction; delta = %g.",
                    tmp___10, tmp___9, oxkndx, deltak);
        }
      }
#line 1008
      return;
    }
  }
  {
#line 1017
  xival = *(dy_x + xindx) + deltak;
#line 1018
  tmp___11 = fabs(xival);
  }
#line 1018
  if (tmp___11 < dy_tols->zero) {
#line 1018
    xival = (double )0;
  }
#line 1020
  newxj = (bool )0;
#line 1021
  if (diri < 0) {
    {
#line 1022
    bndi = *(dy_sys->vub + xindx);
#line 1023
    distk = bndi - xival;
#line 1024
    tmp___15 = fabs(*(dy_sys->vlb + xindx));
    }
#line 1024
    if (tmp___15 < dy_tols->inf) {
      {
#line 1024
      tmp___13 = fabs(*(dy_sys->vlb + xindx));
#line 1024
      tmp___14 = *(dy_sys->vlb + xindx) - xival > dy_tols->pfeas * (1.0 + tmp___13);
      }
    } else {
#line 1024
      tmp___14 = xival < *(dy_sys->vlb + xindx);
    }
#line 1024
    if (tmp___14) {
#line 1024
      distk = - distk;
    }
  } else {
    {
#line 1026
    bndi = *(dy_sys->vlb + xindx);
#line 1027
    distk = xival - bndi;
#line 1028
    tmp___19 = fabs(*(dy_sys->vub + xindx));
    }
#line 1028
    if (tmp___19 < dy_tols->inf) {
      {
#line 1028
      tmp___17 = fabs(*(dy_sys->vub + xindx));
#line 1028
      tmp___18 = xival - *(dy_sys->vub + xindx) > dy_tols->pfeas * (1.0 + tmp___17);
      }
    } else {
#line 1028
      tmp___18 = xival > *(dy_sys->vub + xindx);
    }
#line 1028
    if (tmp___18) {
#line 1028
      distk = - distk;
    }
  }
  {
#line 1029
  tmp___20 = fabs(distk);
  }
#line 1029
  if (tmp___20 < dy_tols->zero) {
#line 1029
    distk = (double )0;
  }
#line 1030
  if (distk > (double )0) {
#line 1030
    if (*distj < (double )0) {
#line 1031
      newxj = (bool )1;
    } else {
#line 1030
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 1033
    tmp___21 = fabs(distk);
#line 1033
    tmp___22 = fabs(*distj);
    }
#line 1033
    if (tmp___21 < tmp___22) {
#line 1034
      newxj = (bool )1;
    }
  }
#line 1036
  if ((int )newxj == 1) {
#line 1037
    *oxjndx = oxkndx;
#line 1038
    *distj = distk;
#line 1039
    *cbarj = cbark;
#line 1040
    *dirj = dirk;
#line 1041
    *abarij = abarik;
#line 1043
    if (dy_opts->print.varmgmt >= 3) {
      {
#line 1044
      tmp___23 = consys_nme(orig_sys, (char )'v', *oxjndx, (bool )1, (char *)((void *)0));
#line 1044
      tmp___24 = dy_prtvstat(xkstatus);
#line 1044
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      t3eval: choosing %s %s (%d), ",
                  tmp___24, tmp___23, *oxjndx);
#line 1047
      dyio_outfmt(dy_logchn, dy_gtxecho, "cbar = %g, delta = %g, dist = %g.", *cbarj,
                  deltak, *distj);
      }
    }
  }
#line 1052
  return;
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static int type2activate(consys_struct *orig_sys , int xindx , int diri , int oxjndx ,
                         int dirj , double cbarj ) 
{ 
  int xjndx ;
  int xkndx ;
  double abarij ;
  double deltaj ;
  bool pivoted ;
  dyret_enum pivresult ;
  dyret_enum duennaresult ;
  int retval ;
  char const   *rtnnme ;
  flags xjstatus ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  bool tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;

  {
#line 1091
  rtnnme = "type2activate";
#line 1096
  if (dy_opts->print.varmgmt >= 1) {
    {
#line 1097
    xjstatus = (flags )(- *(dy_origvars + oxjndx));
#line 1098
    tmp = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 1098
    tmp___0 = dy_prtvstat(xjstatus);
#line 1098
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating and pivoting %s %s (%d), ",
                tmp___0, tmp, oxjndx);
    }
#line 1102
    if (dirj < 0) {
#line 1102
      tmp___1 = "falling";
    } else {
#line 1102
      tmp___1 = "rising";
    }
    {
#line 1102
    dyio_outfmt(dy_logchn, dy_gtxecho, " cbar = %g, %s.", cbarj, tmp___1);
    }
  }
  {
#line 1108
  tmp___4 = dy_actNBPrimArch(orig_sys, oxjndx);
  }
#line 1108
  if ((int )tmp___4 == 0) {
    {
#line 1109
    tmp___2 = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 1109
    tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1109
    errmsg(430, rtnnme, orig_sys->nme, tmp___3, dy_lp->tot.iters, "activate", "variable",
           tmp___2, oxjndx);
    }
#line 1113
    return (-1);
  }
  {
#line 1114
  xjndx = *(dy_origvars + oxjndx);
#line 1115
  *(dy_cbar + xjndx) = cbarj;
#line 1119
  pivresult = dy_dualpivot(xindx, diri, & xjndx, & dirj, & cbarj, & abarij, & deltaj,
                           & xkndx);
  }
  {
#line 1126
  if ((int )pivresult == 4) {
#line 1126
    goto case_4;
  }
#line 1126
  if ((int )pivresult == 6) {
#line 1126
    goto case_4;
  }
#line 1126
  if ((int )pivresult == 7) {
#line 1126
    goto case_4;
  }
#line 1126
  if ((int )pivresult == -2) {
#line 1126
    goto case_4;
  }
#line 1126
  if ((int )pivresult == 1) {
#line 1126
    goto case_4;
  }
#line 1129
  goto switch_default;
  case_4: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_neg_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1127
  pivoted = (bool )1;
#line 1128
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1130
  pivoted = (bool )0;
#line 1131
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1133
  if (dy_opts->print.varmgmt >= 3) {
#line 1133
    goto _L;
  } else
#line 1133
  if (dy_opts->print.varmgmt >= 2) {
#line 1133
    if ((int )pivresult != 1) {
      _L: /* CIL Label */ 
      {
#line 1135
      tmp___5 = dy_prtdyret(pivresult);
      }
#line 1135
      if ((int )pivoted == 1) {
#line 1135
        tmp___6 = "succeeded";
      } else {
#line 1135
        tmp___6 = "failed";
      }
      {
#line 1135
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      pivot attempt %s, pivot return code = %s.",
                  tmp___6, tmp___5);
      }
    }
  }
#line 1139
  if (dy_opts->print.dual >= 4) {
    {
#line 1140
    dy_logpivot(pivresult, xjndx, dirj, cbarj, xindx, diri, abarij, deltaj);
    }
  }
  {
#line 1160
  dy_lp->phase = (dyphase_enum )4;
#line 1161
  duennaresult = dy_duenna(pivresult, xjndx, xindx, -1, -1);
  }
#line 1162
  if ((int )pivresult == -6) {
    {
#line 1163
    tmp___7 = dy_clrpivrej((int *)((void *)0));
    }
#line 1163
    if ((int )tmp___7 != 1) {
#line 1163
      return (-1);
    }
  }
#line 1164
  dy_lp->phase = (dyphase_enum )7;
  {
#line 1168
  if ((int )duennaresult == 7) {
#line 1168
    goto case_7___0;
  }
#line 1168
  if ((int )duennaresult == 3) {
#line 1168
    goto case_7___0;
  }
#line 1168
  if ((int )duennaresult == 1) {
#line 1168
    goto case_7___0;
  }
#line 1175
  if ((int )duennaresult == -3) {
#line 1175
    goto case_neg_3;
  }
#line 1175
  if ((int )duennaresult == 6) {
#line 1175
    goto case_neg_3;
  }
#line 1178
  goto switch_default___0;
  case_7___0: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 1169
  if ((int )pivoted == 1) {
#line 1170
    retval = 1;
  } else {
#line 1172
    retval = 0;
  }
#line 1173
  goto switch_break___0;
  case_neg_3: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
#line 1176
  retval = 0;
#line 1177
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1179
  retval = -1;
  switch_break___0: /* CIL Label */ ;
  }
#line 1182
  if (dy_opts->print.varmgmt >= 3) {
    {
#line 1184
    tmp___8 = dy_prtdyret(duennaresult);
#line 1184
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      La Duenna return code %s.", tmp___8);
    }
  } else
#line 1182
  if (dy_opts->print.varmgmt >= 2) {
#line 1182
    if ((int )duennaresult != 1) {
      {
#line 1184
      tmp___8 = dy_prtdyret(duennaresult);
#line 1184
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      La Duenna return code %s.", tmp___8);
      }
    }
  }
#line 1186
  if (dy_opts->print.varmgmt >= 1) {
#line 1187
    if (dy_opts->print.varmgmt >= 2) {
      {
#line 1188
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  ");
      }
    }
#line 1189
    if (retval == 1) {
      {
#line 1190
      dyio_outfmt(dy_logchn, dy_gtxecho, " 1 activation and pivot.");
#line 1191
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    constraint system %s now %d x %d (%d + %d).",
                  dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
      }
    } else
#line 1196
    if (retval == 0) {
      {
#line 1197
      dyio_outfmt(dy_logchn, dy_gtxecho, " activate & pivot failed; reverting to primal.");
      }
    }
  }
#line 1201
  return (retval);
}
}
#line 1205 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
static int type3activate(consys_struct *orig_sys , double *betai , int xindx , int diri ,
                         int oxjndx , int dirj , double cbarj , double abarij , int *p_actcnt ) 
{ 
  int candxi ;
  int oxkndx ;
  int xjndx ;
  int xqndx ;
  int pkndx ;
  double cbark ;
  double abarik ;
  double deltak ;
  double distj ;
  flags xjstatus ;
  flags xkstatus ;
  bool fatal ;
  int actcnt ;
  int retval ;
  dyret_enum duennaresult ;
  dyret_enum outresult ;
  pkvec_struct *ak ;
  pkcoeff_struct *aqk ;
  char const   *rtnnme ;
  double deltaj ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  bool tmp___4 ;
  int tmp___5 ;
  bool tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  double tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;

  {
#line 1254
  rtnnme = "type3activate";
#line 1260
  retval = -1;
#line 1261
  *p_actcnt = -1;
#line 1262
  actcnt = 0;
#line 1263
  ak = (pkvec_struct *)((void *)0);
#line 1270
  candxi = xindx;
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1271
    if (! (oxjndx != 0)) {
#line 1271
      goto while_break;
    }
#line 1275
    if (dy_opts->print.varmgmt >= 1) {
      {
#line 1276
      xjstatus = (flags )(- *(dy_origvars + oxjndx));
#line 1277
      tmp = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 1277
      tmp___0 = dy_prtvstat(xjstatus);
#line 1277
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating and flipping %s %s (%d), ",
                  tmp___0, tmp, oxjndx);
      }
#line 1281
      if (dirj < 0) {
#line 1281
        tmp___1 = "falling";
      } else {
#line 1281
        tmp___1 = "rising";
      }
      {
#line 1281
      dyio_outfmt(dy_logchn, dy_gtxecho, " cbar = %g, %s.", cbarj, tmp___1);
      }
    }
    {
#line 1287
    tmp___4 = dy_actNBPrimArch(orig_sys, oxjndx);
    }
#line 1287
    if ((int )tmp___4 == 0) {
      {
#line 1288
      tmp___2 = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 1288
      tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1288
      errmsg(430, rtnnme, orig_sys->nme, tmp___3, dy_lp->tot.iters, "activate", "variable",
             tmp___2, oxjndx);
      }
#line 1292
      return (-1);
    }
#line 1293
    actcnt ++;
#line 1298
    xjndx = *(dy_origvars + oxjndx);
#line 1299
    xjstatus = *(dy_status + xjndx);
#line 1300
    if (xjstatus & (unsigned int )(1 << 7)) {
#line 1300
      tmp___5 = 1;
    } else {
#line 1300
      tmp___5 = 0;
    }
#line 1300
    if (tmp___5) {
#line 1301
      *(dy_status + xjndx) = (flags )(1 << 6);
#line 1302
      *(dy_x + xjndx) = *(dy_sys->vub + xjndx);
    } else {
#line 1304
      *(dy_status + xjndx) = (flags )(1 << 7);
#line 1305
      *(dy_x + xjndx) = *(dy_sys->vlb + xjndx);
    }
    {
#line 1306
    *(dy_cbar + xjndx) = cbarj;
#line 1307
    tmp___6 = dy_calcprimals();
    }
#line 1307
    if ((int )tmp___6 == 0) {
      {
#line 1308
      errmsg(316, rtnnme, dy_sys->nme);
      }
#line 1309
      return (-1);
    }
    {
#line 1310
    dy_setbasicstatus();
    }
#line 1315
    if (dy_opts->print.dual >= 4) {
      {
#line 1316
      deltaj = (double )dirj * (*(dy_sys->vub + xjndx) - *(dy_sys->vlb + xjndx));
#line 1317
      dy_logpivot((dyret_enum )1, xjndx, dirj, cbarj, xjndx, dirj, abarij, deltaj);
      }
    }
    {
#line 1320
    dy_lp->phase = (dyphase_enum )4;
#line 1321
    duennaresult = dy_duenna((dyret_enum )1, xjndx, xindx, -1, -1);
#line 1322
    dy_lp->phase = (dyphase_enum )7;
    }
    {
#line 1326
    if ((int )duennaresult == 7) {
#line 1326
      goto case_7;
    }
#line 1326
    if ((int )duennaresult == 3) {
#line 1326
      goto case_7;
    }
#line 1326
    if ((int )duennaresult == 1) {
#line 1326
      goto case_7;
    }
#line 1330
    if ((int )duennaresult == -3) {
#line 1330
      goto case_neg_3;
    }
#line 1330
    if ((int )duennaresult == 6) {
#line 1330
      goto case_neg_3;
    }
#line 1333
    goto switch_default;
    case_7: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1327
    retval = 1;
#line 1328
    goto switch_break;
    case_neg_3: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 1331
    retval = 0;
#line 1332
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1334
    retval = -1;
#line 1335
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1350
    if (retval != 1) {
#line 1350
      goto while_break;
    }
    {
#line 1352
    outresult = dy_dualout(& candxi);
    }
#line 1353
    if (! ((int )outresult == 1)) {
#line 1353
      if (! ((int )outresult == 7)) {
#line 1354
        retval = 0;
#line 1355
        goto while_break;
      }
    }
#line 1356
    if (xindx != candxi) {
#line 1357
      retval = 1;
#line 1358
      goto while_break;
    }
#line 1365
    oxjndx = 0;
#line 1366
    distj = dy_tols->inf;
#line 1367
    cbarj = 0.0;
#line 1368
    abarij = 0.0;
#line 1369
    fatal = (bool )0;
#line 1370
    oxkndx = 1;
    {
#line 1370
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1370
      if (! (oxkndx <= orig_sys->varcnt)) {
#line 1370
        goto while_break___0;
      }
#line 1371
      xkstatus = (flags )(- *(dy_origvars + oxkndx));
#line 1372
      if (*(dy_origvars + oxkndx) < 0) {
#line 1372
        if ((flags )(- *(dy_origvars + oxkndx)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 1372
          tmp___10 = 0;
        } else {
#line 1372
          tmp___10 = 1;
        }
#line 1372
        if (! tmp___10) {
#line 1372
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1375
        if (dy_opts->print.varmgmt >= 3) {
          {
#line 1376
          tmp___7 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
          }
#line 1376
          if (*(dy_origvars + oxkndx) > 0) {
#line 1376
            tmp___9 = "loaded";
          } else {
            {
#line 1376
            tmp___8 = dy_prtvstat(xkstatus);
#line 1376
            tmp___9 = (char const   *)tmp___8;
            }
          }
          {
#line 1376
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      skipping %s %s (%d).", tmp___9,
                      tmp___7, oxkndx);
          }
        }
#line 1380
        goto __Cont;
      }
      {
#line 1386
      tmp___12 = consys_getcol_pk(orig_sys, oxkndx, & ak);
      }
#line 1386
      if ((int )tmp___12 == 0) {
        {
#line 1387
        tmp___11 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1387
        errmsg(122, rtnnme, orig_sys->nme, "column", tmp___11, oxkndx);
#line 1389
        fatal = (bool )1;
        }
#line 1390
        goto while_break___0;
      }
#line 1391
      abarik = 0.0;
#line 1392
      cbark = *(orig_sys->obj + oxkndx);
#line 1393
      pkndx = 0;
#line 1393
      aqk = ak->coeffs;
      {
#line 1393
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1393
        if (! (pkndx < ak->cnt)) {
#line 1393
          goto while_break___1;
        }
#line 1394
        if (*(dy_origcons + aqk->ndx) > 0) {
#line 1395
          xqndx = *(dy_origcons + aqk->ndx);
#line 1396
          abarik += *(betai + xqndx) * aqk->val;
#line 1397
          cbark -= *(dy_y + xqndx) * aqk->val;
        }
#line 1393
        pkndx ++;
#line 1393
        aqk ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1398
      tmp___13 = fabs(abarik);
      }
#line 1398
      if (tmp___13 < dy_tols->zero) {
#line 1398
        abarik = (double )0;
      }
#line 1399
      if (abarik == (double )0) {
#line 1402
        if (dy_opts->print.varmgmt >= 3) {
          {
#line 1403
          tmp___14 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1403
          tmp___15 = dy_prtvstat(xkstatus);
#line 1403
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n      skipping %s %s (%d), abarik = 0.",
                      tmp___15, tmp___14, oxkndx);
          }
        }
#line 1408
        goto __Cont;
      }
      {
#line 1409
      tmp___16 = fabs(cbark);
      }
#line 1409
      if (tmp___16 < dy_tols->zero) {
#line 1409
        cbark = (double )0;
      }
      {
#line 1410
      deltak = cbark / abarik;
#line 1411
      tmp___17 = fabs(deltak);
      }
#line 1411
      if (tmp___17 < dy_tols->zero) {
#line 1411
        deltak = (double )0;
      }
#line 1416
      if ((double )diri * - deltak <= (double )0) {
        {
#line 1417
        type3eval(orig_sys, xindx, diri, oxkndx, xkstatus, abarik, cbark, & oxjndx,
                  & distj, & cbarj, & dirj, & abarij);
        }
#line 1419
        if (distj == (double )0) {
#line 1419
          goto while_break___0;
        }
      }
      __Cont: /* CIL Label */ 
#line 1370
      oxkndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1424
  if (oxjndx == 0) {
#line 1424
    retval = 0;
  }
#line 1425
  *p_actcnt = actcnt;
#line 1426
  if ((unsigned long )ak != (unsigned long )((void *)0)) {
    {
#line 1426
    pkvec_free(ak);
    }
  }
#line 1428
  if (dy_opts->print.varmgmt >= 1) {
    {
#line 1429
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activated %d variables", actcnt);
    }
    {
#line 1431
    if (retval == 1) {
#line 1431
      goto case_1___0;
    }
#line 1434
    if (retval == 0) {
#line 1434
      goto case_0;
    }
#line 1437
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 1432
    dyio_outfmt(dy_logchn, dy_gtxecho, ", success.");
    }
#line 1433
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 1435
    dyio_outfmt(dy_logchn, dy_gtxecho, ", exhaustion.");
    }
#line 1436
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1438
    dyio_outfmt(dy_logchn, dy_gtxecho, ", error.");
    }
#line 1439
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1442
  return (retval);
}
}
#line 1446 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_bound.c"
int dy_dualaddvars(consys_struct *orig_sys ) 
{ 
  int acttype ;
  int newcnt ;
  int xindx ;
  int xipos ;
  int diri ;
  int evalcode ;
  int oxkndx ;
  int pkndx ;
  int xqndx ;
  int ox2ndx ;
  int dir2 ;
  int ox3ndx ;
  int dir3 ;
  double *betai ;
  double abarik ;
  double cbark ;
  double deltak ;
  double delta2 ;
  double cbar2 ;
  double dist3 ;
  double cbar3 ;
  double abari3 ;
  flags xkstatus ;
  bool fatal ;
  pkvec_struct *ak ;
  pkcoeff_struct *aqk ;
  int retval ;
  char const   *rtnnme ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  double tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
#line 1529
  rtnnme = "dy_dualaddvars";
#line 1531
  retval = -1;
#line 1532
  dir2 = 0;
#line 1553
  xindx = dy_lp->ubnd.ndx;
#line 1554
  if (xindx < 0) {
#line 1555
    xindx = - xindx;
#line 1556
    diri = -1;
  } else {
#line 1558
    diri = 1;
  }
  {
#line 1559
  xipos = *(dy_var2basis + xindx);
#line 1565
  tmp = calloc((size_t )(dy_sys->concnt + 1), sizeof(double ));
#line 1565
  betai = (double *)tmp;
#line 1566
  *(betai + xipos) = 1.0;
#line 1567
  dy_btran(betai);
  }
#line 1569
  if (dy_opts->print.varmgmt >= 2) {
    {
#line 1570
    tmp___0 = consys_nme(dy_sys, (char )'v', xindx, (bool )1, (char *)((void *)0));
#line 1570
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    leaving variable %s (%d) ", tmp___0,
                xindx);
    }
#line 1572
    if (diri > 0) {
      {
#line 1573
      dyio_outfmt(dy_logchn, dy_gtxecho, "rising to lb = %g.", *(dy_sys->vlb + xindx));
      }
    } else {
      {
#line 1576
      dyio_outfmt(dy_logchn, dy_gtxecho, "falling to ub = %g.", *(dy_sys->vub + xindx));
      }
    }
  }
#line 1584
  if ((unsigned int )dy_lp->phase == 1U) {
#line 1585
    acttype = 1;
  } else {
#line 1587
    acttype = dy_opts->dualadd;
  }
#line 1588
  ak = (pkvec_struct *)((void *)0);
#line 1589
  newcnt = 0;
#line 1590
  ox2ndx = 0;
#line 1591
  delta2 = dy_tols->inf;
#line 1592
  cbar2 = 0.0;
#line 1593
  ox3ndx = 0;
#line 1594
  dist3 = - dy_tols->inf;
#line 1595
  cbar3 = 0.0;
#line 1596
  abari3 = (double )0;
#line 1597
  fatal = (bool )0;
#line 1598
  oxkndx = 1;
  {
#line 1598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1598
    if (! (oxkndx <= orig_sys->varcnt)) {
#line 1598
      goto while_break;
    }
#line 1599
    xkstatus = (flags )(- *(dy_origvars + oxkndx));
#line 1600
    if (*(dy_origvars + oxkndx) < 0) {
#line 1600
      if ((flags )(- *(dy_origvars + oxkndx)) & ((1U << (sizeof(flags ) * 8UL - 4UL)) | (unsigned int )(1 << 5))) {
#line 1600
        tmp___4 = 0;
      } else {
#line 1600
        tmp___4 = 1;
      }
#line 1600
      if (! tmp___4) {
#line 1600
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1603
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 1604
        tmp___1 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
        }
#line 1604
        if (*(dy_origvars + oxkndx) > 0) {
#line 1604
          tmp___3 = "loaded";
        } else {
          {
#line 1604
          tmp___2 = dy_prtvstat(xkstatus);
#line 1604
          tmp___3 = (char const   *)tmp___2;
          }
        }
        {
#line 1604
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      skipping %s %s (%d).", tmp___3,
                    tmp___1, oxkndx);
        }
      }
#line 1608
      goto __Cont;
    }
    {
#line 1623
    tmp___6 = consys_getcol_pk(orig_sys, oxkndx, & ak);
    }
#line 1623
    if ((int )tmp___6 == 0) {
      {
#line 1624
      tmp___5 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1624
      errmsg(122, rtnnme, orig_sys->nme, "column", tmp___5, oxkndx);
#line 1626
      fatal = (bool )1;
      }
#line 1627
      goto while_break;
    }
#line 1628
    abarik = 0.0;
#line 1629
    cbark = *(orig_sys->obj + oxkndx);
#line 1630
    pkndx = 0;
#line 1630
    aqk = ak->coeffs;
    {
#line 1630
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1630
      if (! (pkndx < ak->cnt)) {
#line 1630
        goto while_break___0;
      }
#line 1631
      if (*(dy_origcons + aqk->ndx) > 0) {
#line 1632
        xqndx = *(dy_origcons + aqk->ndx);
#line 1633
        abarik += *(betai + xqndx) * aqk->val;
#line 1634
        cbark -= *(dy_y + xqndx) * aqk->val;
      }
#line 1630
      pkndx ++;
#line 1630
      aqk ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1635
    tmp___7 = fabs(abarik);
    }
#line 1635
    if (tmp___7 < dy_tols->zero) {
#line 1635
      abarik = (double )0;
    }
#line 1636
    if (abarik == (double )0) {
#line 1639
      if (dy_opts->print.varmgmt >= 3) {
        {
#line 1640
        tmp___8 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1640
        tmp___9 = dy_prtvstat(xkstatus);
#line 1640
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n      skipping %s %s (%d), abarik = 0.",
                    tmp___9, tmp___8, oxkndx);
        }
      }
#line 1645
      goto __Cont;
    }
    {
#line 1646
    tmp___10 = fabs(cbark);
    }
#line 1646
    if (tmp___10 < dy_tols->zero) {
#line 1646
      cbark = (double )0;
    }
    {
#line 1647
    deltak = cbark / abarik;
#line 1648
    tmp___11 = fabs(deltak);
    }
#line 1648
    if (tmp___11 < dy_tols->zero) {
#line 1648
      deltak = (double )0;
    }
#line 1656
    if ((double )diri * - deltak >= (double )0) {
      {
#line 1657
      evalcode = type1var(orig_sys, xindx, diri, oxkndx, xkstatus, abarik, cbark);
      }
#line 1658
      if (evalcode < 0) {
        {
#line 1659
        tmp___12 = consys_nme(orig_sys, (char )'v', oxkndx, (bool )1, (char *)((void *)0));
#line 1659
        tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1659
        errmsg(400, rtnnme, dy_sys->nme, tmp___13, dy_lp->tot.iters, 1, tmp___12,
               oxkndx);
#line 1662
        fatal = (bool )1;
        }
#line 1663
        goto while_break;
      } else
#line 1665
      if (evalcode > 0) {
#line 1666
        newcnt ++;
      } else
#line 1668
      if (newcnt == 0) {
#line 1668
        if (acttype >= 2) {
          {
#line 1669
          type2eval(orig_sys, xindx, diri, oxkndx, xkstatus, abarik, cbark, & ox2ndx,
                    & delta2, & cbar2, & dir2);
          }
        }
      }
    } else
#line 1676
    if (newcnt == 0) {
#line 1676
      if (ox2ndx == 0) {
#line 1676
        if (acttype >= 3) {
          {
#line 1677
          type3eval(orig_sys, xindx, diri, oxkndx, xkstatus, abarik, cbark, & ox3ndx,
                    & dist3, & cbar3, & dir3, & abari3);
          }
        }
      }
    }
#line 1682
    if (dy_opts->addvar > 0) {
#line 1682
      if (newcnt >= dy_opts->addvar) {
#line 1682
        goto while_break;
      }
    }
    __Cont: /* CIL Label */ 
#line 1598
    oxkndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1688
  if ((unsigned long )ak != (unsigned long )((void *)0)) {
    {
#line 1688
    pkvec_free(ak);
    }
  }
#line 1689
  if ((int )fatal == 1) {
#line 1689
    return (retval);
  }
#line 1690
  if (newcnt > 0) {
#line 1693
    if (dy_opts->print.varmgmt >= 1) {
#line 1694
      if (dy_opts->print.varmgmt >= 2) {
        {
#line 1695
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
        }
      }
      {
#line 1696
      dyio_outfmt(dy_logchn, dy_gtxecho, " %d activations.", newcnt);
#line 1697
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    constraint system %s now %d x %d (%d + %d).",
                  dy_sys->nme, dy_sys->concnt, dy_sys->varcnt, dy_sys->archvcnt, dy_sys->logvcnt);
      }
    }
#line 1702
    retval = newcnt;
  } else
#line 1708
  if (ox2ndx > 0) {
#line 1708
    if (acttype >= 2) {
      {
#line 1709
      retval = type2activate(orig_sys, xindx, diri, ox2ndx, dir2, cbar2);
      }
    } else {
#line 1708
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1717
  if (ox3ndx > 0) {
#line 1717
    if (acttype >= 3) {
      {
#line 1718
      retval = type3activate(orig_sys, betai, xindx, diri, ox3ndx, dir3, cbar3, abari3,
                             & newcnt);
      }
#line 1720
      if (retval >= 0) {
#line 1721
        retval = newcnt;
      }
    } else {
#line 1726
      retval = 0;
    }
  } else {
#line 1726
    retval = 0;
  }
#line 1728
  if ((unsigned long )betai != (unsigned long )((void *)0)) {
    {
#line 1728
    free((void *)betai);
    }
  }
#line 1738
  return (retval);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___3  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 1957 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
char const   *dy_prtlpret(lpret_enum lpret ) ;
#line 1960
bool dy_dumpcompact(ioid chn , bool echo , lpprob_struct *soln , bool nbzeros ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
char const   *dy_prtlpret(lpret_enum lpret ) 
{ 
  char const   *rtnnme ;

  {
#line 38
  rtnnme = "dy_prtlpret";
  {
#line 41
  if ((int )lpret == 0) {
#line 41
    goto case_0;
  }
#line 43
  if ((int )lpret == 1) {
#line 43
    goto case_1;
  }
#line 45
  if ((int )lpret == 2) {
#line 45
    goto case_2;
  }
#line 47
  if ((int )lpret == 3) {
#line 47
    goto case_3;
  }
#line 49
  if ((int )lpret == 4) {
#line 49
    goto case_4;
  }
#line 51
  if ((int )lpret == 5) {
#line 51
    goto case_5;
  }
#line 53
  if ((int )lpret == 6) {
#line 53
    goto case_6;
  }
#line 55
  if ((int )lpret == 7) {
#line 55
    goto case_7;
  }
#line 57
  if ((int )lpret == 8) {
#line 57
    goto case_8;
  }
#line 59
  if ((int )lpret == 9) {
#line 59
    goto case_9;
  }
#line 61
  if ((int )lpret == 10) {
#line 61
    goto case_10;
  }
#line 63
  if ((int )lpret == 11) {
#line 63
    goto case_11;
  }
#line 65
  if ((int )lpret == 12) {
#line 65
    goto case_12;
  }
#line 67
  if ((int )lpret == 13) {
#line 67
    goto case_13;
  }
#line 69
  if ((int )lpret == -1) {
#line 69
    goto case_neg_1;
  }
#line 71
  goto switch_default;
  case_0: /* CIL Label */ 
#line 42
  return ("invalid");
  case_1: /* CIL Label */ 
#line 44
  return ("optimal");
  case_2: /* CIL Label */ 
#line 46
  return ("unbounded");
  case_3: /* CIL Label */ 
#line 48
  return ("pseudo-unbounded");
  case_4: /* CIL Label */ 
#line 50
  return ("infeasible");
  case_5: /* CIL Label */ 
#line 52
  return ("accuracy check");
  case_6: /* CIL Label */ 
#line 54
  return ("stalled");
  case_7: /* CIL Label */ 
#line 56
  return ("iteration limit exceeded");
  case_8: /* CIL Label */ 
#line 58
  return ("insufficient memory");
  case_9: /* CIL Label */ 
#line 60
  return ("lost feasibility");
  case_10: /* CIL Label */ 
#line 62
  return ("punt!");
  case_11: /* CIL Label */ 
#line 64
  return ("force primal -> dual");
  case_12: /* CIL Label */ 
#line 66
  return ("force dual -> primal");
  case_13: /* CIL Label */ 
#line 68
  return ("force full activation");
  case_neg_1: /* CIL Label */ 
#line 70
  return ("unspecified fatal error");
  switch_default: /* CIL Label */ 
  {
#line 72
  errmsg(5, rtnnme, "lpret", (int )lpret);
  }
#line 73
  return ("nonsense");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
static char buffer[100]  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
char *dy_prtvstat(flags status ) 
{ 
  flags mystatus ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 91
  rtnnme = "dy_prtvstat";
#line 98
  buffer[0] = (char )'\000';
#line 99
  if (status != 0U) {
#line 100
    mystatus = status;
#line 101
    mystatus &= ~ (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
  } else {
    {
#line 103
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"INV");
    }
#line 104
    return (buffer);
  }
#line 106
  if (mystatus != 0U) {
    {
#line 108
    if (mystatus == 1U) {
#line 108
      goto case_1;
    }
#line 111
    if (mystatus == (flags )(1 << 10)) {
#line 111
      goto case_exp;
    }
#line 114
    if (mystatus == (flags )(1 << 1)) {
#line 114
      goto case_exp___0;
    }
#line 117
    if (mystatus == (flags )(1 << 2)) {
#line 117
      goto case_exp___1;
    }
#line 120
    if (mystatus == (flags )(1 << 3)) {
#line 120
      goto case_exp___2;
    }
#line 123
    if (mystatus == (flags )(1 << 11)) {
#line 123
      goto case_exp___3;
    }
#line 126
    if (mystatus == (flags )(1 << 4)) {
#line 126
      goto case_exp___4;
    }
#line 129
    if (mystatus == (flags )(1 << 5)) {
#line 129
      goto case_exp___5;
    }
#line 132
    if (mystatus == (flags )(1 << 6)) {
#line 132
      goto case_exp___6;
    }
#line 135
    if (mystatus == (flags )(1 << 7)) {
#line 135
      goto case_exp___7;
    }
#line 138
    if (mystatus == (flags )(1 << 8)) {
#line 138
      goto case_exp___8;
    }
#line 141
    if (mystatus == (flags )(1 << 9)) {
#line 141
      goto case_exp___9;
    }
#line 144
    if (mystatus == 0U) {
#line 144
      goto case_0;
    }
#line 147
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 109
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BFX");
    }
#line 110
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 112
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BUUB");
    }
#line 113
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 115
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BUB");
    }
#line 116
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 118
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"B");
    }
#line 119
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 121
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BLB");
    }
#line 122
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    {
#line 124
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BLLB");
    }
#line 125
    goto switch_break;
    case_exp___4: /* CIL Label */ 
    {
#line 127
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"BFR");
    }
#line 128
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    {
#line 130
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"NBFX");
    }
#line 131
    goto switch_break;
    case_exp___6: /* CIL Label */ 
    {
#line 133
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"NBUB");
    }
#line 134
    goto switch_break;
    case_exp___7: /* CIL Label */ 
    {
#line 136
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"NBLB");
    }
#line 137
    goto switch_break;
    case_exp___8: /* CIL Label */ 
    {
#line 139
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"NBFR");
    }
#line 140
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    {
#line 142
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"SB");
    }
#line 143
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 145
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"INV");
    }
#line 146
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 148
    errmsg(6, rtnnme, "status", (int )status);
#line 149
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"NONSENSE");
    }
#line 150
    return (buffer);
    switch_break: /* CIL Label */ ;
    }
  }
#line 154
  if (status != mystatus) {
    {
#line 155
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"(");
    }
#line 156
    if (status & (1U << (sizeof(flags ) * 8UL - 2UL))) {
#line 156
      tmp = 1;
    } else {
#line 156
      tmp = 0;
    }
#line 156
    if (tmp) {
      {
#line 156
      strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"v");
      }
    }
#line 157
    if (status & (1U << (sizeof(flags ) * 8UL - 3UL))) {
#line 157
      tmp___0 = 1;
    } else {
#line 157
      tmp___0 = 0;
    }
#line 157
    if (tmp___0) {
      {
#line 157
      strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"p");
      }
    }
#line 158
    if (status & (1U << (sizeof(flags ) * 8UL - 4UL))) {
#line 158
      tmp___1 = 1;
    } else {
#line 158
      tmp___1 = 0;
    }
#line 158
    if (tmp___1) {
      {
#line 158
      strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"l");
      }
    }
    {
#line 159
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)")");
    }
  }
#line 161
  return (buffer);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
char const   *dy_prtlpphase(dyphase_enum phase , bool abbrv ) 
{ 
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
#line 179
  rtnnme = "dy_prtlpphase";
  {
#line 182
  if ((unsigned int )phase == 1U) {
#line 182
    goto case_1;
  }
#line 184
  if ((unsigned int )phase == 5U) {
#line 184
    goto case_5;
  }
#line 186
  if ((unsigned int )phase == 6U) {
#line 186
    goto case_6;
  }
#line 188
  if ((unsigned int )phase == 7U) {
#line 188
    goto case_7;
  }
#line 190
  if ((unsigned int )phase == 2U) {
#line 190
    goto case_2;
  }
#line 192
  if ((unsigned int )phase == 3U) {
#line 192
    goto case_3;
  }
#line 194
  if ((unsigned int )phase == 8U) {
#line 194
    goto case_8;
  }
#line 196
  if ((unsigned int )phase == 9U) {
#line 196
    goto case_9;
  }
#line 198
  if ((unsigned int )phase == 10U) {
#line 198
    goto case_10;
  }
#line 200
  if ((unsigned int )phase == 4U) {
#line 200
    goto case_4;
  }
#line 202
  if ((unsigned int )phase == 11U) {
#line 202
    goto case_11;
  }
#line 204
  if ((unsigned int )phase == 12U) {
#line 204
    goto case_12;
  }
#line 206
  if ((unsigned int )phase == 13U) {
#line 206
    goto case_13;
  }
#line 208
  if ((unsigned int )phase == 14U) {
#line 208
    goto case_14;
  }
#line 210
  if ((unsigned int )phase == 0U) {
#line 210
    goto case_0;
  }
#line 212
  goto switch_default;
  case_1: /* CIL Label */ 
#line 183
  if ((int )abbrv == 1) {
#line 183
    tmp = "IN";
  } else {
#line 183
    tmp = "initialisation";
  }
#line 183
  return (tmp);
  case_5: /* CIL Label */ 
#line 185
  if ((int )abbrv == 1) {
#line 185
    tmp___0 = "VD";
  } else {
#line 185
    tmp___0 = "variable deactivation";
  }
#line 185
  return (tmp___0);
  case_6: /* CIL Label */ 
#line 187
  if ((int )abbrv == 1) {
#line 187
    tmp___1 = "VG";
  } else {
#line 187
    tmp___1 = "variable generation";
  }
#line 187
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 189
  if ((int )abbrv == 1) {
#line 189
    tmp___2 = "VA";
  } else {
#line 189
    tmp___2 = "variable activation";
  }
#line 189
  return (tmp___2);
  case_2: /* CIL Label */ 
#line 191
  if ((int )abbrv == 1) {
#line 191
    tmp___3 = "P1";
  } else {
#line 191
    tmp___3 = "primal phase I";
  }
#line 191
  return (tmp___3);
  case_3: /* CIL Label */ 
#line 193
  if ((int )abbrv == 1) {
#line 193
    tmp___4 = "P2";
  } else {
#line 193
    tmp___4 = "primal phase II";
  }
#line 193
  return (tmp___4);
  case_8: /* CIL Label */ 
#line 195
  if ((int )abbrv == 1) {
#line 195
    tmp___5 = "CD";
  } else {
#line 195
    tmp___5 = "constraint deactivation";
  }
#line 195
  return (tmp___5);
  case_9: /* CIL Label */ 
#line 197
  if ((int )abbrv == 1) {
#line 197
    tmp___6 = "CG";
  } else {
#line 197
    tmp___6 = "constraint generation";
  }
#line 197
  return (tmp___6);
  case_10: /* CIL Label */ 
#line 199
  if ((int )abbrv == 1) {
#line 199
    tmp___7 = "CA";
  } else {
#line 199
    tmp___7 = "constraint activation";
  }
#line 199
  return (tmp___7);
  case_4: /* CIL Label */ 
#line 201
  if ((int )abbrv == 1) {
#line 201
    tmp___8 = "D2";
  } else {
#line 201
    tmp___8 = "dual";
  }
#line 201
  return (tmp___8);
  case_11: /* CIL Label */ 
#line 203
  if ((int )abbrv == 1) {
#line 203
    tmp___9 = "FD";
  } else {
#line 203
    tmp___9 = "force dual";
  }
#line 203
  return (tmp___9);
  case_12: /* CIL Label */ 
#line 205
  if ((int )abbrv == 1) {
#line 205
    tmp___10 = "FP";
  } else {
#line 205
    tmp___10 = "force primal";
  }
#line 205
  return (tmp___10);
  case_13: /* CIL Label */ 
#line 207
  if ((int )abbrv == 1) {
#line 207
    tmp___11 = "FF";
  } else {
#line 207
    tmp___11 = "force full";
  }
#line 207
  return (tmp___11);
  case_14: /* CIL Label */ 
#line 209
  if ((int )abbrv == 1) {
#line 209
    tmp___12 = "DN";
  } else {
#line 209
    tmp___12 = "done";
  }
#line 209
  return (tmp___12);
  case_0: /* CIL Label */ 
#line 211
  if ((int )abbrv == 1) {
#line 211
    tmp___13 = "NV";
  } else {
#line 211
    tmp___13 = "invalid";
  }
#line 211
  return (tmp___13);
  switch_default: /* CIL Label */ 
  {
#line 213
  errmsg(6, rtnnme, "lp phase", (int )phase);
  }
#line 214
  if ((int )abbrv == 1) {
#line 214
    tmp___14 = "??";
  } else {
#line 214
    tmp___14 = "nonsense";
  }
#line 214
  return (tmp___14);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
char const   *dy_prtdyret(dyret_enum retcode ) 
{ 
  char const   *rtnnme ;

  {
#line 230
  rtnnme = "dy_prtdyret";
  {
#line 233
  if ((int )retcode == 1) {
#line 233
    goto case_1;
  }
#line 235
  if ((int )retcode == 7) {
#line 235
    goto case_7;
  }
#line 237
  if ((int )retcode == 8) {
#line 237
    goto case_8;
  }
#line 239
  if ((int )retcode == 9) {
#line 239
    goto case_9;
  }
#line 241
  if ((int )retcode == 10) {
#line 241
    goto case_10;
  }
#line 243
  if ((int )retcode == 4) {
#line 243
    goto case_4;
  }
#line 245
  if ((int )retcode == 5) {
#line 245
    goto case_5;
  }
#line 247
  if ((int )retcode == -4) {
#line 247
    goto case_neg_4;
  }
#line 249
  if ((int )retcode == -3) {
#line 249
    goto case_neg_3;
  }
#line 251
  if ((int )retcode == -2) {
#line 251
    goto case_neg_2;
  }
#line 253
  if ((int )retcode == 3) {
#line 253
    goto case_3;
  }
#line 258
  if ((int )retcode == -1) {
#line 258
    goto case_neg_1;
  }
#line 260
  if ((int )retcode == 6) {
#line 260
    goto case_6;
  }
#line 262
  if ((int )retcode == 2) {
#line 262
    goto case_2;
  }
#line 264
  if ((int )retcode == -6) {
#line 264
    goto case_neg_6;
  }
#line 266
  if ((int )retcode == -5) {
#line 266
    goto case_neg_5;
  }
#line 268
  if ((int )retcode == -7) {
#line 268
    goto case_neg_7;
  }
#line 270
  if ((int )retcode == -8) {
#line 270
    goto case_neg_8;
  }
#line 272
  if ((int )retcode == -9) {
#line 272
    goto case_neg_9;
  }
#line 274
  if ((int )retcode == -10) {
#line 274
    goto case_neg_10;
  }
#line 276
  if ((int )retcode == 0) {
#line 276
    goto case_0;
  }
#line 278
  goto switch_default;
  case_1: /* CIL Label */ 
#line 234
  return ("ok");
  case_7: /* CIL Label */ 
#line 236
  return ("optimal");
  case_8: /* CIL Label */ 
#line 238
  return ("unbounded");
  case_9: /* CIL Label */ 
#line 240
  return ("pseudo-unbounded");
  case_10: /* CIL Label */ 
#line 242
  return ("infeasible");
  case_4: /* CIL Label */ 
#line 244
  return ("request accuracy check");
  case_5: /* CIL Label */ 
#line 246
  return ("accuracy check failure");
  case_neg_4: /* CIL Label */ 
#line 248
  return ("loss of primal feasibility");
  case_neg_3: /* CIL Label */ 
#line 250
  return ("loss of dual feasibility");
  case_neg_2: /* CIL Label */ 
#line 252
  return ("degenerate pivot");
  case_3: /* CIL Label */ 
#line 254
  if ((unsigned int )dy_lp->phase == 4U) {
#line 255
    return ("reselect leaving variable");
  } else {
#line 257
    return ("reselect entering variable");
  }
  case_neg_1: /* CIL Label */ 
#line 259
  return ("numerically unstable pivot");
  case_6: /* CIL Label */ 
#line 261
  return ("punt!");
  case_2: /* CIL Label */ 
#line 263
  return ("basis patched");
  case_neg_6: /* CIL Label */ 
#line 265
  return ("basis singular");
  case_neg_5: /* CIL Label */ 
#line 267
  return ("ill-conditioned basis");
  case_neg_7: /* CIL Label */ 
#line 269
  return ("no space for basis");
  case_neg_8: /* CIL Label */ 
#line 271
  return ("stalled");
  case_neg_9: /* CIL Label */ 
#line 273
  return ("iteration limit");
  case_neg_10: /* CIL Label */ 
#line 275
  return ("fatal error");
  case_0: /* CIL Label */ 
#line 277
  return ("invalid");
  switch_default: /* CIL Label */ 
  {
#line 279
  errmsg(6, rtnnme, "dyret_enum code", (int )retcode);
  }
#line 280
  return ("nonsense");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
void dy_logpivot(dyret_enum result , int xjndx , int indir , double cbarj , int xindx ,
                 int outdir , double abarij , double delta ) 
{ 
  bool validin ;
  bool validout ;
  char const   *resstr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;

  {
#line 311
  validin = (bool )1;
#line 312
  validout = (bool )1;
  {
#line 315
  if ((int )result == 1) {
#line 315
    goto case_1;
  }
#line 318
  if ((int )result == -2) {
#line 318
    goto case_neg_2;
  }
#line 321
  if ((int )result == 8) {
#line 321
    goto case_8;
  }
#line 329
  if ((int )result == 9) {
#line 329
    goto case_9;
  }
#line 332
  if ((int )result == -4) {
#line 332
    goto case_neg_4;
  }
#line 335
  if ((int )result == -3) {
#line 335
    goto case_neg_3;
  }
#line 338
  if ((int )result == 7) {
#line 338
    goto case_7;
  }
#line 344
  if ((int )result == 6) {
#line 344
    goto case_6;
  }
#line 349
  if ((int )result == 4) {
#line 349
    goto case_4;
  }
#line 355
  if ((int )result == -1) {
#line 355
    goto case_neg_1;
  }
#line 360
  if ((int )result == -6) {
#line 360
    goto case_neg_6;
  }
#line 363
  if ((int )result == -7) {
#line 363
    goto case_neg_7;
  }
#line 366
  if ((int )result == -10) {
#line 366
    goto case_neg_10;
  }
#line 369
  if ((int )result == 3) {
#line 369
    goto case_3;
  }
#line 374
  goto switch_default;
  case_1: /* CIL Label */ 
#line 316
  resstr = "(ok)";
#line 317
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 319
  resstr = "(degen)";
#line 320
  goto switch_break;
  case_8: /* CIL Label */ 
#line 322
  if ((unsigned int )dy_lp->phase == 4U) {
#line 323
    resstr = "(infea)";
#line 324
    validin = (bool )0;
  } else {
#line 326
    resstr = "(unbnd)";
#line 327
    validout = (bool )0;
  }
#line 328
  goto switch_break;
  case_9: /* CIL Label */ 
#line 330
  resstr = "(swing)";
#line 331
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 333
  resstr = "(!pfea)";
#line 334
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 336
  resstr = "(!dfea)";
#line 337
  goto switch_break;
  case_7: /* CIL Label */ 
#line 339
  if ((unsigned int )dy_lp->phase == 2U) {
#line 340
    resstr = "(infea)";
  } else {
#line 342
    resstr = "(opt)";
  }
#line 343
  goto switch_break;
  case_6: /* CIL Label */ 
#line 345
  resstr = "(punt!)";
#line 346
  if (xjndx <= 0) {
#line 347
    validin = (bool )0;
  }
#line 348
  goto switch_break;
  case_4: /* CIL Label */ 
#line 350
  if ((int )dy_lp->pivok == 0) {
#line 351
    resstr = "(chkab)";
  } else {
#line 353
    resstr = "(chkrq)";
  }
#line 354
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 356
  resstr = "(mad)";
#line 357
  if (xjndx <= 0) {
#line 358
    validin = (bool )0;
  }
#line 359
  goto switch_break;
  case_neg_6: /* CIL Label */ 
#line 361
  resstr = "(sing)";
#line 362
  goto switch_break;
  case_neg_7: /* CIL Label */ 
#line 364
  resstr = "(nosp)";
#line 365
  goto switch_break;
  case_neg_10: /* CIL Label */ 
#line 367
  resstr = "(fatal)";
#line 368
  goto switch_break;
  case_3: /* CIL Label */ 
#line 370
  resstr = "(resel)";
#line 371
  if ((unsigned int )dy_lp->phase == 4U) {
#line 372
    validout = (bool )1;
  }
#line 373
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 375
  resstr = "(huh?)";
#line 376
  result = (dyret_enum )0;
#line 377
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 378
  tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 378
  dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s%6d %-7s ", tmp, dy_lp->tot.iters + 1, resstr);
  }
#line 382
  if ((int )result == 0) {
#line 382
    return;
  }
#line 384
  if ((int )validin == 1) {
#line 384
    if (xjndx > 0) {
#line 385
      if (indir == 1) {
#line 385
        tmp___0 = "inc";
      } else {
#line 385
        tmp___0 = "dec";
      }
      {
#line 385
      tmp___1 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 385
      dyio_outfmt(dy_logchn, dy_gtxecho, "In: %s (%d) %s cbarj = %g ;", tmp___1, xjndx,
                  tmp___0, cbarj);
      }
    } else {
      {
#line 389
      dyio_outfmt(dy_logchn, dy_gtxecho, "In: <not selected>");
      }
    }
  } else {
    {
#line 389
    dyio_outfmt(dy_logchn, dy_gtxecho, "In: <not selected>");
    }
  }
#line 391
  if ((int )result == -10) {
#line 391
    return;
  }
#line 393
  if ((int )result == -4) {
    {
#line 394
    tmp___2 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 394
    dyio_outfmt(dy_logchn, dy_gtxecho, " Infeas: %s (%d) = %g, lb = %g, ub = %g",
                tmp___2, xindx, *(dy_xbasic + *(dy_var2basis + xindx)), *(dy_sys->vlb + xindx),
                *(dy_sys->vub + xindx));
    }
#line 399
    return;
  }
#line 401
  if ((int )validout == 1) {
#line 401
    if (xindx > 0) {
#line 402
      if (outdir == 1) {
#line 402
        tmp___3 = "inc";
      } else {
#line 402
        tmp___3 = "dec";
      }
      {
#line 402
      tmp___4 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 402
      dyio_outfmt(dy_logchn, dy_gtxecho, " Out: %s (%d) %s", tmp___4, xindx, tmp___3);
      }
    } else {
      {
#line 406
      dyio_outfmt(dy_logchn, dy_gtxecho, " Out: <not selected>");
      }
    }
  } else {
    {
#line 406
    dyio_outfmt(dy_logchn, dy_gtxecho, " Out: <not selected>");
    }
  }
#line 408
  if ((int )validin == 1) {
#line 408
    if ((int )validout == 1) {
#line 409
      if (indir == 1) {
#line 409
        tmp___5 = delta;
      } else {
#line 409
        tmp___5 = - delta;
      }
      {
#line 409
      dyio_outfmt(dy_logchn, dy_gtxecho, ", abarij = %g, delta = %g", abarij, tmp___5);
      }
    }
  }
#line 412
  if ((unsigned int )dy_lp->phase == 4U) {
    {
#line 413
    tmp___6 = dy_calcdualobj();
#line 413
    dyio_outfmt(dy_logchn, dy_gtxecho, ", yb = %g.", tmp___6);
    }
  } else
#line 415
  if ((unsigned int )dy_lp->phase == 2U) {
    {
#line 416
    tmp___7 = dy_calcpinfeas();
#line 416
    dyio_outfmt(dy_logchn, dy_gtxecho, ", infeas = %g.", tmp___7);
    }
  } else
#line 418
  if ((unsigned int )dy_lp->phase == 3U) {
    {
#line 419
    tmp___8 = dy_calcobj();
#line 419
    dyio_outfmt(dy_logchn, dy_gtxecho, ", cx = %g.", tmp___8);
    }
  } else {
    {
#line 421
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
    }
  }
#line 423
  return;
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_io.c"
bool dy_dumpcompact(ioid chn , bool echo , lpprob_struct *soln , bool nbzeros ) 
{ 
  int vndx ;
  int cndx ;
  int bpos ;
  double val ;
  bool nononbasic ;
  consys_struct *sys ;
  basis_struct *basis ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 464
  rtnnme = "dy_dumpcompact";
#line 475
  sys = soln->consys;
#line 482
  tmp = dy_prtlpphase(soln->phase, (bool )0);
#line 482
  dyio_outfmt(chn, echo, "\n\nSystem: %s\t\t\tfinal status: %s after %d iterations.",
              sys->nme, tmp, soln->iters);
  }
#line 485
  if ((unsigned int )soln->phase != 14U) {
    {
#line 486
    dyio_outchr(chn, echo, (char )'\n');
    }
#line 487
    return ((bool )1);
  }
  {
#line 492
  tmp___0 = dy_prtlpret(soln->lpret);
#line 492
  dyio_outfmt(chn, echo, "\n    lp status: %s", tmp___0);
  }
  {
#line 494
  if ((int )soln->lpret == 1) {
#line 494
    goto case_1;
  }
#line 497
  if ((int )soln->lpret == 4) {
#line 497
    goto case_4;
  }
#line 500
  if ((int )soln->lpret == 2) {
#line 500
    goto case_2;
  }
#line 512
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 495
  dyio_outfmt(chn, echo, "\t\tobjective: %.9g", soln->obj);
  }
#line 496
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 498
  dyio_outfmt(chn, echo, "\t\tinfeasibility: %.9g", soln->obj);
  }
#line 499
  goto switch_break;
  case_2: /* CIL Label */ 
#line 501
  if (soln->obj != (double )0) {
#line 502
    if (soln->obj < (double )0) {
      {
#line 503
      vndx = abs((int )soln->obj);
#line 504
      bpos = -1;
      }
    } else {
#line 506
      vndx = (int )soln->obj;
#line 507
      bpos = 1;
    }
#line 508
    if (bpos < 0) {
#line 508
      tmp___1 = "decreasing";
    } else {
#line 508
      tmp___1 = "increasing";
    }
    {
#line 508
    tmp___2 = consys_nme(sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 508
    dyio_outfmt(chn, echo, "\t\tunbounded variable %s (%d) (%s)", tmp___2, vndx, tmp___1);
    }
  }
#line 511
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 513
  dyio_outchr(chn, echo, (char )'\n');
  }
#line 514
  return ((bool )1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 519
  dyio_outfmt(chn, echo, "\n\nPosn\tConstraint\tDual\t\tPrimal\n");
#line 520
  basis = soln->basis;
#line 521
  bpos = 1;
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    if (! (bpos <= basis->len)) {
#line 521
      goto while_break;
    }
#line 522
    cndx = (basis->el + bpos)->cndx;
#line 523
    vndx = (basis->el + bpos)->vndx;
#line 524
    if (vndx < 0) {
#line 524
      vndx = sys->varcnt - vndx;
    }
    {
#line 525
    tmp___3 = consys_nme(sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 525
    tmp___4 = consys_nme(sys, (char )'c', cndx, (bool )0, (char *)((void *)0));
#line 525
    dyio_outfmt(chn, echo, "\n%5d\t(%4d) %-8s\t%12.4g\t(%4d) %-8s %12.7g", bpos, cndx,
                tmp___4, *(soln->y + bpos), vndx, tmp___3, *(soln->x + bpos));
#line 521
    bpos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 531
  nononbasic = (bool )1;
#line 532
  vndx = 1;
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 532
    if (! (vndx <= sys->varcnt)) {
#line 532
      goto while_break___0;
    }
#line 533
    if ((int )*(soln->status + vndx) > 0) {
#line 534
      if ((int )nononbasic == 1) {
        {
#line 535
        dyio_outfmt(chn, echo, "\n\nNonbasic Primal\n");
#line 536
        nononbasic = (bool )0;
        }
      }
      {
#line 539
      if (*(soln->status + vndx) == (flags )(1 << 5)) {
#line 539
        goto case_exp;
      }
#line 539
      if (*(soln->status + vndx) == (flags )(1 << 7)) {
#line 539
        goto case_exp;
      }
#line 543
      if (*(soln->status + vndx) == (flags )(1 << 6)) {
#line 543
        goto case_exp___1;
      }
#line 548
      if (*(soln->status + vndx) == (flags )(1 << 9)) {
#line 548
        goto case_exp___2;
      }
#line 548
      if (*(soln->status + vndx) == (flags )(1 << 8)) {
#line 548
        goto case_exp___2;
      }
#line 551
      goto switch_default___0;
      case_exp: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
#line 540
      val = *(sys->vlb + vndx);
#line 541
      if ((int )nbzeros == 0) {
#line 541
        if (val == (double )0) {
#line 541
          goto __Cont;
        }
      }
#line 542
      goto switch_break___0;
      case_exp___1: /* CIL Label */ 
#line 544
      val = *(sys->vub + vndx);
#line 545
      if ((int )nbzeros == 0) {
#line 545
        if (val == (double )0) {
#line 545
          goto __Cont;
        }
      }
#line 546
      goto switch_break___0;
      case_exp___2: /* CIL Label */ 
      case_exp___3: /* CIL Label */ 
#line 549
      val = (double )0;
#line 550
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 552
      val = QNaNbits___3.fpdbl;
#line 553
      errmsg(1, rtnnme, 553);
      }
#line 554
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 555
      tmp___5 = dy_prtvstat(*(soln->status + vndx));
#line 555
      tmp___6 = consys_nme(sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 555
      dyio_outfmt(chn, echo, "\n(%4d) %-8s %3s %12.7g", vndx, tmp___6, tmp___5, val);
      }
    }
    __Cont: /* CIL Label */ 
#line 532
    vndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 559
  if ((int )nononbasic == 1) {
    {
#line 560
    dyio_outfmt(chn, echo, "\n\nNo nonbasic architectural variables.\n");
    }
  } else {
    {
#line 562
    dyio_outchr(chn, echo, (char )'\n');
    }
  }
#line 564
  return ((bool )1);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib1.c"
static void *pointer  =    (void *)0;
#line 46 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib1.c"
void dy_glp_save_pointer(void *ptr ) 
{ 


  {
#line 47
  pointer = ptr;
#line 48
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib1.c"
void *dy_glp_read_pointer(void) 
{ 
  void *ptr ;

  {
#line 74
  ptr = pointer;
#line 75
  return (ptr);
}
}
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 379 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.h"
bool dyio_ioinit(void) ;
#line 79
void dyio_ioterm(void) ;
#line 81
ioid dyio_openfile(char const   *path , char const   *mode ) ;
#line 82
bool dyio_isactive(ioid id ) ;
#line 83
bool dyio_closefile(ioid id ) ;
#line 84
bool dyio_setmode(ioid id , char mode ) ;
#line 84
bool dyio_ttyq(ioid id ) ;
#line 86
bool dyio_chgerrlog(char const   *newerrpath , bool echo ) ;
#line 88
char const   *dyio_idtopath(ioid id ) ;
#line 89
ioid dyio_pathtoid(char const   *path , char const   *mode ) ;
#line 94
bool dyio_scan(ioid id , char const   *pattern , bool rwnd , bool wrap ) ;
#line 99
void dyio_flushio(ioid id , bool echo ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static filblk_struct *filblks  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static ioid maxfiles  ;
#line 158 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static chartab_struct chartab_eof  =    {(chrclass )6, (chrclass )6, (char )'\377'};
#line 158 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static chartab_struct chartab_err  =    {(chrclass )7, (chrclass )7, (char )'\377'};
#line 158 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static chartab_struct chartab_nl  =    {(chrclass )3, (chrclass )3, (char )'\n'};
#line 163 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static chartab_struct chartab[128]  = 
#line 163
  {      {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )0, (chrclass )0, (char )'\t'}, 
        {(chrclass )0, (chrclass )0, (char )'\n'}, 
        {(chrclass )0, (chrclass )0, (char )'\v'}, 
        {(chrclass )0, (chrclass )0, (char )'\f'}, 
        {(chrclass )0, (chrclass )0, (char )'\r'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )4, (chrclass )4, (char )'\000'}, 
        {(chrclass )0, (chrclass )0, (char )' '}, 
        {(chrclass )3, (chrclass )3, (char )'!'}, 
        {(chrclass )3, (chrclass )3, (char )'\"'}, 
        {(chrclass )1, (chrclass )1, (char )'#'}, 
        {(chrclass )3, (chrclass )3, (char )'$'}, 
        {(chrclass )3, (chrclass )5, (char )'%'}, 
        {(chrclass )3, (chrclass )3, (char )'&'}, 
        {(chrclass )1, (chrclass )1, (char )'\''}, 
        {(chrclass )3, (chrclass )3, (char )'('}, 
        {(chrclass )3, (chrclass )3, (char )')'}, 
        {(chrclass )3, (chrclass )3, (char )'*'}, 
        {(chrclass )1, (chrclass )1, (char )'+'}, 
        {(chrclass )3, (chrclass )3, (char )','}, 
        {(chrclass )1, (chrclass )1, (char )'-'}, 
        {(chrclass )1, (chrclass )5, (char )'.'}, 
        {(chrclass )3, (chrclass )3, (char )'/'}, 
        {(chrclass )1, (chrclass )5, (char )'0'}, 
        {(chrclass )1, (chrclass )5, (char )'1'}, 
        {(chrclass )1, (chrclass )5, (char )'2'}, 
        {(chrclass )1, (chrclass )5, (char )'3'}, 
        {(chrclass )1, (chrclass )5, (char )'4'}, 
        {(chrclass )1, (chrclass )5, (char )'5'}, 
        {(chrclass )1, (chrclass )5, (char )'6'}, 
        {(chrclass )1, (chrclass )5, (char )'7'}, 
        {(chrclass )1, (chrclass )5, (char )'8'}, 
        {(chrclass )1, (chrclass )5, (char )'9'}, 
        {(chrclass )3, (chrclass )3, (char )':'}, 
        {(chrclass )3, (chrclass )3, (char )';'}, 
        {(chrclass )3, (chrclass )3, (char )'<'}, 
        {(chrclass )3, (chrclass )3, (char )'='}, 
        {(chrclass )3, (chrclass )3, (char )'>'}, 
        {(chrclass )3, (chrclass )3, (char )'?'}, 
        {(chrclass )3, (chrclass )3, (char )'@'}, 
        {(chrclass )2, (chrclass )5, (char )'A'}, 
        {(chrclass )2, (chrclass )5, (char )'B'}, 
        {(chrclass )2, (chrclass )5, (char )'C'}, 
        {(chrclass )2, (chrclass )5, (char )'D'}, 
        {(chrclass )2, (chrclass )5, (char )'E'}, 
        {(chrclass )2, (chrclass )5, (char )'F'}, 
        {(chrclass )2, (chrclass )5, (char )'G'}, 
        {(chrclass )2, (chrclass )5, (char )'H'}, 
        {(chrclass )2, (chrclass )5, (char )'I'}, 
        {(chrclass )2, (chrclass )5, (char )'J'}, 
        {(chrclass )2, (chrclass )5, (char )'K'}, 
        {(chrclass )2, (chrclass )5, (char )'L'}, 
        {(chrclass )2, (chrclass )5, (char )'M'}, 
        {(chrclass )2, (chrclass )5, (char )'N'}, 
        {(chrclass )2, (chrclass )5, (char )'O'}, 
        {(chrclass )2, (chrclass )5, (char )'P'}, 
        {(chrclass )2, (chrclass )5, (char )'Q'}, 
        {(chrclass )2, (chrclass )5, (char )'R'}, 
        {(chrclass )2, (chrclass )5, (char )'S'}, 
        {(chrclass )2, (chrclass )5, (char )'T'}, 
        {(chrclass )2, (chrclass )5, (char )'U'}, 
        {(chrclass )2, (chrclass )5, (char )'V'}, 
        {(chrclass )2, (chrclass )5, (char )'W'}, 
        {(chrclass )2, (chrclass )5, (char )'X'}, 
        {(chrclass )2, (chrclass )5, (char )'Y'}, 
        {(chrclass )2, (chrclass )5, (char )'Z'}, 
        {(chrclass )3, (chrclass )3, (char )'['}, 
        {(chrclass )3, (chrclass )3, (char )'\\'}, 
        {(chrclass )3, (chrclass )3, (char )']'}, 
        {(chrclass )3, (chrclass )3, (char )'^'}, 
        {(chrclass )3, (chrclass )5, (char )'_'}, 
        {(chrclass )3, (chrclass )3, (char )'`'}, 
        {(chrclass )2, (chrclass )5, (char )'a'}, 
        {(chrclass )2, (chrclass )5, (char )'b'}, 
        {(chrclass )2, (chrclass )5, (char )'c'}, 
        {(chrclass )2, (chrclass )5, (char )'d'}, 
        {(chrclass )2, (chrclass )5, (char )'e'}, 
        {(chrclass )2, (chrclass )5, (char )'f'}, 
        {(chrclass )2, (chrclass )5, (char )'g'}, 
        {(chrclass )2, (chrclass )5, (char )'h'}, 
        {(chrclass )2, (chrclass )5, (char )'i'}, 
        {(chrclass )2, (chrclass )5, (char )'j'}, 
        {(chrclass )2, (chrclass )5, (char )'k'}, 
        {(chrclass )2, (chrclass )5, (char )'l'}, 
        {(chrclass )2, (chrclass )5, (char )'m'}, 
        {(chrclass )2, (chrclass )5, (char )'n'}, 
        {(chrclass )2, (chrclass )5, (char )'o'}, 
        {(chrclass )2, (chrclass )5, (char )'p'}, 
        {(chrclass )2, (chrclass )5, (char )'q'}, 
        {(chrclass )2, (chrclass )5, (char )'r'}, 
        {(chrclass )2, (chrclass )5, (char )'s'}, 
        {(chrclass )2, (chrclass )5, (char )'t'}, 
        {(chrclass )2, (chrclass )5, (char )'u'}, 
        {(chrclass )2, (chrclass )5, (char )'v'}, 
        {(chrclass )2, (chrclass )5, (char )'w'}, 
        {(chrclass )2, (chrclass )5, (char )'x'}, 
        {(chrclass )2, (chrclass )5, (char )'y'}, 
        {(chrclass )2, (chrclass )5, (char )'z'}, 
        {(chrclass )3, (chrclass )3, (char )'{'}, 
        {(chrclass )3, (chrclass )3, (char )'|'}, 
        {(chrclass )3, (chrclass )3, (char )'}'}, 
        {(chrclass )4, (chrclass )4, (char )'~'}, 
        {(chrclass )4, (chrclass )4, (char )'\177'}};
#line 298 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static lex_struct lex_eof  =    {(lexclass )6, (char *)"end-of-file"};
#line 298 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static lex_struct lex_err  =    {(lexclass )7, (char *)"lexical scan error"};
#line 298 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static lex_struct lex_nil___0  =    {(lexclass )0, (char *)((void *)0)};
#line 304 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_ioinit(void) 
{ 
  int len ;
  filblk_struct *filblk ;
  char *fname ;
  char *errlogpath ;
  char *tmp ;
  char const   *rtnnme ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 330
  rtnnme = "dyio_ioinit";
#line 339
  maxfiles = 14;
#line 340
  tmp___0 = calloc((size_t )(maxfiles + 1), sizeof(filblk_struct ));
#line 340
  filblks = (filblk_struct *)tmp___0;
#line 341
  filblk = filblks + 1;
#line 342
  filblk->stream = stdin;
#line 343
  filblk->dname = (char *)((void *)0);
#line 344
  filblk->fname = (char *)"stdin";
#line 345
  filblk->modes |= (unsigned int )((1 | (1 << 2)) | (1 << 3));
#line 346
  filblk->refcnt = 1;
#line 348
  filblk = filblks + 2;
#line 349
  filblk->stream = stdout;
#line 350
  filblk->dname = (char *)((void *)0);
#line 351
  filblk->fname = (char *)"stdout";
#line 352
  filblk->modes |= (unsigned int )((1 | (1 << 2)) | (1 << 4));
#line 353
  filblk->refcnt = 1;
#line 355
  filblk = filblks + 3;
#line 356
  filblk->stream = stderr;
#line 357
  filblk->dname = (char *)((void *)0);
#line 358
  filblk->fname = (char *)"stderr";
#line 359
  filblk->modes |= (unsigned int )((1 | (1 << 2)) | (1 << 4));
#line 360
  filblk->refcnt = 1;
#line 364
  filblk = filblks + 4;
#line 365
  filblk->stream = errlogq(& errlogpath);
  }
#line 366
  if ((unsigned long )filblk->stream != (unsigned long )((void *)0)) {
#line 367
    if ((unsigned long )errlogpath == (unsigned long )((void *)0)) {
      {
#line 368
      errmsg(14, rtnnme);
#line 369
      errmsg(1, rtnnme, 369);
      }
#line 370
      return ((bool )0);
    }
    {
#line 371
    fname = strrchr((char const   *)errlogpath, '/');
    }
#line 372
    if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 373
      filblk->dname = (char *)((void *)0);
#line 374
      fname = errlogpath;
    } else {
      {
#line 376
      len = (int )(fname - errlogpath);
#line 377
      tmp___1 = malloc((size_t )(len + 1));
#line 377
      tmp = (char *)tmp___1;
#line 378
      strncpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)errlogpath,
              (size_t )len);
#line 379
      *(tmp + len) = (char )'\000';
#line 380
      filblk->dname = tmp;
#line 381
      fname ++;
      }
    }
    {
#line 382
    tmp___2 = strlen((char const   *)fname);
#line 382
    tmp___3 = malloc(tmp___2 + 1UL);
#line 382
    tmp = (char *)tmp___3;
#line 383
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)fname);
#line 384
    filblk->fname = tmp;
#line 385
    filblk->modes |= (unsigned int )(1 | (1 << 4));
#line 386
    filblk->refcnt = 1;
    }
  }
#line 388
  return ((bool )1);
}
}
#line 391 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
void dyio_ioterm(void) 
{ 
  int id ;

  {
#line 407
  id = 4;
  {
#line 407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 407
    if (! (id <= maxfiles)) {
#line 407
      goto while_break;
    }
#line 408
    if ((unsigned long )(filblks + id)->dname != (unsigned long )((void *)0)) {
      {
#line 408
      free((void *)(filblks + id)->dname);
      }
    }
#line 409
    if ((unsigned long )(filblks + id)->fname != (unsigned long )((void *)0)) {
      {
#line 409
      free((void *)(filblks + id)->fname);
      }
    }
#line 407
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  free((void *)filblks);
  }
#line 412
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static bool rwmodecmp(filblk_struct *filblk , char const   *mode ) 
{ 
  char const   *rtnnme ;
  flags modes ;
  bool rw ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 430
  rtnnme = "rwmodecmp";
#line 434
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
    {
#line 435
    errmsg(2, rtnnme, "r/w mode");
    }
#line 436
    return ((bool )0);
  }
#line 437
  if ((unsigned long )filblk == (unsigned long )((void *)0)) {
    {
#line 438
    errmsg(2, rtnnme, "filblk");
    }
#line 439
    return ((bool )0);
  }
#line 440
  modes = filblk->modes;
#line 442
  if ((int const   )*(mode + 1) == 43) {
#line 442
    rw = (bool )1;
  } else {
#line 442
    rw = (bool )0;
  }
  {
#line 444
  if ((int const   )*(mode + 0) == 114) {
#line 444
    goto case_114;
  }
#line 449
  if ((int const   )*(mode + 0) == 119) {
#line 449
    goto case_119;
  }
#line 449
  if ((int const   )*(mode + 0) == 97) {
#line 449
    goto case_119;
  }
#line 453
  goto switch_default;
  case_114: /* CIL Label */ 
#line 445
  if (modes & (unsigned int )(1 << 3)) {
#line 445
    tmp = 0;
  } else {
#line 445
    tmp = 1;
  }
#line 445
  if (tmp == 1) {
#line 445
    return ((bool )0);
  }
#line 446
  if ((int )rw == 1) {
#line 446
    if (modes & (unsigned int )(1 << 4)) {
#line 446
      tmp___0 = 0;
    } else {
#line 446
      tmp___0 = 1;
    }
#line 446
    if (tmp___0 == 1) {
#line 446
      return ((bool )0);
    }
  }
#line 447
  return ((bool )1);
  case_119: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 450
  if (modes & (unsigned int )(1 << 4)) {
#line 450
    tmp___1 = 0;
  } else {
#line 450
    tmp___1 = 1;
  }
#line 450
  if (tmp___1 == 1) {
#line 450
    return ((bool )0);
  }
#line 451
  if ((int )rw == 1) {
#line 451
    if (modes & (unsigned int )(1 << 3)) {
#line 451
      tmp___2 = 0;
    } else {
#line 451
      tmp___2 = 1;
    }
#line 451
    if (tmp___2 == 1) {
#line 451
      return ((bool )0);
    }
  }
#line 452
  return ((bool )1);
  switch_default: /* CIL Label */ 
  {
#line 454
  errmsg(4, rtnnme, "r/w mode", mode);
  }
#line 455
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static bool setrwmode(filblk_struct *filblk , char *mode ) 
{ 
  char const   *rtnnme ;
  bool rw ;

  {
#line 471
  rtnnme = "setrwmode";
#line 474
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
    {
#line 475
    errmsg(2, rtnnme, "r/w mode");
    }
#line 476
    return ((bool )0);
  }
#line 477
  if ((unsigned long )filblk == (unsigned long )((void *)0)) {
    {
#line 478
    errmsg(2, rtnnme, "filblk");
    }
#line 479
    return ((bool )0);
  }
#line 481
  if ((int )*(mode + 1) == 43) {
#line 481
    rw = (bool )1;
  } else {
#line 481
    rw = (bool )0;
  }
  {
#line 483
  if ((int )*(mode + 0) == 114) {
#line 483
    goto case_114;
  }
#line 490
  if ((int )*(mode + 0) == 119) {
#line 490
    goto case_119;
  }
#line 490
  if ((int )*(mode + 0) == 97) {
#line 490
    goto case_119;
  }
#line 496
  goto switch_default;
  case_114: /* CIL Label */ 
#line 484
  if ((int )rw == 1) {
#line 485
    filblk->modes |= (unsigned int )((1 << 3) | (1 << 4));
  } else {
#line 487
    filblk->modes |= (unsigned int )(1 << 3);
  }
#line 488
  return ((bool )1);
  case_119: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 491
  if ((int )rw == 1) {
#line 492
    filblk->modes |= (unsigned int )((1 << 3) | (1 << 4));
  } else {
#line 494
    filblk->modes |= (unsigned int )(1 << 4);
  }
#line 495
  return ((bool )1);
  switch_default: /* CIL Label */ 
  {
#line 497
  errmsg(4, rtnnme, "r/w mode", mode);
  }
#line 498
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_setmode(ioid id , char mode ) 
{ 
  filblk_struct *filblk ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 516
  rtnnme = "dyio_setmode";
#line 520
  if (id < 1) {
    {
#line 521
    errmsg(5, rtnnme, "stream id", id);
    }
#line 522
    return ((bool )0);
  } else
#line 520
  if (maxfiles < id) {
    {
#line 521
    errmsg(5, rtnnme, "stream id", id);
    }
#line 522
    return ((bool )0);
  }
#line 523
  filblk = filblks + id;
#line 524
  if (filblk->modes & 1U) {
#line 524
    tmp = 1;
  } else {
#line 524
    tmp = 0;
  }
#line 524
  if (tmp == 0) {
    {
#line 525
    errmsg(15, rtnnme, id);
    }
#line 526
    return ((bool )0);
  }
#line 527
  if (filblk->modes & (unsigned int )(1 << 3)) {
#line 527
    tmp___1 = 1;
  } else {
#line 527
    tmp___1 = 0;
  }
#line 527
  if (tmp___1 == 0) {
    {
#line 528
    tmp___0 = dyio_idtopath(id);
#line 528
    errmsg(16, rtnnme, tmp___0);
    }
#line 529
    return ((bool )0);
  }
  {
#line 535
  if ((int )mode == 76) {
#line 535
    goto case_76;
  }
#line 535
  if ((int )mode == 108) {
#line 535
    goto case_76;
  }
#line 540
  if ((int )mode == 70) {
#line 540
    goto case_70;
  }
#line 540
  if ((int )mode == 102) {
#line 540
    goto case_70;
  }
#line 544
  goto switch_default;
  case_76: /* CIL Label */ 
  case_108: /* CIL Label */ 
#line 536
  filblk->modes &= (unsigned int )(~ (1 << 2));
#line 537
  filblk->modes |= (unsigned int )(1 << 1);
#line 538
  goto switch_break;
  case_70: /* CIL Label */ 
  case_102: /* CIL Label */ 
#line 541
  filblk->modes &= (unsigned int )(~ (1 << 1));
#line 542
  filblk->modes |= (unsigned int )(1 << 2);
#line 543
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 545
  errmsg(3, rtnnme, "scanning mode", (int )mode);
  }
#line 546
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 548
  return ((bool )1);
}
}
#line 564 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static char fullpath[4096]  ;
#line 565 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static char const   *badid  =    "!invalid id!";
#line 552 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
char const   *dyio_idtopath(ioid id ) 
{ 
  filblk_struct *filblk ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 567
  rtnnme = "dyio_idtopath";
#line 571
  if (id < 1) {
    {
#line 572
    errmsg(5, rtnnme, "stream id", id);
    }
#line 573
    return (badid);
  } else
#line 571
  if (maxfiles < id) {
    {
#line 572
    errmsg(5, rtnnme, "stream id", id);
    }
#line 573
    return (badid);
  }
#line 574
  filblk = filblks + id;
#line 575
  if (filblk->modes & 1U) {
#line 575
    tmp = 1;
  } else {
#line 575
    tmp = 0;
  }
#line 575
  if (tmp == 0) {
    {
#line 576
    errmsg(15, rtnnme, id);
    }
#line 577
    return (badid);
  }
#line 581
  fullpath[0] = (char )'\000';
#line 582
  if ((unsigned long )filblk->dname != (unsigned long )((void *)0)) {
    {
#line 583
    strcat((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)filblk->dname);
#line 584
    strcat((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)"/");
    }
  }
  {
#line 585
  strcat((char */* __restrict  */)(fullpath), (char const   */* __restrict  */)filblk->fname);
  }
#line 587
  return ((char const   *)(fullpath));
}
}
#line 591 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
ioid dyio_pathtoid(char const   *path , char const   *mode ) 
{ 
  char const   *fname ;
  int ndx ;
  int dlen ;
  filblk_struct *filblk ;
  char const   *rtnnme ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;

  {
#line 609
  rtnnme = "dyio_pathtoid";
#line 611
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 612
    errmsg(2, rtnnme, "path");
    }
#line 613
    return (-1);
  }
  {
#line 615
  tmp = strrchr(path, '/');
#line 615
  fname = (char const   *)tmp;
  }
#line 616
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 617
    dlen = 0;
#line 618
    fname = path;
  } else {
#line 620
    dlen = (int )(fname - path);
#line 621
    fname ++;
  }
#line 623
  ndx = 1;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (ndx <= maxfiles)) {
#line 623
      goto while_break;
    }
#line 624
    filblk = filblks + ndx;
#line 625
    if (filblk->modes & 1U) {
#line 625
      tmp___0 = 0;
    } else {
#line 625
      tmp___0 = 1;
    }
#line 625
    if (tmp___0 == 1) {
#line 625
      goto __Cont;
    }
    {
#line 626
    tmp___1 = strcmp((char const   *)filblk->fname, fname);
    }
#line 626
    if (tmp___1 != 0) {
#line 626
      goto __Cont;
    }
#line 627
    if ((unsigned long )filblk->dname == (unsigned long )((void *)0)) {
#line 628
      if (dlen != 0) {
#line 628
        goto __Cont;
      }
    } else {
      {
#line 630
      tmp___2 = strncmp((char const   *)filblk->dname, path, (size_t )dlen);
      }
#line 630
      if (tmp___2 != 0) {
#line 630
        goto __Cont;
      }
    }
#line 631
    if ((unsigned long )mode != (unsigned long )((void *)0)) {
      {
#line 631
      tmp___3 = rwmodecmp(filblk, mode);
      }
#line 631
      if ((int )tmp___3 == 0) {
#line 631
        goto __Cont;
      }
    }
#line 632
    return (ndx);
    __Cont: /* CIL Label */ 
#line 623
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 634
  return (-1);
}
}
#line 658
extern int isatty(int fildes ) ;
#line 639 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_ttyq(ioid id ) 
{ 
  filblk_struct *filblk ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 656
  rtnnme = "dyio_ttyq";
#line 664
  if (id < 1) {
    {
#line 665
    errmsg(5, rtnnme, "stream id", id);
    }
#line 666
    return ((bool )0);
  } else
#line 664
  if (maxfiles < id) {
    {
#line 665
    errmsg(5, rtnnme, "stream id", id);
    }
#line 666
    return ((bool )0);
  }
#line 667
  filblk = filblks + id;
#line 668
  if (filblk->modes & 1U) {
#line 668
    tmp = 1;
  } else {
#line 668
    tmp = 0;
  }
#line 668
  if (tmp == 0) {
    {
#line 669
    errmsg(15, rtnnme, id);
    }
#line 670
    return ((bool )0);
  }
  {
#line 674
  tmp___0 = fileno(filblk->stream);
#line 674
  tmp___1 = isatty(tmp___0);
  }
#line 674
  if (tmp___1 == 1) {
#line 675
    return ((bool )1);
  } else {
#line 677
    return ((bool )0);
  }
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
ioid dyio_openfile(char const   *path , char const   *mode ) 
{ 
  FILE *handle ;
  filblk_struct *filblk ;
  char const   *fname ;
  char *tmp ;
  char mode_var[3] ;
  int len ;
  ioid id ;
  bool mustexist ;
  bool totop ;
  char const   *rtnnme ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 718
  rtnnme = "dyio_openfile";
#line 722
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 723
    errmsg(2, rtnnme, "path");
    }
#line 724
    return (-1);
  }
#line 725
  if ((unsigned long )mode == (unsigned long )((void *)0)) {
    {
#line 726
    errmsg(2, rtnnme, "r/w mode");
    }
#line 727
    return (-1);
  }
#line 731
  mode_var[0] = (char )*(mode + 0);
#line 732
  mode_var[1] = (char )*(mode + 1);
#line 733
  mode_var[2] = (char )'\000';
#line 739
  mustexist = (bool )0;
#line 740
  totop = (bool )0;
  {
#line 742
  if ((int )mode_var[0] == 82) {
#line 742
    goto case_82;
  }
#line 747
  if ((int )mode_var[0] == 81) {
#line 747
    goto case_81;
  }
#line 751
  if ((int )mode_var[0] == 87) {
#line 751
    goto case_87;
  }
#line 755
  if ((int )mode_var[0] == 65) {
#line 755
    goto case_65;
  }
#line 758
  if ((int )mode_var[0] == 114) {
#line 758
    goto case_114;
  }
#line 761
  if ((int )mode_var[0] == 113) {
#line 761
    goto case_113;
  }
#line 765
  if ((int )mode_var[0] == 97) {
#line 765
    goto case_97;
  }
#line 765
  if ((int )mode_var[0] == 119) {
#line 765
    goto case_97;
  }
#line 767
  goto switch_default;
  case_82: /* CIL Label */ 
#line 743
  mode_var[0] = (char )'r';
#line 744
  totop = (bool )1;
#line 745
  mustexist = (bool )1;
#line 746
  goto switch_break;
  case_81: /* CIL Label */ 
#line 748
  mode_var[0] = (char )'r';
#line 749
  totop = (bool )1;
#line 750
  goto switch_break;
  case_87: /* CIL Label */ 
#line 752
  mode_var[0] = (char )'w';
#line 753
  totop = (bool )1;
#line 754
  goto switch_break;
  case_65: /* CIL Label */ 
#line 756
  mode_var[0] = (char )'a';
#line 757
  goto switch_break;
  case_114: /* CIL Label */ 
#line 759
  mustexist = (bool )1;
#line 760
  goto switch_break;
  case_113: /* CIL Label */ 
#line 762
  mode_var[0] = (char )'r';
#line 763
  goto switch_break;
  case_97: /* CIL Label */ 
  case_119: /* CIL Label */ 
#line 766
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 768
  errmsg(4, rtnnme, "r/w mode", mode);
  }
#line 769
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 778
  id = dyio_pathtoid(path, (char const   *)(mode_var));
  }
#line 779
  if (id != -1) {
#line 780
    if ((int )totop == 1) {
      {
#line 782
      if ((int )mode_var[0] == 114) {
#line 782
        goto case_114___0;
      }
#line 785
      if ((int )mode_var[0] == 119) {
#line 785
        goto case_119___0;
      }
#line 793
      if ((int )mode_var[0] == 97) {
#line 793
        goto case_97___0;
      }
#line 781
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
      {
#line 783
      rewind((filblks + id)->stream);
      }
#line 784
      goto switch_break___0;
      case_119___0: /* CIL Label */ 
      {
#line 786
      fclose((filblks + id)->stream);
#line 787
      (filblks + id)->stream = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)(mode_var));
      }
#line 788
      if ((unsigned long )(filblks + id)->stream == (unsigned long )((void *)0)) {
        {
#line 789
        tmp___0 = dyio_idtopath(id);
#line 789
        errmsg(10, rtnnme, tmp___0, mode_var);
#line 790
        perror(rtnnme);
        }
#line 791
        return (-1);
      }
#line 792
      goto switch_break___0;
      case_97___0: /* CIL Label */ 
      {
#line 794
      errmsg(1, rtnnme, 794);
      }
#line 795
      return (-1);
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 796
    ((filblks + id)->refcnt) ++;
#line 797
    return (id);
  }
#line 801
  id = 1;
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (id <= maxfiles) {
#line 801
      if ((filblks + id)->modes & 1U) {
#line 801
        tmp___1 = 1;
      } else {
#line 801
        tmp___1 = 0;
      }
#line 801
      if (! (tmp___1 == 1)) {
#line 801
        goto while_break;
      }
    } else {
#line 801
      goto while_break;
    }
#line 801
    id ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 804
  if (id > maxfiles) {
    {
#line 805
    errmsg(13, rtnnme);
    }
#line 806
    return (-1);
  }
  {
#line 807
  filblk = filblks + id;
#line 811
  handle = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)(mode_var));
  }
#line 812
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 813
    if ((int )mode_var[0] == 114) {
#line 813
      if ((int )mustexist == 0) {
#line 814
        return (0);
      } else {
        {
#line 816
        errmsg(10, rtnnme, path, mode_var);
#line 817
        perror(rtnnme);
        }
#line 818
        return (-1);
      }
    } else {
      {
#line 816
      errmsg(10, rtnnme, path, mode_var);
#line 817
      perror(rtnnme);
      }
#line 818
      return (-1);
    }
  }
  {
#line 822
  filblk->stream = handle;
#line 823
  setrwmode(filblk, mode_var);
#line 824
  tmp___2 = strrchr(path, '/');
#line 824
  fname = (char const   *)tmp___2;
  }
#line 825
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 826
    filblk->dname = (char *)((void *)0);
#line 827
    fname = path;
  } else {
    {
#line 829
    fname ++;
#line 830
    len = (int )(fname - path);
#line 831
    tmp___3 = malloc((size_t )(len + 1));
#line 831
    tmp = (char *)tmp___3;
#line 832
    strncpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)path, (size_t )len);
#line 833
    *(tmp + len) = (char )'\000';
#line 834
    filblk->dname = tmp;
    }
  }
  {
#line 835
  tmp___4 = strlen(fname);
#line 835
  tmp___5 = malloc(tmp___4 + 1UL);
#line 835
  tmp = (char *)tmp___5;
#line 836
  strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)fname);
#line 837
  filblk->fname = tmp;
#line 838
  filblk->modes |= (unsigned int )(1 | (1 << 2));
#line 839
  filblk->refcnt = 1;
  }
#line 841
  return (id);
}
}
#line 845 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_isactive(ioid id ) 
{ 
  char const   *rtnnme ;
  int tmp ;

  {
#line 856
  rtnnme = "dyio_isactive";
#line 860
  if (id < 0) {
    {
#line 861
    errmsg(5, rtnnme, "stream id", id);
    }
#line 862
    return ((bool )0);
  } else
#line 860
  if (maxfiles < id) {
    {
#line 861
    errmsg(5, rtnnme, "stream id", id);
    }
#line 862
    return ((bool )0);
  }
#line 864
  if (id == 0) {
#line 864
    return ((bool )0);
  }
#line 866
  if ((filblks + id)->modes & 1U) {
#line 866
    tmp = 1;
  } else {
#line 866
    tmp = 0;
  }
#line 866
  return ((bool )tmp);
}
}
#line 870 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_closefile(ioid id ) 
{ 
  filblk_struct *filblk ;
  bool retval ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 884
  rtnnme = "dyio_closefile";
#line 888
  if (id < 1) {
    {
#line 889
    errmsg(5, rtnnme, "stream id", id);
    }
#line 890
    return ((bool )0);
  } else
#line 888
  if (maxfiles < id) {
    {
#line 889
    errmsg(5, rtnnme, "stream id", id);
    }
#line 890
    return ((bool )0);
  }
#line 891
  filblk = filblks + id;
#line 892
  if (filblk->modes & 1U) {
#line 892
    tmp = 1;
  } else {
#line 892
    tmp = 0;
  }
#line 892
  if (tmp == 0) {
    {
#line 893
    errmsg(15, rtnnme, id);
    }
#line 894
    return ((bool )0);
  }
#line 899
  (filblk->refcnt) --;
#line 899
  if (filblk->refcnt > 0) {
#line 899
    return ((bool )1);
  }
  {
#line 903
  tmp___1 = fclose(filblk->stream);
  }
#line 903
  if (tmp___1 == -1) {
    {
#line 904
    tmp___0 = dyio_idtopath(id);
#line 904
    errmsg(11, rtnnme, tmp___0);
#line 905
    perror(rtnnme);
#line 906
    retval = (bool )0;
    }
  } else {
#line 908
    retval = (bool )1;
  }
#line 914
  filblk->modes &= 4294967294U;
#line 915
  if (id > 3) {
#line 916
    if ((unsigned long )filblk->dname != (unsigned long )((void *)0)) {
      {
#line 917
      free((void *)filblk->dname);
#line 918
      filblk->dname = (char *)((void *)0);
      }
    }
    {
#line 919
    free((void *)filblk->fname);
#line 920
    filblk->fname = (char *)((void *)0);
    }
  }
#line 922
  return (retval);
}
}
#line 926 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_chgerrlog(char const   *newerrpath , bool echo ) 
{ 
  ioid olderrid ;
  ioid newerrid ;
  bool close ;
  char *olderrpath ;
  FILE *newerrchn ;
  char const   *rtnnme ;
  bool tmp ;

  {
#line 952
  rtnnme = "dyio_chgerrlog";
#line 961
  if ((unsigned long )newerrpath == (unsigned long )((void *)0)) {
    {
#line 962
    reseterrlogchn((char const   *)((void *)0), (FILE *)((void *)0), echo, (bool )0);
    }
#line 963
    return ((bool )1);
  }
  {
#line 970
  errlogq(& olderrpath);
  }
#line 971
  if ((unsigned long )olderrpath == (unsigned long )((void *)0)) {
#line 972
    close = (bool )0;
#line 973
    olderrid = -1;
  } else {
    {
#line 975
    olderrid = dyio_pathtoid((char const   *)olderrpath, (char const   *)((void *)0));
    }
#line 976
    if (olderrid == -1) {
#line 977
      close = (bool )1;
    } else {
#line 979
      close = (bool )0;
    }
  }
  {
#line 983
  newerrid = dyio_pathtoid(newerrpath, "w");
  }
#line 984
  if (newerrid == -1) {
    {
#line 985
    newerrid = dyio_openfile(newerrpath, "w");
    }
#line 986
    if (newerrid == -1) {
      {
#line 987
      errmsg(10, rtnnme, newerrpath, "w");
      }
#line 988
      return ((bool )0);
    }
  }
  {
#line 989
  newerrchn = (filblks + newerrid)->stream;
#line 994
  tmp = reseterrlogchn(newerrpath, newerrchn, echo, close);
  }
#line 994
  if ((int )tmp == 0) {
    {
#line 995
    errmsg(18, rtnnme, olderrpath, newerrpath);
    }
#line 996
    return ((bool )0);
  }
#line 1000
  if (olderrid != -1) {
    {
#line 1000
    dyio_closefile(olderrid);
    }
  }
#line 1002
  return ((bool )1);
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
long dyio_mark(ioid id ) 
{ 
  filblk_struct *filblk ;
  long here ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 1021
  rtnnme = "dyio_mark";
#line 1025
  if (id < 1) {
    {
#line 1026
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1027
    return (-1L);
  } else
#line 1025
  if (maxfiles < id) {
    {
#line 1026
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1027
    return (-1L);
  }
#line 1028
  filblk = filblks + id;
#line 1029
  if (filblk->modes & 1U) {
#line 1029
    tmp = 1;
  } else {
#line 1029
    tmp = 0;
  }
#line 1029
  if (tmp == 0) {
    {
#line 1030
    errmsg(15, rtnnme, id);
    }
#line 1031
    return (-1L);
  }
  {
#line 1035
  here = ftell(filblk->stream);
  }
#line 1036
  if (here < 0L) {
    {
#line 1037
    tmp___0 = dyio_idtopath(id);
#line 1037
    errmsg(23, rtnnme, tmp___0);
#line 1038
    perror(rtnnme);
    }
  }
#line 1040
  return (here);
}
}
#line 1044 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_backup(ioid id , long there ) 
{ 
  filblk_struct *filblk ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1058
  rtnnme = "dyio_backup";
#line 1062
  if (id < 1) {
    {
#line 1063
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1064
    return ((bool )0);
  } else
#line 1062
  if (maxfiles < id) {
    {
#line 1063
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1064
    return ((bool )0);
  }
#line 1065
  filblk = filblks + id;
#line 1066
  if (filblk->modes & 1U) {
#line 1066
    tmp = 1;
  } else {
#line 1066
    tmp = 0;
  }
#line 1066
  if (tmp == 0) {
    {
#line 1067
    errmsg(15, rtnnme, id);
    }
#line 1068
    return ((bool )0);
  }
  {
#line 1072
  tmp___1 = fseek(filblk->stream, there, 0);
  }
#line 1072
  if (tmp___1 < 0) {
    {
#line 1073
    tmp___0 = dyio_idtopath(id);
#line 1073
    errmsg(24, rtnnme, tmp___0, there);
#line 1074
    perror(rtnnme);
    }
#line 1075
    return ((bool )0);
  }
#line 1077
  return ((bool )1);
}
}
#line 1081 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static chartab_struct *nxtchar(FILE *stream , flags modes ) 
{ 
  char const   *rtnnme ;
  int nxt ;
  int id ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1095
  rtnnme = "nxtchar";
#line 1100
  nxt = _IO_getc(stream);
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (nxt != -1) {
#line 1100
      if (! ((unsigned int )chartab[nxt].class1 == 4U)) {
#line 1100
        goto while_break;
      }
    } else {
#line 1100
      goto while_break;
    }
    {
#line 1100
    nxt = _IO_getc(stream);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1106
  if (nxt == -1) {
    {
#line 1107
    tmp___0 = ferror(stream);
    }
#line 1107
    if (tmp___0 != 0) {
#line 1108
      id = 1;
      {
#line 1108
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1108
        if (id <= maxfiles) {
#line 1108
          if (! ((unsigned long )(filblks + id)->stream != (unsigned long )stream)) {
#line 1108
            goto while_break___0;
          }
        } else {
#line 1108
          goto while_break___0;
        }
#line 1108
        id ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1109
      if (id <= maxfiles) {
        {
#line 1110
        tmp = dyio_idtopath(id);
#line 1110
        errmsg(12, rtnnme, tmp);
        }
      } else {
        {
#line 1112
        errmsg(12, rtnnme, "unknown");
#line 1113
        errmsg(1, rtnnme, 1113);
        }
      }
      {
#line 1114
      perror(rtnnme);
      }
#line 1115
      return (& chartab_err);
    } else {
#line 1117
      return (& chartab_eof);
    }
  }
#line 1119
  if (nxt == 10) {
#line 1119
    if (modes & (unsigned int )(1 << 1)) {
#line 1119
      tmp___1 = 1;
    } else {
#line 1119
      tmp___1 = 0;
    }
#line 1119
    if (tmp___1 == 1) {
#line 1120
      return (& chartab_nl);
    } else {
#line 1122
      return (& chartab[nxt]);
    }
  } else {
#line 1122
    return (& chartab[nxt]);
  }
}
}
#line 1160 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static struct state_struct states[30]  ;
#line 1127 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
bool dyio_scan(ioid id , char const   *pattern , bool rwnd , bool wrap ) 
{ 
  struct state_struct *state ;
  int patlen ;
  int patndx ;
  int statendx ;
  char const   *patptr ;
  bool retry ;
  chartab_struct *chr ;
  filblk_struct *filblk ;
  FILE *stream ;
  flags mode ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 1170
  rtnnme = "dyio_scan";
#line 1174
  if (id < 1) {
    {
#line 1175
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1176
    return ((bool )0);
  } else
#line 1174
  if (maxfiles < id) {
    {
#line 1175
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1176
    return ((bool )0);
  }
#line 1177
  filblk = filblks + id;
#line 1178
  if (filblk->modes & 1U) {
#line 1178
    tmp = 1;
  } else {
#line 1178
    tmp = 0;
  }
#line 1178
  if (tmp == 0) {
    {
#line 1179
    errmsg(15, rtnnme, id);
    }
#line 1180
    return ((bool )0);
  }
#line 1181
  if (filblk->modes & (unsigned int )(1 << 3)) {
#line 1181
    tmp___1 = 1;
  } else {
#line 1181
    tmp___1 = 0;
  }
#line 1181
  if (tmp___1 == 0) {
    {
#line 1182
    tmp___0 = dyio_idtopath(id);
#line 1182
    errmsg(16, rtnnme, tmp___0);
    }
#line 1183
    return ((bool )0);
  }
#line 1184
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
    {
#line 1185
    errmsg(2, rtnnme, "pattern");
    }
#line 1186
    return ((bool )0);
  }
  {
#line 1187
  tmp___2 = strlen(pattern);
#line 1187
  patlen = (int )tmp___2;
  }
#line 1188
  if (patlen > 30) {
    {
#line 1189
    errmsg(25, rtnnme, pattern, 30);
#line 1190
    patlen = 30;
    }
  }
#line 1196
  state = states;
#line 1196
  patptr = pattern;
#line 1197
  state->nxtchr = (char )*patptr;
#line 1198
  state->fail = states;
#line 1199
  state ++;
#line 1199
  patptr ++;
#line 1200
  state->nxtchr = (char )*patptr;
#line 1201
  state->fail = states;
#line 1202
  statendx = 2;
  {
#line 1202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1202
    if (! (statendx < patlen)) {
#line 1202
      goto while_break;
    }
#line 1203
    patndx = (int )(state->fail - states);
#line 1204
    state ++;
    {
#line 1205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1205
      if ((int const   )*patptr != (int const   )*(pattern + patndx)) {
#line 1205
        if (! (patndx > 0)) {
#line 1205
          goto while_break___0;
        }
      } else {
#line 1205
        goto while_break___0;
      }
#line 1206
      patndx = (int )(states[patndx].fail - states);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1207
    if ((int const   )*patptr != (int const   )*(pattern + patndx)) {
#line 1207
      if (patndx == 0) {
#line 1208
        state->fail = states;
      } else {
#line 1210
        state->fail = & states[patndx + 1];
      }
    } else {
#line 1210
      state->fail = & states[patndx + 1];
    }
#line 1211
    patptr ++;
#line 1212
    state->nxtchr = (char )*patptr;
#line 1202
    statendx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1216
  stream = filblk->stream;
#line 1217
  mode = filblk->modes;
#line 1218
  if ((int )rwnd == 0) {
#line 1219
    retry = wrap;
  } else {
    {
#line 1221
    rewind(stream);
#line 1222
    retry = (bool )0;
    }
  }
#line 1230
  state = states;
  {
#line 1230
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1230
    if (! ((unsigned long )state != (unsigned long )(& states[patlen]))) {
#line 1230
      goto while_break___1;
    }
    {
#line 1231
    chr = nxtchar(stream, mode);
    }
#line 1232
    if ((unsigned int )chr->class1 == 7U) {
#line 1232
      return ((bool )0);
    }
#line 1233
    if ((unsigned int )chr->class1 == 6U) {
#line 1234
      if ((int )retry == 0) {
#line 1235
        return ((bool )0);
      } else {
        {
#line 1237
        rewind(stream);
#line 1238
        retry = (bool )0;
#line 1239
        state = states;
        }
#line 1240
        goto __Cont;
      }
    }
#line 1245
    if ((int )chr->chrtrn == (int )state->nxtchr) {
#line 1246
      state ++;
#line 1247
      goto __Cont;
    }
#line 1254
    state = state->fail;
    {
#line 1254
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1254
      if ((int )chr->chrtrn == (int )state->nxtchr) {
#line 1254
        goto while_break___2;
      } else
#line 1254
      if ((unsigned long )state == (unsigned long )(states)) {
#line 1254
        goto while_break___2;
      }
#line 1254
      state = state->fail;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1257
    if ((int )chr->chrtrn == (int )state->nxtchr) {
#line 1257
      state ++;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1262
  return ((bool )1);
}
}
#line 1297 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static char stringspace[81]  ;
#line 1298 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static lex_struct lex  =    {(lexclass )0, stringspace};
#line 1268 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
lex_struct *dyio_scanlex(ioid id ) 
{ 
  chartab_struct *chr ;
  char *lexptr ;
  bool ovf ;
  filblk_struct *filblk ;
  FILE *stream ;
  flags mode ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 1299
  rtnnme = "dyio_scanlex";
#line 1303
  if (id < 1) {
    {
#line 1304
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1305
    return (& lex_err);
  } else
#line 1303
  if (maxfiles < id) {
    {
#line 1304
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1305
    return (& lex_err);
  }
#line 1306
  filblk = filblks + id;
#line 1307
  if (filblk->modes & 1U) {
#line 1307
    tmp = 1;
  } else {
#line 1307
    tmp = 0;
  }
#line 1307
  if (tmp == 0) {
    {
#line 1308
    errmsg(15, rtnnme, id);
    }
#line 1309
    return (& lex_err);
  }
#line 1310
  if (filblk->modes & (unsigned int )(1 << 3)) {
#line 1310
    tmp___1 = 1;
  } else {
#line 1310
    tmp___1 = 0;
  }
#line 1310
  if (tmp___1 == 0) {
    {
#line 1311
    tmp___0 = dyio_idtopath(id);
#line 1311
    errmsg(16, rtnnme, tmp___0);
    }
#line 1312
    return (& lex_err);
  }
  {
#line 1313
  stream = filblk->stream;
#line 1314
  mode = filblk->modes;
#line 1319
  chr = nxtchar(stream, mode);
  }
  {
#line 1319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1319
    if (! ((unsigned int )chr->class1 == 0U)) {
#line 1319
      goto while_break;
    }
    {
#line 1319
    chr = nxtchar(stream, mode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1322
  if ((unsigned int )chr->class1 == 6U) {
#line 1322
    return (& lex_eof);
  }
#line 1323
  if ((unsigned int )chr->class1 == 7U) {
#line 1323
    return (& lex_err);
  }
#line 1329
  lexptr = lex.string;
#line 1330
  tmp___2 = lexptr;
#line 1330
  lexptr ++;
#line 1330
  *tmp___2 = chr->chrtrn;
#line 1331
  ovf = (bool )0;
  {
#line 1333
  if ((unsigned int )chr->class1 == 1U) {
#line 1333
    goto case_1;
  }
#line 1355
  if ((unsigned int )chr->class1 == 2U) {
#line 1355
    goto case_2;
  }
#line 1370
  if ((unsigned int )chr->class1 == 3U) {
#line 1370
    goto case_3;
  }
#line 1373
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1334
  chr = nxtchar(stream, mode);
  }
  {
#line 1334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1335
    if ((unsigned int )chr->class1 != 1U) {
#line 1335
      if ((int )chr->chrtrn != 69) {
#line 1335
        if ((int )chr->chrtrn != 101) {
#line 1339
          goto while_break___0;
        } else {
#line 1335
          goto _L___1;
        }
      } else {
#line 1335
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1335
    if ((int )chr->chrtrn == 43) {
#line 1335
      goto _L;
    } else
#line 1335
    if ((int )chr->chrtrn == 45) {
      _L: /* CIL Label */ 
#line 1335
      if ((int )*(lexptr - 1) != 69) {
#line 1335
        if ((int )*(lexptr - 1) != 101) {
#line 1339
          goto while_break___0;
        }
      }
    }
#line 1340
    if ((int )ovf == 0) {
#line 1341
      if ((unsigned long )lexptr < (unsigned long )(& stringspace[80])) {
#line 1342
        tmp___3 = lexptr;
#line 1342
        lexptr ++;
#line 1342
        *tmp___3 = chr->chrtrn;
      } else {
        {
#line 1344
        ovf = (bool )1;
#line 1345
        *lexptr = (char )'\000';
#line 1346
        errmsg(26, rtnnme, lex.string, 80);
        }
      }
    }
    {
#line 1334
    chr = nxtchar(stream, mode);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1347
  if (! ((unsigned int )chr->class1 == 6U)) {
#line 1347
    if (! ((unsigned int )chr->class1 == 7U)) {
      {
#line 1348
      ungetc((int )chr->chrtrn, stream);
      }
    }
  }
#line 1349
  if ((unsigned long )(lexptr - 1) == (unsigned long )lex.string) {
#line 1349
    if ((int )*(lexptr - 1) == 43) {
#line 1351
      lex.class = (lexclass )3;
    } else
#line 1349
    if ((int )*(lexptr - 1) == 45) {
#line 1351
      lex.class = (lexclass )3;
    } else {
#line 1353
      lex.class = (lexclass )1;
    }
  } else {
#line 1353
    lex.class = (lexclass )1;
  }
#line 1354
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1356
  chr = nxtchar(stream, mode);
  }
  {
#line 1356
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1356
    if (! ((unsigned int )chr->class2 == 5U)) {
#line 1356
      goto while_break___1;
    }
#line 1359
    if ((int )ovf == 0) {
#line 1360
      if ((unsigned long )lexptr < (unsigned long )(& stringspace[80])) {
#line 1361
        tmp___4 = lexptr;
#line 1361
        lexptr ++;
#line 1361
        *tmp___4 = chr->chrtrn;
      } else {
        {
#line 1363
        ovf = (bool )1;
#line 1364
        *lexptr = (char )'\000';
#line 1365
        errmsg(26, rtnnme, lex.string, 80);
        }
      }
    }
    {
#line 1356
    chr = nxtchar(stream, mode);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1366
  if (! ((unsigned int )chr->class1 == 6U)) {
#line 1366
    if (! ((unsigned int )chr->class1 == 7U)) {
      {
#line 1367
      ungetc((int )chr->chrtrn, stream);
      }
    }
  }
#line 1368
  lex.class = (lexclass )2;
#line 1369
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1371
  lex.class = (lexclass )3;
#line 1372
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1374
  errmsg(1, rtnnme, 1374);
  }
#line 1375
  return (& lex_err);
  switch_break: /* CIL Label */ ;
  }
#line 1382
  if ((unsigned int )chr->class1 == 7U) {
#line 1382
    return (& lex_err);
  }
#line 1383
  *lexptr = (char )'\000';
#line 1384
  return (& lex);
}
}
#line 1454 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static lex_struct lex___0  =    {(lexclass )0, (char *)((void *)0)};
#line 1390 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
lex_struct *dyio_scanstr(ioid id , lexclass stype , int fslen , char qschr , char qechr ) 
{ 
  chartab_struct *chr ;
  char *lexptr ;
  bool invseen ;
  int ndx ;
  int expcnt ;
  filblk_struct *filblk ;
  FILE *stream ;
  flags mode ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
#line 1455
  rtnnme = "dyio_scanstr";
#line 1459
  if ((unsigned long )lex___0.string != (unsigned long )((void *)0)) {
    {
#line 1460
    free((void *)lex___0.string);
#line 1461
    lex___0.string = (char *)((void *)0);
    }
  }
#line 1465
  if (id < 0) {
    {
#line 1466
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1467
    return (& lex_err);
  } else
#line 1465
  if (maxfiles < id) {
    {
#line 1466
    errmsg(5, rtnnme, "stream id", id);
    }
#line 1467
    return (& lex_err);
  }
#line 1468
  filblk = filblks + id;
#line 1469
  if (filblk->modes & 1U) {
#line 1469
    tmp = 1;
  } else {
#line 1469
    tmp = 0;
  }
#line 1469
  if (tmp == 0) {
    {
#line 1470
    errmsg(15, rtnnme, id);
    }
#line 1471
    return (& lex_err);
  }
#line 1472
  if (filblk->modes & (unsigned int )(1 << 3)) {
#line 1472
    tmp___1 = 1;
  } else {
#line 1472
    tmp___1 = 0;
  }
#line 1472
  if (tmp___1 == 0) {
    {
#line 1473
    tmp___0 = dyio_idtopath(id);
#line 1473
    errmsg(16, rtnnme, tmp___0);
    }
#line 1474
    return (& lex_err);
  }
  {
#line 1475
  stream = filblk->stream;
#line 1476
  mode = filblk->modes;
#line 1481
  invseen = (bool )0;
#line 1482
  chr = nxtchar(stream, mode);
  }
  {
#line 1482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1482
    if (! ((unsigned int )chr->class1 == 0U)) {
#line 1482
      goto while_break;
    }
    {
#line 1485
    invseen = (bool )1;
#line 1482
    chr = nxtchar(stream, mode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1486
  if ((unsigned int )chr->class1 == 7U) {
#line 1486
    return (& lex_err);
  }
#line 1487
  if ((unsigned int )chr->class1 == 6U) {
#line 1488
    if ((int )invseen == 1) {
#line 1488
      if ((int )qschr == 0) {
#line 1488
        if ((int )qechr == 0) {
#line 1489
          return (& lex_nil___0);
        } else
#line 1488
        if ((int )qechr == 32) {
#line 1489
          return (& lex_nil___0);
        } else {
#line 1491
          return (& lex_eof);
        }
      } else {
#line 1491
        return (& lex_eof);
      }
    } else {
#line 1491
      return (& lex_eof);
    }
  }
  {
#line 1501
  if ((unsigned int )stype == 4U) {
#line 1501
    goto case_4;
  }
#line 1526
  if ((unsigned int )stype == 5U) {
#line 1526
    goto case_5;
  }
#line 1585
  goto switch_default___0;
  case_4: /* CIL Label */ 
#line 1502
  if (fslen <= 0) {
    {
#line 1503
    errmsg(5, rtnnme, "fslen", fslen);
#line 1504
    ungetc((int )chr->chrtrn, stream);
    }
#line 1505
    return (& lex_err);
  }
  {
#line 1506
  tmp___2 = malloc((size_t )(fslen + 1));
#line 1506
  lexptr = (char *)tmp___2;
#line 1507
  lex___0.string = lexptr;
#line 1508
  tmp___3 = lexptr;
#line 1508
  lexptr ++;
#line 1508
  *tmp___3 = chr->chrtrn;
#line 1509
  ndx = fslen - 1;
  }
  {
#line 1509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1509
    if (! (ndx != 0)) {
#line 1509
      goto while_break___0;
    }
    {
#line 1510
    chr = nxtchar(stream, mode);
    }
#line 1511
    if ((unsigned int )chr->class1 == 6U) {
      {
#line 1512
      *lexptr = (char )'\000';
#line 1513
      errmsg(27, rtnnme, fslen, lex___0.string);
#line 1514
      free((void *)lex___0.string);
#line 1515
      lex___0.string = (char *)((void *)0);
      }
#line 1516
      return (& lex_err);
    } else
#line 1511
    if ((unsigned int )chr->class1 == 7U) {
      {
#line 1512
      *lexptr = (char )'\000';
#line 1513
      errmsg(27, rtnnme, fslen, lex___0.string);
#line 1514
      free((void *)lex___0.string);
#line 1515
      lex___0.string = (char *)((void *)0);
      }
#line 1516
      return (& lex_err);
    }
#line 1517
    tmp___4 = lexptr;
#line 1517
    lexptr ++;
#line 1517
    *tmp___4 = chr->chrtrn;
#line 1509
    ndx --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1518
  lex___0.class = (lexclass )4;
#line 1519
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1528
  if ((int )qschr == 0) {
#line 1528
    goto case_0;
  }
#line 1533
  if ((int )qschr == 32) {
#line 1533
    goto case_32;
  }
#line 1538
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1529
  if ((int )invseen == 1) {
#line 1529
    if ((int )qechr == 0) {
      {
#line 1530
      ungetc((int )chr->chrtrn, stream);
      }
#line 1531
      return (& lex_nil___0);
    } else
#line 1529
    if ((int )qechr == 32) {
      {
#line 1530
      ungetc((int )chr->chrtrn, stream);
      }
#line 1531
      return (& lex_nil___0);
    }
  }
#line 1532
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 1534
  if ((int )invseen != 1) {
    {
#line 1535
    ungetc((int )chr->chrtrn, stream);
    }
#line 1536
    return (& lex_err);
  }
#line 1537
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1539
  if ((int )qschr != (int )chr->chrtrn) {
    {
#line 1540
    ungetc((int )chr->chrtrn, stream);
    }
#line 1541
    return (& lex_err);
  }
  {
#line 1542
  chr = nxtchar(stream, mode);
  }
#line 1543
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1544
  tmp___5 = malloc((size_t )251);
#line 1544
  lexptr = (char *)tmp___5;
#line 1545
  lex___0.string = lexptr;
#line 1546
  ndx = 250;
#line 1547
  expcnt = 0;
  }
  {
#line 1548
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1549
    if ((unsigned int )chr->class1 == 6U) {
      {
#line 1550
      *lexptr = (char )'\000';
#line 1551
      errmsg(28, rtnnme, (int )qschr, (int )qechr, lex___0.string);
#line 1552
      free((void *)lex___0.string);
#line 1553
      lex___0.string = (char *)((void *)0);
      }
#line 1554
      return (& lex_err);
    } else
#line 1549
    if ((unsigned int )chr->class1 == 7U) {
      {
#line 1550
      *lexptr = (char )'\000';
#line 1551
      errmsg(28, rtnnme, (int )qschr, (int )qechr, lex___0.string);
#line 1552
      free((void *)lex___0.string);
#line 1553
      lex___0.string = (char *)((void *)0);
      }
#line 1554
      return (& lex_err);
    }
#line 1555
    if ((int )qechr == 32) {
#line 1555
      if ((unsigned int )chr->class1 == 0U) {
#line 1557
        goto while_break___1;
      } else {
#line 1555
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1555
    if ((int )qechr == 0) {
#line 1555
      if ((unsigned int )chr->class1 == 0U) {
#line 1557
        goto while_break___1;
      } else
#line 1555
      if ((unsigned int )chr->class1 == 3U) {
#line 1557
        goto while_break___1;
      }
    }
#line 1558
    if ((int )chr->chrtrn == (int )qechr) {
#line 1559
      if ((int )qechr >= 32) {
        {
#line 1560
        chr = nxtchar(stream, mode);
        }
#line 1561
        if ((int )chr->chrtrn != (int )qechr) {
#line 1562
          if ((unsigned int )chr->class1 != 6U) {
#line 1562
            if ((unsigned int )chr->class1 != 7U) {
              {
#line 1563
              ungetc((int )chr->chrtrn, stream);
              }
            }
          }
#line 1564
          goto while_break___1;
        }
      } else {
#line 1566
        goto while_break___1;
      }
    }
#line 1567
    tmp___6 = lexptr;
#line 1567
    lexptr ++;
#line 1567
    *tmp___6 = chr->chrtrn;
#line 1568
    ndx --;
#line 1569
    if (ndx <= 0) {
      {
#line 1570
      expcnt ++;
#line 1571
      tmp___7 = malloc((size_t )((expcnt + 1) * 250 + 1));
#line 1571
      lexptr = (char *)tmp___7;
#line 1572
      strncpy((char */* __restrict  */)lexptr, (char const   */* __restrict  */)lex___0.string,
              (size_t )(expcnt * 250));
#line 1573
      free((void *)lex___0.string);
#line 1574
      lex___0.string = lexptr;
#line 1575
      lexptr += expcnt * 250;
#line 1576
      ndx = 250;
      }
    }
    {
#line 1577
    chr = nxtchar(stream, mode);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1578
  if ((unsigned long )lex___0.string == (unsigned long )lexptr) {
    {
#line 1579
    free((void *)lex___0.string);
#line 1580
    lex___0.string = (char *)((void *)0);
    }
#line 1581
    return (& lex_nil___0);
  } else {
#line 1583
    lex___0.class = (lexclass )5;
  }
#line 1584
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 1586
  errmsg(5, rtnnme, "string type", (unsigned int )stype);
#line 1587
  ungetc((int )chr->chrtrn, stream);
  }
#line 1588
  return (& lex_err);
  switch_break: /* CIL Label */ ;
  }
#line 1593
  *lexptr = (char )'\000';
#line 1594
  return (& lex___0);
}
}
#line 1605 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
void dyio_flushio(ioid id , bool echo ) 
{ 
  FILE *strmid ;
  filblk_struct *filblk ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1626
  rtnnme = "dyio_flushio";
#line 1631
  if (id < 0) {
    {
#line 1632
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1633
    return;
  } else
#line 1631
  if (maxfiles < id) {
    {
#line 1632
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1633
    return;
  }
#line 1637
  if (id != 0) {
#line 1638
    filblk = filblks + id;
#line 1639
    if (filblk->modes & 1U) {
#line 1639
      tmp___2 = 1;
    } else {
#line 1639
      tmp___2 = 0;
    }
#line 1639
    if (tmp___2 == 0) {
      {
#line 1640
      errmsg(15, rtnnme, id);
      }
    } else {
#line 1642
      if (filblk->modes & (unsigned int )(1 << 4)) {
#line 1642
        tmp___1 = 1;
      } else {
#line 1642
        tmp___1 = 0;
      }
#line 1642
      if (tmp___1 == 0) {
        {
#line 1643
        tmp = dyio_idtopath(id);
#line 1643
        errmsg(17, rtnnme, tmp);
        }
      } else {
        {
#line 1645
        strmid = filblk->stream;
#line 1646
        tmp___0 = fflush(strmid);
        }
#line 1646
        if (tmp___0 != 0) {
          {
#line 1646
          perror(rtnnme);
          }
        }
      }
    }
  }
#line 1650
  if ((int )echo == 1) {
    {
#line 1651
    tmp___3 = fflush(stdout);
    }
#line 1651
    if (tmp___3 != 0) {
      {
#line 1651
      perror(rtnnme);
      }
    }
  }
#line 1653
  return;
}
}
#line 1657 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
void dyio_outfmt(ioid id , bool echo , char const   *pattern  , ...) 
{ 
  va_list parms ;
  filblk_struct *filblk ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ioid tmp___2 ;

  {
#line 1682
  rtnnme = "dyio_outfmt";
#line 1686
  if (id < 0) {
    {
#line 1687
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1688
    return;
  } else
#line 1686
  if (maxfiles < id) {
    {
#line 1687
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1688
    return;
  }
#line 1689
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
    {
#line 1690
    errmsg(2, rtnnme, "pattern");
    }
#line 1691
    return;
  }
  {
#line 1695
  __builtin_va_start(parms, pattern);
  }
#line 1697
  if (id != 0) {
#line 1698
    filblk = filblks + id;
#line 1699
    if (filblk->modes & 1U) {
#line 1699
      tmp___1 = 1;
    } else {
#line 1699
      tmp___1 = 0;
    }
#line 1699
    if (tmp___1 == 0) {
      {
#line 1700
      errmsg(15, rtnnme, id);
      }
    } else {
#line 1702
      if (filblk->modes & (unsigned int )(1 << 4)) {
#line 1702
        tmp___0 = 1;
      } else {
#line 1702
        tmp___0 = 0;
      }
#line 1702
      if (tmp___0 == 0) {
        {
#line 1703
        tmp = dyio_idtopath(id);
#line 1703
        errmsg(17, rtnnme, tmp);
        }
      } else {
        {
#line 1705
        vfprintf((FILE */* __restrict  */)filblk->stream, (char const   */* __restrict  */)pattern,
                 parms);
        }
      }
    }
  }
#line 1710
  if ((int )echo == 1) {
    {
#line 1710
    tmp___2 = dyio_pathtoid("stdout", (char const   *)((void *)0));
    }
#line 1710
    if (id != tmp___2) {
      {
#line 1711
      vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)pattern,
               parms);
      }
    }
  }
  {
#line 1713
  __builtin_va_end(parms);
  }
#line 1715
  return;
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
void dyio_outchr(ioid id , bool echo , char chr ) 
{ 
  FILE *strmid ;
  filblk_struct *filblk ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ioid tmp___2 ;

  {
#line 1738
  rtnnme = "dyio_outchr";
#line 1743
  if (id < 0) {
    {
#line 1744
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1745
    return;
  } else
#line 1743
  if (maxfiles < id) {
    {
#line 1744
    errmsg(5, rtnnme, "i/o id", id);
    }
#line 1745
    return;
  }
#line 1746
  if ((int )chr == 0) {
    {
#line 1747
    errmsg(2, rtnnme, "chr");
    }
#line 1748
    return;
  }
#line 1752
  if (id != 0) {
#line 1753
    filblk = filblks + id;
#line 1754
    if (filblk->modes & 1U) {
#line 1754
      tmp___1 = 1;
    } else {
#line 1754
      tmp___1 = 0;
    }
#line 1754
    if (tmp___1 == 0) {
      {
#line 1755
      errmsg(15, rtnnme, id);
      }
    } else {
#line 1757
      if (filblk->modes & (unsigned int )(1 << 4)) {
#line 1757
        tmp___0 = 1;
      } else {
#line 1757
        tmp___0 = 0;
      }
#line 1757
      if (tmp___0 == 0) {
        {
#line 1758
        tmp = dyio_idtopath(id);
#line 1758
        errmsg(17, rtnnme, tmp);
        }
      } else {
        {
#line 1760
        strmid = filblk->stream;
#line 1761
        _IO_putc((int )chr, (filblks + id)->stream);
        }
      }
    }
  }
#line 1766
  if ((int )echo == 1) {
    {
#line 1766
    tmp___2 = dyio_pathtoid("stdout", (char const   *)((void *)0));
    }
#line 1766
    if (id != tmp___2) {
      {
#line 1766
      _IO_putc((int )chr, stdout);
      }
    }
  }
#line 1768
  return;
}
}
#line 1804 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static char ourbuf___0[241]  ;
#line 1805 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static char spaces[240]  ;
#line 1808 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
static bool frstflg  =    (bool )1;
#line 1772 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_io.c"
int dyio_outfxd(char *buffer___1 , int fldsze , char lcr , char const   *pattern 
                , ...) 
{ 
  int count ;
  va_list parms ;
  int tlen ;
  int hlen ;
  bool pad ;
  char const   *rtnnme ;
  size_t tmp ;

  {
#line 1809
  rtnnme = "dyio_outfxd";
#line 1814
  if ((int )frstflg == 1) {
#line 1815
    count = 0;
    {
#line 1815
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1815
      if (! (count < 240)) {
#line 1815
        goto while_break;
      }
#line 1816
      *(spaces + count) = (char )' ';
#line 1817
      frstflg = (bool )0;
#line 1815
      count ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1821
  if ((unsigned long )buffer___1 == (unsigned long )((void *)0)) {
    {
#line 1822
    errmsg(2, rtnnme, "buffer");
    }
#line 1823
    return (0);
  }
#line 1824
  if (fldsze < 0) {
#line 1824
    pad = (bool )0;
  } else {
#line 1824
    pad = (bool )1;
  }
  {
#line 1825
  fldsze = abs(fldsze);
  }
#line 1826
  if (fldsze < 1) {
    {
#line 1827
    errmsg(5, rtnnme, "fldsze", fldsze);
    }
#line 1828
    return (0);
  } else
#line 1826
  if (fldsze > 240) {
    {
#line 1827
    errmsg(5, rtnnme, "fldsze", fldsze);
    }
#line 1828
    return (0);
  }
#line 1829
  if ((int )lcr != 108) {
#line 1829
    if ((int )lcr != 99) {
#line 1829
      if ((int )lcr != 114) {
        {
#line 1830
        errmsg(3, rtnnme, "left/center/right", (int )lcr);
        }
#line 1831
        return (0);
      }
    }
  }
#line 1832
  if ((unsigned long )pattern == (unsigned long )((void *)0)) {
    {
#line 1833
    errmsg(2, rtnnme, "pattern");
    }
#line 1834
    return (0);
  }
  {
#line 1839
  __builtin_va_start(parms, pattern);
#line 1840
  vsprintf((char */* __restrict  */)(ourbuf___0), (char const   */* __restrict  */)pattern,
           parms);
#line 1841
  __builtin_va_end(parms);
#line 1843
  tmp = strlen((char const   *)(ourbuf___0));
#line 1843
  tlen = (int )tmp;
  }
  {
#line 1845
  if ((int )lcr == 108) {
#line 1845
    goto case_108;
  }
#line 1855
  if ((int )lcr == 99) {
#line 1855
    goto case_99;
  }
#line 1865
  if ((int )lcr == 114) {
#line 1865
    goto case_114;
  }
#line 1844
  goto switch_break;
  case_108: /* CIL Label */ 
#line 1846
  if (fldsze > tlen) {
    {
#line 1847
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )tlen);
    }
#line 1848
    if ((int )pad == 1) {
      {
#line 1849
      memcpy((void */* __restrict  */)((void *)(buffer___1 + tlen)), (void const   */* __restrict  */)((void *)(spaces)),
             (size_t )(fldsze - tlen));
      }
    } else {
#line 1851
      fldsze = tlen;
    }
  } else {
    {
#line 1853
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )fldsze);
    }
  }
#line 1854
  goto switch_break;
  case_99: /* CIL Label */ 
#line 1856
  if (fldsze > tlen) {
    {
#line 1857
    hlen = fldsze - tlen;
#line 1858
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(spaces)),
           (size_t )(hlen >> 1));
#line 1859
    memcpy((void */* __restrict  */)((void *)(buffer___1 + (hlen >> 1))), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )tlen);
#line 1860
    memcpy((void */* __restrict  */)((void *)((buffer___1 + (hlen >> 1)) + tlen)),
           (void const   */* __restrict  */)((void *)(spaces)), (size_t )(hlen - (hlen >> 1)));
    }
  } else {
    {
#line 1863
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )fldsze);
    }
  }
#line 1864
  goto switch_break;
  case_114: /* CIL Label */ 
#line 1866
  if (fldsze > tlen) {
    {
#line 1867
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(spaces)),
           (size_t )(fldsze - tlen));
#line 1868
    memcpy((void */* __restrict  */)((void *)((buffer___1 + fldsze) - tlen)), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )tlen);
    }
  } else {
    {
#line 1870
    memcpy((void */* __restrict  */)((void *)buffer___1), (void const   */* __restrict  */)((void *)(ourbuf___0)),
           (size_t )fldsze);
    }
  }
#line 1871
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1872
  *(buffer___1 + fldsze) = (char )'\000';
#line 1873
  return (fldsze);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdr.h"
void prtbnfdef(ioid chn , bool echo , bnfdef_struct *bnfdef ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static char badtype[30]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static char const   *prtbnftype(bnftype_enum type ) 
{ 
  int fldsze ;

  {
  {
#line 45
  if ((unsigned int )type == 0U) {
#line 45
    goto case_0;
  }
#line 47
  if ((unsigned int )type == 1U) {
#line 47
    goto case_1;
  }
#line 49
  if ((unsigned int )type == 2U) {
#line 49
    goto case_2;
  }
#line 51
  if ((unsigned int )type == 3U) {
#line 51
    goto case_3;
  }
#line 53
  if ((unsigned int )type == 4U) {
#line 53
    goto case_4;
  }
#line 55
  if ((unsigned int )type == 5U) {
#line 55
    goto case_5;
  }
#line 57
  if ((unsigned int )type == 6U) {
#line 57
    goto case_6;
  }
#line 59
  if ((unsigned int )type == 7U) {
#line 59
    goto case_7;
  }
#line 61
  if ((unsigned int )type == 8U) {
#line 61
    goto case_8;
  }
#line 63
  if ((unsigned int )type == 9U) {
#line 63
    goto case_9;
  }
#line 65
  goto switch_default;
  case_0: /* CIL Label */ 
#line 46
  return ("G");
  case_1: /* CIL Label */ 
#line 48
  return ("NP");
  case_2: /* CIL Label */ 
#line 50
  return ("P");
  case_3: /* CIL Label */ 
#line 52
  return ("T");
  case_4: /* CIL Label */ 
#line 54
  return ("DF");
  case_5: /* CIL Label */ 
#line 56
  return ("DB");
  case_6: /* CIL Label */ 
#line 58
  return ("RF");
  case_7: /* CIL Label */ 
#line 60
  return ("RB");
  case_8: /* CIL Label */ 
#line 62
  return ("I");
  case_9: /* CIL Label */ 
#line 64
  return ("L");
  switch_default: /* CIL Label */ 
  {
#line 66
  fldsze = (int )(sizeof(badtype) - 1UL);
#line 67
  dyio_outfxd(badtype, - fldsze, (char )'l', "bad bnf type (%d)", (unsigned int )type);
  }
#line 68
  return ((char const   *)(badtype));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static char badtype___0[40]  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static char const   *prtbnfttype(bnfttype_enum ttype ) 
{ 
  int fldsze ;

  {
  {
#line 87
  if ((unsigned int )ttype == 0U) {
#line 87
    goto case_0;
  }
#line 89
  if ((unsigned int )ttype == 1U) {
#line 89
    goto case_1;
  }
#line 91
  if ((unsigned int )ttype == 2U) {
#line 91
    goto case_2;
  }
#line 93
  if ((unsigned int )ttype == 3U) {
#line 93
    goto case_3;
  }
#line 95
  if ((unsigned int )ttype == 4U) {
#line 95
    goto case_4;
  }
#line 97
  if ((unsigned int )ttype == 5U) {
#line 97
    goto case_5;
  }
#line 99
  goto switch_default;
  case_0: /* CIL Label */ 
#line 88
  return ("NIL");
  case_1: /* CIL Label */ 
#line 90
  return ("N");
  case_2: /* CIL Label */ 
#line 92
  return ("ID");
  case_3: /* CIL Label */ 
#line 94
  return ("D");
  case_4: /* CIL Label */ 
#line 96
  return ("F");
  case_5: /* CIL Label */ 
#line 98
  return ("Q");
  switch_default: /* CIL Label */ 
  {
#line 100
  fldsze = (int )(sizeof(badtype___0) - 1UL);
#line 101
  dyio_outfxd(badtype___0, - fldsze, (char )'l', "bad terminal type (%d)", (unsigned int )ttype);
  }
#line 102
  return ((char const   *)(badtype___0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtdefname(ioid chn , bool echo , bnfdef_struct *def ) 
{ 


  {
#line 126
  if ((unsigned long )def == (unsigned long )((void *)0)) {
    {
#line 127
    dyio_outfmt(chn, echo, "<<null pointer>>");
    }
  } else
#line 129
  if ((unsigned long )def->name == (unsigned long )((void *)0)) {
    {
#line 130
    dyio_outfmt(chn, echo, "unnamed(%#08x)", def);
    }
  } else {
    {
#line 132
    dyio_outfmt(chn, echo, "%s", def->name);
    }
  }
#line 134
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtrefname(ioid chn , bool echo , bnfref_struct *ref ) 
{ 


  {
#line 148
  if ((unsigned long )ref == (unsigned long )((void *)0)) {
    {
#line 149
    dyio_outfmt(chn, echo, "<<null pointer>>");
    }
  } else
#line 151
  if ((unsigned long )ref->name == (unsigned long )((void *)0)) {
    {
#line 152
    dyio_outfmt(chn, echo, "unnamed(%#08x)", ref);
    }
  } else {
    {
#line 154
    dyio_outfmt(chn, echo, "%s", ref->name);
    }
  }
#line 156
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtstring(ioid chn , bool echo , char const   *string ) 
{ 


  {
#line 172
  if ((unsigned long )string != (unsigned long )((void *)0)) {
    {
#line 173
    dyio_outfmt(chn, echo, "\"%s\"", string);
    }
  } else {
    {
#line 175
    dyio_outchr(chn, echo, (char )'*');
    }
  }
#line 175
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtstore(ioid chn , bool echo , bnfref_any ref ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 191
  if ((ref.t2)->uflgs & (unsigned int )(1 << 1)) {
#line 191
    tmp___0 = 1;
  } else {
#line 191
    tmp___0 = 0;
  }
#line 191
  if (tmp___0 == 1) {
#line 191
    goto _L;
  } else
#line 191
  if ((unsigned int )(ref.t2)->type == 8U) {
    _L: /* CIL Label */ 
#line 192
    if ((ref.t2)->uflgs & (unsigned int )(1 << 2)) {
#line 192
      tmp = 1;
    } else {
#line 192
      tmp = 0;
    }
#line 192
    if (tmp == 1) {
      {
#line 192
      dyio_outchr(chn, echo, (char )'@');
      }
    }
    {
#line 193
    dyio_outfmt(chn, echo, "%d", (ref.t2)->offset);
    }
  } else {
    {
#line 195
    dyio_outchr(chn, echo, (char )'*');
    }
  }
#line 195
  return;
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtlst(ioid chn , bool echo , struct bnfref_type3 *ref ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 210
  if (ref->uflgs & 1U) {
#line 210
    tmp___0 = 1;
  } else {
#line 210
    tmp___0 = 0;
  }
#line 210
  if (tmp___0 == 1) {
#line 211
    if (ref->uflgs & (unsigned int )(1 << 3)) {
#line 211
      tmp = 1;
    } else {
#line 211
      tmp = 0;
    }
#line 211
    if (tmp == 1) {
      {
#line 211
      dyio_outchr(chn, echo, (char )'@');
      }
    }
    {
#line 212
    prtrefname(chn, echo, (bnfref_struct *)ref);
    }
  } else {
    {
#line 214
    dyio_outchr(chn, echo, (char )'*');
    }
  }
#line 214
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtlbl(ioid chn , bool echo , bnflblsrc_enum code , bnfref_struct *src ) 
{ 


  {
  {
#line 233
  if ((unsigned int )code == 0U) {
#line 233
    goto case_0;
  }
#line 236
  if ((unsigned int )code == 1U) {
#line 236
    goto case_1;
  }
#line 239
  if ((unsigned int )code == 2U) {
#line 239
    goto case_2;
  }
#line 242
  if ((unsigned int )code == 3U) {
#line 242
    goto case_3;
  }
#line 245
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 234
  prtrefname(chn, echo, src);
  }
#line 235
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 237
  dyio_outfmt(chn, echo, "%%%d", (int )((char *)src - (char *)0));
  }
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 240
  dyio_outchr(chn, echo, (char )'c');
  }
#line 241
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 243
  dyio_outchr(chn, echo, (char )'n');
  }
#line 244
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 246
  dyio_outfmt(chn, echo, "invalid! (%d)", (unsigned int )code);
  }
#line 247
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
static void prtlblsav(ioid chn , bool echo , int flg , bnfLBdef_struct *def ) 
{ 
  int tmp ;

  {
#line 263
  if (def->dflgs & (unsigned int )flg) {
#line 263
    tmp = 1;
  } else {
#line 263
    tmp = 0;
  }
#line 263
  if (tmp == 1) {
    {
#line 265
    if (flg == 1 << 1) {
#line 265
      goto case_exp;
    }
#line 268
    if (flg == 1 << 2) {
#line 268
      goto case_exp___0;
    }
#line 264
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 266
    dyio_outfmt(chn, echo, "%%%d", def->savnd);
    }
#line 267
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 269
    dyio_outfmt(chn, echo, "%%%d", def->savnm);
    }
#line 270
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 272
    dyio_outchr(chn, echo, (char )'*');
    }
  }
#line 272
  return;
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
void prtbnfref(ioid chn , bool echo , bnfref_struct *bnfref ) 
{ 
  bnfref_any ref ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 296
  ref.com = bnfref;
#line 297
  if ((unsigned long )ref.com == (unsigned long )((void *)0)) {
    {
#line 298
    dyio_outfmt(chn, echo, "<null!>");
    }
#line 299
    return;
  }
  {
#line 303
  tmp = prtbnftype((ref.com)->type);
#line 303
  dyio_outfmt(chn, echo, "<%s,", tmp);
#line 304
  prtrefname(chn, echo, ref.com);
#line 305
  dyio_outfmt(chn, echo, "->");
#line 306
  prtdefname(chn, echo, (ref.com)->defn);
  }
  {
#line 311
  if ((unsigned int )(ref.com)->type == 0U) {
#line 311
    goto case_0;
  }
#line 317
  if ((unsigned int )(ref.com)->type == 1U) {
#line 317
    goto case_1;
  }
#line 321
  if ((unsigned int )(ref.com)->type == 2U) {
#line 321
    goto case_2;
  }
#line 330
  if ((unsigned int )(ref.com)->type == 3U) {
#line 330
    goto case_3;
  }
#line 344
  if ((unsigned int )(ref.com)->type == 8U) {
#line 344
    goto case_8;
  }
#line 352
  if ((unsigned int )(ref.com)->type == 9U) {
#line 352
    goto case_9;
  }
#line 352
  if ((unsigned int )(ref.com)->type == 7U) {
#line 352
    goto case_9;
  }
#line 352
  if ((unsigned int )(ref.com)->type == 6U) {
#line 352
    goto case_9;
  }
#line 352
  if ((unsigned int )(ref.com)->type == 5U) {
#line 352
    goto case_9;
  }
#line 352
  if ((unsigned int )(ref.com)->type == 4U) {
#line 352
    goto case_9;
  }
#line 354
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 312
  dyio_outchr(chn, echo, (char )',');
#line 313
  prtstore(chn, echo, ref);
#line 314
  dyio_outchr(chn, echo, (char )',');
#line 315
  prtlst(chn, echo, ref.t3);
  }
#line 316
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 318
  dyio_outchr(chn, echo, (char )',');
#line 319
  prtlst(chn, echo, ref.t3);
  }
#line 320
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 322
  dyio_outchr(chn, echo, (char )',');
  }
#line 323
  if ((ref.P)->uflgs & (unsigned int )(1 << 7)) {
#line 323
    tmp___0 = 1;
  } else {
#line 323
    tmp___0 = 0;
  }
#line 323
  if (tmp___0 == 1) {
    {
#line 324
    dyio_outfmt(chn, echo, "%%%d", (ref.P)->offset);
    }
  } else {
    {
#line 326
    prtstore(chn, echo, ref);
    }
  }
  {
#line 327
  dyio_outchr(chn, echo, (char )',');
#line 328
  prtlst(chn, echo, ref.t3);
  }
#line 329
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 331
  dyio_outchr(chn, echo, (char )',');
  }
#line 332
  if ((ref.T)->uflgs & (unsigned int )(1 << 4)) {
#line 332
    tmp___1 = 1;
  } else {
#line 332
    tmp___1 = 0;
  }
#line 332
  if (tmp___1 == 1) {
    {
#line 333
    dyio_outfmt(chn, echo, "flt,");
    }
  }
#line 334
  if ((ref.T)->uflgs & (unsigned int )(1 << 10)) {
#line 334
    tmp___2 = 1;
  } else {
#line 334
    tmp___2 = 0;
  }
#line 334
  if (tmp___2 == 1) {
    {
#line 335
    dyio_outfmt(chn, echo, "dbl,");
    }
  }
#line 336
  if ((ref.T)->uflgs & (unsigned int )(1 << 5)) {
#line 336
    tmp___3 = 1;
  } else {
#line 336
    tmp___3 = 0;
  }
#line 336
  if (tmp___3 == 1) {
    {
#line 337
    dyio_outfmt(chn, echo, "cs,");
    }
  }
#line 338
  if ((ref.T)->uflgs & (unsigned int )(1 << 6)) {
#line 338
    tmp___4 = 1;
  } else {
#line 338
    tmp___4 = 0;
  }
#line 338
  if (tmp___4 == 1) {
    {
#line 339
    dyio_outfmt(chn, echo, "min,");
    }
  }
#line 340
  if ((ref.T)->uflgs & (unsigned int )(1 << 8)) {
#line 340
    tmp___5 = 1;
  } else {
#line 340
    tmp___5 = 0;
  }
#line 340
  if (tmp___5 == 1) {
    {
#line 341
    dyio_outfmt(chn, echo, "exact,");
    }
  }
  {
#line 342
  prtstore(chn, echo, ref);
  }
#line 343
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 345
  dyio_outchr(chn, echo, (char )',');
#line 346
  prtstore(chn, echo, ref);
  }
#line 347
  goto switch_break;
  case_9: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 353
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 355
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 356
  dyio_outchr(chn, echo, (char )'>');
  }
#line 356
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
void prtbnfdef(ioid chn , bool echo , bnfdef_struct *bnfdef ) 
{ 
  bnfdef_any def ;
  bnfref_struct ***altrefs ;
  bnfref_struct **comprefs ;
  int altnum ;
  int altndx ;
  int compnum ;
  int compndx ;
  char const   *txm1 ;
  char const   *tmp ;
  bnfref_struct **tmp___0 ;
  bnfref_struct **tmp___1 ;
  bnfref_struct ***tmp___2 ;
  bnfref_struct ***tmp___3 ;
  bnfref_struct ***tmp___4 ;
  bnfref_struct **tmp___5 ;
  bnfref_struct **tmp___6 ;
  bnfref_struct ***tmp___7 ;
  bnfref_struct ***tmp___8 ;
  bnfref_struct ***tmp___9 ;
  bnfref_struct **tmp___10 ;
  bnfref_struct **tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 375
  txm1 = "|\n\t";
#line 380
  comprefs = (bnfref_struct **)((void *)0);
#line 384
  def.com = bnfdef;
#line 385
  if ((unsigned long )def.com == (unsigned long )((void *)0)) {
    {
#line 386
    dyio_outfmt(chn, echo, "<null!>");
    }
#line 387
    return;
  }
  {
#line 391
  tmp = prtbnftype((def.com)->type);
#line 391
  dyio_outfmt(chn, echo, "\n<%s,", tmp);
#line 392
  prtdefname(chn, echo, def.com);
  }
#line 393
  if ((unsigned int )(def.com)->type == 0U) {
    {
#line 394
    dyio_outfmt(chn, echo, ",%d,", (def.G)->size);
    }
#line 395
    if ((def.G)->link >= 0) {
      {
#line 396
      dyio_outfmt(chn, echo, "%d", (def.G)->link);
      }
    } else {
      {
#line 398
      dyio_outchr(chn, echo, (char )'*');
      }
    }
  }
  {
#line 399
  dyio_outfmt(chn, echo, "> ::= ");
  }
  {
#line 404
  if ((unsigned int )(def.com)->type == 0U) {
#line 404
    goto case_0;
  }
#line 413
  if ((unsigned int )(def.com)->type == 1U) {
#line 413
    goto case_1;
  }
#line 429
  if ((unsigned int )(def.com)->type == 2U) {
#line 429
    goto case_2;
  }
#line 445
  if ((unsigned int )(def.com)->type == 3U) {
#line 445
    goto case_3;
  }
#line 481
  if ((unsigned int )(def.com)->type == 5U) {
#line 481
    goto case_5___0;
  }
#line 481
  if ((unsigned int )(def.com)->type == 4U) {
#line 481
    goto case_5___0;
  }
#line 498
  if ((unsigned int )(def.com)->type == 7U) {
#line 498
    goto case_7;
  }
#line 498
  if ((unsigned int )(def.com)->type == 6U) {
#line 498
    goto case_7;
  }
#line 515
  if ((unsigned int )(def.com)->type == 8U) {
#line 515
    goto case_8;
  }
#line 518
  if ((unsigned int )(def.com)->type == 9U) {
#line 518
    goto case_9;
  }
#line 403
  goto switch_break;
  case_0: /* CIL Label */ 
#line 405
  comprefs = (def.G)->comps;
#line 406
  if ((unsigned long )comprefs != (unsigned long )((void *)0)) {
#line 407
    tmp___0 = comprefs;
#line 407
    comprefs ++;
#line 407
    compnum = (int )((char *)*tmp___0 - (char *)0);
  } else {
#line 409
    compnum = 0;
  }
#line 410
  compndx = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (compndx < compnum)) {
#line 410
      goto while_break;
    }
    {
#line 411
    tmp___1 = comprefs;
#line 411
    comprefs ++;
#line 411
    prtbnfref(chn, echo, *tmp___1);
#line 410
    compndx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  goto switch_break;
  case_1: /* CIL Label */ 
#line 414
  altrefs = (def.NP)->alts;
#line 415
  if ((unsigned long )altrefs != (unsigned long )((void *)0)) {
#line 416
    tmp___2 = altrefs;
#line 416
    altrefs ++;
#line 416
    altnum = (int )((char *)*tmp___2 - (char *)0);
#line 417
    tmp___3 = altrefs;
#line 417
    altrefs ++;
#line 417
    comprefs = *tmp___3;
  } else {
#line 419
    altnum = 0;
  }
#line 420
  altndx = 0;
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 420
    if (! (altndx < altnum)) {
#line 420
      goto while_break___0;
    }
#line 421
    if ((unsigned long )comprefs != (unsigned long )((void *)0)) {
#line 422
      tmp___5 = comprefs;
#line 422
      comprefs ++;
#line 422
      compnum = (int )((char *)*tmp___5 - (char *)0);
#line 423
      compndx = 0;
      {
#line 423
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 423
        if (! (compndx < compnum)) {
#line 423
          goto while_break___1;
        }
        {
#line 424
        tmp___6 = comprefs;
#line 424
        comprefs ++;
#line 424
        prtbnfref(chn, echo, *tmp___6);
#line 423
        compndx ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 426
      dyio_outfmt(chn, echo, "<null alternative! (%d)>", altndx + 1);
      }
    }
#line 427
    if (altndx < altnum - 1) {
      {
#line 427
      dyio_outfmt(chn, echo, txm1);
      }
    }
#line 420
    altndx ++;
#line 420
    tmp___4 = altrefs;
#line 420
    altrefs ++;
#line 420
    comprefs = *tmp___4;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 428
  goto switch_break;
  case_2: /* CIL Label */ 
#line 430
  altrefs = (def.P)->alts;
#line 431
  if ((unsigned long )altrefs != (unsigned long )((void *)0)) {
#line 432
    tmp___7 = altrefs;
#line 432
    altrefs ++;
#line 432
    altnum = (int )((char *)*tmp___7 - (char *)0);
#line 433
    tmp___8 = altrefs;
#line 433
    altrefs ++;
#line 433
    comprefs = *tmp___8;
  } else {
#line 435
    altnum = 0;
  }
#line 436
  altndx = 0;
  {
#line 436
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 436
    if (! (altndx < altnum)) {
#line 436
      goto while_break___2;
    }
#line 437
    if ((unsigned long )comprefs != (unsigned long )((void *)0)) {
#line 438
      tmp___10 = comprefs;
#line 438
      comprefs ++;
#line 438
      compnum = (int )((char *)*tmp___10 - (char *)0);
#line 439
      compndx = 0;
      {
#line 439
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 439
        if (! (compndx < compnum)) {
#line 439
          goto while_break___3;
        }
        {
#line 440
        tmp___11 = comprefs;
#line 440
        comprefs ++;
#line 440
        prtbnfref(chn, echo, *tmp___11);
#line 439
        compndx ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
      {
#line 442
      dyio_outfmt(chn, echo, "<null alternative! (%d)>", altndx + 1);
      }
    }
#line 443
    if (altndx < altnum - 1) {
      {
#line 443
      dyio_outfmt(chn, echo, txm1);
      }
    }
#line 436
    altndx ++;
#line 436
    tmp___9 = altrefs;
#line 436
    altrefs ++;
#line 436
    comprefs = *tmp___9;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 444
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 446
  tmp___12 = prtbnfttype((def.T)->ttype);
#line 446
  dyio_outfmt(chn, echo, "<%s", tmp___12);
  }
  {
#line 448
  if ((unsigned int )(def.T)->ttype == 0U) {
#line 448
    goto case_0___0;
  }
#line 450
  if ((unsigned int )(def.T)->ttype == 1U) {
#line 450
    goto case_1___0;
  }
#line 454
  if ((unsigned int )(def.T)->ttype == 2U) {
#line 454
    goto case_2___0;
  }
#line 457
  if ((unsigned int )(def.T)->ttype == 3U) {
#line 457
    goto case_3___0;
  }
#line 460
  if ((unsigned int )(def.T)->ttype == 4U) {
#line 460
    goto case_4;
  }
#line 464
  if ((unsigned int )(def.T)->ttype == 5U) {
#line 464
    goto case_5;
  }
#line 447
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 449
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 451
  dyio_outfmt(chn, echo, "(%d),", (def.T)->parm1);
#line 452
  prtstring(chn, echo, (def.T)->val);
  }
#line 453
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 455
  prtstring(chn, echo, (def.T)->val);
  }
#line 456
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 458
  prtstring(chn, echo, (def.T)->val);
  }
#line 459
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 461
  dyio_outfmt(chn, echo, "(%d),", (def.T)->parm1);
#line 462
  prtstring(chn, echo, (def.T)->val);
  }
#line 463
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 465
  dyio_outchr(chn, echo, (char )'(');
  }
#line 466
  if ((int )(def.T)->qschr < 32) {
    {
#line 467
    dyio_outfmt(chn, echo, "%#02x", (int )(def.T)->qschr);
    }
  } else {
    {
#line 469
    dyio_outchr(chn, echo, (def.T)->qschr);
    }
  }
  {
#line 470
  dyio_outchr(chn, echo, (char )',');
  }
#line 471
  if ((int )(def.T)->qechr < 32) {
    {
#line 472
    dyio_outfmt(chn, echo, "%#02x", (int )(def.T)->qechr);
    }
  } else {
    {
#line 474
    dyio_outchr(chn, echo, (def.T)->qechr);
    }
  }
  {
#line 475
  dyio_outfmt(chn, echo, "),");
#line 476
  prtstring(chn, echo, (def.T)->val);
  }
#line 477
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 478
  dyio_outchr(chn, echo, (char )'>');
  }
#line 479
  goto switch_break;
  case_5___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  {
#line 482
  dyio_outchr(chn, echo, (char )'<');
  }
#line 483
  if ((def.LB)->dflgs & 1U) {
#line 483
    tmp___13 = 1;
  } else {
#line 483
    tmp___13 = 0;
  }
#line 483
  if (tmp___13 == 1) {
    {
#line 484
    dyio_outfmt(chn, echo, "a,");
    }
  } else {
    {
#line 486
    dyio_outfmt(chn, echo, "b,");
    }
  }
  {
#line 487
  prtlbl(chn, echo, (def.LB)->nmcd, (def.LB)->nmsrc);
#line 488
  dyio_outchr(chn, echo, (char )',');
#line 489
  prtlblsav(chn, echo, 1 << 2, def.LB);
#line 490
  dyio_outchr(chn, echo, (char )',');
#line 491
  prtlbl(chn, echo, (def.LB)->ndcd, (def.LB)->ndsrc);
#line 492
  dyio_outfmt(chn, echo, "(%d)", (def.LB)->offset);
#line 493
  dyio_outchr(chn, echo, (char )',');
#line 494
  prtlblsav(chn, echo, 1 << 1, def.LB);
#line 495
  dyio_outchr(chn, echo, (char )'>');
  }
#line 496
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 499
  dyio_outchr(chn, echo, (char )'<');
  }
#line 500
  if ((def.LB)->dflgs & 1U) {
#line 500
    tmp___14 = 1;
  } else {
#line 500
    tmp___14 = 0;
  }
#line 500
  if (tmp___14 == 1) {
    {
#line 501
    dyio_outfmt(chn, echo, "a,");
    }
  } else {
    {
#line 503
    dyio_outfmt(chn, echo, "b,");
    }
  }
  {
#line 504
  prtlbl(chn, echo, (def.LB)->nmcd, (def.LB)->nmsrc);
#line 505
  dyio_outfmt(chn, echo, "(%d)", (def.LB)->offset);
#line 506
  dyio_outchr(chn, echo, (char )',');
#line 507
  prtlblsav(chn, echo, 1 << 2, def.LB);
#line 508
  dyio_outchr(chn, echo, (char )',');
#line 509
  prtlbl(chn, echo, (def.LB)->ndcd, (def.LB)->ndsrc);
#line 510
  dyio_outfmt(chn, echo, "(%d)", (def.LB)->offset2);
#line 511
  dyio_outchr(chn, echo, (char )',');
#line 512
  prtlblsav(chn, echo, 1 << 1, def.LB);
#line 513
  dyio_outchr(chn, echo, (char )'>');
  }
#line 514
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 516
  dyio_outfmt(chn, echo, "<%d>", (def.I)->ival);
  }
#line 517
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 519
  dyio_outchr(chn, echo, (char )'<');
  }
#line 520
  if ((def.L)->dflgs & (unsigned int )(1 << 2)) {
#line 520
    tmp___15 = 1;
  } else {
#line 520
    tmp___15 = 0;
  }
#line 520
  if (tmp___15 == 1) {
    {
#line 521
    dyio_outfmt(chn, echo, "%%%d", (int )((def.L)->txt - (char *)0));
    }
  } else {
    {
#line 523
    prtstring(chn, echo, (char const   *)(def.L)->txt);
    }
  }
  {
#line 524
  dyio_outchr(chn, echo, (char )'>');
  }
#line 525
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 525
  return;
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_bnfrdrio.c"
void printtab(ioid chn , bool echo , int nestlvl___0 , bool numlvl___0 , bool tablvl___0 ) 
{ 
  int tabcnt ;

  {
#line 547
  if ((int )numlvl___0 == 1) {
    {
#line 548
    dyio_outfmt(chn, echo, "%2d: ", nestlvl___0);
#line 549
    nestlvl___0 --;
    }
  }
#line 554
  if ((int )tablvl___0 == 1) {
#line 555
    tabcnt = nestlvl___0;
    {
#line 555
    while (1) {
      while_continue: /* CIL Label */ ;
#line 555
      if (! (tabcnt > 0)) {
#line 555
        goto while_break;
      }
      {
#line 556
      dyio_outfmt(chn, echo, "%4s", " ");
#line 555
      tabcnt --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 558
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.h"
extern ioid dy_cmdchn ;
#line 44
extern bool dy_cmdecho ;
#line 204 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) finite)(double __value )  __attribute__((__const__)) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___4  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 153 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t Infbits  __attribute__((__unused__))  =    {{(unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\000',
     (unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\360', (unsigned char )'\177'}};
#line 37 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
void dy_exposeOptDefaults(lpopts_struct **opts_lb , lpopts_struct **opts_dflt , lpopts_struct **opts_ub ) ;
#line 37
void dy_exposeTolDefaults(lptols_struct **tols_dflt ) ;
#line 49
extern lpopts_struct *main_lpopts ;
#line 50
extern lptols_struct *main_lptols ;
#line 71
static bool string_opt(char **str ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zid  =    {(bnftype_enum )3, "zid", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    (char const   *)((void *)0)};
#line 72 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zgetstring_zid  =    {(bnftype_enum )3, "zgetstring_zid", (bnfdef_struct *)(& zid), (1U << 1) | (unsigned int )(1 << 2),
    0};
#line 74 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zgetstring_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zgetstring_zid)};
#line 75 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zgetstring_int  =    {(bnftype_enum )0, "zgetstring_int", (int )sizeof(char *), (int )((void *)0), zgetstring_alt};
#line 76 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zgetstring  =    {(bnftype_enum )0, "zgetstring", (bnfdef_struct *)(& zgetstring_int), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 54 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool string_opt(char **str ) 
{ 
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;

  {
  {
#line 66
  rtnnme = "string_opt";
#line 81
  rdrinit();
#line 82
  tmp = parse(dy_cmdchn, & zgetstring, & result);
  }
#line 82
  if ((int )tmp == 0) {
    {
#line 83
    rdrclear();
#line 84
    errmsg(240, rtnnme, "zgetstring");
    }
#line 85
    return ((bool )0);
  }
  {
#line 86
  dyio_outfmt(dy_logchn, dy_cmdecho, " %s", *((char **)result.g));
#line 87
  dyio_flushio(dy_logchn, dy_cmdecho);
#line 89
  *str = *((char **)result.g);
#line 94
  free(result.g);
#line 95
  rdrclear();
  }
#line 97
  return ((bool )1);
}
}
#line 118
static bool integer_opt(int *iloc ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zdnum  =    {(bnftype_enum )3, "zdnum", (bnfttype_enum )1, (char )'\000', (char )'\000', 10,
    (char const   *)((void *)0)};
#line 119 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zgetnum_zdnum  =    {(bnftype_enum )3, "zgetnum_zdnum", (bnfdef_struct *)(& zdnum), 1U << 1, 0};
#line 120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zgetnum_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zgetnum_zdnum)};
#line 121 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zgetnum_int  =    {(bnftype_enum )0, "zgetnum_int", (int )sizeof(int ), (int )((void *)0), zgetnum_alt};
#line 122 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zgetnum  =    {(bnftype_enum )0, "zgetnum", (bnfdef_struct *)(& zgetnum_int), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool integer_opt(int *iloc ) 
{ 
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;

  {
  {
#line 113
  rtnnme = "integer_opt";
#line 127
  rdrinit();
#line 128
  tmp = parse(dy_cmdchn, & zgetnum, & result);
  }
#line 128
  if ((int )tmp == 0) {
    {
#line 129
    rdrclear();
#line 130
    errmsg(240, rtnnme, "zgetnum");
    }
#line 131
    return ((bool )0);
  }
  {
#line 132
  dyio_outfmt(dy_logchn, dy_cmdecho, " %d", *((int *)result.g));
#line 133
  dyio_flushio(dy_logchn, dy_cmdecho);
#line 135
  *iloc = *((int *)result.g);
#line 140
  free(result.g);
#line 141
  rdrclear();
  }
#line 143
  return ((bool )1);
}
}
#line 165
static bool double_opt(double *rloc ) ;
#line 165 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zdnum___0  =    {(bnftype_enum )3, "zdnum", (bnfttype_enum )1, (char )'\000', (char )'\000', 10,
    (char const   *)((void *)0)};
#line 166 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zgetnum_zdnum___0  =    {(bnftype_enum )3, "zgetnum_zdnum", (bnfdef_struct *)(& zdnum___0), (1U << 10) | (unsigned int )(1 << 1),
    0};
#line 167 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zgetnum_alt___0[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zgetnum_zdnum___0)};
#line 168 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zgetnum_int___0  =    {(bnftype_enum )0, "zgetnum_int", (int )sizeof(double ), (int )((void *)0), zgetnum_alt___0};
#line 169 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zgetnum___0  =    {(bnftype_enum )0, "zgetnum", (bnfdef_struct *)(& zgetnum_int___0), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 147 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool double_opt(double *rloc ) 
{ 
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;

  {
  {
#line 160
  rtnnme = "double_opt";
#line 174
  rdrinit();
#line 175
  tmp = parse(dy_cmdchn, & zgetnum___0, & result);
  }
#line 175
  if ((int )tmp == 0) {
    {
#line 176
    rdrclear();
#line 177
    errmsg(240, rtnnme, "zgetnum");
    }
#line 178
    return ((bool )0);
  }
  {
#line 179
  dyio_outfmt(dy_logchn, dy_cmdecho, " %g", *((double *)result.g));
#line 180
  dyio_flushio(dy_logchn, dy_cmdecho);
#line 182
  *rloc = *((double *)result.g);
#line 187
  free(result.g);
#line 188
  rdrclear();
  }
#line 190
  return ((bool )1);
}
}
#line 266
static bool bool_opt(bool *bloc ) ;
#line 266 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziTRUE  =    {(bnftype_enum )8, "ziTRUE", 1};
#line 267 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziFALSE  =    {(bnftype_enum )8, "ziFALSE", 0};
#line 268 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zTRUE  =    {(bnftype_enum )3, "zTRUE", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "TRUE"};
#line 269 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zFALSE  =    {(bnftype_enum )3, "zFALSE", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "FALSE"};
#line 271 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zparsebool_ziTRUE  =    {(bnftype_enum )8, "zparsebool_ziTRUE", (bnfdef_struct *)(& ziTRUE), (flags )0,
    (int )(& ((struct boolopt_struct *)0)->val)};
#line 272 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zparsebool_ziFALSE  =    {(bnftype_enum )8, "zparsebool_ziFALSE", (bnfdef_struct *)(& ziFALSE), (flags )0,
    (int )(& ((struct boolopt_struct *)0)->val)};
#line 273 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zparsebool_zTRUE  =    {(bnftype_enum )3, "zparsebool_zTRUE", (bnfdef_struct *)(& zTRUE), ((1U << 1) | (unsigned int )(1 << 2)) | (unsigned int )(1 << 6),
    (int )(& ((struct boolopt_struct *)0)->str)};
#line 275 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zparsebool_zFALSE  =    {(bnftype_enum )3, "zparsebool_zFALSE", (bnfdef_struct *)(& zFALSE), ((1U << 1) | (unsigned int )(1 << 2)) | (unsigned int )(1 << 6),
    (int )(& ((struct boolopt_struct *)0)->str)};
#line 277 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zparsebool_alt1[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zparsebool_zFALSE),      (bnfref_struct *)(& zparsebool_ziFALSE)};
#line 279 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zparsebool_alt2[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zparsebool_zTRUE),      (bnfref_struct *)(& zparsebool_ziTRUE)};
#line 281 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zparsebool_alts[3]  = {      (bnfref_struct **)2,      zparsebool_alt1,      zparsebool_alt2};
#line 283 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPdef_struct zparsebool  =    {(bnftype_enum )1, "zparsebool", zparsebool_alts};
#line 284 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPref_struct zparsebool_ref  =    {(bnftype_enum )1, "zparsebool_ref", (bnfdef_struct *)(& zparsebool), (flags )((void *)0),
    0, (bnfref_struct *)((char *)0)};
#line 286 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zgetbool_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zparsebool_ref)};
#line 287 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zgetbool_int  =    {(bnftype_enum )0, "zgetbool_int", (int )sizeof(struct boolopt_struct ), (int )((void *)0),
    zgetbool_alt};
#line 288 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zgetbool  =    {(bnftype_enum )0, "zgetbool", (bnfdef_struct *)(& zgetbool_int), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 241 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool bool_opt(bool *bloc ) 
{ 
  struct boolopt_struct *boolopt ;
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;

  {
  {
#line 261
  rtnnme = "bool_opt";
#line 293
  rdrinit();
#line 294
  tmp = parse(dy_cmdchn, & zgetbool, & result);
  }
#line 294
  if ((int )tmp == 0) {
    {
#line 295
    rdrclear();
#line 296
    errmsg(240, rtnnme, "zgetbool");
    }
#line 297
    return ((bool )0);
  }
  {
#line 298
  boolopt = (struct boolopt_struct *)result.g;
#line 299
  rdrclear();
#line 301
  dyio_outfmt(dy_logchn, dy_cmdecho, " %s", boolopt->str);
#line 302
  dyio_flushio(dy_logchn, dy_cmdecho);
#line 304
  *bloc = (bool )boolopt->val;
#line 309
  strfree((char const   *)boolopt->str);
#line 310
  free((void *)boolopt);
  }
#line 312
  return ((bool )1);
}
}
#line 359
cmd_retval dy_printopt(char const   *keywd ) ;
#line 359 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry prntkwds[18]  = 
#line 359
  {      {"basis", 1, 1}, 
        {"conmgmt", 2, 2}, 
        {"crash", 2, 3}, 
        {"degen", 2, 4}, 
        {"dual", 2, 5}, 
        {"force", 2, 6}, 
        {"major", 1, 7}, 
        {"phase1", 6, 8}, 
        {"phase2", 6, 9}, 
        {"pivoting", 4, 10}, 
        {"pivreject", 4, 11}, 
        {"pricing", 2, 12}, 
        {"rays", 1, 13}, 
        {"scaling", 2, 14}, 
        {"setup", 2, 15}, 
        {"soln", 2, 16}, 
        {"tableau", 1, 17}, 
        {"varmgmt", 1, 18}};
#line 379 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numprntcodes  =    (int )(sizeof(prntkwds) / sizeof(keytab_entry ));
#line 322 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
cmd_retval dy_printopt(char const   *keywd ) 
{ 
  char *what ;
  char cmdstr[50] ;
  int code ;
  int dflt ;
  int lb ;
  int ub ;
  int *opt ;
  lpopts_struct *opts_lb ;
  lpopts_struct *opts_dflt ;
  lpopts_struct *opts_ub ;
  char const   *rtnnme ;
  enum prntcodes prntcode ;
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 346
  rtnnme = "dy_printopt";
#line 384
  dy_exposeOptDefaults(& opts_lb, & opts_dflt, & opts_ub);
#line 388
  prntcode = (enum prntcodes )0;
#line 389
  tmp = string_opt(& what);
  }
#line 389
  if ((int )tmp == 1) {
    {
#line 390
    code = ambig(what, prntkwds, numprntcodes);
    }
#line 391
    if (code < 0) {
#line 392
      if (code < -1) {
        {
#line 393
        errmsg(233, rtnnme, what);
        }
      } else {
        {
#line 395
        errmsg(234, rtnnme, what);
        }
      }
    } else {
#line 397
      prntcode = (enum prntcodes )code;
    }
  }
  {
#line 401
  dyio_outfxd(cmdstr, - ((int )(sizeof(cmdstr) - 1UL)), (char )'l', "%s %s", keywd,
              what);
  }
  {
#line 403
  if ((unsigned int )prntcode == 2U) {
#line 403
    goto case_2;
  }
#line 409
  if ((unsigned int )prntcode == 3U) {
#line 409
    goto case_3;
  }
#line 415
  if ((unsigned int )prntcode == 4U) {
#line 415
    goto case_4;
  }
#line 421
  if ((unsigned int )prntcode == 1U) {
#line 421
    goto case_1;
  }
#line 427
  if ((unsigned int )prntcode == 7U) {
#line 427
    goto case_7;
  }
#line 433
  if ((unsigned int )prntcode == 8U) {
#line 433
    goto case_8;
  }
#line 439
  if ((unsigned int )prntcode == 9U) {
#line 439
    goto case_9;
  }
#line 445
  if ((unsigned int )prntcode == 5U) {
#line 445
    goto case_5;
  }
#line 451
  if ((unsigned int )prntcode == 6U) {
#line 451
    goto case_6;
  }
#line 457
  if ((unsigned int )prntcode == 10U) {
#line 457
    goto case_10;
  }
#line 463
  if ((unsigned int )prntcode == 11U) {
#line 463
    goto case_11;
  }
#line 469
  if ((unsigned int )prntcode == 12U) {
#line 469
    goto case_12;
  }
#line 475
  if ((unsigned int )prntcode == 13U) {
#line 475
    goto case_13;
  }
#line 481
  if ((unsigned int )prntcode == 14U) {
#line 481
    goto case_14;
  }
#line 487
  if ((unsigned int )prntcode == 15U) {
#line 487
    goto case_15;
  }
#line 493
  if ((unsigned int )prntcode == 16U) {
#line 493
    goto case_16;
  }
#line 499
  if ((unsigned int )prntcode == 17U) {
#line 499
    goto case_17;
  }
#line 505
  if ((unsigned int )prntcode == 18U) {
#line 505
    goto case_18;
  }
#line 511
  goto switch_default;
  case_2: /* CIL Label */ 
#line 404
  opt = & main_lpopts->print.conmgmt;
#line 405
  dflt = opts_dflt->print.conmgmt;
#line 406
  lb = opts_lb->print.conmgmt;
#line 407
  ub = opts_ub->print.conmgmt;
#line 408
  goto switch_break;
  case_3: /* CIL Label */ 
#line 410
  opt = & main_lpopts->print.crash;
#line 411
  dflt = opts_dflt->print.crash;
#line 412
  lb = opts_lb->print.crash;
#line 413
  ub = opts_ub->print.crash;
#line 414
  goto switch_break;
  case_4: /* CIL Label */ 
#line 416
  opt = & main_lpopts->print.degen;
#line 417
  dflt = opts_dflt->print.degen;
#line 418
  lb = opts_lb->print.degen;
#line 419
  ub = opts_ub->print.degen;
#line 420
  goto switch_break;
  case_1: /* CIL Label */ 
#line 422
  opt = & main_lpopts->print.basis;
#line 423
  dflt = opts_dflt->print.basis;
#line 424
  lb = opts_lb->print.basis;
#line 425
  ub = opts_ub->print.basis;
#line 426
  goto switch_break;
  case_7: /* CIL Label */ 
#line 428
  opt = & main_lpopts->print.major;
#line 429
  dflt = opts_dflt->print.major;
#line 430
  lb = opts_lb->print.major;
#line 431
  ub = opts_ub->print.major;
#line 432
  goto switch_break;
  case_8: /* CIL Label */ 
#line 434
  opt = & main_lpopts->print.phase1;
#line 435
  dflt = opts_dflt->print.phase1;
#line 436
  lb = opts_lb->print.phase1;
#line 437
  ub = opts_ub->print.phase1;
#line 438
  goto switch_break;
  case_9: /* CIL Label */ 
#line 440
  opt = & main_lpopts->print.phase2;
#line 441
  dflt = opts_dflt->print.phase2;
#line 442
  lb = opts_lb->print.phase2;
#line 443
  ub = opts_ub->print.phase2;
#line 444
  goto switch_break;
  case_5: /* CIL Label */ 
#line 446
  opt = & main_lpopts->print.dual;
#line 447
  dflt = opts_dflt->print.dual;
#line 448
  lb = opts_lb->print.dual;
#line 449
  ub = opts_ub->print.dual;
#line 450
  goto switch_break;
  case_6: /* CIL Label */ 
#line 452
  opt = & main_lpopts->print.force;
#line 453
  dflt = opts_dflt->print.force;
#line 454
  lb = opts_lb->print.force;
#line 455
  ub = opts_ub->print.force;
#line 456
  goto switch_break;
  case_10: /* CIL Label */ 
#line 458
  opt = & main_lpopts->print.pivoting;
#line 459
  dflt = opts_dflt->print.pivoting;
#line 460
  lb = opts_lb->print.pivoting;
#line 461
  ub = opts_ub->print.pivoting;
#line 462
  goto switch_break;
  case_11: /* CIL Label */ 
#line 464
  opt = & main_lpopts->print.pivreject;
#line 465
  dflt = opts_dflt->print.pivreject;
#line 466
  lb = opts_lb->print.pivreject;
#line 467
  ub = opts_ub->print.pivreject;
#line 468
  goto switch_break;
  case_12: /* CIL Label */ 
#line 470
  opt = & main_lpopts->print.pricing;
#line 471
  dflt = opts_dflt->print.pricing;
#line 472
  lb = opts_lb->print.pricing;
#line 473
  ub = opts_ub->print.pricing;
#line 474
  goto switch_break;
  case_13: /* CIL Label */ 
#line 476
  opt = & main_lpopts->print.rays;
#line 477
  dflt = opts_dflt->print.rays;
#line 478
  lb = opts_lb->print.rays;
#line 479
  ub = opts_ub->print.rays;
#line 480
  goto switch_break;
  case_14: /* CIL Label */ 
#line 482
  opt = & main_lpopts->print.scaling;
#line 483
  dflt = opts_dflt->print.scaling;
#line 484
  lb = opts_lb->print.scaling;
#line 485
  ub = opts_ub->print.scaling;
#line 486
  goto switch_break;
  case_15: /* CIL Label */ 
#line 488
  opt = & main_lpopts->print.setup;
#line 489
  dflt = opts_dflt->print.setup;
#line 490
  lb = opts_lb->print.setup;
#line 491
  ub = opts_ub->print.setup;
#line 492
  goto switch_break;
  case_16: /* CIL Label */ 
#line 494
  opt = & main_lpopts->print.soln;
#line 495
  dflt = opts_dflt->print.soln;
#line 496
  lb = opts_lb->print.soln;
#line 497
  ub = opts_ub->print.soln;
#line 498
  goto switch_break;
  case_17: /* CIL Label */ 
#line 500
  opt = & main_lpopts->print.tableau;
#line 501
  dflt = opts_dflt->print.tableau;
#line 502
  lb = opts_lb->print.tableau;
#line 503
  ub = opts_ub->print.tableau;
#line 504
  goto switch_break;
  case_18: /* CIL Label */ 
#line 506
  opt = & main_lpopts->print.varmgmt;
#line 507
  dflt = opts_dflt->print.varmgmt;
#line 508
  lb = opts_lb->print.varmgmt;
#line 509
  ub = opts_ub->print.varmgmt;
#line 510
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 512
  errmsg(236, rtnnme, "<what>", "keyword", keywd);
  }
#line 513
  return ((cmd_retval )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 518
  tmp___0 = integer_opt(opt);
  }
#line 518
  if ((int )tmp___0 == 1) {
#line 519
    if (*opt >= 0) {
#line 520
      if (*opt > ub) {
        {
#line 521
        warn(241, rtnnme, lb, cmdstr, ub, *opt, ub);
#line 522
        *opt = ub;
        }
      }
    } else {
      {
#line 524
      warn(243, rtnnme, cmdstr, dflt);
      }
    }
  } else {
    {
#line 526
    errmsg(236, rtnnme, "<level>", "parameter", keywd);
    }
  }
  {
#line 528
  strfree((char const   *)what);
  }
#line 530
  return ((cmd_retval )0);
}
}
#line 565
static bool lpctl_active(void) ;
#line 565 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zcomma  =    {(bnftype_enum )3, "zcomma", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    ","};
#line 566 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zcomma_ref  =    {(bnftype_enum )3, "zcomma_ref", (bnfdef_struct *)(& zcomma), (flags )((void *)0),
    (int )((void *)0)};
#line 567 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zdnum___2  =    {(bnftype_enum )3, "zdnum", (bnfttype_enum )1, (char )'\000', (char )'\000', 10,
    (char const   *)((void *)0)};
#line 568 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zactfrac_varfrac  =    {(bnftype_enum )3, "zactfrac_varfrac", (bnfdef_struct *)(& zdnum___2), (1U << 1) | (unsigned int )(1 << 4),
    (int )(& ((struct actfrac_struct *)0)->varfrac)};
#line 570 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zactfrac_confrac  =    {(bnftype_enum )3, "zactfrac_confrac", (bnfdef_struct *)(& zdnum___2), (1U << 1) | (unsigned int )(1 << 4),
    (int )(& ((struct actfrac_struct *)0)->confrac)};
#line 572 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zvar  =    {(bnftype_enum )3, "zvar", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "variables"};
#line 573 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zvar_ref  =    {(bnftype_enum )3, "zvar_ref", (bnfdef_struct *)(& zvar), 1U << 6, (int )((void *)0)};
#line 574 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zcon  =    {(bnftype_enum )3, "zcon", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "constraints"};
#line 575 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zcon_ref  =    {(bnftype_enum )3, "zcon_ref", (bnfdef_struct *)(& zcon), 1U << 6, (int )((void *)0)};
#line 576 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziTRUE___0  =    {(bnftype_enum )8, "ziTRUE", 1};
#line 577 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zactfrac_varseen  =    {(bnftype_enum )8, "zactfrac_varseen", (bnfdef_struct *)(& ziTRUE___0), (flags )0,
    (int )(& ((struct actfrac_struct *)0)->var_seen)};
#line 578 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zactfrac_conseen  =    {(bnftype_enum )8, "zactfrac_conseen", (bnfdef_struct *)(& ziTRUE___0), (flags )0,
    (int )(& ((struct actfrac_struct *)0)->con_seen)};
#line 580 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zactfrac_alt1[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zvar_ref),      (bnfref_struct *)(& zactfrac_varseen),      (bnfref_struct *)(& zactfrac_varfrac)};
#line 582 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zactfrac_alt2[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zcon_ref),      (bnfref_struct *)(& zactfrac_conseen),      (bnfref_struct *)(& zactfrac_confrac)};
#line 584 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zactfrac_alts[3]  = {      (bnfref_struct **)2,      zactfrac_alt1,      zactfrac_alt2};
#line 586 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPdef_struct zactfrac  =    {(bnftype_enum )1, "zactfrac", zactfrac_alts};
#line 587 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPref_struct zactfrac_list  =    {(bnftype_enum )1, "zactfrac_list", (bnfdef_struct *)(& zactfrac), (flags )1, 0,
    (bnfref_struct *)(& zcomma_ref)};
#line 589 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zactfracs_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zactfrac_list)};
#line 590 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zactfracs_int  =    {(bnftype_enum )0, "zactfracs_int", (int )sizeof(struct actfrac_struct ), (int )((void *)0),
    zactfracs_alt};
#line 592 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zactfracs  =    {(bnftype_enum )0, "zactfracs", (bnfdef_struct *)(& zactfracs_int), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 534 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool lpctl_active(void) 
{ 
  struct actfrac_struct *actfrac ;
  lpopts_struct *opts_lb ;
  lpopts_struct *opts_dflt ;
  lpopts_struct *opts_ub ;
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;

  {
  {
#line 560
  rtnnme = "lpctl_active";
#line 594
  dy_exposeOptDefaults(& opts_lb, & opts_dflt, & opts_ub);
#line 599
  rdrinit();
#line 600
  tmp = parse(dy_cmdchn, & zactfracs, & result);
  }
#line 600
  if ((int )tmp == 0) {
    {
#line 601
    rdrclear();
#line 602
    errmsg(240, rtnnme, "zactfracs");
    }
#line 603
    return ((bool )0);
  }
  {
#line 604
  actfrac = (struct actfrac_struct *)result.g;
#line 605
  rdrclear();
  }
#line 609
  if (actfrac->var_seen == 1) {
    {
#line 610
    dyio_outfmt(dy_logchn, dy_gtxecho, " variables %.2f", (double )actfrac->varfrac);
    }
#line 611
    if (actfrac->con_seen == 1) {
      {
#line 612
      dyio_outchr(dy_logchn, dy_gtxecho, (char )',');
      }
    }
#line 613
    if (actfrac->varfrac >= (float )0) {
#line 614
      if (actfrac->varfrac > opts_ub->active.vars) {
        {
#line 615
        warn(244, rtnnme, (double )opts_lb->active.vars, "variables", (double )opts_ub->active.vars,
             (double )actfrac->varfrac, (double )opts_ub->active.vars);
#line 617
        main_lpopts->active.vars = opts_ub->active.vars;
        }
      } else {
#line 619
        main_lpopts->active.vars = actfrac->varfrac;
      }
    } else {
      {
#line 621
      warn(245, rtnnme, "variables", (double )opts_dflt->active.vars);
      }
    }
  }
#line 623
  if (actfrac->con_seen == 1) {
    {
#line 624
    dyio_outfmt(dy_logchn, dy_gtxecho, " constraints %.2f", (double )actfrac->confrac);
    }
#line 625
    if (actfrac->confrac >= (float )0) {
#line 626
      if (actfrac->confrac > opts_ub->active.cons) {
        {
#line 627
        warn(244, rtnnme, (double )opts_lb->active.cons, "constraints", (double )opts_ub->active.cons,
             (double )actfrac->confrac, (double )opts_ub->active.cons);
#line 629
        main_lpopts->active.cons = opts_ub->active.cons;
        }
      } else {
#line 631
        main_lpopts->active.cons = actfrac->confrac;
      }
    } else {
      {
#line 633
      warn(245, rtnnme, "constraints", (double )opts_dflt->active.cons);
      }
    }
  }
  {
#line 635
  free((void *)actfrac);
  }
#line 637
  return ((bool )1);
}
}
#line 677
static bool lpctl_finpurge(void) ;
#line 677 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct znil  =    {(bnftype_enum )3, "znil", (bnfttype_enum )0, (char )'\000', (char )'\000', (int )((void *)0),
    (char const   *)((void *)0)};
#line 678 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct znil_ref  =    {(bnftype_enum )3, "znil_ref", (bnfdef_struct *)(& znil), (flags )((void *)0),
    (int )((void *)0)};
#line 679 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zcomma___0  =    {(bnftype_enum )3, "zcomma", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    ","};
#line 680 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zcomma_ref___0  =    {(bnftype_enum )3, "zcomma_ref", (bnfdef_struct *)(& zcomma___0), (flags )((void *)0),
    (int )((void *)0)};
#line 682 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zpurge  =    {(bnftype_enum )3, "zpurge", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "purge"};
#line 683 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zpurge_ref  =    {(bnftype_enum )3, "zpurge_ref", (bnfdef_struct *)(& zpurge), 1U << 6, (int )((void *)0)};
#line 684 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zvar___0  =    {(bnftype_enum )3, "zvar", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "variables"};
#line 685 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zvar_ref___0  =    {(bnftype_enum )3, "zvar_ref", (bnfdef_struct *)(& zvar___0), 1U << 6, (int )((void *)0)};
#line 686 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zcon___0  =    {(bnftype_enum )3, "zcon", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "constraints"};
#line 687 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zcon_ref___0  =    {(bnftype_enum )3, "zcon_ref", (bnfdef_struct *)(& zcon___0), 1U << 6, (int )((void *)0)};
#line 689 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziminus1  =    {(bnftype_enum )8, "ziminus1", -1};
#line 690 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziTRUE___1  =    {(bnftype_enum )8, "ziTRUE", 1};
#line 691 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziFALSE___0  =    {(bnftype_enum )8, "ziFALSE", 0};
#line 692 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zTRUE___0  =    {(bnftype_enum )3, "zTRUE", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "TRUE"};
#line 693 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zTRUE_ref  =    {(bnftype_enum )3, "zTRUE_ref", (bnfdef_struct *)(& zTRUE___0), 1U << 6, (int )((void *)0)};
#line 694 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zFALSE___0  =    {(bnftype_enum )3, "zFALSE", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "FALSE"};
#line 695 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zFALSE_ref  =    {(bnftype_enum )3, "zFALSE_ref", (bnfdef_struct *)(& zFALSE___0), 1U << 6, (int )((void *)0)};
#line 697 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zwhatvar_ziTRUE  =    {(bnftype_enum )8, "zwhatvar_ziTRUE", (bnfdef_struct *)(& ziTRUE___1), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->vars)};
#line 698 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zwhatvar_ziFALSE  =    {(bnftype_enum )8, "zwhatvar_ziFALSE", (bnfdef_struct *)(& ziFALSE___0), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->vars)};
#line 699 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zwhat_alt1[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zvar_ref___0),      (bnfref_struct *)(& zTRUE_ref),      (bnfref_struct *)(& zwhatvar_ziTRUE)};
#line 701 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zwhat_alt2[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zvar_ref___0),      (bnfref_struct *)(& zFALSE_ref),      (bnfref_struct *)(& zwhatvar_ziFALSE)};
#line 703 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zwhatcon_ziTRUE  =    {(bnftype_enum )8, "zwhatcon_ziTRUE", (bnfdef_struct *)(& ziTRUE___1), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->cons)};
#line 704 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zwhatcon_ziFALSE  =    {(bnftype_enum )8, "zwhatcon_ziFALSE", (bnfdef_struct *)(& ziFALSE___0), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->cons)};
#line 705 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zwhat_alt3[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zcon_ref___0),      (bnfref_struct *)(& zFALSE_ref),      (bnfref_struct *)(& zwhatcon_ziFALSE)};
#line 707 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zwhat_alt4[4]  = {      (bnfref_struct *)3,      (bnfref_struct *)(& zcon_ref___0),      (bnfref_struct *)(& zTRUE_ref),      (bnfref_struct *)(& zwhatcon_ziTRUE)};
#line 709 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zwhat_alt5[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& znil_ref)};
#line 710 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zwhat_alts[6]  = {      (bnfref_struct **)5,      zwhat_alt1,      zwhat_alt2,      zwhat_alt3, 
        zwhat_alt4,      zwhat_alt5};
#line 713 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPdef_struct zwhat  =    {(bnftype_enum )1, "zwhat", zwhat_alts};
#line 715 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPref_struct zfinpurge_what  =    {(bnftype_enum )1, "zfinpurge_what", (bnfdef_struct *)(& zwhat), (flags )1, 0,
    (bnfref_struct *)(& zcomma_ref___0)};
#line 717 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zfinpurge_varminus1  =    {(bnftype_enum )8, "zfinpurge_varminus1", (bnfdef_struct *)(& ziminus1), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->vars)};
#line 719 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zfinpurge_conminus1  =    {(bnftype_enum )8, "zfinpurge_conminus1", (bnfdef_struct *)(& ziminus1), (flags )0,
    (int )(& ((struct finpurge_struct *)0)->cons)};
#line 721 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zfinpurge_alt[5]  = {      (bnfref_struct *)4,      (bnfref_struct *)(& zfinpurge_varminus1),      (bnfref_struct *)(& zfinpurge_conminus1),      (bnfref_struct *)(& zpurge_ref), 
        (bnfref_struct *)(& zfinpurge_what)};
#line 723 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zfinpurge_def  =    {(bnftype_enum )0, "zfinpurge_def", (int )sizeof(struct finpurge_struct ), (int )((void *)0),
    zfinpurge_alt};
#line 725 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zfinpurge  =    {(bnftype_enum )0, "zfinpurge", (bnfdef_struct *)(& zfinpurge_def), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 641 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool lpctl_finpurge(void) 
{ 
  struct finpurge_struct *optvals ;
  lpopts_struct *opts_lb ;
  lpopts_struct *opts_dflt ;
  lpopts_struct *opts_ub ;
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 671
  rtnnme = "lpctl_finpurge";
#line 727
  dy_exposeOptDefaults(& opts_lb, & opts_dflt, & opts_ub);
#line 732
  rdrinit();
#line 733
  tmp = parse(dy_cmdchn, & zfinpurge, & result);
  }
#line 733
  if ((int )tmp == 0) {
    {
#line 734
    rdrclear();
#line 735
    errmsg(240, rtnnme, "zfinspec");
    }
#line 736
    return ((bool )0);
  }
  {
#line 737
  optvals = (struct finpurge_struct *)result.g;
#line 738
  rdrclear();
  }
#line 743
  if (optvals->vars < 0) {
#line 743
    if (optvals->cons < 0) {
#line 744
      if ((int )opts_dflt->finpurge.vars == 1) {
#line 744
        tmp___0 = "true";
      } else {
#line 744
        tmp___0 = "false";
      }
      {
#line 744
      warn(246, rtnnme, "final variable deactivation", tmp___0);
      }
#line 746
      if ((int )opts_dflt->finpurge.cons == 1) {
#line 746
        tmp___1 = "true";
      } else {
#line 746
        tmp___1 = "false";
      }
      {
#line 746
      warn(246, rtnnme, "final constraint deactivation", tmp___1);
      }
#line 748
      return ((bool )1);
    }
  }
#line 752
  if (optvals->vars >= 0) {
#line 753
    main_lpopts->finpurge.vars = (bool )optvals->vars;
#line 754
    if ((int )main_lpopts->finpurge.vars == 1) {
#line 754
      tmp___2 = "true";
    } else {
#line 754
      tmp___2 = "false";
    }
    {
#line 754
    dyio_outfmt(dy_logchn, dy_gtxecho, "variables %s", tmp___2);
    }
  }
#line 756
  if (optvals->cons >= 0) {
#line 757
    main_lpopts->finpurge.cons = (bool )optvals->cons;
#line 758
    if (optvals->vars >= 0) {
      {
#line 758
      dyio_outfmt(dy_logchn, dy_gtxecho, ", ");
      }
    }
#line 759
    if ((int )main_lpopts->finpurge.cons == 1) {
#line 759
      tmp___3 = "true";
    } else {
#line 759
      tmp___3 = "false";
    }
    {
#line 759
    dyio_outfmt(dy_logchn, dy_gtxecho, "constraints %s", tmp___3);
    }
  }
  {
#line 762
  free((void *)optvals);
  }
#line 764
  return ((bool )1);
}
}
#line 818
static bool lpctl_load(void) ;
#line 818 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct znil___0  =    {(bnftype_enum )3, "znil", (bnfttype_enum )0, (char )'\000', (char )'\000', (int )((void *)0),
    (char const   *)((void *)0)};
#line 819 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct znil_ref___0  =    {(bnftype_enum )3, "znil_ref", (bnfdef_struct *)(& znil___0), (flags )((void *)0),
    (int )((void *)0)};
#line 820 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zcomma___1  =    {(bnftype_enum )3, "zcomma", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    ","};
#line 821 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zcomma_ref___1  =    {(bnftype_enum )3, "zcomma_ref", (bnfdef_struct *)(& zcomma___1), (flags )((void *)0),
    (int )((void *)0)};
#line 822 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zlsq  =    {(bnftype_enum )3, "zlsq", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    "["};
#line 823 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zlsq_ref  =    {(bnftype_enum )3, "zlsq_ref", (bnfdef_struct *)(& zlsq), (flags )((void *)0),
    (int )((void *)0)};
#line 824 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zlpar  =    {(bnftype_enum )3, "zlpar", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    "("};
#line 825 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zlpar_ref  =    {(bnftype_enum )3, "zlpar_ref", (bnfdef_struct *)(& zlpar), (flags )((void *)0),
    (int )((void *)0)};
#line 826 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zrsq  =    {(bnftype_enum )3, "zrsq", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    "]"};
#line 827 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zrsq_ref  =    {(bnftype_enum )3, "zrsq_ref", (bnfdef_struct *)(& zrsq), (flags )((void *)0),
    (int )((void *)0)};
#line 828 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zrpar  =    {(bnftype_enum )3, "zrpar", (bnfttype_enum )3, (char )'\000', (char )'\000', (int )((void *)0),
    ")"};
#line 829 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zrpar_ref  =    {(bnftype_enum )3, "zrpar_ref", (bnfdef_struct *)(& zrpar), (flags )((void *)0),
    (int )((void *)0)};
#line 830 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zdnum___3  =    {(bnftype_enum )3, "zdnum", (bnfttype_enum )1, (char )'\000', (char )'\000', 10,
    (char const   *)((void *)0)};
#line 832 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zldelim_alt1[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zlsq_ref)};
#line 833 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zldelim_alt2[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zlpar_ref)};
#line 834 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zldelim_alts[3]  = {      (bnfref_struct **)2,      zldelim_alt1,      zldelim_alt2};
#line 836 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPdef_struct zldelim  =    {(bnftype_enum )2, "zldelim", zldelim_alts};
#line 838 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zrdelim_alt1[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zrsq_ref)};
#line 839 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zrdelim_alt2[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zrpar_ref)};
#line 840 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zrdelim_alts[3]  = {      (bnfref_struct **)2,      zrdelim_alt1,      zrdelim_alt2};
#line 842 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPdef_struct zrdelim  =    {(bnftype_enum )2, "zrdelim", zrdelim_alts};
#line 844 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPref_struct zinterval_ldelim  =    {(bnftype_enum )2, "zinterval_ldelim", (bnfdef_struct *)(& zldelim), (flags )((1 << 1) | (1 << 8)),
    (int )(& ((struct interval_struct *)0)->ldelim), (bnfref_struct *)((char *)0)};
#line 846 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zinterval_ub  =    {(bnftype_enum )3, "zinterval_ub", (bnfdef_struct *)(& zdnum___3), (1U << 1) | (unsigned int )(1 << 10),
    (int )(& ((struct interval_struct *)0)->ub)};
#line 848 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zinterval_lb  =    {(bnftype_enum )3, "zinterval_lb", (bnfdef_struct *)(& zdnum___3), (1U << 1) | (unsigned int )(1 << 10),
    (int )(& ((struct interval_struct *)0)->lb)};
#line 850 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPref_struct zinterval_rdelim  =    {(bnftype_enum )2, "zinterval_rdelim", (bnfdef_struct *)(& zrdelim), (flags )((1 << 1) | (1 << 8)),
    (int )(& ((struct interval_struct *)0)->rdelim), (bnfref_struct *)((char *)0)};
#line 852 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zinterval_alt[5]  = {      (bnfref_struct *)4,      (bnfref_struct *)(& zinterval_ldelim),      (bnfref_struct *)(& zinterval_ub),      (bnfref_struct *)(& zinterval_lb), 
        (bnfref_struct *)(& zinterval_rdelim)};
#line 857 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zinterval  =    {(bnftype_enum )0, "zinterval", (int )sizeof(struct interval_struct ), (int )(& ((struct interval_struct *)0)->nxt),
    zinterval_alt};
#line 860 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zfraction_dnum  =    {(bnftype_enum )3, "zfraction_dnum", (bnfdef_struct *)(& zdnum___3), (1U << 1) | (unsigned int )(1 << 10),
    (int )(& ((struct load_struct *)0)->frac)};
#line 862 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziTRUE___2  =    {(bnftype_enum )8, "ziTRUE", 1};
#line 863 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zfrac_valid  =    {(bnftype_enum )8, "zfrac_valid", (bnfdef_struct *)(& ziTRUE___2), (flags )0, (int )(& ((struct load_struct *)0)->frac_valid)};
#line 864 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zfraction_alt1[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zfraction_dnum),      (bnfref_struct *)(& zfrac_valid)};
#line 866 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zfraction_alt2[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& znil_ref___0)};
#line 867 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zfraction_alts[3]  = {      (bnfref_struct **)2,      zfraction_alt1,      zfraction_alt2};
#line 869 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPdef_struct zfraction  =    {(bnftype_enum )2, "zfraction", zfraction_alts};
#line 871 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfPref_struct zloadbody_fraction  =    {(bnftype_enum )2, "zloadbody_fraction", (bnfdef_struct *)(& zfraction), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 872 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zloadbody_interval  =    {(bnftype_enum )0, "zloadbody_interval", (bnfdef_struct *)(& zinterval), (flags )((1 << 1) | 1),
    (int )(& ((struct load_struct *)0)->intervals), (bnfref_struct *)(& zcomma_ref___1)};
#line 875 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zloadbody_alt1[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zloadbody_fraction),      (bnfref_struct *)(& zloadbody_interval)};
#line 877 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zloadbody_alt2[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zloadbody_fraction)};
#line 879 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zloadbody_alts[3]  = {      (bnfref_struct **)2,      zloadbody_alt1,      zloadbody_alt2};
#line 881 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPdef_struct zloadbody  =    {(bnftype_enum )1, "zloadbody", zloadbody_alts};
#line 882 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPref_struct zloadbody_ref  =    {(bnftype_enum )1, "zloadbody_ref", (bnfdef_struct *)(& zloadbody), (flags )((void *)0),
    0, (bnfref_struct *)((char *)0)};
#line 884 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zload_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zloadbody_ref)};
#line 885 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zload_def  =    {(bnftype_enum )0, "zload_def", (int )sizeof(struct load_struct ), (int )((void *)0),
    zload_alt};
#line 886 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zload  =    {(bnftype_enum )0, "zload", (bnfdef_struct *)(& zload_def), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 768 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool lpctl_load(void) 
{ 
  struct interval_struct *intv ;
  struct interval_struct *temp ;
  struct load_struct *loadspec ;
  lpopts_struct *opts_lb ;
  lpopts_struct *opts_dflt ;
  lpopts_struct *opts_ub ;
  char intvstr[50] ;
  int intvndx ;
  int intvlen ;
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 812
  rtnnme = "lpctl_load";
#line 888
  dy_exposeOptDefaults(& opts_lb, & opts_dflt, & opts_ub);
#line 893
  rdrinit();
#line 894
  tmp = parse(dy_cmdchn, & zload, & result);
  }
#line 894
  if ((int )tmp == 0) {
    {
#line 895
    rdrclear();
#line 896
    errmsg(240, rtnnme, "zload");
    }
#line 897
    return ((bool )0);
  }
  {
#line 898
  loadspec = (struct load_struct *)result.g;
#line 899
  rdrclear();
  }
#line 904
  if (loadspec->frac_valid == 0) {
#line 904
    if ((unsigned long )loadspec->intervals == (unsigned long )((void *)0)) {
      {
#line 905
      warn(245, rtnnme, "initial load fraction", opts_dflt->initcons.frac);
#line 906
      intvndx = 0;
#line 907
      intvlen = (int )(sizeof(intvstr) - 1UL);
      }
#line 908
      if ((int )opts_dflt->initcons.i1uopen == 1) {
#line 909
        intvstr[intvndx] = (char )'(';
      } else {
#line 911
        intvstr[intvndx] = (char )'[';
      }
      {
#line 912
      intvndx ++;
#line 913
      tmp___0 = dyio_outfxd(& intvstr[intvndx], - (intvlen - intvndx), (char )'l',
                            "%.5f %.5f", opts_dflt->initcons.i1u, opts_dflt->initcons.i1l);
#line 913
      intvndx += tmp___0;
      }
#line 916
      if ((int )opts_dflt->initcons.i1lopen == 1) {
#line 917
        intvstr[intvndx] = (char )')';
      } else {
#line 919
        intvstr[intvndx] = (char )']';
      }
#line 920
      intvndx ++;
#line 921
      if ((int )opts_dflt->initcons.i2valid == 1) {
#line 922
        if ((int )opts_dflt->initcons.i2uopen == 1) {
#line 923
          intvstr[intvndx] = (char )'(';
        } else {
#line 925
          intvstr[intvndx] = (char )'[';
        }
        {
#line 926
        intvndx ++;
#line 927
        tmp___1 = dyio_outfxd(& intvstr[intvndx], - (intvlen - intvndx), (char )'l',
                              "%.5f %.5f", opts_dflt->initcons.i2u, opts_dflt->initcons.i2l);
#line 927
        intvndx += tmp___1;
        }
#line 930
        if ((int )opts_dflt->initcons.i2lopen == 1) {
#line 931
          intvstr[intvndx] = (char )')';
        } else {
#line 933
          intvstr[intvndx] = (char )']';
        }
#line 934
        intvndx ++;
      }
      {
#line 935
      intvstr[intvndx] = (char )'\000';
#line 936
      warn(246, rtnnme, "load interval", intvstr);
      }
#line 937
      return ((bool )1);
    }
  }
#line 941
  if (loadspec->frac_valid == 1) {
    {
#line 942
    dyio_outfmt(dy_logchn, dy_gtxecho, " %.2f", loadspec->frac);
    }
#line 943
    if (loadspec->frac < opts_lb->initcons.frac) {
      {
#line 945
      warn(244, rtnnme, opts_lb->initcons.frac, "initial load fraction", opts_ub->initcons.frac,
           loadspec->frac, opts_ub->initcons.frac);
#line 947
      main_lpopts->initcons.frac = opts_ub->initcons.frac;
      }
    } else
#line 943
    if (loadspec->frac > opts_ub->initcons.frac) {
      {
#line 945
      warn(244, rtnnme, opts_lb->initcons.frac, "initial load fraction", opts_ub->initcons.frac,
           loadspec->frac, opts_ub->initcons.frac);
#line 947
      main_lpopts->initcons.frac = opts_ub->initcons.frac;
      }
    } else {
#line 949
      main_lpopts->initcons.frac = loadspec->frac;
    }
  }
  {
#line 954
  intv = loadspec->intervals;
#line 955
  free((void *)loadspec);
  }
#line 956
  if ((unsigned long )intv == (unsigned long )((void *)0)) {
#line 956
    return ((bool )1);
  }
  {
#line 958
  dyio_outfmt(dy_logchn, dy_gtxecho, " %c %.5f %.5f %c", (int )intv->ldelim, intv->ub,
              intv->lb, (int )intv->rdelim);
  }
#line 960
  if ((int )intv->ldelim == 40) {
#line 961
    main_lpopts->initcons.i1uopen = (bool )1;
  } else {
#line 963
    main_lpopts->initcons.i1uopen = (bool )0;
  }
#line 964
  if (intv->ub > opts_ub->initcons.i1u) {
    {
#line 965
    warn(244, rtnnme, opts_lb->initcons.i1u, "initial load angle bound", opts_ub->initcons.i1u,
         intv->ub, opts_ub->initcons.i1u);
#line 967
    main_lpopts->initcons.i1u = opts_ub->initcons.i1u;
    }
  } else
#line 964
  if (intv->ub < opts_lb->initcons.i1u) {
    {
#line 965
    warn(244, rtnnme, opts_lb->initcons.i1u, "initial load angle bound", opts_ub->initcons.i1u,
         intv->ub, opts_ub->initcons.i1u);
#line 967
    main_lpopts->initcons.i1u = opts_ub->initcons.i1u;
    }
  } else {
#line 969
    main_lpopts->initcons.i1u = intv->ub;
  }
#line 970
  if (intv->lb > opts_ub->initcons.i1l) {
    {
#line 971
    warn(244, rtnnme, opts_lb->initcons.i1l, "initial load angle bound", opts_ub->initcons.i1l,
         intv->lb, opts_lb->initcons.i1l);
#line 973
    main_lpopts->initcons.i1l = opts_lb->initcons.i1l;
    }
  } else
#line 970
  if (intv->lb < opts_lb->initcons.i1l) {
    {
#line 971
    warn(244, rtnnme, opts_lb->initcons.i1l, "initial load angle bound", opts_ub->initcons.i1l,
         intv->lb, opts_lb->initcons.i1l);
#line 973
    main_lpopts->initcons.i1l = opts_lb->initcons.i1l;
    }
  } else {
#line 975
    main_lpopts->initcons.i1l = intv->lb;
  }
#line 976
  if ((int )intv->rdelim == 41) {
#line 977
    main_lpopts->initcons.i1lopen = (bool )1;
  } else {
#line 979
    main_lpopts->initcons.i1lopen = (bool )0;
  }
  {
#line 984
  temp = intv->nxt;
#line 985
  free((void *)intv);
  }
#line 986
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 987
    main_lpopts->initcons.i2valid = (bool )0;
#line 988
    return ((bool )1);
  }
  {
#line 990
  intv = temp;
#line 991
  dyio_outfmt(dy_logchn, dy_gtxecho, ", %c %.5f %.5f %c", (int )intv->ldelim, intv->ub,
              intv->lb, (int )intv->rdelim);
  }
#line 993
  if ((int )intv->ldelim == 40) {
#line 994
    main_lpopts->initcons.i2uopen = (bool )1;
  } else {
#line 996
    main_lpopts->initcons.i2uopen = (bool )0;
  }
#line 997
  if (intv->ub > opts_ub->initcons.i2u) {
    {
#line 998
    warn(244, rtnnme, opts_lb->initcons.i2u, "initial load angle bound", opts_ub->initcons.i2u,
         intv->ub, opts_ub->initcons.i2u);
#line 1000
    main_lpopts->initcons.i2u = opts_ub->initcons.i2u;
    }
  } else
#line 997
  if (intv->ub < opts_lb->initcons.i2u) {
    {
#line 998
    warn(244, rtnnme, opts_lb->initcons.i2u, "initial load angle bound", opts_ub->initcons.i2u,
         intv->ub, opts_ub->initcons.i2u);
#line 1000
    main_lpopts->initcons.i2u = opts_ub->initcons.i2u;
    }
  } else {
#line 1002
    main_lpopts->initcons.i2u = intv->ub;
  }
#line 1003
  if (intv->lb > opts_ub->initcons.i2l) {
    {
#line 1004
    warn(244, rtnnme, opts_lb->initcons.i2l, "initial load angle bound", opts_ub->initcons.i2l,
         intv->lb, opts_lb->initcons.i2l);
#line 1006
    main_lpopts->initcons.i2l = opts_lb->initcons.i2l;
    }
  } else
#line 1003
  if (intv->lb < opts_lb->initcons.i2l) {
    {
#line 1004
    warn(244, rtnnme, opts_lb->initcons.i2l, "initial load angle bound", opts_ub->initcons.i2l,
         intv->lb, opts_lb->initcons.i2l);
#line 1006
    main_lpopts->initcons.i2l = opts_lb->initcons.i2l;
    }
  } else {
#line 1008
    main_lpopts->initcons.i2l = intv->lb;
  }
#line 1009
  if ((int )intv->rdelim == 41) {
#line 1010
    main_lpopts->initcons.i2lopen = (bool )1;
  } else {
#line 1012
    main_lpopts->initcons.i2lopen = (bool )0;
  }
  {
#line 1014
  free((void *)intv);
  }
#line 1016
  return ((bool )1);
}
}
#line 1055
static bool lpctl_infinity(void) ;
#line 1055 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zIEEE  =    {(bnftype_enum )3, "zIEEE", (bnfttype_enum )2, (char )'\000', (char )'\000', (int )((void *)0),
    "IEEE"};
#line 1056 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zIEEE_ref  =    {(bnftype_enum )3, "zIEEE_ref", (bnfdef_struct *)(& zIEEE), 1U << 6, (int )((void *)0)};
#line 1057 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziOne  =    {(bnftype_enum )8, "ziOne", 1};
#line 1058 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zDBLMAX  =    {(bnftype_enum )3, "zDBLMAX", (bnfttype_enum )2, (char )'\000', (char )'\000',
    (int )((void *)0), "DBL_MAX"};
#line 1059 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zDBLMAX_ref  =    {(bnftype_enum )3, "zDBLMAX_ref", (bnfdef_struct *)(& zDBLMAX), 1U << 6, (int )((void *)0)};
#line 1060 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziTwo  =    {(bnftype_enum )8, "ziTwo", 2};
#line 1061 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTdef_struct zdnum___4  =    {(bnftype_enum )3, "zdnum", (bnfttype_enum )1, (char )'\000', (char )'\000', 10,
    (char const   *)((void *)0)};
#line 1062 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIdef_struct ziThree  =    {(bnftype_enum )8, "ziThree", 3};
#line 1064 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zinfbody_IEEE  =    {(bnftype_enum )8, "zinfbody_IEEE", (bnfdef_struct *)(& ziOne), (flags )0, (int )(& ((struct infinity_struct *)0)->code)};
#line 1065 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zinfbody_alt1[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zIEEE_ref),      (bnfref_struct *)(& zinfbody_IEEE)};
#line 1068 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zinfbody_DBLMAX  =    {(bnftype_enum )8, "zinfbody_DBLMAX", (bnfdef_struct *)(& ziTwo), (flags )0, (int )(& ((struct infinity_struct *)0)->code)};
#line 1069 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zinfbody_alt2[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zDBLMAX_ref),      (bnfref_struct *)(& zinfbody_DBLMAX)};
#line 1072 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfIref_struct zinfbody_dbl  =    {(bnftype_enum )8, "zinfbody_dbl", (bnfdef_struct *)(& ziThree), (flags )0, (int )(& ((struct infinity_struct *)0)->code)};
#line 1073 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfTref_struct zinfbody_dblval  =    {(bnftype_enum )3, "zinfbody_dblval", (bnfdef_struct *)(& zdnum___4), (1U << 1) | (unsigned int )(1 << 10),
    (int )(& ((struct infinity_struct *)0)->val)};
#line 1075 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zinfbody_alt3[3]  = {      (bnfref_struct *)2,      (bnfref_struct *)(& zinfbody_dblval),      (bnfref_struct *)(& zinfbody_dbl)};
#line 1078 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct **zinfbody_alts[4]  = {      (bnfref_struct **)3,      zinfbody_alt1,      zinfbody_alt2,      zinfbody_alt3};
#line 1080 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPdef_struct zinfbody  =    {(bnftype_enum )1, "zinfbody", zinfbody_alts};
#line 1081 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfNPref_struct zinfbody_ref  =    {(bnftype_enum )1, "zinfbody_ref", (bnfdef_struct *)(& zinfbody), (flags )((void *)0),
    0, (bnfref_struct *)((char *)0)};
#line 1083 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfref_struct *zinfinitydef_alt[2]  = {      (bnfref_struct *)1,      (bnfref_struct *)(& zinfbody_ref)};
#line 1084 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGdef_struct zinfinity_def  =    {(bnftype_enum )0, "zinfinity_def", (int )sizeof(struct infinity_struct ), (int )((void *)0),
    zinfinitydef_alt};
#line 1086 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bnfGref_struct zinfinity  =    {(bnftype_enum )0, "zinfinity", (bnfdef_struct *)(& zinfinity_def), (flags )((void *)0),
    (int )((void *)0), (bnfref_struct *)((char *)0)};
#line 1020 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static bool lpctl_infinity(void) 
{ 
  struct infinity_struct *infinityspec ;
  lptols_struct *tols_dflt ;
  double infinity ;
  parse_any result ;
  char const   *rtnnme ;
  bool tmp ;
  int tmp___0 ;

  {
  {
#line 1049
  rtnnme = "lpctl_infinity";
#line 1088
  dy_exposeTolDefaults(& tols_dflt);
#line 1093
  rdrinit();
#line 1094
  tmp = parse(dy_cmdchn, & zinfinity, & result);
  }
#line 1094
  if ((int )tmp == 0) {
    {
#line 1095
    rdrclear();
#line 1096
    errmsg(240, rtnnme, "zinfinity");
    }
#line 1097
    return ((bool )0);
  }
  {
#line 1098
  infinityspec = (struct infinity_struct *)result.g;
#line 1099
  rdrclear();
  }
  {
#line 1106
  if (infinityspec->code == 1) {
#line 1106
    goto case_1;
  }
#line 1112
  if (infinityspec->code == 2) {
#line 1112
    goto case_2;
  }
#line 1116
  if (infinityspec->code == 3) {
#line 1116
    goto case_3;
  }
#line 1127
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1107
  dyio_outfmt(dy_logchn, dy_gtxecho, " IEEE (%g)", Infbits.fpdbl);
#line 1108
  infinity = Infbits.fpdbl;
#line 1109
  tmp___0 = finite(infinity);
  }
#line 1109
  if (tmp___0) {
    {
#line 1110
    warn(314, rtnnme, infinity);
    }
  }
#line 1111
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1113
  dyio_outfmt(dy_logchn, dy_gtxecho, " DBL_MAX (%g)", (double )1.79769313486231570815e+308L);
#line 1114
  infinity = (double )1.79769313486231570815e+308L;
  }
#line 1115
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1117
  dyio_outfmt(dy_logchn, dy_gtxecho, " %g", infinityspec->val);
#line 1118
  infinity = infinityspec->val;
  }
#line 1119
  if (infinity == (double )0) {
    {
#line 1120
    infinity = main_lptols->inf;
#line 1121
    warn(245, rtnnme, "infinity", infinity);
    }
  } else
#line 1123
  if (infinity < (double )0) {
    {
#line 1124
    errmsg(242, rtnnme, infinity, "infinity");
#line 1125
    infinity = tols_dflt->inf;
    }
  }
#line 1126
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1128
  free((void *)infinityspec);
  }
#line 1129
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1131
  main_lptols->inf = infinity;
#line 1132
  free((void *)infinityspec);
  }
#line 1134
  return ((bool )1);
}
}
#line 1208
cmd_retval dy_ctlopt(char const   *keywd ) ;
#line 1208 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry ctlkwds[42]  = 
#line 1208
  {      {"actconlim", 8, 8}, 
        {"actconlvl", 8, 9}, 
        {"active", 4, 1}, 
        {"actvarlim", 4, 2}, 
        {"antidegen", 2, 15}, 
        {"bogus", 1, 3}, 
        {"check", 2, 4}, 
        {"cold", 5, 5}, 
        {"coldbasis", 5, 6}, 
        {"coldvars", 5, 7}, 
        {"context", 3, 11}, 
        {"costz", 3, 13}, 
        {"dchk", 2, 14}, 
        {"deactconlvl", 3, 10}, 
        {"degenlite", 6, 16}, 
        {"degenpivs", 6, 17}, 
        {"dfeas", 2, 18}, 
        {"dualacttype", 5, 19}, 
        {"dualmultipiv", 5, 20}, 
        {"factor", 2, 21}, 
        {"final", 2, 22}, 
        {"forcecopy", 2, 12}, 
        {"fullsys", 2, 23}, 
        {"groom", 1, 24}, 
        {"idle", 2, 27}, 
        {"infinity", 2, 25}, 
        {"iters", 2, 26}, 
        {"load", 1, 28}, 
        {"patch", 2, 29}, 
        {"pchk", 2, 30}, 
        {"pfeas", 2, 31}, 
        {"pivot", 2, 32}, 
        {"primmultipiv", 5, 33}, 
        {"purgecon", 6, 34}, 
        {"purgevar", 6, 35}, 
        {"reframe", 1, 36}, 
        {"scaling", 4, 37}, 
        {"scan", 4, 38}, 
        {"swing", 2, 39}, 
        {"usedual", 1, 40}, 
        {"warm", 1, 41}, 
        {"zero", 1, 42}};
#line 1254 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numctlkwds  =    (int )(sizeof(ctlkwds) / sizeof(keytab_entry ));
#line 1261 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry groomkwds[3]  = {      {"abort", 1, 2}, 
        {"silent", 1, 0}, 
        {"warn", 1, 1}};
#line 1265 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numgroomkwds  =    (int )(sizeof(groomkwds) / sizeof(keytab_entry ));
#line 1271 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry basiskwds[3]  = {      {"architectural", 1, 3}, 
        {"logical", 1, 1}, 
        {"slack", 1, 2}};
#line 1275 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numbasiskwds  =    (int )(sizeof(basiskwds) / sizeof(keytab_entry ));
#line 1281 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry contextkwds[3]  = {      {"single", 1, 1}, 
        {"initial", 1, 2}, 
        {"bandc", 1, 3}};
#line 1285 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numcontextkwds  =    (int )(sizeof(contextkwds) / sizeof(keytab_entry ));
#line 1293 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry litekwds[6]  = {      {"alignedge", 6, 3}, 
        {"alignobj", 6, 2}, 
        {"perpedge", 5, 5}, 
        {"perpobj", 5, 4}, 
        {"pivot", 6, 1}, 
        {"pivotabort", 6, 0}};
#line 1300 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numlitekwds  =    (int )(sizeof(litekwds) / sizeof(keytab_entry ));
#line 1307 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static keytab_entry deactkwds[3]  = {      {"aggressive", 1, 1}, 
        {"fanatic", 1, 2}, 
        {"normal", 1, 0}};
#line 1311 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
static int numdeactkwds  =    (int )(sizeof(deactkwds) / sizeof(keytab_entry ));
#line 1139 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_options.c"
cmd_retval dy_ctlopt(char const   *keywd ) 
{ 
  char *what ;
  char cmdstr[50] ;
  int code ;
  int intdflt ;
  int intlb ;
  int intub ;
  int *intopt ;
  int numkwds ;
  double *toler ;
  double tolerdflt ;
  double dblopt ;
  bool booldflt ;
  bool *boolopt ;
  keytab_entry *kwds ;
  cmd_retval retval ;
  lpopts_struct *opts_lb ;
  lpopts_struct *opts_dflt ;
  lpopts_struct *opts_ub ;
  lptols_struct *tols_dflt ;
  char const   *rtnnme ;
  enum ctlcodes ctlcode ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 1186
  rtnnme = "dy_ctlopt";
#line 1316
  kwds = (keytab_entry *)((void *)0);
#line 1317
  numkwds = 0;
#line 1318
  intdflt = -2147483647;
#line 1319
  intlb = 2147483647;
#line 1320
  intub = -2147483647;
#line 1321
  intopt = (int *)((void *)0);
#line 1322
  toler = (double *)((void *)0);
#line 1323
  tolerdflt = QNaNbits___4.fpdbl;
#line 1324
  boolopt = (bool *)((void *)0);
#line 1328
  dy_exposeOptDefaults(& opts_lb, & opts_dflt, & opts_ub);
#line 1329
  dy_exposeTolDefaults(& tols_dflt);
#line 1333
  ctlcode = (enum ctlcodes )0;
#line 1334
  tmp = string_opt(& what);
  }
#line 1334
  if ((int )tmp == 1) {
    {
#line 1335
    code = ambig(what, ctlkwds, numctlkwds);
    }
#line 1336
    if (code < 0) {
#line 1337
      if (code < -1) {
        {
#line 1338
        errmsg(233, rtnnme, what);
        }
      } else {
        {
#line 1340
        errmsg(234, rtnnme, what);
        }
      }
    } else {
#line 1342
      ctlcode = (enum ctlcodes )code;
    }
  }
  {
#line 1348
  dyio_outfxd(cmdstr, - ((int )(sizeof(cmdstr) - 1UL)), (char )'l', "%s %s", keywd,
              what);
  }
  {
#line 1350
  if ((unsigned int )ctlcode == 2U) {
#line 1350
    goto case_2;
  }
#line 1356
  if ((unsigned int )ctlcode == 3U) {
#line 1356
    goto case_3;
  }
#line 1360
  if ((unsigned int )ctlcode == 4U) {
#line 1360
    goto case_4;
  }
#line 1366
  if ((unsigned int )ctlcode == 5U) {
#line 1366
    goto case_5;
  }
#line 1370
  if ((unsigned int )ctlcode == 6U) {
#line 1370
    goto case_6;
  }
#line 1378
  if ((unsigned int )ctlcode == 7U) {
#line 1378
    goto case_7;
  }
#line 1384
  if ((unsigned int )ctlcode == 8U) {
#line 1384
    goto case_8;
  }
#line 1390
  if ((unsigned int )ctlcode == 9U) {
#line 1390
    goto case_9;
  }
#line 1396
  if ((unsigned int )ctlcode == 11U) {
#line 1396
    goto case_11;
  }
#line 1404
  if ((unsigned int )ctlcode == 13U) {
#line 1404
    goto case_13;
  }
#line 1408
  if ((unsigned int )ctlcode == 12U) {
#line 1408
    goto case_12;
  }
#line 1412
  if ((unsigned int )ctlcode == 14U) {
#line 1412
    goto case_14;
  }
#line 1416
  if ((unsigned int )ctlcode == 15U) {
#line 1416
    goto case_15;
  }
#line 1420
  if ((unsigned int )ctlcode == 16U) {
#line 1420
    goto case_16;
  }
#line 1428
  if ((unsigned int )ctlcode == 17U) {
#line 1428
    goto case_17;
  }
#line 1434
  if ((unsigned int )ctlcode == 18U) {
#line 1434
    goto case_18;
  }
#line 1438
  if ((unsigned int )ctlcode == 19U) {
#line 1438
    goto case_19;
  }
#line 1444
  if ((unsigned int )ctlcode == 21U) {
#line 1444
    goto case_21;
  }
#line 1450
  if ((unsigned int )ctlcode == 23U) {
#line 1450
    goto case_23;
  }
#line 1454
  if ((unsigned int )ctlcode == 24U) {
#line 1454
    goto case_24;
  }
#line 1462
  if ((unsigned int )ctlcode == 26U) {
#line 1462
    goto case_26;
  }
#line 1468
  if ((unsigned int )ctlcode == 27U) {
#line 1468
    goto case_27;
  }
#line 1474
  if ((unsigned int )ctlcode == 20U) {
#line 1474
    goto case_20;
  }
#line 1480
  if ((unsigned int )ctlcode == 33U) {
#line 1480
    goto case_33;
  }
#line 1486
  if ((unsigned int )ctlcode == 29U) {
#line 1486
    goto case_29;
  }
#line 1490
  if ((unsigned int )ctlcode == 30U) {
#line 1490
    goto case_30;
  }
#line 1494
  if ((unsigned int )ctlcode == 31U) {
#line 1494
    goto case_31;
  }
#line 1498
  if ((unsigned int )ctlcode == 32U) {
#line 1498
    goto case_32;
  }
#line 1502
  if ((unsigned int )ctlcode == 34U) {
#line 1502
    goto case_34;
  }
#line 1506
  if ((unsigned int )ctlcode == 10U) {
#line 1506
    goto case_10;
  }
#line 1514
  if ((unsigned int )ctlcode == 35U) {
#line 1514
    goto case_35;
  }
#line 1518
  if ((unsigned int )ctlcode == 36U) {
#line 1518
    goto case_36;
  }
#line 1522
  if ((unsigned int )ctlcode == 37U) {
#line 1522
    goto case_37;
  }
#line 1528
  if ((unsigned int )ctlcode == 38U) {
#line 1528
    goto case_38;
  }
#line 1534
  if ((unsigned int )ctlcode == 39U) {
#line 1534
    goto case_39;
  }
#line 1538
  if ((unsigned int )ctlcode == 40U) {
#line 1538
    goto case_40;
  }
#line 1542
  if ((unsigned int )ctlcode == 41U) {
#line 1542
    goto case_41;
  }
#line 1546
  if ((unsigned int )ctlcode == 42U) {
#line 1546
    goto case_42;
  }
#line 1550
  if ((unsigned int )ctlcode == 1U) {
#line 1550
    goto case_1;
  }
#line 1556
  if ((unsigned int )ctlcode == 25U) {
#line 1556
    goto case_25;
  }
#line 1562
  if ((unsigned int )ctlcode == 28U) {
#line 1562
    goto case_28;
  }
#line 1568
  if ((unsigned int )ctlcode == 22U) {
#line 1568
    goto case_22;
  }
#line 1574
  goto switch_default;
  case_2: /* CIL Label */ 
#line 1351
  intopt = & main_lpopts->addvar;
#line 1352
  intdflt = opts_dflt->addvar;
#line 1353
  intlb = opts_lb->addvar;
#line 1354
  intub = opts_ub->addvar;
#line 1355
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1357
  toler = & main_lptols->bogus;
#line 1358
  tolerdflt = tols_dflt->bogus;
#line 1359
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1361
  intopt = & main_lpopts->check;
#line 1362
  intdflt = opts_dflt->check;
#line 1363
  intlb = opts_lb->check;
#line 1364
  intub = opts_ub->check;
#line 1365
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1367
  boolopt = & main_lpopts->forcecold;
#line 1368
  booldflt = opts_dflt->forcecold;
#line 1369
  goto switch_break;
  case_6: /* CIL Label */ 
#line 1371
  intopt = (int *)(& main_lpopts->coldbasis);
#line 1372
  intdflt = (int )opts_dflt->coldbasis;
#line 1373
  intlb = (int )opts_lb->coldbasis;
#line 1374
  intub = (int )opts_ub->coldbasis;
#line 1375
  numkwds = numbasiskwds;
#line 1376
  kwds = basiskwds;
#line 1377
  goto switch_break;
  case_7: /* CIL Label */ 
#line 1379
  intopt = & main_lpopts->coldvars;
#line 1380
  intdflt = opts_dflt->coldvars;
#line 1381
  intlb = opts_lb->coldvars;
#line 1382
  intub = opts_ub->coldvars;
#line 1383
  goto switch_break;
  case_8: /* CIL Label */ 
#line 1385
  intopt = & main_lpopts->con.actlim;
#line 1386
  intdflt = opts_dflt->con.actlim;
#line 1387
  intlb = opts_lb->con.actlim;
#line 1388
  intub = opts_ub->con.actlim;
#line 1389
  goto switch_break;
  case_9: /* CIL Label */ 
#line 1391
  intopt = & main_lpopts->con.actlvl;
#line 1392
  intdflt = opts_dflt->con.actlvl;
#line 1393
  intlb = opts_lb->con.actlvl;
#line 1394
  intub = opts_ub->con.actlvl;
#line 1395
  goto switch_break;
  case_11: /* CIL Label */ 
#line 1397
  intopt = (int *)(& main_lpopts->context);
#line 1398
  intdflt = (int )opts_dflt->context;
#line 1399
  intlb = (int )opts_lb->context;
#line 1400
  intub = (int )opts_ub->context;
#line 1401
  numkwds = numcontextkwds;
#line 1402
  kwds = contextkwds;
#line 1403
  goto switch_break;
  case_13: /* CIL Label */ 
#line 1405
  toler = & main_lptols->cost;
#line 1406
  tolerdflt = tols_dflt->cost;
#line 1407
  goto switch_break;
  case_12: /* CIL Label */ 
#line 1409
  boolopt = & main_lpopts->copyorigsys;
#line 1410
  booldflt = opts_dflt->copyorigsys;
#line 1411
  goto switch_break;
  case_14: /* CIL Label */ 
#line 1413
  toler = & main_lptols->dchk;
#line 1414
  tolerdflt = tols_dflt->dchk;
#line 1415
  goto switch_break;
  case_15: /* CIL Label */ 
#line 1417
  boolopt = & main_lpopts->degen;
#line 1418
  booldflt = opts_dflt->degen;
#line 1419
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1421
  intopt = & main_lpopts->degenlite;
#line 1422
  intdflt = opts_dflt->degenlite;
#line 1423
  intlb = opts_lb->degenlite;
#line 1424
  intub = opts_ub->degenlite;
#line 1425
  numkwds = numlitekwds;
#line 1426
  kwds = litekwds;
#line 1427
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1429
  intopt = & main_lpopts->degenpivlim;
#line 1430
  intdflt = opts_dflt->degenpivlim;
#line 1431
  intlb = opts_lb->degenpivlim;
#line 1432
  intub = opts_ub->degenpivlim;
#line 1433
  goto switch_break;
  case_18: /* CIL Label */ 
#line 1435
  toler = & main_lptols->dfeas_scale;
#line 1436
  tolerdflt = tols_dflt->dfeas_scale;
#line 1437
  goto switch_break;
  case_19: /* CIL Label */ 
#line 1439
  intopt = & main_lpopts->dualadd;
#line 1440
  intdflt = opts_dflt->dualadd;
#line 1441
  intlb = opts_lb->dualadd;
#line 1442
  intub = opts_ub->dualadd;
#line 1443
  goto switch_break;
  case_21: /* CIL Label */ 
#line 1445
  intopt = & main_lpopts->factor;
#line 1446
  intdflt = opts_dflt->factor;
#line 1447
  intlb = opts_lb->factor;
#line 1448
  intub = opts_ub->factor;
#line 1449
  goto switch_break;
  case_23: /* CIL Label */ 
#line 1451
  boolopt = & main_lpopts->fullsys;
#line 1452
  booldflt = opts_dflt->fullsys;
#line 1453
  goto switch_break;
  case_24: /* CIL Label */ 
#line 1455
  intopt = & main_lpopts->groom;
#line 1456
  intdflt = opts_dflt->groom;
#line 1457
  intlb = opts_lb->groom;
#line 1458
  intub = opts_ub->groom;
#line 1459
  numkwds = numgroomkwds;
#line 1460
  kwds = groomkwds;
#line 1461
  goto switch_break;
  case_26: /* CIL Label */ 
#line 1463
  intopt = & main_lpopts->iterlim;
#line 1464
  intdflt = opts_dflt->iterlim;
#line 1465
  intlb = opts_lb->iterlim;
#line 1466
  intub = opts_ub->iterlim;
#line 1467
  goto switch_break;
  case_27: /* CIL Label */ 
#line 1469
  intopt = & main_lpopts->idlelim;
#line 1470
  intdflt = opts_dflt->idlelim;
#line 1471
  intlb = opts_lb->idlelim;
#line 1472
  intub = opts_ub->idlelim;
#line 1473
  goto switch_break;
  case_20: /* CIL Label */ 
#line 1475
  intopt = & main_lpopts->dpsel.strat;
#line 1476
  intdflt = opts_dflt->dpsel.strat;
#line 1477
  intlb = opts_lb->dpsel.strat;
#line 1478
  intub = opts_ub->dpsel.strat;
#line 1479
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1481
  intopt = & main_lpopts->ppsel.strat;
#line 1482
  intdflt = opts_dflt->ppsel.strat;
#line 1483
  intlb = opts_lb->ppsel.strat;
#line 1484
  intub = opts_ub->ppsel.strat;
#line 1485
  goto switch_break;
  case_29: /* CIL Label */ 
#line 1487
  boolopt = & main_lpopts->patch;
#line 1488
  booldflt = opts_dflt->patch;
#line 1489
  goto switch_break;
  case_30: /* CIL Label */ 
#line 1491
  toler = & main_lptols->pchk;
#line 1492
  tolerdflt = tols_dflt->pchk;
#line 1493
  goto switch_break;
  case_31: /* CIL Label */ 
#line 1495
  toler = & main_lptols->pfeas_scale;
#line 1496
  tolerdflt = tols_dflt->pfeas_scale;
#line 1497
  goto switch_break;
  case_32: /* CIL Label */ 
#line 1499
  toler = & main_lptols->pivot;
#line 1500
  tolerdflt = tols_dflt->pivot;
#line 1501
  goto switch_break;
  case_34: /* CIL Label */ 
#line 1503
  toler = & main_lptols->purge;
#line 1504
  tolerdflt = tols_dflt->purge;
#line 1505
  goto switch_break;
  case_10: /* CIL Label */ 
#line 1507
  intopt = & main_lpopts->con.deactlvl;
#line 1508
  intdflt = opts_dflt->con.deactlvl;
#line 1509
  intlb = opts_lb->con.deactlvl;
#line 1510
  intub = opts_ub->con.deactlvl;
#line 1511
  numkwds = numdeactkwds;
#line 1512
  kwds = deactkwds;
#line 1513
  goto switch_break;
  case_35: /* CIL Label */ 
#line 1515
  toler = & main_lptols->purgevar;
#line 1516
  tolerdflt = tols_dflt->purgevar;
#line 1517
  goto switch_break;
  case_36: /* CIL Label */ 
#line 1519
  toler = & main_lptols->reframe;
#line 1520
  tolerdflt = tols_dflt->reframe;
#line 1521
  goto switch_break;
  case_37: /* CIL Label */ 
#line 1523
  intopt = & main_lpopts->scaling;
#line 1524
  intdflt = opts_dflt->scaling;
#line 1525
  intlb = opts_lb->scaling;
#line 1526
  intub = opts_ub->scaling;
#line 1527
  goto switch_break;
  case_38: /* CIL Label */ 
#line 1529
  intopt = & main_lpopts->scan;
#line 1530
  intdflt = opts_dflt->scan;
#line 1531
  intlb = opts_lb->scan;
#line 1532
  intub = opts_ub->scan;
#line 1533
  goto switch_break;
  case_39: /* CIL Label */ 
#line 1535
  toler = & main_lptols->swing;
#line 1536
  tolerdflt = tols_dflt->swing;
#line 1537
  goto switch_break;
  case_40: /* CIL Label */ 
#line 1539
  boolopt = & main_lpopts->usedual;
#line 1540
  booldflt = opts_dflt->usedual;
#line 1541
  goto switch_break;
  case_41: /* CIL Label */ 
#line 1543
  boolopt = & main_lpopts->forcewarm;
#line 1544
  booldflt = opts_dflt->forcewarm;
#line 1545
  goto switch_break;
  case_42: /* CIL Label */ 
#line 1547
  toler = & main_lptols->zero;
#line 1548
  tolerdflt = tols_dflt->zero;
#line 1549
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1551
  booldflt = lpctl_active();
  }
#line 1552
  if ((int )booldflt == 1) {
#line 1553
    return ((cmd_retval )0);
  } else {
#line 1555
    return ((cmd_retval )1);
  }
  case_25: /* CIL Label */ 
  {
#line 1557
  booldflt = lpctl_infinity();
  }
#line 1558
  if ((int )booldflt == 1) {
#line 1559
    return ((cmd_retval )0);
  } else {
#line 1561
    return ((cmd_retval )1);
  }
  case_28: /* CIL Label */ 
  {
#line 1563
  booldflt = lpctl_load();
  }
#line 1564
  if ((int )booldflt == 1) {
#line 1565
    return ((cmd_retval )0);
  } else {
#line 1567
    return ((cmd_retval )1);
  }
  case_22: /* CIL Label */ 
  {
#line 1569
  booldflt = lpctl_finpurge();
  }
#line 1570
  if ((int )booldflt == 1) {
#line 1571
    return ((cmd_retval )0);
  } else {
#line 1573
    return ((cmd_retval )1);
  }
  switch_default: /* CIL Label */ 
  {
#line 1575
  errmsg(236, rtnnme, "<what>", "keyword", keywd);
#line 1576
  strfree((char const   *)what);
  }
#line 1577
  return ((cmd_retval )1);
  switch_break: /* CIL Label */ ;
  }
#line 1587
  retval = (cmd_retval )1;
  {
#line 1601
  if ((unsigned int )ctlcode == 38U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 37U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 33U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 27U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 26U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 20U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 19U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 17U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 11U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 9U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 8U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 4U) {
#line 1601
    goto case_38___0;
  }
#line 1601
  if ((unsigned int )ctlcode == 2U) {
#line 1601
    goto case_38___0;
  }
#line 1614
  if ((unsigned int )ctlcode == 21U) {
#line 1614
    goto case_21___0;
  }
#line 1614
  if ((unsigned int )ctlcode == 7U) {
#line 1614
    goto case_21___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 41U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 40U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 29U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 23U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 15U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 12U) {
#line 1631
    goto case_41___0;
  }
#line 1631
  if ((unsigned int )ctlcode == 5U) {
#line 1631
    goto case_41___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 42U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 39U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 36U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 35U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 34U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 32U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 31U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 30U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 18U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 14U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 13U) {
#line 1648
    goto case_42___0;
  }
#line 1648
  if ((unsigned int )ctlcode == 3U) {
#line 1648
    goto case_42___0;
  }
#line 1661
  if ((unsigned int )ctlcode == 10U) {
#line 1661
    goto case_10___0;
  }
#line 1661
  if ((unsigned int )ctlcode == 16U) {
#line 1661
    goto case_10___0;
  }
#line 1661
  if ((unsigned int )ctlcode == 6U) {
#line 1661
    goto case_10___0;
  }
#line 1661
  if ((unsigned int )ctlcode == 24U) {
#line 1661
    goto case_10___0;
  }
#line 1675
  goto switch_default___0;
  case_38___0: /* CIL Label */ 
  case_37___0: /* CIL Label */ 
  case_33___0: /* CIL Label */ 
  case_27___0: /* CIL Label */ 
  case_26___0: /* CIL Label */ 
  case_20___0: /* CIL Label */ 
  case_19___0: /* CIL Label */ 
  case_17___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
  case_9___0: /* CIL Label */ 
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  {
#line 1602
  tmp___0 = integer_opt(intopt);
  }
#line 1602
  if ((int )tmp___0 == 1) {
#line 1603
    if (*intopt >= 0) {
#line 1604
      if (intub > 0) {
#line 1604
        if (*intopt > intub) {
          {
#line 1605
          warn(241, rtnnme, intlb, cmdstr, intub, *intopt, intub);
#line 1606
          *intopt = intub;
          }
        }
      }
    } else {
      {
#line 1608
      warn(243, rtnnme, cmdstr, intdflt);
      }
    }
#line 1609
    retval = (cmd_retval )0;
  } else {
    {
#line 1611
    errmsg(236, rtnnme, "<integer>", "parameter", keywd);
    }
  }
#line 1612
  goto switch_break___0;
  case_21___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
  {
#line 1615
  tmp___1 = integer_opt(intopt);
  }
#line 1615
  if ((int )tmp___1 == 1) {
#line 1616
    if (*intopt >= 0) {
#line 1617
      if (intub > 0) {
#line 1617
        if (*intopt > intub) {
          {
#line 1618
          warn(241, rtnnme, intlb, cmdstr, intub, *intopt, intub);
          }
        }
      }
    } else {
      {
#line 1620
      warn(243, rtnnme, cmdstr, intdflt);
      }
    }
#line 1621
    retval = (cmd_retval )0;
  } else {
    {
#line 1623
    errmsg(236, rtnnme, "<integer>", "parameter", keywd);
    }
  }
#line 1624
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
  case_40___0: /* CIL Label */ 
  case_29___0: /* CIL Label */ 
  case_23___0: /* CIL Label */ 
  case_15___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  {
#line 1632
  tmp___2 = bool_opt(boolopt);
  }
#line 1632
  if ((int )tmp___2 == 1) {
#line 1633
    retval = (cmd_retval )0;
  } else {
    {
#line 1635
    errmsg(236, rtnnme, "<bool>", "parameter", keywd);
    }
  }
#line 1636
  goto switch_break___0;
  case_42___0: /* CIL Label */ 
  case_39___0: /* CIL Label */ 
  case_36___0: /* CIL Label */ 
  case_35___0: /* CIL Label */ 
  case_34___0: /* CIL Label */ 
  case_32___0: /* CIL Label */ 
  case_31___0: /* CIL Label */ 
  case_30___0: /* CIL Label */ 
  case_18___0: /* CIL Label */ 
  case_14___0: /* CIL Label */ 
  case_13___0: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 1649
  tmp___3 = double_opt(& dblopt);
  }
#line 1649
  if ((int )tmp___3 == 1) {
#line 1650
    if (dblopt <= (double )0) {
      {
#line 1651
      warn(245, rtnnme, cmdstr, tolerdflt);
      }
    } else {
#line 1653
      *toler = dblopt;
    }
#line 1654
    retval = (cmd_retval )0;
  } else {
    {
#line 1656
    errmsg(236, rtnnme, "<double>", "parameter", keywd);
    }
  }
#line 1657
  goto switch_break___0;
  case_10___0: /* CIL Label */ 
  case_16___0: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
  case_24___0: /* CIL Label */ 
  {
#line 1662
  tmp___4 = string_opt(& what);
  }
#line 1662
  if ((int )tmp___4 == 1) {
    {
#line 1663
    code = ambig(what, kwds, numkwds);
    }
#line 1664
    if (code < 0) {
#line 1665
      if (code < -1) {
        {
#line 1666
        errmsg(233, rtnnme, what);
        }
      } else {
        {
#line 1668
        errmsg(234, rtnnme, what);
        }
      }
    } else {
#line 1670
      *intopt = code;
#line 1671
      retval = (cmd_retval )0;
    }
  } else {
    {
#line 1673
    errmsg(236, rtnnme, "<string>", "parameter", cmdstr);
    }
  }
#line 1674
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1676
  errmsg(1, rtnnme, 1676);
  }
#line 1677
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1679
  strfree((char const   *)what);
  }
#line 1681
  return (retval);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_retained ;
#line 1731
dyret_enum dy_coldstart(consys_struct *orig_sys ) ;
#line 1731
dyret_enum dy_crash(void) ;
#line 1824
lpret_enum dy_primal(void) ;
#line 1842
lpret_enum dy_dual(void) ;
#line 1860
lpret_enum dylp(lpprob_struct *orig_lp , lpopts_struct *orig_opts , lptols_struct *orig_tols ,
                lpstats_struct *orig_stats ) ;
#line 1873
void dy_pseinit(void) ;
#line 1876
void dy_finishup(lpprob_struct *orig_lp , dyphase_enum phase ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
lp_struct *dy_lp  =    (lp_struct *)((void *)0);
#line 98 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
consys_struct *dy_sys  =    (consys_struct *)((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
lpopts_struct *dy_opts  =    (lpopts_struct *)((void *)0);
#line 100 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
lptols_struct *dy_tols  =    (lptols_struct *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_actvars  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_actcons  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_origvars  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_origcons  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_basis  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_var2basis  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_brkout  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_degenset  =    (int *)((void *)0);
#line 104 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
int *dy_ddegenset  =    (int *)((void *)0);
#line 113 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
flags *dy_status  =    (flags *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_x  =    (double *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_xbasic  =    (double *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_y  =    (double *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_gamma  =    (double *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_cbar  =    (double *)((void *)0);
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
double *dy_rho  =    (double *)((void *)0);
#line 120 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
bool *dy_frame  =    (bool *)((void *)0);
#line 128 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
bool dy_retained  =    (bool )0;
#line 138 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
static void updateOptsAndTols(lpopts_struct *client_opts , lptols_struct *client_tols ) 
{ 
  lptols_struct lcl_tols ;
  lpopts_struct lcl_opts ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 184
  if ((int )dy_retained == 1) {
    {
#line 185
    memcpy((void */* __restrict  */)(& lcl_tols), (void const   */* __restrict  */)dy_tols,
           sizeof(lptols_struct ));
#line 186
    memcpy((void */* __restrict  */)(& lcl_opts), (void const   */* __restrict  */)dy_opts,
           sizeof(lpopts_struct ));
    }
  } else {
    {
#line 188
    tmp = malloc(sizeof(lptols_struct ));
#line 188
    dy_tols = (lptols_struct *)tmp;
#line 189
    tmp___0 = malloc(sizeof(lpopts_struct ));
#line 189
    dy_opts = (lpopts_struct *)tmp___0;
    }
  }
  {
#line 193
  memcpy((void */* __restrict  */)dy_tols, (void const   */* __restrict  */)client_tols,
         sizeof(lptols_struct ));
#line 194
  memcpy((void */* __restrict  */)dy_opts, (void const   */* __restrict  */)client_opts,
         sizeof(lpopts_struct ));
  }
#line 200
  if ((int )dy_retained == 1) {
#line 201
    dy_opts->dpsel.strat = lcl_opts.dpsel.strat;
#line 202
    dy_tols->pfeas = lcl_tols.pfeas;
#line 203
    dy_tols->dfeas = lcl_tols.dfeas;
  } else {
#line 205
    if (dy_tols->pfeas <= (double )0) {
#line 206
      dy_tols->pfeas = dy_tols->pfeas_scale * dy_tols->zero;
    }
#line 207
    if (dy_tols->dfeas <= (double )0) {
#line 208
      dy_tols->dfeas = dy_tols->dfeas_scale * dy_tols->cost;
    }
  }
#line 210
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
static dyphase_enum addcon_nextphase(int actcnt ) 
{ 
  dyphase_enum retval ;
  flags chkflgs ;
  char const   *rtnnme ;
  dyret_enum tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 230
  retval = (dyphase_enum )0;
#line 231
  chkflgs = (flags )(1 | (1 << 2));
#line 232
  rtnnme = "addcon_nextphase";
#line 242
  if (actcnt < 0) {
#line 242
    return ((dyphase_enum )0);
  }
  {
#line 245
  if ((unsigned int )dy_lp->simplex.active == 3U) {
#line 245
    goto case_3;
  }
#line 278
  if ((unsigned int )dy_lp->simplex.active == 2U) {
#line 278
    goto case_2___0;
  }
#line 311
  if ((unsigned int )dy_lp->simplex.active == 4U) {
#line 311
    goto case_4;
  }
#line 340
  goto switch_default___2;
  case_3: /* CIL Label */ 
  {
#line 247
  if ((int )dy_lp->lpret == 1) {
#line 247
    goto case_1;
  }
#line 253
  if ((int )dy_lp->lpret == 2) {
#line 253
    goto case_2;
  }
#line 262
  if ((int )dy_lp->lpret == 3) {
#line 262
    goto case_3___0;
  }
#line 269
  if ((int )dy_lp->lpret == 11) {
#line 269
    goto case_11;
  }
#line 275
  goto switch_default;
  case_1: /* CIL Label */ 
#line 248
  if (actcnt == 0) {
#line 249
    retval = (dyphase_enum )14;
  } else {
#line 251
    retval = (dyphase_enum )8;
  }
#line 252
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 254
  if (actcnt == 0) {
#line 255
    if (dy_lp->sys.cons.loadable > 0) {
#line 256
      retval = (dyphase_enum )13;
    } else {
#line 258
      retval = (dyphase_enum )14;
    }
  } else {
#line 260
    retval = dy_lp->simplex.next;
  }
#line 261
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 263
  if (actcnt == 0) {
#line 264
    retval = (dyphase_enum )3;
#line 265
    dy_lp->simplex.next = (dyphase_enum )3;
  } else {
#line 267
    retval = dy_lp->simplex.next;
  }
#line 268
  goto switch_break___0;
  case_11: /* CIL Label */ 
#line 270
  if (actcnt == 0) {
#line 271
    retval = (dyphase_enum )13;
  } else {
#line 273
    retval = (dyphase_enum )8;
  }
#line 274
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 276
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 277
  goto switch_break;
  case_2___0: /* CIL Label */ 
  {
#line 280
  if ((int )dy_lp->lpret == 2) {
#line 280
    goto case_2___1;
  }
#line 287
  if ((int )dy_lp->lpret == 3) {
#line 287
    goto case_3___1;
  }
#line 294
  if ((int )dy_lp->lpret == 11) {
#line 294
    goto case_11___0;
  }
#line 301
  if ((int )dy_lp->lpret == 6) {
#line 301
    goto case_6;
  }
#line 301
  if ((int )dy_lp->lpret == 10) {
#line 301
    goto case_6;
  }
#line 308
  goto switch_default___0;
  case_2___1: /* CIL Label */ 
#line 281
  if (actcnt == 0) {
#line 282
    retval = (dyphase_enum )13;
  } else {
#line 284
    retval = (dyphase_enum )2;
#line 285
    dy_lp->simplex.next = (dyphase_enum )2;
  }
#line 286
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 288
  if (actcnt == 0) {
#line 289
    retval = (dyphase_enum )2;
#line 290
    dy_lp->simplex.next = (dyphase_enum )2;
  } else {
#line 292
    retval = dy_lp->simplex.next;
  }
#line 293
  goto switch_break___1;
  case_11___0: /* CIL Label */ 
#line 295
  if (actcnt == 0) {
#line 296
    retval = (dyphase_enum )13;
  } else {
#line 298
    retval = (dyphase_enum )8;
  }
#line 299
  goto switch_break___1;
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 302
  if (actcnt == 0) {
#line 303
    retval = (dyphase_enum )11;
  } else {
#line 305
    retval = (dyphase_enum )2;
#line 306
    dy_lp->simplex.next = (dyphase_enum )2;
  }
#line 307
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 309
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 310
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 313
  if ((int )dy_lp->lpret == 1) {
#line 313
    goto case_1___0;
  }
#line 319
  if ((int )dy_lp->lpret == 3) {
#line 319
    goto case_3___2;
  }
#line 330
  if ((int )dy_lp->lpret == 6) {
#line 330
    goto case_6___0;
  }
#line 330
  if ((int )dy_lp->lpret == 10) {
#line 330
    goto case_6___0;
  }
#line 337
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
#line 314
  if (actcnt == 0) {
#line 315
    retval = (dyphase_enum )14;
  } else {
#line 317
    retval = (dyphase_enum )6;
  }
#line 318
  goto switch_break___2;
  case_3___2: /* CIL Label */ 
#line 320
  if (actcnt == 0) {
#line 321
    if (dy_lp->sys.vars.loadable <= 0) {
#line 322
      retval = (dyphase_enum )2;
#line 323
      dy_lp->simplex.next = (dyphase_enum )2;
    } else {
#line 325
      retval = (dyphase_enum )7;
    }
  } else {
#line 327
    retval = dy_lp->simplex.next;
  }
#line 328
  goto switch_break___2;
  case_6___0: /* CIL Label */ 
  case_10___0: /* CIL Label */ 
#line 331
  if (actcnt == 0) {
#line 332
    retval = (dyphase_enum )12;
  } else {
#line 334
    retval = (dyphase_enum )4;
#line 335
    dy_lp->simplex.next = (dyphase_enum )4;
  }
#line 336
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
#line 338
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 339
  goto switch_break;
  switch_default___2: /* CIL Label */ 
#line 341
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 343
  if ((unsigned int )retval == 4U) {
#line 343
    if ((int )dy_opts->usedual == 0) {
#line 344
      retval = (dyphase_enum )2;
#line 345
      dy_lp->simplex.next = (dyphase_enum )2;
    }
  }
#line 351
  if ((unsigned int )dy_lp->simplex.next == 2U) {
    {
#line 352
    tmp = dy_accchk(& chkflgs);
    }
#line 352
    if ((int )tmp != 1) {
#line 353
      retval = (dyphase_enum )0;
    }
  }
#line 355
  if ((unsigned int )retval == 0U) {
    {
#line 356
    tmp___0 = dy_prtlpphase(dy_lp->simplex.next, (bool )1);
#line 356
    tmp___1 = dy_prtlpret(dy_lp->lpret);
#line 356
    tmp___2 = dy_prtlpphase(dy_lp->simplex.active, (bool )1);
#line 356
    tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 356
    errmsg(435, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, actcnt, "constraints",
           tmp___2, tmp___1, tmp___0);
    }
  }
#line 369
  return (retval);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
static dyphase_enum addvar_nextphase(int actcnt ) 
{ 
  dyphase_enum retval ;
  flags chkflgs ;
  char const   *rtnnme ;
  dyret_enum tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 389
  retval = (dyphase_enum )0;
#line 390
  chkflgs = (flags )(1 | (1 << 2));
#line 391
  rtnnme = "addvar_nextphase";
#line 393
  if (actcnt < 0) {
#line 393
    return ((dyphase_enum )0);
  }
  {
#line 396
  if ((unsigned int )dy_lp->simplex.active == 2U) {
#line 396
    goto case_2;
  }
#line 423
  if ((unsigned int )dy_lp->simplex.active == 3U) {
#line 423
    goto case_3;
  }
#line 451
  if ((unsigned int )dy_lp->simplex.active == 4U) {
#line 451
    goto case_4___0;
  }
#line 484
  goto switch_default___2;
  case_2: /* CIL Label */ 
  {
#line 398
  if ((int )dy_lp->lpret == 4) {
#line 398
    goto case_4;
  }
#line 406
  if ((int )dy_lp->lpret == 6) {
#line 406
    goto case_6;
  }
#line 406
  if ((int )dy_lp->lpret == 10) {
#line 406
    goto case_6;
  }
#line 416
  if ((int )dy_lp->lpret == 11) {
#line 416
    goto case_11;
  }
#line 420
  goto switch_default;
  case_4: /* CIL Label */ 
#line 399
  if (actcnt == 0) {
#line 400
    retval = (dyphase_enum )14;
  } else {
#line 402
    retval = (dyphase_enum )2;
#line 403
    dy_lp->simplex.next = (dyphase_enum )2;
  }
#line 404
  goto switch_break___0;
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 407
  if (actcnt == 0) {
#line 408
    if (dy_lp->sys.cons.loadable > 0) {
#line 409
      retval = (dyphase_enum )9;
    } else {
#line 411
      retval = (dyphase_enum )11;
    }
  } else {
#line 413
    retval = (dyphase_enum )2;
#line 414
    dy_lp->simplex.next = (dyphase_enum )2;
  }
#line 415
  goto switch_break___0;
  case_11: /* CIL Label */ 
#line 417
  retval = (dyphase_enum )4;
#line 418
  dy_lp->simplex.next = (dyphase_enum )4;
#line 419
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 421
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 422
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 425
  if ((int )dy_lp->lpret == 1) {
#line 425
    goto case_1;
  }
#line 437
  if ((int )dy_lp->lpret == 6) {
#line 437
    goto case_6___0;
  }
#line 437
  if ((int )dy_lp->lpret == 10) {
#line 437
    goto case_6___0;
  }
#line 444
  if ((int )dy_lp->lpret == 11) {
#line 444
    goto case_11___0;
  }
#line 448
  goto switch_default___0;
  case_1: /* CIL Label */ 
#line 426
  if ((unsigned int )dy_lp->simplex.next == 3U) {
#line 427
    if (actcnt == 0) {
#line 428
      retval = (dyphase_enum )9;
#line 429
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 431
      retval = (dyphase_enum )3;
    }
  } else
#line 433
  if ((unsigned int )dy_lp->simplex.next == 4U) {
#line 434
    retval = (dyphase_enum )4;
  }
#line 435
  goto switch_break___1;
  case_6___0: /* CIL Label */ 
  case_10___0: /* CIL Label */ 
#line 438
  if (actcnt == 0) {
#line 439
    retval = (dyphase_enum )11;
  } else {
#line 441
    retval = (dyphase_enum )3;
#line 442
    dy_lp->simplex.next = (dyphase_enum )3;
  }
#line 443
  goto switch_break___1;
  case_11___0: /* CIL Label */ 
#line 445
  retval = (dyphase_enum )4;
#line 446
  dy_lp->simplex.next = (dyphase_enum )4;
#line 447
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 449
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 450
  goto switch_break;
  case_4___0: /* CIL Label */ 
  {
#line 453
  if ((int )dy_lp->lpret == 1) {
#line 453
    goto case_1___0;
  }
#line 464
  if ((int )dy_lp->lpret == 4) {
#line 464
    goto case_4___1;
  }
#line 468
  if ((int )dy_lp->lpret == 3) {
#line 468
    goto case_3___0;
  }
#line 475
  if ((int )dy_lp->lpret == 9) {
#line 475
    goto case_9;
  }
#line 478
  if ((int )dy_lp->lpret == 12) {
#line 478
    goto case_12;
  }
#line 481
  goto switch_default___1;
  case_1___0: /* CIL Label */ 
#line 454
  if ((unsigned int )dy_lp->simplex.next == 3U) {
#line 455
    if (actcnt == 0) {
#line 456
      retval = (dyphase_enum )9;
#line 457
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 459
      retval = (dyphase_enum )5;
    }
  } else
#line 461
  if ((unsigned int )dy_lp->simplex.next == 4U) {
#line 462
    retval = (dyphase_enum )4;
  }
#line 463
  goto switch_break___2;
  case_4___1: /* CIL Label */ 
#line 465
  retval = (dyphase_enum )2;
#line 466
  dy_lp->simplex.next = (dyphase_enum )2;
#line 467
  goto switch_break___2;
  case_3___0: /* CIL Label */ 
#line 469
  if (actcnt == 0) {
#line 469
    if ((unsigned int )dy_lp->simplex.next != 2U) {
#line 470
      dy_lp->simplex.next = (dyphase_enum )2;
#line 471
      retval = (dyphase_enum )7;
    } else {
#line 473
      retval = dy_lp->simplex.next;
    }
  } else {
#line 473
    retval = dy_lp->simplex.next;
  }
#line 474
  goto switch_break___2;
  case_9: /* CIL Label */ 
#line 476
  retval = dy_lp->simplex.next;
#line 477
  goto switch_break___2;
  case_12: /* CIL Label */ 
#line 479
  retval = (dyphase_enum )5;
#line 480
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
#line 482
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 483
  goto switch_break;
  switch_default___2: /* CIL Label */ 
#line 485
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 491
  if ((unsigned int )dy_lp->simplex.next == 2U) {
    {
#line 492
    tmp = dy_accchk(& chkflgs);
    }
#line 492
    if ((int )tmp != 1) {
#line 493
      retval = (dyphase_enum )0;
    }
  }
#line 495
  if ((unsigned int )retval == 0U) {
    {
#line 496
    tmp___0 = dy_prtlpphase(dy_lp->simplex.next, (bool )1);
#line 496
    tmp___1 = dy_prtlpret(dy_lp->lpret);
#line 496
    tmp___2 = dy_prtlpphase(dy_lp->simplex.active, (bool )1);
#line 496
    tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 496
    errmsg(435, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, actcnt, "variables",
           tmp___2, tmp___1, tmp___0);
    }
  }
#line 502
  return (retval);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
static dyphase_enum initial_activation(lpprob_struct *orig_lp ) 
{ 
  int xindx ;
  int xipos ;
  int conresult ;
  int varresult ;
  flags xistatus ;
  flags calcflgs ;
  consys_struct *orig_sys ;
  dyret_enum retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 526
  rtnnme = "initial_activation";
#line 528
  orig_sys = orig_lp->consys;
#line 529
  conresult = -1;
#line 530
  varresult = -1;
#line 536
  if (orig_lp->ctlopts & (unsigned int )(1 << 8)) {
#line 536
    tmp___3 = 1;
  } else {
#line 536
    tmp___3 = 0;
  }
#line 536
  if (tmp___3) {
#line 539
    if (dy_opts->print.conmgmt >= 1) {
      {
#line 540
      tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 540
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: pre-activating violated constraints, ",
                  dy_sys->nme, tmp, dy_lp->tot.iters);
#line 544
      dyio_outfmt(dy_logchn, dy_gtxecho, "obj = %g ...", dy_lp->z);
      }
    }
    {
#line 546
    conresult = dy_activateCons(orig_sys, (bool )0);
    }
#line 547
    if (conresult > 0) {
      {
#line 548
      calcflgs = (flags )(((1 | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 549
      retval = dy_accchk(& calcflgs);
      }
#line 550
      if ((int )retval != 1) {
        {
#line 551
        tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 551
        errmsg(304, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters);
        }
#line 553
        return ((dyphase_enum )0);
      }
#line 554
      if (calcflgs & 1U) {
#line 554
        tmp___2 = 0;
      } else {
#line 554
        tmp___2 = 1;
      }
#line 554
      if (tmp___2) {
#line 555
        dy_lp->simplex.next = (dyphase_enum )3;
      } else {
#line 557
        if (calcflgs & (unsigned int )(1 << 3)) {
#line 557
          tmp___1 = 0;
        } else {
#line 557
          tmp___1 = 1;
        }
#line 557
        if (tmp___1) {
#line 558
          dy_lp->simplex.next = (dyphase_enum )4;
        } else {
#line 560
          dy_lp->simplex.next = (dyphase_enum )2;
        }
      }
    }
  } else {
#line 562
    conresult = 0;
  }
#line 569
  if (conresult >= 0) {
#line 569
    if (orig_lp->ctlopts & (unsigned int )(1 << 7)) {
#line 569
      tmp___8 = 1;
    } else {
#line 569
      tmp___8 = 0;
    }
#line 569
    if (tmp___8) {
#line 572
      if (dy_opts->print.varmgmt >= 1) {
        {
#line 573
        tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 573
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: [%s](%s)%d: pre-activating variables, ",
                    rtnnme, dy_sys->nme, tmp___4, dy_lp->tot.iters);
#line 577
        tmp___5 = dy_prtlpphase(dy_lp->simplex.next, (bool )1);
#line 577
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s rules, obj = %g ...", tmp___5, dy_lp->z);
        }
      }
#line 580
      if ((unsigned int )dy_lp->simplex.next == 2U) {
        {
#line 581
        varresult = dy_activateVars(orig_sys, (int *)((void *)0));
        }
      } else
#line 580
      if ((unsigned int )dy_lp->simplex.next == 3U) {
        {
#line 581
        varresult = dy_activateVars(orig_sys, (int *)((void *)0));
        }
      } else {
#line 583
        xipos = 1;
        {
#line 583
        while (1) {
          while_continue: /* CIL Label */ ;
#line 583
          if (! (xipos <= dy_sys->concnt)) {
#line 583
            goto while_break;
          }
#line 584
          xindx = *(dy_basis + xipos);
#line 585
          xistatus = *(dy_status + xindx);
#line 586
          if (xistatus & (unsigned int )((1 << 11) | (1 << 10))) {
#line 586
            tmp___7 = 1;
          } else {
#line 586
            tmp___7 = 0;
          }
#line 586
          if (tmp___7) {
#line 587
            if (xistatus & (unsigned int )(1 << 10)) {
#line 587
              tmp___6 = 1;
            } else {
#line 587
              tmp___6 = 0;
            }
#line 587
            if (tmp___6) {
#line 587
              xindx = - xindx;
            }
            {
#line 588
            dy_lp->ubnd.ndx = xindx;
#line 589
            varresult = dy_dualaddvars(orig_sys);
            }
#line 590
            if (varresult < 0) {
#line 590
              goto while_break;
            }
          }
#line 583
          xipos ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 591
        dy_lp->ubnd.ndx = 0;
      }
    }
  }
#line 596
  if (conresult < 0) {
#line 597
    return ((dyphase_enum )0);
  } else
#line 596
  if (varresult < 0) {
#line 597
    return ((dyphase_enum )0);
  } else {
#line 599
    return (dy_lp->simplex.next);
  }
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
static bool commonstart(start_enum start ) 
{ 
  char const   *rtnnme ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
#line 617
  rtnnme = "commonstart";
#line 623
  if ((unsigned int )start != 2U) {
    {
#line 624
    tmp = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_brkout));
    }
#line 624
    if ((int )tmp == 0) {
      {
#line 626
      errmsg(100, rtnnme, dy_sys->nme, "breakout vector");
      }
#line 627
      return ((bool )0);
    }
    {
#line 628
    tmp___0 = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_degenset));
    }
#line 628
    if ((int )tmp___0 == 0) {
      {
#line 630
      errmsg(100, rtnnme, dy_sys->nme, "primal degenerate set vector");
      }
#line 631
      return ((bool )0);
    }
    {
#line 632
    tmp___1 = consys_attach(dy_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_ddegenset));
    }
#line 632
    if ((int )tmp___1 == 0) {
      {
#line 634
      errmsg(100, rtnnme, dy_sys->nme, "dual degenerate set vector");
      }
#line 635
      return ((bool )0);
    }
  }
#line 637
  dy_lp->degen = 0;
#line 641
  if ((unsigned int )start != 2U) {
    {
#line 642
    dy_initpivrej(dy_sys->varcnt / 10);
    }
  }
#line 647
  if ((unsigned int )start != 2U) {
    {
#line 648
    tmp___2 = consys_attach(dy_sys, 1U << 1, (int )sizeof(double ), (void **)(& dy_gamma));
    }
#line 648
    if ((int )tmp___2 == 0) {
      {
#line 650
      errmsg(100, rtnnme, dy_sys->nme, "column norm vector");
      }
#line 651
      return ((bool )0);
    }
    {
#line 652
    tmp___3 = consys_attach(dy_sys, 1U << 1, (int )sizeof(bool ), (void **)(& dy_frame));
    }
#line 652
    if ((int )tmp___3 == 0) {
      {
#line 654
      errmsg(100, rtnnme, dy_sys->nme, "reference frame vector");
      }
#line 655
      return ((bool )0);
    }
    {
#line 656
    tmp___4 = consys_attach(dy_sys, 1U << 2, (int )sizeof(double ), (void **)(& dy_rho));
    }
#line 656
    if ((int )tmp___4 == 0) {
      {
#line 658
      errmsg(100, rtnnme, dy_sys->nme, "basis inverse row norm");
      }
#line 659
      return ((bool )0);
    }
  }
#line 666
  if ((unsigned int )dy_lp->simplex.next == 4U) {
    {
#line 667
    dy_dseinit();
#line 668
    dy_lp->simplex.init_dse = (bool )0;
#line 669
    dy_lp->simplex.init_pse = (bool )1;
    }
  } else {
    {
#line 671
    dy_pseinit();
#line 672
    dy_lp->simplex.init_pse = (bool )0;
#line 673
    dy_lp->simplex.init_dse = (bool )1;
    }
  }
#line 675
  return ((bool )1);
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.c"
lpret_enum dylp(lpprob_struct *orig_lp , lpopts_struct *orig_opts , lptols_struct *orig_tols ,
                lpstats_struct *orig_stats ) 
{ 
  int cnt ;
  dyphase_enum phase ;
  double tol ;
  lpret_enum lpresult ;
  flags checks ;
  consys_struct *orig_sys ;
  char const   *rtnnme ;
  start_enum start ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;
  dyret_enum tmp___9 ;
  char const   *tmp___10 ;
  dyret_enum tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  dyret_enum tmp___14 ;
  dyret_enum tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  bool tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  bool tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  double tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  double tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  dyret_enum tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  double tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char const   *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  bool tmp___47 ;
  char const   *tmp___48 ;
  bool tmp___49 ;

  {
#line 724
  rtnnme = "dylp";
#line 753
  if ((unsigned int )orig_lp->phase == 14U) {
#line 753
    if (orig_lp->ctlopts & (unsigned int )(1 << 1)) {
#line 753
      tmp = 1;
    } else {
#line 753
      tmp = 0;
    }
#line 753
    if (tmp) {
#line 754
      if ((int )dy_retained == 1) {
        {
#line 755
        dy_finishup(orig_lp, (dyphase_enum )0);
        }
      }
#line 756
      return (orig_lp->lpret);
    }
  }
#line 763
  orig_sys = orig_lp->consys;
#line 764
  if (orig_sys->opts & (1U << 4)) {
#line 764
    tmp___0 = 1;
  } else {
#line 764
    tmp___0 = 0;
  }
#line 764
  if (tmp___0) {
    {
#line 766
    errmsg(115, rtnnme, orig_sys->nme);
    }
#line 767
    if ((int )dy_retained == 1) {
#line 770
      if (orig_opts->print.major >= 1) {
        {
#line 771
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  Attempting cleanup of retained structures for %2.",
                    orig_sys->nme);
        }
      }
      {
#line 775
      orig_lp->phase = (dyphase_enum )14;
#line 776
      orig_lp->ctlopts |= (unsigned int )(1 << 1);
#line 777
      dy_finishup(orig_lp, (dyphase_enum )0);
      }
    }
#line 778
    return ((lpret_enum )-1);
  }
#line 812
  if ((int )orig_opts->forcecold == 1) {
#line 813
    start = (start_enum )0;
#line 814
    phase = (dyphase_enum )0;
  } else
#line 816
  if ((int )orig_opts->forcewarm == 1) {
#line 817
    start = (start_enum )1;
  } else {
#line 819
    start = (start_enum )2;
#line 820
    if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 820
      tmp___1 = 0;
    } else {
#line 820
      tmp___1 = 1;
    }
#line 820
    if (tmp___1) {
      {
#line 821
      errmsg(396, rtnnme, orig_sys->nme, "hot start");
      }
#line 822
      return ((lpret_enum )0);
    } else
#line 820
    if ((int )dy_retained == 0) {
      {
#line 821
      errmsg(396, rtnnme, orig_sys->nme, "hot start");
      }
#line 822
      return ((lpret_enum )0);
    }
#line 823
    if (! ((int )orig_lp->lpret == 1)) {
#line 823
      if (! ((int )orig_lp->lpret == 2)) {
#line 823
        if (! ((int )orig_lp->lpret == 4)) {
#line 823
          if (! ((int )orig_lp->lpret == 7)) {
            {
#line 825
            tmp___2 = dy_prtlpret(orig_lp->lpret);
#line 825
            errmsg(395, rtnnme, orig_sys->nme, tmp___2);
            }
#line 826
            return ((lpret_enum )0);
          }
        }
      }
    }
  }
#line 829
  if (orig_opts->print.major >= 1) {
#line 830
    if ((unsigned int )start == 2U) {
#line 830
      tmp___4 = "hot";
    } else {
#line 830
      if ((unsigned int )start == 1U) {
#line 830
        tmp___3 = "warm";
      } else {
#line 830
        tmp___3 = "cold";
      }
#line 830
      tmp___4 = tmp___3;
    }
    {
#line 830
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %s start for lp %s.", tmp___4, orig_sys->nme);
    }
  }
#line 857
  orig_lp->phase = (dyphase_enum )1;
#line 858
  orig_lp->lpret = (lpret_enum )0;
#line 859
  lpresult = (lpret_enum )0;
#line 860
  if ((int )dy_retained == 1) {
#line 860
    if ((unsigned int )start != 2U) {
      {
#line 861
      checks = orig_lp->ctlopts & 1U;
#line 862
      orig_lp->ctlopts &= 4294967294U;
#line 863
      dy_finishup(orig_lp, (dyphase_enum )1);
#line 864
      orig_lp->ctlopts |= checks;
      }
    }
  }
  {
#line 865
  orig_lp->ctlopts &= (unsigned int )(~ (1 << 11));
#line 875
  updateOptsAndTols(orig_opts, orig_tols);
  }
#line 876
  if ((unsigned int )start != 2U) {
    {
#line 877
    dy_sys = (consys_struct *)((void *)0);
#line 878
    dy_actvars = (int *)((void *)0);
#line 879
    dy_actcons = (int *)((void *)0);
#line 880
    dy_origvars = (int *)((void *)0);
#line 881
    dy_origcons = (int *)((void *)0);
#line 882
    dy_basis = (int *)((void *)0);
#line 883
    dy_var2basis = (int *)((void *)0);
#line 884
    dy_status = (flags *)((void *)0);
#line 885
    dy_x = (double *)((void *)0);
#line 886
    dy_xbasic = (double *)((void *)0);
#line 887
    dy_y = (double *)((void *)0);
#line 888
    dy_cbar = (double *)((void *)0);
#line 889
    dy_gamma = (double *)((void *)0);
#line 890
    dy_frame = (bool *)((void *)0);
#line 891
    dy_rho = (double *)((void *)0);
#line 892
    dy_brkout = (int *)((void *)0);
#line 893
    dy_degenset = (int *)((void *)0);
#line 894
    dy_ddegenset = (int *)((void *)0);
#line 895
    dy_freepivrej();
#line 896
    tmp___5 = calloc((size_t )1, sizeof(lp_struct ));
#line 896
    dy_lp = (lp_struct *)tmp___5;
#line 897
    dy_lp->p1obj.installed = (bool )0;
#line 898
    dy_lp->p1obj.infvars = (int *)((void *)0);
#line 899
    dy_lp->p1obj.p1obj = (double *)((void *)0);
#line 900
    dy_lp->p1obj.p2obj = (double *)((void *)0);
    }
  }
#line 902
  dy_lp->phase = (dyphase_enum )1;
#line 903
  dy_lp->lpret = (lpret_enum )0;
#line 914
  if ((unsigned int )start == 2U) {
#line 914
    tmp___6 = 1;
  } else {
#line 914
    tmp___6 = 0;
  }
  {
#line 914
  tmp___7 = dy_initlclsystem(orig_lp, (bool )tmp___6);
  }
#line 914
  if ((int )tmp___7 != 1) {
    {
#line 915
    errmsg(406, rtnnme, orig_sys->nme);
#line 916
    orig_lp->lpret = (lpret_enum )-1;
#line 917
    dy_finishup(orig_lp, dy_lp->phase);
    }
#line 918
    return ((lpret_enum )-1);
  }
#line 919
  orig_sys = orig_lp->consys;
  {
#line 939
  if ((unsigned int )start == 2U) {
#line 939
    goto case_2;
  }
#line 945
  if ((unsigned int )start == 1U) {
#line 945
    goto case_1;
  }
#line 951
  if ((unsigned int )start == 0U) {
#line 951
    goto case_0;
  }
#line 938
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 940
  tmp___9 = dy_hotstart(orig_lp);
  }
#line 940
  if ((int )tmp___9 != 1) {
    {
#line 941
    tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 941
    errmsg(371, rtnnme, orig_sys->nme, tmp___8, 0, "hot start");
#line 943
    dy_lp->lpret = (lpret_enum )-1;
    }
  }
#line 944
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 946
  tmp___11 = dy_warmstart(orig_lp);
  }
#line 946
  if ((int )tmp___11 != 1) {
    {
#line 947
    tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 947
    errmsg(371, rtnnme, orig_sys->nme, tmp___10, 0, "warm start");
#line 949
    dy_lp->lpret = (lpret_enum )-1;
    }
  }
#line 950
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 952
  tmp___15 = dy_coldstart(orig_sys);
  }
#line 952
  if ((int )tmp___15 != 1) {
    {
#line 953
    tmp___12 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 953
    errmsg(371, rtnnme, orig_sys->nme, tmp___12, 0, "cold start");
#line 955
    dy_lp->lpret = (lpret_enum )-1;
    }
  } else {
    {
#line 957
    tmp___14 = dy_crash();
    }
#line 957
    if ((int )tmp___14 != 1) {
      {
#line 958
      tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 958
      errmsg(302, rtnnme, dy_sys->nme, tmp___13, dy_lp->tot.iters, "crash");
#line 960
      dy_lp->lpret = (lpret_enum )-1;
      }
    }
  }
#line 961
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 962
  if ((int )dy_lp->lpret != 0) {
#line 963
    orig_lp->lpret = dy_lp->lpret;
#line 964
    if ((int )orig_lp->lpret == 4) {
#line 964
      goto _L;
    } else
#line 964
    if ((int )orig_lp->lpret == 2) {
      _L: /* CIL Label */ 
#line 965
      dy_lp->phase = (dyphase_enum )14;
#line 966
      orig_lp->phase = (dyphase_enum )14;
#line 968
      if (dy_opts->print.major >= 1) {
#line 969
        if ((int )orig_lp->lpret == 4) {
#line 969
          tmp___16 = "infeasibility";
        } else {
#line 969
          tmp___16 = "unboundedness";
        }
        {
#line 969
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\n%s (%s): prima facie %s.", rtnnme,
                    dy_sys->nme, tmp___16);
        }
      }
    }
    {
#line 974
    dy_finishup(orig_lp, dy_lp->phase);
    }
#line 975
    return (orig_lp->lpret);
  }
#line 981
  phase = dy_lp->simplex.next;
#line 982
  if ((int )dy_opts->usedual == 0) {
#line 982
    if ((unsigned int )phase == 4U) {
#line 982
      phase = (dyphase_enum )2;
    }
  }
  {
#line 983
  dy_lp->simplex.active = (dyphase_enum )0;
#line 984
  dy_lp->simplex.init_dse = (bool )1;
#line 985
  dy_lp->simplex.init_pse = (bool )1;
#line 986
  tmp___18 = commonstart(start);
  }
#line 986
  if ((int )tmp___18 == 0) {
    {
#line 987
    tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 987
    errmsg(371, rtnnme, orig_sys->nme, tmp___17, 0, "common start");
#line 989
    orig_lp->lpret = (lpret_enum )-1;
#line 990
    dy_finishup(orig_lp, dy_lp->phase);
    }
#line 991
    return ((lpret_enum )-1);
  }
#line 999
  dy_lp->lastz.cd = - dy_tols->inf;
#line 1000
  dy_lp->lastz.vd = - dy_tols->inf;
#line 1001
  dy_lp->ubnd.ndx = 0;
#line 1010
  if (dy_sys->concnt == 0) {
#line 1011
    dy_lp->simplex.active = (dyphase_enum )3;
#line 1012
    dy_lp->simplex.next = (dyphase_enum )3;
#line 1013
    dy_lp->lpret = (lpret_enum )1;
#line 1014
    phase = (dyphase_enum )6;
  } else
#line 1026
  if ((unsigned int )start == 0U) {
#line 1026
    if ((int )dy_opts->fullsys == 0) {
#line 1026
      if (dy_sys->archvcnt > dy_opts->coldvars) {
        {
#line 1028
        cnt = dy_deactivateVars(orig_sys);
        }
#line 1029
        if (cnt < 0) {
          {
#line 1030
          tmp___19 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1030
          errmsg(371, rtnnme, orig_sys->nme, tmp___19, 0, "initial variable deactivation");
          }
        }
#line 1032
        if ((unsigned int )phase == 2U) {
#line 1032
          if (cnt > 0) {
            {
#line 1033
            tmp___21 = dy_initp1obj();
            }
#line 1033
            if ((int )tmp___21 == 0) {
              {
#line 1034
              tmp___20 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1034
              errmsg(318, rtnnme, dy_sys->nme, tmp___20, dy_lp->tot.iters, "initialise");
#line 1036
              phase = (dyphase_enum )0;
              }
            }
          }
        }
      } else {
#line 1026
        goto _L___2;
      }
    } else {
#line 1026
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1044
  if ((unsigned int )start == 1U) {
#line 1044
    goto _L___0;
  } else
#line 1044
  if ((unsigned int )start == 2U) {
    _L___0: /* CIL Label */ 
#line 1045
    if ((int )dy_opts->fullsys == 0) {
#line 1045
      if (orig_lp->ctlopts & (unsigned int )((1 << 8) | (1 << 7))) {
#line 1045
        tmp___22 = 1;
      } else {
#line 1045
        tmp___22 = 0;
      }
#line 1045
      if (tmp___22) {
        {
#line 1047
        phase = initial_activation(orig_lp);
        }
      }
    }
  }
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    if ((unsigned int )phase != 14U) {
#line 1059
      if (! ((unsigned int )phase != 0U)) {
#line 1059
        goto while_break;
      }
    } else {
#line 1059
      goto while_break;
    }
#line 1060
    dy_lp->phase = phase;
#line 1062
    if (dy_opts->print.major >= 1) {
      {
#line 1063
      tmp___23 = dy_prtlpphase(phase, (bool )0);
#line 1063
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\n%s (%s): entering phase %s, iter %d.",
                  rtnnme, dy_sys->nme, tmp___23, dy_lp->tot.iters);
      }
    }
    {
#line 1105
    if ((unsigned int )phase == 3U) {
#line 1105
      goto case_3;
    }
#line 1105
    if ((unsigned int )phase == 2U) {
#line 1105
      goto case_3;
    }
#line 1170
    if ((unsigned int )phase == 5U) {
#line 1170
      goto case_5___0;
    }
#line 1206
    if ((unsigned int )phase == 6U) {
#line 1206
      goto case_6___0;
    }
#line 1240
    if ((unsigned int )phase == 7U) {
#line 1240
      goto case_7;
    }
#line 1306
    if ((unsigned int )phase == 8U) {
#line 1306
      goto case_8;
    }
#line 1344
    if ((unsigned int )phase == 9U) {
#line 1344
      goto case_9;
    }
#line 1366
    if ((unsigned int )phase == 10U) {
#line 1366
      goto case_10___0;
    }
#line 1440
    if ((unsigned int )phase == 4U) {
#line 1440
      goto case_4___0;
    }
#line 1474
    if ((unsigned int )phase == 11U) {
#line 1474
      goto case_11;
    }
#line 1477
    if ((unsigned int )phase == 12U) {
#line 1477
      goto case_12;
    }
#line 1480
    if ((unsigned int )phase == 13U) {
#line 1480
      goto case_13;
    }
#line 1489
    goto switch_default___1;
    case_3: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
#line 1107
    dy_lp->simplex.active = phase;
#line 1108
    if ((int )dy_lp->simplex.init_pse == 1) {
      {
#line 1109
      dy_pseinit();
#line 1110
      dy_lp->simplex.init_pse = (bool )0;
      }
    }
    {
#line 1111
    dy_lp->simplex.init_dse = (bool )1;
#line 1112
    lpresult = dy_primal();
#line 1113
    dy_lp->simplex.next = dy_lp->phase;
    }
    {
#line 1115
    if ((int )lpresult == 1) {
#line 1115
      goto case_1___0;
    }
#line 1119
    if ((int )lpresult == 4) {
#line 1119
      goto case_4;
    }
#line 1122
    if ((int )lpresult == 2) {
#line 1122
      goto case_2___1;
    }
#line 1134
    if ((int )lpresult == 3) {
#line 1134
      goto case_3___0;
    }
#line 1144
    if ((int )lpresult == 6) {
#line 1144
      goto case_6;
    }
#line 1144
    if ((int )lpresult == 10) {
#line 1144
      goto case_6;
    }
#line 1147
    if ((int )lpresult == 5) {
#line 1147
      goto case_5;
    }
#line 1150
    goto switch_default;
    case_1___0: /* CIL Label */ 
#line 1116
    phase = (dyphase_enum )6;
#line 1117
    dy_lp->simplex.next = (dyphase_enum )3;
#line 1118
    goto switch_break___1;
    case_4: /* CIL Label */ 
#line 1120
    phase = (dyphase_enum )6;
#line 1121
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
#line 1123
    if (dy_sys->concnt < orig_sys->concnt) {
#line 1124
      phase = (dyphase_enum )9;
    } else {
#line 1126
      phase = (dyphase_enum )14;
    }
#line 1133
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 1135
    phase = (dyphase_enum )9;
#line 1142
    goto switch_break___1;
    case_6: /* CIL Label */ 
    case_10: /* CIL Label */ 
#line 1145
    phase = (dyphase_enum )6;
#line 1146
    goto switch_break___1;
    case_5: /* CIL Label */ 
#line 1148
    phase = (dyphase_enum )13;
#line 1149
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 1151
    if ((unsigned int )dy_opts->context == 3U) {
#line 1151
      if (! ((int )lpresult == 7)) {
        {
#line 1152
        tmp___24 = dy_prtlpret(lpresult);
#line 1152
        errmsg(353, rtnnme, orig_sys->nme, "primal", tmp___24);
        }
      }
    } else {
      {
#line 1152
      tmp___24 = dy_prtlpret(lpresult);
#line 1152
      errmsg(353, rtnnme, orig_sys->nme, "primal", tmp___24);
      }
    }
#line 1154
    phase = (dyphase_enum )14;
#line 1155
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1156
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 1171
    tmp___25 = fabs(dy_lp->z);
#line 1171
    tol = dy_tols->purge * (1.0 + tmp___25);
#line 1172
    tmp___28 = fabs(dy_lp->z - dy_lp->lastz.vd);
    }
#line 1172
    if (tmp___28 <= tol) {
#line 1190
      if (dy_opts->print.varmgmt >= 2) {
        {
#line 1191
        tmp___27 = dy_prtlpphase(phase, (bool )1);
#line 1191
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: variable purge skipped, obj = %g.",
                    dy_sys->nme, tmp___27, dy_lp->tot.iters, dy_lp->z);
        }
      }
#line 1196
      phase = dy_lp->simplex.next;
    } else {
#line 1175
      if (dy_opts->print.varmgmt >= 1) {
        {
#line 1176
        tmp___26 = dy_prtlpphase(phase, (bool )1);
#line 1176
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: purging variables, obj = %g ...",
                    dy_sys->nme, tmp___26, dy_lp->tot.iters, dy_lp->z);
        }
      }
      {
#line 1181
      cnt = dy_deactivateVars(orig_sys);
#line 1182
      dy_lp->lastz.vd = dy_lp->z;
      }
#line 1183
      if (cnt < 0) {
#line 1184
        phase = (dyphase_enum )0;
      } else {
#line 1186
        phase = dy_lp->simplex.next;
      }
    }
#line 1197
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
#line 1207
    phase = (dyphase_enum )7;
#line 1208
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 1241
    if (dy_lp->sys.vars.loadable <= 0) {
#line 1244
      if (dy_opts->print.varmgmt >= 1) {
        {
#line 1245
        tmp___29 = dy_prtlpphase(phase, (bool )1);
#line 1245
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: no loadable variables; skipping.",
                    dy_sys->nme, tmp___29, dy_lp->tot.iters);
        }
      }
      {
#line 1250
      phase = addvar_nextphase(0);
      }
#line 1251
      goto switch_break___0;
    } else {
#line 1253
      if ((unsigned int )dy_lp->simplex.next == 4U) {
#line 1253
        if ((int )dy_lp->lpret == 4) {
#line 1254
          if (dy_opts->dualadd > 0) {
#line 1257
            if (dy_opts->print.varmgmt >= 1) {
              {
#line 1258
              tmp___30 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1258
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: [%s](%s)%d: activating variables, ",
                          rtnnme, dy_sys->nme, tmp___30, dy_lp->tot.iters);
#line 1262
              tmp___31 = dy_prtlpphase(dy_lp->simplex.next, (bool )1);
#line 1262
              dyio_outfmt(dy_logchn, dy_gtxecho, "%s rules, obj = %g ...", tmp___31,
                          dy_lp->z);
              }
            }
            {
#line 1266
            cnt = dy_dualaddvars(orig_sys);
            }
          } else {
#line 1268
            cnt = 0;
          }
#line 1269
          if (cnt > 0) {
#line 1270
            phase = (dyphase_enum )4;
          } else
#line 1272
          if (cnt == 0) {
            {
#line 1273
            dy_lp->simplex.next = (dyphase_enum )2;
#line 1274
            checks = (flags )(1 | (1 << 2));
#line 1275
            tmp___32 = dy_accchk(& checks);
            }
#line 1275
            if ((int )tmp___32 != 1) {
#line 1276
              phase = (dyphase_enum )0;
            }
          } else {
#line 1278
            phase = (dyphase_enum )0;
          }
        }
      }
#line 1279
      if ((unsigned int )phase == 7U) {
#line 1282
        if (dy_opts->print.varmgmt >= 1) {
          {
#line 1283
          tmp___33 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1283
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: [%s](%s)%d: activating variables, ",
                      rtnnme, dy_sys->nme, tmp___33, dy_lp->tot.iters);
#line 1287
          tmp___34 = dy_prtlpphase(dy_lp->simplex.next, (bool )1);
#line 1287
          dyio_outfmt(dy_logchn, dy_gtxecho, "%s rules, obj = %g ...", tmp___34, dy_lp->z);
          }
        }
        {
#line 1290
        cnt = dy_activateVars(orig_sys, (int *)((void *)0));
#line 1291
        phase = addvar_nextphase(cnt);
        }
      }
    }
#line 1292
    goto switch_break___0;
    case_8: /* CIL Label */ 
    {
#line 1307
    tmp___35 = fabs(dy_lp->z);
#line 1307
    tol = dy_tols->purge * (1.0 + tmp___35);
    }
#line 1308
    if (dy_lp->z - dy_lp->lastz.cd > tol) {
#line 1311
      if (dy_opts->print.conmgmt >= 1) {
        {
#line 1312
        tmp___36 = dy_prtlpphase(phase, (bool )1);
#line 1312
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: purging constraints, obj = %g ...",
                    dy_sys->nme, tmp___36, dy_lp->tot.iters, dy_lp->z);
        }
      }
      {
#line 1317
      cnt = dy_deactivateCons(orig_sys);
      }
#line 1318
      if (cnt < 0) {
#line 1319
        phase = (dyphase_enum )0;
      } else {
#line 1321
        phase = (dyphase_enum )4;
      }
#line 1322
      dy_lp->lastz.cd = dy_lp->z;
    } else {
#line 1330
      if (dy_opts->print.conmgmt >= 2) {
        {
#line 1331
        tmp___37 = dy_prtlpphase(phase, (bool )1);
#line 1331
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: constraint purge skipped, obj = %g.",
                    dy_sys->nme, tmp___37, dy_lp->tot.iters, dy_lp->z);
        }
      }
#line 1336
      phase = (dyphase_enum )4;
    }
#line 1337
    goto switch_break___0;
    case_9: /* CIL Label */ 
#line 1345
    phase = (dyphase_enum )10;
#line 1346
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
#line 1367
    if (dy_lp->sys.cons.loadable <= 0) {
      {
#line 1368
      phase = addcon_nextphase(0);
      }
#line 1370
      if (dy_opts->print.conmgmt >= 1) {
        {
#line 1371
        tmp___38 = dy_prtlpphase(phase, (bool )1);
#line 1371
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: no loadable constraints; skipping.",
                    dy_sys->nme, tmp___38, dy_lp->tot.iters);
        }
      }
#line 1376
      goto switch_break___0;
    }
#line 1377
    if ((int )dy_lp->lpret == 3) {
#line 1377
      goto _L___4;
    } else
#line 1377
    if ((int )dy_lp->lpret == 2) {
#line 1377
      if ((unsigned int )dy_lp->simplex.next == 3U) {
#line 1377
        goto _L___4;
      } else
#line 1377
      if ((unsigned int )dy_lp->simplex.next == 2U) {
        _L___4: /* CIL Label */ 
#line 1383
        if (dy_opts->print.conmgmt >= 1) {
          {
#line 1384
          tmp___39 = dy_prtlpphase(phase, (bool )1);
#line 1384
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: activating bounding constraints, ",
                      dy_sys->nme, tmp___39, dy_lp->tot.iters);
#line 1388
          dyio_outfmt(dy_logchn, dy_gtxecho, "obj = %g ...", dy_lp->z);
          }
        }
        {
#line 1390
        cnt = dy_activateBndCons(orig_sys);
        }
#line 1391
        if (cnt > 0) {
#line 1392
          phase = dy_lp->simplex.next;
        } else
#line 1394
        if (cnt == 0) {
#line 1395
          dy_lp->simplex.next = (dyphase_enum )2;
        } else {
#line 1397
          phase = (dyphase_enum )0;
        }
      }
    }
#line 1398
    if ((unsigned int )phase == 10U) {
#line 1401
      if (dy_opts->print.conmgmt >= 1) {
        {
#line 1402
        tmp___40 = dy_prtlpphase(phase, (bool )1);
#line 1402
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  [%s](%s)%d: activating violated constraints, ",
                    dy_sys->nme, tmp___40, dy_lp->tot.iters);
#line 1406
        dyio_outfmt(dy_logchn, dy_gtxecho, "obj = %g ...", dy_lp->z);
        }
      }
      {
#line 1408
      cnt = dy_activateCons(orig_sys, (bool )1);
#line 1409
      phase = addcon_nextphase(cnt);
      }
    }
#line 1410
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 1441
    dy_lp->simplex.active = (dyphase_enum )4;
#line 1442
    if ((int )dy_lp->simplex.init_dse == 1) {
      {
#line 1443
      dy_dseinit();
#line 1444
      dy_lp->simplex.init_dse = (bool )0;
      }
    }
    {
#line 1445
    dy_lp->simplex.init_pse = (bool )1;
#line 1446
    lpresult = dy_dual();
#line 1447
    dy_lp->simplex.next = (dyphase_enum )4;
    }
    {
#line 1449
    if ((int )lpresult == 1) {
#line 1449
      goto case_1___1;
    }
#line 1453
    if ((int )lpresult == 4) {
#line 1453
      goto case_4___1;
    }
#line 1456
    if ((int )lpresult == 9) {
#line 1456
      goto case_9___0;
    }
#line 1461
    if ((int )lpresult == 3) {
#line 1461
      goto case_3___1;
    }
#line 1461
    if ((int )lpresult == 6) {
#line 1461
      goto case_3___1;
    }
#line 1461
    if ((int )lpresult == 10) {
#line 1461
      goto case_3___1;
    }
#line 1464
    if ((int )lpresult == 5) {
#line 1464
      goto case_5___1;
    }
#line 1467
    goto switch_default___0;
    case_1___1: /* CIL Label */ 
#line 1450
    phase = (dyphase_enum )6;
#line 1451
    dy_lp->simplex.next = (dyphase_enum )3;
#line 1452
    goto switch_break___2;
    case_4___1: /* CIL Label */ 
#line 1454
    phase = (dyphase_enum )6;
#line 1455
    goto switch_break___2;
    case_9___0: /* CIL Label */ 
#line 1457
    phase = (dyphase_enum )11;
#line 1458
    goto switch_break___2;
    case_3___1: /* CIL Label */ 
    case_6___1: /* CIL Label */ 
    case_10___1: /* CIL Label */ 
#line 1462
    phase = (dyphase_enum )9;
#line 1463
    goto switch_break___2;
    case_5___1: /* CIL Label */ 
#line 1465
    phase = (dyphase_enum )13;
#line 1466
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 1468
    if ((unsigned int )dy_opts->context == 3U) {
#line 1468
      if (! ((int )lpresult == 7)) {
        {
#line 1469
        tmp___41 = dy_prtlpret(lpresult);
#line 1469
        errmsg(353, rtnnme, orig_sys->nme, "dual", tmp___41);
        }
      }
    } else {
      {
#line 1469
      tmp___41 = dy_prtlpret(lpresult);
#line 1469
      errmsg(353, rtnnme, orig_sys->nme, "dual", tmp___41);
      }
    }
#line 1471
    phase = (dyphase_enum )14;
#line 1472
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1473
    goto switch_break___0;
    case_11: /* CIL Label */ 
    {
#line 1475
    phase = dy_forcePrimal2Dual(orig_sys);
    }
#line 1476
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 1478
    phase = dy_forceDual2Primal(orig_sys);
    }
#line 1479
    goto switch_break___0;
    case_13: /* CIL Label */ 
#line 1481
    if ((int )dy_lp->sys.forcedfull == 1) {
#line 1483
      dy_lp->lpret = (lpret_enum )13;
#line 1484
      phase = (dyphase_enum )14;
    } else
#line 1481
    if (dy_lp->sys.cons.loadable <= 0) {
#line 1481
      if (dy_lp->sys.vars.loadable <= 0) {
#line 1483
        dy_lp->lpret = (lpret_enum )13;
#line 1484
        phase = (dyphase_enum )14;
      } else {
        {
#line 1486
        phase = dy_forceFull(orig_sys);
#line 1487
        dy_lp->sys.forcedfull = (bool )1;
        }
      }
    } else {
      {
#line 1486
      phase = dy_forceFull(orig_sys);
#line 1487
      dy_lp->sys.forcedfull = (bool )1;
      }
    }
#line 1488
    goto switch_break___0;
    switch_default___1: /* CIL Label */ 
    {
#line 1490
    phase = (dyphase_enum )0;
#line 1491
    errmsg(1, rtnnme, 1491);
    }
#line 1492
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1502
  if ((unsigned int )phase == 14U) {
#line 1502
    if ((int )dy_lp->lpret == 1) {
#line 1503
      if ((int )dy_opts->finpurge.vars == 1) {
#line 1506
        if (dy_opts->print.major >= 1) {
          {
#line 1507
          tmp___42 = dy_prtlpphase((dyphase_enum )5, (bool )0);
#line 1507
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\n%s (%s): entering phase %s (final), iter %d.",
                      rtnnme, dy_sys->nme, tmp___42, dy_lp->tot.iters);
          }
        }
        {
#line 1512
        cnt = dy_deactivateVars(orig_sys);
        }
#line 1513
        if (cnt < 0) {
          {
#line 1514
          tmp___43 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1514
          errmsg(371, rtnnme, orig_sys->nme, tmp___43, dy_lp->tot.pivs, "final variable deactivation");
          }
        }
      }
#line 1517
      if ((int )dy_opts->finpurge.cons == 1) {
#line 1520
        if (dy_opts->print.major >= 1) {
          {
#line 1521
          tmp___44 = dy_prtlpphase((dyphase_enum )8, (bool )0);
#line 1521
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\n%s (%s): entering phase %s (final), iter %d.",
                      rtnnme, dy_sys->nme, tmp___44, dy_lp->tot.iters);
          }
        }
        {
#line 1526
        dy_opts->con.deactlvl = 0;
#line 1527
        cnt = dy_deactivateCons(orig_sys);
        }
#line 1528
        if (cnt < 0) {
          {
#line 1529
          tmp___45 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1529
          errmsg(371, rtnnme, orig_sys->nme, tmp___45, dy_lp->tot.pivs, "final constraint deactivation");
          }
        }
      }
    }
  }
#line 1539
  if ((unsigned int )phase == 14U) {
#line 1539
    if ((int )dy_lp->lpret == 4) {
      {
#line 1540
      phase = (dyphase_enum )3;
#line 1541
      tmp___47 = dy_swapobjs((dyphase_enum )3);
      }
#line 1541
      if ((int )tmp___47 == 0) {
        {
#line 1542
        phase = (dyphase_enum )14;
#line 1543
        tmp___46 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1543
        errmsg(318, rtnnme, dy_sys->nme, tmp___46, dy_lp->tot.iters, "remove");
#line 1545
        dy_lp->lpret = (lpret_enum )-1;
        }
      }
      {
#line 1546
      dy_calcduals();
#line 1547
      tmp___49 = dy_calccbar();
      }
#line 1547
      if ((int )tmp___49 == 0) {
        {
#line 1548
        phase = (dyphase_enum )14;
#line 1549
        tmp___48 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1549
        errmsg(384, rtnnme, dy_sys->nme, tmp___48, dy_lp->tot.iters);
#line 1551
        dy_lp->lpret = (lpret_enum )-1;
        }
      }
#line 1552
      phase = (dyphase_enum )14;
    }
  }
  {
#line 1557
  orig_lp->phase = phase;
#line 1561
  dy_finishup(orig_lp, dy_lp->phase);
  }
#line 1563
  return (orig_lp->lpret);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___5  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 57 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_scaling.c"
bool consys_evalsys(consys_struct *consys , double *p_scm , int *p_gecnt ) 
{ 
  int i ;
  int gecnt ;
  double amax ;
  double amin ;
  double aij ;
  double *rsc ;
  double *csc ;
  rowhdr_struct *rowi ;
  coeff_struct *coeffij ;

  {
#line 109
  *p_scm = QNaNbits___5.fpdbl;
#line 110
  *p_gecnt = -1;
#line 112
  rsc = consys->rowscale;
#line 113
  csc = consys->colscale;
#line 114
  amax = 0.0;
#line 115
  amin = consys->inf;
#line 116
  gecnt = 0;
#line 121
  i = 1;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i <= consys->concnt)) {
#line 121
      goto while_break;
    }
#line 122
    rowi = *(consys->mtx.rows + i);
#line 136
    if ((unsigned int )*(consys->ctyp + i) == 2U) {
#line 137
      gecnt ++;
    }
#line 139
    coeffij = rowi->coeffs;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 139
        goto while_break___0;
      }
#line 154
      aij = coeffij->val;
#line 155
      if (aij == 0.0) {
#line 155
        goto __Cont;
      }
      {
#line 157
      aij = fabs(aij);
      }
#line 158
      if ((unsigned long )rsc != (unsigned long )((void *)0)) {
#line 158
        aij *= *(rsc + i);
      }
#line 159
      if ((unsigned long )csc != (unsigned long )((void *)0)) {
#line 159
        aij *= *(csc + (coeffij->colhdr)->ndx);
      }
#line 160
      if (aij > amax) {
#line 160
        amax = aij;
      }
#line 161
      if (aij < amin) {
#line 161
        amin = aij;
      }
      __Cont: /* CIL Label */ 
#line 139
      coeffij = coeffij->rownxt;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (consys->concnt == 0) {
#line 167
    *p_gecnt = 0;
#line 168
    *p_scm = 1.0;
#line 169
    consys->maxaij = (double )0;
#line 170
    consys->minaij = (double )0;
  } else {
    {
#line 172
    *p_gecnt = gecnt;
#line 173
    *p_scm = sqrt(amax / amin);
#line 174
    consys->maxaij = amax;
#line 175
    consys->minaij = amin;
    }
  }
#line 177
  return ((bool )1);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_scaling.c"
bool consys_geomscale(consys_struct *consys , double **p_rowscale , double **p_colscale ) 
{ 
  int i ;
  int j ;
  int iter ;
  double sqm ;
  double sqm_old ;
  double eps ;
  double aij ;
  double rcmax ;
  double rcmin ;
  double maxaij ;
  double minaij ;
  double *rowscale ;
  double *colscale ;
  coeff_struct *coeffij ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 235
  if ((unsigned long )*p_rowscale == (unsigned long )((void *)0)) {
    {
#line 236
    tmp = malloc((unsigned long )(consys->concnt + 1) * sizeof(double ));
#line 236
    rowscale = (double *)tmp;
#line 237
    *(rowscale + 0) = (double )0;
#line 238
    i = 1;
    }
    {
#line 238
    while (1) {
      while_continue: /* CIL Label */ ;
#line 238
      if (! (i <= consys->concnt)) {
#line 238
        goto while_break;
      }
#line 238
      *(rowscale + i) = 1.0;
#line 238
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 240
    rowscale = *p_rowscale;
  }
#line 241
  if ((unsigned long )*p_colscale == (unsigned long )((void *)0)) {
    {
#line 242
    tmp___0 = malloc((unsigned long )(consys->varcnt + 1) * sizeof(double ));
#line 242
    colscale = (double *)tmp___0;
#line 243
    *(colscale + 0) = (double )0;
#line 244
    j = 1;
    }
    {
#line 244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 244
      if (! (j <= consys->varcnt)) {
#line 244
        goto while_break___0;
      }
#line 244
      *(colscale + j) = 1.0;
#line 244
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 246
    colscale = *p_colscale;
  }
  {
#line 248
  sqm_old = sqrt(consys->maxaij / consys->minaij);
#line 249
  eps = 1.0;
#line 255
  iter = 1;
  }
  {
#line 255
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 255
    if (iter <= 20) {
#line 255
      if (! (eps > .05)) {
#line 255
        goto while_break___1;
      }
    } else {
#line 255
      goto while_break___1;
    }
#line 256
    maxaij = 0.0;
#line 257
    minaij = consys->inf;
#line 258
    i = 1;
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 258
      if (! (i <= consys->concnt)) {
#line 258
        goto while_break___2;
      }
#line 259
      coeffij = (*(consys->mtx.rows + i))->coeffs;
#line 260
      if ((unsigned long )coeffij == (unsigned long )((void *)0)) {
#line 260
        goto __Cont;
      }
#line 261
      rcmax = 0.0;
#line 262
      rcmin = consys->inf;
      {
#line 263
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 263
        if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 263
          goto while_break___3;
        }
        {
#line 264
        aij = fabs(coeffij->val);
        }
#line 265
        if (aij == (double )0) {
#line 265
          goto __Cont___0;
        }
#line 266
        j = (coeffij->colhdr)->ndx;
#line 267
        aij *= *(colscale + j);
#line 268
        if (aij > rcmax) {
#line 268
          rcmax = aij;
        }
#line 269
        if (aij < rcmin) {
#line 269
          rcmin = aij;
        }
        __Cont___0: /* CIL Label */ 
#line 263
        coeffij = coeffij->rownxt;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 270
      tmp___1 = sqrt(rcmax * rcmin);
#line 270
      *(rowscale + i) = (double )1 / tmp___1;
      }
#line 271
      if (*(rowscale + i) * rcmax > maxaij) {
#line 271
        maxaij = *(rowscale + i) * rcmax;
      }
#line 272
      if (*(rowscale + i) * rcmin < minaij) {
#line 272
        minaij = *(rowscale + i) * rcmin;
      }
      __Cont: /* CIL Label */ 
#line 258
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 279
    maxaij = 0.0;
#line 280
    minaij = consys->inf;
#line 281
    j = 1;
    {
#line 281
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 281
      if (! (j <= consys->varcnt)) {
#line 281
        goto while_break___4;
      }
#line 282
      coeffij = (*(consys->mtx.cols + j))->coeffs;
#line 283
      if ((unsigned long )coeffij == (unsigned long )((void *)0)) {
#line 283
        goto __Cont___1;
      }
#line 284
      rcmax = 0.0;
#line 285
      rcmin = consys->inf;
      {
#line 286
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 286
        if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 286
          goto while_break___5;
        }
        {
#line 287
        aij = fabs(coeffij->val);
        }
#line 288
        if (aij == (double )0) {
#line 288
          goto __Cont___2;
        }
#line 289
        i = (coeffij->rowhdr)->ndx;
#line 290
        aij *= *(rowscale + i);
#line 291
        if (aij > rcmax) {
#line 291
          rcmax = aij;
        }
#line 292
        if (aij < rcmin) {
#line 292
          rcmin = aij;
        }
        __Cont___2: /* CIL Label */ 
#line 286
        coeffij = coeffij->colnxt;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 293
      tmp___2 = sqrt(rcmax * rcmin);
#line 293
      *(colscale + j) = (double )1 / tmp___2;
      }
#line 294
      if (*(colscale + j) * rcmax > maxaij) {
#line 294
        maxaij = *(colscale + j) * rcmax;
      }
#line 295
      if (*(colscale + j) * rcmin < minaij) {
#line 295
        minaij = *(colscale + j) * rcmin;
      }
      __Cont___1: /* CIL Label */ 
#line 281
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 296
    sqm = sqrt(maxaij / minaij);
#line 297
    eps = (sqm_old - sqm) / sqm_old;
#line 303
    sqm_old = sqm;
#line 255
    iter ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 306
  consys->maxaij = maxaij;
#line 307
  consys->minaij = minaij;
#line 309
  *p_rowscale = rowscale;
#line 310
  *p_colscale = colscale;
#line 312
  return ((bool )1);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_scaling.c"
bool consys_equiscale(consys_struct *consys , double **p_rowscale , double **p_colscale ) 
{ 
  int i ;
  int j ;
  double sqm ;
  double sqm_old ;
  double eps ;
  double aij ;
  double rcmax ;
  double rcmin ;
  double maxaij ;
  double minaij ;
  double *rowscale ;
  double *colscale ;
  coeff_struct *coeffij ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 370
  if ((unsigned long )*p_rowscale == (unsigned long )((void *)0)) {
    {
#line 371
    tmp = malloc((unsigned long )(consys->concnt + 1) * sizeof(double ));
#line 371
    rowscale = (double *)tmp;
#line 372
    *(rowscale + 0) = (double )0;
#line 373
    i = 1;
    }
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
#line 373
      if (! (i <= consys->concnt)) {
#line 373
        goto while_break;
      }
#line 373
      *(rowscale + i) = 1.0;
#line 373
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 375
    rowscale = *p_rowscale;
  }
#line 376
  if ((unsigned long )*p_colscale == (unsigned long )((void *)0)) {
    {
#line 377
    tmp___0 = malloc((unsigned long )(consys->varcnt + 1) * sizeof(double ));
#line 377
    colscale = (double *)tmp___0;
#line 378
    *(colscale + 0) = (double )0;
#line 379
    j = 1;
    }
    {
#line 379
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 379
      if (! (j <= consys->varcnt)) {
#line 379
        goto while_break___0;
      }
#line 379
      *(colscale + j) = 1.0;
#line 379
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 381
    colscale = *p_colscale;
  }
  {
#line 383
  sqm_old = sqrt(consys->maxaij / consys->minaij);
#line 384
  eps = 1.0;
#line 389
  maxaij = 0.0;
#line 390
  minaij = consys->inf;
#line 391
  j = 1;
  }
  {
#line 391
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 391
    if (! (j <= consys->varcnt)) {
#line 391
      goto while_break___1;
    }
#line 392
    coeffij = (*(consys->mtx.cols + j))->coeffs;
#line 393
    if ((unsigned long )coeffij == (unsigned long )((void *)0)) {
#line 393
      goto __Cont;
    }
#line 394
    rcmax = 0.0;
#line 395
    rcmin = consys->inf;
    {
#line 396
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 396
      if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 396
        goto while_break___2;
      }
      {
#line 397
      aij = fabs(coeffij->val);
      }
#line 398
      if (aij == (double )0) {
#line 398
        goto __Cont___0;
      }
#line 399
      i = (coeffij->rowhdr)->ndx;
#line 400
      aij *= *(rowscale + i);
#line 401
      if (aij > rcmax) {
#line 401
        rcmax = aij;
      }
#line 402
      if (aij < rcmin) {
#line 402
        rcmin = aij;
      }
      __Cont___0: /* CIL Label */ 
#line 396
      coeffij = coeffij->colnxt;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 403
    *(colscale + j) = (double )1 / rcmax;
#line 404
    if (*(colscale + j) * rcmax > maxaij) {
#line 404
      maxaij = *(colscale + j) * rcmax;
    }
#line 405
    if (*(colscale + j) * rcmin < minaij) {
#line 405
      minaij = *(colscale + j) * rcmin;
    }
    __Cont: /* CIL Label */ 
#line 391
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 406
  sqm = sqrt(maxaij / minaij);
#line 407
  eps = (sqm_old - sqm) / sqm_old;
#line 414
  consys->maxaij = maxaij;
#line 415
  consys->minaij = minaij;
#line 417
  *p_rowscale = rowscale;
#line 418
  *p_colscale = colscale;
  }
#line 420
  return ((bool )1);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_scaling.c"
bool consys_applyscale(consys_struct *consys , bool convctyp , double *rowscale ,
                       double *colscale ) 
{ 
  int i ;
  int j ;
  double aij ;
  double maxaij ;
  double minaij ;
  coeff_struct *coeffij ;
  int tmp ;

  {
#line 485
  i = 1;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i <= consys->concnt)) {
#line 485
      goto while_break;
    }
#line 486
    coeffij = (*(consys->mtx.rows + i))->coeffs;
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 487
        goto while_break___0;
      }
#line 488
      coeffij->val *= *(rowscale + i);
#line 487
      coeffij = coeffij->rownxt;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 490
    i = 1;
    {
#line 490
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 490
      if (! (i <= consys->concnt)) {
#line 490
        goto while_break___1;
      }
#line 491
      *(consys->rhs + i) *= *(rowscale + i);
#line 490
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 492
  if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 493
    i = 1;
    {
#line 493
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 493
      if (! (i <= consys->concnt)) {
#line 493
        goto while_break___2;
      }
#line 494
      *(consys->rhslow + i) *= *(rowscale + i);
#line 493
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 495
  if ((int )convctyp == 1) {
#line 495
    if ((unsigned long )consys->ctyp != (unsigned long )((void *)0)) {
#line 496
      i = 1;
      {
#line 496
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 496
        if (! (i <= consys->concnt)) {
#line 496
          goto while_break___3;
        }
#line 497
        if (*(rowscale + i) < (double )0) {
#line 504
          *(consys->ctyp + i) = (contyp_enum )4;
        }
#line 496
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 513
  maxaij = 0.0;
#line 514
  minaij = consys->inf;
#line 515
  j = 1;
  {
#line 515
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 515
    if (! (j <= consys->varcnt)) {
#line 515
      goto while_break___4;
    }
#line 516
    coeffij = (*(consys->mtx.cols + j))->coeffs;
    {
#line 517
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 517
      if (! ((unsigned long )coeffij != (unsigned long )((void *)0))) {
#line 517
        goto while_break___5;
      }
#line 518
      coeffij->val *= *(colscale + j);
#line 519
      if (coeffij->val != 0.0) {
        {
#line 520
        aij = fabs(coeffij->val);
        }
#line 521
        if (aij < minaij) {
#line 521
          minaij = aij;
        }
#line 522
        if (aij > maxaij) {
#line 522
          maxaij = aij;
        }
      }
#line 517
      coeffij = coeffij->colnxt;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 515
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 523
  if ((unsigned long )consys->obj != (unsigned long )((void *)0)) {
#line 524
    j = 1;
    {
#line 524
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 524
      if (! (j <= consys->varcnt)) {
#line 524
        goto while_break___6;
      }
#line 525
      *(consys->obj + j) *= *(colscale + j);
#line 524
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 526
  if (consys->opts & (1U << 3)) {
#line 526
    tmp = 0;
  } else {
#line 526
    tmp = 1;
  }
#line 526
  if (tmp) {
#line 527
    if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
#line 528
      j = 1;
      {
#line 528
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 528
        if (! (j <= consys->varcnt)) {
#line 528
          goto while_break___7;
        }
#line 529
        *(consys->vlb + j) /= *(colscale + j);
#line 528
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 530
    if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 531
      j = 1;
      {
#line 531
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 531
        if (! (j <= consys->varcnt)) {
#line 531
          goto while_break___8;
        }
#line 532
        *(consys->vub + j) /= *(colscale + j);
#line 531
        j ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  } else {
#line 534
    if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
#line 535
      j = 1;
      {
#line 535
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 535
        if (! (j <= consys->varcnt)) {
#line 535
          goto while_break___9;
        }
#line 536
        if (*(consys->vlb + j) > - consys->inf) {
#line 537
          *(consys->vlb + j) /= *(colscale + j);
        }
#line 535
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 538
    if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 539
      j = 1;
      {
#line 539
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 539
        if (! (j <= consys->varcnt)) {
#line 539
          goto while_break___10;
        }
#line 540
        if (*(consys->vub + j) < consys->inf) {
#line 541
          *(consys->vub + j) /= *(colscale + j);
        }
#line 539
        j ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
#line 543
  consys->maxaij = maxaij;
#line 544
  consys->minaij = minaij;
#line 546
  return ((bool )1);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.h"
LUF_WA *dy_glp_luf_alloc_wa(LUF *luf ) ;
#line 325
void dy_glp_luf_free_wa(LUF_WA *wa ) ;
#line 339
void dy_glp_luf_solve(LUF *luf , int tr , double *x ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
LUF *dy_glp_luf_create(int n , int sv_size ) 
{ 
  LUF *luf ;
  int i ;
  int j ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;

  {
#line 57
  if (n < 1) {
    {
#line 58
    dy_glp_fault("luf_create: n = %d; invalid parameter", n);
    }
  }
#line 59
  if (sv_size < 0) {
    {
#line 60
    dy_glp_fault("luf_create: sv_size = %d; invalid parameter", sv_size);
    }
  }
#line 61
  if (sv_size == 0) {
#line 61
    sv_size = 5 * (n + 10);
  }
  {
#line 62
  tmp = dy_glp_umalloc((int )sizeof(LUF ));
#line 62
  luf = (LUF *)tmp;
#line 63
  luf->n = n;
#line 64
  luf->valid = 1;
#line 66
  tmp___0 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 66
  luf->fr_ptr = (int *)tmp___0;
#line 67
  tmp___1 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 67
  luf->fr_len = (int *)tmp___1;
#line 68
  i = 1;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i <= n)) {
#line 68
      goto while_break;
    }
#line 69
    *(luf->fr_ptr + i) = sv_size + 1;
#line 70
    *(luf->fr_len + i) = 0;
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 73
  tmp___2 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 73
  luf->fc_ptr = (int *)tmp___2;
#line 74
  tmp___3 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 74
  luf->fc_len = (int *)tmp___3;
#line 75
  j = 1;
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (! (j <= n)) {
#line 75
      goto while_break___0;
    }
#line 76
    *(luf->fc_ptr + j) = sv_size + 1;
#line 77
    *(luf->fc_len + j) = 0;
#line 75
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 80
  tmp___4 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 80
  luf->vr_ptr = (int *)tmp___4;
#line 81
  tmp___5 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 81
  luf->vr_len = (int *)tmp___5;
#line 82
  tmp___6 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 82
  luf->vr_cap = (int *)tmp___6;
#line 83
  tmp___7 = dy_glp_ucalloc(1 + n, (int )sizeof(double ));
#line 83
  luf->vr_piv = (double *)tmp___7;
#line 84
  i = 1;
  }
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 84
    if (! (i <= n)) {
#line 84
      goto while_break___1;
    }
#line 85
    *(luf->vr_ptr + i) = 1;
#line 86
    *(luf->vr_len + i) = 0;
#line 87
    *(luf->vr_cap + i) = 0;
#line 88
    *(luf->vr_piv + i) = 1.0;
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 91
  tmp___8 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 91
  luf->vc_ptr = (int *)tmp___8;
#line 92
  tmp___9 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 92
  luf->vc_len = (int *)tmp___9;
#line 93
  tmp___10 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 93
  luf->vc_cap = (int *)tmp___10;
#line 94
  j = 1;
  }
  {
#line 94
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 94
    if (! (j <= n)) {
#line 94
      goto while_break___2;
    }
#line 95
    *(luf->vc_ptr + j) = 1;
#line 96
    *(luf->vc_len + j) = 0;
#line 97
    *(luf->vc_cap + j) = 0;
#line 94
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 100
  tmp___11 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 100
  luf->pp_row = (int *)tmp___11;
#line 101
  tmp___12 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 101
  luf->pp_col = (int *)tmp___12;
#line 102
  k = 1;
  }
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 102
    if (! (k <= n)) {
#line 102
      goto while_break___3;
    }
#line 103
    *(luf->pp_row + k) = k;
#line 104
    *(luf->pp_col + k) = k;
#line 102
    k ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 107
  tmp___13 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 107
  luf->qq_row = (int *)tmp___13;
#line 108
  tmp___14 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 108
  luf->qq_col = (int *)tmp___14;
#line 109
  k = 1;
  }
  {
#line 109
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 109
    if (! (k <= n)) {
#line 109
      goto while_break___4;
    }
#line 110
    *(luf->qq_row + k) = k;
#line 111
    *(luf->qq_col + k) = k;
#line 109
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 114
  luf->sv_size = sv_size;
#line 115
  luf->sv_beg = 1;
#line 116
  luf->sv_end = sv_size + 1;
#line 117
  tmp___15 = dy_glp_ucalloc(1 + sv_size, (int )sizeof(int ));
#line 117
  luf->sv_ndx = (int *)tmp___15;
#line 118
  tmp___16 = dy_glp_ucalloc(1 + sv_size, (int )sizeof(double ));
#line 118
  luf->sv_val = (double *)tmp___16;
#line 121
  luf->sv_head = 1;
#line 122
  luf->sv_tail = n + n;
#line 123
  tmp___17 = dy_glp_ucalloc((1 + n) + n, (int )sizeof(int ));
#line 123
  luf->sv_prev = (int *)tmp___17;
#line 124
  tmp___18 = dy_glp_ucalloc((1 + n) + n, (int )sizeof(int ));
#line 124
  luf->sv_next = (int *)tmp___18;
#line 125
  k = 1;
  }
  {
#line 125
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 125
    if (! (k <= n + n)) {
#line 125
      goto while_break___5;
    }
#line 126
    *(luf->sv_prev + k) = k - 1;
#line 127
    *(luf->sv_next + k) = k + 1;
#line 125
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 129
  *(luf->sv_next + (n + n)) = 0;
#line 131
  tmp___19 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 131
  luf->flag = (int *)tmp___19;
#line 132
  tmp___20 = dy_glp_ucalloc(1 + n, (int )sizeof(double ));
#line 132
  luf->work = (double *)tmp___20;
#line 134
  luf->new_sva = 0;
#line 135
  luf->piv_tol = 0.10;
#line 136
  luf->piv_lim = 4;
#line 137
  luf->suhl = 1;
#line 138
  luf->eps_tol = 1e-15;
#line 139
  luf->max_gro = 1e+12;
#line 141
  luf->nnz_a = n;
#line 142
  luf->nnz_f = 0;
#line 143
  luf->nnz_v = 0;
#line 144
  luf->max_a = 1.0;
#line 145
  luf->big_v = 1.0;
#line 146
  luf->rank = n;
  }
#line 147
  return (luf);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_defrag_sva(LUF *luf ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_next ;
  int sv_beg ;
  int i ;
  int j ;
  int k ;

  {
#line 172
  n = luf->n;
#line 173
  vr_ptr = luf->vr_ptr;
#line 174
  vr_len = luf->vr_len;
#line 175
  vr_cap = luf->vr_cap;
#line 176
  vc_ptr = luf->vc_ptr;
#line 177
  vc_len = luf->vc_len;
#line 178
  vc_cap = luf->vc_cap;
#line 179
  sv_ndx = luf->sv_ndx;
#line 180
  sv_val = luf->sv_val;
#line 181
  sv_next = luf->sv_next;
#line 182
  sv_beg = 1;
#line 185
  k = luf->sv_head;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (k != 0)) {
#line 185
      goto while_break;
    }
#line 186
    if (k <= n) {
#line 188
      i = k;
#line 189
      if (*(vr_ptr + i) != sv_beg) {
#line 189
        goto while_break;
      }
#line 190
      *(vr_cap + i) = *(vr_len + i);
#line 191
      sv_beg += *(vr_cap + i);
    } else {
#line 195
      j = k - n;
#line 196
      if (*(vc_ptr + j) != sv_beg) {
#line 196
        goto while_break;
      }
#line 197
      *(vc_cap + j) = *(vc_len + j);
#line 198
      sv_beg += *(vc_cap + j);
    }
#line 185
    k = *(sv_next + k);
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  k = k;
  {
#line 203
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 203
    if (! (k != 0)) {
#line 203
      goto while_break___0;
    }
#line 204
    if (k <= n) {
      {
#line 206
      i = k;
#line 207
      memmove((void *)(sv_ndx + sv_beg), (void const   *)(sv_ndx + *(vr_ptr + i)),
              (unsigned long )*(vr_len + i) * sizeof(int ));
#line 209
      memmove((void *)(sv_val + sv_beg), (void const   *)(sv_val + *(vr_ptr + i)),
              (unsigned long )*(vr_len + i) * sizeof(double ));
#line 211
      *(vr_ptr + i) = sv_beg;
#line 212
      *(vr_cap + i) = *(vr_len + i);
#line 213
      sv_beg += *(vr_cap + i);
      }
    } else {
      {
#line 217
      j = k - n;
#line 218
      memmove((void *)(sv_ndx + sv_beg), (void const   *)(sv_ndx + *(vc_ptr + j)),
              (unsigned long )*(vc_len + j) * sizeof(int ));
#line 220
      memmove((void *)(sv_val + sv_beg), (void const   *)(sv_val + *(vc_ptr + j)),
              (unsigned long )*(vc_len + j) * sizeof(double ));
#line 222
      *(vc_ptr + j) = sv_beg;
#line 223
      *(vc_cap + j) = *(vc_len + j);
#line 224
      sv_beg += *(vc_cap + j);
      }
    }
#line 203
    k = *(sv_next + k);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 228
  luf->sv_beg = sv_beg;
#line 229
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
int dy_glp_luf_enlarge_row(LUF *luf , int i , int cap ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_cap ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int cur ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;

  {
#line 259
  n = luf->n;
#line 260
  vr_ptr = luf->vr_ptr;
#line 261
  vr_len = luf->vr_len;
#line 262
  vr_cap = luf->vr_cap;
#line 263
  vc_cap = luf->vc_cap;
#line 264
  sv_ndx = luf->sv_ndx;
#line 265
  sv_val = luf->sv_val;
#line 266
  sv_prev = luf->sv_prev;
#line 267
  sv_next = luf->sv_next;
#line 268
  ret = 0;
#line 270
  if (1 <= i) {
#line 270
    if (i <= n) {
#line 270
      tmp = 1;
    } else {
      {
#line 270
      dy_glp_insist("1 <= i && i <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    270);
#line 270
      tmp = 1;
      }
    }
  } else {
    {
#line 270
    dy_glp_insist("1 <= i && i <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  270);
#line 270
    tmp = 1;
    }
  }
#line 271
  if (*(vr_cap + i) < cap) {
#line 271
    tmp___0 = 1;
  } else {
    {
#line 271
    dy_glp_insist("vr_cap[i] < cap", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  271);
#line 271
    tmp___0 = 1;
    }
  }
#line 273
  if (luf->sv_end - luf->sv_beg < cap) {
    {
#line 274
    dy_glp_luf_defrag_sva(luf);
    }
#line 275
    if (luf->sv_end - luf->sv_beg < cap) {
#line 276
      ret = 1;
#line 277
      goto done;
    }
  }
  {
#line 281
  cur = *(vr_cap + i);
#line 283
  memmove((void *)(sv_ndx + luf->sv_beg), (void const   *)(sv_ndx + *(vr_ptr + i)),
          (unsigned long )*(vr_len + i) * sizeof(int ));
#line 285
  memmove((void *)(sv_val + luf->sv_beg), (void const   *)(sv_val + *(vr_ptr + i)),
          (unsigned long )*(vr_len + i) * sizeof(double ));
#line 288
  *(vr_ptr + i) = luf->sv_beg;
#line 289
  *(vr_cap + i) = cap;
#line 291
  luf->sv_beg += cap;
#line 295
  k = i;
  }
#line 297
  if (*(sv_prev + k) == 0) {
#line 298
    luf->sv_head = *(sv_next + k);
  } else {
#line 302
    kk = *(sv_prev + k);
#line 303
    if (kk <= n) {
#line 303
      *(vr_cap + kk) += cur;
    } else {
#line 303
      *(vc_cap + (kk - n)) += cur;
    }
#line 304
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 306
  if (*(sv_next + k) == 0) {
#line 307
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 309
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 311
  *(sv_prev + k) = luf->sv_tail;
#line 312
  *(sv_next + k) = 0;
#line 313
  if (*(sv_prev + k) == 0) {
#line 314
    luf->sv_head = k;
  } else {
#line 316
    *(sv_next + *(sv_prev + k)) = k;
  }
#line 317
  luf->sv_tail = k;
  done: 
#line 318
  return (ret);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
int dy_glp_luf_enlarge_col(LUF *luf , int j , int cap ) 
{ 
  int n ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int cur ;
  int k ;
  int kk ;
  int tmp ;
  int tmp___0 ;

  {
#line 349
  n = luf->n;
#line 350
  vr_cap = luf->vr_cap;
#line 351
  vc_ptr = luf->vc_ptr;
#line 352
  vc_len = luf->vc_len;
#line 353
  vc_cap = luf->vc_cap;
#line 354
  sv_ndx = luf->sv_ndx;
#line 355
  sv_val = luf->sv_val;
#line 356
  sv_prev = luf->sv_prev;
#line 357
  sv_next = luf->sv_next;
#line 358
  ret = 0;
#line 360
  if (1 <= j) {
#line 360
    if (j <= n) {
#line 360
      tmp = 1;
    } else {
      {
#line 360
      dy_glp_insist("1 <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    360);
#line 360
      tmp = 1;
      }
    }
  } else {
    {
#line 360
    dy_glp_insist("1 <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  360);
#line 360
    tmp = 1;
    }
  }
#line 361
  if (*(vc_cap + j) < cap) {
#line 361
    tmp___0 = 1;
  } else {
    {
#line 361
    dy_glp_insist("vc_cap[j] < cap", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  361);
#line 361
    tmp___0 = 1;
    }
  }
#line 363
  if (luf->sv_end - luf->sv_beg < cap) {
    {
#line 364
    dy_glp_luf_defrag_sva(luf);
    }
#line 365
    if (luf->sv_end - luf->sv_beg < cap) {
#line 366
      ret = 1;
#line 367
      goto done;
    }
  }
  {
#line 371
  cur = *(vc_cap + j);
#line 373
  memmove((void *)(sv_ndx + luf->sv_beg), (void const   *)(sv_ndx + *(vc_ptr + j)),
          (unsigned long )*(vc_len + j) * sizeof(int ));
#line 375
  memmove((void *)(sv_val + luf->sv_beg), (void const   *)(sv_val + *(vc_ptr + j)),
          (unsigned long )*(vc_len + j) * sizeof(double ));
#line 378
  *(vc_ptr + j) = luf->sv_beg;
#line 379
  *(vc_cap + j) = cap;
#line 381
  luf->sv_beg += cap;
#line 385
  k = n + j;
  }
#line 387
  if (*(sv_prev + k) == 0) {
#line 388
    luf->sv_head = *(sv_next + k);
  } else {
#line 392
    kk = *(sv_prev + k);
#line 393
    if (kk <= n) {
#line 393
      *(vr_cap + kk) += cur;
    } else {
#line 393
      *(vc_cap + (kk - n)) += cur;
    }
#line 394
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 396
  if (*(sv_next + k) == 0) {
#line 397
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 399
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 401
  *(sv_prev + k) = luf->sv_tail;
#line 402
  *(sv_next + k) = 0;
#line 403
  if (*(sv_prev + k) == 0) {
#line 404
    luf->sv_head = k;
  } else {
#line 406
    *(sv_next + *(sv_prev + k)) = k;
  }
#line 407
  luf->sv_tail = k;
  done: 
#line 408
  return (ret);
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
LUF_WA *dy_glp_luf_alloc_wa(LUF *luf ) 
{ 
  LUF_WA *wa ;
  int n ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 430
  n = luf->n;
#line 431
  tmp = dy_glp_umalloc((int )sizeof(LUF_WA ));
#line 431
  wa = (LUF_WA *)tmp;
#line 432
  tmp___0 = dy_glp_ucalloc(1 + n, (int )sizeof(double ));
#line 432
  wa->rs_max = (double *)tmp___0;
#line 433
  tmp___1 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 433
  wa->rs_head = (int *)tmp___1;
#line 434
  tmp___2 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 434
  wa->rs_prev = (int *)tmp___2;
#line 435
  tmp___3 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 435
  wa->rs_next = (int *)tmp___3;
#line 436
  tmp___4 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 436
  wa->cs_head = (int *)tmp___4;
#line 437
  tmp___5 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 437
  wa->cs_prev = (int *)tmp___5;
#line 438
  tmp___6 = dy_glp_ucalloc(1 + n, (int )sizeof(int ));
#line 438
  wa->cs_next = (int *)tmp___6;
  }
#line 439
  return (wa);
}
}
#line 455 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_free_wa(LUF_WA *wa ) 
{ 


  {
  {
#line 456
  dy_glp_ufree((void *)wa->rs_max);
#line 457
  dy_glp_ufree((void *)wa->rs_head);
#line 458
  dy_glp_ufree((void *)wa->rs_prev);
#line 459
  dy_glp_ufree((void *)wa->rs_next);
#line 460
  dy_glp_ufree((void *)wa->cs_head);
#line 461
  dy_glp_ufree((void *)wa->cs_prev);
#line 462
  dy_glp_ufree((void *)wa->cs_next);
#line 463
  dy_glp_ufree((void *)wa);
  }
#line 464
  return;
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
static int initialize(LUF *luf , void *info , int (*col)(void *info , int j , int *rn ,
                                                         double *aj ) , LUF_WA *wa ) 
{ 
  int n ;
  int *fc_ptr ;
  int *fc_len ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int *flag ;
  double *work ;
  double *rs_max ;
  int *rs_head ;
  int *rs_prev ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int ret ;
  int i ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int k ;
  int len ;
  int nnz ;
  int sv_beg ;
  int sv_end ;
  int ptr ;
  double big ;
  double val ;
  int tmp ;
  int *rn ;
  double *aj ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 482
  n = luf->n;
#line 483
  fc_ptr = luf->fc_ptr;
#line 484
  fc_len = luf->fc_len;
#line 485
  vr_ptr = luf->vr_ptr;
#line 486
  vr_len = luf->vr_len;
#line 487
  vr_cap = luf->vr_cap;
#line 488
  vc_ptr = luf->vc_ptr;
#line 489
  vc_len = luf->vc_len;
#line 490
  vc_cap = luf->vc_cap;
#line 491
  pp_row = luf->pp_row;
#line 492
  pp_col = luf->pp_col;
#line 493
  qq_row = luf->qq_row;
#line 494
  qq_col = luf->qq_col;
#line 495
  sv_ndx = luf->sv_ndx;
#line 496
  sv_val = luf->sv_val;
#line 497
  sv_prev = luf->sv_prev;
#line 498
  sv_next = luf->sv_next;
#line 499
  flag = luf->flag;
#line 500
  work = luf->work;
#line 501
  rs_max = wa->rs_max;
#line 502
  rs_head = wa->rs_head;
#line 503
  rs_prev = wa->rs_prev;
#line 504
  rs_next = wa->rs_next;
#line 505
  cs_head = wa->cs_head;
#line 506
  cs_prev = wa->cs_prev;
#line 507
  cs_next = wa->cs_next;
#line 508
  ret = 0;
#line 512
  sv_beg = 1;
#line 513
  sv_end = luf->sv_size + 1;
#line 517
  j = 1;
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! (j <= n)) {
#line 517
      goto while_break;
    }
#line 518
    *(fc_ptr + j) = sv_end;
#line 519
    *(fc_len + j) = 0;
#line 517
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  i = 1;
  {
#line 522
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 522
    if (! (i <= n)) {
#line 522
      goto while_break___0;
    }
#line 523
    tmp = 0;
#line 523
    *(vr_cap + i) = tmp;
#line 523
    *(vr_len + i) = tmp;
#line 523
    *(flag + i) = 0;
#line 522
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 527
  nnz = 0;
#line 528
  big = 0.0;
#line 529
  j = 1;
  {
#line 529
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 529
    if (! (j <= n)) {
#line 529
      goto while_break___1;
    }
    {
#line 530
    rn = pp_row;
#line 531
    aj = work;
#line 533
    len = (*col)(info, j, rn, aj);
    }
#line 534
    if (0 <= len) {
#line 534
      if (! (len <= n)) {
        {
#line 535
        dy_glp_fault("luf_decomp: j = %d; len = %d; invalid column length", j, len);
        }
      }
    } else {
      {
#line 535
      dy_glp_fault("luf_decomp: j = %d; len = %d; invalid column length", j, len);
      }
    }
#line 538
    if (sv_end - sv_beg < len) {
#line 540
      ret = 1;
#line 541
      goto done;
    }
#line 544
    *(vc_ptr + j) = sv_beg;
#line 546
    tmp___0 = len;
#line 546
    *(vc_cap + j) = tmp___0;
#line 546
    *(vc_len + j) = tmp___0;
#line 548
    nnz += len;
#line 550
    ptr = 1;
    {
#line 550
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 550
      if (! (ptr <= len)) {
#line 550
        goto while_break___2;
      }
#line 552
      i = *(rn + ptr);
#line 553
      val = *(aj + ptr);
#line 554
      if (1 <= i) {
#line 554
        if (! (i <= n)) {
          {
#line 555
          dy_glp_fault("luf_decomp: i = %d; j = %d; invalid row index", i, j);
          }
        }
      } else {
        {
#line 555
        dy_glp_fault("luf_decomp: i = %d; j = %d; invalid row index", i, j);
        }
      }
#line 557
      if (*(flag + i)) {
        {
#line 558
        dy_glp_fault("luf_decomp: i = %d; j = %d; duplicate element not allowed",
                     i, j);
        }
      }
#line 560
      if (val == 0.0) {
        {
#line 561
        dy_glp_fault("luf_decomp: i = %d; j = %d; zero element not allowed", i, j);
        }
      }
#line 564
      *(sv_ndx + sv_beg) = i;
#line 565
      *(sv_val + sv_beg) = val;
#line 566
      sv_beg ++;
#line 568
      if (val < 0.0) {
#line 568
        val = - val;
      }
#line 569
      if (big < val) {
#line 569
        big = val;
      }
#line 571
      *(flag + i) = 1;
#line 573
      (*(vr_cap + i)) ++;
#line 550
      ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 576
    ptr = 1;
    {
#line 576
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 576
      if (! (ptr <= len)) {
#line 576
        goto while_break___3;
      }
#line 576
      *(flag + *(rn + ptr)) = 0;
#line 576
      ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 529
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 579
  i = 1;
  {
#line 579
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 579
    if (! (i <= n)) {
#line 579
      goto while_break___4;
    }
#line 581
    len = *(vr_cap + i);
#line 583
    if (sv_end - sv_beg < len) {
#line 585
      ret = 1;
#line 586
      goto done;
    }
#line 589
    *(vr_ptr + i) = sv_beg;
#line 591
    sv_beg += len;
#line 579
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 595
  j = 1;
  {
#line 595
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 595
    if (! (j <= n)) {
#line 595
      goto while_break___5;
    }
#line 597
    j_beg = *(vc_ptr + j);
#line 598
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 599
    k = j_beg;
    {
#line 599
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 599
      if (! (k <= j_end)) {
#line 599
        goto while_break___6;
      }
#line 601
      i = *(sv_ndx + k);
#line 602
      val = *(sv_val + k);
#line 604
      i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 605
      *(sv_ndx + i_ptr) = j;
#line 606
      *(sv_val + i_ptr) = val;
#line 608
      (*(vr_len + i)) ++;
#line 599
      k ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 595
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 612
  k = 1;
  {
#line 612
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 612
    if (! (k <= n)) {
#line 612
      goto while_break___7;
    }
#line 613
    tmp___3 = k;
#line 613
    *(qq_col + k) = tmp___3;
#line 613
    tmp___2 = tmp___3;
#line 613
    *(qq_row + k) = tmp___2;
#line 613
    tmp___1 = tmp___2;
#line 613
    *(pp_col + k) = tmp___1;
#line 613
    *(pp_row + k) = tmp___1;
#line 612
    k ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 615
  luf->sv_beg = sv_beg;
#line 616
  luf->sv_end = sv_end;
#line 619
  luf->sv_head = n + 1;
#line 620
  luf->sv_tail = n;
#line 621
  i = 1;
  {
#line 621
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 621
    if (! (i <= n)) {
#line 621
      goto while_break___8;
    }
#line 622
    *(sv_prev + i) = i - 1;
#line 623
    *(sv_next + i) = i + 1;
#line 621
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 625
  *(sv_prev + 1) = n + n;
#line 626
  *(sv_next + n) = 0;
#line 627
  j = 1;
  {
#line 627
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 627
    if (! (j <= n)) {
#line 627
      goto while_break___9;
    }
#line 628
    *(sv_prev + (n + j)) = (n + j) - 1;
#line 629
    *(sv_next + (n + j)) = (n + j) + 1;
#line 627
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 631
  *(sv_prev + (n + 1)) = 0;
#line 632
  *(sv_next + (n + n)) = 1;
#line 634
  k = 1;
  {
#line 634
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 634
    if (! (k <= n)) {
#line 634
      goto while_break___10;
    }
#line 635
    *(flag + k) = 0;
#line 636
    *(work + k) = 0.0;
#line 634
    k ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 639
  luf->nnz_a = nnz;
#line 640
  luf->nnz_f = 0;
#line 641
  luf->nnz_v = nnz;
#line 642
  luf->max_a = big;
#line 643
  luf->big_v = big;
#line 644
  luf->rank = -1;
#line 648
  i = 1;
  {
#line 648
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 648
    if (! (i <= n)) {
#line 648
      goto while_break___11;
    }
#line 648
    *(rs_max + i) = - 1.0;
#line 648
    i ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 650
  len = 0;
  {
#line 650
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 650
    if (! (len <= n)) {
#line 650
      goto while_break___12;
    }
#line 650
    *(rs_head + len) = 0;
#line 650
    len ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 651
  i = 1;
  {
#line 651
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 651
    if (! (i <= n)) {
#line 651
      goto while_break___13;
    }
#line 652
    len = *(vr_len + i);
#line 653
    *(rs_prev + i) = 0;
#line 654
    *(rs_next + i) = *(rs_head + len);
#line 655
    if (*(rs_next + i) != 0) {
#line 655
      *(rs_prev + *(rs_next + i)) = i;
    }
#line 656
    *(rs_head + len) = i;
#line 651
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 659
  len = 0;
  {
#line 659
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 659
    if (! (len <= n)) {
#line 659
      goto while_break___14;
    }
#line 659
    *(cs_head + len) = 0;
#line 659
    len ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 660
  j = 1;
  {
#line 660
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 660
    if (! (j <= n)) {
#line 660
      goto while_break___15;
    }
#line 661
    len = *(vc_len + j);
#line 662
    *(cs_prev + j) = 0;
#line 663
    *(cs_next + j) = *(cs_head + len);
#line 664
    if (*(cs_next + j) != 0) {
#line 664
      *(cs_prev + *(cs_next + j)) = j;
    }
#line 665
    *(cs_head + len) = j;
#line 660
    j ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  done: 
#line 668
  return (ret);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
static int find_pivot(LUF *luf , LUF_WA *wa , int *_p , int *_q ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vc_ptr ;
  int *vc_len ;
  int *sv_ndx ;
  double *sv_val ;
  double piv_tol ;
  int piv_lim ;
  int suhl ;
  double *rs_max ;
  int *rs_head ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int p ;
  int q ;
  int len ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int ncand ;
  int next_j ;
  int min_p ;
  int min_q ;
  int min_len ;
  double best ;
  double cost ;
  double big ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 732
  n = luf->n;
#line 733
  vr_ptr = luf->vr_ptr;
#line 734
  vr_len = luf->vr_len;
#line 735
  vc_ptr = luf->vc_ptr;
#line 736
  vc_len = luf->vc_len;
#line 737
  sv_ndx = luf->sv_ndx;
#line 738
  sv_val = luf->sv_val;
#line 739
  piv_tol = luf->piv_tol;
#line 740
  piv_lim = luf->piv_lim;
#line 741
  suhl = luf->suhl;
#line 742
  rs_max = wa->rs_max;
#line 743
  rs_head = wa->rs_head;
#line 744
  rs_next = wa->rs_next;
#line 745
  cs_head = wa->cs_head;
#line 746
  cs_prev = wa->cs_prev;
#line 747
  cs_next = wa->cs_next;
#line 752
  q = 0;
#line 752
  p = q;
#line 752
  best = (double )1.79769313486231570815e+308L;
#line 752
  ncand = 0;
#line 755
  j = *(cs_head + 1);
#line 756
  if (j != 0) {
#line 757
    if (*(vc_len + j) == 1) {
#line 757
      tmp = 1;
    } else {
      {
#line 757
      dy_glp_insist("vc_len[j] == 1", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    757);
#line 757
      tmp = 1;
      }
    }
#line 758
    p = *(sv_ndx + *(vc_ptr + j));
#line 758
    q = j;
#line 759
    goto done;
  }
#line 763
  i = *(rs_head + 1);
#line 764
  if (i != 0) {
#line 765
    if (*(vr_len + i) == 1) {
#line 765
      tmp___0 = 1;
    } else {
      {
#line 765
      dy_glp_insist("vr_len[i] == 1", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    765);
#line 765
      tmp___0 = 1;
      }
    }
#line 766
    p = i;
#line 766
    q = *(sv_ndx + *(vr_ptr + i));
#line 767
    goto done;
  }
#line 771
  len = 2;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (len <= n)) {
#line 771
      goto while_break;
    }
#line 773
    j = *(cs_head + len);
    {
#line 773
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 773
      if (! (j != 0)) {
#line 773
        goto while_break___0;
      }
#line 775
      j_beg = *(vc_ptr + j);
#line 776
      j_end = (j_beg + *(vc_len + j)) - 1;
#line 778
      next_j = *(cs_next + j);
#line 782
      min_q = 0;
#line 782
      min_p = min_q;
#line 782
      min_len = 2147483647;
#line 783
      j_ptr = j_beg;
      {
#line 783
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 783
        if (! (j_ptr <= j_end)) {
#line 783
          goto while_break___1;
        }
#line 785
        i = *(sv_ndx + j_ptr);
#line 786
        i_beg = *(vr_ptr + i);
#line 787
        i_end = (i_beg + *(vr_len + i)) - 1;
#line 790
        if (*(vr_len + i) >= min_len) {
#line 790
          goto __Cont;
        }
#line 793
        big = *(rs_max + i);
#line 794
        if (big < 0.0) {
#line 796
          i_ptr = i_beg;
          {
#line 796
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 796
            if (! (i_ptr <= i_end)) {
#line 796
              goto while_break___2;
            }
#line 797
            temp = *(sv_val + i_ptr);
#line 798
            if (temp < 0.0) {
#line 798
              temp = - temp;
            }
#line 799
            if (big < temp) {
#line 799
              big = temp;
            }
#line 796
            i_ptr ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 801
          *(rs_max + i) = big;
        }
#line 804
        i_ptr = *(vr_ptr + i);
        {
#line 804
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 804
          if (! (*(sv_ndx + i_ptr) != j)) {
#line 804
            goto while_break___3;
          }
#line 804
          i_ptr ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 805
        if (i_ptr <= i_end) {
#line 805
          tmp___1 = 1;
        } else {
          {
#line 805
          dy_glp_insist("i_ptr <= i_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                        805);
#line 805
          tmp___1 = 1;
          }
        }
#line 808
        temp = *(sv_val + i_ptr);
#line 809
        if (temp < 0.0) {
#line 809
          temp = - temp;
        }
#line 810
        if (temp < piv_tol * big) {
#line 810
          goto __Cont;
        }
#line 812
        min_p = i;
#line 812
        min_q = j;
#line 812
        min_len = *(vr_len + i);
#line 817
        if (min_len <= len) {
#line 818
          p = min_p;
#line 818
          q = min_q;
#line 819
          goto done;
        }
        __Cont: /* CIL Label */ 
#line 783
        j_ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 823
      if (min_p != 0) {
#line 825
        ncand ++;
#line 827
        cost = (double )(min_len - 1) * (double )(len - 1);
#line 830
        if (cost < best) {
#line 830
          p = min_p;
#line 830
          q = min_q;
#line 830
          best = cost;
        }
#line 834
        if (ncand == piv_lim) {
#line 834
          goto done;
        }
      } else
#line 842
      if (suhl) {
#line 844
        if (*(cs_prev + j) == 0) {
#line 845
          *(cs_head + len) = *(cs_next + j);
        } else {
#line 847
          *(cs_next + *(cs_prev + j)) = *(cs_next + j);
        }
#line 848
        if (! (*(cs_next + j) == 0)) {
#line 851
          *(cs_prev + *(cs_next + j)) = *(cs_prev + j);
        }
#line 855
        tmp___2 = j;
#line 855
        *(cs_next + j) = tmp___2;
#line 855
        *(cs_prev + j) = tmp___2;
      }
#line 773
      j = next_j;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 860
    i = *(rs_head + len);
    {
#line 860
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 860
      if (! (i != 0)) {
#line 860
        goto while_break___4;
      }
#line 862
      i_beg = *(vr_ptr + i);
#line 863
      i_end = (i_beg + *(vr_len + i)) - 1;
#line 866
      big = *(rs_max + i);
#line 867
      if (big < 0.0) {
#line 869
        i_ptr = i_beg;
        {
#line 869
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 869
          if (! (i_ptr <= i_end)) {
#line 869
            goto while_break___5;
          }
#line 870
          temp = *(sv_val + i_ptr);
#line 871
          if (temp < 0.0) {
#line 871
            temp = - temp;
          }
#line 872
          if (big < temp) {
#line 872
            big = temp;
          }
#line 869
          i_ptr ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 874
        *(rs_max + i) = big;
      }
#line 879
      min_q = 0;
#line 879
      min_p = min_q;
#line 879
      min_len = 2147483647;
#line 880
      i_ptr = i_beg;
      {
#line 880
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 880
        if (! (i_ptr <= i_end)) {
#line 880
          goto while_break___6;
        }
#line 882
        j = *(sv_ndx + i_ptr);
#line 885
        if (*(vc_len + j) >= min_len) {
#line 885
          goto __Cont___0;
        }
#line 888
        temp = *(sv_val + i_ptr);
#line 889
        if (temp < 0.0) {
#line 889
          temp = - temp;
        }
#line 890
        if (temp < piv_tol * big) {
#line 890
          goto __Cont___0;
        }
#line 892
        min_p = i;
#line 892
        min_q = j;
#line 892
        min_len = *(vc_len + j);
#line 897
        if (min_len <= len) {
#line 898
          p = min_p;
#line 898
          q = min_q;
#line 899
          goto done;
        }
        __Cont___0: /* CIL Label */ 
#line 880
        i_ptr ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 903
      if (min_p != 0) {
#line 905
        ncand ++;
#line 907
        cost = (double )(len - 1) * (double )(min_len - 1);
#line 910
        if (cost < best) {
#line 910
          p = min_p;
#line 910
          q = min_q;
#line 910
          best = cost;
        }
#line 914
        if (ncand == piv_lim) {
#line 914
          goto done;
        }
      } else
#line 918
      if (min_p != min_p) {
#line 918
        tmp___3 = 1;
      } else {
        {
#line 918
        dy_glp_insist("min_p != min_p", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                      918);
#line 918
        tmp___3 = 1;
        }
      }
#line 860
      i = *(rs_next + i);
    }
    while_break___4: /* CIL Label */ ;
    }
#line 771
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 923
  *_p = p;
#line 923
  *_q = q;
#line 924
  return (p == 0);
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
static int eliminate(LUF *luf , LUF_WA *wa , int p , int q ) 
{ 
  int n ;
  int *fc_ptr ;
  int *fc_len ;
  int *vr_ptr ;
  int *vr_len ;
  int *vr_cap ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int *flag ;
  double *work ;
  double eps_tol ;
  double *rs_max ;
  int *rs_head ;
  int *rs_prev ;
  int *rs_next ;
  int *cs_head ;
  int *cs_prev ;
  int *cs_next ;
  int *ndx ;
  int ret ;
  int len ;
  int fill ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int k ;
  int p_beg ;
  int p_end ;
  int p_ptr ;
  int q_beg ;
  int q_end ;
  int q_ptr ;
  double fip ;
  double val ;
  double vpq ;
  double temp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 990
  n = luf->n;
#line 991
  fc_ptr = luf->fc_ptr;
#line 992
  fc_len = luf->fc_len;
#line 993
  vr_ptr = luf->vr_ptr;
#line 994
  vr_len = luf->vr_len;
#line 995
  vr_cap = luf->vr_cap;
#line 996
  vr_piv = luf->vr_piv;
#line 997
  vc_ptr = luf->vc_ptr;
#line 998
  vc_len = luf->vc_len;
#line 999
  vc_cap = luf->vc_cap;
#line 1000
  sv_ndx = luf->sv_ndx;
#line 1001
  sv_val = luf->sv_val;
#line 1002
  sv_prev = luf->sv_prev;
#line 1003
  sv_next = luf->sv_next;
#line 1004
  flag = luf->flag;
#line 1005
  work = luf->work;
#line 1006
  eps_tol = luf->eps_tol;
#line 1007
  rs_max = wa->rs_max;
#line 1008
  rs_head = wa->rs_head;
#line 1009
  rs_prev = wa->rs_prev;
#line 1010
  rs_next = wa->rs_next;
#line 1011
  cs_head = wa->cs_head;
#line 1012
  cs_prev = wa->cs_prev;
#line 1013
  cs_next = wa->cs_next;
#line 1016
  ndx = luf->fr_len;
#line 1017
  ret = 0;
#line 1021
  if (1 <= p) {
#line 1021
    if (p <= n) {
#line 1021
      tmp = 1;
    } else {
      {
#line 1021
      dy_glp_insist("1 <= p && p <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    1021);
#line 1021
      tmp = 1;
      }
    }
  } else {
    {
#line 1021
    dy_glp_insist("1 <= p && p <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  1021);
#line 1021
    tmp = 1;
    }
  }
#line 1022
  if (1 <= q) {
#line 1022
    if (q <= n) {
#line 1022
      tmp___0 = 1;
    } else {
      {
#line 1022
      dy_glp_insist("1 <= q && q <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    1022);
#line 1022
      tmp___0 = 1;
      }
    }
  } else {
    {
#line 1022
    dy_glp_insist("1 <= q && q <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  1022);
#line 1022
    tmp___0 = 1;
    }
  }
#line 1025
  if (*(rs_prev + p) == 0) {
#line 1026
    *(rs_head + *(vr_len + p)) = *(rs_next + p);
  } else {
#line 1028
    *(rs_next + *(rs_prev + p)) = *(rs_next + p);
  }
#line 1029
  if (! (*(rs_next + p) == 0)) {
#line 1032
    *(rs_prev + *(rs_next + p)) = *(rs_prev + p);
  }
#line 1035
  if (*(cs_prev + q) == 0) {
#line 1036
    *(cs_head + *(vc_len + q)) = *(cs_next + q);
  } else {
#line 1038
    *(cs_next + *(cs_prev + q)) = *(cs_next + q);
  }
#line 1039
  if (! (*(cs_next + q) == 0)) {
#line 1042
    *(cs_prev + *(cs_next + q)) = *(cs_prev + q);
  }
#line 1044
  p_beg = *(vr_ptr + p);
#line 1045
  p_end = (p_beg + *(vr_len + p)) - 1;
#line 1046
  p_ptr = p_beg;
  {
#line 1046
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1046
    if (! (*(sv_ndx + p_ptr) != q)) {
#line 1046
      goto while_break;
    }
#line 1046
    p_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  if (p_ptr <= p_end) {
#line 1047
    tmp___1 = 1;
  } else {
    {
#line 1047
    dy_glp_insist("p_ptr <= p_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  1047);
#line 1047
    tmp___1 = 1;
    }
  }
#line 1049
  tmp___2 = *(sv_val + p_ptr);
#line 1049
  *(vr_piv + p) = tmp___2;
#line 1049
  vpq = tmp___2;
#line 1051
  *(sv_ndx + p_ptr) = *(sv_ndx + p_end);
#line 1052
  *(sv_val + p_ptr) = *(sv_val + p_end);
#line 1053
  (*(vr_len + p)) --;
#line 1054
  p_end --;
#line 1056
  q_beg = *(vc_ptr + q);
#line 1057
  q_end = (q_beg + *(vc_len + q)) - 1;
#line 1058
  q_ptr = q_beg;
  {
#line 1058
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1058
    if (! (*(sv_ndx + q_ptr) != p)) {
#line 1058
      goto while_break___0;
    }
#line 1058
    q_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1059
  if (q_ptr <= q_end) {
#line 1059
    tmp___3 = 1;
  } else {
    {
#line 1059
    dy_glp_insist("q_ptr <= q_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  1059);
#line 1059
    tmp___3 = 1;
    }
  }
#line 1061
  *(sv_ndx + q_ptr) = *(sv_ndx + q_end);
#line 1062
  (*(vc_len + q)) --;
#line 1063
  q_end --;
#line 1066
  p_ptr = p_beg;
  {
#line 1066
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1066
    if (! (p_ptr <= p_end)) {
#line 1066
      goto while_break___1;
    }
#line 1068
    j = *(sv_ndx + p_ptr);
#line 1070
    *(flag + j) = 1;
#line 1071
    *(work + j) = *(sv_val + p_ptr);
#line 1074
    if (*(cs_prev + j) == 0) {
#line 1075
      *(cs_head + *(vc_len + j)) = *(cs_next + j);
    } else {
#line 1077
      *(cs_next + *(cs_prev + j)) = *(cs_next + j);
    }
#line 1078
    if (! (*(cs_next + j) == 0)) {
#line 1081
      *(cs_prev + *(cs_next + j)) = *(cs_prev + j);
    }
#line 1083
    j_beg = *(vc_ptr + j);
#line 1084
    j_end = (j_beg + *(vc_len + j)) - 1;
#line 1085
    j_ptr = j_beg;
    {
#line 1085
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1085
      if (! (*(sv_ndx + j_ptr) != p)) {
#line 1085
        goto while_break___2;
      }
#line 1085
      j_ptr ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1086
    if (j_ptr <= j_end) {
#line 1086
      tmp___4 = 1;
    } else {
      {
#line 1086
      dy_glp_insist("j_ptr <= j_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    1086);
#line 1086
      tmp___4 = 1;
      }
    }
#line 1089
    *(sv_ndx + j_ptr) = *(sv_ndx + j_end);
#line 1090
    (*(vc_len + j)) --;
#line 1066
    p_ptr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1094
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1094
    if (! (q_beg <= q_end)) {
#line 1094
      goto while_break___3;
    }
#line 1097
    i = *(sv_ndx + q_beg);
#line 1100
    if (*(rs_prev + i) == 0) {
#line 1101
      *(rs_head + *(vr_len + i)) = *(rs_next + i);
    } else {
#line 1103
      *(rs_next + *(rs_prev + i)) = *(rs_next + i);
    }
#line 1104
    if (! (*(rs_next + i) == 0)) {
#line 1107
      *(rs_prev + *(rs_next + i)) = *(rs_prev + i);
    }
#line 1109
    i_beg = *(vr_ptr + i);
#line 1110
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1111
    i_ptr = i_beg;
    {
#line 1111
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1111
      if (! (*(sv_ndx + i_ptr) != q)) {
#line 1111
        goto while_break___4;
      }
#line 1111
      i_ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1112
    if (i_ptr <= i_end) {
#line 1112
      tmp___5 = 1;
    } else {
      {
#line 1112
      dy_glp_insist("i_ptr <= i_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    1112);
#line 1112
      tmp___5 = 1;
      }
    }
#line 1114
    fip = *(sv_val + i_ptr) / vpq;
#line 1117
    *(sv_ndx + i_ptr) = *(sv_ndx + i_end);
#line 1118
    *(sv_val + i_ptr) = *(sv_val + i_end);
#line 1119
    (*(vr_len + i)) --;
#line 1120
    i_end --;
#line 1122
    *(sv_ndx + q_beg) = *(sv_ndx + q_end);
#line 1123
    (*(vc_len + q)) --;
#line 1124
    q_end --;
#line 1132
    fill = *(vr_len + p);
#line 1133
    i_ptr = i_beg;
    {
#line 1133
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1133
      if (! (i_ptr <= i_end)) {
#line 1133
        goto while_break___5;
      }
#line 1135
      j = *(sv_ndx + i_ptr);
#line 1137
      if (*(flag + j)) {
#line 1139
        tmp___6 = *(sv_val + i_ptr) - fip * *(work + j);
#line 1139
        *(sv_val + i_ptr) = tmp___6;
#line 1139
        temp = tmp___6;
#line 1140
        if (temp < 0.0) {
#line 1140
          temp = - temp;
        }
#line 1141
        *(flag + j) = 0;
#line 1142
        fill --;
#line 1143
        if (temp == 0.0) {
#line 1143
          goto _L;
        } else
#line 1143
        if (temp < eps_tol) {
          _L: /* CIL Label */ 
#line 1147
          *(sv_ndx + i_ptr) = *(sv_ndx + i_end);
#line 1148
          *(sv_val + i_ptr) = *(sv_val + i_end);
#line 1149
          (*(vr_len + i)) --;
#line 1150
          i_ptr --;
#line 1151
          i_end --;
#line 1153
          j_beg = *(vc_ptr + j);
#line 1154
          j_end = (j_beg + *(vc_len + j)) - 1;
#line 1155
          j_ptr = j_beg;
          {
#line 1155
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1155
            if (! (*(sv_ndx + j_ptr) != i)) {
#line 1155
              goto while_break___6;
            }
#line 1155
            j_ptr ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1156
          if (j_ptr <= j_end) {
#line 1156
            tmp___7 = 1;
          } else {
            {
#line 1156
            dy_glp_insist("j_ptr <= j_end", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                          1156);
#line 1156
            tmp___7 = 1;
            }
          }
#line 1158
          *(sv_ndx + j_ptr) = *(sv_ndx + j_end);
#line 1159
          (*(vc_len + j)) --;
        } else
#line 1163
        if (luf->big_v < temp) {
#line 1163
          luf->big_v = temp;
        }
      }
#line 1133
      i_ptr ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1170
    if (*(vr_len + i) + fill > *(vr_cap + i)) {
      {
#line 1172
      tmp___8 = dy_glp_luf_enlarge_row(luf, i, *(vr_len + i) + fill);
      }
#line 1172
      if (tmp___8) {
#line 1174
        ret = 1;
#line 1175
        goto done;
      }
#line 1179
      p_beg = *(vr_ptr + p);
#line 1180
      p_end = (p_beg + *(vr_len + p)) - 1;
#line 1181
      q_beg = *(vc_ptr + q);
#line 1182
      q_end = (q_beg + *(vc_len + q)) - 1;
    }
#line 1187
    len = 0;
#line 1188
    p_ptr = p_beg;
    {
#line 1188
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1188
      if (! (p_ptr <= p_end)) {
#line 1188
        goto while_break___7;
      }
#line 1190
      j = *(sv_ndx + p_ptr);
#line 1191
      if (*(flag + j)) {
#line 1193
        val = - fip * *(work + j);
#line 1193
        temp = val;
#line 1194
        if (temp < 0.0) {
#line 1194
          temp = - temp;
        }
#line 1195
        if (! (temp == 0.0)) {
#line 1195
          if (! (temp < eps_tol)) {
#line 1199
            i_ptr = *(vr_ptr + i) + *(vr_len + i);
#line 1200
            *(sv_ndx + i_ptr) = j;
#line 1201
            *(sv_val + i_ptr) = val;
#line 1202
            (*(vr_len + i)) ++;
#line 1204
            len ++;
#line 1204
            *(ndx + len) = j;
#line 1206
            if (luf->big_v < temp) {
#line 1206
              luf->big_v = temp;
            }
          }
        }
      } else {
#line 1213
        *(flag + j) = 1;
      }
#line 1188
      p_ptr ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1217
    k = 1;
    {
#line 1217
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1217
      if (! (k <= len)) {
#line 1217
        goto while_break___8;
      }
#line 1219
      j = *(ndx + k);
#line 1221
      if (*(vc_len + j) + 1 > *(vc_cap + j)) {
        {
#line 1223
        tmp___9 = dy_glp_luf_enlarge_col(luf, j, *(vc_len + j) + 10);
        }
#line 1223
        if (tmp___9) {
#line 1225
          ret = 1;
#line 1226
          goto done;
        }
#line 1230
        p_beg = *(vr_ptr + p);
#line 1231
        p_end = (p_beg + *(vr_len + p)) - 1;
#line 1232
        q_beg = *(vc_ptr + q);
#line 1233
        q_end = (q_beg + *(vc_len + q)) - 1;
      }
#line 1236
      j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 1237
      *(sv_ndx + j_ptr) = i;
#line 1238
      (*(vc_len + j)) ++;
#line 1217
      k ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1242
    *(rs_prev + i) = 0;
#line 1243
    *(rs_next + i) = *(rs_head + *(vr_len + i));
#line 1244
    if (*(rs_next + i) != 0) {
#line 1244
      *(rs_prev + *(rs_next + i)) = i;
    }
#line 1245
    *(rs_head + *(vr_len + i)) = i;
#line 1248
    *(rs_max + i) = - 1.0;
#line 1251
    if (luf->sv_end - luf->sv_beg < 1) {
      {
#line 1253
      dy_glp_luf_defrag_sva(luf);
      }
#line 1254
      if (luf->sv_end - luf->sv_beg < 1) {
#line 1256
        ret = 1;
#line 1257
        goto done;
      }
#line 1261
      p_beg = *(vr_ptr + p);
#line 1262
      p_end = (p_beg + *(vr_len + p)) - 1;
#line 1263
      q_beg = *(vc_ptr + q);
#line 1264
      q_end = (q_beg + *(vc_len + q)) - 1;
    }
#line 1268
    (luf->sv_end) --;
#line 1269
    *(sv_ndx + luf->sv_end) = i;
#line 1270
    *(sv_val + luf->sv_end) = fip;
#line 1271
    (*(fc_len + p)) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1275
  if (*(vc_len + q) == 0) {
#line 1275
    tmp___10 = 1;
  } else {
    {
#line 1275
    dy_glp_insist("vc_len[q] == 0", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                  1275);
#line 1275
    tmp___10 = 1;
    }
  }
#line 1277
  *(vc_cap + q) = 0;
#line 1279
  k = n + q;
#line 1280
  if (*(sv_prev + k) == 0) {
#line 1281
    luf->sv_head = *(sv_next + k);
  } else {
#line 1283
    *(sv_next + *(sv_prev + k)) = *(sv_next + k);
  }
#line 1284
  if (*(sv_next + k) == 0) {
#line 1285
    luf->sv_tail = *(sv_prev + k);
  } else {
#line 1287
    *(sv_prev + *(sv_next + k)) = *(sv_prev + k);
  }
#line 1290
  *(fc_ptr + p) = luf->sv_end;
#line 1292
  p_ptr = p_beg;
  {
#line 1292
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1292
    if (! (p_ptr <= p_end)) {
#line 1292
      goto while_break___9;
    }
#line 1294
    j = *(sv_ndx + p_ptr);
#line 1296
    *(flag + j) = 0;
#line 1297
    *(work + j) = 0.0;
#line 1305
    if (*(vc_len + j) != 1) {
#line 1305
      if (*(cs_prev + j) == j) {
#line 1305
        if (! (*(cs_next + j) == j)) {
#line 1305
          goto _L___1;
        }
      } else {
#line 1305
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1306
      *(cs_prev + j) = 0;
#line 1307
      *(cs_next + j) = *(cs_head + *(vc_len + j));
#line 1308
      if (*(cs_next + j) != 0) {
#line 1308
        *(cs_prev + *(cs_next + j)) = j;
      }
#line 1309
      *(cs_head + *(vc_len + j)) = j;
    }
#line 1292
    p_ptr ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  done: 
#line 1313
  return (ret);
}
}
#line 1325 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
static int build_v_cols(LUF *luf ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  int *vc_ptr ;
  int *vc_len ;
  int *vc_cap ;
  int *sv_ndx ;
  double *sv_val ;
  int *sv_prev ;
  int *sv_next ;
  int ret ;
  int i ;
  int i_beg ;
  int i_end ;
  int i_ptr ;
  int j ;
  int j_ptr ;
  int k ;
  int nnz ;

  {
#line 1326
  n = luf->n;
#line 1327
  vr_ptr = luf->vr_ptr;
#line 1328
  vr_len = luf->vr_len;
#line 1329
  vc_ptr = luf->vc_ptr;
#line 1330
  vc_len = luf->vc_len;
#line 1331
  vc_cap = luf->vc_cap;
#line 1332
  sv_ndx = luf->sv_ndx;
#line 1333
  sv_val = luf->sv_val;
#line 1334
  sv_prev = luf->sv_prev;
#line 1335
  sv_next = luf->sv_next;
#line 1336
  ret = 0;
#line 1343
  nnz = 0;
#line 1344
  i = 1;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1344
    if (! (i <= n)) {
#line 1344
      goto while_break;
    }
#line 1347
    i_beg = *(vr_ptr + i);
#line 1348
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1349
    i_ptr = i_beg;
    {
#line 1349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1349
      if (! (i_ptr <= i_end)) {
#line 1349
        goto while_break___0;
      }
#line 1350
      (*(vc_cap + *(sv_ndx + i_ptr))) ++;
#line 1349
      i_ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1352
    nnz += *(vr_len + i);
#line 1344
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  luf->nnz_v = nnz;
#line 1357
  if (luf->sv_end - luf->sv_beg < nnz) {
#line 1359
    ret = 1;
#line 1360
    goto done;
  }
#line 1363
  j = 1;
  {
#line 1363
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1363
    if (! (j <= n)) {
#line 1363
      goto while_break___1;
    }
#line 1365
    *(vc_ptr + j) = luf->sv_beg;
#line 1367
    luf->sv_beg += *(vc_cap + j);
#line 1363
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1371
  i = 1;
  {
#line 1371
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1371
    if (! (i <= n)) {
#line 1371
      goto while_break___2;
    }
#line 1373
    i_beg = *(vr_ptr + i);
#line 1374
    i_end = (i_beg + *(vr_len + i)) - 1;
#line 1375
    i_ptr = i_beg;
    {
#line 1375
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1375
      if (! (i_ptr <= i_end)) {
#line 1375
        goto while_break___3;
      }
#line 1377
      j = *(sv_ndx + i_ptr);
#line 1379
      j_ptr = *(vc_ptr + j) + *(vc_len + j);
#line 1380
      *(sv_ndx + j_ptr) = i;
#line 1381
      *(sv_val + j_ptr) = *(sv_val + i_ptr);
#line 1383
      (*(vc_len + j)) ++;
#line 1375
      i_ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1371
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1389
  k = n + 1;
  {
#line 1389
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1389
    if (! (k <= n + n)) {
#line 1389
      goto while_break___4;
    }
#line 1390
    *(sv_prev + k) = k - 1;
#line 1391
    *(sv_next + k) = k + 1;
#line 1389
    k ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1393
  *(sv_prev + (n + 1)) = luf->sv_tail;
#line 1394
  *(sv_next + luf->sv_tail) = n + 1;
#line 1395
  *(sv_next + (n + n)) = 0;
#line 1396
  luf->sv_tail = n + n;
  done: 
#line 1398
  return (ret);
}
}
#line 1410 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
static int build_f_rows(LUF *luf ) 
{ 
  int n ;
  int *fr_ptr ;
  int *fr_len ;
  int *fc_ptr ;
  int *fc_len ;
  int *sv_ndx ;
  double *sv_val ;
  int ret ;
  int i ;
  int j ;
  int j_beg ;
  int j_end ;
  int j_ptr ;
  int ptr ;
  int nnz ;

  {
#line 1411
  n = luf->n;
#line 1412
  fr_ptr = luf->fr_ptr;
#line 1413
  fr_len = luf->fr_len;
#line 1414
  fc_ptr = luf->fc_ptr;
#line 1415
  fc_len = luf->fc_len;
#line 1416
  sv_ndx = luf->sv_ndx;
#line 1417
  sv_val = luf->sv_val;
#line 1418
  ret = 0;
#line 1421
  i = 1;
  {
#line 1421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1421
    if (! (i <= n)) {
#line 1421
      goto while_break;
    }
#line 1421
    *(fr_len + i) = 0;
#line 1421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1424
  nnz = 0;
#line 1425
  j = 1;
  {
#line 1425
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1425
    if (! (j <= n)) {
#line 1425
      goto while_break___0;
    }
#line 1428
    j_beg = *(fc_ptr + j);
#line 1429
    j_end = (j_beg + *(fc_len + j)) - 1;
#line 1430
    j_ptr = j_beg;
    {
#line 1430
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1430
      if (! (j_ptr <= j_end)) {
#line 1430
        goto while_break___1;
      }
#line 1431
      (*(fr_len + *(sv_ndx + j_ptr))) ++;
#line 1430
      j_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1433
    nnz += *(fc_len + j);
#line 1425
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1436
  luf->nnz_f = nnz;
#line 1438
  if (luf->sv_end - luf->sv_beg < nnz) {
#line 1440
    ret = 1;
#line 1441
    goto done;
  }
#line 1444
  i = 1;
  {
#line 1444
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1444
    if (! (i <= n)) {
#line 1444
      goto while_break___2;
    }
#line 1447
    *(fr_ptr + i) = luf->sv_end;
#line 1449
    luf->sv_end -= *(fr_len + i);
#line 1444
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1453
  j = 1;
  {
#line 1453
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1453
    if (! (j <= n)) {
#line 1453
      goto while_break___3;
    }
#line 1455
    j_beg = *(fc_ptr + j);
#line 1456
    j_end = (j_beg + *(fc_len + j)) - 1;
#line 1457
    j_ptr = j_beg;
    {
#line 1457
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1457
      if (! (j_ptr <= j_end)) {
#line 1457
        goto while_break___4;
      }
#line 1459
      i = *(sv_ndx + j_ptr);
#line 1461
      (*(fr_ptr + i)) --;
#line 1461
      ptr = *(fr_ptr + i);
#line 1462
      *(sv_ndx + ptr) = j;
#line 1463
      *(sv_val + ptr) = *(sv_val + j_ptr);
#line 1457
      j_ptr ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1453
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 1467
  return (ret);
}
}
#line 1557 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
int dy_glp_luf_decomp(LUF *luf , void *info , int (*col)(void *info , int j , int *rn ,
                                                         double *aj ) , LUF_WA *_wa ) 
{ 
  int n ;
  int *pp_row ;
  int *pp_col ;
  int *qq_row ;
  int *qq_col ;
  double piv_tol ;
  int piv_lim ;
  int suhl ;
  double eps_tol ;
  double max_gro ;
  LUF_WA *wa ;
  LUF_WA *tmp ;
  LUF_WA *tmp___0 ;
  int ret ;
  int i ;
  int j ;
  int k ;
  int p ;
  int q ;
  int t ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1560
  n = luf->n;
#line 1561
  pp_row = luf->pp_row;
#line 1562
  pp_col = luf->pp_col;
#line 1563
  qq_row = luf->qq_row;
#line 1564
  qq_col = luf->qq_col;
#line 1565
  piv_tol = luf->piv_tol;
#line 1566
  piv_lim = luf->piv_lim;
#line 1567
  suhl = luf->suhl;
#line 1568
  eps_tol = luf->eps_tol;
#line 1569
  max_gro = luf->max_gro;
#line 1570
  if ((unsigned long )_wa == (unsigned long )((void *)0)) {
    {
#line 1570
    tmp = dy_glp_luf_alloc_wa(luf);
#line 1570
    tmp___0 = tmp;
    }
  } else {
#line 1570
    tmp___0 = _wa;
  }
#line 1570
  wa = tmp___0;
#line 1571
  ret = 0;
#line 1574
  if (0.0 < piv_tol) {
#line 1574
    if (! (piv_tol < 1.0)) {
      {
#line 1575
      dy_glp_fault("luf_decomp: piv_tol = %g; invalid parameter", piv_tol);
      }
    }
  } else {
    {
#line 1575
    dy_glp_fault("luf_decomp: piv_tol = %g; invalid parameter", piv_tol);
    }
  }
#line 1576
  if (! (piv_lim > 0)) {
    {
#line 1577
    dy_glp_fault("luf_decomp: piv_lim = %d; invalid parameter", piv_lim);
    }
  }
#line 1578
  if (! (suhl == 0)) {
#line 1578
    if (! (suhl == 1)) {
      {
#line 1579
      dy_glp_fault("luf_decomp: suhl = %d; invalid parameter", suhl);
      }
    }
  }
#line 1580
  if (0.0 <= eps_tol) {
#line 1580
    if (! (eps_tol <= 1.0)) {
      {
#line 1581
      dy_glp_fault("luf_decomp: eps_tol = %g; invalid_parameter", eps_tol);
      }
    }
  } else {
    {
#line 1581
    dy_glp_fault("luf_decomp: eps_tol = %g; invalid_parameter", eps_tol);
    }
  }
#line 1582
  if (! (max_gro >= 1.0)) {
    {
#line 1583
    dy_glp_fault("luf_decomp: max_gro = %g; invalid parameter", max_gro);
    }
  }
#line 1585
  luf->valid = 0;
  more: 
#line 1587
  if (luf->new_sva > 0) {
    {
#line 1588
    dy_glp_ufree((void *)luf->sv_ndx);
#line 1589
    dy_glp_ufree((void *)luf->sv_val);
#line 1590
    luf->sv_size = luf->new_sva;
#line 1591
    tmp___1 = dy_glp_ucalloc(1 + luf->sv_size, (int )sizeof(int ));
#line 1591
    luf->sv_ndx = (int *)tmp___1;
#line 1592
    tmp___2 = dy_glp_ucalloc(1 + luf->sv_size, (int )sizeof(double ));
#line 1592
    luf->sv_val = (double *)tmp___2;
#line 1593
    luf->new_sva = 0;
    }
  }
  {
#line 1596
  tmp___3 = initialize(luf, info, col, wa);
  }
#line 1596
  if (tmp___3) {
#line 1598
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1599
    goto more;
  }
#line 1602
  k = 1;
  {
#line 1602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1602
    if (! (k <= n)) {
#line 1602
      goto while_break;
    }
    {
#line 1604
    tmp___4 = find_pivot(luf, wa, & p, & q);
    }
#line 1604
    if (tmp___4) {
#line 1607
      luf->rank = k - 1;
#line 1608
      ret = 1;
#line 1609
      goto done;
    }
#line 1614
    i = *(pp_col + p);
#line 1615
    j = *(qq_row + q);
#line 1616
    if (k <= i) {
#line 1616
      if (i <= n) {
#line 1616
        if (k <= j) {
#line 1616
          if (j <= n) {
#line 1616
            tmp___5 = 1;
          } else {
            {
#line 1616
            dy_glp_insist("k <= i && i <= n && k <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                          1616);
#line 1616
            tmp___5 = 1;
            }
          }
        } else {
          {
#line 1616
          dy_glp_insist("k <= i && i <= n && k <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                        1616);
#line 1616
          tmp___5 = 1;
          }
        }
      } else {
        {
#line 1616
        dy_glp_insist("k <= i && i <= n && k <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                      1616);
#line 1616
        tmp___5 = 1;
        }
      }
    } else {
      {
#line 1616
      dy_glp_insist("k <= i && i <= n && k <= j && j <= n", "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c",
                    1616);
#line 1616
      tmp___5 = 1;
      }
    }
    {
#line 1618
    t = *(pp_row + k);
#line 1619
    *(pp_row + i) = t;
#line 1619
    *(pp_col + t) = i;
#line 1620
    *(pp_row + k) = p;
#line 1620
    *(pp_col + p) = k;
#line 1622
    t = *(qq_col + k);
#line 1623
    *(qq_col + j) = t;
#line 1623
    *(qq_row + t) = j;
#line 1624
    *(qq_col + k) = q;
#line 1624
    *(qq_row + q) = k;
#line 1627
    tmp___6 = eliminate(luf, wa, p, q);
    }
#line 1627
    if (tmp___6) {
#line 1629
      luf->new_sva = luf->sv_size + luf->sv_size;
#line 1630
      goto more;
    }
#line 1633
    if (luf->big_v > max_gro * luf->max_a) {
#line 1636
      luf->rank = k - 1;
#line 1637
      ret = 2;
#line 1638
      goto done;
    }
#line 1602
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1646
  dy_glp_luf_defrag_sva(luf);
#line 1648
  tmp___7 = build_v_cols(luf);
  }
#line 1648
  if (tmp___7) {
#line 1650
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1651
    goto more;
  }
  {
#line 1654
  tmp___8 = build_f_rows(luf);
  }
#line 1654
  if (tmp___8) {
#line 1656
    luf->new_sva = luf->sv_size + luf->sv_size;
#line 1657
    goto more;
  }
#line 1660
  luf->valid = 1;
#line 1661
  luf->rank = n;
#line 1664
  t = 3 * (n + luf->nnz_v) + 2 * luf->nnz_f;
#line 1665
  if (luf->sv_size < t) {
#line 1666
    luf->new_sva = luf->sv_size;
    {
#line 1667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1667
      if (! (luf->new_sva < t)) {
#line 1667
        goto while_break___0;
      }
#line 1667
      luf->new_sva += luf->new_sva;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  done: 
#line 1670
  if ((unsigned long )_wa == (unsigned long )((void *)0)) {
    {
#line 1670
    dy_glp_luf_free_wa(wa);
    }
  }
#line 1672
  return (ret);
}
}
#line 1695 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_f_solve(LUF *luf , int tr , double *x ) 
{ 
  int n ;
  int *fr_ptr ;
  int *fr_len ;
  int *fc_ptr ;
  int *fc_len ;
  int *pp_row ;
  int *sv_ndx ;
  double *sv_val ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double xk ;

  {
#line 1696
  n = luf->n;
#line 1697
  fr_ptr = luf->fr_ptr;
#line 1698
  fr_len = luf->fr_len;
#line 1699
  fc_ptr = luf->fc_ptr;
#line 1700
  fc_len = luf->fc_len;
#line 1701
  pp_row = luf->pp_row;
#line 1702
  sv_ndx = luf->sv_ndx;
#line 1703
  sv_val = luf->sv_val;
#line 1706
  if (! luf->valid) {
    {
#line 1707
    dy_glp_fault("luf_f_solve: LU-factorization is not valid");
    }
  }
#line 1708
  if (! tr) {
#line 1710
    j = 1;
    {
#line 1710
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1710
      if (! (j <= n)) {
#line 1710
        goto while_break;
      }
#line 1711
      k = *(pp_row + j);
#line 1712
      xk = *(x + k);
#line 1713
      if (xk != 0.0) {
#line 1714
        beg = *(fc_ptr + k);
#line 1715
        end = (beg + *(fc_len + k)) - 1;
#line 1716
        ptr = beg;
        {
#line 1716
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1716
          if (! (ptr <= end)) {
#line 1716
            goto while_break___0;
          }
#line 1717
          *(x + *(sv_ndx + ptr)) -= *(sv_val + ptr) * xk;
#line 1716
          ptr ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1710
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1723
    i = n;
    {
#line 1723
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1723
      if (! (i >= 1)) {
#line 1723
        goto while_break___1;
      }
#line 1724
      k = *(pp_row + i);
#line 1725
      xk = *(x + k);
#line 1726
      if (xk != 0.0) {
#line 1727
        beg = *(fr_ptr + k);
#line 1728
        end = (beg + *(fr_len + k)) - 1;
#line 1729
        ptr = beg;
        {
#line 1729
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1729
          if (! (ptr <= end)) {
#line 1729
            goto while_break___2;
          }
#line 1730
          *(x + *(sv_ndx + ptr)) -= *(sv_val + ptr) * xk;
#line 1729
          ptr ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1723
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1734
  return;
}
}
#line 1757 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_v_solve(LUF *luf , int tr , double *x ) 
{ 
  int n ;
  int *vr_ptr ;
  int *vr_len ;
  double *vr_piv ;
  int *vc_ptr ;
  int *vc_len ;
  int *pp_row ;
  int *qq_col ;
  int *sv_ndx ;
  double *sv_val ;
  double *b ;
  int i ;
  int j ;
  int k ;
  int beg ;
  int end ;
  int ptr ;
  double temp ;

  {
#line 1758
  n = luf->n;
#line 1759
  vr_ptr = luf->vr_ptr;
#line 1760
  vr_len = luf->vr_len;
#line 1761
  vr_piv = luf->vr_piv;
#line 1762
  vc_ptr = luf->vc_ptr;
#line 1763
  vc_len = luf->vc_len;
#line 1764
  pp_row = luf->pp_row;
#line 1765
  qq_col = luf->qq_col;
#line 1766
  sv_ndx = luf->sv_ndx;
#line 1767
  sv_val = luf->sv_val;
#line 1768
  b = luf->work;
#line 1771
  if (! luf->valid) {
    {
#line 1772
    dy_glp_fault("luf_v_solve: LU-factorization is not valid");
    }
  }
#line 1773
  k = 1;
  {
#line 1773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1773
    if (! (k <= n)) {
#line 1773
      goto while_break;
    }
#line 1773
    *(b + k) = *(x + k);
#line 1773
    *(x + k) = 0.0;
#line 1773
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1774
  if (! tr) {
#line 1776
    k = n;
    {
#line 1776
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1776
      if (! (k >= 1)) {
#line 1776
        goto while_break___0;
      }
#line 1777
      i = *(pp_row + k);
#line 1777
      j = *(qq_col + k);
#line 1778
      temp = *(b + i);
#line 1779
      if (temp != 0.0) {
#line 1780
        temp /= *(vr_piv + i);
#line 1780
        *(x + j) = temp;
#line 1781
        beg = *(vc_ptr + j);
#line 1782
        end = (beg + *(vc_len + j)) - 1;
#line 1783
        ptr = beg;
        {
#line 1783
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1783
          if (! (ptr <= end)) {
#line 1783
            goto while_break___1;
          }
#line 1784
          *(b + *(sv_ndx + ptr)) -= *(sv_val + ptr) * temp;
#line 1783
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1776
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1790
    k = 1;
    {
#line 1790
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1790
      if (! (k <= n)) {
#line 1790
        goto while_break___2;
      }
#line 1791
      i = *(pp_row + k);
#line 1791
      j = *(qq_col + k);
#line 1792
      temp = *(b + j);
#line 1793
      if (temp != 0.0) {
#line 1794
        temp /= *(vr_piv + i);
#line 1794
        *(x + i) = temp;
#line 1795
        beg = *(vr_ptr + i);
#line 1796
        end = (beg + *(vr_len + i)) - 1;
#line 1797
        ptr = beg;
        {
#line 1797
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1797
          if (! (ptr <= end)) {
#line 1797
            goto while_break___3;
          }
#line 1798
          *(b + *(sv_ndx + ptr)) -= *(sv_val + ptr) * temp;
#line 1797
          ptr ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 1790
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1802
  return;
}
}
#line 1825 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_solve(LUF *luf , int tr , double *x ) 
{ 


  {
#line 1826
  if (! luf->valid) {
    {
#line 1827
    dy_glp_fault("luf_solve: LU-factorization is not valid");
    }
  }
#line 1828
  if (! tr) {
    {
#line 1830
    dy_glp_luf_f_solve(luf, 0, x);
#line 1831
    dy_glp_luf_v_solve(luf, 0, x);
    }
  } else {
    {
#line 1835
    dy_glp_luf_v_solve(luf, 1, x);
#line 1836
    dy_glp_luf_f_solve(luf, 1, x);
    }
  }
#line 1838
  return;
}
}
#line 1855 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glpluf.c"
void dy_glp_luf_delete(LUF *luf ) 
{ 


  {
  {
#line 1856
  dy_glp_ufree((void *)luf->fr_ptr);
#line 1857
  dy_glp_ufree((void *)luf->fr_len);
#line 1858
  dy_glp_ufree((void *)luf->fc_ptr);
#line 1859
  dy_glp_ufree((void *)luf->fc_len);
#line 1860
  dy_glp_ufree((void *)luf->vr_ptr);
#line 1861
  dy_glp_ufree((void *)luf->vr_len);
#line 1862
  dy_glp_ufree((void *)luf->vr_cap);
#line 1863
  dy_glp_ufree((void *)luf->vr_piv);
#line 1864
  dy_glp_ufree((void *)luf->vc_ptr);
#line 1865
  dy_glp_ufree((void *)luf->vc_len);
#line 1866
  dy_glp_ufree((void *)luf->vc_cap);
#line 1867
  dy_glp_ufree((void *)luf->pp_row);
#line 1868
  dy_glp_ufree((void *)luf->pp_col);
#line 1869
  dy_glp_ufree((void *)luf->qq_row);
#line 1870
  dy_glp_ufree((void *)luf->qq_col);
#line 1871
  dy_glp_ufree((void *)luf->sv_ndx);
#line 1872
  dy_glp_ufree((void *)luf->sv_val);
#line 1873
  dy_glp_ufree((void *)luf->sv_prev);
#line 1874
  dy_glp_ufree((void *)luf->sv_next);
#line 1875
  dy_glp_ufree((void *)luf->flag);
#line 1876
  dy_glp_ufree((void *)luf->work);
#line 1877
  dy_glp_ufree((void *)luf);
  }
#line 1878
  return;
}
}
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 250 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
double exvec_2norm(double *vec , int len ) ;
#line 550 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
double consys_infnormcol(consys_struct *consys , int colndx ) ;
#line 111 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static int near_perp_far(void const   *elem1 , void const   *elem2 ) 
{ 
  angle_struct const   *c1 ;
  angle_struct const   *c2 ;

  {
#line 114
  c1 = (angle_struct const   *)elem1;
#line 115
  c2 = (angle_struct const   *)elem2;
#line 117
  if (c1->angle > c2->angle) {
#line 118
    return (-1);
  } else
#line 120
  if (c1->angle < c2->angle) {
#line 121
    return (1);
  } else {
#line 123
    return (0);
  }
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool cold_sortcons(consys_struct *orig_sys , int **p_eqs , ineq_struct **p_ineqs ,
                          int **p_noload ) 
{ 
  int i ;
  int ndx ;
  int m ;
  int n ;
  int eqcnt ;
  int ineqcnt ;
  int noloadcnt ;
  int nearcnt ;
  int perpcnt ;
  int farcnt ;
  double cnorm ;
  double ainorm ;
  double aidotc ;
  double pi180 ;
  double anglei ;
  double *c ;
  int *eqs ;
  int *noload ;
  ineq_struct *ineqs ;
  angle_struct *angles ;
  contyp_enum *ctyp ;
  double *rhs ;
  double *rhslow ;
  bool retval ;
  bool need_angles ;
  pkvec_struct *ai ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char const   *tmp___12 ;

  {
#line 174
  rtnnme = "cold_sortcons";
#line 199
  if ((unsigned long )*p_eqs == (unsigned long )((void *)0)) {
    {
#line 200
    tmp = malloc((unsigned long )(orig_sys->concnt + 1) * sizeof(int ));
#line 200
    eqs = (int *)tmp;
    }
  } else {
#line 202
    eqs = *p_eqs;
  }
#line 203
  if ((unsigned long )*p_ineqs == (unsigned long )((void *)0)) {
    {
#line 204
    tmp___0 = calloc((size_t )1, sizeof(ineq_struct ));
#line 204
    ineqs = (ineq_struct *)tmp___0;
#line 205
    tmp___1 = malloc((unsigned long )orig_sys->concnt * sizeof(angle_struct ));
#line 205
    ineqs->angles = (angle_struct *)tmp___1;
    }
  } else {
#line 208
    ineqs = *p_ineqs;
  }
#line 209
  if ((unsigned long )*p_noload == (unsigned long )((void *)0)) {
    {
#line 210
    tmp___2 = malloc((unsigned long )(orig_sys->concnt + 1) * sizeof(int ));
#line 210
    noload = (int *)tmp___2;
    }
  } else {
#line 212
    noload = *p_noload;
  }
  {
#line 218
  angles = ineqs->angles;
#line 220
  m = orig_sys->concnt;
#line 221
  n = orig_sys->varcnt;
#line 222
  retval = (bool )1;
#line 228
  ai = pkvec_new(0);
#line 229
  eqcnt = 0;
#line 230
  ineqcnt = 0;
#line 231
  noloadcnt = 0;
#line 232
  ctyp = orig_sys->ctyp;
#line 233
  rhs = orig_sys->rhs;
#line 234
  rhslow = orig_sys->rhslow;
#line 236
  i = 1;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i <= m)) {
#line 236
      goto while_break;
    }
#line 237
    if ((unsigned int )*(ctyp + i) == 1U) {
#line 238
      (dy_lp->sys.cons.unloadable) ++;
#line 239
      (dy_lp->sys.cons.loadable) --;
#line 240
      noloadcnt ++;
#line 240
      *(noload + noloadcnt) = i;
#line 242
      if (dy_opts->print.setup >= 4) {
        {
#line 243
        tmp___3 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 243
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tskipping nonbinding constraint %s (%d).",
                    tmp___3, i);
        }
      }
#line 247
      goto __Cont;
    }
#line 248
    if ((unsigned int )*(ctyp + i) == 5U) {
#line 249
      if (*(rhs + i) < *(rhslow + i)) {
#line 252
        if (dy_opts->print.setup >= 1) {
          {
#line 253
          tmp___4 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 253
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  Prima facie infeasibility for %s (%d),",
                      tmp___4, i);
#line 256
          dyio_outfmt(dy_logchn, dy_gtxecho, " rhslow = %g > rhs = %g.", *(rhslow + i),
                      *(rhs + i));
          }
        }
#line 259
        dy_lp->lpret = (lpret_enum )4;
      }
    }
    {
#line 260
    tmp___6 = consys_getrow_pk(orig_sys, i, & ai);
    }
#line 260
    if ((int )tmp___6 == 0) {
      {
#line 261
      tmp___5 = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 261
      errmsg(122, rtnnme, orig_sys->nme, "row", tmp___5, i);
#line 263
      retval = (bool )0;
      }
#line 264
      goto while_break;
    }
#line 265
    if (ai->cnt == 0) {
#line 266
      (dy_lp->sys.cons.unloadable) ++;
#line 267
      (dy_lp->sys.cons.loadable) --;
#line 268
      noloadcnt ++;
#line 268
      *(noload + noloadcnt) = i;
#line 270
      if (dy_opts->print.setup >= 4) {
        {
#line 271
        tmp___7 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 271
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tskipping empty constraint %s (%d).",
                    tmp___7, i);
        }
      }
    } else
#line 277
    if ((unsigned int )*(ctyp + i) == 3U) {
#line 278
      eqcnt ++;
#line 278
      *(eqs + eqcnt) = i;
    } else {
#line 280
      tmp___8 = ineqcnt;
#line 280
      ineqcnt ++;
#line 280
      (angles + tmp___8)->ndx = i;
    }
    __Cont: /* CIL Label */ 
#line 236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if ((unsigned long )ai != (unsigned long )((void *)0)) {
    {
#line 282
    pkvec_free(ai);
    }
  }
#line 283
  *(eqs + 0) = eqcnt;
#line 284
  ineqs->cnt = ineqcnt;
#line 285
  *(noload + 0) = noloadcnt;
#line 288
  if (dy_opts->print.setup >= 2) {
    {
#line 289
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    found %d equalities, %d inequalities",
                eqcnt, ineqcnt);
    }
#line 292
    if (noloadcnt != 0) {
      {
#line 293
      dyio_outfmt(dy_logchn, dy_gtxecho, ", discarded %d empty/nonbinding rows", noloadcnt);
      }
    }
    {
#line 295
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
    }
  }
#line 303
  if ((int )retval == 0) {
#line 304
    if ((unsigned long )*p_eqs == (unsigned long )((void *)0)) {
#line 304
      if ((unsigned long )eqs != (unsigned long )((void *)0)) {
        {
#line 304
        free((void *)eqs);
        }
      }
    }
#line 305
    if ((unsigned long )*p_ineqs == (unsigned long )((void *)0)) {
#line 305
      if ((unsigned long )ineqs != (unsigned long )((void *)0)) {
#line 306
        if ((unsigned long )ineqs->angles != (unsigned long )((void *)0)) {
          {
#line 306
          free((void *)angles);
          }
        }
        {
#line 307
        free((void *)ineqs);
        }
      }
    }
#line 308
    if ((unsigned long )*p_noload == (unsigned long )((void *)0)) {
#line 308
      if ((unsigned long )noload != (unsigned long )((void *)0)) {
        {
#line 308
        free((void *)noload);
        }
      }
    }
#line 309
    return ((bool )0);
  }
#line 314
  need_angles = (bool )1;
#line 315
  if ((int )dy_opts->fullsys == 1) {
#line 315
    need_angles = (bool )0;
  }
#line 320
  if (dy_opts->print.setup >= 2) {
#line 320
    need_angles = (bool )1;
  }
#line 327
  if ((int )need_angles == 1) {
    {
#line 328
    c = orig_sys->obj;
#line 329
    nearcnt = 0;
#line 330
    perpcnt = 0;
#line 331
    farcnt = 0;
#line 332
    cnorm = exvec_2norm(c, n);
#line 333
    tmp___9 = acos(- 1.0);
#line 333
    pi180 = (double )180 / tmp___9;
    }
#line 335
    if (dy_opts->print.setup >= 4) {
      {
#line 336
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t||c|| = %.4f", cnorm);
#line 337
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tConstraint\t\t||a||\t(c/||c||).(a/||a||)\tangle");
      }
    }
#line 341
    ndx = 0;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (ndx < ineqcnt)) {
#line 341
        goto while_break___0;
      }
      {
#line 342
      i = (angles + ndx)->ndx;
#line 343
      aidotc = consys_dotrow(orig_sys, i, c);
#line 344
      tmp___11 = fabs(aidotc - (double )0);
      }
#line 344
      if (tmp___11 <= dy_tols->zero) {
        {
#line 347
        ainorm = consys_2normrow(orig_sys, i);
#line 349
        anglei = (double )90;
        }
      } else {
        {
#line 351
        ainorm = consys_2normrow(orig_sys, i);
#line 352
        tmp___10 = acos(aidotc / (ainorm * cnorm));
#line 352
        anglei = pi180 * tmp___10;
        }
      }
#line 353
      (angles + ndx)->angle = anglei;
#line 354
      if (anglei > (double )90) {
#line 355
        nearcnt ++;
      } else
#line 357
      if (anglei < (double )90) {
#line 358
        farcnt ++;
      } else {
#line 360
        perpcnt ++;
      }
#line 362
      if (dy_opts->print.setup >= 4) {
        {
#line 363
        tmp___12 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 363
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-10s (%3d) %12.4f %18.10f%15.6f",
                    tmp___12, i, ainorm, aidotc / (ainorm * cnorm), anglei);
        }
      }
#line 341
      ndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 370
    if (dy_opts->print.setup >= 2) {
      {
#line 371
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    inequality partition %d near, %d perp, %d far.",
                  nearcnt, perpcnt, farcnt);
      }
    }
    {
#line 375
    ineqs->perp = nearcnt;
#line 376
    ineqs->far = nearcnt + perpcnt;
#line 377
    qsort((void *)(angles + 0), (size_t )ineqcnt, sizeof(angle_struct ), & near_perp_far);
    }
  }
#line 410
  if ((unsigned long )*p_eqs == (unsigned long )((void *)0)) {
#line 410
    *p_eqs = eqs;
  }
#line 411
  if ((unsigned long )*p_ineqs == (unsigned long )((void *)0)) {
#line 411
    *p_ineqs = ineqs;
  }
#line 412
  if ((unsigned long )*p_noload == (unsigned long )((void *)0)) {
#line 412
    *p_noload = noload;
  }
#line 414
  return ((bool )1);
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool cold_createdysys(consys_struct *orig_sys , int eqcnt , int ineqcnt ) 
{ 
  int m_sze ;
  int n_sze ;
  char nmebuf[50] ;
  flags parts ;
  flags opts ;
  char const   *rtnnme ;
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
  {
#line 460
  parts = ((((((1U << 3) | (1U << 4)) | (1U << 5)) | (1U << 6)) | (1U << 9)) | (1U << 10)) | (1U << 11);
#line 460
  opts = 1U | (1U << 2);
#line 464
  rtnnme = "cold_createdysys";
#line 470
  dyio_outfxd(nmebuf, - ((int )(sizeof(nmebuf) - 1UL)), (char )'l', "%s[actv]", orig_sys->nme);
  }
#line 472
  if ((int )dy_opts->fullsys == 1) {
#line 473
    m_sze = orig_sys->concnt;
#line 474
    n_sze = orig_sys->archvcnt + m_sze;
  } else {
#line 476
    m_sze = (int )((float )eqcnt + (float )orig_sys->concnt * dy_opts->active.cons);
#line 477
    n_sze = (int )((float )orig_sys->archvcnt * dy_opts->active.vars + (float )m_sze);
  }
#line 479
  if (dy_opts->print.setup >= 1) {
    {
#line 480
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    creating constraint system %s (%d x %d)",
                nmebuf, m_sze, n_sze);
    }
  }
  {
#line 484
  dy_sys = consys_create((char const   *)(nmebuf), parts, opts, m_sze, n_sze, dy_tols->inf);
  }
#line 485
  if ((unsigned long )dy_sys == (unsigned long )((void *)0)) {
    {
#line 486
    errmsg(152, rtnnme, nmebuf);
    }
#line 487
    return ((bool )0);
  }
  {
#line 497
  dy_actvars = (int *)((void *)0);
#line 498
  tmp = consys_attach(dy_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_actvars));
  }
#line 498
  if ((int )tmp == 0) {
    {
#line 500
    errmsg(100, rtnnme, dy_sys->nme, "active -> original variable map");
    }
#line 501
    return ((bool )0);
  }
  {
#line 502
  dy_actcons = (int *)((void *)0);
#line 503
  tmp___0 = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_actcons));
  }
#line 503
  if ((int )tmp___0 == 0) {
    {
#line 505
    errmsg(100, rtnnme, dy_sys->nme, "active -> original constraint map");
    }
#line 506
    return ((bool )0);
  }
  {
#line 507
  dy_origvars = (int *)((void *)0);
#line 508
  tmp___1 = consys_attach(orig_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_origvars));
  }
#line 508
  if ((int )tmp___1 == 0) {
    {
#line 510
    errmsg(100, rtnnme, orig_sys->nme, "original -> active variable map");
    }
#line 511
    return ((bool )0);
  }
  {
#line 512
  dy_origcons = (int *)((void *)0);
#line 513
  tmp___2 = consys_attach(orig_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_origcons));
  }
#line 513
  if ((int )tmp___2 == 0) {
    {
#line 515
    errmsg(100, rtnnme, orig_sys->nme, "original -> active constraint map");
    }
#line 516
    return ((bool )0);
  }
#line 518
  return ((bool )1);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool cold_scanvars(consys_struct *orig_sys ) 
{ 
  int j ;
  int flippable ;
  flags statj ;
  double *vlb ;
  double *vub ;
  double *obj ;
  double lj ;
  double uj ;
  double cj ;
  bool retval ;
  pkvec_struct *aj ;
  char *rtnnme ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 571
  rtnnme = (char *)"cold_scanvars";
#line 573
  retval = (bool )1;
#line 577
  vlb = orig_sys->vlb;
#line 578
  vub = orig_sys->vub;
#line 579
  obj = orig_sys->obj;
#line 580
  flippable = 0;
#line 582
  aj = pkvec_new(0);
#line 584
  j = 1;
  }
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (! (j <= orig_sys->varcnt)) {
#line 584
      goto while_break;
    }
#line 585
    lj = *(vlb + j);
#line 586
    uj = *(vub + j);
#line 587
    cj = *(obj + j);
#line 595
    if (lj > - dy_tols->inf) {
#line 595
      if (uj < dy_tols->inf) {
        {
#line 596
        tmp___4 = fabs(uj);
        }
#line 596
        if (tmp___4 < dy_tols->inf) {
          {
#line 596
          tmp___5 = fabs(lj - uj);
#line 596
          tmp___6 = fabs(uj);
          }
#line 596
          if (tmp___5 < dy_tols->pfeas * (1.0 + tmp___6)) {
#line 596
            if (lj != uj) {
#line 597
              if (cj < (double )0) {
#line 598
                statj = (unsigned int )(1 << 6) | (1U << (sizeof(flags ) * 8UL - 4UL));
              } else {
#line 600
                statj = (unsigned int )(1 << 7) | (1U << (sizeof(flags ) * 8UL - 4UL));
              }
#line 602
              if (dy_opts->print.setup >= 3) {
                {
#line 603
                tmp = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)0);
#line 603
                dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tDirty fixed variable %s (%d)",
                            tmp, j);
#line 605
                tmp___0 = dy_prtvstat(statj);
#line 605
                dyio_outfmt(dy_logchn, dy_gtxecho, " assigned status %s.", tmp___0);
#line 607
                dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  original lb = %g, ub = %g, diff = %g, tol = %g",
                            lj, uj, uj - lj, dy_tols->pfeas);
                }
              }
            } else {
#line 596
              goto _L___0;
            }
          } else {
#line 596
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 613
        if (uj < lj) {
#line 614
          dy_lp->lpret = (lpret_enum )4;
#line 616
          if (dy_opts->print.setup >= 1) {
            {
#line 617
            tmp___1 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)0);
#line 617
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tPrima facie infeasibility for %s (%d), lb = %g > ub = %g.",
                        tmp___1, j, lj, uj);
            }
          }
#line 621
          statj = (unsigned int )(1 << 7) | (1U << (sizeof(flags ) * 8UL - 4UL));
        } else
#line 623
        if (lj == uj) {
#line 624
          statj = (unsigned int )(1 << 5) | (1U << (sizeof(flags ) * 8UL - 4UL));
#line 626
          if (dy_opts->print.setup >= 3) {
            {
#line 627
            tmp___2 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)0);
#line 627
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tFixed variable %s (%d) = %g",
                        tmp___2, j, lj);
#line 629
            tmp___3 = dy_prtvstat(statj);
#line 629
            dyio_outfmt(dy_logchn, dy_gtxecho, " assigned status %s.", tmp___3);
            }
          }
        } else {
#line 634
          flippable ++;
#line 635
          if (cj < (double )0) {
#line 636
            statj = (flags )(1 << 6);
          } else {
#line 638
            statj = (flags )(1 << 7);
          }
        }
      } else {
#line 595
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 644
    if (lj > - dy_tols->inf) {
#line 645
      statj = (flags )(1 << 7);
    } else
#line 647
    if (uj < dy_tols->inf) {
#line 648
      statj = (flags )(1 << 6);
    } else {
#line 650
      statj = (flags )(1 << 8);
    }
    {
#line 662
    tmp___8 = consys_getcol_pk(orig_sys, j, & aj);
    }
#line 662
    if ((int )tmp___8 == 0) {
      {
#line 663
      tmp___7 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 663
      errmsg(122, rtnnme, dy_sys->nme, "column", tmp___7, j);
#line 665
      retval = (bool )0;
      }
#line 666
      goto while_break;
    }
#line 667
    if (aj->cnt == 0) {
#line 668
      if (cj > (double )0) {
#line 668
        if (lj <= - dy_tols->inf) {
#line 668
          goto _L___2;
        } else {
#line 668
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 668
      if (cj < (double )0) {
#line 668
        if (uj >= dy_tols->inf) {
          _L___2: /* CIL Label */ 
#line 669
          dy_lp->lpret = (lpret_enum )2;
#line 670
          dy_lp->z = (double )(- j);
#line 672
          if (dy_opts->print.setup >= 1) {
            {
#line 673
            tmp___9 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)0);
#line 673
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tPrima facie unboundedness for %s (%d), ",
                        tmp___9, j);
#line 676
            dyio_outfmt(dy_logchn, dy_gtxecho, "c = %g, lb = %g, ub = %g.", cj, lj,
                        uj);
            }
          }
        } else {
#line 668
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 681
        statj |= 1U << (sizeof(flags ) * 8UL - 4UL);
#line 683
        if (dy_opts->print.setup >= 3) {
          {
#line 684
          tmp___10 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)0);
#line 684
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tEmpty column for variable %s (%d),",
                      tmp___10, j, lj);
#line 687
          tmp___11 = dy_prtvstat(statj);
#line 687
          dyio_outfmt(dy_logchn, dy_gtxecho, " assigned status %s,", tmp___11);
#line 689
          dyio_outfmt(dy_logchn, dy_gtxecho, " c = %g, lb = %g, ub = %g.", cj, lj,
                      uj);
          }
        }
      }
    }
#line 694
    *(dy_origvars + j) = - ((int )statj);
#line 695
    if (statj & (1U << (sizeof(flags ) * 8UL - 4UL))) {
#line 695
      tmp___12 = 1;
    } else {
#line 695
      tmp___12 = 0;
    }
#line 695
    if (tmp___12 == 1) {
#line 696
      (dy_lp->sys.vars.unloadable) ++;
#line 697
      (dy_lp->sys.vars.loadable) --;
    }
#line 584
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  if ((unsigned long )aj != (unsigned long )((void *)0)) {
    {
#line 700
    pkvec_free(aj);
    }
  }
#line 710
  uj = (double )flippable / (double )orig_sys->varcnt;
#line 711
  if (uj < .25) {
#line 711
    if ((int )dy_opts->dpsel.flex == 1) {
#line 712
      dy_opts->dpsel.flex = (bool )0;
#line 713
      dy_opts->dpsel.strat = 0;
#line 715
      if (dy_opts->print.setup >= 2) {
        {
#line 716
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %d (%.1f%%) flippable variables; disabling dual multipivot.",
                    flippable, uj * (double )100);
        }
      } else
#line 715
      if (dy_opts->print.dual >= 2) {
        {
#line 716
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %d (%.1f%%) flippable variables; disabling dual multipivot.",
                    flippable, uj * (double )100);
        }
      }
    }
  }
#line 727
  return (retval);
}
}
#line 733 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool cold_loadfull(consys_struct *orig_sys , int *eqs , ineq_struct *ineqs ) 
{ 
  int i ;
  int ndx ;
  int eqcnt ;
  int ineqcnt ;
  bool retval ;
  angle_struct *angles ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;

  {
#line 755
  rtnnme = "cold_loadfull";
#line 757
  eqcnt = *(eqs + 0);
#line 758
  ineqcnt = ineqs->cnt;
#line 759
  retval = (bool )1;
#line 763
  if (eqcnt > 0) {
#line 764
    ndx = 1;
    {
#line 764
    while (1) {
      while_continue: /* CIL Label */ ;
#line 764
      if (! (ndx <= eqcnt)) {
#line 764
        goto while_break;
      }
#line 765
      i = *(eqs + ndx);
#line 767
      if (dy_opts->print.setup >= 3) {
        {
#line 768
        tmp = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 768
        tmp___0 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 768
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) ...", tmp___0,
                    tmp, i);
        }
      }
      {
#line 775
      tmp___3 = dy_loadcon(orig_sys, i, (bool )1, (int *)((void *)0));
      }
#line 775
      if ((int )tmp___3 == 0) {
        {
#line 776
        tmp___1 = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 776
        tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 776
        errmsg(430, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters, "activate", "constraint",
               tmp___1, i);
#line 780
        retval = (bool )0;
        }
#line 781
        goto while_break;
      }
#line 764
      ndx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 783
    if (dy_opts->print.setup >= 2) {
      {
#line 784
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    transferred %d equalities ...", eqcnt);
      }
    }
#line 787
    if ((int )retval == 0) {
#line 788
      return ((bool )0);
    }
  }
#line 792
  if (ineqcnt > 0) {
#line 793
    angles = ineqs->angles;
#line 794
    ndx = 0;
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (! (ndx < ineqcnt)) {
#line 794
        goto while_break___0;
      }
#line 795
      i = (angles + ndx)->ndx;
#line 797
      if (dy_opts->print.setup >= 3) {
        {
#line 798
        tmp___4 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 798
        tmp___5 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 798
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) ...", tmp___5,
                    tmp___4, i);
        }
      }
      {
#line 805
      tmp___8 = dy_loadcon(orig_sys, i, (bool )1, (int *)((void *)0));
      }
#line 805
      if ((int )tmp___8 == 0) {
        {
#line 806
        tmp___6 = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 806
        tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 806
        errmsg(430, rtnnme, dy_sys->nme, tmp___7, dy_lp->tot.iters, "activate", "constraint",
               tmp___6, i);
#line 810
        retval = (bool )0;
        }
#line 811
        goto while_break___0;
      }
#line 794
      ndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 813
    if (dy_opts->print.setup >= 2) {
      {
#line 814
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    transferred %d inequalities ...",
                  ineqcnt);
      }
    }
  }
#line 819
  return (retval);
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool cold_loadpartial(consys_struct *orig_sys , int *eqs , ineq_struct *ineqs ) 
{ 
  int i ;
  int ndx ;
  int eqcnt ;
  int ineqcnt ;
  int ineq_actvcnt ;
  bool retval ;
  angle_struct *angles ;
  int intcnt ;
  int intndx ;
  double albs[2] ;
  double aubs[2] ;
  double alb ;
  double aub ;
  double dblndx ;
  double incr ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;

  {
#line 849
  rtnnme = "cold_loadpartial";
#line 851
  eqcnt = *(eqs + 0);
#line 852
  ineqcnt = ineqs->cnt;
#line 853
  retval = (bool )1;
#line 857
  if (eqcnt > 0) {
#line 858
    ndx = 1;
    {
#line 858
    while (1) {
      while_continue: /* CIL Label */ ;
#line 858
      if (! (ndx <= eqcnt)) {
#line 858
        goto while_break;
      }
#line 859
      i = *(eqs + ndx);
#line 861
      if (dy_opts->print.setup >= 3) {
        {
#line 862
        tmp = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 862
        tmp___0 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 862
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) ...", tmp___0,
                    tmp, i);
        }
      }
      {
#line 869
      tmp___3 = dy_loadcon(orig_sys, i, (bool )1, (int *)((void *)0));
      }
#line 869
      if ((int )tmp___3 == 0) {
        {
#line 870
        tmp___1 = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 870
        tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 870
        errmsg(430, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters, "activate", "constraint",
               tmp___1, i);
#line 874
        retval = (bool )0;
        }
#line 875
        goto while_break;
      }
#line 858
      ndx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 877
    if (dy_opts->print.setup >= 2) {
      {
#line 878
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    transferred %d equalities ...", eqcnt);
      }
    }
#line 881
    if ((int )retval == 0) {
#line 882
      return ((bool )0);
    }
  }
#line 886
  if (ineqcnt == 0) {
#line 886
    return ((bool )1);
  }
#line 895
  if (dy_opts->print.setup >= 2) {
#line 896
    if ((int )dy_opts->initcons.i1lopen == 1) {
#line 896
      tmp___4 = ')';
    } else {
#line 896
      tmp___4 = ']';
    }
#line 896
    if ((int )dy_opts->initcons.i1uopen == 1) {
#line 896
      tmp___5 = '(';
    } else {
#line 896
      tmp___5 = '[';
    }
    {
#line 896
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    inequalities: sampling %.2f, %c %.4f %.4f %c",
                dy_opts->initcons.frac, tmp___5, dy_opts->initcons.i1u, dy_opts->initcons.i1l,
                tmp___4);
    }
#line 902
    if ((int )dy_opts->initcons.i2valid == 1) {
#line 903
      if ((int )dy_opts->initcons.i2lopen == 1) {
#line 903
        tmp___6 = ')';
      } else {
#line 903
        tmp___6 = ']';
      }
#line 903
      if ((int )dy_opts->initcons.i2uopen == 1) {
#line 903
        tmp___7 = '(';
      } else {
#line 903
        tmp___7 = '[';
      }
      {
#line 903
      dyio_outfmt(dy_logchn, dy_gtxecho, ", %c %.4f %.4f %c", tmp___7, dy_opts->initcons.i2u,
                  dy_opts->initcons.i2l, tmp___6);
      }
    }
  }
#line 908
  incr = (double )1 / dy_opts->initcons.frac;
#line 909
  if ((int )dy_opts->initcons.i1lopen == 1) {
#line 910
    albs[0] = dy_opts->initcons.i1l + dy_tols->zero;
  } else {
#line 912
    albs[0] = dy_opts->initcons.i1l - dy_tols->zero;
  }
#line 913
  if ((int )dy_opts->initcons.i1uopen == 1) {
#line 914
    aubs[0] = dy_opts->initcons.i1u - dy_tols->zero;
  } else {
#line 916
    aubs[0] = dy_opts->initcons.i1u + dy_tols->zero;
  }
#line 917
  if ((int )dy_opts->initcons.i2valid == 1) {
#line 918
    if ((int )dy_opts->initcons.i2lopen == 1) {
#line 919
      albs[1] = dy_opts->initcons.i2l + dy_tols->zero;
    } else {
#line 921
      albs[1] = dy_opts->initcons.i2l - dy_tols->zero;
    }
#line 922
    if ((int )dy_opts->initcons.i2uopen == 1) {
#line 923
      aubs[1] = dy_opts->initcons.i2u - dy_tols->zero;
    } else {
#line 925
      aubs[1] = dy_opts->initcons.i2u + dy_tols->zero;
    }
#line 926
    intcnt = 2;
  } else {
#line 928
    intcnt = 1;
  }
#line 929
  angles = ineqs->angles;
#line 930
  ineq_actvcnt = 0;
#line 934
  ndx = 0;
#line 935
  intndx = 0;
  {
#line 935
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 935
    if (! (intndx < intcnt)) {
#line 935
      goto while_break___0;
    }
#line 936
    alb = albs[intndx];
#line 937
    aub = aubs[intndx];
    {
#line 946
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 946
      if (ndx < ineqcnt) {
#line 946
        if (! ((angles + ndx)->angle > aub)) {
#line 946
          goto while_break___1;
        }
      } else {
#line 946
        goto while_break___1;
      }
#line 946
      ndx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 947
    dblndx = (double )ndx;
    {
#line 952
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 952
      if (ndx < ineqcnt) {
#line 952
        if (! ((angles + ndx)->angle > alb)) {
#line 952
          goto while_break___2;
        }
      } else {
#line 952
        goto while_break___2;
      }
#line 953
      i = (angles + ndx)->ndx;
#line 955
      if (dy_opts->print.setup >= 3) {
        {
#line 956
        tmp___8 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 956
        tmp___9 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 956
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    activating %s %s (%d) %g off 90 ...",
                    tmp___9, tmp___8, i, (angles + ndx)->angle - (double )90);
        }
      }
      {
#line 965
      tmp___12 = dy_loadcon(orig_sys, i, (bool )1, (int *)((void *)0));
      }
#line 965
      if ((int )tmp___12 == 0) {
        {
#line 966
        tmp___10 = consys_nme(orig_sys, (char )'c', i, (bool )1, (char *)((void *)0));
#line 966
        tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 966
        errmsg(430, rtnnme, dy_sys->nme, tmp___11, dy_lp->tot.iters, "activate", "constraint",
               tmp___10, i);
#line 970
        retval = (bool )0;
        }
#line 971
        goto while_break___2;
      }
#line 972
      ineq_actvcnt ++;
#line 973
      dblndx += incr;
#line 974
      ndx = (int )dblndx;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 935
    intndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 979
  if (dy_opts->print.setup >= 2) {
    {
#line 980
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    transferred %d inequalities ...", ineq_actvcnt);
    }
  }
#line 984
  return (retval);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
dyret_enum dy_coldstart(consys_struct *orig_sys ) 
{ 
  int i ;
  int j ;
  int ndx ;
  int n ;
  int eqcnt ;
  int ineqcnt ;
  int noloadcnt ;
  double *vlb ;
  double *vub ;
  double *obj ;
  double vlbj ;
  double vubj ;
  double objj ;
  flags statj ;
  int *eqs ;
  int *noload ;
  ineq_struct *ineqs ;
  int nbfxcnt ;
  bool retval ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 1009
  nbfxcnt = 0;
#line 1014
  rtnnme = "dy_coldstart";
#line 1019
  dy_lp->sys.forcedfull = (bool )0;
#line 1020
  dy_lp->sys.vars.loadable = orig_sys->varcnt;
#line 1021
  dy_lp->sys.vars.unloadable = 0;
#line 1022
  dy_lp->sys.cons.loadable = orig_sys->concnt;
#line 1023
  dy_lp->sys.cons.unloadable = 0;
#line 1029
  eqs = (int *)((void *)0);
#line 1030
  ineqs = (ineq_struct *)((void *)0);
#line 1031
  noload = (int *)((void *)0);
#line 1032
  retval = cold_sortcons(orig_sys, & eqs, & ineqs, & noload);
  }
#line 1033
  if ((int )retval == 0) {
    {
#line 1034
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1034
    errmsg(312, rtnnme, orig_sys->nme, tmp, dy_lp->tot.iters);
    }
#line 1036
    if ((unsigned long )eqs != (unsigned long )((void *)0)) {
      {
#line 1036
      free((void *)eqs);
      }
    }
#line 1037
    if ((unsigned long )ineqs != (unsigned long )((void *)0)) {
#line 1038
      if ((unsigned long )ineqs->angles != (unsigned long )((void *)0)) {
        {
#line 1038
        free((void *)ineqs->angles);
        }
      }
      {
#line 1039
      free((void *)ineqs);
      }
    }
#line 1040
    if ((unsigned long )noload != (unsigned long )((void *)0)) {
      {
#line 1040
      free((void *)noload);
      }
    }
#line 1041
    return ((dyret_enum )-10);
  }
  {
#line 1042
  eqcnt = *(eqs + 0);
#line 1043
  ineqcnt = ineqs->cnt;
#line 1048
  retval = cold_createdysys(orig_sys, eqcnt, ineqcnt);
  }
#line 1049
  if ((int )retval == 0) {
#line 1050
    if ((unsigned long )eqs != (unsigned long )((void *)0)) {
      {
#line 1050
      free((void *)eqs);
      }
    }
#line 1051
    if ((unsigned long )ineqs != (unsigned long )((void *)0)) {
#line 1052
      if ((unsigned long )ineqs->angles != (unsigned long )((void *)0)) {
        {
#line 1052
        free((void *)ineqs->angles);
        }
      }
      {
#line 1053
      free((void *)ineqs);
      }
    }
#line 1054
    if ((unsigned long )noload != (unsigned long )((void *)0)) {
      {
#line 1054
      free((void *)noload);
      }
    }
#line 1055
    return ((dyret_enum )-10);
  }
  {
#line 1060
  retval = cold_scanvars(orig_sys);
  }
#line 1061
  if ((int )retval == 0) {
#line 1062
    if ((unsigned long )eqs != (unsigned long )((void *)0)) {
      {
#line 1062
      free((void *)eqs);
      }
    }
#line 1063
    if ((unsigned long )ineqs != (unsigned long )((void *)0)) {
#line 1064
      if ((unsigned long )ineqs->angles != (unsigned long )((void *)0)) {
        {
#line 1064
        free((void *)ineqs->angles);
        }
      }
      {
#line 1065
      free((void *)ineqs);
      }
    }
#line 1066
    if ((unsigned long )noload != (unsigned long )((void *)0)) {
      {
#line 1066
      free((void *)noload);
      }
    }
#line 1067
    return ((dyret_enum )-10);
  }
#line 1071
  noloadcnt = *(noload + 0);
#line 1072
  if (noloadcnt > 0) {
#line 1073
    ndx = 1;
    {
#line 1073
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1073
      if (! (ndx <= noloadcnt)) {
#line 1073
        goto while_break;
      }
#line 1074
      i = *(noload + ndx);
#line 1075
      *(dy_origcons + i) = -1;
#line 1073
      ndx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1076
  if ((unsigned long )noload != (unsigned long )((void *)0)) {
    {
#line 1076
    free((void *)noload);
    }
  }
#line 1088
  if ((int )dy_opts->fullsys == 1) {
    {
#line 1089
    retval = cold_loadfull(orig_sys, eqs, ineqs);
#line 1090
    dy_lp->sys.forcedfull = (bool )1;
    }
#line 1091
    if ((int )retval == 1) {
#line 1091
      if (dy_sys->archvcnt + dy_lp->sys.vars.unloadable < orig_sys->varcnt) {
#line 1095
        if (dy_opts->print.setup >= 1) {
          {
#line 1096
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  system %s has %d variables referenced only by nonbinding rows.",
                      orig_sys->nme, orig_sys->varcnt - (dy_sys->archvcnt + dy_lp->sys.vars.unloadable));
          }
        }
      }
    }
  } else {
    {
#line 1103
    retval = cold_loadpartial(orig_sys, eqs, ineqs);
#line 1104
    dy_lp->sys.forcedfull = (bool )0;
    }
  }
#line 1105
  if ((unsigned long )eqs != (unsigned long )((void *)0)) {
    {
#line 1105
    free((void *)eqs);
    }
  }
#line 1106
  if ((unsigned long )ineqs != (unsigned long )((void *)0)) {
#line 1107
    if ((unsigned long )ineqs->angles != (unsigned long )((void *)0)) {
      {
#line 1107
      free((void *)ineqs->angles);
      }
    }
    {
#line 1108
    free((void *)ineqs);
    }
  }
#line 1109
  if ((int )retval == 0) {
    {
#line 1110
    tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1110
    errmsg(313, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, orig_sys->nme);
    }
#line 1113
    return ((dyret_enum )-10);
  }
#line 1119
  n = orig_sys->varcnt;
#line 1120
  vlb = orig_sys->vlb;
#line 1121
  vub = orig_sys->vub;
#line 1122
  obj = orig_sys->obj;
#line 1123
  dy_lp->inactzcorr = (double )0;
#line 1124
  j = 1;
  {
#line 1124
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1124
    if (! (j <= n)) {
#line 1124
      goto while_break___0;
    }
#line 1125
    if (*(dy_origvars + j) <= 0) {
#line 1126
      statj = (flags )(- *(dy_origvars + j));
#line 1127
      statj &= ~ (1U << (sizeof(flags ) * 8UL - 4UL));
#line 1128
      vlbj = *(vlb + j);
#line 1129
      vubj = *(vub + j);
#line 1130
      objj = *(obj + j);
      {
#line 1133
      if (statj == (flags )(1 << 5)) {
#line 1133
        goto case_exp;
      }
#line 1133
      if (statj == (flags )(1 << 7)) {
#line 1133
        goto case_exp;
      }
#line 1139
      if (statj == (flags )(1 << 6)) {
#line 1139
        goto case_exp___1;
      }
#line 1131
      goto switch_break;
      case_exp: /* CIL Label */ 
      case_exp___0: /* CIL Label */ 
#line 1134
      dy_lp->inactzcorr += objj * vlbj;
#line 1136
      if (statj == (flags )(1 << 5)) {
#line 1136
        nbfxcnt ++;
      }
#line 1138
      goto switch_break;
      case_exp___1: /* CIL Label */ 
#line 1140
      dy_lp->inactzcorr += objj * vubj;
#line 1141
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 1124
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1150
  if (dy_opts->print.setup >= 1) {
    {
#line 1151
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  system %s has %d constraints, (%d+%d) variables",
                dy_sys->nme, dy_sys->concnt, dy_sys->archvcnt, dy_sys->logvcnt);
#line 1154
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %d constraints, %d variables ", orig_sys->concnt - dy_sys->concnt,
                orig_sys->archvcnt - dy_sys->archvcnt);
    }
#line 1157
    if (nbfxcnt > 0) {
      {
#line 1157
      dyio_outfmt(dy_logchn, dy_gtxecho, " (%d fixed)", nbfxcnt);
      }
    }
    {
#line 1158
    dyio_outfmt(dy_logchn, dy_gtxecho, " remain inactive in system %s.", orig_sys->nme);
    }
#line 1160
    if (dy_lp->sys.cons.unloadable > 0) {
      {
#line 1161
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %d constraints, %d variables unloadable.",
                  dy_lp->sys.cons.unloadable, dy_lp->sys.vars.unloadable);
      }
    } else
#line 1160
    if (dy_lp->sys.vars.unloadable > 0) {
      {
#line 1161
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  %d constraints, %d variables unloadable.",
                  dy_lp->sys.cons.unloadable, dy_lp->sys.vars.unloadable);
      }
    }
#line 1164
    if (dy_opts->print.setup >= 6) {
#line 1165
      vubj = (double )0;
#line 1166
      j = 1;
      {
#line 1166
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1166
        if (! (j <= n)) {
#line 1166
          goto while_break___1;
        }
#line 1167
        if (*(dy_origvars + j) <= 0) {
#line 1168
          statj = (flags )(- *(dy_origvars + j));
          {
#line 1170
          if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 6)) {
#line 1170
            goto case_exp___2;
          }
#line 1173
          if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 7)) {
#line 1173
            goto case_exp___3;
          }
#line 1177
          if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 8)) {
#line 1177
            goto case_exp___4;
          }
#line 1177
          if ((statj & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)))) == (unsigned int )(1 << 5)) {
#line 1177
            goto case_exp___4;
          }
#line 1180
          goto switch_default;
          case_exp___2: /* CIL Label */ 
#line 1171
          vlbj = *(vub + j);
#line 1172
          goto switch_break___0;
          case_exp___3: /* CIL Label */ 
#line 1174
          vlbj = *(vlb + j);
#line 1175
          goto switch_break___0;
          case_exp___4: /* CIL Label */ 
          case_exp___5: /* CIL Label */ 
#line 1178
          vlbj = (double )0;
#line 1179
          goto switch_break___0;
          switch_default: /* CIL Label */ 
          {
#line 1181
          tmp___1 = dy_prtvstat(statj);
#line 1181
          tmp___2 = consys_nme(orig_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1181
          tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1181
          errmsg(433, rtnnme, dy_sys->nme, tmp___3, dy_lp->tot.iters, "inactive",
                 tmp___2, j, tmp___1);
          }
#line 1185
          return ((dyret_enum )-10);
          switch_break___0: /* CIL Label */ ;
          }
#line 1186
          if (vlbj != (double )0) {
#line 1187
            if (vubj == (double )0) {
              {
#line 1188
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tinactive variables with nonzero values:");
              }
            }
            {
#line 1190
            vubj += (double )1;
#line 1191
            tmp___4 = dy_prtvstat(statj);
#line 1191
            tmp___5 = consys_nme(orig_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1191
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s", tmp___5,
                        j, vlbj, tmp___4);
            }
          }
        }
#line 1166
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1194
      if (vubj == (double )0) {
        {
#line 1195
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tall inactive variables are zero.");
        }
      }
    }
  }
#line 1199
  return ((dyret_enum )1);
}
}
#line 1270 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static int ib_archvcomp(void const   *elem1 , void const   *elem2 ) 
{ 
  ibrank_struct const   *v1 ;
  ibrank_struct const   *v2 ;

  {
#line 1283
  v1 = (ibrank_struct const   *)elem1;
#line 1284
  v2 = (ibrank_struct const   *)elem2;
#line 1286
  if (v1->bndcnt < v2->bndcnt) {
#line 1287
    return (-1);
  } else
#line 1289
  if (v1->bndcnt > v2->bndcnt) {
#line 1290
    return (1);
  } else
#line 1292
  if (v1->nonzero < v2->nonzero) {
#line 1293
    return (-1);
  } else
#line 1295
  if (v1->nonzero > v2->nonzero) {
#line 1296
    return (1);
  } else {
#line 1298
    return (0);
  }
}
}
#line 1302 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool ib_archvrank(int *p_cnt , ibrank_struct **p_archvars ) 
{ 
  int j ;
  int m ;
  int n ;
  int eligible ;
  double *vlb ;
  double *vub ;
  double vlbj ;
  double vubj ;
  pkvec_struct *aj ;
  ibrank_struct *archvars ;
  bool scaled ;
  bool retval ;
  char const   *rtnnme ;
  int freecnt ;
  int onebndcnt ;
  int twobndcnt ;
  void *tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;

  {
#line 1331
  rtnnme = "ib_archvrank";
#line 1337
  freecnt = 0;
#line 1338
  onebndcnt = 0;
#line 1339
  twobndcnt = 0;
#line 1343
  retval = (bool )1;
#line 1345
  vlb = dy_sys->vlb;
#line 1346
  vub = dy_sys->vub;
#line 1351
  if ((unsigned long )*p_archvars == (unsigned long )((void *)0)) {
    {
#line 1352
    tmp = malloc((unsigned long )dy_sys->archvcnt * sizeof(ibrank_struct ));
#line 1352
    archvars = (ibrank_struct *)tmp;
    }
  } else {
#line 1355
    archvars = *p_archvars;
  }
  {
#line 1362
  n = dy_sys->varcnt;
#line 1363
  m = dy_sys->logvcnt;
#line 1364
  scaled = dy_isscaled();
#line 1365
  eligible = 0;
#line 1366
  aj = pkvec_new(0);
#line 1367
  j = m + 1;
  }
  {
#line 1367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1367
    if (! (j <= n)) {
#line 1367
      goto while_break;
    }
    {
#line 1368
    tmp___1 = consys_getcol_pk(dy_sys, j, & aj);
    }
#line 1368
    if ((int )tmp___1 == 0) {
      {
#line 1369
      tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1369
      errmsg(122, rtnnme, dy_sys->nme, "column", tmp___0, j);
#line 1371
      retval = (bool )0;
      }
#line 1372
      goto while_break;
    }
#line 1373
    (archvars + eligible)->ndx = j;
#line 1374
    (archvars + eligible)->nonzero = aj->cnt;
#line 1375
    if (scaled) {
#line 1376
      (archvars + eligible)->ajmax = 1.0;
    } else {
      {
#line 1378
      (archvars + eligible)->ajmax = consys_infnormcol(dy_sys, j);
      }
    }
#line 1379
    vlbj = *(vlb + j);
#line 1380
    vubj = *(vub + j);
#line 1381
    if (vlbj > - dy_tols->inf) {
#line 1381
      if (vubj < dy_tols->inf) {
#line 1382
        (archvars + eligible)->bndcnt = 2;
#line 1390
        twobndcnt ++;
      } else {
#line 1381
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1394
    if (vlbj > - dy_tols->inf) {
#line 1395
      (archvars + eligible)->bndcnt = 1;
#line 1397
      onebndcnt ++;
    } else
#line 1394
    if (vubj < dy_tols->inf) {
#line 1395
      (archvars + eligible)->bndcnt = 1;
#line 1397
      onebndcnt ++;
    } else {
#line 1401
      (archvars + eligible)->bndcnt = 0;
#line 1403
      freecnt ++;
    }
#line 1406
    eligible ++;
#line 1367
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1409
  if (dy_opts->print.crash >= 4) {
    {
#line 1410
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%d eligible architecturals: %d free, %d 1-bound, %d 2-bound",
                eligible, freecnt, onebndcnt, twobndcnt);
    }
  }
#line 1415
  if ((unsigned long )aj != (unsigned long )((void *)0)) {
    {
#line 1415
    pkvec_free(aj);
    }
  }
#line 1416
  if ((int )retval == 0) {
#line 1417
    if ((unsigned long )archvars != (unsigned long )((void *)0)) {
      {
#line 1417
      free((void *)archvars);
      }
    }
#line 1418
    return ((bool )0);
  }
#line 1423
  if (eligible > 1) {
    {
#line 1424
    qsort((void *)(archvars + 0), (size_t )eligible, sizeof(ibrank_struct ), & ib_archvcomp);
    }
  } else
#line 1426
  if (eligible == 0) {
#line 1427
    if ((unsigned long )*p_archvars == (unsigned long )((void *)0)) {
#line 1428
      if ((unsigned long )archvars != (unsigned long )((void *)0)) {
        {
#line 1428
        free((void *)archvars);
        }
      }
#line 1429
      archvars = (ibrank_struct *)((void *)0);
    }
  }
#line 1433
  *p_cnt = eligible;
#line 1434
  *p_archvars = archvars;
#line 1436
  return ((bool )1);
}
}
#line 1441 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static int ib_archvselect(int cnt , ibrank_struct *vars ) 
{ 
  int i ;
  int j ;
  int m ;
  int ndx ;
  int pkndx ;
  int covered ;
  double ratio ;
  double *estpiv ;
  ibrank_struct *var ;
  bool scaled ;
  bool select___0 ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  dyret_enum retval ;
  char const   *rtnnme ;
  int bndcnt ;
  double maxratio ;
  void *tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 1493
  rtnnme = "ib_archvselect";
#line 1500
  retval = (dyret_enum )0;
#line 1501
  ratio = (double )0;
#line 1505
  m = dy_sys->concnt;
#line 1506
  scaled = dy_isscaled();
#line 1508
  aj = (pkvec_struct *)((void *)0);
#line 1509
  tmp = malloc((unsigned long )(m + 1) * sizeof(double ));
#line 1509
  estpiv = (double *)tmp;
#line 1510
  i = 1;
  }
  {
#line 1510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1510
    if (! (i <= m)) {
#line 1510
      goto while_break;
    }
#line 1510
    *(estpiv + i) = dy_tols->inf;
#line 1510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1511
  covered = 0;
#line 1515
  ndx = 0;
  {
#line 1515
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1515
    if (! (ndx < cnt)) {
#line 1515
      goto while_break___0;
    }
    {
#line 1516
    var = vars + ndx;
#line 1517
    j = var->ndx;
#line 1518
    tmp___1 = consys_getcol_pk(dy_sys, j, & aj);
    }
#line 1518
    if ((int )tmp___1 == 0) {
      {
#line 1519
      tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 1519
      errmsg(122, rtnnme, dy_sys->nme, "column", tmp___0, j);
#line 1521
      retval = (dyret_enum )-1;
      }
#line 1522
      goto while_break___0;
    }
#line 1524
    bndcnt = 0;
#line 1525
    if (*(dy_sys->vlb + j) > - dy_tols->inf) {
#line 1525
      bndcnt ++;
    }
#line 1526
    if (*(dy_sys->vub + j) < dy_tols->inf) {
#line 1526
      bndcnt ++;
    }
#line 1527
    maxratio = - 1.0;
#line 1542
    select___0 = (bool )0;
#line 1543
    pkndx = aj->cnt - 1;
    {
#line 1543
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1543
      if (! (pkndx >= 0)) {
#line 1543
        goto while_break___1;
      }
      {
#line 1544
      aij = aj->coeffs + pkndx;
#line 1545
      i = aij->ndx;
#line 1546
      ratio = fabs(aij->val);
      }
#line 1547
      if (! scaled) {
#line 1547
        ratio /= var->ajmax;
      }
#line 1548
      if (*(dy_basis + i) == 0) {
#line 1549
        if (ratio > .9) {
#line 1550
          select___0 = (bool )1;
#line 1551
          goto while_break___1;
        } else
#line 1554
        if (maxratio < ratio) {
#line 1554
          maxratio = ratio;
        }
      } else
#line 1558
      if (ratio > .1 * *(estpiv + i)) {
#line 1558
        goto while_break___1;
      }
#line 1543
      pkndx --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1563
    if ((int )select___0 == 1) {
#line 1564
      *(dy_basis + i) = j;
#line 1565
      *(dy_var2basis + j) = i;
#line 1566
      *(estpiv + i) = ratio;
#line 1567
      covered ++;
#line 1569
      if (dy_opts->print.crash >= 4) {
        {
#line 1570
        tmp___2 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1570
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  adding %s (%d) (%d bounds)", tmp___2,
                    j, bndcnt);
#line 1572
        tmp___3 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1572
        tmp___4 = consys_prtcontyp(*(dy_sys->ctyp + i));
#line 1572
        dyio_outfmt(dy_logchn, dy_gtxecho, " to cover %s %s (%d),", tmp___4, tmp___3,
                    i);
#line 1575
        dyio_outfmt(dy_logchn, dy_gtxecho, " |a<%d,%d>/max(a<*,%d>)| = %g.", i, j,
                    j, ratio);
        }
      }
#line 1578
      if (covered == m) {
#line 1578
        goto while_break___0;
      }
    } else
#line 1581
    if (dy_opts->print.crash >= 4) {
      {
#line 1582
      tmp___5 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1582
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  rejected %s (%d) (%d bounds)", tmp___5,
                  j, bndcnt);
      }
#line 1584
      if (pkndx >= 0) {
        {
#line 1585
        dyio_outfmt(dy_logchn, dy_gtxecho, "; lower diag violation at .1;");
#line 1586
        dyio_outfmt(dy_logchn, dy_gtxecho, " a<%d,%d> = %g, estpiv<%d> = %g, ratio %g.",
                    i, j, ratio, i, *(estpiv + i), ratio / *(estpiv + i));
        }
      } else
#line 1590
      if (maxratio > (double )0) {
        {
#line 1591
        dyio_outfmt(dy_logchn, dy_gtxecho, " at %g < .9; no suitable pivots.", maxratio);
        }
      } else {
        {
#line 1594
        dyio_outfmt(dy_logchn, dy_gtxecho, " no non-zeroes in uncovered rows.");
        }
      }
    }
#line 1515
    ndx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1598
  if ((unsigned long )aj != (unsigned long )((void *)0)) {
    {
#line 1598
    pkvec_free(aj);
    }
  }
#line 1599
  if ((unsigned long )estpiv != (unsigned long )((void *)0)) {
    {
#line 1599
    free((void *)estpiv);
    }
  }
#line 1600
  if ((int )retval < 0) {
#line 1600
    return ((int )retval);
  }
#line 1606
  if (dy_opts->print.crash >= 2) {
    {
#line 1607
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    added %d architectural variables.",
                covered);
    }
  }
#line 1611
  return (covered);
}
}
#line 1615 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static int ib_slackselect(void) 
{ 
  int i ;
  int m ;
  int covered ;
  contyp_enum *ctyp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1632
  m = dy_sys->concnt;
#line 1633
  ctyp = dy_sys->ctyp;
#line 1634
  covered = 0;
#line 1636
  i = 1;
  {
#line 1636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1636
    if (! (i <= m)) {
#line 1636
      goto while_break;
    }
#line 1637
    if ((unsigned int )*(ctyp + i) != 3U) {
#line 1637
      if (*(dy_basis + i) == 0) {
#line 1638
        *(dy_basis + i) = i;
#line 1639
        *(dy_var2basis + i) = i;
#line 1640
        covered ++;
#line 1642
        if (dy_opts->print.crash >= 4) {
          {
#line 1643
          tmp = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 1643
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  adding %s (%d)", tmp, i);
#line 1645
          tmp___0 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1645
          dyio_outfmt(dy_logchn, dy_gtxecho, " to cover %s (%d).", tmp___0, i);
          }
        }
      }
    }
#line 1636
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1650
  if (dy_opts->print.crash >= 2) {
    {
#line 1651
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    added %d slack/surplus variables.",
                covered);
    }
  }
#line 1655
  return (covered);
}
}
#line 1658 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static int ib_artifselect(void) 
{ 
  int i ;
  int m ;
  int covered ;
  contyp_enum *ctyp ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1675
  m = dy_sys->concnt;
#line 1676
  ctyp = dy_sys->ctyp;
#line 1677
  covered = 0;
#line 1679
  i = 1;
  {
#line 1679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1679
    if (! (i <= dy_sys->concnt)) {
#line 1679
      goto while_break;
    }
#line 1680
    if ((unsigned int )*(ctyp + i) == 3U) {
#line 1680
      if (*(dy_basis + i) == 0) {
#line 1681
        *(dy_basis + i) = i;
#line 1682
        *(dy_var2basis + i) = i;
#line 1683
        covered ++;
#line 1685
        if (dy_opts->print.crash >= 4) {
          {
#line 1686
          tmp = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 1686
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  adding %s (%d)", tmp, i);
#line 1688
          tmp___0 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1688
          dyio_outfmt(dy_logchn, dy_gtxecho, " to cover %s (%d).", tmp___0, i);
          }
        }
      }
    }
#line 1679
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1693
  if (dy_opts->print.crash >= 2) {
    {
#line 1694
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    added %d artificial variables.", covered);
    }
  }
#line 1698
  return (covered);
}
}
#line 1702 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
static bool ib_populatebasis(void) 
{ 
  int m ;
  int basiscnt ;
  int archvcnt ;
  int slkcnt ;
  int artifcnt ;
  int iretval ;
  bool bretval ;
  ibrank_struct *archvars ;
  char const   *rtnnme ;
  int i ;
  int j ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1727
  rtnnme = "ib_populatebasis";
#line 1739
  m = dy_sys->concnt;
#line 1742
  if (dy_opts->print.crash >= 1) {
    {
#line 1743
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  constructing ");
    }
    {
#line 1745
    if ((unsigned int )dy_opts->coldbasis == 1U) {
#line 1745
      goto case_1;
    }
#line 1748
    if ((unsigned int )dy_opts->coldbasis == 2U) {
#line 1748
      goto case_2;
    }
#line 1751
    if ((unsigned int )dy_opts->coldbasis == 3U) {
#line 1751
      goto case_3;
    }
#line 1754
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1746
    dyio_outfmt(dy_logchn, dy_gtxecho, "logical");
    }
#line 1747
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1749
    dyio_outfmt(dy_logchn, dy_gtxecho, "slack");
    }
#line 1750
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1752
    dyio_outfmt(dy_logchn, dy_gtxecho, "architectural");
    }
#line 1753
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1755
    errmsg(1, rtnnme, 1755);
    }
#line 1756
    return ((bool )0);
    switch_break: /* CIL Label */ ;
    }
    {
#line 1757
    dyio_outfmt(dy_logchn, dy_gtxecho, " basis for system %s, %d constraints.", dy_sys->nme,
                m);
    }
  }
#line 1762
  basiscnt = 0;
#line 1767
  if ((unsigned int )dy_opts->coldbasis == 1U) {
    {
#line 1768
    slkcnt = ib_slackselect();
#line 1769
    basiscnt += slkcnt;
    }
  } else
#line 1767
  if ((unsigned int )dy_opts->coldbasis == 2U) {
    {
#line 1768
    slkcnt = ib_slackselect();
#line 1769
    basiscnt += slkcnt;
    }
  }
#line 1784
  if (basiscnt < m) {
#line 1784
    if ((unsigned int )dy_opts->coldbasis == 2U) {
#line 1784
      goto _L;
    } else
#line 1784
    if ((unsigned int )dy_opts->coldbasis == 3U) {
      _L: /* CIL Label */ 
      {
#line 1786
      archvars = (ibrank_struct *)((void *)0);
#line 1787
      bretval = ib_archvrank(& archvcnt, & archvars);
      }
#line 1788
      if ((int )bretval == 0) {
        {
#line 1789
        tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1789
        errmsg(305, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "rank", "architectural");
        }
#line 1792
        if ((unsigned long )archvars != (unsigned long )((void *)0)) {
          {
#line 1792
          free((void *)archvars);
          }
        }
#line 1793
        return ((bool )0);
      }
      {
#line 1794
      iretval = ib_archvselect(archvcnt, archvars);
      }
#line 1795
      if ((unsigned long )archvars != (unsigned long )((void *)0)) {
        {
#line 1795
        free((void *)archvars);
        }
      }
#line 1796
      if (iretval < 0) {
        {
#line 1797
        tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1797
        errmsg(305, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, "select", "architectural");
        }
#line 1800
        return ((bool )0);
      }
#line 1801
      basiscnt += iretval;
    }
  }
#line 1805
  if (basiscnt < m) {
#line 1805
    if ((unsigned int )dy_opts->coldbasis == 3U) {
      {
#line 1806
      slkcnt = ib_slackselect();
#line 1807
      basiscnt += slkcnt;
      }
    }
  }
#line 1812
  if (basiscnt < m) {
    {
#line 1813
    artifcnt = ib_artifselect();
#line 1814
    basiscnt += artifcnt;
    }
  }
#line 1817
  if (dy_opts->print.crash >= 4) {
    {
#line 1818
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    Pos\'n Variable           Constraint");
#line 1820
    i = 1;
    }
    {
#line 1820
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1820
      if (! (i <= basiscnt)) {
#line 1820
        goto while_break;
      }
      {
#line 1821
      j = *(dy_basis + i);
#line 1822
      tmp___1 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1822
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t     %3d  (%3d) %-15s", i, j, tmp___1);
#line 1824
      tmp___2 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 1824
      dyio_outfmt(dy_logchn, dy_gtxecho, "%-15s", tmp___2);
#line 1820
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1831
  if (basiscnt < m) {
    {
#line 1832
    errmsg(301, rtnnme, basiscnt, m, dy_sys->nme);
    }
#line 1833
    return ((bool )0);
  }
#line 1835
  return ((bool )1);
}
}
#line 1840 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_coldstart.c"
dyret_enum dy_crash(void) 
{ 
  int vndx ;
  double *vub ;
  double *vlb ;
  double *obj ;
  flags calcflgs ;
  dyret_enum retval ;
  char const   *rtnnme ;
  int cndx ;
  bool tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;
  bool tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  bool tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;

  {
  {
#line 1865
  rtnnme = "dy_crash";
#line 1907
  obj = dy_sys->obj;
#line 1908
  vlb = dy_sys->vlb;
#line 1909
  vub = dy_sys->vub;
#line 1910
  tmp = consys_attach(dy_sys, 1U << 2, (int )sizeof(int ), (void **)(& dy_basis));
  }
#line 1910
  if ((int )tmp == 0) {
    {
#line 1912
    errmsg(100, rtnnme, dy_sys->nme, "basis vector");
    }
#line 1913
    return ((dyret_enum )-10);
  }
  {
#line 1914
  tmp___0 = consys_attach(dy_sys, 1U << 1, (int )sizeof(int ), (void **)(& dy_var2basis));
  }
#line 1914
  if ((int )tmp___0 == 0) {
    {
#line 1916
    errmsg(100, rtnnme, dy_sys->nme, "inverse basis vector");
    }
#line 1917
    return ((dyret_enum )-10);
  }
  {
#line 1921
  tmp___2 = ib_populatebasis();
  }
#line 1921
  if ((int )tmp___2 == 0) {
    {
#line 1922
    tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1922
    errmsg(302, rtnnme, dy_sys->nme, tmp___1, dy_lp->tot.iters, "populate");
    }
#line 1924
    return ((dyret_enum )-10);
  }
#line 1929
  if (dy_sys->concnt > 0) {
#line 1932
    if (dy_opts->print.crash >= 2) {
      {
#line 1933
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tfactoring ...");
      }
    }
    {
#line 1935
    calcflgs = (flags )0;
#line 1936
    retval = dy_factor(& calcflgs);
    }
    {
#line 1939
    if ((int )retval == 2) {
#line 1939
      goto case_2;
    }
#line 1939
    if ((int )retval == 1) {
#line 1939
      goto case_2;
    }
#line 1941
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1940
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1942
    errmsg(309, rtnnme, dy_sys->nme);
    }
#line 1943
    return (retval);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1948
  tmp___3 = consys_attach(dy_sys, 1U << 1, (int )sizeof(flags ), (void **)(& dy_status));
  }
#line 1948
  if ((int )tmp___3 == 0) {
    {
#line 1950
    errmsg(100, rtnnme, dy_sys->nme, "status vector");
    }
#line 1951
    return ((dyret_enum )-10);
  }
  {
#line 1952
  tmp___4 = consys_attach(dy_sys, 1U << 2, (int )sizeof(double ), (void **)(& dy_xbasic));
  }
#line 1952
  if ((int )tmp___4 == 0) {
    {
#line 1954
    errmsg(100, rtnnme, dy_sys->nme, "basic variable vector");
    }
#line 1955
    return ((dyret_enum )-10);
  }
  {
#line 1956
  tmp___5 = consys_attach(dy_sys, 1U << 1, (int )sizeof(double ), (void **)(& dy_x));
  }
#line 1956
  if ((int )tmp___5 == 0) {
    {
#line 1958
    errmsg(100, rtnnme, dy_sys->nme, "primal variable vector");
    }
#line 1959
    return ((dyret_enum )-10);
  }
  {
#line 1960
  tmp___6 = consys_attach(dy_sys, 1U << 2, (int )sizeof(double ), (void **)(& dy_y));
  }
#line 1960
  if ((int )tmp___6 == 0) {
    {
#line 1962
    errmsg(100, rtnnme, dy_sys->nme, "dual variable vector");
    }
#line 1963
    return ((dyret_enum )-10);
  }
  {
#line 1964
  tmp___7 = consys_attach(dy_sys, 1U << 1, (int )sizeof(double ), (void **)(& dy_cbar));
  }
#line 1964
  if ((int )tmp___7 == 0) {
    {
#line 1966
    errmsg(100, rtnnme, dy_sys->nme, "reduced cost vector");
    }
#line 1967
    return ((dyret_enum )-10);
  }
  {
#line 1973
  dy_calcduals();
#line 1974
  tmp___9 = dy_calccbar();
  }
#line 1974
  if ((int )tmp___9 == 0) {
    {
#line 1975
    tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1975
    errmsg(384, rtnnme, dy_sys->nme, tmp___8, dy_lp->tot.iters);
    }
#line 1977
    return ((dyret_enum )-10);
  }
#line 1989
  if (dy_opts->print.crash >= 2) {
    {
#line 1990
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\testablishing initial status and reference frame ...");
    }
  }
#line 1993
  vndx = 1;
  {
#line 1993
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1993
    if (! (vndx <= dy_sys->varcnt)) {
#line 1993
      goto while_break;
    }
#line 1994
    if (*(dy_var2basis + vndx) != 0) {
#line 1995
      if (*(vlb + vndx) == *(vub + vndx)) {
#line 1996
        *(dy_status + vndx) = (flags )1;
      } else
#line 1998
      if (*(vlb + vndx) <= - dy_tols->inf) {
#line 1998
        if (*(vub + vndx) >= dy_tols->inf) {
#line 1999
          *(dy_status + vndx) = (flags )(1 << 4);
        } else {
#line 2001
          *(dy_status + vndx) = (flags )(1 << 2);
        }
      } else {
#line 2001
        *(dy_status + vndx) = (flags )(1 << 2);
      }
    } else
#line 2003
    if (*(vlb + vndx) > - dy_tols->inf) {
#line 2003
      if (*(vub + vndx) < dy_tols->inf) {
#line 2004
        if (*(vub + vndx) == *(vlb + vndx)) {
#line 2005
          *(dy_status + vndx) = (flags )(1 << 5);
#line 2006
          *(dy_x + vndx) = *(vub + vndx);
        } else
#line 2008
        if (*(dy_cbar + vndx) >= (double )0) {
#line 2009
          *(dy_status + vndx) = (flags )(1 << 7);
#line 2010
          *(dy_x + vndx) = *(vlb + vndx);
        } else {
#line 2012
          *(dy_status + vndx) = (flags )(1 << 6);
#line 2013
          *(dy_x + vndx) = *(vub + vndx);
        }
      } else {
#line 2003
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2015
    if (*(vlb + vndx) > - dy_tols->inf) {
#line 2016
      *(dy_status + vndx) = (flags )(1 << 7);
#line 2017
      *(dy_x + vndx) = *(vlb + vndx);
    } else
#line 2019
    if (*(vub + vndx) < dy_tols->inf) {
#line 2020
      *(dy_status + vndx) = (flags )(1 << 6);
#line 2021
      *(dy_x + vndx) = *(vub + vndx);
    } else {
#line 2023
      *(dy_status + vndx) = (flags )(1 << 8);
#line 2024
      *(dy_x + vndx) = (double )0;
    }
#line 2026
    if (dy_opts->print.crash >= 4) {
      {
#line 2027
      tmp___10 = dy_prtvstat(*(dy_status + vndx));
#line 2027
      tmp___11 = consys_nme(dy_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 2027
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  %s (%d) %s", tmp___11, vndx, tmp___10);
      }
#line 2030
      if (*(dy_status + vndx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 2030
        tmp___12 = 1;
      } else {
#line 2030
        tmp___12 = 0;
      }
#line 2030
      if (tmp___12) {
        {
#line 2031
        dyio_outfmt(dy_logchn, dy_gtxecho, " with value %g.", *(dy_x + vndx));
        }
      } else {
        {
#line 2033
        dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
        }
      }
    }
#line 1993
    vndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2043
  if (dy_opts->print.crash >= 2) {
    {
#line 2044
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tcalculating basic variable values ...");
    }
  }
  {
#line 2047
  tmp___13 = dy_calcprimals();
  }
#line 2047
  if ((int )tmp___13 == 0) {
    {
#line 2048
    errmsg(316, rtnnme, dy_sys->nme);
    }
#line 2049
    return ((dyret_enum )-10);
  }
  {
#line 2050
  dy_lp->z = dy_calcobj();
#line 2051
  dy_setfinalstatus();
#line 2056
  calcflgs = (flags )(((1 | (1 << 2)) | (1 << 3)) | (1 << 5));
#line 2057
  retval = dy_accchk(& calcflgs);
  }
#line 2058
  if ((int )retval != 1) {
    {
#line 2059
    tmp___14 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2059
    errmsg(304, rtnnme, dy_sys->nme, tmp___14, dy_lp->tot.iters);
    }
#line 2061
    return (retval);
  }
#line 2062
  if (calcflgs & 1U) {
#line 2062
    tmp___16 = 0;
  } else {
#line 2062
    tmp___16 = 1;
  }
#line 2062
  if (tmp___16) {
#line 2063
    dy_lp->simplex.next = (dyphase_enum )3;
  } else {
#line 2065
    if (calcflgs & (unsigned int )(1 << 3)) {
#line 2065
      tmp___15 = 0;
    } else {
#line 2065
      tmp___15 = 1;
    }
#line 2065
    if (tmp___15) {
#line 2066
      dy_lp->simplex.next = (dyphase_enum )4;
    } else {
#line 2068
      dy_lp->simplex.next = (dyphase_enum )2;
    }
  }
#line 2074
  if (dy_opts->print.crash >= 3) {
    {
#line 2075
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  Pos\'n Constraint\tDual\tPrimal\t\t   Status\tValue");
#line 2077
    cndx = 1;
    }
    {
#line 2077
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2077
      if (! (cndx <= dy_sys->concnt)) {
#line 2077
        goto while_break___0;
      }
      {
#line 2078
      vndx = *(dy_basis + cndx);
#line 2079
      tmp___17 = consys_nme(dy_sys, (char )'c', cndx, (bool )0, (char *)((void *)0));
#line 2079
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n   %4d  %-13s%7g", cndx, tmp___17, *(dy_y + cndx));
#line 2081
      tmp___18 = dy_prtvstat(*(dy_status + vndx));
#line 2081
      tmp___19 = consys_nme(dy_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 2081
      dyio_outfmt(dy_logchn, dy_gtxecho, "  (%4d) %-13s %-7s %7g", vndx, tmp___19,
                  tmp___18, *(dy_x + vndx));
#line 2077
      cndx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2085
  if (dy_opts->print.crash >= 2) {
    {
#line 2086
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tinitial objective %g", dy_lp->z);
    }
#line 2087
    if (dy_lp->infeascnt != 0) {
      {
#line 2088
      dyio_outfmt(dy_logchn, dy_gtxecho, ", %d infeasible vars, infeas. = %g", dy_lp->infeascnt,
                  dy_lp->infeas);
      }
    }
    {
#line 2090
    tmp___20 = dy_prtlpphase(dy_lp->simplex.next, (bool )0);
#line 2090
    dyio_outfmt(dy_logchn, dy_gtxecho, ", target simplex %s.", tmp___20);
    }
  }
#line 2094
  return ((dyret_enum )1);
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_pricenbvars(lpprob_struct *orig_lp , flags priceme , double **p_ocbar , int *p_nbcnt ,
                    int **p_nbvars ) ;
#line 1898
bool dy_pricedualpiv(lpprob_struct *orig_lp , int oxindx , double nubi , double xi ,
                     double nlbi , int nbcnt , int *nbvars , double *nbcbar , double *p_upeni ,
                     double *p_dpeni ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_penalty.c"
static bool dy_unscale_betai(consys_struct *orig_sys , int oxindx , double **betai ,
                             double **ai ) 
{ 


  {
#line 70
  return ((bool )0);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_penalty.c"
static void dy_orig_cbarLocal(int nbcnt , double *cbar , int *vndx ) 
{ 
  int j ;
  int k ;
  double cbarj ;
  double const   *rscale ;
  double const   *cscale ;
  bool tmp ;
  double tmp___0 ;

  {
  {
#line 114
  tmp = dy_isscaled();
  }
#line 114
  if ((int )tmp == 0) {
#line 114
    return;
  }
  {
#line 115
  dy_scaling_vectors(& rscale, & cscale);
#line 120
  k = 0;
  }
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (k < nbcnt)) {
#line 120
      goto while_break;
    }
#line 121
    j = *(vndx + k);
#line 122
    cbarj = *(cbar + k);
#line 123
    if (j > 0) {
#line 124
      cbarj /= (double )*(cscale + j);
    } else {
#line 126
      cbarj *= (double )*(rscale + - j);
    }
    {
#line 127
    tmp___0 = fabs(cbarj);
    }
#line 127
    if (tmp___0 < dy_tols->dfeas) {
#line 127
      cbarj = (double )0;
    }
#line 128
    *(cbar + k) = cbarj;
#line 120
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_penalty.c"
bool dy_pricenbvars(lpprob_struct *orig_lp , flags priceme , double **p_ocbar , int *p_nbcnt ,
                    int **p_nbvars ) 
{ 
  int oxjndx ;
  int xjndx ;
  int pkndx ;
  int cndx ;
  int nbcnt ;
  int *nbvars ;
  double cbarj ;
  double *ocbar ;
  flags statj ;
  bool retval ;
  consys_struct *orig_sys ;
  pkvec_struct *aj ;
  pkcoeff_struct *aij ;
  char const   *rtnnme ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 177
  rtnnme = "dy_pricenbvars";
#line 205
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 205
    tmp = 0;
  } else {
#line 205
    tmp = 1;
  }
#line 205
  if (tmp) {
    {
#line 206
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "price nonbasic columns");
    }
#line 207
    return ((bool )0);
  }
  {
#line 208
  dy_initlclsystem(orig_lp, (bool )1);
#line 209
  orig_sys = orig_lp->consys;
  }
#line 214
  if ((unsigned long )*p_ocbar == (unsigned long )((void *)0)) {
    {
#line 215
    tmp___0 = calloc((size_t )orig_sys->varcnt, sizeof(double ));
#line 215
    *p_ocbar = (double *)tmp___0;
    }
  }
#line 216
  ocbar = *p_ocbar;
#line 217
  if ((unsigned long )*p_nbvars == (unsigned long )((void *)0)) {
    {
#line 218
    tmp___1 = calloc((size_t )orig_sys->varcnt, sizeof(int ));
#line 218
    *p_nbvars = (int *)tmp___1;
    }
  }
#line 219
  nbvars = *p_nbvars;
#line 227
  retval = (bool )1;
#line 228
  aj = (pkvec_struct *)((void *)0);
#line 229
  nbcnt = 0;
#line 230
  oxjndx = 1;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (oxjndx <= orig_sys->varcnt)) {
#line 230
      goto while_break;
    }
#line 231
    if (*(dy_origvars + oxjndx) > 0) {
#line 232
      xjndx = *(dy_origvars + oxjndx);
#line 233
      statj = *(dy_status + xjndx);
#line 234
      if (statj & priceme) {
#line 234
        tmp___4 = 1;
      } else {
#line 234
        tmp___4 = 0;
      }
#line 234
      if (tmp___4) {
        {
#line 235
        cbarj = *(dy_cbar + xjndx);
#line 236
        tmp___2 = fabs(cbarj);
        }
#line 236
        if (tmp___2 < dy_tols->dfeas) {
#line 236
          cbarj = (double )0;
        }
#line 246
        *(ocbar + nbcnt) = cbarj;
#line 247
        tmp___3 = nbcnt;
#line 247
        nbcnt ++;
#line 247
        *(nbvars + tmp___3) = oxjndx;
      }
    } else {
#line 255
      statj = (flags )(- *(dy_origvars + oxjndx));
#line 265
      if (statj & priceme) {
#line 265
        tmp___9 = 1;
      } else {
#line 265
        tmp___9 = 0;
      }
#line 265
      if (tmp___9) {
        {
#line 266
        cbarj = *(orig_sys->obj + oxjndx);
#line 267
        tmp___6 = consys_getcol_pk(orig_sys, oxjndx, & aj);
        }
#line 267
        if ((int )tmp___6 == 0) {
          {
#line 268
          tmp___5 = consys_nme(orig_sys, (char )'v', oxjndx, (bool )1, (char *)((void *)0));
#line 268
          errmsg(122, rtnnme, orig_sys->nme, "column", tmp___5, oxjndx);
#line 270
          retval = (bool )0;
          }
#line 271
          goto while_break;
        }
#line 272
        pkndx = 0;
#line 272
        aij = aj->coeffs;
        {
#line 272
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 272
          if (! (pkndx < aj->cnt)) {
#line 272
            goto while_break___0;
          }
#line 273
          if (*(dy_origcons + aij->ndx) > 0) {
#line 274
            cndx = *(dy_origcons + aij->ndx);
#line 275
            cbarj -= *(dy_y + cndx) * aij->val;
          }
#line 272
          pkndx ++;
#line 272
          aij ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 276
        tmp___7 = fabs(cbarj);
        }
#line 276
        if (tmp___7 < dy_tols->dfeas) {
#line 276
          cbarj = (double )0;
        }
#line 286
        *(ocbar + nbcnt) = cbarj;
#line 287
        tmp___8 = nbcnt;
#line 287
        nbcnt ++;
#line 287
        *(nbvars + tmp___8) = oxjndx;
      }
    }
#line 230
    oxjndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  xjndx = 1;
  {
#line 293
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 293
    if (! (xjndx <= dy_sys->concnt)) {
#line 293
      goto while_break___1;
    }
#line 294
    statj = *(dy_status + xjndx);
#line 295
    if (statj & priceme) {
#line 295
      tmp___12 = 1;
    } else {
#line 295
      tmp___12 = 0;
    }
#line 295
    if (tmp___12) {
      {
#line 296
      cbarj = *(dy_cbar + xjndx);
#line 297
      tmp___10 = fabs(cbarj);
      }
#line 297
      if (tmp___10 < dy_tols->dfeas) {
#line 297
        cbarj = (double )0;
      }
#line 307
      *(ocbar + nbcnt) = cbarj;
#line 308
      tmp___11 = nbcnt;
#line 308
      nbcnt ++;
#line 308
      *(nbvars + tmp___11) = - *(dy_actcons + xjndx);
    }
#line 293
    xjndx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 309
  *p_nbcnt = nbcnt;
#line 313
  dy_orig_cbarLocal(nbcnt, ocbar, nbvars);
#line 317
  dy_freelclsystem(orig_lp, (bool )0);
  }
#line 318
  if ((unsigned long )aj != (unsigned long )((void *)0)) {
    {
#line 318
    pkvec_free(aj);
    }
  }
#line 320
  return (retval);
}
}
#line 324 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_penalty.c"
static bool pricedualpiv(consys_struct *orig_sys , double *betai , double *ai , int oxindx ,
                         double nubi , double xi , double nlbi , int nbcnt , int *nbvars ,
                         double *nbcbar , double *p_upeni , double *p_dpeni ) 
{ 


  {
#line 608
  return ((bool )0);
}
}
#line 613 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_penalty.c"
bool dy_pricedualpiv(lpprob_struct *orig_lp , int oxindx , double nubi , double xi ,
                     double nlbi , int nbcnt , int *nbvars , double *nbcbar , double *p_upeni ,
                     double *p_dpeni ) 
{ 
  double *betai ;
  double *ai ;
  consys_struct *orig_sys ;
  bool retval ;
  char const   *rtnnme ;
  int tmp ;
  bool tmp___0 ;

  {
#line 677
  rtnnme = "dy_pricedualpiv";
#line 701
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 701
    tmp = 0;
  } else {
#line 701
    tmp = 1;
  }
#line 701
  if (tmp) {
    {
#line 702
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "calculate penalty");
    }
#line 703
    return ((bool )0);
  }
  {
#line 704
  orig_sys = orig_lp->consys;
#line 708
  betai = (double *)((void *)0);
#line 709
  ai = (double *)((void *)0);
#line 710
  tmp___0 = dy_unscale_betai(orig_sys, oxindx, & betai, & ai);
  }
#line 710
  if ((int )tmp___0 == 0) {
#line 711
    return ((bool )0);
  }
  {
#line 715
  retval = pricedualpiv(orig_sys, betai, ai, oxindx, nubi, xi, nlbi, nbcnt, nbvars,
                        nbcbar, p_upeni, p_dpeni);
  }
#line 720
  if ((unsigned long )ai != (unsigned long )((void *)0)) {
    {
#line 720
    free((void *)ai);
    }
  }
#line 721
  if ((unsigned long )betai != (unsigned long )((void *)0)) {
    {
#line 721
    free((void *)betai);
    }
  }
#line 723
  return (retval);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_littab.c"
static hel *littable[2039]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_littab.c"
char const   *stralloc(char const   *string ) 
{ 
  litent *lit ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 75
  rtnnme = "stralloc";
#line 77
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 78
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null string parameter!\n",
            rtnnme);
    }
#line 79
    return ((char const   *)((void *)0));
  }
  {
#line 81
  tmp = lookup(string, littable, 2039);
#line 81
  lit = (litent *)tmp;
  }
#line 83
  if ((unsigned long )lit != (unsigned long )((void *)0)) {
#line 84
    (lit->refs) ++;
#line 85
    return ((char const   *)lit->text);
  }
  {
#line 87
  tmp___0 = malloc(sizeof(litent ));
#line 87
  lit = (litent *)tmp___0;
#line 88
  tmp___1 = strlen(string);
#line 88
  tmp___2 = malloc(tmp___1 + 1UL);
#line 88
  lit->text = (char *)tmp___2;
#line 89
  strcpy((char */* __restrict  */)lit->text, (char const   */* __restrict  */)string);
#line 90
  lit->refs = 1;
#line 91
  tmp___3 = enter((char const   *)lit->text, littable, 2039, (void *)((char *)lit));
  }
#line 91
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: couldn\'t enter string \"%s\" in literal table!\n",
            rtnnme, string);
#line 94
    free((void *)lit->text);
#line 95
    free((void *)lit);
    }
#line 96
    return ((char const   *)((void *)0));
  }
#line 98
  return ((char const   *)lit->text);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/DylpStdLib/dylib_littab.c"
bool strfree(char const   *string ) 
{ 
  litent *lit ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 118
  rtnnme = "strfree";
#line 120
  if ((unsigned long )string == (unsigned long )((void *)0)) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: null string parameter!\n",
            rtnnme);
    }
#line 122
    return ((bool )0);
  }
  {
#line 124
  tmp = lookup(string, littable, 2039);
#line 124
  lit = (litent *)tmp;
  }
#line 126
  if ((unsigned long )lit == (unsigned long )((void *)0)) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: no entry for string \"%s\" in literal table!\n",
            rtnnme, string);
    }
#line 129
    return ((bool )0);
  }
#line 131
  (lit->refs) --;
#line 131
  if (lit->refs == 0) {
    {
#line 132
    tmp___0 = erase((char const   *)lit->text, littable, 2039);
    }
#line 132
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: confusion deleting entry for string \"%s\"!\n",
              rtnnme, lit->text);
      }
#line 135
      return ((bool )0);
    }
    {
#line 136
    free((void *)lit->text);
#line 137
    free((void *)lit);
    }
  }
#line 139
  return ((bool )1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.h"
cmd_retval process_cmds(bool silent ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static int level  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static bool prompt  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static struct __anonstruct_cmdchns_24 cmdchns[15]  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static keytab_entry usercmds[13]  = 
#line 90
  {      {"help", 1, 1}, 
        {"incumbent", 1, 255}, 
        {"lpcontrol", 3, 12}, 
        {"lpprint", 3, 2}, 
        {"mipcontrol", 4, 255}, 
        {"miplimit", 4, 255}, 
        {"mipprint", 4, 255}, 
        {"objdelta", 4, 255}, 
        {"objective", 4, 255}, 
        {"phic", 2, 255}, 
        {"priority", 2, 255}, 
        {"recovery", 1, 255}, 
        {"tourclass", 1, 255}};
#line 110 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static cmd_retval docmd(lex_struct *txt ) 
{ 
  lex_struct *lex___1 ;
  char const   *keywd ;
  int cmd ;
  cmd_retval retval ;
  char const   *rtnnme ;

  {
#line 129
  rtnnme = "docmd";
#line 163
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
    {
#line 164
    errmsg(2, rtnnme, "txt");
    }
#line 165
    return ((cmd_retval )1);
  }
#line 166
  if ((unsigned int )txt->class != 2U) {
    {
#line 167
    errmsg(5, rtnnme, (int )txt->class);
    }
#line 168
    return ((cmd_retval )1);
  }
  {
#line 173
  dyio_outfmt(dy_logchn, dy_cmdecho, (char const   *)txt->string);
#line 174
  dyio_flushio(dy_logchn, dy_cmdecho);
#line 175
  cmd = ambig(txt->string, usercmds, (int )(sizeof(usercmds) / sizeof(keytab_entry )));
  }
#line 176
  if (cmd < 0) {
#line 177
    if (cmd < -1) {
      {
#line 178
      errmsg(233, rtnnme, txt->string);
      }
    } else {
      {
#line 180
      errmsg(234, rtnnme, txt->string);
      }
    }
#line 181
    return ((cmd_retval )1);
  }
  {
#line 186
  keywd = stralloc((char const   *)txt->string);
#line 187
  dyio_setmode(dy_cmdchn, (char )'f');
#line 188
  retval = (cmd_retval )1;
#line 189
  dyio_setmode(dy_cmdchn, (char )'f');
  }
  {
#line 191
  if (cmd == 2) {
#line 191
    goto case_2;
  }
#line 194
  if (cmd == 12) {
#line 194
    goto case_12;
  }
#line 229
  if (cmd == 1) {
#line 229
    goto case_1;
  }
#line 234
  if (cmd == 255) {
#line 234
    goto case_255;
  }
#line 190
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 192
  retval = dy_printopt(keywd);
  }
#line 193
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 195
  retval = dy_ctlopt(keywd);
  }
#line 196
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 230
  dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tHeh heh heh.\t\tSurely you jest?\n");
#line 232
  retval = (cmd_retval )0;
  }
#line 233
  goto switch_break;
  case_255: /* CIL Label */ 
  {
#line 235
  dyio_outfmt(dy_logchn, dy_gtxecho, "\nThe command \"%s\" is unimplemented in this configuration.\n",
              keywd);
#line 238
  retval = (cmd_retval )0;
  }
#line 239
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 240
  strfree(keywd);
#line 241
  dyio_setmode(dy_cmdchn, (char )'l');
  }
#line 246
  if ((unsigned int )retval != 1U) {
    {
#line 247
    lex___1 = dyio_scanstr(dy_cmdchn, (lexclass )5, 0, (char )'\000', (char )'\n');
    }
#line 248
    if (! ((unsigned int )lex___1->class == 0U)) {
#line 248
      if (! ((unsigned int )lex___1->class == 6U)) {
#line 248
        if (! ((unsigned int )lex___1->class == 7U)) {
          {
#line 250
          dyio_outfmt(dy_logchn, dy_cmdecho, " %s", lex___1->string);
          }
        }
      }
    }
#line 251
    if ((unsigned int )lex___1->class == 7U) {
#line 251
      retval = (cmd_retval )1;
    }
  }
#line 253
  return (retval);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static cmd_retval indcmd(bool silent ) 
{ 
  lex_struct *file ;
  char const   *rtnnme ;
  bool tmp ;
  bool tmp___0 ;

  {
  {
#line 272
  rtnnme = "indcmd";
#line 277
  file = dyio_scanstr(dy_cmdchn, (lexclass )5, 0, (char )'\"', (char )'\"');
  }
#line 278
  if ((unsigned int )file->class != 5U) {
    {
#line 279
    errmsg(236, rtnnme, "file name", "parameter", "@");
    }
#line 280
    return ((cmd_retval )1);
  }
  {
#line 284
  cmdchns[level].chn = dy_cmdchn;
#line 285
  cmdchns[level].cecho = dy_cmdecho;
#line 286
  cmdchns[level].gecho = dy_gtxecho;
#line 287
  cmdchns[level].prompt = prompt;
#line 288
  dy_cmdchn = dyio_openfile((char const   *)file->string, "r");
  }
#line 289
  if (dy_cmdchn < 0) {
#line 290
    dy_cmdchn = cmdchns[level].chn;
#line 291
    return ((cmd_retval )1);
  }
  {
#line 292
  dyio_setmode(dy_cmdchn, (char )'l');
#line 296
  dyio_outfmt(dy_logchn, dy_cmdecho, " \"%s\"\n", file->string);
#line 297
  dyio_outfmt(dy_logchn, dy_gtxecho, "\tcommand source file now %s\n", file->string);
#line 304
  level ++;
#line 305
  tmp = dyio_ttyq(dy_cmdchn);
  }
#line 305
  if ((int )tmp == 1) {
#line 306
    prompt = (bool )1;
  } else
#line 305
  if ((int )silent == 0) {
#line 306
    prompt = (bool )1;
  } else {
#line 308
    prompt = (bool )0;
  }
  {
#line 309
  tmp___0 = dyio_ttyq(dy_cmdchn);
  }
#line 309
  if ((int )tmp___0 == 0) {
#line 309
    if ((int )silent == 0) {
#line 310
      dy_cmdecho = (bool )1;
    } else {
#line 312
      dy_cmdecho = (bool )0;
    }
  } else {
#line 312
    dy_cmdecho = (bool )0;
  }
#line 314
  return ((cmd_retval )0);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
static cmd_retval dobuiltin(lex_struct *txt , bool silent ) 
{ 
  lex_struct *lex___1 ;
  cmd_retval retval ;
  char const   *rtnnme ;

  {
#line 335
  rtnnme = "dobuiltin";
#line 337
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
    {
#line 338
    errmsg(2, rtnnme, "txt");
    }
#line 339
    return ((cmd_retval )1);
  }
#line 340
  if ((unsigned int )txt->class != 3U) {
    {
#line 341
    errmsg(5, rtnnme, (int )txt->class);
    }
#line 342
    return ((cmd_retval )1);
  }
#line 346
  if ((int )*(txt->string) == 10) {
#line 346
    return ((cmd_retval )0);
  }
#line 348
  if ((int )*(txt->string) == 33) {
    {
#line 349
    dyio_outchr(dy_logchn, dy_cmdecho, (char )'!');
#line 350
    lex___1 = dyio_scanstr(dy_cmdchn, (lexclass )5, 0, (char )'\000', (char )'\n');
    }
#line 351
    if ((unsigned int )lex___1->class != 0U) {
      {
#line 352
      dyio_outfmt(dy_logchn, dy_gtxecho, " %s", lex___1->string);
      }
    }
#line 353
    return ((cmd_retval )0);
  }
#line 355
  if ((int )*(txt->string) != 64) {
    {
#line 356
    errmsg(230, rtnnme, txt->string);
    }
#line 357
    return ((cmd_retval )1);
  }
  {
#line 362
  retval = indcmd(silent);
  }
#line 364
  return (retval);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_cmdint.c"
cmd_retval process_cmds(bool silent ) 
{ 
  lex_struct *txt ;
  cmd_retval retval ;
  char const   *rtnnme ;
  bool tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 386
  rtnnme = "process_cmds";
#line 395
  level = 0;
#line 396
  txt = (lex_struct *)((void *)0);
#line 397
  retval = (cmd_retval )0;
#line 398
  tmp = dyio_ttyq(dy_cmdchn);
  }
#line 398
  if ((int )tmp == 1) {
#line 399
    prompt = (bool )1;
  } else
#line 398
  if ((int )silent == 0) {
#line 399
    prompt = (bool )1;
  } else {
#line 401
    prompt = (bool )0;
  }
  {
#line 402
  tmp___0 = dyio_ttyq(dy_cmdchn);
  }
#line 402
  if ((int )tmp___0 == 0) {
#line 402
    if ((int )silent == 0) {
#line 403
      dy_cmdecho = (bool )1;
    } else {
#line 405
      dy_cmdecho = (bool )0;
    }
  } else {
#line 405
    dy_cmdecho = (bool )0;
  }
#line 406
  dy_gtxecho = (bool )(! silent);
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! ((unsigned int )retval == 0U)) {
#line 412
      goto while_break;
    }
    {
#line 413
    dyio_outfmt(dy_logchn, prompt, "\n(%d)%% ", level);
#line 414
    retval = (cmd_retval )1;
#line 423
    txt = dyio_scanlex(dy_cmdchn);
    }
    {
#line 425
    if ((unsigned int )txt->class == 2U) {
#line 425
      goto case_2;
    }
#line 428
    if ((unsigned int )txt->class == 3U) {
#line 428
      goto case_3;
    }
#line 431
    if ((unsigned int )txt->class == 6U) {
#line 431
      goto case_6;
    }
#line 445
    if ((unsigned int )txt->class == 7U) {
#line 445
      goto case_7;
    }
#line 447
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 426
    retval = docmd(txt);
    }
#line 427
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 429
    retval = dobuiltin(txt, silent);
    }
#line 430
    goto switch_break;
    case_6: /* CIL Label */ 
#line 432
    if (level == 0) {
#line 433
      retval = (cmd_retval )2;
    } else {
      {
#line 435
      tmp___2 = dyio_closefile(dy_cmdchn);
      }
#line 435
      if ((int )tmp___2 == 0) {
        {
#line 436
        tmp___1 = dyio_idtopath(dy_cmdchn);
#line 436
        warn(232, rtnnme, tmp___1);
        }
      }
      {
#line 437
      level --;
#line 437
      dy_cmdchn = cmdchns[level].chn;
#line 438
      tmp___3 = dyio_idtopath(dy_cmdchn);
#line 438
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\treturning to command source file %s\n",
                  tmp___3);
#line 441
      dy_cmdecho = cmdchns[level].cecho;
#line 442
      dy_gtxecho = cmdchns[level].gecho;
#line 443
      retval = (cmd_retval )0;
      }
    }
#line 444
    goto switch_break;
    case_7: /* CIL Label */ 
#line 446
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 448
    if ((unsigned long )txt->string == (unsigned long )((void *)0)) {
#line 448
      tmp___4 = "<<nil>>";
    } else {
#line 448
      tmp___4 = (char const   *)txt->string;
    }
    {
#line 448
    errmsg(230, rtnnme, tmp___4);
    }
#line 449
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 450
    dyio_flushio(dy_logchn, dy_cmdecho);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  if ((unsigned int )retval == 1U) {
    {
#line 454
    errmsg(235, rtnnme);
    }
  }
#line 455
  if ((unsigned int )retval == 2U) {
#line 455
    if ((unsigned int )txt->class == 6U) {
#line 455
      retval = (cmd_retval )0;
    }
  }
#line 457
  return (retval);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_detach(consys_struct *consys , void **pvec , bool all ) ;
#line 1869 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
lpret_enum dyret2lpret(dyret_enum dyret ) ;
#line 112 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static bool forcesuperbasic(void) 
{ 
  int k ;
  int supercnt ;
  flags statk ;
  flags checks ;
  double valk ;
  double lbk ;
  double ubk ;
  int tmp ;
  dyret_enum tmp___0 ;

  {
#line 144
  supercnt = 0;
#line 145
  k = 1;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (k < dy_sys->varcnt)) {
#line 145
      goto while_break;
    }
#line 151
    if (*(dy_status + k) & (unsigned int )(1 << 9)) {
#line 151
      tmp = 1;
    } else {
#line 151
      tmp = 0;
    }
#line 151
    if (tmp) {
#line 152
      supercnt ++;
#line 153
      ubk = *(dy_sys->vub + k);
#line 154
      lbk = *(dy_sys->vlb + k);
#line 155
      statk = (flags )(1 << 9);
#line 156
      if (ubk < dy_tols->inf) {
#line 156
        if (lbk > - dy_tols->inf) {
#line 157
          if (*(dy_sys->obj + k) < (double )0) {
#line 158
            statk |= (unsigned int )(1 << 6);
#line 159
            valk = ubk;
          } else {
#line 161
            statk |= (unsigned int )(1 << 7);
#line 162
            valk = lbk;
          }
        } else {
#line 156
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 164
      if (ubk < dy_tols->inf) {
#line 165
        statk |= (unsigned int )(1 << 6);
#line 166
        valk = ubk;
      } else
#line 168
      if (lbk > - dy_tols->inf) {
#line 169
        statk |= (unsigned int )(1 << 7);
#line 170
        valk = lbk;
      } else {
#line 172
        statk |= (unsigned int )(1 << 8);
#line 173
        valk = (double )0;
      }
#line 174
      *(dy_status + k) ^= statk;
#line 175
      *(dy_x + k) = valk;
    }
#line 145
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (supercnt > 0) {
    {
#line 193
    checks = (flags )(1 | (1 << 2));
#line 194
    tmp___0 = dy_accchk(& checks);
    }
#line 194
    if ((int )tmp___0 != 1) {
#line 194
      return ((bool )0);
    }
  }
#line 196
  return ((bool )1);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static dyret_enum preoptimality(dyret_enum lpretval , flags *result ) 
{ 
  flags checkflags ;
  dyret_enum retval ;
  char const   *rtnnme ;
  int print ;
  char const   *tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  dyret_enum tmp___2 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 231
  rtnnme = "preoptimality";
#line 245
  if ((unsigned int )dy_lp->phase == 2U) {
#line 246
    print = dy_opts->print.phase1;
  } else {
#line 248
    print = dy_opts->print.phase2;
  }
#line 250
  if (print >= 4) {
    {
#line 251
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 251
    tmp___0 = dy_prtdyret(lpretval);
#line 251
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: validating %s at iteration (%s)%d.",
                rtnnme, tmp___0, tmp, dy_lp->tot.iters);
    }
  }
#line 269
  *result = (flags )0;
#line 270
  checkflags = (flags )0;
#line 271
  checkflags |= (unsigned int )(((((((1 << 8) | (1 << 1)) | 1) | (1 << 2)) | (1 << 4)) | (1 << 3)) | (1 << 5));
#line 273
  if ((int )lpretval == 7) {
#line 273
    if (dy_lp->basis.etas == 0) {
#line 274
      checkflags &= (unsigned int )(~ (1 << 8));
    }
  }
#line 280
  if (print >= 4) {
    {
#line 281
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tclearing pivot rejection and antidegeneracy machinery ... ");
    }
  }
  {
#line 284
  tmp___1 = dy_clrpivrej((int *)((void *)0));
  }
#line 284
  if ((int )tmp___1 != 1) {
#line 284
    return ((dyret_enum )-10);
  }
#line 285
  if (dy_lp->degen > 0) {
    {
#line 286
    tmp___2 = dy_degenout(0);
    }
#line 286
    if ((int )tmp___2 == 4) {
#line 286
      checkflags |= (unsigned int )(1 << 8);
    }
  }
#line 293
  if (print >= 4) {
#line 294
    if (checkflags & (unsigned int )(1 << 8)) {
#line 294
      tmp___5 = 1;
    } else {
#line 294
      tmp___5 = 0;
    }
#line 294
    if (tmp___5) {
#line 294
      tmp___4 = "refactoring and ";
    } else {
#line 294
      tmp___4 = "";
    }
    {
#line 294
    dyio_outfmt(dy_logchn, dy_gtxecho, "done.\n\t%schecking accuracy ... ", tmp___4);
    }
  }
  {
#line 297
  retval = dy_accchk(& checkflags);
#line 298
  *result = checkflags;
  }
#line 299
  if ((int )retval == 1) {
#line 299
    goto _L;
  } else
#line 299
  if ((int )retval == 2) {
    _L: /* CIL Label */ 
#line 307
    if (checkflags & (unsigned int )((1 << 1) | (1 << 4))) {
#line 307
      tmp___17 = 1;
    } else {
#line 307
      tmp___17 = 0;
    }
#line 307
    if (tmp___17) {
#line 310
      if (print >= 4) {
#line 311
        if (print >= 5) {
#line 311
          tmp___7 = "\n\t";
        } else {
#line 311
          tmp___7 = " ";
        }
        {
#line 311
        dyio_outfmt(dy_logchn, dy_gtxecho, "%sfailed", tmp___7);
        }
#line 312
        if (checkflags & (unsigned int )(1 << 1)) {
#line 312
          tmp___8 = 1;
        } else {
#line 312
          tmp___8 = 0;
        }
#line 312
        if (tmp___8) {
          {
#line 313
          dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
          }
        }
#line 314
        if (checkflags & (unsigned int )(1 << 4)) {
#line 314
          tmp___9 = 1;
        } else {
#line 314
          tmp___9 = 0;
        }
#line 314
        if (tmp___9) {
          {
#line 315
          dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
          }
        }
        {
#line 316
        dyio_outfmt(dy_logchn, dy_gtxecho, " check(s).");
        }
      }
#line 318
      retval = (dyret_enum )5;
    } else {
#line 320
      if (checkflags & (unsigned int )(1 | (1 << 3))) {
#line 320
        tmp___16 = 1;
      } else {
#line 320
        tmp___16 = 0;
      }
#line 320
      if (tmp___16) {
#line 323
        if (print >= 4) {
#line 324
          if (print >= 5) {
#line 324
            tmp___10 = "\n\t";
          } else {
#line 324
            tmp___10 = " ";
          }
          {
#line 324
          dyio_outfmt(dy_logchn, dy_gtxecho, "%slost", tmp___10);
          }
#line 325
          if (checkflags & (unsigned int )(1 << 1)) {
#line 325
            tmp___11 = 1;
          } else {
#line 325
            tmp___11 = 0;
          }
#line 325
          if (tmp___11) {
            {
#line 326
            dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
            }
          }
#line 327
          if (checkflags & (unsigned int )(1 << 4)) {
#line 327
            tmp___12 = 1;
          } else {
#line 327
            tmp___12 = 0;
          }
#line 327
          if (tmp___12) {
            {
#line 328
            dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
            }
          }
          {
#line 329
          dyio_outfmt(dy_logchn, dy_gtxecho, " feasibility.");
          }
        }
#line 331
        if (checkflags & 1U) {
#line 331
          tmp___13 = 1;
        } else {
#line 331
          tmp___13 = 0;
        }
#line 331
        if (tmp___13) {
#line 332
          retval = (dyret_enum )-4;
        } else {
#line 334
          retval = (dyret_enum )-3;
        }
      } else
#line 337
      if (print >= 4) {
#line 338
        if ((int )retval == 1) {
#line 338
          tmp___14 = "done";
        } else {
#line 338
          tmp___14 = "patched";
        }
#line 338
        if (print >= 5) {
#line 338
          tmp___15 = "\n\t";
        } else {
#line 338
          tmp___15 = " ";
        }
        {
#line 338
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s%s.", tmp___15, tmp___14);
        }
      }
    }
  } else {
#line 302
    if (print >= 4) {
#line 303
      if (print >= 5) {
#line 303
        tmp___6 = "\n\t";
      } else {
#line 303
        tmp___6 = " ";
      }
      {
#line 303
      dyio_outfmt(dy_logchn, dy_gtxecho, "%sfailed.", tmp___6);
      }
    }
#line 305
    return (retval);
  }
#line 342
  return (retval);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
bool dy_swapobjs(dyphase_enum phase ) 
{ 
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  void *tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  bool tmp___6 ;
  bool tmp___7 ;

  {
#line 375
  rtnnme = "dy_swapobjs";
#line 401
  if ((unsigned int )phase == 2U) {
#line 402
    if ((int )dy_lp->p1obj.installed == 1) {
#line 403
      if (dy_lp->infeascnt > dy_lp->p1obj.infvars_sze) {
        {
#line 404
        dy_lp->p1obj.infvars_sze = dy_lp->infeascnt;
#line 405
        tmp = realloc((void *)dy_lp->p1obj.infvars, (unsigned long )dy_lp->infeascnt * sizeof(int ));
#line 405
        dy_lp->p1obj.infvars = (int *)tmp;
        }
      }
    } else {
#line 408
      if ((unsigned long )dy_lp->p1obj.p1obj == (unsigned long )((void *)0)) {
        {
#line 409
        tmp___0 = malloc((unsigned long )dy_lp->infeascnt * sizeof(int ));
#line 409
        dy_lp->p1obj.infvars = (int *)tmp___0;
#line 410
        dy_lp->p1obj.infvars_sze = dy_lp->infeascnt;
#line 411
        dy_lp->p1obj.p1obj = (double *)((void *)0);
#line 412
        tmp___1 = consys_attach(dy_sys, 1U << 3, (int )sizeof(double ), (void **)(& dy_lp->p1obj.p1obj));
        }
#line 412
        if ((int )tmp___1 == 0) {
          {
#line 414
          errmsg(100, rtnnme, dy_sys->nme, "&dy_lp->p1obj.p1obj");
          }
#line 415
          return ((bool )0);
        }
        {
#line 416
        dy_lp->p1obj.p2obj = dy_sys->obj;
#line 417
        tmp___2 = consys_attach(dy_sys, 1U << 3, (int )sizeof(double ), (void **)(& dy_lp->p1obj.p2obj));
        }
#line 417
        if ((int )tmp___2 == 0) {
          {
#line 419
          errmsg(100, rtnnme, dy_sys->nme, "&dy_lp->p1obj.p2obj");
          }
#line 420
          return ((bool )0);
        }
      } else
#line 422
      if (dy_lp->infeascnt > dy_lp->p1obj.infvars_sze) {
        {
#line 423
        dy_lp->p1obj.infvars_sze = dy_lp->infeascnt;
#line 424
        tmp___3 = realloc((void *)dy_lp->p1obj.infvars, (unsigned long )dy_lp->infeascnt * sizeof(int ));
#line 424
        dy_lp->p1obj.infvars = (int *)tmp___3;
        }
      }
      {
#line 427
      tmp___4 = consys_detach(dy_sys, (void **)(& dy_sys->obj), (bool )0);
      }
#line 427
      if ((int )tmp___4 == 0) {
        {
#line 428
        errmsg(105, rtnnme, dy_sys->nme, "&dy_sys->obj (P2)");
        }
#line 429
        return ((bool )0);
      }
      {
#line 430
      dy_sys->obj = dy_lp->p1obj.p1obj;
#line 431
      tmp___5 = consys_attach(dy_sys, 1U << 3, (int )sizeof(double ), (void **)(& dy_sys->obj));
      }
#line 431
      if ((int )tmp___5 == 0) {
        {
#line 433
        errmsg(100, rtnnme, dy_sys->nme, "&dy_sys->obj (P1)");
        }
#line 434
        return ((bool )0);
      }
#line 435
      dy_lp->p1obj.installed = (bool )1;
    }
  } else
#line 442
  if ((unsigned int )phase == 3U) {
#line 443
    if ((int )dy_lp->p1obj.installed == 0) {
#line 443
      return ((bool )1);
    }
    {
#line 444
    tmp___6 = consys_detach(dy_sys, (void **)(& dy_sys->obj), (bool )0);
    }
#line 444
    if ((int )tmp___6 == 0) {
      {
#line 445
      errmsg(105, rtnnme, dy_sys->nme, "&dy_sys->obj (P1)");
      }
#line 446
      return ((bool )0);
    }
    {
#line 447
    dy_sys->obj = dy_lp->p1obj.p2obj;
#line 448
    tmp___7 = consys_attach(dy_sys, 1U << 3, (int )sizeof(double ), (void **)(& dy_sys->obj));
    }
#line 448
    if ((int )tmp___7 == 0) {
      {
#line 450
      errmsg(100, rtnnme, dy_sys->nme, "&dy_sys->obj (P2)");
      }
#line 451
      return ((bool )0);
    }
#line 452
    dy_lp->p1obj.installed = (bool )0;
  } else {
#line 459
    if ((unsigned long )dy_lp->p1obj.infvars != (unsigned long )((void *)0)) {
      {
#line 459
      free((void *)dy_lp->p1obj.infvars);
      }
    }
#line 460
    if ((int )dy_lp->p1obj.installed == 1) {
#line 461
      if ((unsigned long )dy_lp->p1obj.p2obj != (unsigned long )((void *)0)) {
        {
#line 461
        free((void *)dy_lp->p1obj.p2obj);
        }
      }
    } else
#line 463
    if ((unsigned long )dy_lp->p1obj.p1obj != (unsigned long )((void *)0)) {
      {
#line 463
      free((void *)dy_lp->p1obj.p1obj);
      }
    }
  }
#line 465
  return ((bool )1);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
bool dy_initp1obj(void) 
{ 
  int *infvars ;
  int infcnt ;
  int xipos ;
  int xindx ;
  double *p1obj ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  bool tmp___7 ;

  {
#line 488
  rtnnme = "dy_initp1obj";
#line 491
  if (dy_opts->print.phase1 >= 2) {
    {
#line 492
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    initialising phase 1 objective and reduced costs.");
    }
  }
  {
#line 503
  tmp___0 = dy_swapobjs((dyphase_enum )2);
  }
#line 503
  if ((int )tmp___0 == 0) {
    {
#line 504
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 504
    errmsg(318, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "install/resize");
    }
#line 506
    return ((bool )0);
  }
  {
#line 512
  infvars = dy_lp->p1obj.infvars;
#line 513
  p1obj = dy_lp->p1obj.p1obj;
#line 514
  infcnt = 0;
#line 515
  memset((void *)p1obj, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(double ));
#line 522
  xipos = 1;
  }
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 522
    if (! (xipos <= dy_sys->concnt)) {
#line 522
      goto while_break;
    }
#line 523
    xindx = *(dy_basis + xipos);
#line 524
    if (*(dy_status + xindx) & (unsigned int )((1 << 11) | (1 << 10))) {
#line 524
      tmp___1 = 0;
    } else {
#line 524
      tmp___1 = 1;
    }
#line 524
    if (tmp___1) {
#line 524
      goto __Cont;
    }
#line 525
    tmp___2 = infcnt;
#line 525
    infcnt ++;
#line 525
    *(infvars + tmp___2) = xindx;
#line 526
    if (*(dy_status + xindx) & (unsigned int )(1 << 11)) {
#line 526
      tmp___5 = 1;
    } else {
#line 526
      tmp___5 = 0;
    }
#line 526
    if (tmp___5) {
#line 527
      *(dy_sys->obj + xindx) = - 1.0;
#line 529
      if (dy_opts->print.phase1 >= 7) {
        {
#line 530
        tmp___3 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 530
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%16s (%3d) = %16.8g < lb = %16.8g, infeas = %16.8g",
                    tmp___3, xindx, *(dy_xbasic + xipos), *(dy_sys->vlb + xindx),
                    *(dy_sys->vlb + xindx) - *(dy_xbasic + xipos));
        }
      }
    } else {
#line 538
      *(dy_sys->obj + xindx) = 1.0;
#line 540
      if (dy_opts->print.phase1 >= 7) {
        {
#line 541
        tmp___4 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 541
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%16s (%3d) = %16.8g > ub = %16.8g, infeas = %16.8g",
                    tmp___4, xindx, *(dy_xbasic + xipos), *(dy_sys->vub + xindx),
                    *(dy_xbasic + xipos) - *(dy_sys->vub + xindx));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 522
    xipos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  dy_lp->p1obj.infcnt = infcnt;
#line 562
  if (dy_opts->print.phase1 >= 3) {
    {
#line 563
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      saw %d infeasible variables, tot. infeas. %g.",
                infcnt, dy_lp->infeas);
    }
  }
  {
#line 572
  dy_calcduals();
#line 573
  tmp___7 = dy_calccbar();
  }
#line 573
  if ((int )tmp___7 == 0) {
    {
#line 574
    tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 574
    errmsg(384, rtnnme, dy_sys->nme, tmp___6, dy_lp->tot.iters);
    }
#line 576
    return ((bool )0);
  }
  {
#line 577
  dy_lp->z = dy_calcobj();
  }
#line 580
  if (dy_opts->print.phase1 >= 5) {
    {
#line 581
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  recalculated duals and reduced costs.");
    }
  }
#line 598
  return ((bool )1);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static dyret_enum tweakp1obj(bool *reselect , int candxj ) 
{ 
  int *infvars ;
  int ndx ;
  int maxndx ;
  int newfeas ;
  int xkndx ;
  flags statk ;
  bool recalccbar ;
  char const   *rtnnme ;
  int xkpos ;
  double infeas ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  bool tmp___10 ;

  {
#line 644
  rtnnme = "tweakp1obj";
#line 655
  infeas = (double )0;
#line 656
  if (dy_opts->print.phase1 >= 5) {
    {
#line 657
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  checking feasibility & tweaking phase 1 objective.");
    }
  }
#line 678
  newfeas = 0;
#line 679
  maxndx = dy_lp->p1obj.infcnt - 1;
#line 680
  *reselect = (bool )0;
#line 681
  recalccbar = (bool )0;
#line 682
  infvars = dy_lp->p1obj.infvars;
#line 683
  ndx = 0;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! (ndx <= maxndx)) {
#line 683
      goto while_break;
    }
#line 684
    xkndx = *(infvars + ndx);
#line 685
    statk = *(dy_status + xkndx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 687
    if (dy_opts->print.phase1 >= 5) {
#line 687
      if (statk & (unsigned int )((1 << 11) | (1 << 10))) {
#line 687
        tmp___2 = 1;
      } else {
#line 687
        tmp___2 = 0;
      }
#line 687
      if (tmp___2) {
#line 688
        xkpos = *(dy_var2basis + xkndx);
#line 689
        if (dy_opts->print.phase1 >= 7) {
          {
#line 690
          tmp = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 690
          tmp___0 = dy_prtvstat(statk);
#line 690
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    %4s %16s (%3d) = %16.8g", tmp___0,
                      tmp, xkndx, *(dy_xbasic + xkpos));
          }
        }
#line 693
        if (statk & (unsigned int )(1 << 11)) {
#line 693
          tmp___1 = 1;
        } else {
#line 693
          tmp___1 = 0;
        }
#line 693
        if (tmp___1) {
#line 694
          infeas += *(dy_sys->vlb + xkndx) - *(dy_xbasic + xkpos);
#line 695
          if (dy_opts->print.phase1 >= 7) {
            {
#line 696
            dyio_outfmt(dy_logchn, dy_gtxecho, " < lb = %16.8g, inf = %16.8g", *(dy_sys->vlb + xkndx),
                        *(dy_sys->vlb + xkndx) - *(dy_xbasic + xkpos));
            }
          }
        } else {
#line 700
          infeas += *(dy_xbasic + xkpos) - *(dy_sys->vub + xkndx);
#line 701
          if (dy_opts->print.phase1 >= 7) {
            {
#line 702
            dyio_outfmt(dy_logchn, dy_gtxecho, " > ub = %16.8g, inf = %16.8g", *(dy_sys->vub + xkndx),
                        *(dy_xbasic + xkpos) - *(dy_sys->vub + xkndx));
            }
          }
        }
      }
    }
#line 706
    if (statk & (unsigned int )(1 << 11)) {
#line 706
      tmp___7 = 1;
    } else {
#line 706
      tmp___7 = 0;
    }
#line 706
    if (tmp___7) {
#line 707
      ndx ++;
#line 708
      if (*(dy_sys->obj + xkndx) != - 1.0) {
#line 709
        *(dy_sys->obj + xkndx) = - 1.0;
#line 710
        recalccbar = (bool )1;
      }
    } else {
#line 712
      if (statk & (unsigned int )(1 << 10)) {
#line 712
        tmp___6 = 1;
      } else {
#line 712
        tmp___6 = 0;
      }
#line 712
      if (tmp___6) {
#line 713
        ndx ++;
#line 714
        if (*(dy_sys->obj + xkndx) != 1.0) {
#line 715
          *(dy_sys->obj + xkndx) = 1.0;
#line 716
          recalccbar = (bool )1;
        }
      } else {
#line 718
        newfeas ++;
#line 719
        tmp___3 = maxndx;
#line 719
        maxndx --;
#line 719
        *(infvars + ndx) = *(infvars + tmp___3);
#line 720
        if (statk & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 720
          tmp___5 = 1;
        } else {
#line 720
          tmp___5 = 0;
        }
#line 720
        if (tmp___5) {
          {
#line 721
          *(dy_cbar + xkndx) -= *(dy_sys->obj + xkndx);
#line 722
          tmp___4 = fabs(*(dy_cbar + xkndx));
          }
#line 722
          if (tmp___4 < dy_tols->zero) {
#line 722
            *(dy_cbar + xkndx) = (double )0;
          }
#line 723
          dy_lp->z -= *(dy_sys->obj + xkndx) * *(dy_x + xkndx);
#line 724
          if (xkndx == candxj) {
#line 724
            *reselect = (bool )1;
          }
        } else {
#line 726
          recalccbar = (bool )1;
        }
#line 727
        *(dy_sys->obj + xkndx) = 0.0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 728
  dy_lp->p1obj.infcnt = maxndx + 1;
#line 731
  if (dy_opts->print.phase1 >= 5) {
    {
#line 732
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t  saw %d infeasible variables, down %d, tot. infeas. %g.",
                dy_lp->p1obj.infcnt, newfeas, infeas);
    }
  }
#line 735
  if (dy_opts->print.phase1 >= 2) {
#line 735
    if ((int )*reselect == 1) {
      {
#line 736
      tmp___8 = consys_nme(dy_sys, (char )'v', candxj, (bool )0, (char *)((void *)0));
#line 736
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    reselect; newly feasible %s (%d) selected to enter.",
                  tmp___8, candxj);
      }
    }
  }
#line 788
  if (dy_lp->p1obj.infcnt == 0) {
    {
#line 789
    memset((void *)dy_y, 0, (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 790
    memset((void *)dy_cbar, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(double ));
    }
#line 791
    return ((dyret_enum )7);
  }
#line 796
  if ((int )recalccbar == 1) {
    {
#line 797
    dy_calcduals();
#line 798
    tmp___10 = dy_calccbar();
    }
#line 798
    if ((int )tmp___10 == 0) {
      {
#line 799
      tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 799
      errmsg(384, rtnnme, dy_sys->nme, tmp___9, dy_lp->tot.iters);
      }
#line 801
      return ((dyret_enum )-10);
    }
    {
#line 802
    dy_lp->z = dy_calcobj();
#line 803
    *reselect = (bool )1;
    }
#line 805
    if (dy_opts->print.phase1 >= 5) {
      {
#line 806
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trecalculated duals and reduced costs.",
                  maxndx, infeas);
      }
    }
  }
#line 814
  return ((dyret_enum )10);
}
}
#line 818 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static dyret_enum verifyp1obj(void) 
{ 
  int *infvars ;
  int ndx ;
  int xkndx ;
  double ck ;
  flags statk ;
  flags checks ;
  dyret_enum retval ;
  bool err ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;

  {
  {
#line 852
  retval = (dyret_enum )0;
#line 858
  checks = (flags )0;
#line 859
  checks |= (unsigned int )(1 | (1 << 2));
#line 860
  retval = dy_accchk(& checks);
  }
#line 861
  if ((int )retval != 1) {
#line 861
    return (retval);
  }
#line 871
  if (dy_lp->p1obj.infcnt != dy_lp->infeascnt) {
#line 872
    retval = (dyret_enum )3;
  } else {
#line 874
    retval = (dyret_enum )1;
#line 875
    err = (bool )0;
#line 876
    infvars = dy_lp->p1obj.infvars;
#line 877
    ndx = 0;
    {
#line 877
    while (1) {
      while_continue: /* CIL Label */ ;
#line 877
      if (! (ndx < dy_lp->p1obj.infcnt)) {
#line 877
        goto while_break;
      }
#line 878
      xkndx = *(infvars + ndx);
#line 879
      statk = *(dy_status + xkndx) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 880
      ck = *(dy_sys->obj + xkndx);
      {
#line 882
      if (statk == (flags )(1 << 11)) {
#line 882
        goto case_exp;
      }
#line 885
      if (statk == (flags )(1 << 10)) {
#line 885
        goto case_exp___0;
      }
#line 888
      goto switch_default;
      case_exp: /* CIL Label */ 
#line 883
      if (ck != - 1.0) {
#line 883
        err = (bool )1;
      }
#line 884
      goto switch_break;
      case_exp___0: /* CIL Label */ 
#line 886
      if (ck != 1.0) {
#line 886
        err = (bool )1;
      }
#line 887
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 889
      err = (bool )1;
#line 890
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 891
      if ((int )err == 1) {
#line 892
        retval = (dyret_enum )3;
#line 896
        err = (bool )0;
#line 897
        if (dy_opts->print.phase1 >= 5) {
          {
#line 898
          tmp = consys_nme(dy_sys, (char )'v', xkndx, (bool )0, (char *)((void *)0));
#line 898
          tmp___0 = dy_prtvstat(statk);
#line 898
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tphase I c<%d> = %g inconsistent for %s %s (%d) = %g;",
                      xkndx, *(dy_sys->obj + xkndx), tmp___0, tmp, xkndx, *(dy_x + xkndx));
#line 902
          dyio_outfmt(dy_logchn, dy_gtxecho, " lb = %g, ub = %g", *(dy_sys->vlb + xkndx),
                      *(dy_sys->vub + xkndx));
#line 904
          tmp___5 = fabs(*(dy_sys->vub + xkndx));
          }
#line 904
          if (tmp___5 < dy_tols->inf) {
            {
#line 904
            tmp___3 = fabs(*(dy_sys->vub + xkndx));
#line 904
            tmp___4 = *(dy_x + xkndx) - *(dy_sys->vub + xkndx) > dy_tols->pfeas * (1.0 + tmp___3);
            }
          } else {
#line 904
            tmp___4 = *(dy_x + xkndx) > *(dy_sys->vub + xkndx);
          }
#line 904
          if (tmp___4) {
            _L: /* CIL Label */ 
#line 905
            if (statk & (unsigned int )(1 << 11)) {
#line 905
              tmp___1 = 1;
            } else {
#line 905
              tmp___1 = 0;
            }
#line 905
            if (tmp___1) {
              {
#line 906
              dyio_outfmt(dy_logchn, dy_gtxecho, ", infeas = %g.", *(dy_sys->vlb + xkndx) - *(dy_x + xkndx));
              }
            } else {
              {
#line 909
              dyio_outfmt(dy_logchn, dy_gtxecho, ", infeas = %g.", *(dy_x + xkndx) - *(dy_sys->vub + xkndx));
              }
            }
          } else {
            {
#line 904
            tmp___9 = fabs(*(dy_sys->vlb + xkndx));
            }
#line 904
            if (tmp___9 < dy_tols->inf) {
              {
#line 904
              tmp___7 = fabs(*(dy_sys->vlb + xkndx));
#line 904
              tmp___8 = *(dy_sys->vlb + xkndx) - *(dy_x + xkndx) > dy_tols->pfeas * (1.0 + tmp___7);
              }
            } else {
#line 904
              tmp___8 = *(dy_x + xkndx) < *(dy_sys->vlb + xkndx);
            }
#line 904
            if (tmp___8) {
#line 904
              goto _L;
            } else {
              {
#line 912
              dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
              }
            }
          }
        }
      }
#line 877
      ndx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 922
  if ((int )retval == 3) {
    {
#line 923
    dy_setpivparms(1, 1);
#line 924
    checks = (flags )0;
#line 925
    checks |= (unsigned int )(((1 << 8) | 1) | (1 << 2));
#line 926
    retval = dy_accchk(& checks);
    }
#line 927
    if ((int )retval == 1) {
#line 927
      retval = (dyret_enum )3;
    } else
#line 927
    if ((int )retval == 2) {
#line 927
      retval = (dyret_enum )3;
    }
  }
#line 929
  return (retval);
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static dyret_enum primal1(void) 
{ 
  dyret_enum lpretval ;
  dyret_enum scanresult ;
  dyret_enum pivresult ;
  dyret_enum duennaresult ;
  dyret_enum preopresult ;
  dyret_enum p1objresult ;
  int startcol ;
  int scan ;
  int nextcol ;
  int candxj ;
  int xjndx ;
  int indir ;
  int xindx ;
  int outdir ;
  int optcnt ;
  double cbarj ;
  double abarij ;
  double delta ;
  bool do_pivots ;
  bool reselect ;
  flags xjstatus ;
  flags checks ;
  char const   *rtnnme ;
  bool uxpfeas ;
  bool uxnpfeas ;
  bool uxdfeas ;
  bool uxndfeas ;
  dyret_enum tmpretval ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  bool tmp___22 ;
  char const   *tmp___23 ;
  bool tmp___24 ;
  char const   *tmp___25 ;
  bool tmp___26 ;
  char const   *tmp___27 ;

  {
  {
#line 988
  rtnnme = "primal1";
#line 1010
  dy_lp->p1.pivs = 0;
#line 1011
  dy_lp->pivok = (bool )0;
#line 1012
  dy_lp->prev_pivok = (bool )0;
#line 1013
  lpretval = (dyret_enum )0;
#line 1014
  tmp = dy_clrpivrej((int *)((void *)0));
  }
#line 1014
  if ((int )tmp != 1) {
#line 1014
    return ((dyret_enum )-10);
  }
#line 1018
  if ((int )dy_lp->p1obj.installed == 0) {
    {
#line 1019
    tmp___1 = dy_initp1obj();
    }
#line 1019
    if ((int )tmp___1 == 0) {
      {
#line 1020
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1020
      errmsg(318, rtnnme, dy_sys->nme, tmp___0, dy_lp->tot.iters, "initialise");
      }
#line 1022
      return ((dyret_enum )-10);
    }
  }
#line 1030
  scan = dy_opts->scan;
#line 1031
  nextcol = 1;
#line 1032
  optcnt = 0;
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    if (! ((int )lpretval == 0)) {
#line 1033
      goto while_break;
    }
    {
#line 1043
    startcol = nextcol;
#line 1044
    scanresult = dy_primalin(startcol, scan, & candxj, & nextcol);
    }
    {
#line 1046
    if ((int )scanresult == 1) {
#line 1046
      goto case_1;
    }
#line 1049
    if ((int )scanresult == 6) {
#line 1049
      goto case_6;
    }
#line 1057
    if ((int )scanresult == 7) {
#line 1057
      goto case_7;
    }
#line 1061
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1047
    do_pivots = (bool )1;
#line 1048
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1050
    scanresult = dy_dealWithPunt();
    }
#line 1051
    if ((int )scanresult == 3) {
#line 1052
      goto while_continue;
    } else {
#line 1054
      do_pivots = (bool )0;
#line 1055
      lpretval = scanresult;
    }
#line 1056
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1058
    do_pivots = (bool )0;
#line 1059
    lpretval = (dyret_enum )10;
#line 1060
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1062
    do_pivots = (bool )0;
#line 1063
    lpretval = scanresult;
#line 1064
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1082
    xjndx = candxj;
    {
#line 1082
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1082
      if (! ((int )do_pivots == 1)) {
#line 1082
        goto while_break___0;
      }
#line 1090
      indir = 0;
#line 1091
      xjstatus = *(dy_status + xjndx);
#line 1092
      cbarj = *(dy_cbar + xjndx);
#line 1093
      if (cbarj <= (double )0) {
#line 1093
        if (xjstatus & (unsigned int )(((1 << 7) | (1 << 9)) | (1 << 8))) {
#line 1093
          tmp___3 = 1;
        } else {
#line 1093
          tmp___3 = 0;
        }
#line 1093
        if (tmp___3) {
#line 1094
          indir = 1;
        } else {
#line 1093
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1096
      if (cbarj > (double )0) {
#line 1096
        if (xjstatus & (unsigned int )(((1 << 6) | (1 << 9)) | (1 << 8))) {
#line 1096
          tmp___2 = 1;
        } else {
#line 1096
          tmp___2 = 0;
        }
#line 1096
        if (tmp___2) {
#line 1097
          indir = -1;
        }
      }
#line 1104
      if (dy_opts->print.pricing >= 2) {
        {
#line 1105
        tmp___4 = sqrt(*(dy_gamma + xjndx));
#line 1105
        tmp___5 = dy_prtvstat(xjstatus);
        }
#line 1105
        if (indir < 0) {
#line 1105
          tmp___6 = "decreasing";
        } else {
#line 1105
          tmp___6 = "increasing";
        }
        {
#line 1105
        tmp___7 = consys_nme(dy_sys, (char )'v', xjndx, (bool )1, (char *)((void *)0));
#line 1105
        tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1105
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %s (%d), entering %s from %s, price = %g ... ",
                    tmp___8, dy_lp->tot.iters, tmp___7, xjndx, tmp___6, tmp___5, cbarj / tmp___4);
        }
      }
      {
#line 1123
      pivresult = dy_primalpivot(xjndx, indir, & xindx, & outdir, & abarij, & delta,
                                 & candxj);
      }
#line 1126
      if (dy_opts->print.phase1 >= 4) {
        {
#line 1127
        dy_logpivot(pivresult, xjndx, indir, cbarj, xindx, outdir, abarij, delta);
        }
      }
      {
#line 1176
      duennaresult = dy_duenna(pivresult, xjndx, xindx, candxj, -1);
      }
      {
#line 1180
      if ((int )duennaresult == 6) {
#line 1180
        goto case_6___0;
      }
#line 1180
      if ((int )duennaresult == 7) {
#line 1180
        goto case_6___0;
      }
#line 1180
      if ((int )duennaresult == 1) {
#line 1180
        goto case_6___0;
      }
#line 1210
      if ((int )duennaresult == 3) {
#line 1210
        goto case_3;
      }
#line 1213
      if ((int )duennaresult == 8) {
#line 1213
        goto case_8;
      }
#line 1219
      if ((int )duennaresult == 9) {
#line 1219
        goto case_9;
      }
#line 1230
      if ((int )duennaresult == -10) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == -5) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == -9) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == -8) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == -7) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == -6) {
#line 1230
        goto case_neg_10___0;
      }
#line 1230
      if ((int )duennaresult == 5) {
#line 1230
        goto case_neg_10___0;
      }
#line 1234
      goto switch_default___1;
      case_6___0: /* CIL Label */ 
      case_7___0: /* CIL Label */ 
      case_1___0: /* CIL Label */ 
      {
#line 1181
      p1objresult = tweakp1obj(& reselect, candxj);
      }
      {
#line 1183
      if ((int )p1objresult == 10) {
#line 1183
        goto case_10;
      }
#line 1194
      if ((int )p1objresult == 7) {
#line 1194
        goto case_7___1;
      }
#line 1198
      if ((int )p1objresult == -10) {
#line 1198
        goto case_neg_10;
      }
#line 1204
      goto switch_default___0;
      case_10: /* CIL Label */ 
#line 1184
      if ((int )duennaresult == 1) {
#line 1185
        if (candxj <= 0) {
#line 1185
          reselect = (bool )1;
        }
#line 1186
        if ((int )reselect == 1) {
#line 1186
          do_pivots = (bool )0;
        } else
#line 1186
        if (xindx == xjndx) {
#line 1186
          do_pivots = (bool )0;
        }
      } else {
#line 1188
        do_pivots = (bool )0;
#line 1189
        if ((int )duennaresult == 6) {
#line 1190
          lpretval = (dyret_enum )6;
        } else {
#line 1192
          lpretval = (dyret_enum )10;
        }
      }
#line 1193
      goto switch_break___1;
      case_7___1: /* CIL Label */ 
#line 1195
      lpretval = (dyret_enum )7;
#line 1196
      do_pivots = (bool )0;
#line 1197
      goto switch_break___1;
      case_neg_10: /* CIL Label */ 
      {
#line 1199
      tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1199
      errmsg(318, rtnnme, dy_sys->nme, tmp___9, dy_lp->tot.iters, "tweak");
#line 1201
      do_pivots = (bool )0;
#line 1202
      lpretval = p1objresult;
      }
#line 1203
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 1205
      errmsg(7, rtnnme, 1205, "tweakp1obj code", (int )p1objresult);
#line 1206
      do_pivots = (bool )0;
#line 1207
      lpretval = p1objresult;
      }
#line 1208
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 1209
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 1211
      do_pivots = (bool )0;
#line 1212
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 1214
      do_pivots = (bool )0;
#line 1215
      lpretval = duennaresult;
#line 1216
      dy_lp->ubnd.ndx = xjndx * indir;
#line 1217
      dy_lp->ubnd.ratio = (double )0;
#line 1218
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 1220
      if (dy_lp->basis.pivs >= 10) {
#line 1221
        lpretval = duennaresult;
#line 1222
        do_pivots = (bool )0;
      }
#line 1223
      goto switch_break___0;
      case_neg_10___0: /* CIL Label */ 
      case_neg_5: /* CIL Label */ 
      case_neg_9: /* CIL Label */ 
      case_neg_8: /* CIL Label */ 
      case_neg_7: /* CIL Label */ 
      case_neg_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 1231
      do_pivots = (bool )0;
#line 1232
      lpretval = duennaresult;
#line 1233
      goto switch_break___0;
      switch_default___1: /* CIL Label */ 
      {
#line 1235
      errmsg(7, rtnnme, 1235, "La Duenna return code", (int )duennaresult);
#line 1237
      do_pivots = (bool )0;
#line 1238
      lpretval = (dyret_enum )-10;
      }
#line 1239
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1082
      xjndx = candxj;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1244
    if ((int )lpretval == 0) {
#line 1244
      goto while_continue;
    }
#line 1259
    if ((int )lpretval == 7) {
#line 1259
      goto _L___0;
    } else
#line 1259
    if ((int )lpretval == 10) {
#line 1259
      goto _L___0;
    } else
#line 1259
    if ((int )lpretval == 8) {
#line 1259
      goto _L___0;
    } else
#line 1259
    if ((int )lpretval == 6) {
      _L___0: /* CIL Label */ 
      {
#line 1261
      p1objresult = verifyp1obj();
      }
      {
#line 1263
      if ((int )p1objresult == 1) {
#line 1263
        goto case_1___1;
      }
#line 1265
      if ((int )p1objresult == 3) {
#line 1265
        goto case_3___0;
      }
#line 1283
      goto switch_default___2;
      case_1___1: /* CIL Label */ 
#line 1264
      goto switch_break___2;
      case_3___0: /* CIL Label */ 
#line 1268
      if (dy_opts->print.phase1 >= 1) {
        {
#line 1269
        tmp___10 = dy_prtdyret(lpretval);
#line 1269
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tfalse termination (%s) due to inconsistent objective",
                    tmp___10);
#line 1272
        tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1272
        dyio_outfmt(dy_logchn, dy_gtxecho, " at (%s)%d; rebuilding P1 objective.",
                    tmp___11, dy_lp->tot.iters);
        }
      }
      {
#line 1276
      tmp___12 = dy_initp1obj();
      }
#line 1276
      if ((int )tmp___12 == 1) {
#line 1277
        lpretval = (dyret_enum )0;
#line 1278
        goto while_continue;
      }
      {
#line 1279
      tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1279
      errmsg(318, rtnnme, dy_sys->nme, tmp___13, dy_lp->tot.iters, "reinitialise");
#line 1281
      p1objresult = (dyret_enum )-10;
      }
#line 1282
      goto switch_break___2;
      switch_default___2: /* CIL Label */ 
#line 1284
      p1objresult = (dyret_enum )-10;
#line 1285
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 1286
      if ((int )p1objresult == -10) {
#line 1286
        return ((dyret_enum )-10);
      }
    }
#line 1315
    if ((int )lpretval == 7) {
#line 1315
      goto _L___1;
    } else
#line 1315
    if ((int )lpretval == 8) {
#line 1315
      goto _L___1;
    } else
#line 1315
    if ((int )lpretval == 10) {
#line 1315
      goto _L___1;
    } else
#line 1315
    if ((int )lpretval == 6) {
      _L___1: /* CIL Label */ 
      {
#line 1317
      optcnt ++;
#line 1319
      uxpfeas = (bool )0;
#line 1320
      uxnpfeas = (bool )0;
#line 1321
      uxdfeas = (bool )0;
#line 1322
      uxndfeas = (bool )0;
#line 1323
      tmpretval = lpretval;
#line 1325
      preopresult = preoptimality(lpretval, & checks);
      }
      {
#line 1329
      if ((int )preopresult == -3) {
#line 1329
        goto case_neg_3;
      }
#line 1329
      if ((int )preopresult == 2) {
#line 1329
        goto case_neg_3;
      }
#line 1329
      if ((int )preopresult == 1) {
#line 1329
        goto case_neg_3;
      }
#line 1343
      if ((int )preopresult == -4) {
#line 1343
        goto case_neg_4;
      }
#line 1371
      goto switch_default___3;
      case_neg_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_1___2: /* CIL Label */ 
#line 1332
      if ((int )lpretval == 10) {
#line 1334
        uxpfeas = (bool )1;
      } else
#line 1332
      if ((int )lpretval == 6) {
#line 1334
        uxpfeas = (bool )1;
      } else
#line 1332
      if ((int )lpretval == 8) {
#line 1334
        uxpfeas = (bool )1;
      }
#line 1335
      if ((int )preopresult == -3) {
#line 1336
        if ((int )lpretval == 10) {
#line 1336
          uxndfeas = (bool )1;
        }
      } else
#line 1338
      if ((int )lpretval == 6) {
#line 1339
        uxdfeas = (bool )1;
      } else
#line 1338
      if ((int )lpretval == 8) {
#line 1339
        uxdfeas = (bool )1;
      }
#line 1341
      lpretval = (dyret_enum )7;
#line 1342
      goto switch_break___3;
      case_neg_4: /* CIL Label */ 
#line 1346
      if ((int )lpretval == 7) {
#line 1346
        uxnpfeas = (bool )1;
      }
#line 1348
      if (checks & (unsigned int )(1 << 3)) {
#line 1348
        tmp___14 = 0;
      } else {
#line 1348
        tmp___14 = 1;
      }
#line 1348
      if (tmp___14) {
#line 1351
        if ((int )lpretval == 8) {
#line 1352
          uxdfeas = (bool )1;
        } else
#line 1351
        if ((int )lpretval == 6) {
#line 1352
          uxdfeas = (bool )1;
        }
#line 1354
        if ((int )lpretval == 10) {
#line 1358
          lpretval = (dyret_enum )10;
        } else
#line 1354
        if ((int )lpretval == 6) {
#line 1358
          lpretval = (dyret_enum )10;
        } else {
          {
#line 1355
          dy_setpivparms(1, 1);
#line 1356
          lpretval = (dyret_enum )0;
          }
        }
      } else
#line 1360
      if (! ((int )lpretval == 8)) {
#line 1360
        if (! ((int )lpretval == 6)) {
#line 1365
          if ((int )lpretval == 10) {
#line 1366
            uxndfeas = (bool )1;
          }
          {
#line 1368
          dy_setpivparms(1, 1);
#line 1369
          lpretval = (dyret_enum )0;
          }
        }
      }
#line 1370
      goto switch_break___3;
      switch_default___3: /* CIL Label */ 
#line 1372
      lpretval = preopresult;
#line 1373
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 1384
      if (dy_opts->print.phase1 >= 2) {
#line 1385
        if ((int )uxpfeas == 1) {
          {
#line 1386
          tmp___15 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1386
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected primal feasibility at iteration (%s)%d.",
                      tmp___15, dy_lp->tot.iters);
          }
        }
#line 1389
        if ((int )uxnpfeas == 1) {
          {
#line 1390
          tmp___16 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1390
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of primal feasibility at iteration (%s)%d.",
                      tmp___16, dy_lp->tot.iters);
          }
        }
#line 1393
        if ((int )uxdfeas == 1) {
          {
#line 1394
          tmp___17 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1394
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected dual feasibility at iteration (%s)%d.",
                      tmp___17, dy_lp->tot.iters);
          }
        }
#line 1397
        if ((int )uxndfeas == 1) {
          {
#line 1398
          tmp___18 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1398
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of dual feasibility at iteration (%s)%d.",
                      tmp___18, dy_lp->tot.iters);
          }
        }
      }
#line 1403
      if ((int )lpretval == 0) {
#line 1404
        if (optcnt > 15) {
          {
#line 1405
          tmp___19 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1405
          errmsg(387, rtnnme, dy_sys->nme, tmp___19, dy_lp->tot.iters, optcnt);
#line 1407
          lpretval = (dyret_enum )-10;
          }
        } else
#line 1410
        if (dy_opts->print.phase1 >= 2) {
          {
#line 1411
          tmp___20 = dy_prtdyret(tmpretval);
#line 1411
          tmp___21 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1411
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t(%s)%d: false termination (%s); resuming pivoting.",
                      tmp___21, dy_lp->tot.iters, tmp___20);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1428
  tmp___22 = dy_clrpivrej((int *)((void *)0));
  }
#line 1428
  if ((int )tmp___22 != 1) {
#line 1428
    lpretval = (dyret_enum )-10;
  }
#line 1429
  if (dy_lp->degen > 0) {
    {
#line 1429
    dy_degenout(0);
    }
  }
#line 1431
  if ((int )lpretval == 7) {
    {
#line 1432
    tmp___24 = dy_swapobjs((dyphase_enum )3);
    }
#line 1432
    if ((int )tmp___24 == 0) {
      {
#line 1433
      tmp___23 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1433
      errmsg(318, rtnnme, dy_sys->nme, tmp___23, dy_lp->tot.iters, "remove");
      }
#line 1435
      return ((dyret_enum )-10);
    }
    {
#line 1436
    dy_calcduals();
#line 1437
    tmp___26 = dy_calccbar();
    }
#line 1437
    if ((int )tmp___26 == 0) {
      {
#line 1438
      tmp___25 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1438
      errmsg(384, rtnnme, dy_sys->nme, tmp___25, dy_lp->tot.iters);
      }
#line 1440
      return ((dyret_enum )-10);
    }
    {
#line 1441
    dy_lp->z = dy_calcobj();
#line 1442
    dy_pseinit();
    }
  }
#line 1445
  if ((int )lpretval == 8) {
#line 1445
    if (dy_opts->print.phase1 >= 2) {
      {
#line 1446
      tmp___27 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1446
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    [%s] (%s)%d: system is unbounded.",
                  dy_sys->nme, tmp___27, dy_lp->tot.iters);
      }
    }
  }
#line 1457
  return (lpretval);
}
}
#line 1461 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
static dyret_enum primal2(void) 
{ 
  dyret_enum lpretval ;
  dyret_enum scanresult ;
  dyret_enum pivresult ;
  dyret_enum duennaresult ;
  dyret_enum preopresult ;
  int startcol ;
  int scan ;
  int nextcol ;
  int candxj ;
  int xjndx ;
  int indir ;
  int xindx ;
  int outdir ;
  int optcnt ;
  double cbarj ;
  double abarij ;
  double delta ;
  bool do_pivots ;
  flags xjstatus ;
  flags checks ;
  char const   *rtnnme ;
  bool uxnpfeas ;
  bool uxdfeas ;
  bool uxndfeas ;
  dyret_enum tmpretval ;
  bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  bool tmp___15 ;

  {
  {
#line 1501
  rtnnme = "primal2";
#line 1517
  dy_lp->p2.pivs = 0;
#line 1518
  dy_lp->pivok = (bool )0;
#line 1519
  dy_lp->prev_pivok = (bool )0;
#line 1520
  lpretval = (dyret_enum )0;
#line 1528
  tmp = dy_clrpivrej((int *)((void *)0));
  }
#line 1528
  if ((int )tmp != 1) {
#line 1528
    return ((dyret_enum )-10);
  }
#line 1529
  optcnt = 0;
#line 1530
  scan = dy_opts->scan;
#line 1531
  nextcol = 1;
  {
#line 1532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1532
    if (! ((int )lpretval == 0)) {
#line 1532
      goto while_break;
    }
    {
#line 1541
    startcol = nextcol;
#line 1542
    scanresult = dy_primalin(startcol, scan, & candxj, & nextcol);
    }
    {
#line 1544
    if ((int )scanresult == 1) {
#line 1544
      goto case_1;
    }
#line 1547
    if ((int )scanresult == 6) {
#line 1547
      goto case_6;
    }
#line 1555
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1545
    do_pivots = (bool )1;
#line 1546
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1548
    scanresult = dy_dealWithPunt();
    }
#line 1549
    if ((int )scanresult == 3) {
#line 1550
      goto while_continue;
    } else {
#line 1552
      do_pivots = (bool )0;
#line 1553
      lpretval = scanresult;
    }
#line 1554
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1556
    do_pivots = (bool )0;
#line 1557
    lpretval = scanresult;
#line 1558
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1576
    xjndx = candxj;
    {
#line 1576
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1576
      if (! ((int )do_pivots == 1)) {
#line 1576
        goto while_break___0;
      }
#line 1584
      indir = 0;
#line 1585
      xjstatus = *(dy_status + xjndx);
#line 1586
      cbarj = *(dy_cbar + xjndx);
#line 1587
      if (cbarj <= (double )0) {
#line 1587
        if (xjstatus & (unsigned int )(((1 << 7) | (1 << 9)) | (1 << 8))) {
#line 1587
          tmp___1 = 1;
        } else {
#line 1587
          tmp___1 = 0;
        }
#line 1587
        if (tmp___1) {
#line 1588
          indir = 1;
        } else {
#line 1587
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1590
      if (cbarj > (double )0) {
#line 1590
        if (xjstatus & (unsigned int )(((1 << 6) | (1 << 9)) | (1 << 8))) {
#line 1590
          tmp___0 = 1;
        } else {
#line 1590
          tmp___0 = 0;
        }
#line 1590
        if (tmp___0) {
#line 1591
          indir = -1;
        }
      }
#line 1598
      if (dy_opts->print.pricing >= 2) {
        {
#line 1599
        tmp___2 = sqrt(*(dy_gamma + xjndx));
#line 1599
        tmp___3 = dy_prtvstat(xjstatus);
        }
#line 1599
        if (indir < 0) {
#line 1599
          tmp___4 = "decreasing";
        } else {
#line 1599
          tmp___4 = "increasing";
        }
        {
#line 1599
        tmp___5 = consys_nme(dy_sys, (char )'v', xjndx, (bool )1, (char *)((void *)0));
#line 1599
        tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1599
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %s (%d), entering %s from %s, price = %g ... ",
                    tmp___6, dy_lp->tot.iters, tmp___5, xjndx, tmp___4, tmp___3, cbarj / tmp___2);
        }
      }
      {
#line 1617
      pivresult = dy_primalpivot(xjndx, indir, & xindx, & outdir, & abarij, & delta,
                                 & candxj);
      }
#line 1620
      if (dy_opts->print.phase2 >= 4) {
        {
#line 1621
        dy_logpivot(pivresult, xjndx, indir, cbarj, xindx, outdir, abarij, delta);
        }
      }
      {
#line 1661
      duennaresult = dy_duenna(pivresult, xjndx, xindx, candxj, -1);
      }
      {
#line 1663
      if ((int )duennaresult == 1) {
#line 1663
        goto case_1___0;
      }
#line 1666
      if ((int )duennaresult == 3) {
#line 1666
        goto case_3;
      }
#line 1670
      if ((int )duennaresult == 6) {
#line 1670
        goto case_6___0;
      }
#line 1670
      if ((int )duennaresult == 7) {
#line 1670
        goto case_6___0;
      }
#line 1674
      if ((int )duennaresult == 8) {
#line 1674
        goto case_8;
      }
#line 1680
      if ((int )duennaresult == 9) {
#line 1680
        goto case_9;
      }
#line 1692
      if ((int )duennaresult == -10) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -5) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -4) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -9) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -8) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -7) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == -6) {
#line 1692
        goto case_neg_10;
      }
#line 1692
      if ((int )duennaresult == 5) {
#line 1692
        goto case_neg_10;
      }
#line 1696
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
#line 1664
      if (candxj <= 0) {
#line 1664
        do_pivots = (bool )0;
      } else
#line 1664
      if (xjndx == xindx) {
#line 1664
        do_pivots = (bool )0;
      }
#line 1665
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 1667
      do_pivots = (bool )0;
#line 1668
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      case_7: /* CIL Label */ 
#line 1671
      do_pivots = (bool )0;
#line 1672
      lpretval = duennaresult;
#line 1673
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 1675
      do_pivots = (bool )0;
#line 1676
      lpretval = duennaresult;
#line 1677
      dy_lp->ubnd.ndx = xjndx * indir;
#line 1678
      dy_lp->ubnd.ratio = (double )0;
#line 1679
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 1681
      if (dy_lp->basis.pivs >= 10) {
#line 1682
        lpretval = duennaresult;
#line 1683
        do_pivots = (bool )0;
      }
#line 1684
      goto switch_break___0;
      case_neg_10: /* CIL Label */ 
      case_neg_5: /* CIL Label */ 
      case_neg_4: /* CIL Label */ 
      case_neg_9: /* CIL Label */ 
      case_neg_8: /* CIL Label */ 
      case_neg_7: /* CIL Label */ 
      case_neg_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 1693
      do_pivots = (bool )0;
#line 1694
      lpretval = duennaresult;
#line 1695
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 1697
      errmsg(7, rtnnme, 1697, "La Duenna return code", (int )duennaresult);
#line 1699
      do_pivots = (bool )0;
#line 1700
      lpretval = (dyret_enum )-10;
      }
#line 1701
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1576
      xjndx = candxj;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1706
    if ((int )lpretval == 0) {
#line 1706
      goto while_continue;
    }
#line 1731
    if ((int )lpretval == 7) {
#line 1731
      goto _L___0;
    } else
#line 1731
    if ((int )lpretval == 8) {
#line 1731
      goto _L___0;
    } else
#line 1731
    if ((int )lpretval == 6) {
      _L___0: /* CIL Label */ 
      {
#line 1733
      optcnt ++;
#line 1735
      uxnpfeas = (bool )0;
#line 1736
      uxdfeas = (bool )0;
#line 1737
      uxndfeas = (bool )0;
#line 1738
      tmpretval = lpretval;
#line 1740
      preopresult = preoptimality(lpretval, & checks);
      }
      {
#line 1743
      if ((int )preopresult == 2) {
#line 1743
        goto case_2;
      }
#line 1743
      if ((int )preopresult == 1) {
#line 1743
        goto case_2;
      }
#line 1750
      if ((int )preopresult == -4) {
#line 1750
        goto case_neg_4___0;
      }
#line 1765
      if ((int )preopresult == -3) {
#line 1765
        goto case_neg_3;
      }
#line 1777
      goto switch_default___1;
      case_2: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 1746
      if ((int )lpretval == 8) {
#line 1746
        uxdfeas = (bool )1;
      } else
#line 1746
      if ((int )lpretval == 6) {
#line 1746
        uxdfeas = (bool )1;
      }
#line 1748
      lpretval = (dyret_enum )7;
#line 1749
      goto switch_break___1;
      case_neg_4___0: /* CIL Label */ 
#line 1753
      if (dy_opts->print.phase2 >= 1) {
        {
#line 1754
        tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1754
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: lost primal feasibility.",
                    tmp___7, dy_lp->tot.iters);
        }
      }
#line 1757
      uxnpfeas = (bool )1;
#line 1758
      if (checks & (unsigned int )(1 << 3)) {
#line 1758
        tmp___8 = 1;
      } else {
#line 1758
        tmp___8 = 0;
      }
#line 1758
      if (tmp___8) {
#line 1759
        if ((int )lpretval == 7) {
#line 1759
          uxndfeas = (bool )1;
        }
      } else
#line 1761
      if ((int )lpretval != 7) {
#line 1761
        uxdfeas = (bool )1;
      }
#line 1763
      lpretval = (dyret_enum )-4;
#line 1764
      goto switch_break___1;
      case_neg_3: /* CIL Label */ 
#line 1766
      if (! ((int )lpretval == 8)) {
#line 1766
        if (! ((int )lpretval == 6)) {
#line 1769
          if ((int )lpretval == 7) {
            {
#line 1770
            lpretval = (dyret_enum )0;
#line 1771
            dy_setpivparms(1, 1);
#line 1773
            uxndfeas = (bool )1;
            }
          }
        }
      }
#line 1776
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 1778
      lpretval = preopresult;
#line 1779
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 1790
      if (dy_opts->print.phase2 >= 2) {
#line 1791
        if ((int )uxnpfeas == 1) {
          {
#line 1792
          tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1792
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of primal feasibility at iteration (%s)%d.",
                      tmp___9, dy_lp->tot.iters);
          }
        }
#line 1795
        if ((int )uxdfeas == 1) {
          {
#line 1796
          tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1796
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected dual feasibility at iteration (%s)%d.",
                      tmp___10, dy_lp->tot.iters);
          }
        }
#line 1799
        if ((int )uxndfeas == 1) {
          {
#line 1800
          tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1800
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of dual feasibility at iteration (%s)%d.",
                      tmp___11, dy_lp->tot.iters);
          }
        }
      }
#line 1805
      if ((int )lpretval == 0) {
#line 1806
        if (optcnt > 15) {
          {
#line 1807
          tmp___12 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1807
          errmsg(387, rtnnme, dy_sys->nme, tmp___12, dy_lp->tot.iters, optcnt);
#line 1809
          lpretval = (dyret_enum )-10;
          }
        } else
#line 1812
        if (dy_opts->print.phase2 >= 2) {
          {
#line 1813
          tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1813
          tmp___14 = dy_prtdyret(tmpretval);
#line 1813
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tfalse termination (%s) at (%s)%d; resuming pivoting.",
                      tmp___14, tmp___13, dy_lp->tot.iters);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1822
  tmp___15 = dy_clrpivrej((int *)((void *)0));
  }
#line 1822
  if ((int )tmp___15 != 1) {
#line 1822
    lpretval = (dyret_enum )-10;
  }
#line 1823
  if (dy_lp->degen > 0) {
    {
#line 1823
    dy_degenout(0);
    }
  }
#line 1826
  if (dy_opts->print.phase2 >= 2) {
#line 1827
    if ((int )lpretval == 8) {
      {
#line 1828
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: system %s is unbounded.", rtnnme,
                  dy_sys->nme);
      }
    } else
#line 1831
    if ((int )lpretval == 9) {
      {
#line 1832
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: system %s is pseudo-unbounded.", rtnnme,
                  dy_sys->nme);
      }
    }
  }
#line 1841
  return (lpretval);
}
}
#line 1845 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primal.c"
lpret_enum dy_primal(void) 
{ 
  lpret_enum retval ;
  dyret_enum dyret ;
  int lostfeascnt ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  bool tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  double dualobj ;
  double primalobj ;
  double tmp___15 ;

  {
  {
#line 1864
  rtnnme = "dy_primal";
#line 1866
  retval = (lpret_enum )0;
#line 1867
  dy_lp->lpret = (lpret_enum )0;
#line 1868
  dy_setpivparms(-100, -100);
#line 1869
  dy_setpivparms(1, 1);
#line 1870
  dy_lp->basis.pivs = 0;
#line 1878
  lostfeascnt = 0;
  }
  {
#line 1878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1878
    if (! (lostfeascnt < 10)) {
#line 1878
      goto while_break;
    }
#line 1879
    if (dy_lp->infeas > 0.0) {
      {
#line 1880
      dy_lp->phase = (dyphase_enum )2;
#line 1881
      dy_lp->p1.iters = 0;
#line 1882
      dyret = primal1();
      }
#line 1884
      if (dy_opts->print.phase1 >= 2) {
        {
#line 1886
        tmp = dy_prtdyret(dyret);
#line 1886
        tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1886
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal phase I ended, %d pivots, status %s.",
                    tmp___0, dy_lp->tot.iters, dy_lp->p1.pivs, tmp);
        }
      } else
#line 1884
      if (dy_opts->print.phase1 >= 1) {
#line 1884
        if ((int )dyret != 7) {
          {
#line 1886
          tmp = dy_prtdyret(dyret);
#line 1886
          tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1886
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal phase I ended, %d pivots, status %s.",
                      tmp___0, dy_lp->tot.iters, dy_lp->p1.pivs, tmp);
          }
        }
      }
#line 1890
      if (dy_opts->print.major >= 1) {
#line 1890
        if ((int )dyret == 7) {
          {
#line 1891
          tmp___1 = dy_prtlpphase((dyphase_enum )3, (bool )0);
#line 1891
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\n%s (%s): entering phase %s, iter %d.",
                      "dylp", dy_sys->nme, tmp___1, dy_lp->tot.iters);
          }
        }
      }
    } else {
#line 1902
      dyret = (dyret_enum )7;
    }
#line 1903
    if ((int )dyret != 7) {
#line 1903
      goto while_break;
    }
#line 1908
    if (dy_opts->print.phase2 >= 2) {
      {
#line 1909
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: entering primal phase II, z = %g",
                  rtnnme, dy_lp->z);
      }
#line 1912
      if (dy_opts->print.phase2 >= 4) {
        {
#line 1913
        tmp___2 = dy_calcdualobj();
#line 1913
        dyio_outfmt(dy_logchn, dy_gtxecho, ", dual active yb = %g", tmp___2);
        }
      }
      {
#line 1915
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
      }
    }
    {
#line 1917
    dy_lp->phase = (dyphase_enum )3;
#line 1918
    dy_lp->simplex.active = (dyphase_enum )3;
#line 1919
    dy_lp->p2.iters = 0;
#line 1920
    dyret = primal2();
    }
#line 1931
    if ((int )dyret == -4) {
#line 1934
      if (dy_opts->print.phase2 >= 1) {
        {
#line 1935
        tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1935
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: lost feasibility by %g after %d pivots; ",
                    tmp___3, dy_lp->tot.iters, dy_lp->infeas, dy_lp->p2.pivs);
        }
#line 1939
        if (lostfeascnt + 1 < 10) {
          {
#line 1940
          dyio_outfmt(dy_logchn, dy_gtxecho, "returning to phase I for try %d.", lostfeascnt + 2);
          }
        } else {
          {
#line 1943
          dyio_outfmt(dy_logchn, dy_gtxecho, "aborting after %d tries.", lostfeascnt + 1);
          }
        }
      }
#line 1947
      if (lostfeascnt + 1 < 10) {
        {
#line 1948
        dy_lp->phase = (dyphase_enum )2;
#line 1949
        tmp___5 = forcesuperbasic();
        }
#line 1949
        if ((int )tmp___5 == 0) {
          {
#line 1950
          tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1950
          errmsg(391, rtnnme, dy_sys->nme, tmp___4, dy_lp->tot.iters);
#line 1952
          dyret = (dyret_enum )-10;
          }
#line 1953
          goto while_break;
        }
        {
#line 1954
        dy_setpivparms(0, 1);
        }
      }
#line 1955
      goto __Cont;
    } else {
#line 1959
      if (dy_opts->print.phase2 >= 2) {
        {
#line 1961
        tmp___6 = dy_prtdyret(dyret);
#line 1961
        tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1961
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal phase II ended, %d pivots, status %s.",
                    tmp___7, dy_lp->tot.iters, dy_lp->p2.pivs, tmp___6);
        }
      } else
#line 1959
      if (dy_opts->print.phase2 >= 1) {
#line 1959
        if ((int )dyret != 7) {
          {
#line 1961
          tmp___6 = dy_prtdyret(dyret);
#line 1961
          tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1961
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal phase II ended, %d pivots, status %s.",
                      tmp___7, dy_lp->tot.iters, dy_lp->p2.pivs, tmp___6);
          }
        }
      }
#line 1966
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1878
    lostfeascnt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1977
  retval = dyret2lpret(dyret);
  }
#line 1979
  if ((int )retval == 1) {
#line 1979
    goto _L___3;
  } else
#line 1979
  if ((int )retval == 2) {
#line 1979
    goto _L___3;
  } else
#line 1979
  if ((int )retval == 4) {
    _L___3: /* CIL Label */ 
#line 1980
    if ((unsigned int )dy_lp->phase == 2U) {
#line 1980
      if (dy_opts->print.phase1 >= 2) {
#line 1980
        goto _L;
      } else {
#line 1980
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1980
    if ((unsigned int )dy_lp->phase == 3U) {
#line 1980
      if (dy_opts->print.phase2 >= 2) {
        _L: /* CIL Label */ 
        {
#line 1982
        tmp___8 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1982
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: ", tmp___8, dy_lp->tot.iters);
#line 1984
        tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )0);
#line 1984
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s ended, %d pivots, ", tmp___9, dy_lp->tot.pivs);
        }
#line 1986
        if ((int )retval == 1) {
          {
#line 1987
          dyio_outfmt(dy_logchn, dy_gtxecho, "z<opt> = %g.", dy_lp->z);
          }
        } else
#line 1989
        if ((int )retval == 4) {
          {
#line 1990
          dyio_outfmt(dy_logchn, dy_gtxecho, "infeas = %g.", dy_lp->infeas);
          }
        } else {
          {
#line 1992
          dyio_outfmt(dy_logchn, dy_gtxecho, "unbounded.");
          }
        }
      }
    }
  } else
#line 1994
  if ((int )retval == 9) {
#line 1995
    if (dy_opts->print.phase2 >= 1) {
      {
#line 1996
      tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1996
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal simplex aborted; lost feasibility %d times.",
                  tmp___10, dy_lp->tot.iters, lostfeascnt - 1);
      }
    }
  } else
#line 2001
  if ((int )retval == 7) {
#line 2002
    if ((unsigned int )dy_lp->phase == 2U) {
#line 2002
      if (dy_opts->print.phase1 >= 1) {
        {
#line 2004
        tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2004
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal simplex terminated; iteration limit (%d).",
                    tmp___11, dy_lp->tot.iters, dy_opts->iterlim);
        }
      } else {
#line 2002
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2002
    if ((unsigned int )dy_lp->phase == 3U) {
#line 2002
      if (dy_opts->print.phase2 >= 1) {
        {
#line 2004
        tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2004
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: primal simplex terminated; iteration limit (%d).",
                    tmp___11, dy_lp->tot.iters, dy_opts->iterlim);
        }
      }
    }
  } else
#line 2009
  if ((unsigned int )dy_lp->phase == 2U) {
#line 2009
    if (dy_opts->print.phase1 >= 1) {
      {
#line 2011
      tmp___12 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2011
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: ", tmp___12, dy_lp->tot.iters);
#line 2013
      tmp___13 = dy_prtdyret(dyret);
#line 2013
      tmp___14 = dy_prtlpphase(dy_lp->phase, (bool )0);
#line 2013
      dyio_outfmt(dy_logchn, dy_gtxecho, "%s failed, status %s after %d pivots.",
                  tmp___14, tmp___13, dy_lp->tot.pivs);
      }
    } else {
#line 2009
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2009
  if ((unsigned int )dy_lp->phase == 3U) {
#line 2009
    if (dy_opts->print.phase2 >= 1) {
      {
#line 2011
      tmp___12 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2011
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: ", tmp___12, dy_lp->tot.iters);
#line 2013
      tmp___13 = dy_prtdyret(dyret);
#line 2013
      tmp___14 = dy_prtlpphase(dy_lp->phase, (bool )0);
#line 2013
      dyio_outfmt(dy_logchn, dy_gtxecho, "%s failed, status %s after %d pivots.",
                  tmp___14, tmp___13, dy_lp->tot.pivs);
      }
    }
  }
#line 2020
  if (dy_opts->print.phase2 >= 4) {
#line 2020
    if ((int )retval == 1) {
      {
#line 2023
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: comparing dual and primal objectives.",
                  rtnnme);
#line 2025
      dualobj = dy_calcdualobj();
#line 2026
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tdual objective yb = %g.", dualobj);
#line 2028
      primalobj = dy_calcobj();
#line 2029
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tprimal objective cx = %g.", primalobj);
#line 2032
      tmp___15 = fabs(dualobj - primalobj);
      }
#line 2032
      if (tmp___15 <= dy_tols->dchk) {
        {
#line 2037
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tobjectives match.");
        }
      } else {
        {
#line 2033
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tWHOOPS! yb - cx = %g - %g = %g > %g.",
                    dualobj, primalobj, dualobj - primalobj, dy_tols->dchk);
        }
      }
    }
  }
#line 2044
  dy_lp->lpret = retval;
#line 2046
  return (retval);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___6  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 250
double exvec_1norm(double *vec , int len ) ;
#line 1888 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_dupbasis(int dst_basissze , basis_struct **p_dst_basis , basis_struct *src_basis ,
                 int dst_statussze , flags **p_dst_status , int src_statuslen , flags *src_status ) ;
#line 1892
void dy_freesoln(lpprob_struct *lpprob ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
lpret_enum dyret2lpret(dyret_enum dyret ) 
{ 


  {
  {
#line 44
  if ((int )dyret == 1) {
#line 44
    goto case_1;
  }
#line 46
  if ((int )dyret == 7) {
#line 46
    goto case_7;
  }
#line 48
  if ((int )dyret == 8) {
#line 48
    goto case_8;
  }
#line 50
  if ((int )dyret == 9) {
#line 50
    goto case_9;
  }
#line 52
  if ((int )dyret == 10) {
#line 52
    goto case_10;
  }
#line 54
  if ((int )dyret == 4) {
#line 54
    goto case_4;
  }
#line 56
  if ((int )dyret == 5) {
#line 56
    goto case_5;
  }
#line 58
  if ((int )dyret == -4) {
#line 58
    goto case_neg_4;
  }
#line 60
  if ((int )dyret == -3) {
#line 60
    goto case_neg_3;
  }
#line 62
  if ((int )dyret == -2) {
#line 62
    goto case_neg_2;
  }
#line 64
  if ((int )dyret == 3) {
#line 64
    goto case_3;
  }
#line 66
  if ((int )dyret == -1) {
#line 66
    goto case_neg_1;
  }
#line 68
  if ((int )dyret == 6) {
#line 68
    goto case_6;
  }
#line 70
  if ((int )dyret == 2) {
#line 70
    goto case_2;
  }
#line 72
  if ((int )dyret == -5) {
#line 72
    goto case_neg_5;
  }
#line 74
  if ((int )dyret == -7) {
#line 74
    goto case_neg_7;
  }
#line 76
  if ((int )dyret == -8) {
#line 76
    goto case_neg_8;
  }
#line 78
  if ((int )dyret == -9) {
#line 78
    goto case_neg_9;
  }
#line 80
  if ((int )dyret == -10) {
#line 80
    goto case_neg_10;
  }
#line 82
  if ((int )dyret == 0) {
#line 82
    goto case_0;
  }
#line 84
  goto switch_default;
  case_1: /* CIL Label */ 
#line 45
  return ((lpret_enum )0);
  case_7: /* CIL Label */ 
#line 47
  return ((lpret_enum )1);
  case_8: /* CIL Label */ 
#line 49
  return ((lpret_enum )2);
  case_9: /* CIL Label */ 
#line 51
  return ((lpret_enum )3);
  case_10: /* CIL Label */ 
#line 53
  return ((lpret_enum )4);
  case_4: /* CIL Label */ 
#line 55
  return ((lpret_enum )0);
  case_5: /* CIL Label */ 
#line 57
  return ((lpret_enum )5);
  case_neg_4: /* CIL Label */ 
#line 59
  return ((lpret_enum )9);
  case_neg_3: /* CIL Label */ 
#line 61
  return ((lpret_enum )9);
  case_neg_2: /* CIL Label */ 
#line 63
  return ((lpret_enum )0);
  case_3: /* CIL Label */ 
#line 65
  return ((lpret_enum )0);
  case_neg_1: /* CIL Label */ 
#line 67
  return ((lpret_enum )0);
  case_6: /* CIL Label */ 
#line 69
  return ((lpret_enum )10);
  case_2: /* CIL Label */ 
#line 71
  return ((lpret_enum )0);
  case_neg_5: /* CIL Label */ 
#line 73
  return ((lpret_enum )-1);
  case_neg_7: /* CIL Label */ 
#line 75
  return ((lpret_enum )8);
  case_neg_8: /* CIL Label */ 
#line 77
  return ((lpret_enum )6);
  case_neg_9: /* CIL Label */ 
#line 79
  return ((lpret_enum )7);
  case_neg_10: /* CIL Label */ 
#line 81
  return ((lpret_enum )-1);
  case_0: /* CIL Label */ 
#line 83
  return ((lpret_enum )0);
  switch_default: /* CIL Label */ 
#line 85
  return ((lpret_enum )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
bool dy_reducerhs(double *rhs , bool init ) 
{ 
  int vndx ;
  int pkndx ;
  int cndx ;
  pkvec_struct *pkcol ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;

  {
#line 108
  rtnnme = "dy_reducerhs";
#line 128
  if ((int )init == 1) {
    {
#line 129
    memcpy((void */* __restrict  */)rhs, (void const   */* __restrict  */)dy_sys->rhs,
           (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
    }
  }
#line 136
  pkcol = (pkvec_struct *)((void *)0);
#line 137
  vndx = 1;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (vndx <= dy_sys->varcnt)) {
#line 137
      goto while_break;
    }
#line 138
    if (*(dy_status + vndx) & (unsigned int )(((1 << 5) | (1 << 6)) | (1 << 7))) {
#line 138
      tmp___1 = 1;
    } else {
#line 138
      tmp___1 = 0;
    }
#line 138
    if (tmp___1) {
#line 138
      if (*(dy_x + vndx) != 0.0) {
        {
#line 146
        tmp___0 = consys_getcol_pk(dy_sys, vndx, & pkcol);
        }
#line 146
        if ((int )tmp___0 == 0) {
          {
#line 147
          tmp = consys_nme(dy_sys, (char )'v', vndx, (bool )1, (char *)((void *)0));
#line 147
          errmsg(122, rtnnme, dy_sys->nme, "column", tmp, vndx);
          }
#line 149
          return ((bool )0);
        }
#line 150
        pkndx = 0;
        {
#line 150
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 150
          if (! (pkndx < pkcol->cnt)) {
#line 150
            goto while_break___0;
          }
#line 151
          cndx = (pkcol->coeffs + pkndx)->ndx;
#line 152
          *(rhs + cndx) -= (pkcol->coeffs + pkndx)->val * *(dy_x + vndx);
#line 150
          pkndx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 137
    vndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  cndx = 1;
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 156
    if (! (cndx <= dy_sys->concnt)) {
#line 156
      goto while_break___1;
    }
    {
#line 157
    tmp___2 = fabs(*(rhs + cndx));
    }
#line 157
    if (tmp___2 < dy_tols->zero) {
#line 157
      *(rhs + cndx) = (double )0;
    }
#line 156
    cndx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  if ((unsigned long )pkcol != (unsigned long )((void *)0)) {
    {
#line 159
    pkvec_free(pkcol);
    }
  }
#line 161
  return ((bool )1);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
bool dy_calcprimals(void) 
{ 
  int vndx ;
  int bndx ;
  double *xvec ;
  bool degenActive ;
  char const   *rtnnme ;
  int print ;
  void *tmp ;
  bool tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
#line 179
  rtnnme = "dy_calcprimals";
  {
#line 185
  if ((unsigned int )dy_lp->phase == 2U) {
#line 185
    goto case_2;
  }
#line 188
  if ((unsigned int )dy_lp->phase == 3U) {
#line 188
    goto case_3;
  }
#line 191
  if ((unsigned int )dy_lp->phase == 4U) {
#line 191
    goto case_4;
  }
#line 194
  if ((unsigned int )dy_lp->phase == 10U) {
#line 194
    goto case_10;
  }
#line 200
  if ((unsigned int )dy_lp->phase == 7U) {
#line 200
    goto case_7;
  }
#line 206
  if ((unsigned int )dy_lp->phase == 1U) {
#line 206
    goto case_1;
  }
#line 212
  goto switch_default;
  case_2: /* CIL Label */ 
#line 186
  print = dy_opts->print.phase1;
#line 187
  goto switch_break;
  case_3: /* CIL Label */ 
#line 189
  print = dy_opts->print.phase2;
#line 190
  goto switch_break;
  case_4: /* CIL Label */ 
#line 192
  print = dy_opts->print.dual;
#line 193
  goto switch_break;
  case_10: /* CIL Label */ 
#line 195
  if (dy_opts->print.conmgmt >= 3) {
#line 196
    print = 5;
  } else {
#line 198
    print = 0;
  }
#line 199
  goto switch_break;
  case_7: /* CIL Label */ 
#line 201
  if (dy_opts->print.varmgmt >= 3) {
#line 202
    print = 5;
  } else {
#line 204
    print = 0;
  }
#line 205
  goto switch_break;
  case_1: /* CIL Label */ 
#line 207
  if (dy_opts->print.crash >= 4) {
#line 208
    print = 7;
  } else {
#line 210
    print = 0;
  }
#line 211
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 213
  print = 0;
#line 214
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 232
  xvec = (double *)((void *)0);
#line 233
  if (dy_lp->degen > 0) {
#line 233
    if ((unsigned int )dy_lp->phase == 2U) {
#line 235
      degenActive = (bool )1;
    } else
#line 233
    if ((unsigned int )dy_lp->phase == 3U) {
#line 235
      degenActive = (bool )1;
    } else {
#line 237
      degenActive = (bool )0;
    }
  } else {
#line 237
    degenActive = (bool )0;
  }
#line 242
  if (dy_sys->concnt > 0) {
#line 248
    if ((int )degenActive == 1) {
      {
#line 249
      tmp = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 249
      xvec = (double *)tmp;
      }
    } else {
#line 251
      xvec = dy_xbasic;
    }
    {
#line 258
    tmp___0 = dy_reducerhs(xvec, (bool )1);
    }
#line 258
    if ((int )tmp___0 == 0) {
      {
#line 259
      errmsg(340, rtnnme, dy_sys->nme);
      }
#line 260
      if ((int )degenActive == 1) {
        {
#line 260
        free((void *)xvec);
        }
      }
#line 261
      return ((bool )0);
    }
    {
#line 262
    dy_ftran(xvec, (bool )0);
#line 264
    dy_lp->prim.norm1 = exvec_1norm(xvec, dy_sys->concnt);
#line 265
    dy_lp->prim.norm2 = exvec_2norm(xvec, dy_sys->concnt);
#line 266
    dy_lp->prim.max = exvec_infnorm(xvec, dy_sys->concnt, & dy_lp->prim.maxndx);
#line 267
    dy_tols->pfeas = dy_lp->prim.max;
    }
#line 268
    if (dy_tols->pfeas < 10.0) {
#line 269
      dy_tols->pfeas = dy_tols->zero;
    } else {
      {
#line 271
      tmp___1 = log10(dy_tols->pfeas);
#line 271
      dy_tols->pfeas = tmp___1 * dy_tols->zero;
      }
    }
#line 272
    dy_tols->pfeas = dy_tols->pfeas_scale * dy_tols->pfeas;
#line 277
    if ((unsigned int )dy_lp->phase == 2U) {
#line 277
      goto _L;
    } else
#line 277
    if ((unsigned int )dy_lp->phase == 3U) {
      _L: /* CIL Label */ 
#line 278
      bndx = 1;
      {
#line 278
      while (1) {
        while_continue: /* CIL Label */ ;
#line 278
        if (! (bndx <= dy_sys->concnt)) {
#line 278
          goto while_break;
        }
#line 279
        vndx = *(dy_basis + bndx);
#line 280
        if (*(dy_status + vndx) & 1U) {
#line 280
          tmp___2 = 1;
        } else {
#line 280
          tmp___2 = 0;
        }
#line 280
        if (tmp___2) {
#line 299
          *(dy_x + vndx) = *(xvec + bndx);
        } else {
#line 301
          *(dy_x + vndx) = *(xvec + bndx);
        }
#line 278
        bndx ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 303
      bndx = 1;
      {
#line 303
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 303
        if (! (bndx <= dy_sys->concnt)) {
#line 303
          goto while_break___0;
        }
#line 304
        vndx = *(dy_basis + bndx);
#line 305
        *(dy_x + vndx) = *(xvec + bndx);
#line 303
        bndx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else {
#line 311
    dy_tols->pfeas = dy_tols->pfeas_scale * dy_tols->zero;
#line 312
    dy_lp->prim.norm1 = (double )1;
#line 313
    dy_lp->prim.norm2 = (double )1;
#line 314
    dy_lp->prim.max = (double )1;
#line 315
    dy_lp->prim.maxndx = -1;
  }
#line 318
  if (print >= 3) {
    {
#line 319
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: recalculated primal variables:", rtnnme);
#line 321
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tprim.max = %g, scale = %g, pzero = %g, pfeas = %g.",
                dy_lp->prim.max, dy_tols->pfeas_scale, dy_tols->zero, dy_tols->pfeas);
    }
  }
#line 363
  if (print >= 5) {
    {
#line 364
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s%16s%16s%8s", "pos\'n", "var (ndx)",
                "lb", "val", "ub", "status");
    }
#line 367
    if (degenActive) {
      {
#line 367
      dyio_outfmt(dy_logchn, dy_gtxecho, "%16s", "perturbation");
      }
    }
#line 368
    bndx = 1;
    {
#line 368
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 368
      if (! (bndx <= dy_sys->concnt)) {
#line 368
        goto while_break___1;
      }
      {
#line 369
      vndx = *(dy_basis + bndx);
#line 370
      tmp___3 = dy_prtvstat(*(dy_status + vndx));
#line 370
      tmp___4 = consys_nme(dy_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 370
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%14s (%3d)%16.8g%16.8g%16.8g%8s", bndx,
                  tmp___4, vndx, *(dy_sys->vlb + vndx), *(dy_x + vndx), *(dy_sys->vub + vndx),
                  tmp___3);
      }
#line 375
      if ((int )degenActive == 1) {
#line 375
        if (*(dy_degenset + bndx) > 0) {
#line 376
          if (*(dy_brkout + bndx) > 0) {
            {
#line 377
            dyio_outfmt(dy_logchn, dy_gtxecho, "%16.8g", *(dy_xbasic + bndx) - *(dy_sys->vlb + vndx));
            }
          } else {
            {
#line 380
            dyio_outfmt(dy_logchn, dy_gtxecho, "%16.8g", *(dy_sys->vub + vndx) - *(dy_xbasic + bndx));
            }
          }
        }
      }
#line 368
      bndx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 382
    if (print >= 6) {
#line 383
      vndx = 1;
      {
#line 383
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 383
        if (! (vndx <= dy_sys->varcnt)) {
#line 383
          goto while_break___2;
        }
#line 384
        if (*(dy_var2basis + vndx) != 0) {
#line 384
          goto __Cont;
        }
        {
#line 385
        tmp___5 = dy_prtvstat(*(dy_status + vndx));
#line 385
        tmp___6 = consys_nme(dy_sys, (char )'v', vndx, (bool )0, (char *)((void *)0));
#line 385
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%14s (%3d)%16.8g%16.8g%16.8g%8s",
                    " ", tmp___6, vndx, *(dy_sys->vlb + vndx), *(dy_x + vndx), *(dy_sys->vub + vndx),
                    tmp___5);
        }
        __Cont: /* CIL Label */ 
#line 383
        vndx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 395
  if ((int )degenActive == 1) {
    {
#line 395
    free((void *)xvec);
    }
  }
#line 397
  return ((bool )1);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
dyret_enum dy_updateprimals(int j , double deltaj , double *p_abarj ) 
{ 
  int kpos ;
  int k ;
  int m ;
  double *abarj ;
  double abarkj ;
  double deltak ;
  double xk ;
  double ubk ;
  double lbk ;
  double newxk ;
  flags statk ;
  flags newstatk ;
  flags qualsk ;
  double eps0 ;
  double epsu ;
  double epsl ;
  int swingndx ;
  double swingratio ;
  double maxswing ;
  bool swing ;
  dyret_enum retval ;
  char const   *rtnnme ;
  double tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  double tmp___11 ;
  int tmp___12 ;
  double tmp___13 ;
  double tmp___15 ;
  int tmp___16 ;
  double tmp___17 ;
  double tmp___19 ;
  int tmp___20 ;
  double tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  char const   *tmp___24 ;
  double tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  double tmp___28 ;
  char const   *tmp___29 ;
  int tmp___30 ;
  double tmp___31 ;
  int tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  bool first ;
  char *tmp___39 ;
  char const   *tmp___40 ;

  {
  {
#line 446
  rtnnme = "dy_updateprimals";
#line 451
  tmp = fabs(deltaj - (double )0);
  }
#line 451
  if (tmp <= dy_tols->zero) {
#line 451
    return ((dyret_enum )1);
  }
#line 452
  retval = (dyret_enum )0;
#line 453
  m = dy_sys->concnt;
#line 454
  swing = (bool )0;
#line 455
  maxswing = (double )0;
#line 456
  swingndx = -1;
#line 461
  if ((unsigned long )p_abarj != (unsigned long )((void *)0)) {
#line 462
    abarj = p_abarj;
  } else {
    {
#line 464
    abarj = (double *)((void *)0);
#line 465
    tmp___1 = consys_getcol_ex(dy_sys, j, & abarj);
    }
#line 465
    if ((int )tmp___1 == 0) {
      {
#line 466
      tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 466
      errmsg(122, rtnnme, dy_sys->nme, "column", tmp___0, j);
      }
#line 468
      if ((unsigned long )abarj != (unsigned long )((void *)0)) {
        {
#line 468
        free((void *)abarj);
        }
      }
#line 469
      return ((dyret_enum )-10);
    }
    {
#line 470
    dy_ftran(abarj, (bool )0);
    }
  }
#line 474
  kpos = 1;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! (kpos <= m)) {
#line 474
      goto while_break;
    }
#line 475
    abarkj = *(abarj + kpos);
#line 476
    if (abarkj == (double )0) {
#line 476
      goto __Cont;
    }
    {
#line 477
    deltak = abarkj * deltaj;
#line 478
    tmp___2 = fabs(deltak - (double )0);
    }
#line 478
    if (tmp___2 <= dy_tols->zero) {
#line 478
      goto __Cont;
    }
#line 479
    k = *(dy_basis + kpos);
#line 480
    xk = *(dy_xbasic + kpos);
#line 481
    statk = *(dy_status + k) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 482
    qualsk = *(dy_status + k) & (((1U << (sizeof(flags ) * 8UL - 2UL)) | (1U << (sizeof(flags ) * 8UL - 3UL))) | (1U << (sizeof(flags ) * 8UL - 4UL)));
#line 483
    eps0 = dy_tols->zero;
#line 484
    ubk = *(dy_sys->vub + k);
#line 485
    if (ubk < dy_tols->inf) {
      {
#line 486
      tmp___3 = fabs(ubk);
#line 486
      epsu = dy_tols->pfeas * (1.0 + tmp___3);
      }
    } else {
#line 488
      epsu = (double )0;
    }
#line 489
    lbk = *(dy_sys->vlb + k);
#line 490
    if (- dy_tols->inf < lbk) {
      {
#line 491
      tmp___4 = fabs(lbk);
#line 491
      epsl = dy_tols->pfeas * (1.0 + tmp___4);
      }
    } else {
#line 493
      epsl = (double )0;
    }
    {
#line 494
    newxk = xk - deltak;
#line 495
    tmp___5 = fabs(newxk);
    }
#line 495
    if (tmp___5 < eps0) {
#line 495
      newxk = (double )0;
    }
#line 500
    if (statk == (flags )(1 << 4)) {
#line 501
      newstatk = (flags )(1 << 4);
    } else {
      {
#line 503
      tmp___21 = fabs(ubk);
      }
#line 503
      if (tmp___21 < dy_tols->inf) {
        {
#line 503
        tmp___19 = fabs(ubk);
#line 503
        tmp___20 = ubk - newxk > dy_tols->pfeas * (1.0 + tmp___19);
        }
      } else {
#line 503
        tmp___20 = newxk < ubk;
      }
#line 503
      if (tmp___20) {
        {
#line 504
        tmp___13 = fabs(lbk);
        }
#line 504
        if (tmp___13 < dy_tols->inf) {
          {
#line 504
          tmp___11 = fabs(lbk);
#line 504
          tmp___12 = newxk - lbk > dy_tols->pfeas * (1.0 + tmp___11);
          }
        } else {
#line 504
          tmp___12 = newxk > lbk;
        }
#line 504
        if (tmp___12) {
#line 505
          newstatk = (flags )(1 << 2);
        } else {
          {
#line 507
          tmp___9 = fabs(lbk);
          }
#line 507
          if (tmp___9 < dy_tols->inf) {
            {
#line 507
            tmp___7 = fabs(lbk);
#line 507
            tmp___8 = lbk - newxk > dy_tols->pfeas * (1.0 + tmp___7);
            }
          } else {
#line 507
            tmp___8 = newxk < lbk;
          }
#line 507
          if (tmp___8) {
#line 508
            newstatk = (flags )(1 << 11);
          } else {
#line 510
            newstatk = (flags )(1 << 3);
          }
        }
      } else {
        {
#line 512
        tmp___17 = fabs(ubk);
        }
#line 512
        if (tmp___17 < dy_tols->inf) {
          {
#line 512
          tmp___15 = fabs(ubk);
#line 512
          tmp___16 = newxk - ubk > dy_tols->pfeas * (1.0 + tmp___15);
          }
        } else {
#line 512
          tmp___16 = newxk > ubk;
        }
#line 512
        if (tmp___16) {
#line 513
          newstatk = (flags )(1 << 10);
        } else {
#line 515
          newstatk = (flags )(1 << 1);
        }
      }
    }
#line 517
    if (newstatk & (unsigned int )((1 << 3) | (1 << 1))) {
#line 517
      tmp___22 = 1;
    } else {
#line 517
      tmp___22 = 0;
    }
#line 517
    if (tmp___22) {
#line 517
      if (lbk == ubk) {
#line 518
        newstatk = (flags )1;
      }
    }
#line 528
    if (dy_lp->basis.etas > 1) {
#line 528
      if (dy_tols->bogus > 1.0) {
#line 528
        if (newxk != (double )0) {
#line 528
          if (newstatk & (unsigned int )(((1 << 3) | (1 << 1)) | 1)) {
#line 528
            tmp___32 = 0;
          } else {
#line 528
            tmp___32 = 1;
          }
#line 528
          if (tmp___32) {
            {
#line 530
            tmp___25 = fabs(newxk);
            }
#line 530
            if (tmp___25 < eps0 * dy_tols->bogus) {
#line 531
              retval = (dyret_enum )4;
#line 533
              if (dy_opts->print.pivoting >= 1) {
                {
#line 534
                tmp___23 = fabs(newxk);
#line 534
                tmp___24 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 534
                warn(374, rtnnme, dy_sys->nme, tmp___24, dy_lp->tot.iters, "x", k,
                     tmp___23, eps0 * dy_tols->bogus, eps0 * dy_tols->bogus - newxk);
                }
              }
            }
#line 539
            if (newstatk & (unsigned int )((1 << 2) | (1 << 11))) {
#line 539
              tmp___27 = 1;
            } else {
#line 539
              tmp___27 = 0;
            }
#line 539
            if (tmp___27) {
              {
#line 539
              tmp___28 = fabs(lbk - newxk);
              }
#line 539
              if (tmp___28 < epsl * dy_tols->bogus) {
#line 541
                retval = (dyret_enum )4;
#line 543
                if (dy_opts->print.pivoting >= 1) {
                  {
#line 544
                  tmp___26 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 544
                  warn(375, rtnnme, dy_sys->nme, tmp___26, dy_lp->tot.iters, "lb",
                       k, "x", k, lbk, newxk, lbk - newxk, epsl * dy_tols->bogus,
                       epsl * dy_tols->bogus - (lbk - newxk));
                  }
                }
              }
            }
#line 550
            if (newstatk & (unsigned int )((1 << 2) | (1 << 1))) {
#line 550
              tmp___30 = 1;
            } else {
#line 550
              tmp___30 = 0;
            }
#line 550
            if (tmp___30) {
              {
#line 550
              tmp___31 = fabs(newxk - ubk);
              }
#line 550
              if (tmp___31 < epsu * dy_tols->bogus) {
#line 552
                retval = (dyret_enum )4;
#line 554
                if (dy_opts->print.pivoting >= 1) {
                  {
#line 555
                  tmp___29 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 555
                  warn(375, rtnnme, dy_sys->nme, tmp___29, dy_lp->tot.iters, "ub",
                       k, "x", k, ubk, newxk, ubk - newxk, epsu * dy_tols->bogus,
                       epsu * dy_tols->bogus - (ubk - newxk));
                  }
                }
              }
            }
          }
        }
      }
    }
#line 564
    if (newstatk & (unsigned int )((1 << 11) | (1 << 10))) {
#line 564
      tmp___35 = 1;
    } else {
#line 564
      tmp___35 = 0;
    }
#line 564
    if (tmp___35) {
      {
#line 565
      tmp___33 = fabs(newxk);
#line 565
      tmp___34 = fabs(*(dy_xbasic + kpos));
#line 565
      swingratio = (tmp___33 + (double )1) / (tmp___34 + (double )1);
      }
#line 566
      if (swingratio > dy_tols->swing) {
#line 567
        swing = (bool )1;
#line 568
        if (swingratio > maxswing) {
#line 569
          maxswing = swingratio;
#line 570
          swingndx = k;
        }
      }
    }
#line 574
    *(dy_xbasic + kpos) = newxk;
#line 575
    *(dy_x + k) = newxk;
#line 576
    *(dy_status + k) = newstatk | qualsk;
    __Cont: /* CIL Label */ 
#line 474
    kpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if ((int )swing == 1) {
#line 581
    retval = (dyret_enum )9;
#line 582
    dy_lp->ubnd.ndx = swingndx;
#line 583
    dy_lp->ubnd.ratio = maxswing;
#line 585
    if (dy_opts->print.dual >= 2) {
#line 585
      goto _L;
    } else
#line 585
    if (dy_opts->print.phase1 >= 2) {
#line 585
      goto _L;
    } else
#line 585
    if (dy_opts->print.phase2 >= 2) {
      _L: /* CIL Label */ 
      {
#line 587
      k = dy_lp->ubnd.ndx;
#line 588
      statk = *(dy_status + k);
#line 589
      tmp___36 = dy_prtvstat(statk);
#line 589
      tmp___37 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 589
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    Pseudo-unbounded: growth %e for %s (%d) %s = %g",
                  dy_lp->ubnd.ratio, tmp___37, k, tmp___36, *(dy_x + k));
      }
#line 593
      if (statk & (unsigned int )(1 << 10)) {
#line 593
        tmp___38 = 1;
      } else {
#line 593
        tmp___38 = 0;
      }
#line 593
      if (tmp___38) {
        {
#line 594
        dyio_outfmt(dy_logchn, dy_gtxecho, " > %g.", *(dy_sys->vub + k));
        }
      } else {
        {
#line 596
        dyio_outfmt(dy_logchn, dy_gtxecho, " < %g.", *(dy_sys->vlb + k));
        }
      }
    }
  }
#line 603
  if (dy_opts->print.dual >= 6) {
#line 604
    first = (bool )1;
#line 605
    kpos = 1;
    {
#line 605
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 605
      if (! (kpos <= dy_sys->concnt)) {
#line 605
        goto while_break___0;
      }
#line 606
      if (*(abarj + kpos) != (double )0) {
#line 607
        if ((int )first == 1) {
          {
#line 608
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\trevised primal variables:");
#line 609
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s%16s%16s %s", "pos\'n",
                      "var (ndx)", "lb", "val", "ub", "status");
#line 612
          first = (bool )0;
          }
        }
        {
#line 613
        k = *(dy_basis + kpos);
#line 614
        tmp___39 = dy_prtvstat(*(dy_status + k));
#line 614
        tmp___40 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 614
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%14s (%3d)%16.8g%16.8g%16.8g %s",
                    kpos, tmp___40, k, *(dy_sys->vlb + k), *(dy_xbasic + kpos), *(dy_sys->vub + k),
                    tmp___39);
        }
      }
#line 605
      kpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 619
    if ((int )first == 1) {
      {
#line 620
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tno change to primal variables.");
      }
    }
  }
#line 627
  if ((int )retval == 0) {
#line 627
    retval = (dyret_enum )1;
  }
#line 628
  if ((unsigned long )p_abarj == (unsigned long )((void *)0)) {
    {
#line 628
    free((void *)abarj);
    }
  }
#line 630
  return (retval);
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_calcduals(void) 
{ 
  int xkpos ;
  int xkndx ;
  bool degenActive ;
  double *yvec ;
  int print ;
  char *rtnnme ;
  void *tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;

  {
#line 655
  rtnnme = (char *)"dy_calcduals";
  {
#line 658
  if ((unsigned int )dy_lp->phase == 2U) {
#line 658
    goto case_2;
  }
#line 661
  if ((unsigned int )dy_lp->phase == 3U) {
#line 661
    goto case_3;
  }
#line 664
  if ((unsigned int )dy_lp->phase == 4U) {
#line 664
    goto case_4;
  }
#line 667
  if ((unsigned int )dy_lp->phase == 10U) {
#line 667
    goto case_10;
  }
#line 673
  if ((unsigned int )dy_lp->phase == 1U) {
#line 673
    goto case_1;
  }
#line 679
  goto switch_default;
  case_2: /* CIL Label */ 
#line 659
  print = dy_opts->print.phase1;
#line 660
  goto switch_break;
  case_3: /* CIL Label */ 
#line 662
  print = dy_opts->print.phase2;
#line 663
  goto switch_break;
  case_4: /* CIL Label */ 
#line 665
  print = dy_opts->print.dual;
#line 666
  goto switch_break;
  case_10: /* CIL Label */ 
#line 668
  if (dy_opts->print.conmgmt >= 3) {
#line 669
    print = 7;
  } else {
#line 671
    print = 0;
  }
#line 672
  goto switch_break;
  case_1: /* CIL Label */ 
#line 674
  if (dy_opts->print.crash >= 4) {
#line 675
    print = 7;
  } else {
#line 677
    print = 0;
  }
#line 678
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 680
  print = 0;
#line 681
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 684
  if ((unsigned int )dy_lp->phase == 4U) {
#line 684
    if (dy_lp->degen > 0) {
#line 685
      degenActive = (bool )1;
    } else {
#line 687
      degenActive = (bool )0;
    }
  } else {
#line 687
    degenActive = (bool )0;
  }
#line 691
  if (dy_sys->concnt > 0) {
#line 692
    if ((int )degenActive == 1) {
      {
#line 693
      tmp = calloc((size_t )(dy_sys->concnt + 1), sizeof(double ));
#line 693
      yvec = (double *)tmp;
      }
    } else {
#line 695
      yvec = dy_y;
    }
#line 697
    xkpos = 1;
    {
#line 697
    while (1) {
      while_continue: /* CIL Label */ ;
#line 697
      if (! (xkpos <= dy_sys->concnt)) {
#line 697
        goto while_break;
      }
#line 698
      xkndx = *(dy_basis + xkpos);
#line 699
      *(yvec + xkpos) = *(dy_sys->obj + xkndx);
#line 697
      xkpos ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 700
    dy_btran(yvec);
#line 702
    dy_lp->dual.norm1 = exvec_1norm(yvec, dy_sys->concnt);
#line 703
    dy_lp->dual.norm2 = exvec_2norm(yvec, dy_sys->concnt);
#line 704
    dy_lp->dual.max = exvec_infnorm(yvec, dy_sys->concnt, & dy_lp->dual.maxndx);
#line 706
    dy_tols->dfeas = dy_lp->dual.max;
    }
#line 707
    if (dy_tols->dfeas < 10.0) {
#line 708
      dy_tols->dfeas = dy_tols->cost;
    } else {
      {
#line 710
      tmp___0 = log10(dy_tols->dfeas);
#line 710
      dy_tols->dfeas = tmp___0 * dy_tols->cost;
      }
    }
#line 711
    dy_tols->dfeas = dy_tols->dfeas_scale * dy_tols->dfeas;
#line 713
    if ((int )degenActive == 1) {
#line 714
      xkpos = 1;
      {
#line 714
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 714
        if (! (xkpos <= dy_sys->concnt)) {
#line 714
          goto while_break___0;
        }
#line 715
        if (*(dy_ddegenset + xkpos) == 0) {
#line 716
          *(dy_y + xkpos) = *(yvec + xkpos);
        }
#line 714
        xkpos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 717
      free((void *)yvec);
      }
    }
  } else {
#line 723
    dy_tols->dfeas = dy_tols->dfeas_scale * dy_tols->cost;
#line 724
    dy_lp->dual.norm1 = (double )1;
#line 725
    dy_lp->dual.norm2 = (double )1;
#line 726
    dy_lp->dual.max = (double )1;
  }
#line 729
  if (print >= 3) {
    {
#line 730
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: recalculated dual variables:", rtnnme);
#line 732
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tdual.max = %g, scale = %g, dzero = %g, dfeas = %g.",
                dy_lp->dual.max, dy_tols->dfeas_scale, dy_tols->cost, dy_tols->dfeas);
    }
#line 736
    if (print >= 7) {
      {
#line 737
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8s%20s%16s", "pos\'n", "constraint",
                  "val");
      }
#line 739
      if (degenActive) {
        {
#line 740
        dyio_outfmt(dy_logchn, dy_gtxecho, "%16s", "perturbation");
        }
      }
#line 741
      xkpos = 1;
      {
#line 741
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 741
        if (! (xkpos <= dy_sys->concnt)) {
#line 741
          goto while_break___1;
        }
        {
#line 742
        tmp___1 = consys_nme(dy_sys, (char )'c', xkpos, (bool )0, (char *)((void *)0));
#line 742
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n%8d%20s%16.8g", xkpos, tmp___1, *(dy_y + xkpos));
        }
#line 744
        if (degenActive) {
#line 744
          if (*(dy_ddegenset + xkpos) > 0) {
            {
#line 745
            dyio_outfmt(dy_logchn, dy_gtxecho, "%16.8g", *(dy_y + xkpos));
            }
          }
        }
#line 741
        xkpos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 746
      dyio_outchr(dy_logchn, dy_gtxecho, (char )'\n');
      }
    }
  }
#line 749
  return;
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
double dy_calcobj(void) 
{ 
  int vndx ;
  double z ;
  double tmp ;

  {
#line 780
  z = 0.0;
#line 781
  vndx = 1;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! (vndx <= dy_sys->varcnt)) {
#line 781
      goto while_break;
    }
#line 782
    if (*(dy_x + vndx) != 0.0) {
#line 782
      z += *(dy_sys->obj + vndx) * *(dy_x + vndx);
    }
#line 781
    vndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  if ((int )dy_lp->p1obj.installed == 0) {
#line 783
    z += dy_lp->inactzcorr;
  }
  {
#line 784
  tmp = fabs(z);
  }
#line 784
  if (tmp < dy_tols->zero) {
#line 784
    z = (double )0;
  }
#line 786
  return (z);
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
double dy_calcdualobj(void) 
{ 
  int i ;
  int j ;
  int m ;
  int n ;
  flags statj ;
  double z ;
  double bndj ;
  double cbarj ;
  double *rhs ;
  double *vlb ;
  double *vub ;
  char const   *rtnnme ;
  int tmp ;
  double tmp___0 ;

  {
#line 815
  rtnnme = "dy_calcdualobj";
#line 838
  z = 0.0;
#line 840
  m = dy_sys->concnt;
#line 841
  n = dy_sys->varcnt;
#line 842
  rhs = dy_sys->rhs;
#line 843
  vlb = dy_sys->vlb;
#line 844
  vub = dy_sys->vub;
#line 851
  i = 1;
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (i <= m)) {
#line 851
      goto while_break;
    }
#line 852
    j = *(dy_basis + i);
#line 853
    if (*(dy_ddegenset + j) == 0) {
#line 853
      if (*(dy_y + i) != (double )0) {
#line 854
        z += *(dy_y + i) * *(rhs + i);
      }
    }
#line 851
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 873
  j = 1;
  {
#line 873
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 873
    if (! (j <= n)) {
#line 873
      goto while_break___0;
    }
#line 874
    if (*(dy_ddegenset + j) > 0) {
#line 874
      goto __Cont;
    }
#line 875
    statj = *(dy_status + j) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 876
    if (statj & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 876
      tmp = 1;
    } else {
#line 876
      tmp = 0;
    }
#line 876
    if (tmp) {
#line 876
      goto __Cont;
    }
#line 877
    cbarj = *(dy_cbar + j);
#line 878
    if (cbarj == (double )0) {
#line 878
      goto __Cont;
    }
    {
#line 881
    if (statj == (flags )(1 << 5)) {
#line 881
      goto case_exp;
    }
#line 881
    if (statj == (flags )(1 << 7)) {
#line 881
      goto case_exp;
    }
#line 884
    if (statj == (flags )(1 << 6)) {
#line 884
      goto case_exp___1;
    }
#line 888
    if (statj == (flags )(1 << 9)) {
#line 888
      goto case_exp___2;
    }
#line 888
    if (statj == (flags )(1 << 8)) {
#line 888
      goto case_exp___2;
    }
#line 891
    goto switch_default;
    case_exp: /* CIL Label */ 
    case_exp___0: /* CIL Label */ 
#line 882
    bndj = *(vlb + j);
#line 883
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 885
    bndj = *(vub + j);
#line 886
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    case_exp___3: /* CIL Label */ 
#line 889
    bndj = (double )0;
#line 890
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 892
    errmsg(1, rtnnme, 892);
    }
#line 893
    return (QNaNbits___6.fpdbl);
    switch_break: /* CIL Label */ ;
    }
#line 894
    if (bndj != (double )0) {
#line 894
      z += cbarj * bndj;
    }
    __Cont: /* CIL Label */ 
#line 873
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 895
  if ((int )dy_lp->p1obj.installed == 0) {
#line 895
    z += dy_lp->inactzcorr;
  }
  {
#line 899
  tmp___0 = fabs(z);
  }
#line 899
  if (tmp___0 < dy_tols->zero) {
#line 899
    z = (double )0;
  }
#line 901
  return (z);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
double dy_calcpinfeas(void) 
{ 
  int k ;
  int n ;
  double infeas ;
  double xk ;
  double ubk ;
  double lbk ;
  flags statk ;
  double *vub ;
  double *vlb ;
  int tmp ;
  int tmp___0 ;

  {
#line 921
  n = dy_sys->varcnt;
#line 922
  vub = dy_sys->vub;
#line 923
  vlb = dy_sys->vlb;
#line 925
  infeas = (double )0;
#line 926
  k = 1;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    if (! (k <= n)) {
#line 926
      goto while_break;
    }
#line 927
    statk = *(dy_status + k);
#line 928
    if (statk & (unsigned int )(1 << 11)) {
#line 928
      tmp___0 = 1;
    } else {
#line 928
      tmp___0 = 0;
    }
#line 928
    if (tmp___0) {
#line 929
      lbk = *(vlb + k);
#line 930
      xk = *(dy_x + k);
#line 931
      infeas += lbk - xk;
    } else {
#line 933
      if (statk & (unsigned int )(1 << 10)) {
#line 933
        tmp = 1;
      } else {
#line 933
        tmp = 0;
      }
#line 933
      if (tmp) {
#line 934
        ubk = *(vub + k);
#line 935
        xk = *(dy_x + k);
#line 936
        infeas += xk - ubk;
      }
    }
#line 926
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  return (infeas);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
bool dy_calccbar(void) 
{ 
  int xjndx ;
  double cbarj ;
  double tmp ;

  {
#line 975
  xjndx = 1;
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
#line 975
    if (! (xjndx <= dy_sys->varcnt)) {
#line 975
      goto while_break;
    }
#line 979
    if (*(dy_var2basis + xjndx) > 0) {
#line 980
      *(dy_cbar + xjndx) = (double )0;
#line 981
      goto __Cont;
    }
    {
#line 998
    cbarj = consys_dotcol(dy_sys, xjndx, dy_y);
#line 1005
    *(dy_cbar + xjndx) = *(dy_sys->obj + xjndx) - cbarj;
#line 1006
    tmp = fabs(*(dy_cbar + xjndx));
    }
#line 1006
    if (tmp < dy_tols->cost) {
#line 1006
      *(dy_cbar + xjndx) = (double )0;
    }
    __Cont: /* CIL Label */ 
#line 975
    xjndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return ((bool )1);
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_setbasicstatus(void) 
{ 
  int xindx ;
  int bpos ;
  double xi ;
  double ubi ;
  double lbi ;
  flags xistatus ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;

  {
#line 1031
  bpos = 1;
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    if (! (bpos <= dy_sys->concnt)) {
#line 1031
      goto while_break;
    }
#line 1032
    xindx = *(dy_basis + bpos);
#line 1033
    xi = *(dy_x + xindx);
#line 1034
    xistatus = *(dy_status + xindx);
#line 1035
    lbi = *(dy_sys->vlb + xindx);
#line 1036
    ubi = *(dy_sys->vub + xindx);
#line 1037
    if (xistatus & (unsigned int )(1 << 4)) {
#line 1037
      tmp___13 = 0;
    } else {
#line 1037
      tmp___13 = 1;
    }
#line 1037
    if (tmp___13) {
      {
#line 1038
      tmp___12 = fabs(lbi);
      }
#line 1038
      if (tmp___12 < dy_tols->inf) {
        {
#line 1038
        tmp___10 = fabs(lbi);
#line 1038
        tmp___11 = lbi - xi > dy_tols->pfeas * (1.0 + tmp___10);
        }
      } else {
#line 1038
        tmp___11 = xi < lbi;
      }
#line 1038
      if (tmp___11) {
#line 1039
        *(dy_status + xindx) = (flags )(1 << 11);
      } else {
        {
#line 1041
        tmp___6 = fabs(lbi);
        }
#line 1041
        if (tmp___6 < dy_tols->inf) {
          {
#line 1041
          tmp___7 = fabs(xi - lbi);
#line 1041
          tmp___8 = fabs(lbi);
          }
#line 1041
          if (tmp___7 < dy_tols->pfeas * (1.0 + tmp___8)) {
#line 1042
            if (lbi == ubi) {
#line 1043
              *(dy_status + xindx) = (flags )1;
            } else {
#line 1045
              *(dy_status + xindx) = (flags )(1 << 3);
            }
#line 1046
            *(dy_x + xindx) = lbi;
#line 1047
            *(dy_xbasic + bpos) = lbi;
          } else {
#line 1041
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1049
          tmp___5 = fabs(ubi);
          }
#line 1049
          if (tmp___5 < dy_tols->inf) {
            {
#line 1049
            tmp___3 = fabs(ubi);
#line 1049
            tmp___4 = ubi - xi > dy_tols->pfeas * (1.0 + tmp___3);
            }
          } else {
#line 1049
            tmp___4 = xi < ubi;
          }
#line 1049
          if (tmp___4) {
#line 1050
            *(dy_status + xindx) = (flags )(1 << 2);
          } else {
            {
#line 1052
            tmp = fabs(ubi);
            }
#line 1052
            if (tmp < dy_tols->inf) {
              {
#line 1052
              tmp___0 = fabs(xi - ubi);
#line 1052
              tmp___1 = fabs(ubi);
              }
#line 1052
              if (tmp___0 < dy_tols->pfeas * (1.0 + tmp___1)) {
#line 1053
                *(dy_status + xindx) = (flags )(1 << 1);
#line 1054
                *(dy_x + xindx) = ubi;
#line 1055
                *(dy_xbasic + bpos) = ubi;
              } else {
#line 1057
                *(dy_status + xindx) = (flags )(1 << 10);
              }
            } else {
#line 1057
              *(dy_status + xindx) = (flags )(1 << 10);
            }
          }
        }
      }
    }
#line 1059
    if (xistatus != *(dy_status + xindx)) {
#line 1060
      if ((unsigned int )dy_lp->phase != 7U) {
#line 1060
        if (dy_opts->print.basis >= 3) {
          {
#line 1062
          tmp___14 = dy_prtvstat(xistatus);
#line 1062
          tmp___15 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1062
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s ", tmp___15,
                      xindx, xi, tmp___14);
#line 1065
          tmp___16 = dy_prtvstat(*(dy_status + xindx));
#line 1065
          dyio_outfmt(dy_logchn, dy_gtxecho, "corrected to %s.", tmp___16);
          }
        } else {
#line 1060
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1060
      if ((unsigned int )dy_lp->phase == 7U) {
#line 1060
        if (dy_opts->print.varmgmt >= 3) {
          {
#line 1062
          tmp___14 = dy_prtvstat(xistatus);
#line 1062
          tmp___15 = consys_nme(dy_sys, (char )'v', xindx, (bool )0, (char *)((void *)0));
#line 1062
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) = %g, status %s ", tmp___15,
                      xindx, xi, tmp___14);
#line 1065
          tmp___16 = dy_prtvstat(*(dy_status + xindx));
#line 1065
          dyio_outfmt(dy_logchn, dy_gtxecho, "corrected to %s.", tmp___16);
          }
        }
      }
    }
#line 1031
    bpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return;
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_dseinit(void) 
{ 
  int xkpos ;
  double *betak ;
  char const   *tmp ;
  void *tmp___0 ;

  {
#line 1090
  if (dy_opts->print.dual >= 2) {
    {
#line 1091
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1091
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   (%s)%d: initialising ||beta<k>||^2 for DSE.",
                tmp, dy_lp->tot.iters);
    }
  }
  {
#line 1099
  tmp___0 = malloc((unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 1099
  betak = (double *)tmp___0;
#line 1107
  xkpos = 1;
  }
  {
#line 1107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1107
    if (! (xkpos <= dy_sys->concnt)) {
#line 1107
      goto while_break;
    }
    {
#line 1108
    memset((void *)betak, 0, (unsigned long )(dy_sys->concnt + 1) * sizeof(double ));
#line 1109
    *(betak + xkpos) = 1.0;
#line 1110
    dy_btran(betak);
#line 1111
    *(dy_rho + xkpos) = exvec_ssq(betak, dy_sys->concnt);
#line 1107
    xkpos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1115
  free((void *)betak);
  }
#line 1117
  return;
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_pseinit(void) 
{ 
  int xindx ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1136
  if (dy_opts->print.phase1 >= 2) {
    {
#line 1137
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1137
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   (%s)%d: initialising ||abar~<k>||^2 for PSE.",
                tmp, dy_lp->tot.iters);
    }
  } else
#line 1136
  if (dy_opts->print.phase2 >= 2) {
    {
#line 1137
    tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1137
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n   (%s)%d: initialising ||abar~<k>||^2 for PSE.",
                tmp, dy_lp->tot.iters);
    }
  }
  {
#line 1142
  memset((void *)dy_frame, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(bool ));
#line 1143
  memset((void *)dy_gamma, 0, (unsigned long )(dy_sys->varcnt + 1) * sizeof(double ));
#line 1145
  xindx = 1;
  }
  {
#line 1145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1145
    if (! (xindx <= dy_sys->varcnt)) {
#line 1145
      goto while_break;
    }
#line 1146
    if (*(dy_status + xindx) & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | (1 << 8))) {
#line 1146
      tmp___0 = 1;
    } else {
#line 1146
      tmp___0 = 0;
    }
#line 1146
    if (tmp___0) {
#line 1147
      *(dy_frame + xindx) = (bool )1;
#line 1148
      *(dy_gamma + xindx) = 1.0;
    }
#line 1145
    xindx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1150
  return;
}
}
#line 1996 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
bool dy_dupbasis(int dst_basissze , basis_struct **p_dst_basis , basis_struct *src_basis ,
                 int dst_statussze , flags **p_dst_status , int src_statuslen , flags *src_status ) 
{ 
  basis_struct *dst_basis ;
  bool want_basis ;
  bool want_status ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2048
  if ((unsigned long )p_dst_basis != (unsigned long )((void *)0)) {
#line 2049
    want_basis = (bool )1;
  } else {
#line 2051
    want_basis = (bool )0;
  }
#line 2052
  if ((unsigned long )p_dst_status != (unsigned long )((void *)0)) {
#line 2053
    want_status = (bool )1;
  } else {
#line 2055
    want_status = (bool )0;
  }
#line 2061
  if ((int )want_basis == 1) {
#line 2062
    if ((unsigned long )*p_dst_basis != (unsigned long )((void *)0)) {
#line 2063
      dst_basis = *p_dst_basis;
#line 2064
      if (dst_basissze < dst_basis->len) {
#line 2064
        dst_basissze = dst_basis->len;
      }
#line 2065
      if (dst_basis->len < src_basis->len) {
#line 2065
        goto _L;
      } else
#line 2065
      if (dst_basis->len < dst_basissze) {
        _L: /* CIL Label */ 
#line 2065
        if ((unsigned long )dst_basis->el != (unsigned long )((void *)0)) {
          {
#line 2067
          free((void *)dst_basis->el);
#line 2068
          dst_basis->el = (basisel_struct *)((void *)0);
          }
        }
      }
    } else {
      {
#line 2070
      tmp = calloc((size_t )1, sizeof(basis_struct ));
#line 2070
      dst_basis = (basis_struct *)tmp;
#line 2071
      *p_dst_basis = dst_basis;
      }
    }
#line 2073
    if (dst_basissze < src_basis->len) {
#line 2078
      dst_basissze = src_basis->len;
    }
#line 2079
    if ((unsigned long )dst_basis->el == (unsigned long )((void *)0)) {
      {
#line 2080
      tmp___0 = malloc((unsigned long )(dst_basissze + 1) * sizeof(basisel_struct ));
#line 2080
      dst_basis->el = (basisel_struct *)tmp___0;
      }
    }
    {
#line 2083
    memcpy((void */* __restrict  */)dst_basis->el, (void const   */* __restrict  */)src_basis->el,
           (unsigned long )(src_basis->len + 1) * sizeof(basisel_struct ));
#line 2085
    dst_basis->len = src_basis->len;
    }
  }
#line 2090
  if ((int )want_status == 1) {
#line 2091
    if ((unsigned long )*p_dst_status == (unsigned long )((void *)0)) {
#line 2093
      if (dst_statussze < src_statuslen) {
#line 2098
        dst_statussze = src_statuslen;
      }
      {
#line 2099
      tmp___1 = malloc((unsigned long )(dst_statussze + 1) * sizeof(flags ));
#line 2099
      *p_dst_status = (flags *)tmp___1;
      }
    }
    {
#line 2100
    memcpy((void */* __restrict  */)*p_dst_status, (void const   */* __restrict  */)src_status,
           (unsigned long )(src_statuslen + 1) * sizeof(flags ));
    }
  }
#line 2102
  return ((bool )1);
}
}
#line 2106 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
static void build_soln(lpprob_struct *orig_lp ) 
{ 
  int ovndx ;
  int xjndx ;
  int xjpos ;
  int ubndndx ;
  int orig_ubndndx ;
  flags xjstatus ;
  consys_struct *orig_sys ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 2138
  rtnnme = "build_soln";
#line 2157
  orig_sys = orig_lp->consys;
#line 2158
  if (orig_lp->colsze < orig_sys->varcnt) {
#line 2159
    if ((unsigned long )orig_lp->status != (unsigned long )((void *)0)) {
      {
#line 2160
      free((void *)orig_lp->status);
#line 2161
      orig_lp->status = (flags *)((void *)0);
      }
    }
#line 2162
    if ((unsigned long )orig_lp->actvars != (unsigned long )((void *)0)) {
      {
#line 2163
      free((void *)orig_lp->actvars);
#line 2164
      orig_lp->actvars = (bool *)((void *)0);
      }
    }
#line 2165
    orig_lp->colsze = orig_sys->varcnt;
  }
#line 2166
  if ((unsigned long )orig_lp->status == (unsigned long )((void *)0)) {
    {
#line 2167
    tmp = calloc((size_t )(orig_lp->colsze + 1), sizeof(flags ));
#line 2167
    orig_lp->status = (flags *)tmp;
    }
  }
#line 2168
  if (orig_lp->ctlopts & (unsigned int )(1 << 10)) {
#line 2168
    tmp___1 = 1;
  } else {
#line 2168
    tmp___1 = 0;
  }
#line 2168
  if (tmp___1) {
#line 2169
    if ((unsigned long )orig_lp->actvars == (unsigned long )((void *)0)) {
      {
#line 2170
      tmp___0 = calloc((size_t )(orig_lp->colsze + 1), sizeof(bool ));
#line 2170
      orig_lp->actvars = (bool *)tmp___0;
      }
    }
  }
#line 2172
  if (orig_lp->rowsze < dy_sys->concnt) {
#line 2173
    if ((unsigned long )orig_lp->x != (unsigned long )((void *)0)) {
      {
#line 2174
      free((void *)orig_lp->x);
#line 2175
      orig_lp->x = (double *)((void *)0);
      }
    }
#line 2176
    if ((unsigned long )orig_lp->y != (unsigned long )((void *)0)) {
      {
#line 2177
      free((void *)orig_lp->y);
#line 2178
      orig_lp->y = (double *)((void *)0);
      }
    }
#line 2179
    if ((unsigned long )orig_lp->basis != (unsigned long )((void *)0)) {
#line 2180
      if ((unsigned long )(orig_lp->basis)->el != (unsigned long )((void *)0)) {
        {
#line 2181
        free((void *)(orig_lp->basis)->el);
#line 2182
        (orig_lp->basis)->el = (basisel_struct *)((void *)0);
        }
      }
    }
#line 2183
    orig_lp->rowsze = dy_sys->concnt;
  }
#line 2184
  if ((unsigned long )orig_lp->basis == (unsigned long )((void *)0)) {
    {
#line 2185
    tmp___2 = calloc(sizeof(basis_struct ), (size_t )1);
#line 2185
    orig_lp->basis = (basis_struct *)tmp___2;
    }
  }
#line 2186
  if ((unsigned long )(orig_lp->basis)->el == (unsigned long )((void *)0)) {
    {
#line 2187
    tmp___3 = calloc((size_t )(orig_lp->rowsze + 1), sizeof(basisel_struct ));
#line 2187
    (orig_lp->basis)->el = (basisel_struct *)tmp___3;
    }
  }
#line 2189
  if ((unsigned long )orig_lp->x == (unsigned long )((void *)0)) {
    {
#line 2190
    tmp___4 = calloc((size_t )(orig_lp->rowsze + 1), sizeof(double ));
#line 2190
    orig_lp->x = (double *)tmp___4;
    }
  }
#line 2191
  if ((unsigned long )orig_lp->y == (unsigned long )((void *)0)) {
    {
#line 2192
    tmp___5 = calloc((size_t )(orig_lp->rowsze + 1), sizeof(double ));
#line 2192
    orig_lp->y = (double *)tmp___5;
    }
  }
  {
#line 2209
  if ((int )dy_lp->lpret == 1) {
#line 2209
    goto case_1;
  }
#line 2212
  if ((int )dy_lp->lpret == 7) {
#line 2212
    goto case_7;
  }
#line 2228
  if ((int )dy_lp->lpret == 2) {
#line 2228
    goto case_2;
  }
#line 2239
  if ((int )dy_lp->lpret == 4) {
#line 2239
    goto case_4;
  }
#line 2242
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2210
  orig_lp->obj = dy_calcobj();
  }
#line 2211
  goto switch_break;
  case_7: /* CIL Label */ 
#line 2213
  if ((int )dy_lp->p1obj.installed == 1) {
    {
#line 2214
    tmp___9 = dy_swapobjs((dyphase_enum )3);
    }
#line 2214
    if ((int )tmp___9 == 0) {
      {
#line 2215
      tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2215
      errmsg(318, rtnnme, dy_sys->nme, tmp___6, dy_lp->tot.iters, "remove");
#line 2218
      dy_lp->lpret = (lpret_enum )-1;
      }
    } else {
      {
#line 2220
      dy_calcduals();
#line 2221
      tmp___8 = dy_calccbar();
      }
#line 2221
      if ((int )tmp___8 == 0) {
        {
#line 2222
        tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 2222
        errmsg(384, rtnnme, dy_sys->nme, tmp___7, dy_lp->tot.iters);
#line 2224
        dy_lp->lpret = (lpret_enum )-1;
        }
      }
    }
  }
#line 2225
  if ((int )dy_lp->lpret == -1) {
#line 2226
    orig_lp->obj = dy_tols->inf;
  }
#line 2227
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2229
  ubndndx = abs(dy_lp->ubnd.ndx);
  }
#line 2230
  if (ubndndx > dy_sys->concnt) {
#line 2231
    orig_ubndndx = *(dy_actvars + ubndndx);
  } else {
#line 2233
    orig_ubndndx = orig_sys->varcnt + *(dy_actcons + ubndndx);
  }
#line 2234
  if (dy_lp->ubnd.ndx < 0) {
#line 2235
    orig_lp->obj = - ((double )orig_ubndndx);
  } else {
#line 2237
    orig_lp->obj = (double )orig_ubndndx;
  }
#line 2238
  goto switch_break;
  case_4: /* CIL Label */ 
#line 2240
  orig_lp->obj = dy_lp->infeas;
#line 2241
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2243
  orig_lp->obj = dy_tols->inf;
#line 2244
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2245
  orig_lp->lpret = dy_lp->lpret;
#line 2246
  orig_lp->iters = dy_lp->tot.pivs;
#line 2264
  ovndx = 1;
  {
#line 2264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2264
    if (! (ovndx <= orig_sys->varcnt)) {
#line 2264
      goto while_break;
    }
#line 2265
    if (*(dy_origvars + ovndx) <= 0) {
#line 2266
      xjstatus = (flags )(- *(dy_origvars + ovndx));
#line 2267
      *(orig_lp->status + ovndx) = xjstatus & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 2268
      if (orig_lp->ctlopts & (unsigned int )(1 << 10)) {
#line 2268
        tmp___10 = 1;
      } else {
#line 2268
        tmp___10 = 0;
      }
#line 2268
      if (tmp___10) {
#line 2269
        *(orig_lp->actvars + ovndx) = (bool )0;
      }
    } else {
#line 2271
      if (orig_lp->ctlopts & (unsigned int )(1 << 10)) {
#line 2271
        tmp___11 = 1;
      } else {
#line 2271
        tmp___11 = 0;
      }
#line 2271
      if (tmp___11) {
#line 2272
        *(orig_lp->actvars + ovndx) = (bool )1;
      }
#line 2273
      xjndx = *(dy_origvars + ovndx);
#line 2274
      xjstatus = *(dy_status + xjndx);
#line 2275
      if (xjstatus & (unsigned int )((((1 << 5) | (1 << 6)) | (1 << 7)) | ((1 << 9) | (1 << 8)))) {
#line 2275
        tmp___17 = 1;
      } else {
#line 2275
        tmp___17 = 0;
      }
#line 2275
      if (tmp___17) {
#line 2276
        if (xjstatus & (unsigned int )(1 << 9)) {
#line 2276
          tmp___16 = 1;
        } else {
#line 2276
          tmp___16 = 0;
        }
#line 2276
        if (tmp___16) {
#line 2277
          if ((int )dy_lp->lpret == 1) {
            {
#line 2278
            tmp___12 = dy_prtvstat(xjstatus);
#line 2278
            tmp___13 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2278
            errmsg(359, rtnnme, dy_sys->nme, tmp___13, xjndx, tmp___12);
            }
          } else {
            {
#line 2283
            tmp___14 = dy_prtvstat(xjstatus);
#line 2283
            tmp___15 = consys_nme(dy_sys, (char )'v', xjndx, (bool )0, (char *)((void *)0));
#line 2283
            warn(359, rtnnme, dy_sys->nme, tmp___15, xjndx, tmp___14);
            }
          }
        }
#line 2288
        *(orig_lp->status + ovndx) = xjstatus;
      } else {
#line 2290
        xjpos = *(dy_var2basis + xjndx);
#line 2291
        *(orig_lp->status + ovndx) = (flags )(- xjpos);
#line 2292
        ((orig_lp->basis)->el + xjpos)->cndx = *(dy_actcons + xjpos);
#line 2293
        ((orig_lp->basis)->el + xjpos)->vndx = ovndx;
#line 2294
        *(orig_lp->x + xjpos) = *(dy_x + xjndx);
#line 2295
        *(orig_lp->y + xjpos) = *(dy_y + xjpos);
      }
    }
#line 2264
    ovndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2299
  xjpos = 1;
  {
#line 2299
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2299
    if (! (xjpos <= dy_sys->concnt)) {
#line 2299
      goto while_break___0;
    }
#line 2300
    if (*(dy_basis + xjpos) <= dy_sys->concnt) {
#line 2301
      ((orig_lp->basis)->el + xjpos)->cndx = *(dy_actcons + xjpos);
#line 2302
      ((orig_lp->basis)->el + xjpos)->vndx = - *(dy_actcons + *(dy_basis + xjpos));
#line 2303
      *(orig_lp->x + xjpos) = *(dy_xbasic + xjpos);
#line 2304
      *(orig_lp->y + xjpos) = *(dy_y + xjpos);
    }
#line 2299
    xjpos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2308
  dy_orig_soln(orig_lp->x, orig_lp->y);
#line 2312
  (orig_lp->basis)->len = dy_sys->concnt;
  }
#line 2314
  return;
}
}
#line 2325 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_finishup(lpprob_struct *orig_lp , dyphase_enum phase ) 
{ 
  consys_struct *orig_sys ;
  int tmp ;
  int tmp___0 ;

  {
#line 2360
  if ((unsigned int )orig_lp->phase == 14U) {
#line 2360
    if ((unsigned int )phase == 0U) {
#line 2360
      if (orig_lp->ctlopts & (unsigned int )(1 << 1)) {
#line 2360
        tmp = 1;
      } else {
#line 2360
        tmp = 0;
      }
#line 2360
      if (tmp) {
        {
#line 2362
        orig_lp->ctlopts &= (unsigned int )(~ (1 << 10));
#line 2363
        dy_initlclsystem(orig_lp, (bool )1);
        }
      } else {
#line 2360
        goto _L___2;
      }
    } else {
#line 2360
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2365
  if ((unsigned int )orig_lp->phase == 1U) {
#line 2365
    if ((unsigned int )phase == 1U) {
#line 2365
      if ((int )orig_lp->lpret == 0) {
        {
#line 2366
        dy_initlclsystem(orig_lp, (bool )1);
        }
      } else {
#line 2365
        goto _L___0;
      }
    } else {
#line 2365
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2368
  if ((unsigned int )orig_lp->phase == 14U) {
    {
#line 2369
    build_soln(orig_lp);
    }
  } else {
#line 2371
    orig_lp->ctlopts &= (unsigned int )(~ (1 << 10));
  }
#line 2387
  if (orig_lp->ctlopts & 1U) {
#line 2387
    tmp___0 = 0;
  } else {
#line 2387
    tmp___0 = 1;
  }
#line 2387
  if (tmp___0) {
#line 2387
    goto _L___3;
  } else
#line 2387
  if ((int )orig_lp->lpret == 1) {
    {
#line 2426
    orig_lp->ctlopts |= (unsigned int )(1 << 11);
#line 2427
    dy_freelclsystem(orig_lp, (bool )0);
#line 2428
    dy_retained = (bool )1;
    }
  } else
#line 2387
  if ((int )orig_lp->lpret == 2) {
    {
#line 2426
    orig_lp->ctlopts |= (unsigned int )(1 << 11);
#line 2427
    dy_freelclsystem(orig_lp, (bool )0);
#line 2428
    dy_retained = (bool )1;
    }
  } else
#line 2387
  if ((int )orig_lp->lpret == 4) {
    {
#line 2426
    orig_lp->ctlopts |= (unsigned int )(1 << 11);
#line 2427
    dy_freelclsystem(orig_lp, (bool )0);
#line 2428
    dy_retained = (bool )1;
    }
  } else
#line 2387
  if ((int )orig_lp->lpret == 7) {
    {
#line 2426
    orig_lp->ctlopts |= (unsigned int )(1 << 11);
#line 2427
    dy_freelclsystem(orig_lp, (bool )0);
#line 2428
    dy_retained = (bool )1;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 2390
    orig_sys = orig_lp->consys;
#line 2391
    if ((unsigned long )dy_origvars != (unsigned long )((void *)0)) {
      {
#line 2392
      consys_detach(orig_sys, (void **)(& dy_origvars), (bool )1);
#line 2393
      free((void *)dy_origvars);
#line 2394
      dy_origvars = (int *)((void *)0);
      }
    }
#line 2395
    if ((unsigned long )dy_origcons != (unsigned long )((void *)0)) {
      {
#line 2396
      consys_detach(orig_sys, (void **)(& dy_origcons), (bool )1);
#line 2397
      free((void *)dy_origcons);
#line 2398
      dy_origcons = (int *)((void *)0);
      }
    }
    {
#line 2399
    dy_freelclsystem(orig_lp, (bool )1);
    }
#line 2400
    if ((unsigned long )dy_lp != (unsigned long )((void *)0)) {
      {
#line 2400
      dy_swapobjs((dyphase_enum )14);
      }
    }
#line 2401
    if ((unsigned long )dy_sys != (unsigned long )((void *)0)) {
      {
#line 2402
      consys_free(dy_sys);
#line 2403
      dy_sys = (consys_struct *)((void *)0);
      }
    }
#line 2404
    if ((unsigned long )dy_actvars != (unsigned long )((void *)0)) {
      {
#line 2404
      free((void *)dy_actvars);
#line 2404
      dy_actvars = (int *)((void *)0);
      }
    }
#line 2405
    if ((unsigned long )dy_actcons != (unsigned long )((void *)0)) {
      {
#line 2405
      free((void *)dy_actcons);
#line 2405
      dy_actcons = (int *)((void *)0);
      }
    }
#line 2406
    if ((unsigned long )dy_basis != (unsigned long )((void *)0)) {
      {
#line 2406
      free((void *)dy_basis);
#line 2406
      dy_basis = (int *)((void *)0);
      }
    }
#line 2407
    if ((unsigned long )dy_var2basis != (unsigned long )((void *)0)) {
      {
#line 2407
      free((void *)dy_var2basis);
#line 2407
      dy_var2basis = (int *)((void *)0);
      }
    }
#line 2408
    if ((unsigned long )dy_status != (unsigned long )((void *)0)) {
      {
#line 2408
      free((void *)dy_status);
#line 2408
      dy_status = (flags *)((void *)0);
      }
    }
#line 2409
    if ((unsigned long )dy_x != (unsigned long )((void *)0)) {
      {
#line 2409
      free((void *)dy_x);
#line 2409
      dy_x = (double *)((void *)0);
      }
    }
#line 2410
    if ((unsigned long )dy_xbasic != (unsigned long )((void *)0)) {
      {
#line 2410
      free((void *)dy_xbasic);
#line 2410
      dy_xbasic = (double *)((void *)0);
      }
    }
#line 2411
    if ((unsigned long )dy_y != (unsigned long )((void *)0)) {
      {
#line 2411
      free((void *)dy_y);
#line 2411
      dy_y = (double *)((void *)0);
      }
    }
#line 2412
    if ((unsigned long )dy_frame != (unsigned long )((void *)0)) {
      {
#line 2412
      free((void *)dy_frame);
#line 2412
      dy_frame = (bool *)((void *)0);
      }
    }
#line 2413
    if ((unsigned long )dy_gamma != (unsigned long )((void *)0)) {
      {
#line 2413
      free((void *)dy_gamma);
#line 2413
      dy_gamma = (double *)((void *)0);
      }
    }
#line 2414
    if ((unsigned long )dy_cbar != (unsigned long )((void *)0)) {
      {
#line 2414
      free((void *)dy_cbar);
#line 2414
      dy_cbar = (double *)((void *)0);
      }
    }
#line 2415
    if ((unsigned long )dy_rho != (unsigned long )((void *)0)) {
      {
#line 2415
      free((void *)dy_rho);
#line 2415
      dy_rho = (double *)((void *)0);
      }
    }
#line 2416
    if ((unsigned long )dy_brkout != (unsigned long )((void *)0)) {
      {
#line 2416
      free((void *)dy_brkout);
#line 2416
      dy_brkout = (int *)((void *)0);
      }
    }
#line 2417
    if ((unsigned long )dy_degenset != (unsigned long )((void *)0)) {
      {
#line 2417
      free((void *)dy_degenset);
#line 2417
      dy_degenset = (int *)((void *)0);
      }
    }
#line 2418
    if ((unsigned long )dy_ddegenset != (unsigned long )((void *)0)) {
      {
#line 2418
      free((void *)dy_ddegenset);
#line 2418
      dy_ddegenset = (int *)((void *)0);
      }
    }
    {
#line 2419
    dy_freepivrej();
    }
#line 2420
    if ((unsigned long )dy_lp != (unsigned long )((void *)0)) {
      {
#line 2420
      free((void *)dy_lp);
#line 2420
      dy_lp = (lp_struct *)((void *)0);
      }
    }
#line 2421
    if ((unsigned long )dy_tols != (unsigned long )((void *)0)) {
      {
#line 2421
      free((void *)dy_tols);
#line 2421
      dy_tols = (lptols_struct *)((void *)0);
      }
    }
#line 2422
    if ((unsigned long )dy_opts != (unsigned long )((void *)0)) {
      {
#line 2422
      free((void *)dy_opts);
#line 2422
      dy_opts = (lpopts_struct *)((void *)0);
      }
    }
#line 2423
    orig_lp->ctlopts &= (unsigned int )(~ (1 << 11));
#line 2424
    dy_retained = (bool )0;
  }
#line 2430
  return;
}
}
#line 2436 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp_utils.c"
void dy_freesoln(lpprob_struct *lpprob ) 
{ 


  {
#line 2448
  if ((unsigned long )lpprob->basis != (unsigned long )((void *)0)) {
#line 2449
    if ((unsigned long )(lpprob->basis)->el != (unsigned long )((void *)0)) {
      {
#line 2449
      free((void *)(lpprob->basis)->el);
      }
    }
    {
#line 2450
    free((void *)lpprob->basis);
#line 2451
    lpprob->basis = (basis_struct *)((void *)0);
    }
  }
#line 2452
  if ((unsigned long )lpprob->status != (unsigned long )((void *)0)) {
    {
#line 2453
    free((void *)lpprob->status);
#line 2454
    lpprob->status = (flags *)((void *)0);
    }
  }
#line 2455
  if ((unsigned long )lpprob->x != (unsigned long )((void *)0)) {
    {
#line 2456
    free((void *)lpprob->x);
#line 2457
    lpprob->x = (double *)((void *)0);
    }
  }
#line 2458
  if ((unsigned long )lpprob->y != (unsigned long )((void *)0)) {
    {
#line 2459
    free((void *)lpprob->y);
#line 2460
    lpprob->y = (double *)((void *)0);
    }
  }
#line 2461
  if ((unsigned long )lpprob->actvars != (unsigned long )((void *)0)) {
    {
#line 2462
    free((void *)lpprob->actvars);
#line 2463
    lpprob->ctlopts &= (unsigned int )(~ ((1 << 6) | (1 << 10)));
#line 2464
    lpprob->actvars = (bool *)((void *)0);
    }
  }
#line 2465
  lpprob->colsze = 0;
#line 2466
  lpprob->rowsze = 0;
#line 2468
  return;
}
}
#line 230 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnan)(double __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanf)(float __value )  __attribute__((__const__)) ;
#line 230
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __isnanl)(long double __value )  __attribute__((__const__)) ;
#line 243 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
bool pkvec_resize(pkvec_struct *pkvec , int sze ) ;
#line 246
bool pkvec_check(pkvec_struct *pkvec , char const   *caller ) ;
#line 248
double pkvec_2norm(pkvec_struct *vec ) ;
#line 255
double pkvec_dotexvec(pkvec_struct *pkvec , double *exvec ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
static char const   *noname  =    "<<n/a>>";
#line 33 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
pkvec_struct *pkvec_new(int sze ) 
{ 
  pkvec_struct *pkvec ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 46
  rtnnme = "pkvec_new";
#line 48
  if (sze < 0) {
#line 48
    sze = 0;
  }
  {
#line 49
  tmp = calloc((size_t )1, sizeof(pkvec_struct ));
#line 49
  pkvec = (pkvec_struct *)tmp;
#line 50
  pkvec->sze = sze;
#line 51
  pkvec->nme = noname;
  }
#line 52
  if (sze == 0) {
#line 53
    pkvec->coeffs = (pkcoeff_struct *)((void *)0);
  } else {
    {
#line 55
    tmp___0 = malloc(sizeof(pkcoeff_struct ) * (unsigned long )sze);
#line 55
    pkvec->coeffs = (pkcoeff_struct *)tmp___0;
    }
#line 56
    if ((unsigned long )pkvec->coeffs == (unsigned long )((void *)0)) {
      {
#line 57
      errmsg(8, rtnnme, 57, sizeof(pkcoeff_struct ) * (unsigned long )sze);
      }
#line 58
      return ((pkvec_struct *)((void *)0));
    }
  }
#line 60
  return (pkvec);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
bool pkvec_resize(pkvec_struct *pkvec , int sze ) 
{ 
  pkcoeff_struct *coeffs ;
  char const   *rtnnme ;
  char const   *tmp ;
  void *tmp___0 ;

  {
#line 81
  rtnnme = "pkvec_resize";
#line 94
  if (sze == 0) {
#line 94
    if ((int )((double )pkvec->sze * 1.1) > pkvec->sze + 10) {
#line 94
      sze = pkvec->sze + 10;
    } else {
#line 94
      sze = (int )((double )pkvec->sze * 1.1);
    }
  }
#line 95
  if (sze < pkvec->cnt) {
#line 96
    if ((unsigned long )pkvec->nme == (unsigned long )((void *)0)) {
#line 96
      tmp = "<<null>>";
    } else {
#line 96
      tmp = pkvec->nme;
    }
    {
#line 96
    errmsg(91, rtnnme, tmp, pkvec->ndx, pkvec->cnt, sze);
    }
#line 98
    return ((bool )0);
  }
  {
#line 100
  coeffs = pkvec->coeffs;
#line 101
  tmp___0 = realloc((void *)pkvec->coeffs, sizeof(pkcoeff_struct ) * (unsigned long )sze);
#line 101
  pkvec->coeffs = (pkcoeff_struct *)tmp___0;
  }
#line 103
  if ((unsigned long )pkvec->coeffs == (unsigned long )((void *)0)) {
    {
#line 104
    errmsg(8, rtnnme, 104, sizeof(pkcoeff_struct ) * (unsigned long )sze);
#line 105
    pkvec->coeffs = coeffs;
    }
#line 106
    return ((bool )0);
  }
#line 107
  pkvec->sze = sze;
#line 109
  return ((bool )1);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
void pkvec_free(pkvec_struct *pkvec ) 
{ 


  {
#line 134
  if ((unsigned long )pkvec->coeffs != (unsigned long )((void *)0)) {
    {
#line 134
    free((void *)pkvec->coeffs);
    }
  }
  {
#line 135
  free((void *)pkvec);
  }
#line 137
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
bool pkvec_check(pkvec_struct *pkvec , char const   *caller ) 
{ 
  int ndx ;
  char const   *rtnnme ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 175
  rtnnme = "pkvec_check";
#line 182
  if ((unsigned long )caller == (unsigned long )((void *)0)) {
#line 182
    caller = rtnnme;
  }
#line 184
  if ((unsigned long )pkvec->nme == (unsigned long )((void *)0)) {
    {
#line 185
    errmsg(95, caller, pkvec);
    }
#line 186
    return ((bool )0);
  }
#line 188
  if (pkvec->sze < 0) {
#line 188
    goto _L;
  } else
#line 188
  if (pkvec->sze == 0) {
#line 188
    if ((unsigned long )pkvec->coeffs != (unsigned long )((void *)0)) {
#line 188
      goto _L;
    } else {
#line 188
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 188
  if (pkvec->sze != 0) {
#line 188
    if ((unsigned long )pkvec->coeffs == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 191
      if ((unsigned long )pkvec->coeffs == (unsigned long )((void *)0)) {
#line 191
        tmp = "un";
      } else {
#line 191
        tmp = "";
      }
      {
#line 191
      errmsg(90, caller, pkvec->nme, pkvec->ndx, pkvec->sze, pkvec->cnt, tmp);
      }
#line 193
      return ((bool )0);
    }
  }
#line 195
  if (pkvec->ndx < 0) {
    {
#line 197
    errmsg(93, caller, pkvec->nme, pkvec->ndx, pkvec->dflt);
    }
#line 198
    return ((bool )0);
  } else {
#line 195
    if (sizeof(pkvec->dflt) == sizeof(float )) {
      {
#line 195
      tmp___0 = __isnanf((float )pkvec->dflt);
#line 195
      tmp___4 = tmp___0;
      }
    } else {
#line 195
      if (sizeof(pkvec->dflt) == sizeof(double )) {
        {
#line 195
        tmp___1 = __isnan(pkvec->dflt);
#line 195
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 195
        tmp___2 = __isnanl((long double )pkvec->dflt);
#line 195
        tmp___3 = tmp___2;
        }
      }
#line 195
      tmp___4 = tmp___3;
    }
#line 195
    if (tmp___4) {
      {
#line 197
      errmsg(93, caller, pkvec->nme, pkvec->ndx, pkvec->dflt);
      }
#line 198
      return ((bool )0);
    }
  }
#line 200
  if (pkvec->sze == 0) {
#line 200
    return ((bool )1);
  }
#line 202
  if (pkvec->cnt < 0) {
#line 202
    goto _L___1;
  } else
#line 202
  if (pkvec->cnt > pkvec->sze) {
    _L___1: /* CIL Label */ 
#line 203
    if ((unsigned long )pkvec->coeffs == (unsigned long )((void *)0)) {
#line 203
      tmp___5 = "un";
    } else {
#line 203
      tmp___5 = "";
    }
    {
#line 203
    errmsg(90, caller, pkvec->nme, pkvec->ndx, pkvec->sze, pkvec->cnt, tmp___5);
    }
#line 205
    return ((bool )0);
  }
#line 207
  ndx = 0;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (ndx < pkvec->cnt)) {
#line 207
      goto while_break;
    }
#line 208
    if ((pkvec->coeffs + ndx)->ndx < 0) {
      {
#line 210
      errmsg(94, caller, pkvec->nme, pkvec->ndx, ndx, (pkvec->coeffs + ndx)->ndx,
             ndx, (pkvec->coeffs + ndx)->val);
      }
#line 212
      return ((bool )0);
    } else {
#line 208
      if (sizeof((pkvec->coeffs + ndx)->val) == sizeof(float )) {
        {
#line 208
        tmp___6 = __isnanf((float )(pkvec->coeffs + ndx)->val);
#line 208
        tmp___10 = tmp___6;
        }
      } else {
#line 208
        if (sizeof((pkvec->coeffs + ndx)->val) == sizeof(double )) {
          {
#line 208
          tmp___7 = __isnan((pkvec->coeffs + ndx)->val);
#line 208
          tmp___9 = tmp___7;
          }
        } else {
          {
#line 208
          tmp___8 = __isnanl((long double )(pkvec->coeffs + ndx)->val);
#line 208
          tmp___9 = tmp___8;
          }
        }
#line 208
        tmp___10 = tmp___9;
      }
#line 208
      if (tmp___10) {
        {
#line 210
        errmsg(94, caller, pkvec->nme, pkvec->ndx, ndx, (pkvec->coeffs + ndx)->ndx,
               ndx, (pkvec->coeffs + ndx)->val);
        }
#line 212
        return ((bool )0);
      }
    }
#line 207
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((bool )1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double exvec_1norm(double *vec , int len ) 
{ 
  int ndx ;
  double norm ;
  double tmp ;

  {
#line 242
  norm = (double )0;
#line 243
  ndx = 1;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (ndx <= len)) {
#line 243
      goto while_break;
    }
    {
#line 243
    tmp = fabs(*(vec + ndx));
#line 243
    norm += tmp;
#line 243
    ndx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (norm);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double exvec_ssq(double *vec , int len ) 
{ 
  int ndx ;
  double norm ;

  {
#line 274
  norm = (double )0;
#line 275
  ndx = 1;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (ndx <= len)) {
#line 275
      goto while_break;
    }
#line 275
    norm += *(vec + ndx) * *(vec + ndx);
#line 275
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (norm);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double exvec_2norm(double *vec , int len ) 
{ 
  int ndx ;
  double norm ;
  double tmp ;

  {
#line 304
  norm = (double )0;
#line 305
  ndx = 1;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (ndx <= len)) {
#line 305
      goto while_break;
    }
#line 305
    norm += *(vec + ndx) * *(vec + ndx);
#line 305
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  tmp = sqrt(norm);
  }
#line 307
  return (tmp);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double pkvec_2norm(pkvec_struct *vec ) 
{ 
  int ndx ;
  pkcoeff_struct *coeffs ;
  double norm ;
  double tmp ;

  {
#line 337
  norm = (double )0;
#line 338
  coeffs = vec->coeffs;
#line 339
  ndx = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (ndx < vec->cnt)) {
#line 339
      goto while_break;
    }
#line 340
    norm += (coeffs + ndx)->val * (coeffs + ndx)->val;
#line 339
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 342
  tmp = sqrt(norm);
  }
#line 342
  return (tmp);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double exvec_infnorm(double *vec , int len , int *p_jmax ) 
{ 
  int j ;
  int jmax ;
  double norm ;
  double tmp ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 377
  norm = 0.0;
#line 378
  if ((unsigned long )p_jmax != (unsigned long )((void *)0)) {
#line 379
    jmax = len;
#line 380
    j = 1;
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
#line 380
      if (! (j <= len)) {
#line 380
        goto while_break;
      }
      {
#line 381
      tmp = fabs(*(vec + j));
      }
#line 381
      if (tmp > norm) {
        {
#line 382
        norm = fabs(*(vec + j));
#line 383
        jmax = j;
        }
      }
#line 380
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 384
    *p_jmax = jmax;
  } else {
#line 386
    j = 1;
    {
#line 386
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 386
      if (! (j <= len)) {
#line 386
        goto while_break___0;
      }
      {
#line 386
      tmp___2 = fabs(*(vec + j));
      }
#line 386
      if (tmp___2 > norm) {
        {
#line 386
        tmp___1 = fabs(*(vec + j));
#line 386
        norm = tmp___1;
        }
      } else {
#line 386
        norm = norm;
      }
#line 386
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 388
  return (norm);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector_utils.c"
double pkvec_dotexvec(pkvec_struct *pkvec , double *exvec ) 
{ 
  int pkndx ;
  double dot ;
  pkcoeff_struct *coeffs ;

  {
#line 423
  dot = (double )0;
#line 424
  coeffs = pkvec->coeffs;
#line 425
  pkndx = 0;
  {
#line 425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 425
    if (! (pkndx < pkvec->cnt)) {
#line 425
      goto while_break;
    }
#line 426
    dot += (coeffs + pkndx)->val * *(exvec + (coeffs + pkndx)->ndx);
#line 425
    pkndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return (dot);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___7  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 70 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
static int primcand_cmp(void const   *p_primcand1 , void const   *p_primcand2 ) 
{ 
  double delta1 ;
  double delta2 ;
  double ratio1 ;
  double ratio2 ;
  primcand_struct const   *primcand1 ;
  primcand_struct const   *primcand2 ;

  {
#line 85
  primcand1 = (primcand_struct const   *)p_primcand1;
#line 86
  primcand2 = (primcand_struct const   *)p_primcand2;
#line 92
  delta1 = (double )primcand1->deltakj;
#line 93
  delta2 = (double )primcand2->deltakj;
#line 94
  if (delta1 < delta2) {
#line 95
    return (-1);
  } else
#line 97
  if (delta1 > delta2) {
#line 98
    return (1);
  }
#line 102
  ratio1 = (double )primcand1->ratiokj;
#line 103
  ratio2 = (double )primcand2->ratiokj;
#line 104
  if (ratio1 > ratio2) {
#line 105
    return (-1);
  } else
#line 107
  if (ratio1 < ratio2) {
#line 108
    return (1);
  } else {
#line 110
    return (0);
  }
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
static void promoteSanePivot___0(primcand_struct *outcands ) 
{ 
  int ndx ;
  int candcnt ;
  int firsthardsane ;
  int firstsoftsane ;
  double tol ;
  primcand_struct sane ;
  primcand_struct insane ;
  char const   *tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 149
  if ((int )(outcands + 1)->madpiv == 0) {
#line 149
    if ((int )(outcands + 1)->hard == 1) {
#line 149
      return;
    }
  }
#line 154
  candcnt = (outcands + 0)->ndx;
#line 155
  firstsoftsane = -1;
#line 156
  firsthardsane = -1;
#line 157
  ndx = 1;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (ndx <= candcnt) {
#line 157
      if (! (firsthardsane == -1)) {
#line 157
        goto while_break;
      }
    } else {
#line 157
      goto while_break;
    }
#line 158
    if ((int )(outcands + ndx)->madpiv == 0) {
#line 159
      if ((int )(outcands + ndx)->hard == 1) {
#line 160
        firsthardsane = ndx;
      } else
#line 162
      if (firstsoftsane == -1) {
#line 163
        firstsoftsane = ndx;
      }
    }
#line 157
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (firsthardsane < 0) {
#line 164
    if (firstsoftsane < 0) {
#line 164
      return;
    }
  }
#line 167
  if (dy_opts->print.pivoting >= 3) {
    {
#line 168
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      ");
    }
#line 169
    if (firstsoftsane > 0) {
      {
#line 170
      ndx = (outcands + firstsoftsane)->ndx;
#line 171
      tmp = consys_nme(dy_sys, (char )'v', ndx, (bool )0, (char *)((void *)0));
#line 171
      dyio_outfmt(dy_logchn, dy_gtxecho, "first soft sane %s (%d) at %d", tmp, ndx,
                  firstsoftsane);
      }
    }
#line 173
    if (firsthardsane > 0) {
#line 174
      ndx = (outcands + firsthardsane)->ndx;
#line 175
      if (firstsoftsane > 0) {
        {
#line 175
        dyio_outfmt(dy_logchn, dy_gtxecho, ", ");
        }
      }
      {
#line 176
      tmp___0 = consys_nme(dy_sys, (char )'v', ndx, (bool )0, (char *)((void *)0));
#line 176
      dyio_outfmt(dy_logchn, dy_gtxecho, "first hard sane %s (%d) at %d", tmp___0,
                  ndx, firsthardsane);
      }
    }
    {
#line 178
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
    }
  }
  {
#line 185
  tmp___1 = log10(dy_tols->pfeas / dy_tols->zero);
#line 185
  tol = tmp___1 / (double )2;
#line 186
  tmp___2 = pow(10.0, tol);
#line 186
  tol = dy_tols->zero * tmp___2;
  }
#line 187
  if (firsthardsane > 1) {
#line 188
    ndx = firsthardsane;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! (ndx > 1)) {
#line 188
        goto while_break___0;
      }
#line 189
      sane = *(outcands + ndx);
#line 190
      insane = *(outcands + (ndx - 1));
#line 191
      if ((int )insane.hard == 0) {
#line 193
        *(outcands + (ndx - 1)) = sane;
#line 194
        *(outcands + ndx) = insane;
      } else
#line 191
      if ((sane.deltakj - insane.deltakj) * insane.abarkj < tol) {
#line 193
        *(outcands + (ndx - 1)) = sane;
#line 194
        *(outcands + ndx) = insane;
      } else {
#line 196
        goto while_break___0;
      }
#line 188
      ndx --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    if (dy_opts->print.pivoting >= 2) {
#line 198
      if (ndx == 1) {
        {
#line 200
        tmp___3 = consys_nme(dy_sys, (char )'v', (outcands + 1)->ndx, (bool )0, (char *)((void *)0));
#line 200
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      promoted hard sane %s (%d) to %d. ",
                    tmp___3, (outcands + 1)->ndx, ndx);
        }
      } else {
#line 198
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 198
    if (dy_opts->print.pivoting >= 3) {
      {
#line 200
      tmp___3 = consys_nme(dy_sys, (char )'v', (outcands + 1)->ndx, (bool )0, (char *)((void *)0));
#line 200
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      promoted hard sane %s (%d) to %d. ",
                  tmp___3, (outcands + 1)->ndx, ndx);
      }
    }
#line 209
    if (ndx == 1) {
#line 209
      return;
    }
  }
#line 213
  if (firstsoftsane > 1) {
#line 214
    ndx = firstsoftsane;
    {
#line 214
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 214
      if (! (ndx > 1)) {
#line 214
        goto while_break___1;
      }
#line 215
      sane = *(outcands + ndx);
#line 216
      insane = *(outcands + (ndx - 1));
#line 217
      if ((int )insane.hard == 0) {
#line 219
        *(outcands + (ndx - 1)) = sane;
#line 220
        *(outcands + ndx) = insane;
      } else
#line 217
      if ((sane.deltakj - insane.deltakj) * insane.abarkj < tol) {
#line 219
        *(outcands + (ndx - 1)) = sane;
#line 220
        *(outcands + ndx) = insane;
      } else {
#line 222
        goto while_break___1;
      }
#line 214
      ndx --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 224
    if (dy_opts->print.pivoting >= 2) {
#line 224
      if (ndx == 1) {
        {
#line 226
        tmp___4 = consys_nme(dy_sys, (char )'v', (outcands + 1)->ndx, (bool )0, (char *)((void *)0));
#line 226
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      promoted hard sane %s (%d) to %d. ",
                    tmp___4, (outcands + 1)->ndx, ndx);
        }
      } else {
#line 224
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 224
    if (dy_opts->print.pivoting >= 3) {
      {
#line 226
      tmp___4 = consys_nme(dy_sys, (char )'v', (outcands + 1)->ndx, (bool )0, (char *)((void *)0));
#line 226
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t      promoted hard sane %s (%d) to %d. ",
                  tmp___4, (outcands + 1)->ndx, ndx);
      }
    }
  }
#line 237
  return;
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
static dyret_enum scanForPrimOutCands(primcand_struct *outcands , int j , int indir ,
                                      double *abarj , double maxabarj ) 
{ 
  int m ;
  int k ;
  int kpos ;
  int reject ;
  int candcnt ;
  int lastcandcnt ;
  double abarkj ;
  double ratiokj ;
  double xk ;
  double ubk ;
  double lbk ;
  double *vub ;
  double *vlb ;
  flags statk ;
  bool hard ;
  bool sort ;
  primcand_struct *outcand ;
  primcand_struct *curbest ;
  primcand_struct best ;
  dyret_enum retval ;
  bool allowsoftdegen ;
  int print ;
  double tmp ;
  char const   *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___10 ;
  int tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  double tmp___20 ;
  char const   *tmp___21 ;
  double tmp___22 ;
  char const   *tmp___23 ;
  double tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;

  {
  {
#line 292
  allowsoftdegen = (bool )0;
#line 301
  print = dy_opts->print.pivoting;
#line 302
  dy_opts->print.pivoting = 0;
#line 311
  retval = (dyret_enum )-10;
#line 313
  memset((void *)(& best), 0, sizeof(primcand_struct ));
#line 315
  m = dy_sys->concnt;
#line 316
  vub = dy_sys->vub;
#line 317
  vlb = dy_sys->vlb;
#line 318
  (outcands + 0)->ndx = -1;
  }
#line 321
  if (print >= 1) {
    {
#line 322
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    gathering candidates to leave ... ");
    }
#line 324
    if (print >= 4) {
      {
#line 325
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tVariable\t  x<k>\t\tabar<k,j>\t  delta\t\tDisp");
      }
    }
  }
#line 335
  candcnt = 0;
#line 336
  curbest = (primcand_struct *)((void *)0);
#line 337
  if (*(vlb + j) > - dy_tols->inf) {
#line 337
    if (indir == -1) {
#line 337
      goto _L;
    } else {
#line 337
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 337
  if (*(vub + j) < dy_tols->inf) {
#line 337
    if (indir == 1) {
      _L: /* CIL Label */ 
#line 339
      candcnt ++;
#line 340
      outcand = outcands + candcnt;
#line 341
      xk = *(dy_x + j);
#line 342
      outcand->ndx = j;
#line 343
      outcand->abarkj = 1.0;
#line 344
      if (indir == -1) {
#line 345
        outcand->deltakj = xk - *(dy_sys->vlb + j);
      } else {
#line 347
        outcand->deltakj = *(dy_sys->vub + j) - xk;
      }
      {
#line 348
      tmp = fabs(outcand->deltakj);
      }
#line 348
      if (tmp < dy_tols->zero) {
#line 348
        outcand->deltakj = (double )0;
      }
#line 349
      outcand->ratiokj = dy_tols->inf;
#line 350
      outcand->madpiv = (bool )0;
#line 351
      outcand->dir = indir;
#line 352
      outcand->bnd = indir;
#line 353
      outcand->hard = (bool )1;
#line 354
      curbest = outcand;
#line 356
      if (print >= 4) {
        {
#line 357
        tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 357
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___0, j);
#line 359
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", xk, - 1.0);
#line 360
        dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t accepted", outcand->deltakj * (double )indir);
        }
      }
    }
  }
#line 369
  lastcandcnt = candcnt;
#line 370
  kpos = 1;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (kpos <= m)) {
#line 370
      goto while_break;
    }
#line 371
    k = *(dy_basis + kpos);
#line 406
    reject = 0;
#line 407
    statk = *(dy_status + k);
#line 408
    abarkj = *(abarj + kpos);
#line 409
    xk = QNaNbits___7.fpdbl;
#line 410
    outcand = (primcand_struct *)((void *)0);
#line 412
    if (dy_lp->degen > 0) {
#line 412
      if (*(dy_degenset + kpos) != dy_lp->degen) {
#line 413
        reject = -5;
      } else {
#line 412
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 415
      if (statk & (unsigned int )(1 << 4)) {
#line 415
        tmp___14 = 1;
      } else {
#line 415
        tmp___14 = 0;
      }
#line 415
      if (tmp___14) {
#line 416
        reject = -1;
      } else {
        {
#line 418
        tmp___13 = fabs(abarkj - 0.0);
        }
#line 418
        if (tmp___13 <= dy_tols->zero) {
#line 419
          reject = -2;
        } else {
#line 421
          ubk = *(vub + k);
#line 422
          lbk = *(vlb + k);
#line 423
          xk = *(dy_xbasic + kpos);
#line 424
          if (ubk >= dy_tols->inf) {
#line 425
            hard = (bool )1;
          } else
#line 424
          if (lbk <= - dy_tols->inf) {
#line 425
            hard = (bool )1;
          } else {
#line 427
            hard = (bool )0;
          }
#line 428
          if (abarkj * (double )indir > (double )0) {
#line 429
            if (xk > ubk) {
#line 429
              goto _L___1;
            } else
#line 429
            if (xk == ubk) {
#line 429
              if ((int )hard == 0) {
#line 429
                if ((int )allowsoftdegen == 1) {
                  _L___1: /* CIL Label */ 
                  {
#line 430
                  candcnt ++;
#line 431
                  outcand = outcands + candcnt;
#line 432
                  outcand->ndx = k;
#line 433
                  outcand->abarkj = fabs(abarkj);
#line 434
                  outcand->deltakj = fabs((ubk - xk) / outcand->abarkj);
#line 435
                  tmp___1 = fabs(outcand->deltakj);
                  }
#line 435
                  if (tmp___1 < dy_tols->zero) {
#line 435
                    outcand->deltakj = (double )0;
                  }
                  {
#line 436
                  ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 437
                  outcand->ratiokj = ratiokj;
                  }
#line 438
                  if (ratiokj < 1.0) {
#line 439
                    outcand->madpiv = (bool )1;
                  } else {
#line 441
                    outcand->madpiv = (bool )0;
                  }
#line 442
                  outcand->dir = -1;
#line 443
                  outcand->bnd = 1;
#line 444
                  outcand->hard = hard;
                }
              }
            }
#line 445
            if (lbk > - dy_tols->inf) {
#line 446
              if (xk >= lbk) {
                {
#line 447
                candcnt ++;
#line 448
                outcand = outcands + candcnt;
#line 449
                outcand->ndx = k;
#line 450
                outcand->abarkj = fabs(abarkj);
#line 451
                outcand->deltakj = fabs((lbk - xk) / outcand->abarkj);
#line 452
                tmp___2 = fabs(outcand->deltakj);
                }
#line 452
                if (tmp___2 < dy_tols->zero) {
#line 452
                  outcand->deltakj = (double )0;
                }
                {
#line 453
                ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 454
                outcand->ratiokj = ratiokj;
                }
#line 455
                if (ratiokj < 1.0) {
#line 456
                  outcand->madpiv = (bool )1;
                } else {
#line 458
                  outcand->madpiv = (bool )0;
                }
#line 459
                outcand->dir = -1;
#line 460
                outcand->bnd = -1;
#line 461
                outcand->hard = (bool )1;
              } else {
                {
#line 463
                tmp___6 = fabs(lbk);
                }
#line 463
                if (tmp___6 < dy_tols->inf) {
                  {
#line 463
                  tmp___4 = fabs(lbk);
#line 463
                  tmp___5 = lbk - xk > dy_tols->pfeas * (1.0 + tmp___4);
                  }
                } else {
#line 463
                  tmp___5 = xk < lbk;
                }
#line 463
                if (tmp___5) {
#line 479
                  reject = -3;
                } else {
                  {
#line 464
                  candcnt ++;
#line 465
                  outcand = outcands + candcnt;
#line 466
                  outcand->ndx = k;
#line 467
                  outcand->deltakj = (double )0;
#line 468
                  outcand->abarkj = fabs(abarkj);
#line 469
                  ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 470
                  outcand->ratiokj = ratiokj;
                  }
#line 471
                  if (ratiokj < 1.0) {
#line 472
                    outcand->madpiv = (bool )1;
                  } else {
#line 474
                    outcand->madpiv = (bool )0;
                  }
#line 475
                  outcand->dir = -1;
#line 476
                  outcand->bnd = -1;
#line 477
                  outcand->hard = (bool )1;
                }
              }
            } else
#line 481
            if (xk < ubk) {
#line 482
              reject = -4;
            }
          } else {
#line 484
            if (xk < lbk) {
#line 484
              goto _L___2;
            } else
#line 484
            if (xk == lbk) {
#line 484
              if ((int )hard == 0) {
#line 484
                if ((int )allowsoftdegen == 1) {
                  _L___2: /* CIL Label */ 
                  {
#line 485
                  candcnt ++;
#line 486
                  outcand = outcands + candcnt;
#line 487
                  outcand->ndx = k;
#line 488
                  outcand->abarkj = fabs(abarkj);
#line 489
                  outcand->deltakj = fabs((lbk - xk) / outcand->abarkj);
#line 490
                  tmp___7 = fabs(outcand->deltakj);
                  }
#line 490
                  if (tmp___7 < dy_tols->zero) {
#line 490
                    outcand->deltakj = (double )0;
                  }
                  {
#line 491
                  ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 492
                  outcand->ratiokj = ratiokj;
                  }
#line 493
                  if (ratiokj < 1.0) {
#line 494
                    outcand->madpiv = (bool )1;
                  } else {
#line 496
                    outcand->madpiv = (bool )0;
                  }
#line 497
                  outcand->dir = 1;
#line 498
                  outcand->bnd = -1;
#line 499
                  outcand->hard = hard;
                }
              }
            }
#line 500
            if (ubk < dy_tols->inf) {
#line 501
              if (xk <= ubk) {
                {
#line 502
                candcnt ++;
#line 503
                outcand = outcands + candcnt;
#line 504
                outcand->ndx = k;
#line 505
                outcand->abarkj = fabs(abarkj);
#line 506
                outcand->deltakj = fabs((ubk - xk) / outcand->abarkj);
#line 507
                tmp___8 = fabs(outcand->deltakj);
                }
#line 507
                if (tmp___8 < dy_tols->zero) {
#line 507
                  outcand->deltakj = (double )0;
                }
                {
#line 508
                ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 509
                outcand->ratiokj = ratiokj;
                }
#line 510
                if (ratiokj < 1.0) {
#line 511
                  outcand->madpiv = (bool )1;
                } else {
#line 513
                  outcand->madpiv = (bool )0;
                }
#line 514
                outcand->dir = 1;
#line 515
                outcand->bnd = 1;
#line 516
                outcand->hard = (bool )1;
              } else {
                {
#line 518
                tmp___12 = fabs(ubk);
                }
#line 518
                if (tmp___12 < dy_tols->inf) {
                  {
#line 518
                  tmp___10 = fabs(ubk);
#line 518
                  tmp___11 = xk - ubk > dy_tols->pfeas * (1.0 + tmp___10);
                  }
                } else {
#line 518
                  tmp___11 = xk > ubk;
                }
#line 518
                if (tmp___11) {
#line 534
                  reject = -3;
                } else {
                  {
#line 519
                  candcnt ++;
#line 520
                  outcand = outcands + candcnt;
#line 521
                  outcand->ndx = k;
#line 522
                  outcand->deltakj = (double )0;
#line 523
                  outcand->abarkj = fabs(abarkj);
#line 524
                  ratiokj = dy_chkpiv(abarkj, maxabarj);
#line 525
                  outcand->ratiokj = ratiokj;
                  }
#line 526
                  if (ratiokj < 1.0) {
#line 527
                    outcand->madpiv = (bool )1;
                  } else {
#line 529
                    outcand->madpiv = (bool )0;
                  }
#line 530
                  outcand->dir = 1;
#line 531
                  outcand->bnd = 1;
#line 532
                  outcand->hard = (bool )1;
                }
              }
            } else
#line 536
            if (xk > lbk) {
#line 537
              reject = -4;
            }
          }
        }
      }
    }
#line 541
    if (candcnt != lastcandcnt) {
#line 542
      if ((unsigned long )curbest == (unsigned long )((void *)0)) {
#line 543
        curbest = outcand;
      } else
#line 545
      if (curbest->deltakj > outcand->deltakj) {
#line 546
        curbest = outcand;
      } else
#line 548
      if (curbest->deltakj == outcand->deltakj) {
#line 548
        if (curbest->ratiokj < outcand->ratiokj) {
#line 550
          curbest = outcand;
        }
      }
    }
#line 553
    if (print >= 4) {
#line 553
      if (candcnt != lastcandcnt) {
#line 554
        lastcandcnt ++;
        {
#line 554
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 554
          if (! (lastcandcnt <= candcnt)) {
#line 554
            goto while_break___0;
          }
          {
#line 555
          outcand = outcands + lastcandcnt;
#line 556
          tmp___15 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 556
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___15, k);
#line 558
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", xk, abarkj);
#line 559
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t accepted", outcand->deltakj * (double )indir);
          }
#line 561
          if ((int )outcand->madpiv == 1) {
            {
#line 562
            dyio_outfmt(dy_logchn, dy_gtxecho, " (mad)");
            }
          }
#line 563
          if (outcand->deltakj == (double )0) {
            {
#line 564
            dyio_outfmt(dy_logchn, dy_gtxecho, " (degen)");
            }
          }
#line 565
          if ((int )outcand->hard == 0) {
            {
#line 566
            dyio_outfmt(dy_logchn, dy_gtxecho, " (soft)");
            }
          }
#line 554
          lastcandcnt ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 567
        lastcandcnt --;
      } else {
#line 553
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 569
    if (print >= 5) {
      {
#line 570
      tmp___16 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 570
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___16, k);
#line 572
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", xk, abarkj);
      }
      {
#line 574
      if (reject == -1) {
#line 574
        goto case_neg_1;
      }
#line 578
      if (reject == -2) {
#line 578
        goto case_neg_2;
      }
#line 581
      if (reject == -3) {
#line 581
        goto case_neg_3;
      }
#line 585
      if (reject == -4) {
#line 585
        goto case_neg_4;
      }
#line 589
      if (reject == -5) {
#line 589
        goto case_neg_5;
      }
#line 573
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 575
      tmp___17 = dy_prtvstat(statk);
#line 575
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- status %s", tmp___17);
      }
#line 577
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 579
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- zero pivot");
      }
#line 580
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 582
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- borderline infeasible");
      }
#line 584
      goto switch_break;
      case_neg_4: /* CIL Label */ 
      {
#line 586
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- no limiting bound");
      }
#line 588
      goto switch_break;
      case_neg_5: /* CIL Label */ 
      {
#line 590
      dyio_outfmt(dy_logchn, dy_gtxecho, "\t\trejected -- not in restricted subproblem");
      }
#line 592
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 595
    lastcandcnt = candcnt;
#line 370
    kpos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  (outcands + 0)->ndx = candcnt;
#line 601
  sort = (bool )1;
#line 602
  if ((unsigned long )curbest != (unsigned long )((void *)0)) {
#line 603
    if ((int )curbest->hard == 1) {
#line 603
      if (curbest->deltakj > (double )0) {
#line 603
        if ((int )curbest->madpiv == 0) {
#line 605
          best = *curbest;
#line 606
          sort = (bool )0;
        }
      }
    }
  }
#line 627
  dy_opts->print.pivoting = print;
#line 629
  if (candcnt > 0) {
#line 630
    if ((int )sort == 1) {
#line 631
      if (candcnt > 1) {
#line 634
        if (print >= 2) {
#line 635
          if ((int )sort == 0) {
            {
#line 635
            dyio_outfmt(dy_logchn, dy_gtxecho, "!");
            }
          }
          {
#line 636
          dyio_outfmt(dy_logchn, dy_gtxecho, "sorting ... ");
          }
        }
        {
#line 638
        (outcands + 0)->deltakj = - dy_tols->inf;
#line 639
        (outcands + 0)->madpiv = (bool )0;
#line 640
        qsort((void *)(outcands + 1), (size_t )candcnt, sizeof(primcand_struct ),
              & primcand_cmp);
#line 641
        promoteSanePivot___0(outcands);
        }
#line 645
        if ((outcands + 1)->deltakj == (double )0) {
#line 645
          if ((outcands + 2)->deltakj == (double )0) {
#line 645
            if ((int )(outcands + 2)->hard == 1) {
#line 647
              retval = (dyret_enum )-2;
            } else {
#line 649
              retval = (dyret_enum )1;
            }
          } else {
#line 649
            retval = (dyret_enum )1;
          }
        } else {
#line 649
          retval = (dyret_enum )1;
        }
      } else {
#line 651
        retval = (dyret_enum )1;
      }
    }
#line 652
    if ((int )sort == 0) {
#line 670
      *(outcands + 1) = best;
#line 671
      retval = (dyret_enum )1;
    }
  } else {
#line 673
    retval = (dyret_enum )8;
  }
#line 676
  if (print >= 1) {
#line 677
    if (print >= 3) {
#line 677
      if (candcnt > 0) {
        {
#line 678
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n   ");
#line 679
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tVariable\tratio<ik>\tdelta<k>");
#line 681
        m = 1;
        }
        {
#line 681
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 681
          if (! (m <= candcnt)) {
#line 681
            goto while_break___1;
          }
          {
#line 682
          k = (outcands + m)->ndx;
#line 683
          ratiokj = (outcands + m)->ratiokj;
#line 684
          xk = (outcands + m)->deltakj;
#line 685
          tmp___18 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 685
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%-8s (%d)", tmp___18, k);
#line 687
          dyio_outfmt(dy_logchn, dy_gtxecho, "\t%8g\t%8g", ratiokj, xk);
          }
#line 688
          if ((int )(outcands + m)->madpiv == 1) {
            {
#line 689
            dyio_outfmt(dy_logchn, dy_gtxecho, " (mad)");
            }
          }
#line 690
          if (xk == (double )0) {
            {
#line 691
            dyio_outfmt(dy_logchn, dy_gtxecho, " (degen)");
            }
          }
#line 692
          if ((int )(outcands + m)->hard == 0) {
            {
#line 693
            dyio_outfmt(dy_logchn, dy_gtxecho, " (soft)");
            }
          }
#line 681
          m ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 694
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ");
        }
      }
    }
    {
#line 695
    dyio_outfmt(dy_logchn, dy_gtxecho, "%d candidates.", candcnt);
    }
#line 696
    if (print >= 2) {
#line 696
      if ((int )retval == 1) {
#line 696
        goto _L___5;
      } else
#line 696
      if ((int )retval == -2) {
        _L___5: /* CIL Label */ 
#line 697
        k = (outcands + 1)->ndx;
#line 698
        if (j != k) {
          {
#line 699
          kpos = *(dy_var2basis + k);
#line 700
          tmp___19 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 700
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    selected %s (%d) = %g to leave pos\'n %d at",
                      tmp___19, k, *(dy_xbasic + kpos), kpos);
          }
#line 704
          if ((outcands + 1)->dir > 0) {
#line 705
            if (*(dy_status + k) != (flags )(1 << 11)) {
#line 705
              tmp___20 = *(vub + k);
            } else {
#line 705
              tmp___20 = *(vlb + k);
            }
#line 705
            if (*(dy_status + k) != (flags )(1 << 11)) {
#line 705
              tmp___21 = "ub";
            } else {
#line 705
              tmp___21 = "lb";
            }
            {
#line 705
            dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", tmp___21, tmp___20);
            }
          } else {
#line 709
            if (*(dy_status + k) != (flags )(1 << 10)) {
#line 709
              tmp___22 = *(vlb + k);
            } else {
#line 709
              tmp___22 = *(vub + k);
            }
#line 709
            if (*(dy_status + k) != (flags )(1 << 10)) {
#line 709
              tmp___23 = "lb";
            } else {
#line 709
              tmp___23 = "ub";
            }
            {
#line 709
            dyio_outfmt(dy_logchn, dy_gtxecho, " %s = %g, ", tmp___23, tmp___22);
            }
          }
          {
#line 712
          dyio_outfmt(dy_logchn, dy_gtxecho, "abar<%d,%d> = %g, ", j, k, *(abarj + kpos));
          }
        } else {
#line 715
          if ((outcands + 1)->dir > 0) {
#line 715
            tmp___24 = *(vub + k);
          } else {
#line 715
            tmp___24 = *(vlb + k);
          }
#line 715
          if ((outcands + 1)->dir > 0) {
#line 715
            tmp___25 = "ub";
          } else {
#line 715
            tmp___25 = "lb";
          }
          {
#line 715
          tmp___26 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 715
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n    selected %s (%d) = %g to change to %s = %g, ",
                      tmp___26, k, *(dy_x + k), tmp___25, tmp___24);
          }
        }
        {
#line 720
        dyio_outfmt(dy_logchn, dy_gtxecho, "delta = %g.", (outcands + 1)->deltakj);
        }
      } else {
        {
#line 722
        tmp___27 = dy_prtdyret(retval);
#line 722
        dyio_outfmt(dy_logchn, dy_gtxecho, " Returning %s.", tmp___27);
        }
      }
    } else {
      {
#line 722
      tmp___27 = dy_prtdyret(retval);
#line 722
      dyio_outfmt(dy_logchn, dy_gtxecho, " Returning %s.", tmp___27);
      }
    }
  }
#line 724
  dy_opts->print.pivoting = print;
#line 727
  return (retval);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_primalmultipivot.c"
dyret_enum primmultiout(int j , int indir , double *abarj , double maxabarj , int *p_xindx ,
                        int *p_outdir , double *p_deltaj ) 
{ 
  int m ;
  int candcnt ;
  dyret_enum retval ;
  primcand_struct *outcands ;
  primcand_struct *candk ;
  void *tmp ;

  {
  {
#line 787
  retval = (dyret_enum )0;
#line 788
  *p_xindx = 0;
#line 789
  *p_outdir = 0;
#line 790
  *p_deltaj = (double )-1;
#line 791
  m = dy_sys->concnt;
#line 792
  tmp = malloc((unsigned long )((2 * m + 1) + 1) * sizeof(primcand_struct ));
#line 792
  outcands = (primcand_struct *)tmp;
#line 808
  retval = scanForPrimOutCands(outcands, j, indir, abarj, maxabarj);
  }
#line 809
  if ((int )retval == 1) {
#line 809
    goto _L;
  } else
#line 809
  if ((int )retval == -2) {
    _L: /* CIL Label */ 
#line 810
    candcnt = (outcands + 0)->ndx;
#line 811
    candk = outcands + 1;
#line 812
    *p_xindx = candk->ndx;
#line 813
    *p_outdir = candk->dir;
#line 814
    *p_deltaj = candk->deltakj;
#line 815
    if ((int )candk->madpiv == 1) {
#line 816
      retval = (dyret_enum )-1;
    }
  } else {
#line 822
    *p_xindx = -1;
  }
  {
#line 824
  free((void *)outcands);
  }
#line 825
  return (retval);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static INV *luf_basis  =    (INV *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static int luf_capacity  =    0;
#line 117 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static pivtols_struct pivtols[7]  = {      {.01, 4}, 
        {.05, 4}, 
        {.1, 4}, 
        {.2, 4}, 
        {.4, 6}, 
        {.8, 8}, 
        {.95, 10}};
#line 124 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static int pivlevel  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static int minpivlevel  ;
#line 142 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static char buffer___0[20]  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
char *dy_prtpivparms(int lvl ) 
{ 
  pivtols_struct pivtol ;

  {
#line 153
  if (lvl < 0) {
#line 154
    pivtol.stable = (luf_basis->luf)->piv_tol;
#line 155
    pivtol.look = (luf_basis->luf)->piv_lim;
  } else
#line 153
  if ((unsigned long )lvl > sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL) {
#line 154
    pivtol.stable = (luf_basis->luf)->piv_tol;
#line 155
    pivtol.look = (luf_basis->luf)->piv_lim;
  } else {
#line 157
    pivtol.stable = pivtols[lvl].stable;
#line 158
    pivtol.look = pivtols[lvl].look;
  }
  {
#line 160
  dyio_outfxd(buffer___0, -19, (char )'l', "PTPS(%.2f,%d)", pivtol.stable, pivtol.look);
  }
#line 162
  return (buffer___0);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
bool dy_setpivparms(int curdelta , int mindelta ) 
{ 
  bool minretval ;
  bool curretval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 197
  minretval = (bool )0;
#line 198
  curretval = (bool )0;
#line 203
  if (mindelta != 0) {
#line 204
    if (minpivlevel <= 0) {
#line 204
      if (mindelta < 0) {
#line 204
        goto _L;
      } else {
#line 204
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 204
    if ((unsigned long )minpivlevel >= sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL) {
#line 204
      if (mindelta > 0) {
        _L: /* CIL Label */ 
#line 208
        if (dy_opts->print.basis >= 3) {
          {
#line 210
          tmp = dy_prtpivparms(minpivlevel);
#line 210
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    min. pivot ratio unchanged at %s (%d)",
                      tmp, minpivlevel);
          }
        } else
#line 208
        if (dy_opts->print.basis >= 2) {
#line 208
          if (mindelta > 0) {
            {
#line 210
            tmp = dy_prtpivparms(minpivlevel);
#line 210
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    min. pivot ratio unchanged at %s (%d)",
                        tmp, minpivlevel);
            }
          }
        }
      } else {
#line 204
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 216
      minretval = (bool )1;
#line 217
      minpivlevel += mindelta;
#line 218
      if (minpivlevel < 0) {
#line 219
        minpivlevel = 0;
      } else
#line 221
      if ((unsigned long )minpivlevel > sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL) {
#line 222
        minpivlevel = (int )(sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL);
      }
#line 223
      if (pivlevel < minpivlevel) {
#line 224
        if (curdelta > minpivlevel - pivlevel) {
#line 224
          curdelta = curdelta;
        } else {
#line 224
          curdelta = minpivlevel - pivlevel;
        }
      }
#line 226
      if (dy_opts->print.basis >= 2) {
        {
#line 227
        tmp___0 = dy_prtpivparms(minpivlevel);
#line 227
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    setting min. pivot ratio to %s (%d)",
                    tmp___0, minpivlevel);
        }
      }
    }
  }
#line 235
  if (curdelta != 0) {
#line 236
    if (pivlevel <= minpivlevel) {
#line 236
      if (curdelta < 0) {
#line 236
        goto _L___2;
      } else {
#line 236
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 236
    if ((unsigned long )pivlevel >= sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL) {
#line 236
      if (curdelta > 0) {
        _L___2: /* CIL Label */ 
#line 240
        if (dy_opts->print.basis >= 3) {
          {
#line 242
          tmp___1 = dy_prtpivparms(-1);
#line 242
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    cur. pivot ratio unchanged at %s (%d)",
                      tmp___1, pivlevel);
          }
        } else
#line 240
        if (dy_opts->print.basis >= 2) {
#line 240
          if (mindelta > 0) {
            {
#line 242
            tmp___1 = dy_prtpivparms(-1);
#line 242
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    cur. pivot ratio unchanged at %s (%d)",
                        tmp___1, pivlevel);
            }
          }
        }
      } else {
#line 236
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 248
      curretval = (bool )1;
#line 249
      pivlevel += curdelta;
#line 250
      if (pivlevel < minpivlevel) {
#line 251
        pivlevel = minpivlevel;
      } else
#line 253
      if ((unsigned long )pivlevel > sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL) {
#line 254
        pivlevel = (int )(sizeof(pivtols) / sizeof(pivtols_struct ) - 1UL);
      }
#line 255
      (luf_basis->luf)->piv_tol = pivtols[pivlevel].stable;
#line 256
      (luf_basis->luf)->piv_lim = pivtols[pivlevel].look;
#line 258
      if (dy_opts->print.basis >= 2) {
        {
#line 259
        tmp___2 = dy_prtpivparms(-1);
#line 259
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t    setting cur. pivot ratio to %s (%d)",
                    tmp___2, pivlevel);
        }
      }
    }
  }
#line 265
  if ((int )curretval == 0) {
#line 265
    if ((int )minretval == 0) {
#line 266
      return ((bool )0);
    } else {
#line 268
      return ((bool )1);
    }
  } else {
#line 268
    return ((bool )1);
  }
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
double dy_chkpiv(double abarij , double maxabar ) 
{ 
  double ratio ;
  double abspiv ;
  double stable ;
  char const   *rtnnme ;
  char const   *tmp ;

  {
  {
#line 296
  rtnnme = "dy_chkpiv";
#line 312
  abspiv = fabs(abarij);
#line 313
  ratio = dy_tols->pivot * (luf_basis->luf)->piv_tol;
#line 314
  stable = ratio * maxabar;
  }
#line 316
  if (dy_opts->print.pivoting >= 1) {
#line 317
    if (abspiv / stable < 1.0) {
#line 318
      if (abspiv < 1.0) {
#line 318
        tmp = "rejecting";
      } else {
#line 318
        tmp = "tolerating";
      }
      {
#line 318
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: %s pivot = %g < %g; column max = %g, ratio = %g.",
                  rtnnme, tmp, abarij, stable, maxabar, ratio);
      }
    }
  }
#line 324
  if (abspiv / stable >= 1.0) {
#line 325
    return (abspiv / stable);
  } else
#line 327
  if (abspiv >= 1.0) {
#line 328
    return (1.0);
  } else {
#line 330
    return (abspiv / stable);
  }
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
void dy_initbasis(int concnt , int factor , double zero_tol ) 
{ 
  int sva_size ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 358
  rtnnme = "dy_initbasis";
#line 364
  if (concnt > 5) {
#line 364
    luf_capacity = concnt;
  } else {
#line 364
    luf_capacity = 5;
  }
  {
#line 365
  luf_basis = dy_glp_inv_create(luf_capacity, factor);
  }
#line 366
  if ((unsigned long )luf_basis == (unsigned long )((void *)0)) {
#line 367
    if ((unsigned long )dy_lp == (unsigned long )((void *)0)) {
      {
#line 368
      errmsg(302, rtnnme, "empty", "pre-init", 0, "create");
      }
    } else {
      {
#line 370
      tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 370
      errmsg(302, rtnnme, dy_sys->nme, tmp, dy_lp->tot.iters, "create");
      }
    }
#line 372
    return;
  }
#line 379
  sva_size = (luf_basis->luf)->sv_size;
#line 380
  (luf_basis->luf)->new_sva = 3 * sva_size;
#line 382
  if ((unsigned long )dy_opts != (unsigned long )((void *)0)) {
#line 382
    if (dy_opts->print.basis >= 2) {
      {
#line 383
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 383
      dyio_outfmt(dy_logchn, dy_gtxecho, "\ninitbasis: %s(%d) basis capacity %d, piv lim %d.",
                  tmp___0, dy_lp->tot.iters, (luf_basis->luf)->n, luf_basis->hh_max);
      }
    }
  }
#line 403
  pivlevel = 0;
#line 404
  minpivlevel = 0;
#line 406
  if (zero_tol != 0.0) {
#line 406
    (luf_basis->luf)->eps_tol = zero_tol;
  }
#line 407
  (luf_basis->luf)->piv_tol = pivtols[pivlevel].stable;
#line 408
  (luf_basis->luf)->piv_lim = pivtols[pivlevel].look;
#line 409
  (luf_basis->luf)->max_gro = 1.0e7;
#line 418
  luf_basis->upd_tol = 1.0e-10;
#line 420
  return;
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
void dy_freebasis(void) 
{ 


  {
#line 439
  if ((unsigned long )luf_basis != (unsigned long )((void *)0)) {
    {
#line 440
    dy_glp_inv_delete(luf_basis);
#line 441
    luf_basis = (INV *)((void *)0);
    }
  }
  {
#line 443
  dy_glp_free_lib_env();
  }
#line 445
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static void luf_adjustsize(void) 
{ 
  double upd_tol ;
  double piv_tol ;
  double zero_tol ;
  double max_gro ;
  int factor ;
  int look ;
  int capacity ;
  int oldcapacity ;

  {
#line 468
  if (dy_sys->concnt > luf_capacity) {
    {
#line 469
    factor = luf_basis->hh_max;
#line 470
    upd_tol = luf_basis->upd_tol;
#line 471
    zero_tol = (luf_basis->luf)->eps_tol;
#line 472
    piv_tol = (luf_basis->luf)->piv_tol;
#line 473
    look = (luf_basis->luf)->piv_lim;
#line 474
    max_gro = (luf_basis->luf)->max_gro;
#line 476
    oldcapacity = luf_basis->m;
#line 478
    dy_freebasis();
#line 479
    capacity = (int )((double )dy_sys->concnt * 1.5);
#line 480
    dy_initbasis(capacity, factor, zero_tol);
#line 481
    luf_basis->upd_tol = upd_tol;
#line 482
    (luf_basis->luf)->eps_tol = zero_tol;
#line 483
    (luf_basis->luf)->piv_tol = piv_tol;
#line 484
    (luf_basis->luf)->piv_lim = look;
#line 485
    (luf_basis->luf)->max_gro = max_gro;
    }
#line 487
    if (dy_opts->print.basis >= 2) {
      {
#line 488
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    increased basis capacity from %d to %d constraints",
                  oldcapacity, luf_basis->m);
#line 491
      dyio_outfmt(dy_logchn, dy_gtxecho, ", piv lim %d.", luf_basis->hh_max);
      }
    }
  }
#line 497
  luf_basis->m = dy_sys->concnt;
#line 498
  (luf_basis->luf)->n = dy_sys->concnt;
#line 500
  return;
}
}
#line 505 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
void dy_ftran(double *col , bool save ) 
{ 
  int isave ;

  {
#line 524
  if ((int )save == 1) {
#line 525
    isave = 1;
  } else {
#line 527
    isave = 0;
  }
  {
#line 529
  dy_glp_inv_ftran(luf_basis, col, isave);
  }
#line 531
  return;
}
}
#line 534 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
void dy_btran(double *col ) 
{ 


  {
  {
#line 546
  dy_glp_inv_btran(luf_basis, col);
  }
#line 548
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static void adjust_basis(int *p_patchcnt , patch_struct **p_patches ) 
{ 
  int *qq_col ;
  int *pp_row ;
  int rank ;
  int pqndx ;
  int i ;
  int j ;
  int k ;
  int pndx ;
  patch_struct *patches ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 607
  qq_col = (luf_basis->luf)->qq_col;
#line 608
  pp_row = (luf_basis->luf)->pp_row;
#line 609
  rank = (luf_basis->luf)->rank;
#line 611
  tmp = malloc((unsigned long )(dy_sys->concnt - rank) * sizeof(patch_struct ));
#line 611
  patches = (patch_struct *)tmp;
#line 619
  pqndx = rank + 1;
#line 619
  pndx = 0;
  }
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    if (! (pqndx <= dy_sys->concnt)) {
#line 619
      goto while_break;
    }
#line 620
    k = *(qq_col + pqndx);
#line 621
    j = *(dy_basis + k);
#line 622
    i = *(pp_row + pqndx);
#line 623
    *(dy_basis + k) = i;
#line 624
    *(dy_var2basis + j) = 0;
#line 625
    *(dy_var2basis + i) = k;
#line 626
    (patches + pndx)->pos = k;
#line 627
    (patches + pndx)->out = j;
#line 628
    (patches + pndx)->in = i;
#line 630
    if (dy_opts->print.basis >= 3) {
      {
#line 631
      tmp___0 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 631
      tmp___1 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 631
      tmp___2 = consys_nme(dy_sys, (char )'c', k, (bool )0, (char *)((void *)0));
#line 631
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      pos\'n %d (%s (%d)) replacing %s (%d) with %s (%d).",
                  k, tmp___2, k, tmp___1, j, tmp___0, i);
      }
    }
#line 619
    pqndx ++;
#line 619
    pndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  *p_patchcnt = pndx;
#line 640
  *p_patches = patches;
#line 641
  return;
}
}
#line 645 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static dyret_enum adjust_therest(int patchcnt , patch_struct *patches ) 
{ 
  int i ;
  int j ;
  int pndx ;
  pkvec_struct *aj ;
  flags statj ;
  dyret_enum retval ;
  dyphase_enum phase ;
  double valj ;
  double cbarj ;
  double *vub ;
  double *vlb ;
  double *obj ;
  char const   *rtnnme ;
  flags stati ;
  double vali ;
  bool tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  bool tmp___29 ;

  {
#line 704
  rtnnme = "adjust_therest";
#line 726
  phase = dy_lp->phase;
#line 746
  if ((unsigned int )phase == 1U) {
#line 746
    return ((dyret_enum )1);
  }
#line 748
  vlb = dy_sys->vlb;
#line 749
  vub = dy_sys->vub;
#line 750
  obj = dy_sys->obj;
#line 751
  aj = (pkvec_struct *)((void *)0);
#line 752
  retval = (dyret_enum )1;
#line 760
  if ((unsigned int )phase == 2U) {
#line 760
    goto _L;
  } else
#line 760
  if ((unsigned int )phase == 3U) {
#line 760
    goto _L;
  } else
#line 760
  if ((unsigned int )phase == 4U) {
    _L: /* CIL Label */ 
    {
#line 761
    tmp = dy_clrpivrej((int *)((void *)0));
    }
#line 761
    if ((int )tmp != 1) {
#line 761
      return ((dyret_enum )-10);
    }
#line 762
    if (dy_lp->degen > 0) {
#line 763
      if ((unsigned int )phase == 4U) {
        {
#line 764
        dy_dualdegenout(0);
        }
      } else {
        {
#line 766
        dy_degenout(0);
        }
      }
    }
  }
#line 776
  pndx = 0;
  {
#line 776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 776
    if (! (pndx < patchcnt)) {
#line 776
      goto while_break;
    }
#line 777
    i = (patches + pndx)->in;
#line 779
    stati = *(dy_status + i);
#line 780
    vali = *(dy_x + i);
#line 782
    *(dy_status + i) = (flags )(1 << 2);
#line 783
    j = (patches + pndx)->out;
#line 784
    statj = *(dy_status + j);
#line 785
    valj = *(dy_x + j);
    {
#line 787
    if (statj == (flags )(1 << 11)) {
#line 787
      goto case_exp;
    }
#line 791
    if (statj == (flags )(1 << 3)) {
#line 791
      goto case_exp___0;
    }
#line 794
    if (statj == (flags )(1 << 2)) {
#line 794
      goto case_exp___1;
    }
#line 805
    if (statj == (flags )(1 << 1)) {
#line 805
      goto case_exp___2;
    }
#line 808
    if (statj == (flags )(1 << 10)) {
#line 808
      goto case_exp___3;
    }
#line 812
    if (statj == 1U) {
#line 812
      goto case_1;
    }
#line 815
    if (statj == (flags )(1 << 4)) {
#line 815
      goto case_exp___4;
    }
#line 827
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 788
    *(dy_status + j) = (flags )(1 << 7);
#line 789
    *(dy_x + j) = *(vlb + j);
#line 790
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 792
    *(dy_status + j) = (flags )(1 << 7);
#line 793
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 795
    if ((unsigned int )phase == 3U) {
#line 796
      *(dy_status + j) = (flags )(1 << 9);
    } else
#line 798
    if (valj - *(vlb + j) < *(vub + j) - valj) {
#line 799
      *(dy_status + j) = (flags )(1 << 7);
#line 800
      *(dy_x + j) = *(vlb + j);
    } else {
#line 802
      *(dy_status + j) = (flags )(1 << 6);
#line 803
      *(dy_x + j) = *(vub + j);
    }
#line 804
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 806
    *(dy_status + j) = (flags )(1 << 6);
#line 807
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 809
    *(dy_status + j) = (flags )(1 << 6);
#line 810
    *(dy_x + j) = *(vub + j);
#line 811
    goto switch_break;
    case_1: /* CIL Label */ 
#line 813
    *(dy_status + j) = (flags )(1 << 5);
#line 814
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 816
    *(dy_status + j) = (flags )(1 << 8);
#line 817
    if ((unsigned int )phase == 4U) {
#line 820
      if (dy_opts->print.dual >= 1) {
        {
#line 821
        tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 821
        tmp___1 = dy_prtvstat(statj);
#line 821
        tmp___2 = dy_prtlpphase(phase, (bool )1);
#line 821
        warn(346, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters + 1, tmp___1, tmp___0,
             j);
        }
      }
#line 825
      retval = (dyret_enum )-3;
    }
#line 826
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 828
    tmp___3 = dy_prtvstat(statj);
#line 828
    tmp___4 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 828
    errmsg(380, rtnnme, dy_sys->nme, tmp___4, j, tmp___3, "basic");
    }
#line 830
    return ((dyret_enum )-10);
    switch_break: /* CIL Label */ ;
    }
#line 832
    if (dy_opts->print.basis >= 3) {
      {
#line 833
      tmp___5 = dy_prtvstat(stati);
#line 833
      tmp___6 = consys_nme(dy_sys, (char )'v', i, (bool )0, (char *)((void *)0));
#line 833
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) had status %s, value %g, ",
                  tmp___6, i, tmp___5, vali);
#line 837
      tmp___7 = dy_prtvstat(*(dy_status + i));
#line 837
      dyio_outfmt(dy_logchn, dy_gtxecho, "now status %s.", tmp___7);
#line 839
      tmp___8 = dy_prtvstat(statj);
#line 839
      tmp___9 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 839
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t%s (%d) had status %s, value %g, ",
                  tmp___9, j, tmp___8, valj);
#line 843
      tmp___10 = dy_prtvstat(*(dy_status + j));
#line 843
      dyio_outfmt(dy_logchn, dy_gtxecho, "now status %s, value %g.", tmp___10, *(dy_x + j));
      }
    }
#line 776
    pndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 863
  dy_calcduals();
#line 864
  tmp___12 = dy_calccbar();
  }
#line 864
  if ((int )tmp___12 == 0) {
    {
#line 865
    tmp___11 = dy_prtlpphase(phase, (bool )1);
#line 865
    errmsg(384, rtnnme, dy_sys->nme, tmp___11, dy_lp->tot.iters);
    }
#line 867
    return ((dyret_enum )-10);
  }
#line 881
  if ((unsigned int )phase == 4U) {
#line 881
    if ((int )retval != -3) {
#line 882
      j = 1;
      {
#line 882
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 882
        if (! (j <= dy_sys->varcnt)) {
#line 882
          goto while_break___0;
        }
#line 883
        statj = *(dy_status + j);
#line 884
        if (statj & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 884
          tmp___13 = 1;
        } else {
#line 884
          tmp___13 = 0;
        }
#line 884
        if (tmp___13) {
#line 884
          goto __Cont;
        }
#line 885
        if (statj & (unsigned int )(1 << 8)) {
#line 885
          tmp___17 = 1;
        } else {
#line 885
          tmp___17 = 0;
        }
#line 885
        if (tmp___17) {
#line 886
          retval = (dyret_enum )-3;
#line 888
          cbarj = *(dy_cbar + j);
#line 889
          if (dy_opts->print.dual >= 1) {
            {
#line 890
            tmp___14 = dy_prtvstat(statj);
#line 890
            tmp___15 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 890
            tmp___16 = dy_prtlpphase(phase, (bool )1);
#line 890
            warn(347, rtnnme, dy_sys->nme, tmp___16, dy_lp->tot.iters + 1, tmp___15,
                 j, tmp___14, j, cbarj, dy_tols->dfeas);
            }
          }
#line 895
          goto while_break___0;
        }
#line 896
        cbarj = *(dy_cbar + j);
#line 897
        if (cbarj < - dy_tols->dfeas) {
#line 897
          if (statj & (unsigned int )(1 << 6)) {
#line 897
            tmp___25 = 0;
          } else {
#line 897
            tmp___25 = 1;
          }
#line 897
          if (tmp___25) {
#line 898
            if (*(vub + j) >= dy_tols->inf) {
#line 901
              if (dy_opts->print.dual >= 1) {
                {
#line 902
                tmp___18 = dy_prtvstat(statj);
#line 902
                tmp___19 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 902
                tmp___20 = dy_prtlpphase(phase, (bool )1);
#line 902
                warn(347, rtnnme, dy_sys->nme, tmp___20, dy_lp->tot.iters + 1, tmp___19,
                     j, tmp___18, j, cbarj, dy_tols->dfeas);
                }
              }
#line 907
              retval = (dyret_enum )-3;
#line 908
              goto while_break___0;
            } else {
#line 910
              *(dy_status + j) = (flags )(1 << 6);
#line 911
              *(dy_x + j) = *(vub + j);
            }
          } else {
#line 897
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 913
        if (cbarj > dy_tols->dfeas) {
#line 913
          if (statj & (unsigned int )(1 << 7)) {
#line 913
            tmp___24 = 0;
          } else {
#line 913
            tmp___24 = 1;
          }
#line 913
          if (tmp___24) {
#line 914
            if (*(vlb + j) >= dy_tols->inf) {
#line 917
              if (dy_opts->print.dual >= 1) {
                {
#line 918
                tmp___21 = dy_prtvstat(statj);
#line 918
                tmp___22 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 918
                tmp___23 = dy_prtlpphase(phase, (bool )1);
#line 918
                warn(347, rtnnme, dy_sys->nme, tmp___23, dy_lp->tot.iters + 1, tmp___22,
                     j, tmp___21, j, cbarj, dy_tols->dfeas);
                }
              }
#line 923
              retval = (dyret_enum )-3;
#line 924
              goto while_break___0;
            } else {
#line 926
              *(dy_status + j) = (flags )(1 << 7);
#line 927
              *(dy_x + j) = *(vlb + j);
            }
          }
        }
#line 929
        if (dy_opts->print.basis >= 3) {
#line 929
          if (*(dy_status + j) != statj) {
            {
#line 930
            tmp___26 = dy_prtvstat(statj);
#line 930
            tmp___27 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 930
            dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tchanged status of %s (%d) from %s to",
                        tmp___27, j, tmp___26);
#line 933
            tmp___28 = dy_prtvstat(*(dy_status + j));
#line 933
            dyio_outfmt(dy_logchn, dy_gtxecho, " %s to maintain dual feasibility; cbar = %g.",
                        tmp___28, cbarj);
            }
          }
        }
        __Cont: /* CIL Label */ 
#line 882
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 944
  tmp___29 = dy_calcprimals();
  }
#line 944
  if ((int )tmp___29 == 0) {
#line 944
    return ((dyret_enum )-10);
  }
  {
#line 945
  dy_setbasicstatus();
  }
#line 951
  if ((unsigned int )phase == 2U) {
    {
#line 952
    dy_pseinit();
    }
  } else
#line 951
  if ((unsigned int )phase == 3U) {
    {
#line 952
    dy_pseinit();
    }
  } else
#line 954
  if ((unsigned int )phase == 4U) {
#line 954
    if ((int )retval != -3) {
      {
#line 955
      dy_dseinit();
      }
    }
  }
#line 957
  return (retval);
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
static int factor_loadcol(void *p_consys , int i , int *rndx , double *coeff ) 
{ 
  int j ;
  int vecndx ;
  int pkndx ;
  double aij ;
  pkvec_struct *aj ;
  consys_struct *consys ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;

  {
  {
#line 986
  rtnnme = "factor_loadcol";
#line 1000
  consys = (consys_struct *)p_consys;
#line 1001
  aj = pkvec_new(consys->maxcollen);
#line 1006
  j = *(dy_basis + i);
#line 1007
  tmp___0 = consys_getcol_pk(consys, j, & aj);
  }
#line 1007
  if ((int )tmp___0 == 0) {
    {
#line 1008
    tmp = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 1008
    errmsg(112, rtnnme, dy_sys->nme, "retrieve", "column", tmp, j);
    }
#line 1010
    if ((unsigned long )aj != (unsigned long )((void *)0)) {
      {
#line 1010
      pkvec_free(aj);
      }
    }
#line 1011
    return (-1);
  }
#line 1015
  vecndx = 1;
#line 1016
  pkndx = 0;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1016
    if (! (pkndx < aj->cnt)) {
#line 1016
      goto while_break;
    }
#line 1017
    aij = (aj->coeffs + pkndx)->val;
#line 1018
    if (aij != 0.0) {
#line 1019
      *(rndx + vecndx) = (aj->coeffs + pkndx)->ndx;
#line 1020
      *(coeff + vecndx) = aij;
#line 1021
      vecndx ++;
    }
#line 1016
    pkndx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1025
  pkvec_free(aj);
  }
#line 1026
  return (vecndx - 1);
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
dyret_enum dy_factor(flags *calcflgs ) 
{ 
  int retval ;
  int patchcnt ;
  bool try_again ;
  bool patched ;
  dyret_enum retcode ;
  patch_struct *patches ;
  char const   *rtnnme ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 1086
  rtnnme = "dy_factor";
#line 1109
  retcode = (dyret_enum )0;
#line 1110
  patchcnt = 0;
#line 1111
  patches = (patch_struct *)((void *)0);
#line 1117
  luf_adjustsize();
#line 1127
  try_again = (bool )1;
#line 1128
  patched = (bool )0;
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! try_again) {
#line 1129
      goto while_break;
    }
    {
#line 1130
    retval = dy_glp_inv_decomp(luf_basis, (void *)dy_sys, & factor_loadcol);
    }
#line 1132
    if (retval == 0) {
#line 1132
      if (dy_opts->print.basis >= 4) {
        {
#line 1134
        tmp = dy_prtpivparms(-1);
#line 1134
        tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1134
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: factored with %s, basis stability %g.",
                    tmp___0, dy_lp->tot.iters, tmp, luf_basis->min_vrratio);
        }
      } else {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1132
    if (retval > 0) {
#line 1132
      if (dy_opts->print.basis >= 2) {
        {
#line 1134
        tmp = dy_prtpivparms(-1);
#line 1134
        tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1134
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: factored with %s, basis stability %g.",
                    tmp___0, dy_lp->tot.iters, tmp, luf_basis->min_vrratio);
        }
      }
    }
    {
#line 1145
    if (retval == 0) {
#line 1145
      goto case_0;
    }
#line 1162
    if (retval == 1) {
#line 1162
      goto case_1;
    }
#line 1177
    if (retval == 2) {
#line 1177
      goto case_2;
    }
#line 1198
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1146
    try_again = (bool )0;
#line 1147
    retcode = (dyret_enum )1;
#line 1148
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1163
    if ((int )dy_opts->patch == 0) {
      {
#line 1164
      tmp___1 = dy_prtdyret((dyret_enum )-6);
#line 1164
      tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1164
      errmsg(308, rtnnme, dy_sys->nme, tmp___2, dy_lp->tot.iters, tmp___1);
#line 1166
      *calcflgs &= (unsigned int )(~ ((1 << 7) | (1 << 6)));
      }
#line 1167
      return ((dyret_enum )-6);
    }
#line 1169
    if (dy_opts->print.basis >= 2) {
      {
#line 1170
      tmp___3 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1170
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: attempting to patch singular basis.",
                  tmp___3, dy_lp->tot.iters);
      }
    }
    {
#line 1174
    adjust_basis(& patchcnt, & patches);
#line 1175
    patched = (bool )1;
    }
#line 1176
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1178
    retcode = (dyret_enum )-5;
#line 1180
    if (dy_opts->print.basis >= 2) {
      {
#line 1181
      tmp___4 = dy_prtpivparms(-1);
#line 1181
      tmp___5 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1181
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: factor failed at %s, numerical instability,",
                  tmp___5, dy_lp->tot.iters, tmp___4);
#line 1185
      dyio_outfmt(dy_logchn, dy_gtxecho, " max = %g, gro = %g.", (luf_basis->luf)->big_v,
                  (luf_basis->luf)->max_gro);
      }
    }
    {
#line 1188
    tmp___8 = dy_setpivparms(1, 0);
    }
#line 1188
    if ((int )tmp___8 == 0) {
      {
#line 1189
      tmp___6 = dy_prtpivparms(-1);
#line 1189
      tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1189
      errmsg(307, rtnnme, dy_sys->nme, tmp___7, dy_lp->tot.iters, tmp___6);
      }
#line 1191
      return (retcode);
    }
#line 1193
    if (dy_opts->print.basis >= 2) {
      {
#line 1194
      tmp___9 = dy_prtpivparms(-1);
#line 1194
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\ttrying again with %s.", tmp___9);
      }
    }
#line 1197
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1199
    errmsg(7, rtnnme, 1199, "inv_decomp return code", retval);
    }
#line 1200
    return ((dyret_enum )-10);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1209
  dy_lp->basis.etas = 0;
#line 1210
  if ((int )patched == 1) {
    {
#line 1211
    retcode = adjust_therest(patchcnt, patches);
#line 1212
    free((void *)patches);
    }
#line 1213
    if ((int )retcode == -10) {
      {
#line 1214
      tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1214
      errmsg(306, rtnnme, dy_sys->nme, tmp___10, dy_lp->tot.iters);
      }
#line 1216
      return ((dyret_enum )-10);
    }
#line 1218
    if (dy_opts->print.basis >= 1) {
      {
#line 1219
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t[%s]: compensated for basis correction.",
                  dy_sys->nme);
      }
    }
#line 1223
    if (! ((unsigned int )dy_lp->phase == 1U)) {
#line 1224
      *calcflgs |= (unsigned int )((1 << 7) | (1 << 6));
#line 1225
      if ((int )retcode == -3) {
#line 1225
        *calcflgs |= (unsigned int )(1 << 3);
      }
    }
#line 1226
    retcode = (dyret_enum )2;
  } else {
#line 1228
    if (*calcflgs & (unsigned int )(1 << 7)) {
#line 1228
      tmp___12 = 1;
    } else {
#line 1228
      tmp___12 = 0;
    }
#line 1228
    if (tmp___12) {
      {
#line 1229
      tmp___11 = dy_calcprimals();
      }
#line 1229
      if ((int )tmp___11 == 0) {
#line 1230
        *calcflgs &= (unsigned int )(~ (1 << 7));
#line 1231
        return ((dyret_enum )-10);
      }
    }
#line 1232
    if (*calcflgs & (unsigned int )(1 << 6)) {
#line 1232
      tmp___13 = 1;
    } else {
#line 1232
      tmp___13 = 0;
    }
#line 1232
    if (tmp___13) {
      {
#line 1232
      dy_calcduals();
      }
    }
  }
#line 1234
  return (retcode);
}
}
#line 1239 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_basis.c"
dyret_enum dy_pivot(int xipos , double abarij , double maxabarj ) 
{ 
  int retval ;
  double ratio ;
  dyret_enum retcode ;
  char const   *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1277
  rtnnme = "dy_pivot";
#line 1284
  ratio = dy_chkpiv(abarij, maxabarj);
  }
#line 1285
  if (ratio < 1.0) {
#line 1288
    if (dy_opts->print.basis >= 3) {
      {
#line 1289
      tmp = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1289
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n      %s(%d) pivot aborted; est. pivot stability %g.",
                  tmp, dy_lp->tot.iters, rtnnme, ratio);
      }
    }
#line 1294
    return ((dyret_enum )-1);
  }
  {
#line 1298
  retval = dy_glp_inv_update(luf_basis, xipos);
  }
#line 1300
  if (retval == 0) {
#line 1300
    if (dy_opts->print.basis >= 5) {
      {
#line 1302
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1302
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s(%d) estimated pivot stability %g; ",
                  tmp___0, dy_lp->tot.iters, ratio);
#line 1305
      dyio_outfmt(dy_logchn, dy_gtxecho, "measured pivot stability %g.", luf_basis->min_vrratio);
      }
    } else {
#line 1300
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1300
  if (retval > 0) {
#line 1300
    if (dy_opts->print.basis >= 3) {
      {
#line 1302
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1302
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s(%d) estimated pivot stability %g; ",
                  tmp___0, dy_lp->tot.iters, ratio);
#line 1305
      dyio_outfmt(dy_logchn, dy_gtxecho, "measured pivot stability %g.", luf_basis->min_vrratio);
      }
    }
  }
  {
#line 1309
  if (retval == 0) {
#line 1309
    goto case_0;
  }
#line 1312
  if (retval == 1) {
#line 1312
    goto case_1;
  }
#line 1321
  if (retval == 2) {
#line 1321
    goto case_2;
  }
#line 1331
  if (retval == 4) {
#line 1331
    goto case_4;
  }
#line 1331
  if (retval == 3) {
#line 1331
    goto case_4;
  }
#line 1340
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1310
  retcode = (dyret_enum )1;
#line 1311
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1313
  retcode = (dyret_enum )-6;
#line 1315
  if (dy_opts->print.basis >= 2) {
    {
#line 1316
    tmp___1 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1316
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s(%d) singular basis (structural) after pivot.",
                tmp___1, dy_lp->tot.iters);
    }
  }
#line 1320
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1322
  retcode = (dyret_enum )-5;
#line 1324
  if (dy_opts->print.basis >= 2) {
    {
#line 1325
    tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1325
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s(%d) singular basis (numeric) after pivot.",
                tmp___2, dy_lp->tot.iters);
    }
  }
#line 1329
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 1332
  retcode = (dyret_enum )-7;
#line 1334
  if (dy_opts->print.basis >= 2) {
#line 1335
    if (retval == 3) {
#line 1335
      tmp___3 = "eta matrix limit";
    } else {
#line 1335
      tmp___3 = "sparse vector area";
    }
    {
#line 1335
    tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 1335
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n    %s(%d) out of space (%s)", tmp___4,
                dy_lp->tot.iters, tmp___3);
    }
  }
#line 1339
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1341
  errmsg(1, rtnnme, 1341);
#line 1342
  retcode = (dyret_enum )-10;
  }
#line 1343
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1345
  return (retcode);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib.h"
void dy_glp_print(char const   *fmt  , ...) ;
#line 92
double dy_glp_watch(void) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib3.c"
void dy_glp_print(char const   *fmt  , ...) 
{ 
  va_list arg ;

  {
  {
#line 53
  __builtin_va_start(arg, fmt);
#line 54
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
           arg);
#line 55
  __builtin_va_end(arg);
#line 56
  fputc('\n', stdout);
  }
#line 58
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib3.c"
void dy_glp_fault(char const   *fmt  , ...) 
{ 
  va_list arg ;

  {
  {
#line 82
  __builtin_va_start(arg, fmt);
#line 83
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
           arg);
#line 84
  __builtin_va_end(arg);
#line 85
  fputc('\n', stdout);
#line 87
  dy_glp_free_lib_env();
#line 92
  exit(3);
  }
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib3.c"
void dy_glp_insist(char const   *expr , char const   *file , int line ) 
{ 


  {
  {
#line 116
  fputc('\n', stdout);
#line 117
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Assertion failed: %s, file %s, line %d\n",
          expr, file, line);
#line 120
  dy_glp_free_lib_env();
#line 125
  exit(3);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/glplib3.c"
double dy_glp_watch(void) 
{ 
  clock_t tmp ;

  {
  {
#line 147
  tmp = clock();
  }
#line 147
  return ((double )tmp / (double )1000000L);
}
}
#line 1919 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_primalRays(lpprob_struct *orig_lp , int *p_numRays , double ***p_rays ) ;
#line 1921
bool dy_dualRays(lpprob_struct *orig_lp , bool fullRay , int *p_numRays , double ***p_rays ,
                 bool trueDuals ) ;
#line 209 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_rays.c"
static bool testForPrimalRay(int j , int *p_dir , double **p_abarj ) 
{ 
  int k ;
  int m ;
  int kpos ;
  int dir ;
  flags statj ;
  flags statk ;
  double *abarj ;
  double abarkj ;
  double cbarj ;
  bool rayUp ;
  bool rayDown ;
  char const   *rtnnme ;
  int v ;
  char const   *tmp ;
  double tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  double tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  double tmp___16 ;
  char const   *tmp___17 ;

  {
#line 244
  k = 0;
#line 247
  abarkj = 0.0;
#line 250
  rtnnme = "testForPrimalRay";
#line 255
  if (dy_opts->print.rays >= 3) {
    {
#line 256
    tmp = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 256
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      Testing if column %s (%d) is a primal ray",
                tmp, j);
    }
  }
#line 261
  if ((unsigned long )p_abarj != (unsigned long )((void *)0)) {
#line 261
    *p_abarj = (double *)((void *)0);
  }
  {
#line 262
  *p_dir = 0;
#line 263
  rayUp = (bool )1;
#line 264
  rayDown = (bool )1;
#line 273
  cbarj = *(dy_cbar + j);
#line 274
  tmp___0 = fabs(cbarj - (double )0);
  }
#line 274
  if (tmp___0 <= dy_tols->cost) {
#line 277
    if (dy_opts->print.rays >= 4) {
      {
#line 278
      dyio_outfmt(dy_logchn, dy_gtxecho, ".\n\tcbar<%d> = %g; no ray.", j, cbarj);
      }
    }
#line 281
    return ((bool )1);
  } else
#line 283
  if (cbarj < (double )0) {
#line 284
    rayDown = (bool )0;
#line 285
    dir = 1;
  } else {
#line 287
    rayUp = (bool )0;
#line 288
    dir = -1;
  }
#line 290
  if (dy_opts->print.rays >= 4) {
#line 291
    if (dir < 0) {
#line 291
      tmp___1 = "down";
    } else {
#line 291
      tmp___1 = "up";
    }
    {
#line 291
    dyio_outfmt(dy_logchn, dy_gtxecho, ".\n\tcbar<%d> = %g allows %s ray", j, cbarj,
                tmp___1);
    }
  }
#line 298
  statj = *(dy_status + j) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 299
  if (statj & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 299
    tmp___2 = 1;
  } else {
#line 299
    tmp___2 = 0;
  }
#line 299
  if (tmp___2) {
#line 300
    rayUp = (bool )0;
#line 301
    rayDown = (bool )0;
  } else {
    {
#line 304
    if (statj == (flags )(1 << 5)) {
#line 304
      goto case_exp;
    }
#line 308
    if (statj == (flags )(1 << 7)) {
#line 308
      goto case_exp___0;
    }
#line 313
    if (statj == (flags )(1 << 6)) {
#line 313
      goto case_exp___1;
    }
#line 318
    if (statj == (flags )(1 << 8)) {
#line 318
      goto case_exp___2;
    }
#line 320
    if (statj == (flags )(1 << 9)) {
#line 320
      goto case_exp___3;
    }
#line 326
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 305
    rayUp = (bool )0;
#line 306
    rayDown = (bool )0;
#line 307
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 309
    rayDown = (bool )0;
#line 310
    if (*(dy_sys->vub + j) < dy_tols->inf) {
#line 311
      rayUp = (bool )0;
    }
#line 312
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 314
    rayUp = (bool )0;
#line 315
    if (*(dy_sys->vlb + j) > - dy_tols->inf) {
#line 316
      rayDown = (bool )0;
    }
#line 317
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 319
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 321
    if (*(dy_sys->vlb + j) > - dy_tols->inf) {
#line 322
      rayDown = (bool )0;
    }
#line 323
    if (*(dy_sys->vub + j) < dy_tols->inf) {
#line 324
      rayUp = (bool )0;
    }
#line 325
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 327
    errmsg(1, rtnnme, 327);
    }
#line 328
    return ((bool )0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 329
  if ((int )rayUp == 0) {
#line 329
    if ((int )rayDown == 0) {
#line 332
      if (dy_opts->print.rays >= 4) {
#line 333
        if (statj & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 333
          tmp___6 = 1;
        } else {
#line 333
          tmp___6 = 0;
        }
#line 333
        if (tmp___6) {
          {
#line 334
          tmp___3 = dy_prtvstat(statj);
#line 334
          dyio_outfmt(dy_logchn, dy_gtxecho, "; status %s; no ray.", j, cbarj, tmp___3);
          }
        } else
#line 337
        if (dir == 1) {
          {
#line 338
          tmp___4 = dy_prtvstat(statj);
#line 338
          dyio_outfmt(dy_logchn, dy_gtxecho, "; status %s, ub = %g; no ray.", tmp___4,
                      *(dy_sys->vub + j));
          }
        } else {
          {
#line 341
          tmp___5 = dy_prtvstat(statj);
#line 341
          dyio_outfmt(dy_logchn, dy_gtxecho, "; status %s, lb = %g; no ray.", tmp___5,
                      *(dy_sys->vlb + j));
          }
        }
      }
#line 344
      return ((bool )1);
    }
  }
  {
#line 348
  abarj = (double *)((void *)0);
#line 349
  tmp___8 = consys_getcol_ex(dy_sys, j, & abarj);
  }
#line 349
  if ((int )tmp___8 == 0) {
    {
#line 350
    tmp___7 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 350
    errmsg(122, rtnnme, dy_sys->nme, "column", tmp___7, j);
    }
#line 352
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 352
      free((void *)abarj);
      }
    }
#line 353
    return ((bool )0);
  }
  {
#line 354
  dy_ftran(abarj, (bool )0);
#line 355
  m = dy_sys->concnt;
  }
#line 366
  if ((int )rayUp == 1) {
#line 367
    kpos = 1;
    {
#line 367
    while (1) {
      while_continue: /* CIL Label */ ;
#line 367
      if (! (kpos <= m)) {
#line 367
        goto while_break;
      }
      {
#line 368
      tmp___9 = fabs(*(abarj + kpos));
      }
#line 368
      if (tmp___9 < dy_tols->zero) {
#line 368
        *(abarj + kpos) = (double )0;
      }
#line 369
      abarkj = *(abarj + kpos);
#line 370
      if (abarkj == 0.0) {
#line 370
        goto __Cont;
      }
#line 371
      k = *(dy_basis + kpos);
#line 372
      statk = *(dy_status + k);
#line 373
      if (statk & (unsigned int )(1 << 4)) {
#line 373
        tmp___10 = 1;
      } else {
#line 373
        tmp___10 = 0;
      }
#line 373
      if (tmp___10) {
#line 373
        goto __Cont;
      }
#line 374
      if (abarkj > 0.0) {
#line 374
        if (*(dy_sys->vlb + k) > - dy_tols->inf) {
#line 376
          rayUp = (bool )0;
#line 377
          goto while_break;
        } else {
#line 374
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 374
      if (abarkj < 0.0) {
#line 374
        if (*(dy_sys->vub + k) < dy_tols->inf) {
#line 376
          rayUp = (bool )0;
#line 377
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 367
      kpos ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 379
    if (dy_opts->print.rays >= 4) {
#line 380
      if ((int )rayUp == 0) {
        {
#line 381
        tmp___11 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 381
        dyio_outfmt(dy_logchn, dy_gtxecho, "; basis pos\'n %d: abar<%d,%d> = %g; %s (%d) ",
                    kpos, k, j, abarkj, tmp___11, k);
        }
#line 384
        if (abarkj < (double )0) {
          {
#line 385
          dyio_outfmt(dy_logchn, dy_gtxecho, "ub = %g ; no ray up.", *(dy_sys->vub + k));
          }
        } else {
          {
#line 388
          dyio_outfmt(dy_logchn, dy_gtxecho, "lb = %g ; no ray up.", *(dy_sys->vlb + k));
          }
        }
      } else {
        {
#line 391
        dyio_outfmt(dy_logchn, dy_gtxecho, "; confirmed.");
        }
      }
    }
  }
#line 398
  if ((int )rayDown == 1) {
#line 399
    kpos = 1;
    {
#line 399
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 399
      if (! (kpos <= m)) {
#line 399
        goto while_break___0;
      }
      {
#line 400
      tmp___12 = fabs(*(abarj + kpos));
      }
#line 400
      if (tmp___12 < dy_tols->zero) {
#line 400
        *(abarj + kpos) = (double )0;
      }
#line 401
      abarkj = *(abarj + kpos);
#line 402
      if (abarkj == 0.0) {
#line 402
        goto __Cont___0;
      }
#line 403
      k = *(dy_basis + kpos);
#line 404
      statk = *(dy_status + k);
#line 405
      if (statk & (unsigned int )(1 << 4)) {
#line 405
        tmp___13 = 1;
      } else {
#line 405
        tmp___13 = 0;
      }
#line 405
      if (tmp___13) {
#line 405
        goto __Cont___0;
      }
#line 406
      if (abarkj > 0.0) {
#line 406
        if (*(dy_sys->vub + k) < dy_tols->inf) {
#line 408
          rayDown = (bool )0;
#line 409
          goto while_break___0;
        } else {
#line 406
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 406
      if (abarkj < 0.0) {
#line 406
        if (*(dy_sys->vlb + k) > - dy_tols->inf) {
#line 408
          rayDown = (bool )0;
#line 409
          goto while_break___0;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 399
      kpos ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 411
    if (dy_opts->print.rays >= 4) {
#line 412
      if ((int )rayDown == 0) {
        {
#line 413
        tmp___14 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 413
        dyio_outfmt(dy_logchn, dy_gtxecho, "; basis pos\'n %d: abar<%d,%d> = %g; %s (%d) ",
                    kpos, k, j, abarkj, tmp___14, k);
        }
#line 416
        if (abarkj < (double )0) {
          {
#line 417
          dyio_outfmt(dy_logchn, dy_gtxecho, "lb = %g ; no ray down.", *(dy_sys->vlb + k));
          }
        } else {
          {
#line 420
          dyio_outfmt(dy_logchn, dy_gtxecho, "ub = %g ; no ray down.", *(dy_sys->vub + k));
          }
        }
      } else {
        {
#line 423
        dyio_outfmt(dy_logchn, dy_gtxecho, "; confirmed.");
        }
      }
    }
  }
#line 428
  if ((int )rayUp == 1) {
#line 428
    goto _L___1;
  } else
#line 428
  if ((int )rayDown == 1) {
    _L___1: /* CIL Label */ 
#line 428
    if (dy_opts->print.rays >= 6) {
      {
#line 429
      tmp___15 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 429
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    active ray %s (%d)\n      non-zeros:",
                  tmp___15, j);
#line 432
      v = 0;
#line 433
      kpos = 1;
      }
      {
#line 433
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 433
        if (! (kpos <= m)) {
#line 433
          goto while_break___1;
        }
        {
#line 434
        abarkj = *(abarj + kpos);
#line 435
        tmp___16 = fabs(abarkj - (double )0);
        }
#line 435
        if (tmp___16 <= dy_tols->zero) {
#line 435
          goto __Cont___1;
        }
        {
#line 436
        k = *(dy_basis + kpos);
#line 437
        tmp___17 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 437
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s (%d) %g)", tmp___17, k, abarkj);
#line 439
        v ++;
        }
#line 440
        if (v % 3 == 0) {
          {
#line 440
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t");
          }
        }
        __Cont___1: /* CIL Label */ 
#line 433
        kpos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 447
  if ((int )rayUp == 1) {
#line 447
    goto _L___2;
  } else
#line 447
  if ((int )rayDown == 1) {
    _L___2: /* CIL Label */ 
#line 448
    *p_dir = dir;
#line 449
    if ((unsigned long )p_abarj != (unsigned long )((void *)0)) {
#line 450
      *p_abarj = abarj;
    } else
#line 452
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 452
      free((void *)abarj);
      }
    }
#line 454
    if (dy_opts->print.rays == 3) {
      {
#line 455
      dyio_outfmt(dy_logchn, dy_gtxecho, ": yes.");
      }
    }
  } else {
#line 459
    if ((unsigned long )abarj != (unsigned long )((void *)0)) {
      {
#line 459
      free((void *)abarj);
      }
    }
#line 461
    if (dy_opts->print.rays == 3) {
      {
#line 462
      dyio_outfmt(dy_logchn, dy_gtxecho, ": no.");
      }
    }
  }
#line 466
  return ((bool )1);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_rays.c"
bool dy_primalRays(lpprob_struct *orig_lp , int *p_numRays , double ***p_rays ) 
{ 
  int m ;
  int n ;
  int i ;
  int j ;
  int m_orig ;
  int n_orig ;
  int j_orig ;
  int retval ;
  bool error ;
  double *sc_abarj ;
  consys_struct *orig_sys ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  double invSj ;
  double dir ;
  int numCols ;
  int numRays ;
  int maxRays ;
  int rayDir ;
  int j_ray ;
  int j_orig_ray ;
  int i_orig_ray ;
  flags statj_ray ;
  double **rayCollection ;
  bool ourCollection ;
  bool logical ;
  double *ray ;
  char *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  bool tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 519
  rtnnme = (char *)"dy_primalRays";
#line 535
  maxRays = *p_numRays;
#line 536
  if (maxRays == 0) {
#line 537
    return ((bool )1);
  }
#line 538
  *p_numRays = 0;
#line 539
  rayCollection = *p_rays;
#line 540
  if ((unsigned long )rayCollection != (unsigned long )((void *)0)) {
#line 541
    ourCollection = (bool )0;
  } else {
#line 543
    ourCollection = (bool )1;
  }
#line 549
  orig_sys = orig_lp->consys;
  {
#line 551
  if ((int )orig_lp->lpret == 2) {
#line 551
    goto case_2;
  }
#line 554
  if ((int )orig_lp->lpret == 4) {
#line 554
    goto case_4;
  }
#line 554
  if ((int )orig_lp->lpret == 1) {
#line 554
    goto case_4;
  }
#line 557
  goto switch_default;
  case_2: /* CIL Label */ 
#line 552
  goto switch_break;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 555
  tmp = dy_prtlpret(orig_lp->lpret);
#line 555
  warn(954, rtnnme, orig_sys->nme, "primal", tmp);
  }
#line 556
  return ((bool )1);
  switch_default: /* CIL Label */ 
  {
#line 558
  tmp___0 = dy_prtlpret(orig_lp->lpret);
#line 558
  errmsg(954, rtnnme, orig_sys->nme, "primal", tmp___0);
  }
#line 559
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 565
  n_orig = orig_sys->varcnt;
#line 566
  m_orig = orig_sys->concnt;
#line 567
  i_orig_ray = -1;
#line 568
  j_orig_ray = (int )orig_lp->obj;
#line 569
  if (j_orig_ray < 0) {
#line 570
    j_orig_ray = - j_orig_ray;
#line 571
    rayDir = -1;
  } else {
#line 573
    rayDir = 1;
  }
#line 574
  if (j_orig_ray > n_orig) {
#line 575
    i_orig_ray = j_orig_ray - n_orig;
#line 576
    logical = (bool )1;
  } else {
#line 578
    logical = (bool )0;
  }
#line 584
  if ((int )ourCollection == 1) {
    {
#line 585
    tmp___1 = malloc((unsigned long )maxRays * sizeof(double *));
#line 585
    rayCollection = (double **)tmp___1;
    }
  }
  {
#line 586
  sc_abarj = (double *)((void *)0);
#line 587
  scaled = dy_isscaled();
  }
#line 588
  if ((int )scaled == 1) {
    {
#line 589
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 597
  error = (bool )0;
#line 598
  numRays = 0;
#line 599
  if ((int )logical == 1) {
#line 600
    j_ray = *(dy_origcons + i_orig_ray);
  } else {
#line 602
    j_ray = *(dy_origvars + j_orig_ray);
  }
#line 603
  n = dy_sys->varcnt;
#line 604
  m = dy_sys->concnt;
#line 609
  numCols = 1;
  {
#line 609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 609
    if (! (numCols <= n)) {
#line 609
      goto while_break;
    }
#line 610
    statj_ray = *(dy_status + j_ray);
#line 611
    if (statj_ray & (unsigned int )(((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (1 << 5))) {
#line 611
      tmp___2 = 1;
    } else {
#line 611
      tmp___2 = 0;
    }
#line 611
    if (tmp___2) {
#line 611
      goto __Cont;
    }
    {
#line 615
    tmp___3 = testForPrimalRay(j_ray, & rayDir, & sc_abarj);
#line 615
    retval = (int )tmp___3;
    }
#line 616
    if (retval == 0) {
      {
#line 617
      tmp___4 = consys_nme(dy_sys, (char )'v', j_ray, (bool )0, (char *)((void *)0));
#line 617
      errmsg(447, rtnnme, dy_sys->nme, tmp___4, j_ray, "primal");
#line 619
      error = (bool )1;
      }
#line 620
      goto while_break;
    }
#line 621
    if (rayDir == 0) {
#line 621
      goto __Cont;
    }
    {
#line 646
    tmp___5 = calloc((size_t )(n_orig + 1), sizeof(double ));
#line 646
    ray = (double *)tmp___5;
#line 647
    *(rayCollection + numRays) = ray;
#line 648
    numRays ++;
#line 649
    dir = - 1.0 * (double )rayDir;
    }
#line 650
    if ((int )logical == 1) {
#line 651
      i_orig_ray = *(dy_actcons + j_ray);
#line 652
      if ((unsigned int )*(orig_sys->ctyp + i_orig_ray) == 2U) {
#line 653
        dir = - dir;
      }
    } else {
#line 655
      j_orig_ray = *(dy_actvars + j_ray);
    }
#line 657
    if ((int )scaled == 1) {
#line 658
      if ((int )logical == 1) {
#line 659
        invSj = (double )(*(rscale + i_orig_ray) * (double const   )dir);
      } else {
#line 661
        invSj = (double )(((double const   )1 / *(cscale + j_orig_ray)) * (double const   )dir);
      }
#line 662
      i = 1;
      {
#line 662
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 662
        if (! (i <= m)) {
#line 662
          goto while_break___0;
        }
#line 663
        if (*(sc_abarj + i) == (double )0) {
#line 663
          goto __Cont___0;
        }
#line 664
        j = *(dy_basis + i);
#line 665
        if (j <= dy_sys->concnt) {
#line 665
          goto __Cont___0;
        }
        {
#line 666
        j_orig = *(dy_actvars + j);
#line 667
        *(ray + j_orig) = (double )((*(cscale + j_orig) * (double const   )*(sc_abarj + i)) * (double const   )invSj);
#line 668
        tmp___6 = fabs(*(ray + j_orig));
        }
#line 668
        if (tmp___6 < dy_tols->zero) {
#line 668
          *(ray + j_orig) = (double )0;
        }
        __Cont___0: /* CIL Label */ 
#line 662
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 670
      i = 1;
      {
#line 670
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 670
        if (! (i <= m)) {
#line 670
          goto while_break___1;
        }
#line 671
        if (*(sc_abarj + i) == (double )0) {
#line 671
          goto __Cont___1;
        }
#line 672
        j = *(dy_basis + i);
#line 673
        if (j <= dy_sys->concnt) {
#line 673
          goto __Cont___1;
        }
        {
#line 674
        j_orig = *(dy_actvars + j);
#line 675
        *(ray + j_orig) = *(sc_abarj + i) * dir;
#line 676
        tmp___7 = fabs(*(ray + j_orig));
        }
#line 676
        if (tmp___7 < dy_tols->zero) {
#line 676
          *(ray + j_orig) = (double )0;
        }
        __Cont___1: /* CIL Label */ 
#line 670
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 677
    if ((unsigned long )sc_abarj != (unsigned long )((void *)0)) {
      {
#line 678
      free((void *)sc_abarj);
#line 679
      sc_abarj = (double *)((void *)0);
      }
    }
#line 680
    if ((int )logical == 0) {
#line 681
      *(ray + j_orig_ray) = 1.0 * dir;
    }
#line 684
    if (dy_opts->print.rays >= 5) {
#line 685
      if ((int )logical == 1) {
#line 686
        j_orig = orig_sys->varcnt + i_orig_ray;
      } else {
#line 688
        j_orig = j_orig_ray;
      }
      {
#line 689
      tmp___8 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 689
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ray<%d>: %s (%d)\n      non-zeros:",
                  numRays, tmp___8, j_orig);
#line 692
      i = 0;
#line 693
      j_orig = 1;
      }
      {
#line 693
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 693
        if (! (j_orig <= n_orig)) {
#line 693
          goto while_break___2;
        }
#line 694
        if (*(ray + j_orig) != (double )0) {
          {
#line 695
          tmp___9 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 695
          dyio_outfmt(dy_logchn, dy_gtxecho, " (%s (%d) %g)", tmp___9, j_orig, *(ray + j_orig));
          }
        }
#line 698
        i ++;
#line 699
        if (i % 3 == 0) {
          {
#line 699
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t");
          }
        }
#line 693
        j_orig ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 702
    if (numRays >= maxRays) {
#line 702
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 609
    numCols ++;
#line 609
    j_ray = j_ray % n + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if ((unsigned long )sc_abarj != (unsigned long )((void *)0)) {
    {
#line 708
    free((void *)sc_abarj);
    }
  }
#line 709
  if ((int )error == 1) {
#line 710
    if ((unsigned long )rayCollection != (unsigned long )((void *)0)) {
#line 711
      i = 0;
      {
#line 711
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 711
        if (! (i < numRays)) {
#line 711
          goto while_break___3;
        }
#line 712
        if ((unsigned long )*(rayCollection + i) != (unsigned long )((void *)0)) {
          {
#line 713
          free((void *)*(rayCollection + i));
#line 714
          *(rayCollection + i) = (double *)((void *)0);
          }
        }
#line 711
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 715
      if ((int )ourCollection == 1) {
        {
#line 715
        free((void *)rayCollection);
        }
      }
    }
#line 716
    return ((bool )0);
  }
#line 720
  *p_rays = rayCollection;
#line 721
  *p_numRays = numRays;
#line 723
  return ((bool )1);
}
}
#line 727 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_rays.c"
static void testForDualRay(int i , int *p_dir , double **p_abari ) 
{ 
  int bvi ;
  int j ;
  int k ;
  int m ;
  int n ;
  int dir ;
  flags stati ;
  flags statk ;
  double abarik ;
  bool rayUp ;
  bool rayDown ;
  double *betai ;
  double *abari ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  double tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  double tmp___26 ;
  char const   *tmp___27 ;

  {
#line 784
  statk = (flags )0;
#line 785
  abarik = 0.0;
#line 791
  if (dy_opts->print.rays >= 3) {
    {
#line 792
    tmp = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 792
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n      Testing if row %s (%d) is a dual ray",
                tmp, i);
    }
  }
#line 800
  betai = (double *)((void *)0);
#line 801
  abari = (double *)((void *)0);
#line 802
  if ((unsigned long )p_abari != (unsigned long )((void *)0)) {
#line 802
    *p_abari = (double *)((void *)0);
  }
#line 803
  *p_dir = 0;
#line 804
  rayUp = (bool )0;
#line 805
  rayDown = (bool )0;
#line 806
  dir = 0;
#line 821
  bvi = *(dy_basis + i);
#line 822
  stati = *(dy_status + bvi) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
  {
#line 824
  if (stati == (flags )(1 << 10)) {
#line 824
    goto case_exp;
  }
#line 828
  if (stati == (flags )(1 << 11)) {
#line 828
    goto case_exp___0;
  }
#line 832
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 825
  rayDown = (bool )1;
#line 826
  dir = -1;
#line 827
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 829
  rayUp = (bool )1;
#line 830
  dir = 1;
#line 831
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 833
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 842
  if (dir == 0) {
#line 843
    if (dy_opts->print.rays >= 4) {
      {
#line 844
      tmp___0 = dy_prtvstat(stati);
#line 844
      tmp___1 = consys_nme(dy_sys, (char )'v', bvi, (bool )0, (char *)((void *)0));
#line 844
      dyio_outfmt(dy_logchn, dy_gtxecho, ".\n\tbasic var %s (%d) %s; no ray.", tmp___1,
                  bvi, tmp___0);
      }
    }
#line 847
    return;
  } else
#line 849
  if (dy_opts->print.rays >= 4) {
#line 850
    if (dir < 0) {
#line 850
      tmp___2 = "down";
    } else {
#line 850
      tmp___2 = "up";
    }
    {
#line 850
    tmp___3 = dy_prtvstat(stati);
#line 850
    tmp___4 = consys_nme(dy_sys, (char )'v', bvi, (bool )0, (char *)((void *)0));
#line 850
    dyio_outfmt(dy_logchn, dy_gtxecho, ".\n\tbasic var %s (%d) %s allows %s ray",
                tmp___4, bvi, tmp___3, tmp___2);
    }
  }
  {
#line 860
  m = dy_sys->concnt;
#line 861
  n = dy_sys->varcnt;
#line 862
  tmp___5 = calloc((size_t )(m + 1), sizeof(double ));
#line 862
  betai = (double *)tmp___5;
#line 863
  tmp___6 = malloc((unsigned long )(n + 1) * sizeof(double ));
#line 863
  abari = (double *)tmp___6;
#line 864
  *(betai + i) = 1.0;
#line 865
  dy_btran(betai);
  }
#line 886
  if ((int )rayUp == 1) {
#line 887
    k = 1;
    {
#line 887
    while (1) {
      while_continue: /* CIL Label */ ;
#line 887
      if (! (k <= n)) {
#line 887
        goto while_break;
      }
#line 888
      *(abari + k) = (double )0;
#line 889
      statk = *(dy_status + k) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 890
      if (statk & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 890
        tmp___7 = 1;
      } else {
#line 890
        tmp___7 = 0;
      }
#line 890
      if (tmp___7) {
#line 890
        goto __Cont;
      }
      {
#line 891
      abarik = consys_dotcol(dy_sys, k, betai);
#line 892
      *(abari + k) = abarik;
      }
#line 893
      if (statk & (unsigned int )(1 << 5)) {
#line 893
        tmp___8 = 1;
      } else {
#line 893
        tmp___8 = 0;
      }
#line 893
      if (tmp___8) {
#line 893
        goto __Cont;
      }
      {
#line 894
      tmp___9 = fabs(abarik - (double )0);
      }
#line 894
      if (tmp___9 <= dy_tols->zero) {
#line 894
        goto __Cont;
      }
#line 895
      if (statk & (unsigned int )((1 << 9) | (1 << 8))) {
#line 895
        tmp___10 = 1;
      } else {
#line 895
        tmp___10 = 0;
      }
#line 895
      if (tmp___10) {
#line 898
        rayUp = (bool )0;
#line 899
        goto while_break;
      } else {
#line 895
        if (statk & (unsigned int )(1 << 7)) {
#line 895
          tmp___11 = 1;
        } else {
#line 895
          tmp___11 = 0;
        }
#line 895
        if (tmp___11) {
#line 895
          if (abarik < (double )0) {
#line 898
            rayUp = (bool )0;
#line 899
            goto while_break;
          } else {
#line 895
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 895
          if (statk & (unsigned int )(1 << 6)) {
#line 895
            tmp___12 = 1;
          } else {
#line 895
            tmp___12 = 0;
          }
#line 895
          if (tmp___12) {
#line 895
            if (abarik > (double )0) {
#line 898
              rayUp = (bool )0;
#line 899
              goto while_break;
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 887
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 901
    if (dy_opts->print.rays >= 4) {
#line 902
      if ((int )rayUp == 0) {
        {
#line 903
        tmp___13 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 903
        tmp___14 = dy_prtvstat(statk);
#line 903
        dyio_outfmt(dy_logchn, dy_gtxecho, "; %s %s (%d): abar<%d,%d> = %g; %s (%d) ",
                    tmp___14, tmp___13, k, i, k, abarik);
        }
#line 907
        if (statk & (unsigned int )(1 << 8)) {
#line 907
          tmp___15 = 1;
        } else {
#line 907
          tmp___15 = 0;
        }
#line 907
        if (tmp___15) {
          {
#line 908
          dyio_outfmt(dy_logchn, dy_gtxecho, "; no ray.");
          }
        } else {
          {
#line 910
          dyio_outfmt(dy_logchn, dy_gtxecho, "; no ray up.");
          }
        }
      } else {
        {
#line 912
        dyio_outfmt(dy_logchn, dy_gtxecho, "; confirmed.");
        }
      }
    }
  }
#line 918
  if ((int )rayDown == 1) {
#line 919
    k = 1;
    {
#line 919
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 919
      if (! (k <= n)) {
#line 919
        goto while_break___0;
      }
#line 920
      *(abari + k) = (double )0;
#line 921
      statk = *(dy_status + k) & (unsigned int )((((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4)) | (((1 << 5) | (1 << 6)) | (1 << 7))) | ((1 << 9) | (1 << 8)));
#line 922
      if (statk & (unsigned int )((((((1 | (1 << 10)) | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 11)) | (1 << 4))) {
#line 922
        tmp___16 = 1;
      } else {
#line 922
        tmp___16 = 0;
      }
#line 922
      if (tmp___16) {
#line 922
        goto __Cont___0;
      }
      {
#line 923
      abarik = consys_dotcol(dy_sys, k, betai);
#line 924
      *(abari + k) = abarik;
      }
#line 925
      if (statk & (unsigned int )(1 << 5)) {
#line 925
        tmp___17 = 1;
      } else {
#line 925
        tmp___17 = 0;
      }
#line 925
      if (tmp___17) {
#line 925
        goto __Cont___0;
      }
      {
#line 926
      tmp___18 = fabs(abarik - (double )0);
      }
#line 926
      if (tmp___18 <= dy_tols->zero) {
#line 926
        goto __Cont___0;
      }
#line 927
      if (statk & (unsigned int )((1 << 9) | (1 << 8))) {
#line 927
        tmp___19 = 1;
      } else {
#line 927
        tmp___19 = 0;
      }
#line 927
      if (tmp___19) {
#line 930
        rayDown = (bool )0;
#line 931
        goto while_break___0;
      } else {
#line 927
        if (statk & (unsigned int )(1 << 7)) {
#line 927
          tmp___20 = 1;
        } else {
#line 927
          tmp___20 = 0;
        }
#line 927
        if (tmp___20) {
#line 927
          if (abarik > (double )0) {
#line 930
            rayDown = (bool )0;
#line 931
            goto while_break___0;
          } else {
#line 927
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 927
          if (statk & (unsigned int )(1 << 6)) {
#line 927
            tmp___21 = 1;
          } else {
#line 927
            tmp___21 = 0;
          }
#line 927
          if (tmp___21) {
#line 927
            if (abarik < (double )0) {
#line 930
              rayDown = (bool )0;
#line 931
              goto while_break___0;
            }
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 919
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 933
    if (dy_opts->print.rays >= 4) {
#line 934
      if ((int )rayDown == 0) {
        {
#line 935
        tmp___22 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 935
        tmp___23 = dy_prtvstat(statk);
#line 935
        dyio_outfmt(dy_logchn, dy_gtxecho, "; %s %s (%d): abar<%d,%d> = %g; %s (%d) ",
                    tmp___23, tmp___22, k, i, k, abarik);
        }
#line 939
        if (statk & (unsigned int )(1 << 8)) {
#line 939
          tmp___24 = 1;
        } else {
#line 939
          tmp___24 = 0;
        }
#line 939
        if (tmp___24) {
          {
#line 940
          dyio_outfmt(dy_logchn, dy_gtxecho, "; no ray.");
          }
        } else {
          {
#line 942
          dyio_outfmt(dy_logchn, dy_gtxecho, "; no ray down.");
          }
        }
      } else {
        {
#line 944
        dyio_outfmt(dy_logchn, dy_gtxecho, "; confirmed.");
        }
      }
    }
  }
#line 947
  if ((unsigned long )betai != (unsigned long )((void *)0)) {
    {
#line 947
    free((void *)betai);
    }
  }
#line 950
  if ((int )rayUp == 1) {
#line 950
    goto _L___1;
  } else
#line 950
  if ((int )rayDown == 1) {
    _L___1: /* CIL Label */ 
#line 950
    if (dy_opts->print.rays >= 6) {
      {
#line 951
      tmp___25 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 951
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    active ray %s (%d)\n      non-zeros:",
                  tmp___25, i);
#line 954
      j = 0;
#line 955
      k = 1;
      }
      {
#line 955
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 955
        if (! (k <= n)) {
#line 955
          goto while_break___1;
        }
        {
#line 956
        abarik = *(abari + k);
#line 957
        tmp___26 = fabs(abarik - (double )0);
        }
#line 957
        if (tmp___26 <= dy_tols->zero) {
#line 957
          goto __Cont___1;
        }
        {
#line 958
        tmp___27 = consys_nme(dy_sys, (char )'v', k, (bool )0, (char *)((void *)0));
#line 958
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s (%d) %g)", tmp___27, k, abarik);
#line 960
        j ++;
        }
#line 961
        if (j % 3 == 0) {
          {
#line 961
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t");
          }
        }
        __Cont___1: /* CIL Label */ 
#line 955
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 968
  if ((int )rayUp == 1) {
#line 968
    goto _L___2;
  } else
#line 968
  if ((int )rayDown == 1) {
    _L___2: /* CIL Label */ 
#line 969
    *p_dir = dir;
#line 970
    if ((unsigned long )p_abari != (unsigned long )((void *)0)) {
#line 971
      *p_abari = abari;
    } else
#line 973
    if ((unsigned long )abari != (unsigned long )((void *)0)) {
      {
#line 973
      free((void *)abari);
      }
    }
#line 975
    if (dy_opts->print.rays == 3) {
      {
#line 976
      dyio_outfmt(dy_logchn, dy_gtxecho, ": yes.");
      }
    }
  } else {
#line 980
    if ((unsigned long )abari != (unsigned long )((void *)0)) {
      {
#line 980
      free((void *)abari);
      }
    }
#line 982
    if (dy_opts->print.rays == 3) {
      {
#line 983
      dyio_outfmt(dy_logchn, dy_gtxecho, ": no.");
      }
    }
  }
#line 987
  return;
}
}
#line 990 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_rays.c"
bool dy_dualRays(lpprob_struct *orig_lp , bool fullRay , int *p_numRays , double ***p_rays ,
                 bool trueDuals ) 
{ 
  int m ;
  int n ;
  int i ;
  int j ;
  int m_orig ;
  int n_orig ;
  int i_orig ;
  int j_orig ;
  int rayLen ;
  bool error ;
  double *sc_abari ;
  consys_struct *orig_sys ;
  bool scaled ;
  double const   *rscale ;
  double const   *cscale ;
  double Si ;
  double rayk ;
  int numRays ;
  int maxRays ;
  int rayDir ;
  int i_ray ;
  int i_orig_ray ;
  int bv_ray ;
  int bv_orig_ray ;
  flags statbv_ray ;
  double **rayCollection ;
  bool ourCollection ;
  bool logical ;
  double *ray ;
  char *rtnnme ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  double tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;

  {
#line 1060
  rtnnme = (char *)"dy_dualRays";
#line 1076
  maxRays = *p_numRays;
#line 1077
  if (maxRays == 0) {
#line 1078
    return ((bool )1);
  }
#line 1079
  *p_numRays = 0;
#line 1080
  rayCollection = *p_rays;
#line 1081
  if ((unsigned long )rayCollection != (unsigned long )((void *)0)) {
#line 1082
    ourCollection = (bool )0;
  } else {
#line 1084
    ourCollection = (bool )1;
  }
#line 1090
  orig_sys = orig_lp->consys;
  {
#line 1092
  if ((int )orig_lp->lpret == 4) {
#line 1092
    goto case_4;
  }
#line 1095
  if ((int )orig_lp->lpret == 2) {
#line 1095
    goto case_2;
  }
#line 1095
  if ((int )orig_lp->lpret == 1) {
#line 1095
    goto case_2;
  }
#line 1098
  goto switch_default;
  case_4: /* CIL Label */ 
#line 1093
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1096
  tmp = dy_prtlpret(orig_lp->lpret);
#line 1096
  warn(954, rtnnme, orig_sys->nme, "dual", tmp);
  }
#line 1097
  return ((bool )1);
  switch_default: /* CIL Label */ 
  {
#line 1099
  tmp___0 = dy_prtlpret(orig_lp->lpret);
#line 1099
  errmsg(954, rtnnme, orig_sys->nme, "dual", tmp___0);
  }
#line 1100
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 1108
  if ((int )ourCollection == 1) {
    {
#line 1109
    tmp___1 = malloc((unsigned long )maxRays * sizeof(double *));
#line 1109
    rayCollection = (double **)tmp___1;
    }
  }
  {
#line 1110
  sc_abari = (double *)((void *)0);
#line 1111
  scaled = dy_isscaled();
  }
#line 1112
  if ((int )scaled == 1) {
    {
#line 1113
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 1120
  n_orig = orig_sys->varcnt;
#line 1121
  m_orig = orig_sys->concnt;
#line 1122
  if ((int )fullRay == 1) {
#line 1123
    rayLen = m_orig + n_orig;
  } else {
#line 1125
    rayLen = m_orig;
  }
#line 1126
  n = dy_sys->varcnt;
#line 1127
  m = dy_sys->concnt;
#line 1128
  error = (bool )0;
#line 1129
  numRays = 0;
#line 1130
  rayDir = 0;
#line 1136
  i_ray = 1;
  {
#line 1136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1136
    if (! (i_ray <= m)) {
#line 1136
      goto while_break;
    }
#line 1137
    bv_ray = *(dy_basis + i_ray);
#line 1138
    statbv_ray = *(dy_status + bv_ray);
#line 1139
    if (statbv_ray & (unsigned int )((1 << 11) | (1 << 10))) {
#line 1139
      tmp___2 = 1;
    } else {
#line 1139
      tmp___2 = 0;
    }
#line 1139
    if (! tmp___2) {
#line 1139
      goto __Cont;
    }
    {
#line 1144
    testForDualRay(i_ray, & rayDir, & sc_abari);
    }
#line 1145
    if (rayDir == 0) {
#line 1145
      goto __Cont;
    }
    {
#line 1146
    tmp___3 = calloc((size_t )(rayLen + 1), sizeof(double ));
#line 1146
    ray = (double *)tmp___3;
#line 1147
    *(rayCollection + numRays) = ray;
#line 1148
    numRays ++;
#line 1176
    i_orig_ray = *(dy_actcons + i_ray);
    }
#line 1177
    if (bv_ray <= m) {
#line 1178
      logical = (bool )1;
#line 1179
      bv_orig_ray = *(dy_actcons + bv_ray);
#line 1180
      if ((int )scaled == 1) {
#line 1180
        if (*(rscale + bv_orig_ray) < (double const   )0) {
#line 1181
          rayDir = - rayDir;
        }
      }
    } else {
#line 1183
      logical = (bool )0;
#line 1184
      bv_orig_ray = *(dy_actvars + bv_ray);
    }
#line 1212
    if ((int )scaled == 1) {
#line 1213
      if ((int )logical == 1) {
#line 1214
        Si = (double )(((double const   )1 / *(rscale + bv_orig_ray)) * (double const   )rayDir);
      } else {
#line 1216
        Si = (double )(*(cscale + bv_orig_ray) * (double const   )rayDir);
      }
#line 1217
      i = 1;
      {
#line 1217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1217
        if (! (i <= m)) {
#line 1217
          goto while_break___0;
        }
#line 1218
        if (*(sc_abari + i) == (double )0) {
#line 1218
          goto __Cont___0;
        }
        {
#line 1219
        i_orig = *(dy_actcons + i);
#line 1220
        rayk = (Si * *(sc_abari + i)) * (double )*(rscale + i_orig);
#line 1221
        tmp___4 = fabs(rayk);
        }
#line 1221
        if (tmp___4 < dy_tols->zero) {
#line 1221
          rayk = (double )0;
        }
#line 1222
        *(ray + i_orig) = rayk;
        __Cont___0: /* CIL Label */ 
#line 1217
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1223
      if ((int )fullRay == 1) {
#line 1224
        j = m + 1;
        {
#line 1224
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1224
          if (! (j <= n)) {
#line 1224
            goto while_break___1;
          }
#line 1230
          if (*(sc_abari + j) == (double )0) {
#line 1230
            goto __Cont___1;
          }
#line 1235
          j_orig = *(dy_actvars + j);
#line 1236
          rayk = (Si * *(sc_abari + j)) * (double )((double const   )1 / *(cscale + j_orig));
#line 1237
          if ((int )trueDuals == 1) {
#line 1237
            if (*(dy_status + j) & (unsigned int )(1 << 6)) {
#line 1237
              tmp___5 = 1;
            } else {
#line 1237
              tmp___5 = 0;
            }
#line 1237
            if (tmp___5) {
#line 1246
              rayk = - rayk;
            }
          }
          {
#line 1247
          tmp___6 = fabs(rayk);
          }
#line 1247
          if (tmp___6 < dy_tols->zero) {
#line 1247
            rayk = (double )0;
          }
#line 1248
          *(ray + (m_orig + j_orig)) = rayk;
          __Cont___1: /* CIL Label */ 
#line 1224
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 1254
      i = 1;
      {
#line 1254
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1254
        if (! (i <= m)) {
#line 1254
          goto while_break___2;
        }
#line 1255
        if (*(sc_abari + i) == (double )0) {
#line 1255
          goto __Cont___2;
        }
        {
#line 1256
        i_orig = *(dy_actcons + i);
#line 1257
        rayk = *(sc_abari + i) * (double )rayDir;
#line 1258
        tmp___7 = fabs(rayk);
        }
#line 1258
        if (tmp___7 < dy_tols->zero) {
#line 1258
          rayk = (double )0;
        }
#line 1259
        *(ray + i_orig) = rayk;
        __Cont___2: /* CIL Label */ 
#line 1254
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1260
      if ((int )fullRay == 1) {
#line 1261
        j = m + 1;
        {
#line 1261
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1261
          if (! (j <= n)) {
#line 1261
            goto while_break___3;
          }
#line 1267
          if (*(sc_abari + j) == (double )0) {
#line 1267
            goto __Cont___3;
          }
#line 1268
          rayk = *(sc_abari + j) * (double )rayDir;
#line 1269
          if ((int )trueDuals == 1) {
#line 1269
            if (*(dy_status + j) & (unsigned int )(1 << 6)) {
#line 1269
              tmp___8 = 1;
            } else {
#line 1269
              tmp___8 = 0;
            }
#line 1269
            if (tmp___8) {
#line 1278
              rayk = - rayk;
            }
          }
          {
#line 1279
          j_orig = *(dy_actvars + j);
#line 1280
          tmp___9 = fabs(rayk);
          }
#line 1280
          if (tmp___9 < dy_tols->zero) {
#line 1280
            rayk = (double )0;
          }
#line 1281
          *(ray + (m_orig + j_orig)) = rayk;
          __Cont___3: /* CIL Label */ 
#line 1261
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
#line 1282
    if ((unsigned long )sc_abari != (unsigned long )((void *)0)) {
      {
#line 1283
      free((void *)sc_abari);
#line 1284
      sc_abari = (double *)((void *)0);
      }
    }
#line 1300
    if ((int )logical == 1) {
#line 1301
      if ((unsigned int )*(orig_sys->ctyp + bv_orig_ray) == 2U) {
#line 1302
        *(ray + bv_orig_ray) = - 1.0;
      } else {
#line 1304
        *(ray + bv_orig_ray) = 1.0;
      }
    } else
#line 1306
    if ((int )fullRay == 1) {
#line 1307
      *(ray + (m_orig + bv_orig_ray)) = 1.0;
    }
#line 1310
    if (dy_opts->print.rays >= 5) {
      {
#line 1311
      tmp___10 = consys_nme(orig_sys, (char )'c', i_orig_ray, (bool )0, (char *)((void *)0));
#line 1311
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    ray<%d>: %s (%d)\n      non-zeros:",
                  numRays, tmp___10, i_orig_ray);
#line 1314
      j_orig = 0;
#line 1315
      i_orig = 1;
      }
      {
#line 1315
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1315
        if (! (i_orig <= m_orig)) {
#line 1315
          goto while_break___4;
        }
#line 1316
        if (*(ray + i_orig) != (double )0) {
#line 1317
          if (j_orig != 0) {
#line 1317
            if (j_orig % 3 == 0) {
              {
#line 1318
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t");
              }
            }
          }
          {
#line 1319
          tmp___11 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 1319
          dyio_outfmt(dy_logchn, dy_gtxecho, " (%s (%d) %g)", tmp___11, i_orig, *(ray + i_orig));
#line 1322
          j_orig ++;
          }
        }
#line 1315
        i_orig ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1323
      if ((int )fullRay == 1) {
#line 1324
        i_orig = j_orig;
#line 1325
        j_orig = 1;
        {
#line 1325
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1325
          if (! (j_orig <= n_orig)) {
#line 1325
            goto while_break___5;
          }
#line 1326
          if (*(ray + (m_orig + j_orig)) != (double )0) {
#line 1327
            if (i_orig % 3 == 0) {
              {
#line 1328
              dyio_outfmt(dy_logchn, dy_gtxecho, "\n*\t\t");
              }
            }
            {
#line 1329
            tmp___12 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 1329
            dyio_outfmt(dy_logchn, dy_gtxecho, " (%s (%d) %g)", tmp___12, j_orig,
                        *(ray + (m_orig + j_orig)));
#line 1332
            i_orig ++;
            }
          }
#line 1325
          j_orig ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 1335
    if (numRays >= maxRays) {
#line 1335
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1136
    i_ray ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1341
  if ((unsigned long )sc_abari != (unsigned long )((void *)0)) {
    {
#line 1341
    free((void *)sc_abari);
    }
  }
#line 1342
  if ((int )error == 1) {
#line 1343
    if ((unsigned long )rayCollection != (unsigned long )((void *)0)) {
#line 1344
      i = 0;
      {
#line 1344
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1344
        if (! (i < numRays)) {
#line 1344
          goto while_break___6;
        }
#line 1345
        if ((unsigned long )*(rayCollection + i) != (unsigned long )((void *)0)) {
          {
#line 1346
          free((void *)*(rayCollection + i));
#line 1347
          *(rayCollection + i) = (double *)((void *)0);
          }
        }
#line 1344
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1348
      if ((int )ourCollection == 1) {
        {
#line 1348
        free((void *)rayCollection);
        }
      }
    }
#line 1349
    return ((bool )0);
  }
#line 1353
  *p_rays = rayCollection;
#line 1354
  *p_numRays = numRays;
#line 1356
  return ((bool )1);
}
}
#line 1909 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
bool dy_abarj(lpprob_struct *orig_lp , int tgt_j , double **p_abarj ) ;
#line 1910
bool dy_betaj(lpprob_struct *orig_lp , int tgt_j , double **p_betaj ) ;
#line 1911
bool dy_betai(lpprob_struct *orig_lp , int tgt_i , double **p_betai ) ;
#line 1912
bool dy_abari(lpprob_struct *orig_lp , int tgt_i , double **p_abari , double **p_betai ) ;
#line 102 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_tableau.c"
bool dy_betaj(lpprob_struct *orig_lp , int tgt_j , double **p_betaj ) 
{ 
  int m_orig ;
  int n_orig ;
  int i_orig ;
  int j_orig ;
  int k_orig ;
  int m ;
  int n ;
  int i ;
  int j ;
  int k ;
  int j_bpos ;
  int v ;
  bool scaled ;
  bool active ;
  bool logical ;
  bool natural ;
  double *sc_betaj ;
  double *betaj ;
  double const   *rscale ;
  double const   *cscale ;
  double betaij ;
  pkvec_struct *ai ;
  consys_struct *orig_sys ;
  char *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  void *tmp___11 ;
  double tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  bool tmp___16 ;
  char const   *tmp___17 ;
  double tmp___18 ;

  {
#line 160
  rtnnme = (char *)"dy_betaj";
#line 172
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 172
    tmp = 0;
  } else {
#line 172
    tmp = 1;
  }
#line 172
  if (tmp) {
    {
#line 173
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "calculate column of basis inverse");
    }
#line 175
    return ((bool )0);
  }
#line 177
  orig_sys = orig_lp->consys;
#line 178
  m_orig = orig_sys->concnt;
#line 179
  n_orig = orig_sys->varcnt;
#line 181
  m = dy_sys->concnt;
#line 182
  n = dy_sys->varcnt;
#line 184
  if (dy_opts->print.tableau >= 1) {
    {
#line 185
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  generating column beta<%d>", tgt_j);
    }
  }
#line 192
  j = 0;
#line 193
  if (tgt_j < 0) {
#line 194
    i_orig = - tgt_j;
#line 195
    if (i_orig > m_orig) {
      {
#line 196
      errmsg(102, rtnnme, orig_sys->nme, "row", i_orig, 1, m_orig);
      }
#line 197
      return ((bool )0);
    }
#line 198
    logical = (bool )1;
#line 199
    if (*(dy_origcons + i_orig) > 0) {
#line 200
      active = (bool )1;
#line 201
      j = *(dy_origcons + i_orig);
    } else {
#line 203
      active = (bool )0;
    }
  } else
#line 205
  if (tgt_j > 0) {
#line 206
    j_orig = tgt_j;
#line 207
    if (j_orig > n_orig) {
      {
#line 208
      errmsg(102, rtnnme, orig_sys->nme, "column", j_orig, 1, n_orig);
      }
#line 209
      return ((bool )0);
    }
#line 210
    logical = (bool )0;
#line 211
    if (*(dy_origvars + j_orig) > 0) {
#line 212
      active = (bool )1;
#line 213
      j = *(dy_origvars + j_orig);
    } else {
#line 215
      active = (bool )0;
    }
  } else {
    {
#line 217
    errmsg(102, rtnnme, orig_sys->nme, "column", tgt_j, 1, n_orig);
    }
#line 218
    return ((bool )0);
  }
#line 228
  natural = (bool )0;
#line 229
  if ((int )active == 1) {
#line 230
    j_bpos = *(dy_var2basis + j);
#line 231
    if (j_bpos == 0) {
      {
#line 232
      tmp___0 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 232
      errmsg(951, rtnnme, dy_sys->nme, tmp___0, j, "calculate column of basis inverse");
      }
#line 234
      return ((bool )0);
    }
#line 235
    i_orig = *(dy_actcons + j_bpos);
#line 236
    if (j == j_bpos) {
#line 237
      natural = (bool )1;
    }
  } else
#line 239
  if ((int )logical == 1) {
#line 240
    j_bpos = i_orig;
#line 241
    natural = (bool )1;
  } else {
    {
#line 243
    tmp___1 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 243
    errmsg(950, rtnnme, "architectural variable", tmp___1, j_orig, "calculate column of basis inverse");
    }
#line 246
    return ((bool )0);
  }
#line 254
  if ((int )logical == 1) {
#line 254
    if ((int )natural == 1) {
#line 255
      if ((unsigned long )*p_betaj == (unsigned long )((void *)0)) {
        {
#line 256
        tmp___2 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 256
        *p_betaj = (double *)tmp___2;
        }
      } else {
        {
#line 258
        memset((void *)*p_betaj, (int )0.0, (size_t )(m_orig + 1) * sizeof(double ));
        }
      }
#line 259
      *(*p_betaj + i_orig) = 1.0;
#line 261
      if (dy_opts->print.tableau >= 1) {
        {
#line 262
        dyio_outfmt(dy_logchn, dy_gtxecho, ", logical for ");
        }
#line 263
        if ((int )active == 0) {
          {
#line 264
          dyio_outfmt(dy_logchn, dy_gtxecho, "inactive ");
          }
        }
        {
#line 265
        tmp___3 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 265
        dyio_outfmt(dy_logchn, dy_gtxecho, "constraint %s (%d)", tmp___3, i_orig);
        }
#line 267
        if ((int )active == 1) {
          {
#line 268
          tmp___4 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 268
          dyio_outfmt(dy_logchn, dy_gtxecho, ", basis pos\'n %d, constraint %s (%d)",
                      j_bpos, tmp___4, i_orig);
          }
        }
        {
#line 271
        dyio_outfmt(dy_logchn, dy_gtxecho, ".");
        }
#line 272
        if (dy_opts->print.tableau >= 4) {
          {
#line 273
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  non-zeros: (%d, %g)", i_orig, *(*p_betaj + i_orig));
          }
        }
      }
#line 276
      return ((bool )1);
    }
  }
#line 283
  if (dy_opts->print.tableau >= 1) {
#line 284
    if ((int )logical == 1) {
      {
#line 285
      tmp___5 = consys_nme(dy_sys, (char )'c', j, (bool )0, (char *)((void *)0));
#line 285
      dyio_outfmt(dy_logchn, dy_gtxecho, ", logical for active constraint %s (%d)",
                  tmp___5, j);
      }
    } else {
      {
#line 289
      tmp___6 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 289
      dyio_outfmt(dy_logchn, dy_gtxecho, ", architectural %s (%d)", tmp___6, j);
      }
    }
    {
#line 291
    tmp___7 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 291
    dyio_outfmt(dy_logchn, dy_gtxecho, ", basis pos\'n %d, constraint %s (%d).", j_bpos,
                tmp___7, i_orig);
    }
  }
  {
#line 302
  tmp___8 = calloc((size_t )(m + 1), sizeof(double ));
#line 302
  sc_betaj = (double *)tmp___8;
#line 303
  scaled = dy_isscaled();
  }
#line 304
  if ((int )scaled == 1) {
    {
#line 305
    dy_scaling_vectors(& rscale, & cscale);
#line 306
    *(sc_betaj + j_bpos) = (double )*(rscale + i_orig);
    }
  } else {
#line 308
    *(sc_betaj + j_bpos) = 1.0;
  }
  {
#line 309
  dy_ftran(sc_betaj, (bool )0);
  }
#line 313
  if (dy_opts->print.tableau >= 6) {
    {
#line 314
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  dy_sys nonzeros:");
#line 315
    k = 0;
#line 316
    i = 1;
    }
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 316
      if (! (i <= m)) {
#line 316
        goto while_break;
      }
#line 317
      if (*(sc_betaj + i) != (double )0) {
        {
#line 318
        j = *(dy_basis + i);
#line 319
        tmp___9 = consys_nme(dy_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 319
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d", tmp___9, i);
#line 321
        tmp___10 = consys_nme(dy_sys, (char )'v', j, (bool )0, (char *)((void *)0));
#line 321
        dyio_outfmt(dy_logchn, dy_gtxecho, " %s %d %g)", tmp___10, j, *(sc_betaj + i));
#line 323
        k ++;
        }
#line 324
        if (k % 3 == 0) {
          {
#line 324
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t  ");
          }
        }
      }
#line 316
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 335
  if ((unsigned long )*p_betaj == (unsigned long )((void *)0)) {
    {
#line 336
    tmp___11 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 336
    betaj = (double *)tmp___11;
#line 337
    *p_betaj = betaj;
    }
  } else {
    {
#line 339
    memset((void *)*p_betaj, (int )0.0, (size_t )(m_orig + 1) * sizeof(double ));
#line 340
    betaj = *p_betaj;
    }
  }
#line 341
  if ((int )scaled == 1) {
#line 342
    i = 1;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (i <= m)) {
#line 342
        goto while_break___0;
      }
#line 343
      i_orig = *(dy_actcons + i);
#line 344
      k = *(dy_basis + i);
#line 345
      if (k <= m) {
        {
#line 346
        k_orig = *(dy_actcons + k);
#line 347
        *(betaj + i_orig) = *(sc_betaj + i) / (double )*(rscale + k_orig);
#line 348
        tmp___12 = fabs(*(betaj + i_orig));
        }
#line 348
        if (tmp___12 < dy_tols->zero) {
#line 348
          *(betaj + i_orig) = (double )0;
        }
      } else {
#line 350
        j_orig = *(dy_actvars + k);
#line 351
        *(betaj + i_orig) = *(sc_betaj + i) * (double )*(cscale + j_orig);
      }
#line 342
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 353
    i = 1;
    {
#line 353
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 353
      if (! (i <= m)) {
#line 353
        goto while_break___1;
      }
#line 354
      i_orig = *(dy_actcons + i);
#line 355
      *(betaj + i_orig) = *(sc_betaj + i);
#line 353
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 359
  if (dy_opts->print.tableau >= 5) {
    {
#line 360
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  active nonzeros:");
#line 361
    k = 0;
#line 362
    i_orig = 1;
    }
    {
#line 362
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 362
      if (! (i_orig <= m_orig)) {
#line 362
        goto while_break___2;
      }
#line 363
      if (*(betaj + i_orig) != (double )0) {
        {
#line 364
        tmp___13 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 364
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___13, i_orig, *(betaj + i_orig));
#line 367
        k ++;
        }
#line 368
        if (k % 3 == 0) {
          {
#line 368
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t  ");
          }
        }
      }
#line 362
      i_orig ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 371
  if ((unsigned long )sc_betaj != (unsigned long )((void *)0)) {
    {
#line 371
    free((void *)sc_betaj);
    }
  }
#line 389
  if (dy_lp->sys.cons.loadable > 0) {
    {
#line 390
    ai = pkvec_new(orig_sys->maxrowlen);
#line 391
    i_orig = 1;
    }
    {
#line 391
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 391
      if (! (i_orig <= m_orig)) {
#line 391
        goto while_break___3;
      }
#line 392
      if (*(dy_origcons + i_orig) > 0) {
#line 392
        goto __Cont;
      }
#line 394
      if (dy_opts->print.tableau >= 5) {
        {
#line 395
        tmp___14 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 395
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    Processing inactive row %s (%d)",
                    tmp___14, i_orig);
        }
      }
      {
#line 399
      tmp___16 = consys_getrow_pk(orig_sys, i_orig, & ai);
      }
#line 399
      if ((int )tmp___16 == 0) {
        {
#line 400
        tmp___15 = consys_nme(orig_sys, (char )'c', i_orig, (bool )1, (char *)((void *)0));
#line 400
        errmsg(122, rtnnme, orig_sys->nme, "row", tmp___15, i_orig);
        }
#line 402
        if ((unsigned long )ai != (unsigned long )((void *)0)) {
          {
#line 402
          pkvec_free(ai);
          }
        }
#line 403
        if ((unsigned long )betaj != (unsigned long )((void *)0)) {
          {
#line 403
          free((void *)betaj);
          }
        }
#line 404
        return ((bool )0);
      }
#line 405
      betaij = (double )0;
#line 406
      v = 0;
      {
#line 406
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 406
        if (! (v < ai->cnt)) {
#line 406
          goto while_break___4;
        }
#line 407
        j_orig = (ai->coeffs + v)->ndx;
#line 408
        if (*(dy_origvars + j_orig) <= 0) {
#line 408
          goto __Cont___0;
        }
#line 409
        j = *(dy_origvars + j_orig);
#line 410
        j_bpos = *(dy_var2basis + j);
#line 411
        if (j_bpos > 0) {
#line 412
          k_orig = *(dy_actcons + j_bpos);
#line 414
          if (dy_opts->print.tableau >= 5) {
            {
#line 415
            tmp___17 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 415
            dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %d %g)", tmp___17, j_orig,
                        k_orig, (ai->coeffs + v)->val);
            }
          }
#line 419
          betaij += (ai->coeffs + v)->val * *(betaj + k_orig);
        }
        __Cont___0: /* CIL Label */ 
#line 406
        v ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 420
      tmp___18 = fabs(betaij);
      }
#line 420
      if (tmp___18 < dy_tols->zero) {
#line 420
        betaij = (double )0;
      }
#line 421
      *(betaj + i_orig) = - betaij;
      __Cont: /* CIL Label */ 
#line 391
      i_orig ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 422
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 422
      pkvec_free(ai);
      }
    }
  }
#line 425
  if (dy_opts->print.tableau >= 4) {
    {
#line 426
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  nonzeros:");
#line 427
    k = 0;
#line 428
    i = 1;
    }
    {
#line 428
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 428
      if (! (i <= m_orig)) {
#line 428
        goto while_break___5;
      }
#line 429
      if (*(betaj + i) != (double )0) {
        {
#line 430
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%d, %g)", i, *(betaj + i));
#line 431
        k ++;
        }
#line 432
        if (k % 5 == 0) {
          {
#line 432
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
          }
        }
      }
#line 428
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 438
  return ((bool )1);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_tableau.c"
bool dy_abarj(lpprob_struct *orig_lp , int tgt_j , double **p_abarj ) 
{ 
  int n ;
  int m ;
  int i ;
  int j ;
  int k ;
  int j_bpos ;
  int n_orig ;
  int m_orig ;
  int i_orig ;
  int j_orig ;
  int k_orig ;
  int v ;
  double *sc_abarj ;
  double *abarj ;
  double const   *rscale ;
  double const   *cscale ;
  double Sj ;
  double abarij ;
  double agj ;
  pkvec_struct *aj_pk ;
  bool scaled ;
  bool active ;
  bool logical ;
  pkvec_struct *ai ;
  consys_struct *orig_sys ;
  char const   *rtnnme ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  bool tmp___6 ;
  char const   *tmp___7 ;
  bool tmp___8 ;
  void *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  bool tmp___15 ;
  char const   *tmp___16 ;

  {
#line 490
  i_orig = 0;
#line 490
  j_orig = 0;
#line 500
  rtnnme = "dy_abarj";
#line 512
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 512
    tmp = 0;
  } else {
#line 512
    tmp = 1;
  }
#line 512
  if (tmp) {
    {
#line 513
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "calculate column of basis inverse");
    }
#line 515
    return ((bool )0);
  }
#line 517
  orig_sys = orig_lp->consys;
#line 518
  m_orig = orig_sys->concnt;
#line 519
  n_orig = orig_sys->varcnt;
#line 521
  m = dy_sys->concnt;
#line 522
  n = dy_sys->varcnt;
#line 524
  if (dy_opts->print.tableau >= 1) {
    {
#line 525
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  generating column abar<%d>, ", tgt_j);
    }
  }
  {
#line 531
  scaled = dy_isscaled();
  }
#line 532
  if ((int )scaled == 1) {
    {
#line 533
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 539
  j = 0;
#line 540
  if (tgt_j < 0) {
#line 541
    i_orig = - tgt_j;
#line 542
    if (i_orig > m_orig) {
      {
#line 543
      errmsg(102, rtnnme, orig_sys->nme, "row", i_orig, 1, m_orig);
      }
#line 544
      return ((bool )0);
    }
#line 545
    logical = (bool )1;
#line 546
    if (*(dy_origcons + i_orig) > 0) {
#line 547
      active = (bool )1;
#line 548
      j = *(dy_origcons + i_orig);
    } else {
#line 550
      active = (bool )0;
    }
  } else
#line 552
  if (tgt_j > 0) {
#line 553
    j_orig = tgt_j;
#line 554
    if (j_orig > n_orig) {
      {
#line 555
      errmsg(102, rtnnme, orig_sys->nme, "column", j_orig, 1, n_orig);
      }
#line 556
      return ((bool )0);
    }
#line 557
    logical = (bool )0;
#line 558
    if (*(dy_origvars + j_orig) > 0) {
#line 559
      active = (bool )1;
#line 560
      j = *(dy_origvars + j_orig);
    } else {
#line 562
      active = (bool )0;
    }
  } else {
    {
#line 564
    errmsg(102, rtnnme, orig_sys->nme, "column", tgt_j, 1, n_orig);
    }
#line 565
    return ((bool )0);
  }
#line 568
  if (dy_opts->print.tableau >= 1) {
#line 569
    if ((int )logical == 1) {
      {
#line 570
      tmp___0 = consys_nme(orig_sys, (char )'v', n_orig + i_orig, (bool )0, (char *)((void *)0));
#line 570
      dyio_outfmt(dy_logchn, dy_gtxecho, "logical %s (%d) for ", tmp___0, i_orig);
      }
#line 572
      if ((int )active == 0) {
        {
#line 573
        dyio_outfmt(dy_logchn, dy_gtxecho, "inactive ");
        }
      }
      {
#line 574
      tmp___1 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 574
      dyio_outfmt(dy_logchn, dy_gtxecho, "constraint %s (%d)", tmp___1, i_orig);
      }
    } else {
#line 577
      if ((int )active == 0) {
        {
#line 578
        dyio_outfmt(dy_logchn, dy_gtxecho, "inactive ");
        }
      }
      {
#line 579
      tmp___2 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 579
      dyio_outfmt(dy_logchn, dy_gtxecho, "variable %s (%d)", tmp___2, j_orig);
      }
    }
  }
#line 588
  if ((int )active == 0) {
#line 588
    if ((int )logical == 1) {
#line 589
      if ((unsigned long )*p_abarj == (unsigned long )((void *)0)) {
        {
#line 590
        tmp___3 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 590
        abarj = (double *)tmp___3;
#line 591
        *p_abarj = abarj;
        }
      } else {
        {
#line 593
        abarj = *p_abarj;
#line 594
        memset((void *)abarj, 0, (size_t )(m_orig + 1) * sizeof(double ));
        }
      }
#line 595
      *(abarj + i_orig) = 1.0;
#line 597
      if (dy_opts->print.tableau >= 4) {
        {
#line 598
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  nonzeros: (%d, %g)", i_orig, *(abarj + i_orig));
        }
      }
#line 601
      return ((bool )1);
    }
  }
  {
#line 605
  tmp___4 = calloc((size_t )(m + 1), sizeof(double ));
#line 605
  sc_abarj = (double *)tmp___4;
  }
#line 611
  if ((int )active == 1) {
#line 612
    if ((int )logical == 1) {
#line 613
      *(sc_abarj + j) = 1.0;
    } else {
      {
#line 615
      tmp___6 = consys_getcol_ex(dy_sys, j, & sc_abarj);
      }
#line 615
      if ((int )tmp___6 == 0) {
        {
#line 616
        tmp___5 = consys_nme(dy_sys, (char )'v', j, (bool )1, (char *)((void *)0));
#line 616
        errmsg(122, rtnnme, dy_sys->nme, "column", tmp___5, j);
        }
#line 618
        if ((unsigned long )sc_abarj != (unsigned long )((void *)0)) {
          {
#line 618
          free((void *)sc_abarj);
          }
        }
#line 619
        return ((bool )0);
      }
    }
    {
#line 620
    dy_ftran(sc_abarj, (bool )0);
    }
#line 621
    if ((int )scaled == 1) {
#line 622
      if ((int )logical == 1) {
#line 623
        Sj = (double )*(rscale + i_orig);
      } else {
#line 625
        Sj = (double )((double const   )1 / *(cscale + j_orig));
      }
#line 626
      k = 1;
      {
#line 626
      while (1) {
        while_continue: /* CIL Label */ ;
#line 626
        if (! (k <= m)) {
#line 626
          goto while_break;
        }
#line 627
        *(sc_abarj + k) *= Sj;
#line 626
        k ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 638
    aj_pk = (pkvec_struct *)((void *)0);
#line 639
    tmp___8 = consys_getcol_pk(orig_sys, j_orig, & aj_pk);
    }
#line 639
    if ((int )tmp___8 == 0) {
      {
#line 640
      tmp___7 = consys_nme(orig_sys, (char )'v', j_orig, (bool )1, (char *)((void *)0));
#line 640
      errmsg(122, rtnnme, orig_sys->nme, "column", tmp___7, j_orig);
      }
#line 642
      if ((unsigned long )aj_pk != (unsigned long )((void *)0)) {
        {
#line 642
        pkvec_free(aj_pk);
        }
      }
#line 643
      return ((bool )0);
    }
#line 644
    if ((int )scaled == 1) {
#line 645
      k = 0;
      {
#line 645
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 645
        if (! (k < aj_pk->cnt)) {
#line 645
          goto while_break___0;
        }
#line 646
        i_orig = (aj_pk->coeffs + k)->ndx;
#line 647
        if (*(dy_origcons + i_orig) > 0) {
#line 648
          i = *(dy_origcons + i_orig);
#line 649
          *(sc_abarj + i) = (double )(*(rscale + i_orig) * (double const   )(aj_pk->coeffs + k)->val);
        }
#line 645
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 651
      k = 0;
      {
#line 651
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 651
        if (! (k < aj_pk->cnt)) {
#line 651
          goto while_break___1;
        }
#line 652
        i_orig = (aj_pk->coeffs + k)->ndx;
#line 653
        if (*(dy_origcons + i_orig) > 0) {
#line 654
          i = *(dy_origcons + i_orig);
#line 655
          *(sc_abarj + i) = (aj_pk->coeffs + k)->val;
        }
#line 651
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 656
    pkvec_free(aj_pk);
#line 657
    dy_ftran(sc_abarj, (bool )0);
    }
  }
#line 664
  if ((unsigned long )*p_abarj == (unsigned long )((void *)0)) {
    {
#line 665
    tmp___9 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 665
    abarj = (double *)tmp___9;
#line 666
    *p_abarj = abarj;
    }
  } else {
    {
#line 668
    abarj = *p_abarj;
#line 669
    memset((void *)abarj, 0, (size_t )(m_orig + 1) * sizeof(double ));
    }
  }
#line 677
  if ((int )scaled == 1) {
#line 678
    i = 1;
    {
#line 678
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 678
      if (! (i <= m)) {
#line 678
        goto while_break___2;
      }
#line 679
      if (*(sc_abarj + i) == (double )0) {
#line 679
        goto __Cont;
      }
#line 680
      j = *(dy_basis + i);
#line 681
      i_orig = *(dy_actcons + i);
#line 682
      if (j <= dy_sys->concnt) {
#line 683
        j_orig = *(dy_actcons + j);
#line 684
        *(abarj + i_orig) = *(sc_abarj + i) / (double )*(rscale + j_orig);
      } else {
#line 686
        j_orig = *(dy_actvars + j);
#line 687
        *(abarj + i_orig) = *(sc_abarj + i) * (double )*(cscale + j_orig);
      }
      {
#line 688
      tmp___10 = fabs(*(abarj + i_orig));
      }
#line 688
      if (tmp___10 < dy_tols->zero) {
#line 688
        *(abarj + i_orig) = (double )0;
      }
      __Cont: /* CIL Label */ 
#line 678
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 690
    i = 1;
    {
#line 690
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 690
      if (! (i <= m)) {
#line 690
        goto while_break___3;
      }
#line 691
      if (*(sc_abarj + i) == (double )0) {
#line 691
        goto __Cont___0;
      }
      {
#line 692
      i_orig = *(dy_actcons + i);
#line 693
      *(abarj + i_orig) = *(sc_abarj + i);
#line 694
      tmp___11 = fabs(*(abarj + i_orig));
      }
#line 694
      if (tmp___11 < dy_tols->zero) {
#line 694
        *(abarj + i_orig) = (double )0;
      }
      __Cont___0: /* CIL Label */ 
#line 690
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 698
  if (dy_opts->print.tableau >= 5) {
    {
#line 699
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  active nonzeros:");
#line 700
    k = 0;
#line 701
    i_orig = 1;
    }
    {
#line 701
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 701
      if (! (i_orig <= m_orig)) {
#line 701
        goto while_break___4;
      }
#line 702
      if (*(abarj + i_orig) != (double )0) {
        {
#line 703
        tmp___12 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 703
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___12, i_orig, *(abarj + i_orig));
#line 706
        k ++;
        }
#line 707
        if (k % 3 == 0) {
          {
#line 707
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t  ");
          }
        }
      }
#line 701
      i_orig ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 710
  if ((unsigned long )sc_abarj != (unsigned long )((void *)0)) {
    {
#line 710
    free((void *)sc_abarj);
    }
  }
#line 729
  if (dy_lp->sys.cons.loadable > 0) {
    {
#line 730
    ai = pkvec_new(orig_sys->maxrowlen);
#line 731
    i_orig = 1;
    }
    {
#line 731
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 731
      if (! (i_orig <= m_orig)) {
#line 731
        goto while_break___5;
      }
#line 732
      if (*(dy_origcons + i_orig) > 0) {
#line 732
        goto __Cont___1;
      }
#line 734
      if (dy_opts->print.tableau >= 5) {
        {
#line 735
        tmp___13 = consys_nme(orig_sys, (char )'c', i_orig, (bool )0, (char *)((void *)0));
#line 735
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    Processing inactive row %s (%d)",
                    tmp___13, i_orig);
        }
      }
      {
#line 739
      tmp___15 = consys_getrow_pk(orig_sys, i_orig, & ai);
      }
#line 739
      if ((int )tmp___15 == 0) {
        {
#line 740
        tmp___14 = consys_nme(orig_sys, (char )'c', i_orig, (bool )1, (char *)((void *)0));
#line 740
        errmsg(122, rtnnme, orig_sys->nme, "row", tmp___14, i_orig);
        }
#line 742
        if ((unsigned long )ai != (unsigned long )((void *)0)) {
          {
#line 742
          pkvec_free(ai);
          }
        }
#line 743
        if ((unsigned long )abarj != (unsigned long )((void *)0)) {
          {
#line 743
          free((void *)abarj);
          }
        }
#line 744
        return ((bool )0);
      }
#line 745
      abarij = (double )0;
#line 746
      agj = (double )0;
#line 747
      v = 0;
      {
#line 747
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 747
        if (! (v < ai->cnt)) {
#line 747
          goto while_break___6;
        }
#line 748
        j_orig = (ai->coeffs + v)->ndx;
#line 749
        if (j_orig == tgt_j) {
#line 750
          agj = (ai->coeffs + v)->val;
        }
#line 751
        if (*(dy_origvars + j_orig) <= 0) {
#line 752
          goto __Cont___2;
        }
#line 753
        j = *(dy_origvars + j_orig);
#line 754
        j_bpos = *(dy_var2basis + j);
#line 755
        if (j_bpos > 0) {
#line 756
          k_orig = *(dy_actcons + j_bpos);
#line 758
          if (dy_opts->print.tableau >= 5) {
            {
#line 759
            tmp___16 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 759
            dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %d %g)", tmp___16, j_orig,
                        k_orig, (ai->coeffs + v)->val);
            }
          }
#line 763
          abarij += (ai->coeffs + v)->val * *(abarj + k_orig);
        }
        __Cont___2: /* CIL Label */ 
#line 747
        v ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 764
      *(abarj + i_orig) = agj - abarij;
      __Cont___1: /* CIL Label */ 
#line 731
      i_orig ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 765
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 765
      pkvec_free(ai);
      }
    }
  }
#line 768
  if (dy_opts->print.tableau >= 4) {
    {
#line 769
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  nonzeros:");
#line 770
    k = 0;
#line 771
    i = 1;
    }
    {
#line 771
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 771
      if (! (i <= m_orig)) {
#line 771
        goto while_break___7;
      }
#line 772
      if (*(abarj + i) != (double )0) {
        {
#line 773
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%d, %g)", i, *(abarj + i));
#line 774
        k ++;
        }
#line 775
        if (k % 5 == 0) {
          {
#line 775
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t   ");
          }
        }
      }
#line 771
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 782
  return ((bool )1);
}
}
#line 787 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_tableau.c"
bool dy_betai(lpprob_struct *orig_lp , int tgt_i , double **p_betai ) 
{ 
  int m_orig ;
  int n_orig ;
  int i_orig ;
  int j_orig ;
  int m ;
  int n ;
  int i ;
  int j ;
  int j_bpos ;
  int v ;
  bool scaled ;
  bool active ;
  double *sc_betai ;
  double *betai ;
  double const   *rscale ;
  double const   *cscale ;
  double Sj ;
  double gij ;
  pkvec_struct *ai ;
  consys_struct *orig_sys ;
  char *rtnnme ;
  int k_orig ;
  int tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  void *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 841
  rtnnme = (char *)"dy_betai";
#line 857
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 857
    tmp = 0;
  } else {
#line 857
    tmp = 1;
  }
#line 857
  if (tmp) {
    {
#line 858
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "calculate row of basis inverse");
    }
#line 859
    return ((bool )0);
  }
  {
#line 864
  orig_sys = orig_lp->consys;
#line 865
  m_orig = orig_sys->concnt;
#line 866
  n_orig = orig_sys->varcnt;
#line 868
  m = dy_sys->concnt;
#line 869
  n = dy_sys->varcnt;
#line 871
  scaled = dy_isscaled();
  }
#line 872
  if ((int )scaled == 1) {
    {
#line 873
    dy_scaling_vectors(& rscale, & cscale);
    }
  }
#line 876
  if (dy_opts->print.tableau >= 1) {
    {
#line 877
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  generating row beta<%d>,", tgt_i);
    }
  }
#line 882
  if (*(dy_origcons + tgt_i) > 0) {
#line 883
    active = (bool )1;
#line 884
    i = *(dy_origcons + tgt_i);
  } else {
#line 886
    active = (bool )0;
#line 887
    i = -1;
  }
#line 890
  if (dy_opts->print.tableau >= 1) {
#line 891
    if ((int )active == 0) {
      {
#line 892
      dyio_outfmt(dy_logchn, dy_gtxecho, " inactive");
      }
    }
    {
#line 893
    tmp___0 = consys_nme(orig_sys, (char )'c', tgt_i, (bool )0, (char *)((void *)0));
#line 893
    dyio_outfmt(dy_logchn, dy_gtxecho, " constraint %s (%d)", tmp___0, tgt_i);
    }
#line 895
    if ((int )active == 1) {
      {
#line 896
      dyio_outfmt(dy_logchn, dy_gtxecho, ", basis pos\'n %d", i);
      }
    }
    {
#line 897
    dyio_outfmt(dy_logchn, dy_gtxecho, ".");
    }
  }
  {
#line 909
  tmp___1 = calloc((size_t )(m + 1), sizeof(double ));
#line 909
  sc_betai = (double *)tmp___1;
  }
#line 910
  if ((int )active == 1) {
#line 911
    if ((int )scaled == 1) {
#line 912
      j = *(dy_basis + i);
#line 913
      if (j > m) {
#line 914
        j_orig = *(dy_actvars + j);
#line 915
        Sj = (double )*(cscale + j_orig);
      } else {
#line 917
        i_orig = *(dy_actcons + j);
#line 918
        Sj = (double )((double const   )1 / *(rscale + i_orig));
      }
#line 919
      *(sc_betai + i) = Sj;
    } else {
#line 921
      *(sc_betai + i) = 1.0;
    }
    {
#line 922
    dy_btran(sc_betai);
    }
  } else {
    {
#line 930
    ai = (pkvec_struct *)((void *)0);
#line 931
    tmp___3 = consys_getrow_pk(orig_sys, tgt_i, & ai);
    }
#line 931
    if ((int )tmp___3 == 0) {
      {
#line 932
      tmp___2 = consys_nme(orig_sys, (char )'c', tgt_i, (bool )0, (char *)((void *)0));
#line 932
      errmsg(122, rtnnme, orig_sys->nme, "row", tmp___2, tgt_i);
      }
#line 934
      if ((unsigned long )ai != (unsigned long )((void *)0)) {
        {
#line 934
        pkvec_free(ai);
        }
      }
#line 935
      if ((unsigned long )sc_betai != (unsigned long )((void *)0)) {
        {
#line 935
        free((void *)sc_betai);
        }
      }
#line 936
      return ((bool )0);
    }
#line 937
    if ((int )scaled == 1) {
#line 938
      v = 0;
      {
#line 938
      while (1) {
        while_continue: /* CIL Label */ ;
#line 938
        if (! (v < ai->cnt)) {
#line 938
          goto while_break;
        }
#line 939
        j_orig = (ai->coeffs + v)->ndx;
#line 940
        if (*(dy_origvars + j_orig) > 0) {
#line 941
          j = *(dy_origvars + j_orig);
#line 942
          j_bpos = *(dy_var2basis + j);
#line 943
          if (j_bpos > 0) {
#line 944
            gij = (double )(*(cscale + j_orig) * (double const   )(ai->coeffs + v)->val);
#line 945
            *(sc_betai + j_bpos) = - gij;
          }
        }
#line 938
        v ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 947
      v = 0;
      {
#line 947
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 947
        if (! (v < ai->cnt)) {
#line 947
          goto while_break___0;
        }
#line 948
        j_orig = (ai->coeffs + v)->ndx;
#line 949
        if (*(dy_origvars + j_orig) > 0) {
#line 950
          j = *(dy_origvars + j_orig);
#line 951
          j_bpos = *(dy_var2basis + j);
#line 952
          if (j_bpos > 0) {
#line 953
            *(sc_betai + j_bpos) = - (ai->coeffs + v)->val;
          }
        }
#line 947
        v ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 954
    if ((unsigned long )ai != (unsigned long )((void *)0)) {
      {
#line 955
      pkvec_free(ai);
      }
    }
    {
#line 956
    dy_btran(sc_betai);
    }
  }
#line 962
  if ((unsigned long )*p_betai == (unsigned long )((void *)0)) {
    {
#line 963
    tmp___4 = calloc((size_t )(m_orig + 1), sizeof(double ));
#line 963
    betai = (double *)tmp___4;
#line 964
    *p_betai = betai;
    }
  } else {
    {
#line 966
    betai = *p_betai;
#line 967
    memset((void *)betai, 0, (size_t )(m_orig + 1) * sizeof(double ));
    }
  }
#line 973
  if ((int )scaled == 1) {
#line 974
    i = 0;
    {
#line 974
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 974
      if (! (i <= m)) {
#line 974
        goto while_break___1;
      }
#line 975
      i_orig = *(dy_actcons + i);
#line 976
      *(betai + i_orig) = *(sc_betai + i) * (double )*(rscale + i_orig);
#line 974
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 978
    i = 0;
    {
#line 978
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 978
      if (! (i <= m)) {
#line 978
        goto while_break___2;
      }
#line 979
      i_orig = *(dy_actcons + i);
#line 980
      *(betai + i_orig) = *(sc_betai + i);
#line 978
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 981
  if ((int )active == 0) {
#line 982
    *(betai + tgt_i) = 1.0;
  }
#line 984
  if ((unsigned long )sc_betai != (unsigned long )((void *)0)) {
    {
#line 984
    free((void *)sc_betai);
    }
  }
#line 987
  if (dy_opts->print.tableau >= 4) {
    {
#line 988
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  nonzeros:");
#line 989
    v = 0;
#line 990
    i_orig = 1;
    }
    {
#line 990
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 990
      if (! (i_orig <= m_orig)) {
#line 990
        goto while_break___3;
      }
#line 991
      if (*(betai + i_orig) != (double )0) {
#line 992
        if (*(dy_origcons + i_orig) > 0) {
#line 993
          i = *(dy_origcons + i_orig);
#line 994
          j = *(dy_basis + i);
#line 995
          if (j <= m) {
            {
#line 996
            k_orig = *(dy_actcons + j);
#line 997
            tmp___5 = consys_nme(orig_sys, (char )'v', n_orig + k_orig, (bool )0,
                                 (char *)((void *)0));
#line 997
            dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___5, k_orig, *(betai + i_orig));
            }
          } else {
            {
#line 1001
            j_orig = *(dy_actvars + j);
#line 1002
            tmp___6 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 1002
            dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___6, j_orig, *(betai + i_orig));
            }
          }
        } else {
          {
#line 1006
          tmp___7 = consys_nme(orig_sys, (char )'v', n_orig + i_orig, (bool )0, (char *)((void *)0));
#line 1006
          dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___7, i_orig, *(betai + i_orig));
          }
        }
#line 1009
        v ++;
#line 1010
        if (v % 3 == 0) {
          {
#line 1010
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t  ");
          }
        }
      }
#line 990
      i_orig ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1016
  return ((bool )1);
}
}
#line 1020 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_tableau.c"
bool dy_abari(lpprob_struct *orig_lp , int tgt_i , double **p_abari , double **p_betai ) 
{ 
  int m_orig ;
  int n_orig ;
  int j_orig ;
  int i ;
  int j ;
  int j_bpos ;
  bool active ;
  bool dologicals ;
  bool retval ;
  double *betai ;
  double *abari ;
  consys_struct *orig_sys ;
  char *rtnnme ;
  int save_printlvl ;
  int v ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 1058
  rtnnme = (char *)"dy_abari";
#line 1061
  save_printlvl = dy_opts->print.tableau;
#line 1073
  if ((unsigned long )p_betai != (unsigned long )((void *)0)) {
#line 1074
    dologicals = (bool )1;
  }
#line 1078
  if (orig_lp->ctlopts & (unsigned int )(1 << 11)) {
#line 1078
    tmp = 0;
  } else {
#line 1078
    tmp = 1;
  }
#line 1078
  if (tmp) {
    {
#line 1079
    errmsg(396, rtnnme, (orig_lp->consys)->nme, "calculate row of basis inverse");
    }
#line 1080
    return ((bool )0);
  }
#line 1084
  orig_sys = orig_lp->consys;
#line 1085
  m_orig = orig_sys->concnt;
#line 1086
  n_orig = orig_sys->varcnt;
#line 1089
  if (dy_opts->print.tableau >= 1) {
    {
#line 1090
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  generating row abar<%d>,", tgt_i);
    }
  }
#line 1096
  if (*(dy_origcons + tgt_i) > 0) {
#line 1097
    active = (bool )1;
#line 1098
    i = *(dy_origcons + tgt_i);
  } else {
#line 1100
    active = (bool )0;
#line 1101
    i = -1;
  }
#line 1104
  if (dy_opts->print.tableau >= 1) {
#line 1105
    if ((int )active == 0) {
      {
#line 1106
      dyio_outfmt(dy_logchn, dy_gtxecho, " inactive");
      }
    }
    {
#line 1107
    tmp___0 = consys_nme(orig_sys, (char )'c', tgt_i, (bool )0, (char *)((void *)0));
#line 1107
    dyio_outfmt(dy_logchn, dy_gtxecho, " constraint %s (%d)", tmp___0, tgt_i);
    }
#line 1109
    if ((int )active == 1) {
      {
#line 1110
      dyio_outfmt(dy_logchn, dy_gtxecho, ", basis pos\'n %d", i);
      }
    }
    {
#line 1111
    dyio_outfmt(dy_logchn, dy_gtxecho, ".");
    }
  }
  {
#line 1117
  betai = *p_betai;
#line 1119
  dy_opts->print.tableau = 0;
#line 1120
  retval = dy_betai(orig_lp, tgt_i, & betai);
#line 1121
  dy_opts->print.tableau = save_printlvl;
  }
#line 1125
  if ((int )retval == 0) {
    {
#line 1126
    tmp___1 = consys_nme(orig_sys, (char )'c', tgt_i, (bool )0, (char *)((void *)0));
#line 1126
    errmsg(952, rtnnme, orig_sys->nme, "row", tgt_i, "constraint", tmp___1, tgt_i);
    }
#line 1128
    if ((unsigned long )betai != (unsigned long )((void *)0)) {
      {
#line 1128
      free((void *)betai);
      }
    }
#line 1129
    return ((bool )0);
  }
#line 1133
  if ((unsigned long )*p_abari == (unsigned long )((void *)0)) {
    {
#line 1134
    tmp___2 = calloc((size_t )(n_orig + 1), sizeof(double ));
#line 1134
    abari = (double *)tmp___2;
#line 1135
    *p_abari = abari;
    }
  } else {
    {
#line 1137
    abari = *p_abari;
#line 1138
    memset((void *)abari, 0, (size_t )(n_orig + 1) * sizeof(double ));
    }
  }
#line 1146
  j_orig = 1;
  {
#line 1146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1146
    if (! (j_orig <= n_orig)) {
#line 1146
      goto while_break;
    }
#line 1147
    if (*(dy_origvars + j_orig) > 0) {
#line 1148
      j = *(dy_origvars + j_orig);
#line 1149
      j_bpos = *(dy_var2basis + j);
#line 1150
      if (j_bpos > 0) {
#line 1151
        if (j_bpos == i) {
#line 1152
          *(abari + j_orig) = 1.0;
        } else {
#line 1154
          *(abari + j_orig) = 0.0;
        }
#line 1155
        goto __Cont;
      }
    }
    {
#line 1156
    *(abari + j_orig) = consys_dotcol(orig_sys, j_orig, betai);
    }
    __Cont: /* CIL Label */ 
#line 1146
    j_orig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1159
  if (dy_opts->print.tableau >= 4) {
    {
#line 1160
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  nonzeros:");
#line 1161
    v = 0;
#line 1162
    j_orig = 1;
    }
    {
#line 1162
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1162
      if (! (j_orig <= n_orig)) {
#line 1162
        goto while_break___0;
      }
#line 1163
      if (*(abari + j_orig) != (double )0) {
        {
#line 1164
        tmp___3 = consys_nme(orig_sys, (char )'v', j_orig, (bool )0, (char *)((void *)0));
#line 1164
        dyio_outfmt(dy_logchn, dy_gtxecho, " (%s %d %g)", tmp___3, j_orig, *(abari + j_orig));
#line 1167
        v ++;
        }
#line 1168
        if (v % 3 == 0) {
          {
#line 1168
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\t\t  ");
          }
        }
      }
#line 1162
      j_orig ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1175
  if ((int )dologicals == 1) {
#line 1176
    *p_betai = betai;
  } else
#line 1178
  if ((unsigned long )betai != (unsigned long )((void *)0)) {
    {
#line 1178
    free((void *)betai);
    }
  }
#line 1183
  return ((bool )1);
}
}
#line 1972 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
void dy_initstats(lpstats_struct **p_lpstats , consys_struct *orig_sys ) ;
#line 1972
void dy_dumpstats(ioid chn , bool echo , lpstats_struct *lpstats , consys_struct *orig_sys ) ;
#line 1972
void dy_freestats(lpstats_struct **p_lpstats ) ;
#line 1979
void dy_finalstats(lpstats_struct *lpstats ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_statistics.c"
void dy_initstats(lpstats_struct **p_lpstats , consys_struct *orig_sys ) 
{ 
  int k ;
  int m ;
  int n ;
  lpstats_struct *lpstats ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 81
  if ((unsigned long )*p_lpstats != (unsigned long )((void *)0)) {
#line 82
    lpstats = *p_lpstats;
  } else {
    {
#line 84
    tmp = calloc((size_t )1, sizeof(lpstats_struct ));
#line 84
    lpstats = (lpstats_struct *)tmp;
    }
  }
#line 89
  m = orig_sys->concnt;
#line 90
  n = orig_sys->varcnt;
#line 91
  if (lpstats->cons.sze <= m) {
#line 92
    if ((unsigned long )lpstats->cons.angle != (unsigned long )((void *)0)) {
      {
#line 92
      free((void *)lpstats->cons.angle);
#line 92
      lpstats->cons.angle = (double *)((void *)0);
      }
    }
#line 93
    if ((unsigned long )lpstats->cons.actcnt != (unsigned long )((void *)0)) {
      {
#line 93
      free((void *)lpstats->cons.actcnt);
#line 93
      lpstats->cons.actcnt = (int *)((void *)0);
      }
    }
#line 94
    if ((unsigned long )lpstats->cons.deactcnt != (unsigned long )((void *)0)) {
      {
#line 94
      free((void *)lpstats->cons.deactcnt);
#line 94
      lpstats->cons.deactcnt = (int *)((void *)0);
      }
    }
#line 95
    if ((unsigned long )lpstats->cons.init != (unsigned long )((void *)0)) {
      {
#line 95
      free((void *)lpstats->cons.init);
#line 95
      lpstats->cons.init = (bool *)((void *)0);
      }
    }
#line 96
    if ((unsigned long )lpstats->cons.fin != (unsigned long )((void *)0)) {
      {
#line 96
      free((void *)lpstats->cons.fin);
#line 96
      lpstats->cons.fin = (bool *)((void *)0);
      }
    }
#line 97
    lpstats->cons.sze = 0;
  }
#line 98
  if (lpstats->vars.sze <= n) {
#line 99
    if ((unsigned long )lpstats->vars.actcnt != (unsigned long )((void *)0)) {
      {
#line 99
      free((void *)lpstats->vars.actcnt);
#line 99
      lpstats->vars.actcnt = (int *)((void *)0);
      }
    }
#line 100
    if ((unsigned long )lpstats->vars.deactcnt != (unsigned long )((void *)0)) {
      {
#line 100
      free((void *)lpstats->vars.deactcnt);
#line 100
      lpstats->vars.deactcnt = (int *)((void *)0);
      }
    }
#line 101
    lpstats->vars.sze = 0;
  }
#line 105
  lpstats->cons.sze = m;
#line 106
  lpstats->vars.sze = n;
#line 107
  if ((unsigned long )lpstats->cons.angle == (unsigned long )((void *)0)) {
    {
#line 107
    tmp___0 = calloc((size_t )(m + 1), sizeof(double ));
#line 107
    lpstats->cons.angle = (double *)tmp___0;
    }
  } else {
    {
#line 107
    memset((void *)lpstats->cons.angle, 0, (unsigned long )(m + 1) * sizeof(double ));
    }
  }
#line 108
  if ((unsigned long )lpstats->cons.actcnt == (unsigned long )((void *)0)) {
    {
#line 108
    tmp___1 = calloc((size_t )(m + 1), sizeof(int ));
#line 108
    lpstats->cons.actcnt = (int *)tmp___1;
    }
  } else {
    {
#line 108
    memset((void *)lpstats->cons.actcnt, 0, (unsigned long )(m + 1) * sizeof(int ));
    }
  }
#line 109
  if ((unsigned long )lpstats->cons.deactcnt == (unsigned long )((void *)0)) {
    {
#line 109
    tmp___2 = calloc((size_t )(m + 1), sizeof(int ));
#line 109
    lpstats->cons.deactcnt = (int *)tmp___2;
    }
  } else {
    {
#line 109
    memset((void *)lpstats->cons.deactcnt, 0, (unsigned long )(m + 1) * sizeof(int ));
    }
  }
#line 110
  if ((unsigned long )lpstats->cons.init == (unsigned long )((void *)0)) {
    {
#line 110
    tmp___3 = calloc((size_t )(m + 1), sizeof(bool ));
#line 110
    lpstats->cons.init = (bool *)tmp___3;
    }
  } else {
    {
#line 110
    memset((void *)lpstats->cons.init, 0, (unsigned long )(m + 1) * sizeof(bool ));
    }
  }
#line 111
  if ((unsigned long )lpstats->cons.fin == (unsigned long )((void *)0)) {
    {
#line 111
    tmp___4 = calloc((size_t )(m + 1), sizeof(bool ));
#line 111
    lpstats->cons.fin = (bool *)tmp___4;
    }
  } else {
    {
#line 111
    memset((void *)lpstats->cons.fin, 0, (unsigned long )(m + 1) * sizeof(bool ));
    }
  }
#line 112
  if ((unsigned long )lpstats->vars.actcnt == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___5 = calloc((size_t )(n + 1), sizeof(int ));
#line 112
    lpstats->vars.actcnt = (int *)tmp___5;
    }
  } else {
    {
#line 112
    memset((void *)lpstats->vars.actcnt, 0, (unsigned long )(n + 1) * sizeof(int ));
    }
  }
#line 113
  if ((unsigned long )lpstats->vars.deactcnt == (unsigned long )((void *)0)) {
    {
#line 113
    tmp___6 = calloc((size_t )(n + 1), sizeof(int ));
#line 113
    lpstats->vars.deactcnt = (int *)tmp___6;
    }
  } else {
    {
#line 113
    memset((void *)lpstats->vars.deactcnt, 0, (unsigned long )(n + 1) * sizeof(int ));
    }
  }
  {
#line 117
  memset((void *)(lpstats->phasecnts), 0, 15UL * sizeof(int ));
#line 121
  lpstats->angle.max = - 3.40282346638528859812e+38F;
#line 122
  lpstats->angle.min = 3.40282346638528859812e+38F;
#line 123
  memset((void *)(lpstats->angle.hist), 0, 37UL * sizeof(int ));
#line 127
  lpstats->factor.cnt = 0;
#line 128
  lpstats->factor.prevpiv = 0;
#line 129
  lpstats->factor.avgpivs = (float )0;
#line 130
  lpstats->factor.maxpivs = 0;
#line 134
  lpstats->pivrej.max = 0;
#line 135
  lpstats->pivrej.mad = 0;
#line 136
  lpstats->pivrej.sing = 0;
#line 137
  lpstats->pivrej.pivtol_red = 0;
#line 138
  lpstats->pivrej.min_pivtol = (double )1.79769313486231570815e+308L;
#line 139
  lpstats->pivrej.puntcall = 0;
#line 140
  lpstats->pivrej.puntret = 0;
#line 144
  lpstats->dmulti.flippable = 0;
#line 145
  lpstats->dmulti.cnt = 0;
#line 146
  lpstats->dmulti.cands = 0;
#line 147
  lpstats->dmulti.promote = 0;
#line 148
  lpstats->dmulti.nontrivial = 0;
#line 149
  lpstats->dmulti.evals = 0;
#line 150
  lpstats->dmulti.flips = 0;
#line 151
  lpstats->dmulti.pivrnks = 0;
#line 152
  lpstats->dmulti.maxrnk = 0;
#line 156
  lpstats->pmulti.cnt = 0;
#line 157
  lpstats->pmulti.cands = 0;
#line 158
  lpstats->pmulti.nontrivial = 0;
#line 159
  lpstats->pmulti.promote = 0;
#line 163
  lpstats->infeas.prevpiv = 0;
#line 164
  lpstats->infeas.maxcnt = 0;
#line 165
  lpstats->infeas.totpivs = 0;
#line 166
  lpstats->infeas.maxpivs = 0;
#line 167
  lpstats->infeas.chgcnt1 = 0;
#line 168
  lpstats->infeas.chgcnt2 = 0;
#line 172
  k = 0;
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (k < 25)) {
#line 172
      goto while_break;
    }
#line 173
    lpstats->pdegen[k].cnt = 0;
#line 174
    lpstats->pdegen[k].avgsiz = (float )0;
#line 175
    lpstats->pdegen[k].maxsiz = 0;
#line 176
    lpstats->pdegen[k].totpivs = 0;
#line 177
    lpstats->pdegen[k].avgpivs = (float )0;
#line 178
    lpstats->pdegen[k].maxpivs = 0;
#line 172
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  k = 0;
  {
#line 179
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 179
    if (! (k < 25)) {
#line 179
      goto while_break___0;
    }
#line 180
    lpstats->ddegen[k].cnt = 0;
#line 181
    lpstats->ddegen[k].avgsiz = (float )0;
#line 182
    lpstats->ddegen[k].maxsiz = 0;
#line 183
    lpstats->ddegen[k].totpivs = 0;
#line 184
    lpstats->ddegen[k].avgpivs = (float )0;
#line 185
    lpstats->ddegen[k].maxpivs = 0;
#line 179
    k ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 187
  *p_lpstats = lpstats;
#line 189
  return;
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_statistics.c"
void dy_freestats(lpstats_struct **p_lpstats ) 
{ 
  lpstats_struct *lpstats ;

  {
#line 216
  lpstats = *p_lpstats;
#line 217
  *p_lpstats = (lpstats_struct *)((void *)0);
#line 225
  if ((unsigned long )lpstats->cons.angle != (unsigned long )((void *)0)) {
    {
#line 225
    free((void *)lpstats->cons.angle);
#line 225
    lpstats->cons.angle = (double *)((void *)0);
    }
  }
#line 226
  if ((unsigned long )lpstats->cons.actcnt != (unsigned long )((void *)0)) {
    {
#line 226
    free((void *)lpstats->cons.actcnt);
#line 226
    lpstats->cons.actcnt = (int *)((void *)0);
    }
  }
#line 227
  if ((unsigned long )lpstats->cons.deactcnt != (unsigned long )((void *)0)) {
    {
#line 227
    free((void *)lpstats->cons.deactcnt);
#line 227
    lpstats->cons.deactcnt = (int *)((void *)0);
    }
  }
#line 228
  if ((unsigned long )lpstats->cons.init != (unsigned long )((void *)0)) {
    {
#line 228
    free((void *)lpstats->cons.init);
#line 228
    lpstats->cons.init = (bool *)((void *)0);
    }
  }
#line 229
  if ((unsigned long )lpstats->cons.fin != (unsigned long )((void *)0)) {
    {
#line 229
    free((void *)lpstats->cons.fin);
#line 229
    lpstats->cons.fin = (bool *)((void *)0);
    }
  }
#line 230
  if ((unsigned long )lpstats->vars.actcnt != (unsigned long )((void *)0)) {
    {
#line 230
    free((void *)lpstats->vars.actcnt);
#line 230
    lpstats->vars.actcnt = (int *)((void *)0);
    }
  }
#line 231
  if ((unsigned long )lpstats->vars.deactcnt != (unsigned long )((void *)0)) {
    {
#line 231
    free((void *)lpstats->vars.deactcnt);
#line 231
    lpstats->vars.deactcnt = (int *)((void *)0);
    }
  }
  {
#line 233
  free((void *)lpstats);
  }
#line 235
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_statistics.c"
void dy_finalstats(lpstats_struct *lpstats ) 
{ 
  int i ;
  int k ;

  {
#line 270
  k = 1;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (k <= dy_sys->concnt)) {
#line 270
      goto while_break;
    }
#line 271
    i = *(dy_actcons + k);
#line 272
    if (i > 0) {
#line 273
      *(lpstats->cons.fin + i) = (bool )1;
    }
#line 270
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  lpstats->tot.iters = dy_lp->tot.iters;
#line 278
  lpstats->tot.pivs = dy_lp->tot.pivs;
#line 280
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_statistics.c"
void dy_dumpstats(ioid chn , bool echo , lpstats_struct *lpstats , consys_struct *orig_sys ) 
{ 
  int i ;
  int j ;
  int m ;
  int n ;
  int ndx ;
  int tot ;
  int totvact ;
  int maxvact ;
  int minvact ;
  int totvdeact ;
  int maxvdeact ;
  int minvdeact ;
  int totcact ;
  int maxcact ;
  int mincact ;
  int totcdeact ;
  int maxcdeact ;
  int mincdeact ;
  int ineqcnt ;
  int nearcnt ;
  int perpcnt ;
  int farcnt ;
  int initallcact ;
  int initcact ;
  int fincact ;
  int right_init ;
  int wrong_init ;
  int right_fin ;
  int wrong_fin ;
  int rinear ;
  int winear ;
  int rfnear ;
  int wfnear ;
  int riperp ;
  int wiperp ;
  int rfperp ;
  int wfperp ;
  int rifar ;
  int wifar ;
  int rffar ;
  int wffar ;
  double anglei ;
  double degperbin ;
  double brklow ;
  double brkhi ;
  double temp ;
  contyp_enum ctypi ;
  bool initi ;
  bool fini ;
  char const   *rtnnme ;
  double outbrks[8] ;
  int outbins ;
  int outhist[sizeof(outbrks) / sizeof(int ) + 1UL] ;
  char outbuf[20] ;
  int histfld ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 311
  rtnnme = "dy_dumpstats";
#line 313
  outbrks[0] = (double )30;
#line 313
  outbrks[1] = (double )60;
#line 313
  outbrks[2] = (double )85;
#line 313
  outbrks[3] = (double )90;
#line 313
  outbrks[4] = (double )95;
#line 313
  outbrks[5] = (double )120;
#line 313
  outbrks[6] = (double )150;
#line 313
  outbrks[7] = (double )180;
#line 314
  outbins = (int )(sizeof(outbrks) / sizeof(double ));
#line 317
  histfld = 9;
#line 319
  if ((unsigned long )lpstats == (unsigned long )((void *)0)) {
    {
#line 320
    dyio_outfmt(chn, echo, "\n\n<< %s: NULL lpstats structure! >>\n", rtnnme);
    }
#line 321
    return;
  }
  {
#line 323
  dyio_outfmt(chn, echo, "\n\nLP statistics:");
#line 325
  dyio_outfmt(chn, echo, "\n  Angle of constraints to objective (degrees):");
#line 326
  dyio_outfmt(chn, echo, "\n\tmax: %g\tmin: %g\n", (double )lpstats->angle.max, (double )lpstats->angle.min);
#line 329
  degperbin = (double )5;
#line 330
  j = 0;
#line 331
  brkhi = (double )0;
#line 332
  i = 0;
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (i < outbins)) {
#line 332
      goto while_break;
    }
#line 333
    brklow = brkhi;
#line 334
    brkhi = outbrks[i];
#line 335
    if (i < outbins / 2) {
      {
#line 336
      dyio_outfxd(outbuf, histfld, (char )'c', "[%d-%d)", (int )brklow, (int )brkhi);
      }
    } else {
      {
#line 339
      dyio_outfxd(outbuf, histfld, (char )'c', "(%d-%d]", (int )brklow, (int )brkhi);
      }
    }
    {
#line 341
    dyio_outfmt(chn, echo, " %s", outbuf);
    }
#line 342
    if (brkhi == (double )90) {
      {
#line 342
      dyio_outfmt(chn, echo, "   [90]  ");
      }
    }
#line 343
    outhist[i] = 0;
    {
#line 344
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 344
      if (! ((double )j * degperbin < brkhi)) {
#line 344
        goto while_break___0;
      }
#line 345
      outhist[i] += lpstats->angle.hist[j];
#line 344
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 332
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 346
  dyio_outchr(chn, echo, (char )'\n');
#line 347
  i = 0;
  }
  {
#line 347
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 347
    if (! (i < outbins / 2)) {
#line 347
      goto while_break___1;
    }
    {
#line 348
    dyio_outfxd(outbuf, histfld, (char )'c', "%d", outhist[i]);
#line 349
    dyio_outfmt(chn, echo, " %s", outbuf);
#line 347
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 350
  dyio_outfxd(outbuf, 8, (char )'c', "%d", lpstats->angle.hist[36]);
#line 351
  dyio_outfmt(chn, echo, " %s", outbuf);
  }
  {
#line 352
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 352
    if (! (i < outbins)) {
#line 352
      goto while_break___2;
    }
    {
#line 353
    dyio_outfxd(outbuf, histfld, (char )'c', "%d", outhist[i]);
#line 354
    dyio_outfmt(chn, echo, " %s", outbuf);
#line 352
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 356
  dyio_outfmt(chn, echo, "\n  Factoring: %d refactorisations", lpstats->factor.cnt);
#line 358
  dyio_outfmt(chn, echo, "\n\trefactor interval (pivots): avg. %.2f\tmax %d", (double )lpstats->factor.avgpivs,
              lpstats->factor.maxpivs);
#line 361
  dyio_outfmt(chn, echo, "\n  Pivot rejection: %d unstable, %d singular, max len. %d.",
              lpstats->pivrej.mad, lpstats->pivrej.sing, lpstats->pivrej.max);
  }
#line 364
  if (lpstats->pivrej.max > 0) {
    {
#line 365
    dyio_outfmt(chn, echo, "\n\tpivot tolerance: %d reductions, min. tol = %g.", lpstats->pivrej.pivtol_red,
                lpstats->pivrej.min_pivtol);
#line 367
    dyio_outfmt(chn, echo, "\n\tpunts: %d called, %d returned.", lpstats->pivrej.puntcall,
                lpstats->pivrej.puntret);
    }
  }
  {
#line 370
  dyio_outfmt(chn, echo, "\n  Reduction of infeasibility:");
#line 371
  dyio_outfmt(chn, echo, " maximum number of infeasible vars: %d", lpstats->infeas.maxcnt);
  }
#line 373
  if (lpstats->infeas.maxcnt > 0) {
    {
#line 374
    tot = lpstats->infeas.chgcnt1 + lpstats->infeas.chgcnt2;
#line 375
    temp = (double )lpstats->infeas.totpivs / (double )tot;
#line 376
    dyio_outfmt(chn, echo, "\n\tpivots to reduce: tot. %d, avg. %.2f, max %d", lpstats->infeas.totpivs,
                temp, lpstats->infeas.maxpivs);
#line 378
    dyio_outfmt(chn, echo, "\n\tsingle change: %d, multiple change: %d", lpstats->infeas.chgcnt1,
                lpstats->infeas.chgcnt2);
    }
  }
  {
#line 381
  dyio_outfmt(chn, echo, "\n  Primal Multipivot: %d calls, %d sort, %d promote", lpstats->pmulti.cnt,
              lpstats->pmulti.nontrivial, lpstats->pmulti.promote);
  }
#line 384
  if (lpstats->pmulti.cnt > 0) {
    {
#line 385
    temp = (double )((float )lpstats->pmulti.cands / (float )lpstats->pmulti.cnt);
#line 386
    dyio_outfmt(chn, echo, "\n\tcandidates: tot. %d\tavg. %.2f", lpstats->pmulti.cands,
                temp);
    }
  }
  {
#line 389
  dyio_outfmt(chn, echo, "\n  Dual Multipivot: %d calls, %d promote, %d multipivot",
              lpstats->dmulti.cnt, lpstats->dmulti.promote, lpstats->dmulti.nontrivial);
  }
#line 393
  if (lpstats->dmulti.cnt > 0) {
#line 394
    if (lpstats->dmulti.nontrivial > 0) {
#line 395
      temp = (double )((float )lpstats->dmulti.pivrnks / (float )lpstats->dmulti.nontrivial);
    } else {
#line 397
      temp = (double )0;
    }
    {
#line 398
    dyio_outfmt(chn, echo, ", avg. rank %.2f, max %d", temp, lpstats->dmulti.maxrnk);
#line 400
    temp = (double )((float )lpstats->dmulti.cands / (float )lpstats->dmulti.cnt);
#line 401
    dyio_outfmt(chn, echo, "\n\tcandidates: tot. %d\tavg. %.2f", lpstats->dmulti.cands,
                temp);
#line 403
    temp = (double )((float )lpstats->dmulti.evals / (float )lpstats->dmulti.cnt);
#line 404
    dyio_outfmt(chn, echo, "\n\tcolumn evals: tot. %d\tavg. %.2f", lpstats->dmulti.evals,
                temp);
#line 406
    temp = (double )((float )lpstats->dmulti.flips / (float )lpstats->dmulti.cnt);
#line 407
    dyio_outfmt(chn, echo, "\n\tbound flips: tot. %d\tavg. %.2f", lpstats->dmulti.flips,
                temp);
    }
  }
  {
#line 409
  temp = (double )((float )lpstats->dmulti.flippable / (float )orig_sys->varcnt);
#line 410
  dyio_outfmt(chn, echo, "\n\tflippable vars: %d (%.2f%%)", lpstats->dmulti.flippable,
              temp * (double )100);
#line 413
  dyio_outfmt(chn, echo, "\n  Degeneracy:");
  }
#line 414
  if (lpstats->pdegen[0].cnt == 0) {
    {
#line 415
    dyio_outfmt(chn, echo, "\n    Primal: inactive");
    }
  } else {
    {
#line 417
    dyio_outfmt(chn, echo, "\n    Primal:\tLevel\tEntries\t     Vars.\t\tPivots");
#line 419
    dyio_outfmt(chn, echo, "\n\t\t\t\tAvg.\tMax\tTot.\tAvg.\tMax");
#line 420
    ndx = 1;
    }
    {
#line 420
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 420
      if (! (ndx <= lpstats->pdegen[0].cnt)) {
#line 420
        goto while_break___3;
      }
      {
#line 421
      dyio_outfmt(chn, echo, "\n\t\t%d\t%d\t%.2f\t%d\t%d\t%.2f\t%d", ndx, lpstats->pdegen[ndx].cnt,
                  (double )lpstats->pdegen[ndx].avgsiz, lpstats->pdegen[ndx].maxsiz,
                  lpstats->pdegen[ndx].totpivs, (double )lpstats->pdegen[ndx].avgpivs,
                  lpstats->pdegen[ndx].maxpivs);
#line 420
      ndx ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 426
    dyio_outchr(chn, echo, (char )'\n');
    }
  }
#line 427
  if (lpstats->ddegen[0].cnt == 0) {
    {
#line 428
    dyio_outfmt(chn, echo, "\n    Dual: inactive");
    }
  } else {
    {
#line 430
    dyio_outfmt(chn, echo, "\n    Dual:\tLevel\tEntries\t     Vars.\t\tPivots");
#line 431
    dyio_outfmt(chn, echo, "\n\t\t\t\tAvg.\tMax\tTot.\tAvg.\tMax");
#line 432
    ndx = 1;
    }
    {
#line 432
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 432
      if (! (ndx <= lpstats->ddegen[0].cnt)) {
#line 432
        goto while_break___4;
      }
      {
#line 433
      dyio_outfmt(chn, echo, "\n\t\t%d\t%d\t%.2f\t%d\t%d\t%.2f\t%d", ndx, lpstats->ddegen[ndx].cnt,
                  (double )lpstats->ddegen[ndx].avgsiz, lpstats->ddegen[ndx].maxsiz,
                  lpstats->ddegen[ndx].totpivs, (double )lpstats->ddegen[ndx].avgpivs,
                  lpstats->ddegen[ndx].maxpivs);
#line 432
      ndx ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 438
  dyio_outchr(chn, echo, (char )'\n');
#line 447
  m = orig_sys->concnt;
#line 448
  n = orig_sys->varcnt;
#line 449
  totcact = 0;
#line 450
  totcdeact = 0;
#line 451
  maxcact = 0;
#line 452
  mincact = 2147483647;
#line 453
  maxcdeact = 0;
#line 454
  mincdeact = 2147483647;
#line 455
  ineqcnt = 0;
#line 456
  nearcnt = 0;
#line 457
  perpcnt = 0;
#line 458
  farcnt = 0;
#line 459
  initallcact = 0;
#line 460
  initcact = 0;
#line 461
  fincact = 0;
#line 462
  right_init = 0;
#line 463
  wrong_init = 0;
#line 464
  right_fin = 0;
#line 465
  wrong_fin = 0;
#line 466
  rinear = 0;
#line 467
  winear = 0;
#line 468
  rfnear = 0;
#line 469
  wfnear = 0;
#line 470
  riperp = 0;
#line 471
  wiperp = 0;
#line 472
  rfperp = 0;
#line 473
  wfperp = 0;
#line 474
  rifar = 0;
#line 475
  wifar = 0;
#line 476
  rffar = 0;
#line 477
  wffar = 0;
#line 478
  i = 1;
  }
  {
#line 478
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 478
    if (! (i <= m)) {
#line 478
      goto while_break___5;
    }
#line 479
    j = *(lpstats->cons.actcnt + i);
#line 480
    totcact += j;
#line 481
    if (maxcact < j) {
#line 481
      maxcact = j;
    }
#line 482
    if (mincact > j) {
#line 482
      mincact = j;
    }
#line 483
    j = *(lpstats->cons.deactcnt + i);
#line 484
    totcdeact += j;
#line 485
    if (maxcdeact < j) {
#line 485
      maxcdeact = j;
    }
#line 486
    if (mincdeact > j) {
#line 486
      mincdeact = j;
    }
#line 487
    initi = *(lpstats->cons.init + i);
#line 488
    if ((int )initi == 1) {
#line 488
      initallcact ++;
    }
#line 489
    ctypi = *(orig_sys->ctyp + i);
#line 490
    if ((unsigned int )ctypi == 2U) {
#line 490
      goto _L;
    } else
#line 490
    if ((unsigned int )ctypi == 4U) {
#line 490
      goto _L;
    } else
#line 490
    if ((unsigned int )ctypi == 5U) {
      _L: /* CIL Label */ 
#line 491
      ineqcnt ++;
#line 492
      anglei = *(lpstats->cons.angle + i);
#line 493
      if (anglei < (double )90) {
#line 494
        farcnt ++;
      } else
#line 496
      if (anglei > (double )90) {
#line 497
        nearcnt ++;
      } else {
#line 499
        perpcnt ++;
      }
#line 500
      if ((int )initi == 1) {
#line 500
        initcact ++;
      }
#line 501
      fini = *(lpstats->cons.fin + i);
#line 502
      if ((int )fini == 1) {
#line 502
        fincact ++;
      }
#line 503
      if ((int )initi == (int )fini) {
#line 504
        if ((int )initi == 1) {
#line 505
          right_init ++;
#line 506
          if (anglei < (double )90) {
#line 507
            rifar ++;
          } else
#line 509
          if (anglei > (double )90) {
#line 510
            rinear ++;
          } else {
#line 512
            riperp ++;
          }
        } else {
#line 514
          right_fin ++;
#line 515
          if (anglei < (double )90) {
#line 516
            rffar ++;
          } else
#line 518
          if (anglei > (double )90) {
#line 519
            rfnear ++;
          } else {
#line 521
            rfperp ++;
          }
        }
      } else
#line 523
      if ((int )initi == 1) {
#line 524
        wrong_init ++;
#line 525
        if (anglei < (double )90) {
#line 526
          wifar ++;
        } else
#line 528
        if (anglei > (double )90) {
#line 529
          winear ++;
        } else {
#line 531
          wiperp ++;
        }
      } else {
#line 533
        wrong_fin ++;
#line 534
        if (anglei < (double )90) {
#line 535
          wffar ++;
        } else
#line 537
        if (anglei > (double )90) {
#line 538
          wfnear ++;
        } else {
#line 540
          wfperp ++;
        }
      }
    }
#line 478
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 541
  totvact = 0;
#line 542
  totvdeact = 0;
#line 543
  maxvact = 0;
#line 544
  minvact = 2147483647;
#line 545
  maxvdeact = 0;
#line 546
  minvdeact = 2147483647;
#line 547
  j = 1;
  {
#line 547
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 547
    if (! (j <= n)) {
#line 547
      goto while_break___6;
    }
#line 548
    i = *(lpstats->vars.actcnt + j);
#line 549
    totvact += i;
#line 550
    if (maxvact < i) {
#line 550
      maxvact = i;
    }
#line 551
    if (minvact > i) {
#line 551
      minvact = i;
    }
#line 552
    i = *(lpstats->vars.deactcnt + j);
#line 553
    totvdeact += i;
#line 554
    if (maxvdeact < i) {
#line 554
      maxvdeact = i;
    }
#line 555
    if (minvdeact > i) {
#line 555
      minvdeact = i;
    }
#line 547
    j ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 559
  dyio_outfmt(chn, echo, "\n  State\tEntry\tActivity\tAverage\n");
#line 560
  i = 2;
  }
  {
#line 560
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 560
    if (! (i <= 13)) {
#line 560
      goto while_break___7;
    }
#line 561
    j = lpstats->phasecnts[i];
#line 562
    if ((unsigned int )lpstats->ini_simplex == (unsigned int )((dyphase_enum )i)) {
#line 562
      tmp = "* ";
    } else {
#line 562
      tmp = "  ";
    }
    {
#line 562
    tmp___0 = dy_prtlpphase((dyphase_enum )i, (bool )1);
#line 562
    dyio_outfmt(chn, echo, "\n   %2s%2s\t%5d", tmp___0, tmp, j);
#line 565
    temp = (double )0;
    }
    {
#line 567
    if (i == 2) {
#line 567
      goto case_2;
    }
#line 572
    if (i == 3) {
#line 572
      goto case_3;
    }
#line 577
    if (i == 4) {
#line 577
      goto case_4;
    }
#line 582
    if (i == 5) {
#line 582
      goto case_5;
    }
#line 587
    if (i == 7) {
#line 587
      goto case_7;
    }
#line 591
    if (i == 8) {
#line 591
      goto case_8;
    }
#line 596
    if (i == 10) {
#line 596
      goto case_10;
    }
#line 566
    goto switch_break;
    case_2: /* CIL Label */ 
#line 568
    if (j > 0) {
      {
#line 569
      temp = (double )lpstats->p1.pivs / (double )j;
#line 570
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", lpstats->p1.pivs, temp);
      }
    }
#line 571
    goto switch_break;
    case_3: /* CIL Label */ 
#line 573
    if (j > 0) {
      {
#line 574
      temp = (double )lpstats->p2.pivs / (double )j;
#line 575
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", lpstats->p2.pivs, temp);
      }
    }
#line 576
    goto switch_break;
    case_4: /* CIL Label */ 
#line 578
    if (j > 0) {
      {
#line 579
      temp = (double )lpstats->d2.pivs / (double )j;
#line 580
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", lpstats->d2.pivs, temp);
      }
    }
#line 581
    goto switch_break;
    case_5: /* CIL Label */ 
#line 583
    if (j > 0) {
      {
#line 584
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", totvdeact, (double )((float )totvdeact / (float )j));
      }
    }
#line 586
    goto switch_break;
    case_7: /* CIL Label */ 
#line 588
    if (j > 0) {
      {
#line 589
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", totvact, (double )((float )totvact / (float )j));
      }
    }
#line 590
    goto switch_break;
    case_8: /* CIL Label */ 
#line 592
    if (j > 0) {
      {
#line 593
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", totcdeact, (double )((float )totcdeact / (float )j));
      }
    }
#line 595
    goto switch_break;
    case_10: /* CIL Label */ 
#line 597
    if (j > 0) {
      {
#line 598
      dyio_outfmt(chn, echo, "\t%8d\t%7.1f", totcact - initallcact, (double )((float )(totcact - initallcact) / (float )j));
      }
    }
#line 600
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 560
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 601
  dyio_outchr(chn, echo, (char )'\n');
#line 605
  dyio_outfmt(chn, echo, "\n  Initial/Final Constraint System: ");
#line 606
  dyio_outfmt(chn, echo, "%d inequalities, initial %d, final %d", ineqcnt, initcact,
              fincact);
#line 608
  dyio_outfmt(chn, echo, "\n\t%d near, %d perp, %d far", nearcnt, perpcnt, farcnt);
#line 609
  dyio_outfmt(chn, echo, "\n\ttotal: %d/%d active, %d/%d inactive.", right_init, wrong_fin,
              right_fin, wrong_init);
#line 611
  dyio_outfmt(chn, echo, "\n\tnear:  %d/%d active, %d/%d inactive.", rinear, wfnear,
              rfnear, winear);
#line 613
  dyio_outfmt(chn, echo, "\n\tperp:  %d/%d active, %d/%d inactive.", riperp, wfperp,
              rfperp, wiperp);
#line 615
  dyio_outfmt(chn, echo, "\n\tfar:   %d/%d active, %d/%d inactive.\n", rifar, wffar,
              rffar, wifar);
#line 620
  dyio_outfmt(chn, echo, "\n    Constraint\tType   Angle\tInit\tAct\tDeact\tFinal\n");
#line 622
  i = 1;
  }
  {
#line 622
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 622
    if (! (i <= m)) {
#line 622
      goto while_break___8;
    }
    {
#line 623
    tmp___1 = consys_prtcontyp(*(orig_sys->ctyp + i));
#line 623
    tmp___2 = consys_nme(orig_sys, (char )'c', i, (bool )0, (char *)((void *)0));
#line 623
    dyio_outfmt(chn, echo, "\n%5d %s\t%2s %9.5f\t", i, tmp___2, tmp___1, *(lpstats->cons.angle + i));
    }
#line 627
    if ((int )*(lpstats->cons.init + i) == 1) {
      {
#line 627
      dyio_outfmt(chn, echo, "Y");
      }
    }
    {
#line 628
    dyio_outfmt(chn, echo, "\t%d\t%d\t", *(lpstats->cons.actcnt + i), *(lpstats->cons.deactcnt + i));
    }
#line 630
    if ((int )*(lpstats->cons.fin + i) == 1) {
      {
#line 630
      dyio_outfmt(chn, echo, "Y");
      }
    }
#line 622
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 632
  dyio_outchr(chn, echo, (char )'\n');
  }
#line 634
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___8  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 510 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
bool consys_realloc(consys_struct *consys , char rowcol , int incr ) ;
#line 510
bool consys_update(consys_struct *consys , void *old , void *new ) ;
#line 516
bool consys_addcol_ex(consys_struct *consys , vartyp_enum vartyp , char const   **nme ,
                      double *excol , double obj , double vlb , double vub ) ;
#line 516
bool consys_getrow_ex(consys_struct *consys , int rowndx , double **vec ) ;
#line 516
bool consys_delrow_stable(consys_struct *consys , int rowndx ) ;
#line 536
bool consys_setcoeff(consys_struct *consys , int rowndx , int colndx , double val ) ;
#line 538
double consys_getcoeff(consys_struct *consys , int rowndx , int colndx ) ;
#line 540
bool consys_logicals(consys_struct *consys ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool empty_col(consys_struct *consys , int colndx , bool *rescan ) 
{ 
  int rowndx ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *ccoeff ;
  coeff_struct *rcoeff ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 213
  rtnnme = "empty_column";
#line 238
  *rescan = (bool )0;
#line 239
  colhdr = *(consys->mtx.cols + colndx);
#line 248
  ccoeff = colhdr->coeffs;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! ((unsigned long )ccoeff != (unsigned long )((void *)0))) {
#line 248
      goto while_break;
    }
#line 249
    colhdr->coeffs = ccoeff->colnxt;
#line 250
    rowhdr = ccoeff->rowhdr;
#line 257
    rowndx = rowhdr->ndx;
#line 267
    if (rowndx == consys->maxrowndx) {
#line 267
      *rescan = (bool )1;
    }
#line 268
    if ((unsigned long )rowhdr->coeffs == (unsigned long )ccoeff) {
#line 269
      rowhdr->coeffs = ccoeff->rownxt;
    } else {
#line 271
      rcoeff = rowhdr->coeffs;
      {
#line 271
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 271
        if (! ((unsigned long )rcoeff != (unsigned long )((void *)0))) {
#line 271
          goto while_break___0;
        }
#line 272
        if ((unsigned long )rcoeff->rownxt == (unsigned long )ccoeff) {
#line 272
          goto while_break___0;
        }
#line 271
        rcoeff = rcoeff->rownxt;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 279
      rcoeff->rownxt = ccoeff->rownxt;
    }
#line 280
    (rowhdr->len) --;
#line 282
    if (rowhdr->len == 0) {
#line 282
      if (consys->opts & (1U << 1)) {
#line 282
        tmp = 1;
      } else {
#line 282
        tmp = 0;
      }
#line 282
      if (tmp) {
        {
#line 283
        warn(118, rtnnme, consys->nme, "row", rowhdr->nme, rowndx);
        }
      }
    }
    {
#line 285
    free((void *)ccoeff);
#line 248
    ccoeff = colhdr->coeffs;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  consys->mtx.coeffcnt -= colhdr->len;
#line 287
  colhdr->len = 0;
#line 289
  return ((bool )1);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool empty_row(consys_struct *consys , int rowndx , bool *rescan ) 
{ 
  int colndx ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *ccoeff ;
  coeff_struct *rcoeff ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 321
  rtnnme = "empty_row";
#line 346
  *rescan = (bool )0;
#line 347
  rowhdr = *(consys->mtx.rows + rowndx);
#line 356
  rcoeff = rowhdr->coeffs;
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! ((unsigned long )rcoeff != (unsigned long )((void *)0))) {
#line 356
      goto while_break;
    }
#line 357
    rowhdr->coeffs = rcoeff->rownxt;
#line 358
    colhdr = rcoeff->colhdr;
#line 365
    colndx = colhdr->ndx;
#line 375
    if (colndx == consys->maxcolndx) {
#line 375
      *rescan = (bool )1;
    }
#line 376
    if ((unsigned long )colhdr->coeffs == (unsigned long )rcoeff) {
#line 377
      colhdr->coeffs = rcoeff->colnxt;
    } else {
#line 379
      ccoeff = colhdr->coeffs;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! ((unsigned long )ccoeff != (unsigned long )((void *)0))) {
#line 379
          goto while_break___0;
        }
#line 380
        if ((unsigned long )ccoeff->colnxt == (unsigned long )rcoeff) {
#line 380
          goto while_break___0;
        }
#line 379
        ccoeff = ccoeff->colnxt;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 387
      ccoeff->colnxt = rcoeff->colnxt;
    }
#line 388
    (colhdr->len) --;
#line 390
    if (colhdr->len == 0) {
#line 390
      if (consys->opts & (1U << 1)) {
#line 390
        tmp = 1;
      } else {
#line 390
        tmp = 0;
      }
#line 390
      if (tmp) {
        {
#line 391
        warn(118, rtnnme, consys->nme, "column", colhdr->nme, colndx);
        }
      }
    }
    {
#line 393
    free((void *)rcoeff);
#line 356
    rcoeff = rowhdr->coeffs;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  consys->mtx.coeffcnt -= rowhdr->len;
#line 395
  rowhdr->len = 0;
#line 397
  return ((bool )1);
}
}
#line 401 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool move_col(consys_struct *consys , int fndx , int tndx ) 
{ 
  attvhdr_struct *attvhdr ;
  colhdr_struct *colhdr ;
  int tmp ;

  {
#line 444
  colhdr = *(consys->mtx.cols + fndx);
#line 445
  *(consys->mtx.cols + tndx) = colhdr;
#line 446
  colhdr->ndx = tndx;
#line 447
  if (consys->maxcolndx == fndx) {
#line 447
    consys->maxcolndx = tndx;
  }
#line 448
  if (consys->xzndx == fndx) {
#line 448
    consys->xzndx = tndx;
  }
#line 453
  attvhdr = consys->attvecs;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 453
      goto while_break;
    }
#line 465
    if (attvhdr->what & (((((((1U << 3) | (1U << 4)) | (1U << 5)) | (1U << 10)) | (1U << 15)) | (1U << 12)) | (1U << 1))) {
#line 465
      tmp = 1;
    } else {
#line 465
      tmp = 0;
    }
#line 465
    if (tmp) {
      {
#line 466
      memcpy((void */* __restrict  */)((char *)attvhdr->vec + tndx * attvhdr->elsze),
             (void const   */* __restrict  */)((char *)attvhdr->vec + fndx * attvhdr->elsze),
             (size_t )attvhdr->elsze);
      }
    }
#line 453
    attvhdr = attvhdr->nxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 469
  return ((bool )1);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool move_row(consys_struct *consys , int fndx , int tndx ) 
{ 
  attvhdr_struct *attvhdr ;
  rowhdr_struct *rowhdr ;
  int tmp ;

  {
#line 516
  rowhdr = *(consys->mtx.rows + fndx);
#line 517
  *(consys->mtx.rows + tndx) = rowhdr;
#line 518
  rowhdr->ndx = tndx;
#line 519
  if (consys->maxrowndx == fndx) {
#line 519
    consys->maxrowndx = tndx;
  }
#line 520
  if (consys->objndx == fndx) {
#line 520
    consys->objndx = tndx;
  }
#line 525
  attvhdr = consys->attvecs;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 525
      goto while_break;
    }
#line 537
    if (attvhdr->what & ((((((((1U << 6) | (1U << 9)) | (1U << 7)) | (1U << 8)) | (1U << 11)) | (1U << 14)) | (1U << 13)) | (1U << 2))) {
#line 537
      tmp = 1;
    } else {
#line 537
      tmp = 0;
    }
#line 537
    if (tmp) {
      {
#line 538
      memcpy((void */* __restrict  */)((char *)attvhdr->vec + tndx * attvhdr->elsze),
             (void const   */* __restrict  */)((char *)attvhdr->vec + fndx * attvhdr->elsze),
             (size_t )attvhdr->elsze);
      }
    }
#line 525
    attvhdr = attvhdr->nxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  return ((bool )1);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool find_maxes(consys_struct *consys , bool scan_cols , bool scan_rows ) 
{ 
  int colndx ;
  int rowndx ;
  char const   *rtnnme ;
  int tmp ;
  int tmp___0 ;

  {
#line 564
  rtnnme = "find_maxes";
#line 581
  if ((int )scan_cols == 1) {
#line 582
    consys->maxcollen = 0;
#line 583
    colndx = 1;
    {
#line 583
    while (1) {
      while_continue: /* CIL Label */ ;
#line 583
      if (! (colndx <= consys->varcnt)) {
#line 583
        goto while_break;
      }
#line 591
      if ((*(consys->mtx.cols + colndx))->len == 0) {
#line 591
        if (consys->opts & (1U << 1)) {
#line 591
          tmp = 1;
        } else {
#line 591
          tmp = 0;
        }
#line 591
        if (tmp) {
          {
#line 593
          warn(118, rtnnme, consys->nme, "column", (*(consys->mtx.cols + colndx))->nme,
               colndx);
          }
        }
      }
#line 596
      if ((*(consys->mtx.cols + colndx))->len > consys->maxcollen) {
#line 597
        consys->maxcollen = (*(consys->mtx.cols + colndx))->len;
#line 598
        consys->maxcolndx = colndx;
      }
#line 583
      colndx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 599
  if ((int )scan_rows == 1) {
#line 600
    consys->maxrowlen = 0;
#line 601
    rowndx = 1;
    {
#line 601
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 601
      if (! (rowndx <= consys->concnt)) {
#line 601
        goto while_break___0;
      }
#line 609
      if ((*(consys->mtx.rows + rowndx))->len == 0) {
#line 609
        if (consys->opts & (1U << 1)) {
#line 609
          tmp___0 = 1;
        } else {
#line 609
          tmp___0 = 0;
        }
#line 609
        if (tmp___0) {
          {
#line 611
          warn(118, rtnnme, consys->nme, "row", (*(consys->mtx.rows + rowndx))->nme,
               rowndx);
          }
        }
      }
#line 614
      if ((*(consys->mtx.rows + rowndx))->len > consys->maxrowlen) {
#line 615
        consys->maxrowlen = (*(consys->mtx.rows + rowndx))->len;
#line 616
        consys->maxrowndx = rowndx;
      }
#line 601
      rowndx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 618
  return ((bool )1);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
static bool add_logical(consys_struct *consys , int rowndx ) 
{ 
  int colndx ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  contyp_enum contyp ;
  double val ;
  double lb ;
  double ub ;
  char *nme ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 657
  rtnnme = "add_logical";
#line 696
  nme = consys_lognme(consys, rowndx, (char *)((void *)0));
#line 697
  rowhdr = *(consys->mtx.rows + rowndx);
#line 698
  val = 1.0;
#line 699
  lb = 0.0;
#line 700
  ub = consys->inf;
#line 701
  contyp = *(consys->ctyp + rowndx);
  }
  {
#line 703
  if ((unsigned int )contyp == 4U) {
#line 703
    goto case_4;
  }
#line 705
  if ((unsigned int )contyp == 3U) {
#line 705
    goto case_3;
  }
#line 712
  if ((unsigned int )contyp == 2U) {
#line 712
    goto case_2;
  }
#line 715
  if ((unsigned int )contyp == 5U) {
#line 715
    goto case_5;
  }
#line 723
  goto switch_default;
  case_4: /* CIL Label */ 
#line 704
  goto switch_break;
  case_3: /* CIL Label */ 
#line 706
  if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 707
    ub = 0.0;
  } else {
    {
#line 709
    errmsg(120, rtnnme, consys->nme, nme, rowhdr->nme, rowndx);
    }
#line 710
    return ((bool )0);
  }
#line 711
  goto switch_break;
  case_2: /* CIL Label */ 
#line 713
  val = - 1.0;
#line 714
  goto switch_break;
  case_5: /* CIL Label */ 
#line 716
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 716
    if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 716
      if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 718
        ub = *(consys->rhs + rowndx) - *(consys->rhslow + rowndx);
      } else {
        {
#line 720
        errmsg(120, rtnnme, consys->nme, nme, rowhdr->nme, rowndx);
        }
#line 721
        return ((bool )0);
      }
    } else {
      {
#line 720
      errmsg(120, rtnnme, consys->nme, nme, rowhdr->nme, rowndx);
      }
#line 721
      return ((bool )0);
    }
  } else {
    {
#line 720
    errmsg(120, rtnnme, consys->nme, nme, rowhdr->nme, rowndx);
    }
#line 721
    return ((bool )0);
  }
#line 722
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 724
  errmsg(1, rtnnme, 724);
  }
#line 725
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 740
  colndx = rowndx;
#line 741
  tmp = calloc((size_t )1, sizeof(colhdr_struct ));
#line 741
  colhdr = (colhdr_struct *)tmp;
#line 742
  *(consys->mtx.cols + colndx) = colhdr;
#line 743
  colhdr->ndx = colndx;
#line 744
  colhdr->nme = stralloc((char const   *)nme);
#line 746
  tmp___0 = malloc(sizeof(coeff_struct ));
#line 746
  coeff = (coeff_struct *)tmp___0;
#line 747
  coeff->rowhdr = rowhdr;
#line 748
  coeff->colhdr = colhdr;
#line 749
  coeff->val = val;
#line 751
  coeff->colnxt = colhdr->coeffs;
#line 752
  colhdr->coeffs = coeff;
#line 753
  colhdr->len = 1;
  }
#line 754
  if (consys->maxcollen == 0) {
#line 755
    consys->maxcollen = 1;
#line 756
    consys->maxcolndx = colndx;
  }
#line 758
  coeff->rownxt = rowhdr->coeffs;
#line 759
  rowhdr->coeffs = coeff;
#line 760
  (rowhdr->len) ++;
#line 761
  if (rowhdr->len > consys->maxrowlen) {
#line 762
    consys->maxrowlen = rowhdr->len;
#line 763
    consys->maxrowndx = rowndx;
  }
#line 765
  (consys->mtx.coeffcnt) ++;
#line 766
  (consys->logvcnt) ++;
#line 767
  (consys->varcnt) ++;
#line 769
  *(consys->vtyp + colndx) = (vartyp_enum )1;
#line 770
  if ((unsigned long )consys->obj != (unsigned long )((void *)0)) {
#line 770
    *(consys->obj + colndx) = 0.0;
  }
#line 771
  if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
#line 771
    *(consys->vlb + colndx) = 0.0;
  }
#line 772
  if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 772
    *(consys->vub + colndx) = ub;
  }
#line 774
  return ((bool )1);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
consys_struct *consys_create(char const   *nme , flags parts , flags opts , int concnt ,
                             int varcnt , double infinity ) 
{ 
  int colsze ;
  int rowsze ;
  consys_struct *consys ;
  char const   *rtnnme ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  bool tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  bool tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  bool tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  bool tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  bool tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  bool tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  bool tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  bool tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  bool tmp___35 ;
  int tmp___36 ;

  {
#line 802
  rtnnme = "consys_create";
#line 807
  if (concnt > 0) {
#line 808
    rowsze = concnt;
  } else {
#line 810
    rowsze = 3000;
  }
#line 811
  if (varcnt > 0) {
#line 812
    colsze = varcnt;
  } else {
#line 814
    colsze = 1000;
  }
#line 815
  if (opts & 1U) {
#line 815
    tmp = 1;
  } else {
#line 815
    tmp = 0;
  }
#line 815
  if (tmp) {
#line 815
    colsze += rowsze;
  }
  {
#line 821
  tmp___0 = calloc((size_t )1, sizeof(consys_struct ));
#line 821
  consys = (consys_struct *)tmp___0;
  }
#line 822
  if ((unsigned long )nme == (unsigned long )((void *)0)) {
    {
#line 823
    consys->nme = stralloc("<<anon>>");
    }
  } else {
    {
#line 825
    consys->nme = stralloc(nme);
    }
  }
  {
#line 826
  consys->opts = opts;
#line 827
  consys->inf = infinity;
#line 828
  consys->tiny = 1.0e-20;
#line 829
  tmp___1 = finite(infinity);
  }
#line 829
  if (tmp___1) {
#line 829
    consys->opts |= 1U << 3;
  }
  {
#line 830
  consys->colsze = colsze;
#line 831
  consys->rowsze = rowsze;
#line 835
  tmp___2 = calloc((size_t )(colsze + 1), sizeof(colhdr_struct *));
#line 835
  consys->mtx.cols = (colhdr_struct **)tmp___2;
#line 837
  tmp___3 = calloc((size_t )(rowsze + 1), sizeof(rowhdr_struct *));
#line 837
  consys->mtx.rows = (rowhdr_struct **)tmp___3;
  }
#line 852
  if (parts & (1U << 3)) {
#line 852
    tmp___6 = 1;
  } else {
#line 852
    tmp___6 = 0;
  }
#line 852
  if (tmp___6) {
    {
#line 852
    tmp___5 = consys_attach(consys, 1U << 3, (int )sizeof(double ), (void **)(& consys->obj));
    }
#line 852
    if ((int )tmp___5 == 0) {
      {
#line 852
      tmp___4 = consys_assocnme((consys_struct *)((void *)0), 1U << 3);
#line 852
      errmsg(100, rtnnme, consys->nme, tmp___4);
      }
#line 852
      return ((consys_struct *)((void *)0));
    }
#line 852
    consys->parts |= 1U << 3;
#line 852
    parts &= ~ (1U << 3);
  }
#line 853
  if (parts & (1U << 10)) {
#line 853
    tmp___9 = 1;
  } else {
#line 853
    tmp___9 = 0;
  }
#line 853
  if (tmp___9) {
    {
#line 853
    tmp___8 = consys_attach(consys, 1U << 10, (int )sizeof(vartyp_enum ), (void **)(& consys->vtyp));
    }
#line 853
    if ((int )tmp___8 == 0) {
      {
#line 853
      tmp___7 = consys_assocnme((consys_struct *)((void *)0), 1U << 10);
#line 853
      errmsg(100, rtnnme, consys->nme, tmp___7);
      }
#line 853
      return ((consys_struct *)((void *)0));
    }
#line 853
    consys->parts |= 1U << 10;
#line 853
    parts &= ~ (1U << 10);
  }
#line 854
  if (parts & (1U << 4)) {
#line 854
    tmp___12 = 1;
  } else {
#line 854
    tmp___12 = 0;
  }
#line 854
  if (tmp___12) {
    {
#line 854
    tmp___11 = consys_attach(consys, 1U << 4, (int )sizeof(double ), (void **)(& consys->vub));
    }
#line 854
    if ((int )tmp___11 == 0) {
      {
#line 854
      tmp___10 = consys_assocnme((consys_struct *)((void *)0), 1U << 4);
#line 854
      errmsg(100, rtnnme, consys->nme, tmp___10);
      }
#line 854
      return ((consys_struct *)((void *)0));
    }
#line 854
    consys->parts |= 1U << 4;
#line 854
    parts &= ~ (1U << 4);
  }
#line 855
  if (parts & (1U << 5)) {
#line 855
    tmp___15 = 1;
  } else {
#line 855
    tmp___15 = 0;
  }
#line 855
  if (tmp___15) {
    {
#line 855
    tmp___14 = consys_attach(consys, 1U << 5, (int )sizeof(double ), (void **)(& consys->vlb));
    }
#line 855
    if ((int )tmp___14 == 0) {
      {
#line 855
      tmp___13 = consys_assocnme((consys_struct *)((void *)0), 1U << 5);
#line 855
      errmsg(100, rtnnme, consys->nme, tmp___13);
      }
#line 855
      return ((consys_struct *)((void *)0));
    }
#line 855
    consys->parts |= 1U << 5;
#line 855
    parts &= ~ (1U << 5);
  }
#line 856
  if (parts & (1U << 6)) {
#line 856
    tmp___18 = 1;
  } else {
#line 856
    tmp___18 = 0;
  }
#line 856
  if (tmp___18) {
    {
#line 856
    tmp___17 = consys_attach(consys, 1U << 6, (int )sizeof(double ), (void **)(& consys->rhs));
    }
#line 856
    if ((int )tmp___17 == 0) {
      {
#line 856
      tmp___16 = consys_assocnme((consys_struct *)((void *)0), 1U << 6);
#line 856
      errmsg(100, rtnnme, consys->nme, tmp___16);
      }
#line 856
      return ((consys_struct *)((void *)0));
    }
#line 856
    consys->parts |= 1U << 6;
#line 856
    parts &= ~ (1U << 6);
  }
#line 857
  if (parts & (1U << 9)) {
#line 857
    tmp___21 = 1;
  } else {
#line 857
    tmp___21 = 0;
  }
#line 857
  if (tmp___21) {
    {
#line 857
    tmp___20 = consys_attach(consys, 1U << 9, (int )sizeof(double ), (void **)(& consys->rhslow));
    }
#line 857
    if ((int )tmp___20 == 0) {
      {
#line 857
      tmp___19 = consys_assocnme((consys_struct *)((void *)0), 1U << 9);
#line 857
      errmsg(100, rtnnme, consys->nme, tmp___19);
      }
#line 857
      return ((consys_struct *)((void *)0));
    }
#line 857
    consys->parts |= 1U << 9;
#line 857
    parts &= ~ (1U << 9);
  }
#line 858
  if (parts & (1U << 11)) {
#line 858
    tmp___24 = 1;
  } else {
#line 858
    tmp___24 = 0;
  }
#line 858
  if (tmp___24) {
    {
#line 858
    tmp___23 = consys_attach(consys, 1U << 11, (int )sizeof(contyp_enum ), (void **)(& consys->ctyp));
    }
#line 858
    if ((int )tmp___23 == 0) {
      {
#line 858
      tmp___22 = consys_assocnme((consys_struct *)((void *)0), 1U << 11);
#line 858
      errmsg(100, rtnnme, consys->nme, tmp___22);
      }
#line 858
      return ((consys_struct *)((void *)0));
    }
#line 858
    consys->parts |= 1U << 11;
#line 858
    parts &= ~ (1U << 11);
  }
#line 859
  if (parts & (1U << 7)) {
#line 859
    tmp___27 = 1;
  } else {
#line 859
    tmp___27 = 0;
  }
#line 859
  if (tmp___27) {
    {
#line 859
    tmp___26 = consys_attach(consys, 1U << 7, (int )sizeof(conbnd_struct ), (void **)(& consys->cub));
    }
#line 859
    if ((int )tmp___26 == 0) {
      {
#line 859
      tmp___25 = consys_assocnme((consys_struct *)((void *)0), 1U << 7);
#line 859
      errmsg(100, rtnnme, consys->nme, tmp___25);
      }
#line 859
      return ((consys_struct *)((void *)0));
    }
#line 859
    consys->parts |= 1U << 7;
#line 859
    parts &= ~ (1U << 7);
  }
#line 860
  if (parts & (1U << 8)) {
#line 860
    tmp___30 = 1;
  } else {
#line 860
    tmp___30 = 0;
  }
#line 860
  if (tmp___30) {
    {
#line 860
    tmp___29 = consys_attach(consys, 1U << 8, (int )sizeof(conbnd_struct ), (void **)(& consys->clb));
    }
#line 860
    if ((int )tmp___29 == 0) {
      {
#line 860
      tmp___28 = consys_assocnme((consys_struct *)((void *)0), 1U << 8);
#line 860
      errmsg(100, rtnnme, consys->nme, tmp___28);
      }
#line 860
      return ((consys_struct *)((void *)0));
    }
#line 860
    consys->parts |= 1U << 8;
#line 860
    parts &= ~ (1U << 8);
  }
#line 861
  if (parts & (1U << 14)) {
#line 861
    tmp___33 = 1;
  } else {
#line 861
    tmp___33 = 0;
  }
#line 861
  if (tmp___33) {
    {
#line 861
    tmp___32 = consys_attach(consys, 1U << 14, (int )sizeof(double ), (void **)(& consys->rowscale));
    }
#line 861
    if ((int )tmp___32 == 0) {
      {
#line 861
      tmp___31 = consys_assocnme((consys_struct *)((void *)0), 1U << 14);
#line 861
      errmsg(100, rtnnme, consys->nme, tmp___31);
      }
#line 861
      return ((consys_struct *)((void *)0));
    }
#line 861
    consys->parts |= 1U << 14;
#line 861
    parts &= ~ (1U << 14);
  }
#line 862
  if (parts & (1U << 15)) {
#line 862
    tmp___36 = 1;
  } else {
#line 862
    tmp___36 = 0;
  }
#line 862
  if (tmp___36) {
    {
#line 862
    tmp___35 = consys_attach(consys, 1U << 15, (int )sizeof(double ), (void **)(& consys->colscale));
    }
#line 862
    if ((int )tmp___35 == 0) {
      {
#line 862
      tmp___34 = consys_assocnme((consys_struct *)((void *)0), 1U << 15);
#line 862
      errmsg(100, rtnnme, consys->nme, tmp___34);
      }
#line 862
      return ((consys_struct *)((void *)0));
    }
#line 862
    consys->parts |= 1U << 15;
#line 862
    parts &= ~ (1U << 15);
  }
#line 867
  if (parts != 0U) {
    {
#line 867
    errmsg(114, rtnnme, consys->nme, "associated", parts);
    }
  }
#line 870
  return (consys);
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_dupsys(consys_struct *src , consys_struct **p_dst , flags dstvecs ) 
{ 
  int i ;
  int j ;
  char ac ;
  pkvec_struct *pkvec ;
  consys_struct *dst ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 904
  rtnnme = "consys_dupsys";
#line 915
  *p_dst = (consys_struct *)((void *)0);
#line 922
  dstvecs &= src->parts;
#line 923
  dst = consys_create(src->nme, dstvecs, (flags )0, src->rowsze, src->colsze, src->inf);
  }
#line 924
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
    {
#line 925
    errmsg(152, rtnnme, src->nme);
    }
#line 926
    return ((bool )0);
  }
#line 932
  dst->opts = src->opts;
#line 934
  dst->maxaij = src->maxaij;
#line 935
  dst->minaij = src->minaij;
#line 937
  if ((unsigned long )src->objnme != (unsigned long )((void *)0)) {
    {
#line 937
    dst->objnme = stralloc(src->objnme);
    }
  }
  {
#line 938
  dst->objndx = src->objndx;
#line 939
  dst->xzndx = src->xzndx;
#line 943
  pkvec = pkvec_new(0);
#line 944
  i = 1;
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i <= src->concnt)) {
#line 944
      goto while_break;
    }
#line 945
    pkvec->nme = (*(src->mtx.rows + i))->nme;
#line 946
    if (i <= src->archccnt) {
#line 947
      ac = (char )'a';
    } else {
#line 949
      ac = (char )'c';
    }
    {
#line 950
    tmp = consys_addrow_pk(dst, ac, *(src->ctyp + i), pkvec, 0.0, 0.0, (conbnd_struct *)((void *)0),
                           (conbnd_struct *)((void *)0));
    }
#line 950
    if ((int )tmp == 0) {
      {
#line 951
      errmsg(156, rtnnme, "row", dst->nme, pkvec->nme);
      }
#line 952
      if ((unsigned long )pkvec != (unsigned long )((void *)0)) {
        {
#line 952
        pkvec_free(pkvec);
        }
      }
      {
#line 953
      consys_free(dst);
      }
#line 954
      return ((bool )0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 963
  if ((unsigned long )pkvec != (unsigned long )((void *)0)) {
    {
#line 963
    pkvec_free(pkvec);
    }
  }
  {
#line 967
  pkvec = pkvec_new(src->maxcollen);
#line 968
  j = 1;
  }
  {
#line 968
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 968
    if (! (j <= src->varcnt)) {
#line 968
      goto while_break___0;
    }
    {
#line 969
    tmp___1 = consys_getcol_pk(src, j, & pkvec);
    }
#line 969
    if ((int )tmp___1 == 0) {
      {
#line 970
      tmp___0 = consys_nme(src, (char )'v', j, (bool )1, (char *)((void *)0));
#line 970
      errmsg(122, rtnnme, src->nme, "column", tmp___0, j);
      }
#line 971
      if ((unsigned long )pkvec != (unsigned long )((void *)0)) {
        {
#line 971
        pkvec_free(pkvec);
        }
      }
      {
#line 972
      consys_free(dst);
      }
#line 973
      return ((bool )0);
    }
    {
#line 974
    tmp___2 = consys_addcol_pk(dst, *(src->vtyp + j), pkvec, 0.0, 0.0, 0.0);
    }
#line 974
    if ((int )tmp___2 == 0) {
      {
#line 975
      errmsg(156, rtnnme, "column", dst->nme, pkvec->nme);
      }
#line 976
      if ((unsigned long )pkvec != (unsigned long )((void *)0)) {
        {
#line 976
        pkvec_free(pkvec);
        }
      }
      {
#line 977
      consys_free(dst);
      }
#line 978
      return ((bool )0);
    }
#line 968
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 987
  if ((unsigned long )pkvec != (unsigned long )((void *)0)) {
    {
#line 987
    pkvec_free(pkvec);
    }
  }
#line 999
  dst->maxrowndx = src->maxrowndx;
#line 1000
  dst->maxcolndx = src->maxcolndx;
#line 1004
  if (dstvecs & (1U << 3)) {
#line 1004
    tmp___3 = 1;
  } else {
#line 1004
    tmp___3 = 0;
  }
#line 1004
  if (tmp___3) {
    {
#line 1005
    memcpy((void */* __restrict  */)dst->obj, (void const   */* __restrict  */)src->obj,
           (unsigned long )(src->varcnt + 1) * sizeof(double ));
    }
  }
#line 1006
  if (dstvecs & (1U << 4)) {
#line 1006
    tmp___4 = 1;
  } else {
#line 1006
    tmp___4 = 0;
  }
#line 1006
  if (tmp___4) {
    {
#line 1007
    memcpy((void */* __restrict  */)dst->vub, (void const   */* __restrict  */)src->vub,
           (unsigned long )(src->varcnt + 1) * sizeof(double ));
    }
  }
#line 1008
  if (dstvecs & (1U << 5)) {
#line 1008
    tmp___5 = 1;
  } else {
#line 1008
    tmp___5 = 0;
  }
#line 1008
  if (tmp___5) {
    {
#line 1009
    memcpy((void */* __restrict  */)dst->vlb, (void const   */* __restrict  */)src->vlb,
           (unsigned long )(src->varcnt + 1) * sizeof(double ));
    }
  }
#line 1010
  if (dstvecs & (1U << 10)) {
#line 1010
    tmp___6 = 1;
  } else {
#line 1010
    tmp___6 = 0;
  }
#line 1010
  if (tmp___6) {
    {
#line 1011
    memcpy((void */* __restrict  */)dst->vtyp, (void const   */* __restrict  */)src->vtyp,
           (unsigned long )(src->varcnt + 1) * sizeof(vartyp_enum ));
    }
  }
#line 1012
  if (dstvecs & (1U << 15)) {
#line 1012
    tmp___7 = 1;
  } else {
#line 1012
    tmp___7 = 0;
  }
#line 1012
  if (tmp___7) {
    {
#line 1013
    memcpy((void */* __restrict  */)dst->colscale, (void const   */* __restrict  */)src->colscale,
           (unsigned long )(src->varcnt + 1) * sizeof(double ));
    }
  }
#line 1015
  if (dstvecs & (1U << 6)) {
#line 1015
    tmp___8 = 1;
  } else {
#line 1015
    tmp___8 = 0;
  }
#line 1015
  if (tmp___8) {
    {
#line 1016
    memcpy((void */* __restrict  */)dst->rhs, (void const   */* __restrict  */)src->rhs,
           (unsigned long )(src->concnt + 1) * sizeof(double ));
    }
  }
#line 1017
  if (dstvecs & (1U << 9)) {
#line 1017
    tmp___9 = 1;
  } else {
#line 1017
    tmp___9 = 0;
  }
#line 1017
  if (tmp___9) {
    {
#line 1018
    memcpy((void */* __restrict  */)dst->rhslow, (void const   */* __restrict  */)src->rhslow,
           (unsigned long )(src->concnt + 1) * sizeof(double ));
    }
  }
#line 1019
  if (dstvecs & (1U << 7)) {
#line 1019
    tmp___10 = 1;
  } else {
#line 1019
    tmp___10 = 0;
  }
#line 1019
  if (tmp___10) {
    {
#line 1020
    memcpy((void */* __restrict  */)dst->cub, (void const   */* __restrict  */)src->cub,
           (unsigned long )(src->concnt + 1) * sizeof(conbnd_struct ));
    }
  }
#line 1021
  if (dstvecs & (1U << 8)) {
#line 1021
    tmp___11 = 1;
  } else {
#line 1021
    tmp___11 = 0;
  }
#line 1021
  if (tmp___11) {
    {
#line 1022
    memcpy((void */* __restrict  */)dst->clb, (void const   */* __restrict  */)src->clb,
           (unsigned long )(src->concnt + 1) * sizeof(conbnd_struct ));
    }
  }
#line 1023
  if (dstvecs & (1U << 11)) {
#line 1023
    tmp___12 = 1;
  } else {
#line 1023
    tmp___12 = 0;
  }
#line 1023
  if (tmp___12) {
    {
#line 1024
    memcpy((void */* __restrict  */)dst->ctyp, (void const   */* __restrict  */)src->ctyp,
           (unsigned long )(src->concnt + 1) * sizeof(contyp_enum ));
    }
  }
#line 1025
  if (dstvecs & (1U << 14)) {
#line 1025
    tmp___13 = 1;
  } else {
#line 1025
    tmp___13 = 0;
  }
#line 1025
  if (tmp___13) {
    {
#line 1026
    memcpy((void */* __restrict  */)dst->rowscale, (void const   */* __restrict  */)src->rowscale,
           (unsigned long )(src->concnt + 1) * sizeof(double ));
    }
  }
#line 1028
  *p_dst = dst;
#line 1030
  return ((bool )1);
}
}
#line 1034 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
void consys_free(consys_struct *consys ) 
{ 
  int ndx ;
  attvhdr_struct *attvhdr ;
  lnk_struct *lnk ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;

  {
#line 1064
  attvhdr = consys->attvecs;
  {
#line 1064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 1064
      goto while_break;
    }
#line 1065
    consys->attvecs = attvhdr->nxt;
#line 1066
    lnk = attvhdr->pveclst;
    {
#line 1066
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1066
      if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1066
        goto while_break___0;
      }
      {
#line 1067
      attvhdr->pveclst = lnk->llnxt;
#line 1068
      free((void *)lnk);
#line 1066
      lnk = attvhdr->pveclst;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1069
    free((void *)attvhdr);
#line 1064
    attvhdr = consys->attvecs;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1073
  if ((unsigned long )consys->obj != (unsigned long )((void *)0)) {
    {
#line 1073
    free((void *)consys->obj);
    }
  }
#line 1074
  if ((unsigned long )consys->vtyp != (unsigned long )((void *)0)) {
    {
#line 1074
    free((void *)consys->vtyp);
    }
  }
#line 1075
  if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
    {
#line 1075
    free((void *)consys->vub);
    }
  }
#line 1076
  if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
    {
#line 1076
    free((void *)consys->vlb);
    }
  }
#line 1077
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
    {
#line 1077
    free((void *)consys->rhs);
    }
  }
#line 1078
  if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
    {
#line 1078
    free((void *)consys->rhslow);
    }
  }
#line 1079
  if ((unsigned long )consys->ctyp != (unsigned long )((void *)0)) {
    {
#line 1079
    free((void *)consys->ctyp);
    }
  }
#line 1080
  if ((unsigned long )consys->cub != (unsigned long )((void *)0)) {
    {
#line 1080
    free((void *)consys->cub);
    }
  }
#line 1081
  if ((unsigned long )consys->clb != (unsigned long )((void *)0)) {
    {
#line 1081
    free((void *)consys->clb);
    }
  }
#line 1082
  if ((unsigned long )consys->rowscale != (unsigned long )((void *)0)) {
    {
#line 1082
    free((void *)consys->rowscale);
    }
  }
#line 1083
  if ((unsigned long )consys->colscale != (unsigned long )((void *)0)) {
    {
#line 1083
    free((void *)consys->colscale);
    }
  }
#line 1090
  ndx = 1;
  {
#line 1090
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1090
    if (! (ndx <= consys->varcnt)) {
#line 1090
      goto while_break___1;
    }
#line 1091
    colhdr = *(consys->mtx.cols + ndx);
#line 1092
    coeff = colhdr->coeffs;
    {
#line 1092
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1092
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 1092
        goto while_break___2;
      }
      {
#line 1093
      colhdr->coeffs = coeff->colnxt;
#line 1094
      free((void *)coeff);
#line 1092
      coeff = colhdr->coeffs;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1095
    if ((unsigned long )colhdr->nme != (unsigned long )((void *)0)) {
      {
#line 1095
      strfree(colhdr->nme);
      }
    }
    {
#line 1096
    free((void *)colhdr);
#line 1090
    ndx ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1097
  ndx = 1;
  {
#line 1097
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1097
    if (! (ndx <= consys->concnt)) {
#line 1097
      goto while_break___3;
    }
#line 1098
    rowhdr = *(consys->mtx.rows + ndx);
#line 1099
    if ((unsigned long )rowhdr->nme != (unsigned long )((void *)0)) {
      {
#line 1099
      strfree(rowhdr->nme);
      }
    }
    {
#line 1100
    free((void *)rowhdr);
#line 1097
    ndx ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1101
  free((void *)consys->mtx.cols);
#line 1102
  free((void *)consys->mtx.rows);
  }
#line 1106
  if ((unsigned long )consys->objnme != (unsigned long )((void *)0)) {
    {
#line 1106
    strfree(consys->objnme);
    }
  }
#line 1107
  if ((unsigned long )consys->nme != (unsigned long )((void *)0)) {
    {
#line 1107
    strfree(consys->nme);
    }
  }
  {
#line 1108
  free((void *)consys);
  }
#line 1110
  return;
}
}
#line 1114 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_attach(consys_struct *consys , flags what , int elsze , void **pvec ) 
{ 
  int ndx ;
  attvhdr_struct *attvhdr ;
  lnk_struct *lnk ;
  double *dvec ;
  char const   *rtnnme ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 1150
  rtnnme = "consys_attach";
#line 1174
  if ((unsigned long )*pvec == (unsigned long )((void *)0)) {
#line 1175
    if (what & (((((((1U << 3) | (1U << 4)) | (1U << 5)) | (1U << 10)) | (1U << 15)) | (1U << 12)) | (1U << 1))) {
#line 1175
      tmp___1 = 1;
    } else {
#line 1175
      tmp___1 = 0;
    }
#line 1175
    if (tmp___1) {
      {
#line 1176
      tmp = calloc((size_t )(consys->colsze + 1), (size_t )elsze);
#line 1176
      *pvec = tmp;
      }
    } else {
      {
#line 1178
      tmp___0 = calloc((size_t )(consys->rowsze + 1), (size_t )elsze);
#line 1178
      *pvec = tmp___0;
      }
    }
#line 1179
    if (what & (1U << 4)) {
#line 1179
      tmp___4 = 1;
    } else {
#line 1179
      tmp___4 = 0;
    }
#line 1179
    if (tmp___4) {
#line 1180
      dvec = (double *)*pvec;
#line 1181
      *(dvec + 0) = 0.0;
#line 1182
      ndx = 1;
      {
#line 1182
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1182
        if (! (ndx <= consys->colsze)) {
#line 1182
          goto while_break;
        }
#line 1183
        *(dvec + ndx) = consys->inf;
#line 1182
        ndx ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 1185
      if (what & (1U << 15)) {
#line 1185
        tmp___3 = 1;
      } else {
#line 1185
        tmp___3 = 0;
      }
#line 1185
      if (tmp___3) {
#line 1186
        dvec = (double *)*pvec;
#line 1187
        *(dvec + 0) = 0.0;
#line 1188
        ndx = 1;
        {
#line 1188
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1188
          if (! (ndx <= consys->colsze)) {
#line 1188
            goto while_break___0;
          }
#line 1188
          *(dvec + ndx) = 1.0;
#line 1188
          ndx ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 1190
        if (what & (1U << 14)) {
#line 1190
          tmp___2 = 1;
        } else {
#line 1190
          tmp___2 = 0;
        }
#line 1190
        if (tmp___2) {
#line 1191
          dvec = (double *)*pvec;
#line 1192
          *(dvec + 0) = 0.0;
#line 1193
          ndx = 1;
          {
#line 1193
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1193
            if (! (ndx <= consys->rowsze)) {
#line 1193
              goto while_break___1;
            }
#line 1193
            *(dvec + ndx) = 1.0;
#line 1193
            ndx ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
#line 1194
    attvhdr = (attvhdr_struct *)((void *)0);
  } else {
#line 1196
    attvhdr = consys->attvecs;
    {
#line 1196
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1196
      if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 1196
        goto while_break___2;
      }
#line 1197
      if ((unsigned long )attvhdr->vec == (unsigned long )*pvec) {
#line 1197
        goto while_break___2;
      }
#line 1196
      attvhdr = attvhdr->nxt;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1201
  if ((unsigned long )attvhdr == (unsigned long )((void *)0)) {
    {
#line 1202
    tmp___5 = malloc(sizeof(attvhdr_struct ));
#line 1202
    attvhdr = (attvhdr_struct *)tmp___5;
#line 1203
    attvhdr->what = what;
#line 1204
    attvhdr->elsze = elsze;
#line 1205
    attvhdr->vec = *pvec;
#line 1206
    attvhdr->pveclst = (lnk_struct *)((void *)0);
#line 1207
    attvhdr->nxt = consys->attvecs;
#line 1208
    consys->attvecs = attvhdr;
    }
  }
#line 1219
  lnk = attvhdr->pveclst;
  {
#line 1219
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1219
    if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1219
      goto while_break___3;
    }
#line 1220
    if ((unsigned long )pvec == (unsigned long )((void **)lnk->llval)) {
#line 1220
      goto while_break___3;
    }
#line 1219
    lnk = lnk->llnxt;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1221
  if ((unsigned long )lnk == (unsigned long )((void *)0)) {
    {
#line 1222
    tmp___6 = malloc(sizeof(lnk_struct ));
#line 1222
    lnk = (lnk_struct *)tmp___6;
#line 1223
    lnk->llval = (void *)pvec;
#line 1224
    lnk->llnxt = attvhdr->pveclst;
#line 1225
    attvhdr->pveclst = lnk;
    }
  } else {
#line 1228
    if (consys->opts & (1U << 2)) {
#line 1228
      tmp___8 = 1;
    } else {
#line 1228
      tmp___8 = 0;
    }
#line 1228
    if (tmp___8) {
      {
#line 1229
      tmp___7 = consys_assocnme(consys, what);
#line 1229
      warn(107, rtnnme, tmp___7, *pvec, pvec);
      }
    }
  }
#line 1237
  return ((bool )1);
}
}
#line 1241 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_update(consys_struct *consys , void *old , void *new ) 
{ 
  attvhdr_struct *attvhdr ;
  lnk_struct *lnk ;
  char const   *rtnnme ;

  {
#line 1261
  rtnnme = "consys_update";
#line 1281
  attvhdr = consys->attvecs;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1281
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 1281
      goto while_break;
    }
#line 1282
    if ((unsigned long )attvhdr->vec == (unsigned long )old) {
#line 1282
      goto while_break;
    }
#line 1281
    attvhdr = attvhdr->nxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 1283
  if ((unsigned long )attvhdr == (unsigned long )((void *)0)) {
    {
#line 1284
    consys->opts |= 1U << 4;
#line 1285
    errmsg(104, rtnnme, consys->nme, old);
    }
#line 1286
    return ((bool )0);
  }
#line 1295
  attvhdr->vec = new;
#line 1296
  lnk = attvhdr->pveclst;
  {
#line 1296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1296
    if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1296
      goto while_break___0;
    }
#line 1303
    *((void **)lnk->llval) = new;
#line 1296
    lnk = lnk->llnxt;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1305
  return ((bool )1);
}
}
#line 1309 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_detach(consys_struct *consys , void **pvec , bool all ) 
{ 
  attvhdr_struct *attvhdr ;
  attvhdr_struct **pattvhdr ;
  lnk_struct *lnk ;
  lnk_struct **plnk ;
  bool pvec_seen ;
  void *vec ;
  char const   *rtnnme ;
  char *tmp ;

  {
#line 1332
  rtnnme = "consys_detach";
#line 1358
  vec = *pvec;
#line 1359
  pattvhdr = & consys->attvecs;
#line 1359
  attvhdr = *pattvhdr;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 1359
      goto while_break;
    }
#line 1362
    if ((unsigned long )attvhdr->vec == (unsigned long )vec) {
#line 1362
      goto while_break;
    }
#line 1359
    pattvhdr = & attvhdr->nxt;
#line 1359
    attvhdr = *pattvhdr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1363
  if ((unsigned long )attvhdr == (unsigned long )((void *)0)) {
    {
#line 1364
    consys->opts |= 1U << 4;
#line 1365
    errmsg(104, rtnnme, consys->nme, vec);
    }
#line 1366
    return ((bool )0);
  }
#line 1376
  if ((int )all == 1) {
#line 1377
    lnk = attvhdr->pveclst;
    {
#line 1377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1377
      if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1377
        goto while_break___0;
      }
      {
#line 1378
      attvhdr->pveclst = lnk->llnxt;
#line 1379
      free((void *)lnk);
#line 1377
      lnk = attvhdr->pveclst;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1380
    *pattvhdr = attvhdr->nxt;
#line 1381
    free((void *)attvhdr);
    }
  } else {
#line 1383
    pvec_seen = (bool )0;
#line 1384
    plnk = & attvhdr->pveclst;
#line 1385
    lnk = *plnk;
    {
#line 1385
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1385
      if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1385
        goto while_break___1;
      }
#line 1386
      if ((unsigned long )pvec == (unsigned long )((void **)lnk->llval)) {
        {
#line 1387
        pvec_seen = (bool )1;
#line 1388
        *plnk = lnk->llnxt;
#line 1389
        free((void *)lnk);
        }
      } else {
#line 1391
        plnk = & lnk->llnxt;
      }
#line 1385
      lnk = *plnk;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1392
    if ((int )pvec_seen == 0) {
      {
#line 1393
      consys->opts |= 1U << 4;
#line 1394
      tmp = consys_assocnme((consys_struct *)((void *)0), attvhdr->what);
#line 1394
      errmsg(109, rtnnme, consys->nme, pvec, tmp, attvhdr->vec);
      }
#line 1396
      return ((bool )0);
    }
#line 1397
    if ((unsigned long )attvhdr->pveclst == (unsigned long )((void *)0)) {
      {
#line 1398
      *pattvhdr = attvhdr->nxt;
#line 1399
      free((void *)attvhdr);
      }
    }
  }
#line 1401
  return ((bool )1);
}
}
#line 1405 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_realloc(consys_struct *consys , char rowcol , int incr ) 
{ 
  int rowsze ;
  int oldrowsze ;
  int colsze ;
  int oldcolsze ;
  int ndx ;
  int elsze ;
  bool expcols ;
  bool exprows ;
  flags what ;
  char *vec ;
  double *dvec ;
  attvhdr_struct *attvhdr ;
  lnk_struct *lnk ;
  char const   *rtnnme ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1443
  rtnnme = "consys_realloc";
#line 1448
  rowsze = -1;
#line 1449
  oldrowsze = -1;
#line 1450
  colsze = -1;
#line 1451
  oldcolsze = -1;
#line 1471
  expcols = (bool )0;
#line 1472
  exprows = (bool )0;
  {
#line 1474
  if ((int )rowcol == 99) {
#line 1474
    goto case_99;
  }
#line 1479
  if ((int )rowcol == 114) {
#line 1479
    goto case_114;
  }
#line 1488
  goto switch_default;
  case_99: /* CIL Label */ 
#line 1475
  if (incr <= 0) {
#line 1475
    if (10 > (int )((double )consys->colsze * .1)) {
#line 1475
      incr = 10;
    } else {
#line 1475
      incr = (int )((double )consys->colsze * .1);
    }
  }
#line 1476
  colsze = consys->colsze + incr;
#line 1477
  expcols = (bool )1;
#line 1478
  goto switch_break;
  case_114: /* CIL Label */ 
#line 1480
  if (incr <= 0) {
#line 1480
    if (10 > (int )((double )consys->rowsze * .1)) {
#line 1480
      incr = 10;
    } else {
#line 1480
      incr = (int )((double )consys->rowsze * .1);
    }
  }
#line 1481
  rowsze = consys->rowsze + incr;
#line 1482
  exprows = (bool )1;
#line 1483
  if (consys->opts & 1U) {
#line 1483
    tmp = 1;
  } else {
#line 1483
    tmp = 0;
  }
#line 1483
  if (tmp) {
#line 1484
    if (consys->colsze < consys->varcnt + incr) {
#line 1485
      expcols = (bool )1;
#line 1486
      colsze = consys->varcnt + incr;
    }
  }
#line 1487
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1489
  errmsg(3, rtnnme, "rowcol", (int )rowcol);
  }
#line 1490
  return ((bool )0);
  switch_break: /* CIL Label */ ;
  }
#line 1494
  if ((int )exprows == 1) {
    {
#line 1495
    oldrowsze = consys->rowsze;
#line 1496
    tmp___0 = realloc((void *)consys->mtx.rows, (unsigned long )(rowsze + 1) * sizeof(rowhdr_struct **));
#line 1496
    consys->mtx.rows = (rowhdr_struct **)tmp___0;
#line 1498
    memset((void *)(consys->mtx.rows + (oldrowsze + 1)), 0, (unsigned long )(rowsze - oldrowsze) * sizeof(rowhdr_struct **));
#line 1500
    consys->rowsze = rowsze;
    }
  }
#line 1501
  if ((int )expcols == 1) {
    {
#line 1502
    oldcolsze = consys->colsze;
#line 1503
    tmp___1 = realloc((void *)consys->mtx.cols, (unsigned long )(colsze + 1) * sizeof(colhdr_struct **));
#line 1503
    consys->mtx.cols = (colhdr_struct **)tmp___1;
#line 1505
    memset((void *)(consys->mtx.cols + (oldcolsze + 1)), 0, (unsigned long )(colsze - oldcolsze) * sizeof(colhdr_struct **));
#line 1507
    consys->colsze = colsze;
    }
  }
#line 1515
  attvhdr = consys->attvecs;
  {
#line 1515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1515
    if (! ((unsigned long )attvhdr != (unsigned long )((void *)0))) {
#line 1515
      goto while_break;
    }
#line 1516
    vec = (char *)attvhdr->vec;
#line 1517
    what = attvhdr->what;
#line 1518
    elsze = attvhdr->elsze;
#line 1530
    if (what & (((((((1U << 3) | (1U << 4)) | (1U << 5)) | (1U << 10)) | (1U << 15)) | (1U << 12)) | (1U << 1))) {
#line 1530
      tmp___7 = 1;
    } else {
#line 1530
      tmp___7 = 0;
    }
#line 1530
    if (tmp___7) {
#line 1531
      if ((int )expcols == 1) {
        {
#line 1532
        tmp___2 = realloc(attvhdr->vec, (size_t )((colsze + 1) * elsze));
#line 1532
        vec = (char *)tmp___2;
        }
#line 1533
        if (what & (1U << 4)) {
#line 1533
          tmp___4 = 1;
        } else {
#line 1533
          tmp___4 = 0;
        }
#line 1533
        if (tmp___4) {
#line 1534
          dvec = (double *)vec;
#line 1535
          ndx = oldcolsze + 1;
          {
#line 1535
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1535
            if (! (ndx <= colsze)) {
#line 1535
              goto while_break___0;
            }
#line 1536
            *(dvec + ndx) = consys->inf;
#line 1535
            ndx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 1538
          if (what & (1U << 15)) {
#line 1538
            tmp___3 = 1;
          } else {
#line 1538
            tmp___3 = 0;
          }
#line 1538
          if (tmp___3) {
#line 1539
            dvec = (double *)vec;
#line 1540
            *(dvec + 0) = 0.0;
#line 1541
            ndx = oldcolsze + 1;
            {
#line 1541
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1541
              if (! (ndx <= colsze)) {
#line 1541
                goto while_break___1;
              }
#line 1541
              *(dvec + ndx) = 1.0;
#line 1541
              ndx ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
            {
#line 1543
            memset((void *)(vec + (oldcolsze + 1) * elsze), 0, (size_t )((colsze - oldcolsze) * elsze));
            }
          }
        }
      }
    } else
#line 1545
    if ((int )exprows == 1) {
      {
#line 1546
      tmp___5 = realloc(attvhdr->vec, (size_t )((rowsze + 1) * elsze));
#line 1546
      vec = (char *)tmp___5;
      }
#line 1547
      if (what & (1U << 14)) {
#line 1547
        tmp___6 = 1;
      } else {
#line 1547
        tmp___6 = 0;
      }
#line 1547
      if (tmp___6) {
#line 1548
        dvec = (double *)vec;
#line 1549
        *(dvec + 0) = 0.0;
#line 1550
        ndx = oldrowsze + 1;
        {
#line 1550
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1550
          if (! (ndx <= rowsze)) {
#line 1550
            goto while_break___2;
          }
#line 1550
          *(dvec + ndx) = 1.0;
#line 1550
          ndx ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
        {
#line 1552
        memset((void *)(vec + (oldrowsze + 1) * elsze), 0, (size_t )((rowsze - oldrowsze) * elsze));
        }
      }
    }
#line 1553
    if ((unsigned long )vec != (unsigned long )attvhdr->vec) {
#line 1554
      lnk = attvhdr->pveclst;
      {
#line 1554
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1554
        if (! ((unsigned long )lnk != (unsigned long )((void *)0))) {
#line 1554
          goto while_break___3;
        }
#line 1561
        *((void **)lnk->llval) = (void *)vec;
#line 1554
        lnk = lnk->llnxt;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1562
      attvhdr->vec = (void *)vec;
    }
#line 1515
    attvhdr = attvhdr->nxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 1603
  return ((bool )1);
}
}
#line 1607 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_addcol_pk(consys_struct *consys , vartyp_enum vartyp , pkvec_struct *pkcol ,
                      double obj , double vlb , double vub ) 
{ 
  int colndx ;
  int vecndx ;
  int avail ;
  int nzcnt ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  pkcoeff_struct *pkcoeff ;
  char nmebuf[20] ;
  char const   *rtnnme ;
  int tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  void *tmp___4 ;
  double tmp___5 ;

  {
#line 1642
  rtnnme = "consys_addcol_pk";
#line 1672
  colndx = consys->varcnt + 1;
#line 1673
  pkcol->ndx = colndx;
#line 1674
  if ((unsigned long )pkcol->nme == (unsigned long )((void *)0)) {
    {
#line 1675
    dyio_outfxd(nmebuf, - ((int )(sizeof(nmebuf) - 1UL)), (char )'l', "var<%d>", colndx);
#line 1676
    pkcol->nme = (char const   *)(nmebuf);
    }
  }
#line 1684
  if (consys->opts & 1U) {
#line 1684
    tmp = 1;
  } else {
#line 1684
    tmp = 0;
  }
#line 1684
  if (tmp) {
#line 1685
    avail = consys->colsze - consys->rowsze;
  } else {
#line 1687
    avail = consys->colsze;
  }
#line 1688
  if (avail < consys->varcnt + 1) {
    {
#line 1689
    tmp___0 = consys_realloc(consys, (char )'c', 0);
    }
#line 1689
    if ((int )tmp___0 == 0) {
      {
#line 1690
      consys->opts |= 1U << 4;
#line 1691
      errmsg(112, rtnnme, consys->nme, "capacity expansion", "column", pkcol->nme,
             pkcol->ndx);
      }
#line 1693
      return ((bool )0);
    }
  }
  {
#line 1697
  tmp___1 = calloc((size_t )1, sizeof(colhdr_struct ));
#line 1697
  colhdr = (colhdr_struct *)tmp___1;
#line 1698
  *(consys->mtx.cols + colndx) = colhdr;
#line 1699
  colhdr->ndx = colndx;
#line 1700
  colhdr->nme = stralloc(pkcol->nme);
  }
#line 1701
  if ((unsigned long )consys->vtyp != (unsigned long )((void *)0)) {
#line 1702
    *(consys->vtyp + colndx) = vartyp;
  }
#line 1703
  (consys->archvcnt) ++;
#line 1704
  (consys->varcnt) ++;
#line 1705
  if ((unsigned int )vartyp == 2U) {
#line 1706
    (consys->intvcnt) ++;
  } else
#line 1708
  if ((unsigned int )vartyp == 3U) {
#line 1709
    (consys->binvcnt) ++;
  }
#line 1713
  if ((unsigned long )pkcol->nme == (unsigned long )(nmebuf)) {
#line 1713
    pkcol->nme = colhdr->nme;
  }
#line 1720
  if (pkcol->sze > 0) {
#line 1723
    if (pkcol->cnt == 0) {
#line 1723
      if (consys->opts & (1U << 1)) {
#line 1723
        tmp___2 = 1;
      } else {
#line 1723
        tmp___2 = 0;
      }
#line 1723
      if (tmp___2) {
        {
#line 1724
        warn(118, rtnnme, consys->nme, "column", colhdr->nme, colndx);
        }
      }
    }
#line 1726
    nzcnt = 0;
#line 1727
    pkcoeff = pkcol->coeffs;
#line 1728
    vecndx = 0;
    {
#line 1728
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1728
      if (! (vecndx < pkcol->cnt)) {
#line 1728
        goto while_break;
      }
#line 1729
      if (pkcoeff->ndx <= 0) {
        {
#line 1730
        errmsg(102, rtnnme, consys->nme, "row", pkcoeff->ndx, 1, consys->concnt);
        }
#line 1731
        return ((bool )0);
      } else
#line 1729
      if (pkcoeff->ndx > consys->concnt) {
        {
#line 1730
        errmsg(102, rtnnme, consys->nme, "row", pkcoeff->ndx, 1, consys->concnt);
        }
#line 1731
        return ((bool )0);
      }
      {
#line 1732
      tmp___3 = fabs(pkcoeff->val);
      }
#line 1732
      if (tmp___3 >= consys->inf) {
        {
#line 1733
        consys->opts |= 1U << 4;
#line 1734
        errmsg(128, rtnnme, consys->nme, pkcoeff->ndx, colndx, pkcoeff->val, "column",
               colhdr->nme);
        }
#line 1736
        return ((bool )0);
      }
      {
#line 1737
      tmp___5 = fabs(pkcoeff->val);
      }
#line 1737
      if (tmp___5 > consys->tiny) {
        {
#line 1738
        rowhdr = *(consys->mtx.rows + pkcoeff->ndx);
#line 1748
        tmp___4 = malloc(sizeof(coeff_struct ));
#line 1748
        coeff = (coeff_struct *)tmp___4;
#line 1749
        coeff->rowhdr = rowhdr;
#line 1750
        coeff->colhdr = colhdr;
#line 1751
        coeff->val = pkcoeff->val;
#line 1752
        coeff->rownxt = rowhdr->coeffs;
#line 1753
        rowhdr->coeffs = coeff;
#line 1754
        coeff->colnxt = colhdr->coeffs;
#line 1755
        colhdr->coeffs = coeff;
#line 1756
        (rowhdr->len) ++;
#line 1757
        nzcnt ++;
        }
#line 1758
        if (rowhdr->len > consys->maxrowlen) {
#line 1759
          consys->maxrowlen = rowhdr->len;
#line 1760
          consys->maxrowndx = pkcoeff->ndx;
        }
      } else {
        {
#line 1763
        warn(130, rtnnme, consys->nme, pkcoeff->ndx, colndx, pkcoeff->val, consys->tiny,
             "column", colhdr->nme);
        }
      }
#line 1766
      pkcoeff ++;
#line 1728
      vecndx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1768
    colhdr->len = nzcnt;
#line 1769
    consys->mtx.coeffcnt += nzcnt;
#line 1770
    if (colhdr->len > consys->maxcollen) {
#line 1771
      consys->maxcollen = colhdr->len;
#line 1772
      consys->maxcolndx = colndx;
    }
  }
#line 1777
  if ((unsigned long )consys->obj != (unsigned long )((void *)0)) {
#line 1777
    *(consys->obj + colndx) = obj;
  }
#line 1778
  if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
#line 1778
    *(consys->vlb + colndx) = vlb;
  }
#line 1779
  if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 1779
    *(consys->vub + colndx) = vub;
  }
#line 1781
  return ((bool )1);
}
}
#line 1785 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_addcol_ex(consys_struct *consys , vartyp_enum vartyp , char const   **nme ,
                      double *excol , double obj , double vlb , double vub ) 
{ 
  int colndx ;
  int rowndx ;
  int avail ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char nmebuf[20] ;
  char const   *rtnnme ;
  int tmp ;
  bool tmp___0 ;
  void *tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;

  {
#line 1816
  rtnnme = "consys_addcol_ex";
#line 1848
  colndx = consys->varcnt + 1;
#line 1849
  *(excol + 0) = (double )colndx;
#line 1850
  if ((unsigned long )nme == (unsigned long )((void *)0)) {
    {
#line 1851
    dyio_outfxd(nmebuf, - ((int )(sizeof(nmebuf) - 1UL)), (char )'l', "var<%d>", colndx);
#line 1852
    *nme = (char const   *)(nmebuf);
    }
  }
#line 1853
  if (consys->opts & 1U) {
#line 1853
    tmp = 1;
  } else {
#line 1853
    tmp = 0;
  }
#line 1853
  if (tmp) {
#line 1854
    avail = consys->colsze - consys->rowsze;
  } else {
#line 1856
    avail = consys->colsze;
  }
#line 1857
  if (avail < consys->varcnt + 1) {
    {
#line 1858
    tmp___0 = consys_realloc(consys, (char )'c', 0);
    }
#line 1858
    if ((int )tmp___0 == 0) {
      {
#line 1859
      consys->opts |= 1U << 4;
#line 1860
      errmsg(112, rtnnme, consys->nme, "capacity expansion", "column", *nme, *(excol + 0));
      }
#line 1862
      return ((bool )0);
    }
  }
  {
#line 1866
  tmp___1 = calloc((size_t )1, sizeof(colhdr_struct ));
#line 1866
  colhdr = (colhdr_struct *)tmp___1;
#line 1867
  *(consys->mtx.cols + colndx) = colhdr;
#line 1868
  colhdr->ndx = colndx;
#line 1869
  colhdr->nme = stralloc(*nme);
  }
#line 1870
  if ((unsigned long )consys->vtyp != (unsigned long )((void *)0)) {
#line 1871
    *(consys->vtyp + colndx) = vartyp;
  }
#line 1872
  (consys->archvcnt) ++;
#line 1873
  (consys->varcnt) ++;
#line 1874
  if ((unsigned int )vartyp == 2U) {
#line 1875
    (consys->intvcnt) ++;
  } else
#line 1877
  if ((unsigned int )vartyp == 3U) {
#line 1878
    (consys->binvcnt) ++;
  }
#line 1882
  if ((unsigned long )*nme == (unsigned long )(nmebuf)) {
#line 1882
    *nme = colhdr->nme;
  }
#line 1888
  rowndx = 1;
  {
#line 1888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1888
    if (! (rowndx <= consys->concnt)) {
#line 1888
      goto while_break;
    }
    {
#line 1889
    tmp___2 = fabs(*(excol + rowndx));
    }
#line 1889
    if (tmp___2 >= consys->inf) {
      {
#line 1890
      consys->opts |= 1U << 4;
#line 1891
      errmsg(128, rtnnme, consys->nme, rowndx, colndx, *(excol + rowndx), "column",
             colhdr->nme);
      }
#line 1893
      return ((bool )0);
    }
    {
#line 1894
    tmp___4 = fabs(*(excol + rowndx));
    }
#line 1894
    if (tmp___4 >= consys->tiny) {
      {
#line 1895
      (colhdr->len) ++;
#line 1896
      rowhdr = *(consys->mtx.rows + rowndx);
#line 1905
      tmp___3 = malloc(sizeof(coeff_struct ));
#line 1905
      coeff = (coeff_struct *)tmp___3;
#line 1906
      coeff->rowhdr = rowhdr;
#line 1907
      coeff->colhdr = colhdr;
#line 1908
      coeff->val = *(excol + rowndx);
#line 1909
      coeff->rownxt = rowhdr->coeffs;
#line 1910
      rowhdr->coeffs = coeff;
#line 1911
      coeff->colnxt = colhdr->coeffs;
#line 1912
      colhdr->coeffs = coeff;
#line 1913
      (rowhdr->len) ++;
      }
#line 1914
      if (rowhdr->len > consys->maxrowlen) {
#line 1915
        consys->maxrowlen = rowhdr->len;
#line 1916
        consys->maxrowndx = rowndx;
      }
    } else
#line 1919
    if (*(excol + rowndx) != 0.0) {
      {
#line 1920
      rowhdr = *(consys->mtx.rows + rowndx);
#line 1921
      warn(130, rtnnme, consys->nme, rowndx, colndx, *(excol + rowndx), consys->tiny,
           "row", rowhdr->nme);
      }
    }
#line 1888
    rowndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1926
  consys->mtx.coeffcnt += colhdr->len;
#line 1927
  if (colhdr->len > consys->maxcollen) {
#line 1928
    consys->maxcollen = colhdr->len;
#line 1929
    consys->maxcolndx = colndx;
  }
#line 1934
  if ((unsigned long )consys->obj != (unsigned long )((void *)0)) {
#line 1934
    *(consys->obj + colndx) = obj;
  }
#line 1935
  if ((unsigned long )consys->vlb != (unsigned long )((void *)0)) {
#line 1935
    *(consys->vlb + colndx) = vlb;
  }
#line 1936
  if ((unsigned long )consys->vub != (unsigned long )((void *)0)) {
#line 1936
    *(consys->vub + colndx) = vub;
  }
#line 1938
  return ((bool )1);
}
}
#line 1942 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_addrow_pk(consys_struct *consys , char class , contyp_enum contyp , pkvec_struct *pkrow ,
                      double rhs , double rhslow , conbnd_struct *cub , conbnd_struct *clb ) 
{ 
  int rowndx ;
  int vecndx ;
  int nzcnt ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  pkcoeff_struct *pkcoeff ;
  char nmebuf[20] ;
  char const   *rtnnme ;
  char const   *tmp ;
  bool tmp___0 ;
  char const   *tmp___1 ;
  bool tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  void *tmp___6 ;
  double tmp___7 ;
  char const   *tmp___8 ;
  bool tmp___9 ;
  char const   *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;

  {
#line 1985
  rtnnme = "consys_addrow_pk";
#line 2023
  if ((int )class == 97) {
#line 2024
    rowndx = consys->archccnt + 1;
  } else {
#line 2026
    rowndx = consys->concnt + 1;
  }
#line 2027
  pkrow->ndx = rowndx;
#line 2028
  if ((unsigned long )pkrow->nme == (unsigned long )((void *)0)) {
#line 2029
    if ((int )class == 97) {
#line 2029
      tmp = "con";
    } else {
#line 2029
      tmp = "cut";
    }
    {
#line 2029
    dyio_outfxd(nmebuf, - ((int )(sizeof(nmebuf) - 1UL)), (char )'l', "%s<%d>", tmp,
                rowndx);
#line 2031
    pkrow->nme = (char const   *)(nmebuf);
    }
  }
#line 2045
  if (consys->rowsze < consys->concnt + 1) {
    {
#line 2046
    tmp___0 = consys_realloc(consys, (char )'r', 0);
    }
#line 2046
    if ((int )tmp___0 == 0) {
      {
#line 2047
      consys->opts |= 1U << 4;
#line 2048
      errmsg(112, rtnnme, consys->nme, "capacity expansion", "row", pkrow->nme, pkrow->ndx);
      }
#line 2050
      return ((bool )0);
    }
  }
#line 2051
  if (rowndx < consys->concnt + 1) {
    {
#line 2052
    tmp___2 = move_row(consys, rowndx, consys->concnt + 1);
    }
#line 2052
    if ((int )tmp___2 == 0) {
      {
#line 2053
      consys->opts |= 1U << 4;
#line 2054
      tmp___1 = consys_nme(consys, (char )'c', rowndx, (bool )0, (char *)((void *)0));
#line 2054
      errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___1, rowndx);
      }
#line 2056
      return ((bool )0);
    }
  }
  {
#line 2061
  tmp___3 = calloc((size_t )1, sizeof(rowhdr_struct ));
#line 2061
  rowhdr = (rowhdr_struct *)tmp___3;
#line 2062
  *(consys->mtx.rows + rowndx) = rowhdr;
#line 2063
  rowhdr->ndx = rowndx;
#line 2064
  rowhdr->nme = stralloc(pkrow->nme);
  }
#line 2065
  if ((unsigned long )consys->ctyp != (unsigned long )((void *)0)) {
#line 2066
    *(consys->ctyp + rowndx) = contyp;
  }
#line 2067
  if ((int )class == 97) {
#line 2068
    (consys->archccnt) ++;
  } else {
#line 2070
    (consys->cutccnt) ++;
  }
#line 2071
  (consys->concnt) ++;
#line 2075
  if ((unsigned long )pkrow->nme == (unsigned long )(nmebuf)) {
#line 2075
    pkrow->nme = rowhdr->nme;
  }
#line 2082
  if (pkrow->sze > 0) {
#line 2085
    if (pkrow->cnt == 0) {
#line 2085
      if (consys->opts & (1U << 1)) {
#line 2085
        tmp___4 = 1;
      } else {
#line 2085
        tmp___4 = 0;
      }
#line 2085
      if (tmp___4) {
        {
#line 2086
        warn(118, rtnnme, consys->nme, "row", rowhdr->nme, rowndx);
        }
      }
    }
#line 2088
    nzcnt = 0;
#line 2089
    pkcoeff = pkrow->coeffs;
#line 2090
    vecndx = 0;
    {
#line 2090
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2090
      if (! (vecndx < pkrow->cnt)) {
#line 2090
        goto while_break;
      }
#line 2091
      if (pkcoeff->ndx <= 0) {
        {
#line 2092
        errmsg(102, rtnnme, consys->nme, "column", pkcoeff->ndx, 1, consys->varcnt);
        }
#line 2093
        return ((bool )0);
      } else
#line 2091
      if (pkcoeff->ndx > consys->varcnt) {
        {
#line 2092
        errmsg(102, rtnnme, consys->nme, "column", pkcoeff->ndx, 1, consys->varcnt);
        }
#line 2093
        return ((bool )0);
      }
      {
#line 2094
      tmp___5 = fabs(pkcoeff->val);
      }
#line 2094
      if (tmp___5 >= consys->inf) {
        {
#line 2095
        consys->opts |= 1U << 4;
#line 2096
        errmsg(128, rtnnme, consys->nme, rowndx, pkcoeff->ndx, pkcoeff->val, "row",
               rowhdr->nme);
        }
#line 2098
        return ((bool )0);
      }
      {
#line 2099
      tmp___7 = fabs(pkcoeff->val);
      }
#line 2099
      if (tmp___7 > consys->tiny) {
        {
#line 2100
        colhdr = *(consys->mtx.cols + pkcoeff->ndx);
#line 2110
        tmp___6 = malloc(sizeof(coeff_struct ));
#line 2110
        coeff = (coeff_struct *)tmp___6;
#line 2111
        coeff->colhdr = colhdr;
#line 2112
        coeff->rowhdr = rowhdr;
#line 2113
        coeff->val = pkcoeff->val;
#line 2114
        coeff->rownxt = rowhdr->coeffs;
#line 2115
        rowhdr->coeffs = coeff;
#line 2116
        coeff->colnxt = colhdr->coeffs;
#line 2117
        colhdr->coeffs = coeff;
#line 2118
        (colhdr->len) ++;
#line 2119
        nzcnt ++;
        }
#line 2120
        if (colhdr->len > consys->maxcollen) {
#line 2121
          consys->maxcollen = colhdr->len;
#line 2122
          consys->maxcolndx = pkcoeff->ndx;
        }
      } else {
        {
#line 2125
        warn(130, rtnnme, consys->nme, rowndx, pkcoeff->ndx, pkcoeff->val, consys->tiny,
             "row", rowhdr->nme);
        }
      }
#line 2128
      pkcoeff ++;
#line 2090
      vecndx ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2129
    rowhdr->len = nzcnt;
#line 2130
    consys->mtx.coeffcnt += nzcnt;
#line 2134
    if (rowhdr->len > consys->maxrowlen) {
#line 2135
      consys->maxrowlen = rowhdr->len;
#line 2136
      consys->maxrowndx = rowndx;
    }
  }
#line 2141
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 2141
    *(consys->rhs + rowndx) = rhs;
  }
#line 2142
  if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 2142
    *(consys->rhslow + rowndx) = rhslow;
  }
#line 2143
  if ((unsigned long )consys->clb != (unsigned long )((void *)0)) {
#line 2143
    if ((unsigned long )clb != (unsigned long )((void *)0)) {
#line 2143
      *(consys->clb + rowndx) = *clb;
    }
  }
#line 2144
  if ((unsigned long )consys->cub != (unsigned long )((void *)0)) {
#line 2144
    if ((unsigned long )cub != (unsigned long )((void *)0)) {
#line 2144
      *(consys->cub + rowndx) = *cub;
    }
  }
#line 2150
  if (consys->opts & 1U) {
#line 2150
    tmp___13 = 1;
  } else {
#line 2150
    tmp___13 = 0;
  }
#line 2150
  if (tmp___13) {
#line 2151
    if (consys->archvcnt > 0) {
      {
#line 2152
      tmp___9 = move_col(consys, consys->logvcnt + 1, consys->varcnt + 1);
      }
#line 2152
      if ((int )tmp___9 == 0) {
        {
#line 2153
        consys->opts |= 1U << 4;
#line 2154
        tmp___8 = consys_nme(consys, (char )'v', consys->logvcnt + 1, (bool )0, (char *)((void *)0));
#line 2154
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___8, consys->logvcnt + 1);
        }
#line 2157
        return ((bool )0);
      }
    }
#line 2158
    if (rowndx < consys->concnt) {
      {
#line 2159
      tmp___11 = move_col(consys, rowndx, consys->logvcnt + 1);
      }
#line 2159
      if ((int )tmp___11 == 0) {
        {
#line 2160
        consys->opts |= 1U << 4;
#line 2161
        tmp___10 = consys_nme(consys, (char )'c', rowndx, (bool )0, (char *)((void *)0));
#line 2161
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___10, rowndx);
        }
#line 2163
        return ((bool )0);
      }
    }
    {
#line 2164
    tmp___12 = add_logical(consys, rowndx);
    }
#line 2164
    if ((int )tmp___12 == 0) {
      {
#line 2165
      consys->opts |= 1U << 4;
#line 2166
      errmsg(121, rtnnme, consys->nme, rowhdr->nme, rowndx);
      }
#line 2167
      return ((bool )0);
    }
  }
#line 2169
  return ((bool )1);
}
}
#line 2173 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_getcol_pk(consys_struct *consys , int colndx , pkvec_struct **pkvec ) 
{ 
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  pkcoeff_struct *pkcoeff ;
  char const   *rtnnme ;

  {
#line 2196
  rtnnme = "consys_getcol_pk";
#line 2208
  if (colndx <= 0) {
    {
#line 2209
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2210
    return ((bool )0);
  } else
#line 2208
  if (colndx > consys->varcnt) {
    {
#line 2209
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2210
    return ((bool )0);
  }
#line 2212
  colhdr = *(consys->mtx.cols + colndx);
#line 2230
  if ((unsigned long )*pkvec == (unsigned long )((void *)0)) {
    {
#line 2231
    *pkvec = pkvec_new(consys->maxcollen);
    }
  }
#line 2236
  if ((*pkvec)->sze != 0) {
#line 2245
    coeff = colhdr->coeffs;
#line 2245
    pkcoeff = (*pkvec)->coeffs;
    {
#line 2245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2245
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 2245
        goto while_break;
      }
#line 2259
      pkcoeff->ndx = (coeff->rowhdr)->ndx;
#line 2260
      pkcoeff->val = coeff->val;
#line 2245
      coeff = coeff->colnxt;
#line 2245
      pkcoeff ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2261
  (*pkvec)->ndx = colndx;
#line 2262
  (*pkvec)->nme = colhdr->nme;
#line 2263
  (*pkvec)->dim = consys->concnt;
#line 2264
  (*pkvec)->dflt = (double )0;
#line 2265
  (*pkvec)->cnt = colhdr->len;
#line 2267
  return ((bool )1);
}
}
#line 2271 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_getcol_ex(consys_struct *consys , int colndx , double **vec ) 
{ 
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  void *tmp ;

  {
#line 2291
  rtnnme = "consys_getcol_ex";
#line 2303
  if (colndx <= 0) {
    {
#line 2304
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2305
    return ((bool )0);
  } else
#line 2303
  if (colndx > consys->varcnt) {
    {
#line 2304
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2305
    return ((bool )0);
  }
#line 2307
  colhdr = *(consys->mtx.cols + colndx);
#line 2324
  if ((unsigned long )*vec == (unsigned long )((void *)0)) {
    {
#line 2325
    tmp = calloc((size_t )(consys->concnt + 1), sizeof(double ));
#line 2325
    *vec = (double *)tmp;
    }
  } else {
    {
#line 2327
    memset((void *)*vec, 0, (unsigned long )(consys->concnt + 1) * sizeof(double ));
    }
  }
#line 2328
  coeff = colhdr->coeffs;
  {
#line 2328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2328
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 2328
      goto while_break;
    }
#line 2340
    *(*vec + (coeff->rowhdr)->ndx) = coeff->val;
#line 2328
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 2342
  return ((bool )1);
}
}
#line 2347 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_getrow_pk(consys_struct *consys , int rowndx , pkvec_struct **pkvec ) 
{ 
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  pkcoeff_struct *pkcoeff ;
  char const   *rtnnme ;

  {
#line 2370
  rtnnme = "consys_getrow_pk";
#line 2382
  if (rowndx <= 0) {
    {
#line 2383
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2384
    return ((bool )0);
  } else
#line 2382
  if (rowndx > consys->concnt) {
    {
#line 2383
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2384
    return ((bool )0);
  }
#line 2386
  rowhdr = *(consys->mtx.rows + rowndx);
#line 2404
  if ((unsigned long )*pkvec == (unsigned long )((void *)0)) {
    {
#line 2405
    *pkvec = pkvec_new(consys->maxrowlen);
    }
  }
#line 2410
  if ((*pkvec)->sze != 0) {
#line 2419
    coeff = rowhdr->coeffs;
#line 2419
    pkcoeff = (*pkvec)->coeffs;
    {
#line 2419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2419
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 2419
        goto while_break;
      }
#line 2433
      pkcoeff->ndx = (coeff->colhdr)->ndx;
#line 2434
      pkcoeff->val = coeff->val;
#line 2419
      coeff = coeff->rownxt;
#line 2419
      pkcoeff ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2435
  (*pkvec)->ndx = rowndx;
#line 2436
  (*pkvec)->nme = rowhdr->nme;
#line 2437
  (*pkvec)->dim = consys->varcnt;
#line 2438
  (*pkvec)->dflt = (double )0;
#line 2439
  (*pkvec)->cnt = rowhdr->len;
#line 2441
  return ((bool )1);
}
}
#line 2445 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_getrow_ex(consys_struct *consys , int rowndx , double **vec ) 
{ 
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  void *tmp ;

  {
#line 2465
  rtnnme = "consys_getrow_ex";
#line 2477
  if (rowndx <= 0) {
    {
#line 2478
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2479
    return ((bool )0);
  } else
#line 2477
  if (rowndx > consys->concnt) {
    {
#line 2478
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2479
    return ((bool )0);
  }
#line 2481
  rowhdr = *(consys->mtx.rows + rowndx);
#line 2498
  if ((unsigned long )*vec == (unsigned long )((void *)0)) {
    {
#line 2499
    tmp = calloc((size_t )(consys->varcnt + 1), sizeof(double ));
#line 2499
    *vec = (double *)tmp;
    }
  } else {
    {
#line 2501
    memset((void *)*vec, 0, (unsigned long )(consys->varcnt + 1) * sizeof(double ));
    }
  }
#line 2502
  coeff = rowhdr->coeffs;
  {
#line 2502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2502
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 2502
      goto while_break;
    }
#line 2514
    *(*vec + (coeff->colhdr)->ndx) = coeff->val;
#line 2502
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 2516
  return ((bool )1);
}
}
#line 2520 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_delcol(consys_struct *consys , int colndx ) 
{ 
  colhdr_struct *colhdr ;
  vartyp_enum vartyp ;
  bool rescan_rows ;
  bool rescan_cols ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;

  {
#line 2536
  rtnnme = "consys_delcol";
#line 2555
  if (colndx <= consys->logvcnt) {
    {
#line 2556
    errmsg(102, rtnnme, consys->nme, "column", colndx, consys->logvcnt + 1, consys->varcnt);
    }
#line 2558
    return ((bool )0);
  } else
#line 2555
  if (colndx > consys->varcnt) {
    {
#line 2556
    errmsg(102, rtnnme, consys->nme, "column", colndx, consys->logvcnt + 1, consys->varcnt);
    }
#line 2558
    return ((bool )0);
  }
  {
#line 2560
  colhdr = *(consys->mtx.cols + colndx);
#line 2574
  tmp = empty_col(consys, colndx, & rescan_rows);
  }
#line 2574
  if ((int )tmp == 0) {
    {
#line 2575
    consys->opts |= 1U << 4;
#line 2576
    errmsg(112, rtnnme, consys->nme, "empty", "column", colhdr->nme, colndx);
    }
#line 2577
    return ((bool )0);
  }
#line 2578
  if (colndx == consys->maxcolndx) {
#line 2579
    rescan_cols = (bool )1;
  } else {
#line 2581
    rescan_cols = (bool )0;
  }
#line 2587
  if (colndx == consys->xzndx) {
#line 2587
    consys->xzndx = -1;
  }
#line 2588
  if ((unsigned long )consys->vtyp != (unsigned long )((void *)0)) {
#line 2589
    vartyp = *(consys->vtyp + colndx);
#line 2590
    if ((unsigned int )vartyp == 2U) {
#line 2591
      (consys->intvcnt) --;
    } else
#line 2593
    if ((unsigned int )vartyp == 3U) {
#line 2594
      (consys->binvcnt) --;
    }
  }
#line 2600
  if (colndx < consys->varcnt) {
    {
#line 2601
    tmp___1 = move_col(consys, consys->varcnt, colndx);
    }
#line 2601
    if ((int )tmp___1 == 0) {
      {
#line 2602
      consys->opts |= 1U << 4;
#line 2603
      tmp___0 = consys_nme(consys, (char )'v', consys->varcnt, (bool )0, (char *)((void *)0));
#line 2603
      errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___0, consys->varcnt);
      }
#line 2605
      return ((bool )0);
    }
  }
#line 2606
  (consys->archvcnt) --;
#line 2607
  (consys->varcnt) --;
#line 2612
  if ((int )rescan_rows == 1) {
#line 2612
    goto _L;
  } else
#line 2612
  if ((int )rescan_cols == 1) {
    _L: /* CIL Label */ 
    {
#line 2613
    tmp___2 = find_maxes(consys, rescan_cols, rescan_rows);
    }
#line 2613
    if ((int )tmp___2 == 0) {
      {
#line 2614
      errmsg(112, rtnnme, consys->nme, "maxima update", "column", colhdr->nme, colhdr->ndx);
      }
#line 2616
      return ((bool )0);
    }
  }
#line 2617
  if ((unsigned long )colhdr->nme != (unsigned long )((void *)0)) {
    {
#line 2617
    strfree(colhdr->nme);
    }
  }
  {
#line 2618
  free((void *)colhdr);
  }
#line 2620
  return ((bool )1);
}
}
#line 2624 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_delrow(consys_struct *consys , int rowndx ) 
{ 
  int colndx ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  bool rescan_rows ;
  bool rescan_cols ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  char const   *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;
  bool tmp___9 ;
  char const   *tmp___10 ;
  bool tmp___11 ;
  bool tmp___12 ;

  {
#line 2642
  rtnnme = "consys_delrow";
#line 2660
  if (rowndx <= 0) {
    {
#line 2661
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2662
    return ((bool )0);
  } else
#line 2660
  if (rowndx > consys->concnt) {
    {
#line 2661
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2662
    return ((bool )0);
  }
#line 2664
  rowhdr = *(consys->mtx.rows + rowndx);
#line 2683
  rescan_rows = (bool )0;
#line 2684
  if (consys->opts & 1U) {
#line 2684
    tmp___6 = 1;
  } else {
#line 2684
    tmp___6 = 0;
  }
#line 2684
  if (tmp___6) {
    {
#line 2685
    colndx = rowndx;
#line 2686
    colhdr = *(consys->mtx.cols + colndx);
#line 2695
    tmp = empty_col(consys, colndx, & rescan_rows);
    }
#line 2695
    if ((int )tmp == 0) {
      {
#line 2696
      consys->opts |= 1U << 4;
#line 2697
      errmsg(112, rtnnme, consys->nme, "empty", "column", colhdr->nme, colndx);
      }
#line 2698
      return ((bool )0);
    }
#line 2699
    if ((unsigned long )colhdr->nme != (unsigned long )((void *)0)) {
      {
#line 2699
      strfree(colhdr->nme);
      }
    }
    {
#line 2700
    free((void *)colhdr);
    }
#line 2701
    if (colndx < consys->archccnt) {
#line 2701
      if (consys->cutccnt > 0) {
        {
#line 2702
        tmp___1 = move_col(consys, consys->archccnt, colndx);
        }
#line 2702
        if ((int )tmp___1 == 0) {
          {
#line 2703
          consys->opts |= 1U << 4;
#line 2704
          tmp___0 = consys_nme(consys, (char )'v', consys->archccnt, (bool )0, (char *)((void *)0));
#line 2704
          errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___0, consys->archccnt);
          }
#line 2707
          return ((bool )0);
        }
#line 2708
        colndx = consys->archccnt;
      }
    }
#line 2709
    if (colndx < consys->logvcnt) {
      {
#line 2710
      tmp___3 = move_col(consys, consys->logvcnt, colndx);
      }
#line 2710
      if ((int )tmp___3 == 0) {
        {
#line 2711
        consys->opts |= 1U << 4;
#line 2712
        tmp___2 = consys_nme(consys, (char )'v', consys->logvcnt, (bool )0, (char *)((void *)0));
#line 2712
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___2, consys->logvcnt);
        }
#line 2715
        return ((bool )0);
      }
    }
#line 2716
    if (consys->archvcnt > 0) {
      {
#line 2717
      tmp___5 = move_col(consys, consys->varcnt, consys->logvcnt);
      }
#line 2717
      if ((int )tmp___5 == 0) {
        {
#line 2718
        consys->opts |= 1U << 4;
#line 2719
        tmp___4 = consys_nme(consys, (char )'v', consys->varcnt, (bool )0, (char *)((void *)0));
#line 2719
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___4, consys->varcnt);
        }
#line 2722
        return ((bool )0);
      }
    }
#line 2723
    (consys->logvcnt) --;
#line 2724
    (consys->varcnt) --;
  }
  {
#line 2731
  tmp___7 = empty_row(consys, rowndx, & rescan_cols);
  }
#line 2731
  if ((int )tmp___7 == 0) {
    {
#line 2732
    consys->opts |= 1U << 4;
#line 2733
    errmsg(112, rtnnme, consys->nme, "empty", "row", rowhdr->nme, rowndx);
    }
#line 2734
    return ((bool )0);
  }
#line 2735
  if (rowndx == consys->maxrowndx) {
#line 2735
    rescan_rows = (bool )1;
  }
#line 2736
  if (rowndx == consys->objndx) {
#line 2736
    consys->objndx = -1;
  }
#line 2737
  if (rowndx < consys->archccnt) {
#line 2737
    if (consys->cutccnt > 0) {
      {
#line 2738
      tmp___9 = move_row(consys, consys->archccnt, rowndx);
      }
#line 2738
      if ((int )tmp___9 == 0) {
        {
#line 2739
        consys->opts |= 1U << 4;
#line 2740
        tmp___8 = consys_nme(consys, (char )'c', consys->archccnt, (bool )0, (char *)((void *)0));
#line 2740
        errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___8, consys->archccnt);
        }
#line 2743
        return ((bool )0);
      }
#line 2744
      rowndx = consys->archccnt;
    }
  }
#line 2745
  if (rowndx < consys->concnt) {
    {
#line 2746
    tmp___11 = move_row(consys, consys->concnt, rowndx);
    }
#line 2746
    if ((int )tmp___11 == 0) {
      {
#line 2747
      consys->opts |= 1U << 4;
#line 2748
      tmp___10 = consys_nme(consys, (char )'c', consys->concnt, (bool )0, (char *)((void *)0));
#line 2748
      errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___10, consys->concnt);
      }
#line 2750
      return ((bool )0);
    }
  }
#line 2751
  if (rowhdr->ndx <= consys->archccnt) {
#line 2752
    (consys->archccnt) --;
  } else {
#line 2754
    (consys->cutccnt) --;
  }
#line 2755
  (consys->concnt) --;
#line 2760
  if ((int )rescan_rows == 1) {
#line 2760
    goto _L;
  } else
#line 2760
  if ((int )rescan_cols == 1) {
    _L: /* CIL Label */ 
    {
#line 2761
    tmp___12 = find_maxes(consys, rescan_cols, rescan_rows);
    }
#line 2761
    if ((int )tmp___12 == 0) {
      {
#line 2762
      errmsg(112, rtnnme, consys->nme, "maxima update", "row", rowhdr->nme, rowhdr->ndx);
      }
#line 2764
      return ((bool )0);
    }
  }
#line 2765
  if ((unsigned long )rowhdr->nme != (unsigned long )((void *)0)) {
    {
#line 2765
    strfree(rowhdr->nme);
    }
  }
  {
#line 2766
  free((void *)rowhdr);
  }
#line 2768
  return ((bool )1);
}
}
#line 2772 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_delrow_stable(consys_struct *consys , int rowndx ) 
{ 
  int colndx ;
  int i ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  bool rescan_rows ;
  bool rescan_cols ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;
  char const   *tmp___2 ;
  bool tmp___3 ;
  char const   *tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  char const   *tmp___8 ;
  bool tmp___9 ;
  char const   *tmp___10 ;
  bool tmp___11 ;
  char const   *tmp___12 ;
  bool tmp___13 ;
  bool tmp___14 ;

  {
#line 2793
  rtnnme = "consys_delrow";
#line 2811
  if (rowndx <= 0) {
    {
#line 2812
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2813
    return ((bool )0);
  } else
#line 2811
  if (rowndx > consys->concnt) {
    {
#line 2812
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2813
    return ((bool )0);
  }
#line 2815
  rowhdr = *(consys->mtx.rows + rowndx);
#line 2834
  rescan_rows = (bool )0;
#line 2835
  if (consys->opts & 1U) {
#line 2835
    tmp___6 = 1;
  } else {
#line 2835
    tmp___6 = 0;
  }
#line 2835
  if (tmp___6) {
    {
#line 2836
    colndx = rowndx;
#line 2837
    colhdr = *(consys->mtx.cols + colndx);
#line 2846
    tmp = empty_col(consys, colndx, & rescan_rows);
    }
#line 2846
    if ((int )tmp == 0) {
      {
#line 2847
      consys->opts |= 1U << 4;
#line 2848
      errmsg(112, rtnnme, consys->nme, "empty", "column", colhdr->nme, colndx);
      }
#line 2849
      return ((bool )0);
    }
#line 2850
    if ((unsigned long )colhdr->nme != (unsigned long )((void *)0)) {
      {
#line 2850
      strfree(colhdr->nme);
      }
    }
    {
#line 2851
    free((void *)colhdr);
    }
#line 2852
    if (colndx < consys->archccnt) {
#line 2852
      if (consys->cutccnt > 0) {
        {
#line 2853
        tmp___1 = move_col(consys, consys->archccnt, colndx);
        }
#line 2853
        if ((int )tmp___1 == 0) {
          {
#line 2854
          consys->opts |= 1U << 4;
#line 2855
          tmp___0 = consys_nme(consys, (char )'v', consys->archccnt, (bool )0, (char *)((void *)0));
#line 2855
          errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___0, consys->archccnt);
          }
#line 2858
          return ((bool )0);
        }
#line 2859
        colndx = consys->archccnt;
      }
    }
#line 2860
    if (colndx < consys->logvcnt) {
      {
#line 2861
      tmp___3 = move_col(consys, consys->logvcnt, colndx);
      }
#line 2861
      if ((int )tmp___3 == 0) {
        {
#line 2862
        consys->opts |= 1U << 4;
#line 2863
        tmp___2 = consys_nme(consys, (char )'v', consys->logvcnt, (bool )0, (char *)((void *)0));
#line 2863
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___2, consys->logvcnt);
        }
#line 2866
        return ((bool )0);
      }
    }
#line 2867
    if (consys->archvcnt > 0) {
      {
#line 2868
      tmp___5 = move_col(consys, consys->varcnt, consys->logvcnt);
      }
#line 2868
      if ((int )tmp___5 == 0) {
        {
#line 2869
        consys->opts |= 1U << 4;
#line 2870
        tmp___4 = consys_nme(consys, (char )'v', consys->varcnt, (bool )0, (char *)((void *)0));
#line 2870
        errmsg(112, rtnnme, consys->nme, "swap", "column", tmp___4, consys->varcnt);
        }
#line 2873
        return ((bool )0);
      }
    }
#line 2874
    (consys->logvcnt) --;
#line 2875
    (consys->varcnt) --;
  }
  {
#line 2882
  tmp___7 = empty_row(consys, rowndx, & rescan_cols);
  }
#line 2882
  if ((int )tmp___7 == 0) {
    {
#line 2883
    consys->opts |= 1U << 4;
#line 2884
    errmsg(112, rtnnme, consys->nme, "empty", "row", rowhdr->nme, rowndx);
    }
#line 2885
    return ((bool )0);
  }
#line 2886
  if (rowndx == consys->maxrowndx) {
#line 2886
    rescan_rows = (bool )1;
  }
#line 2887
  if (rowndx == consys->objndx) {
#line 2887
    consys->objndx = -1;
  }
#line 2889
  if (rowndx < consys->archccnt) {
#line 2889
    if (consys->cutccnt > 0) {
      {
#line 2890
      tmp___9 = move_row(consys, consys->archccnt, rowndx);
      }
#line 2890
      if ((int )tmp___9 == 0) {
        {
#line 2891
        consys->opts |= 1U << 4;
#line 2892
        tmp___8 = consys_nme(consys, (char )'c', consys->archccnt, (bool )0, (char *)((void *)0));
#line 2892
        errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___8, consys->archccnt);
        }
#line 2895
        return ((bool )0);
      }
#line 2896
      rowndx = consys->archccnt;
    }
  }
#line 2897
  if (rowndx < consys->concnt) {
    {
#line 2898
    tmp___11 = move_row(consys, consys->concnt, rowndx);
    }
#line 2898
    if ((int )tmp___11 == 0) {
      {
#line 2899
      consys->opts |= 1U << 4;
#line 2900
      tmp___10 = consys_nme(consys, (char )'c', consys->concnt, (bool )0, (char *)((void *)0));
#line 2900
      errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___10, consys->concnt);
      }
#line 2902
      return ((bool )0);
    }
  }
#line 2903
  i = rowndx;
  {
#line 2903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2903
    if (! (i < consys->concnt)) {
#line 2903
      goto while_break;
    }
    {
#line 2904
    tmp___13 = move_row(consys, i + 1, i);
    }
#line 2904
    if ((int )tmp___13 == 0) {
      {
#line 2905
      consys->opts |= 1U << 4;
#line 2906
      tmp___12 = consys_nme(consys, (char )'c', i + 1, (bool )0, (char *)((void *)0));
#line 2906
      errmsg(112, rtnnme, consys->nme, "swap", "row", tmp___12, i + 1);
      }
#line 2908
      return ((bool )0);
    }
#line 2903
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2909
  if (rowhdr->ndx <= consys->archccnt) {
#line 2910
    (consys->archccnt) --;
  } else {
#line 2912
    (consys->cutccnt) --;
  }
#line 2913
  (consys->concnt) --;
#line 2918
  if ((int )rescan_rows == 1) {
#line 2918
    goto _L;
  } else
#line 2918
  if ((int )rescan_cols == 1) {
    _L: /* CIL Label */ 
    {
#line 2919
    tmp___14 = find_maxes(consys, rescan_cols, rescan_rows);
    }
#line 2919
    if ((int )tmp___14 == 0) {
      {
#line 2920
      errmsg(112, rtnnme, consys->nme, "maxima update", "row", rowhdr->nme, rowhdr->ndx);
      }
#line 2922
      return ((bool )0);
    }
  }
#line 2923
  if ((unsigned long )rowhdr->nme != (unsigned long )((void *)0)) {
    {
#line 2923
    strfree(rowhdr->nme);
    }
  }
  {
#line 2924
  free((void *)rowhdr);
  }
#line 2926
  return ((bool )1);
}
}
#line 2930 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
double consys_getcoeff(consys_struct *consys , int rowndx , int colndx ) 
{ 
  int lclndx ;
  coeff_struct *coeff ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  char const   *rtnnme ;

  {
#line 2957
  rtnnme = "consys_getcoeff";
#line 2976
  if (rowndx <= 0) {
    {
#line 2977
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2978
    return (QNaNbits___8.fpdbl);
  } else
#line 2976
  if (rowndx > consys->concnt) {
    {
#line 2977
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 2978
    return (QNaNbits___8.fpdbl);
  }
#line 2979
  if (colndx <= 0) {
    {
#line 2980
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2981
    return (QNaNbits___8.fpdbl);
  } else
#line 2979
  if (colndx > consys->varcnt) {
    {
#line 2980
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 2981
    return (QNaNbits___8.fpdbl);
  }
#line 2984
  colhdr = *(consys->mtx.cols + colndx);
#line 3006
  coeff = colhdr->coeffs;
  {
#line 3006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3006
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 3006
      goto while_break;
    }
#line 3007
    rowhdr = coeff->rowhdr;
#line 3014
    lclndx = rowhdr->ndx;
#line 3024
    if (lclndx == rowndx) {
#line 3024
      goto while_break;
    }
#line 3006
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 3028
  if ((unsigned long )coeff == (unsigned long )((void *)0)) {
#line 3029
    return (0.0);
  } else {
#line 3031
    return (coeff->val);
  }
}
}
#line 3035 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_setcoeff(consys_struct *consys , int rowndx , int colndx , double val ) 
{ 
  int lclndx ;
  bool scanrows ;
  bool scancols ;
  coeff_struct *coeff ;
  coeff_struct **pcoeff ;
  colhdr_struct *colhdr ;
  rowhdr_struct *rowhdr ;
  char const   *rtnnme ;
  double tmp ;
  void *tmp___0 ;
  bool tmp___1 ;

  {
#line 3064
  rtnnme = "consys_chgcoeff";
#line 3082
  if (rowndx <= 0) {
    {
#line 3083
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 3084
    return ((bool )0);
  } else
#line 3082
  if (rowndx > consys->concnt) {
    {
#line 3083
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 3084
    return ((bool )0);
  }
#line 3085
  if (colndx <= 0) {
    {
#line 3086
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 3087
    return ((bool )0);
  } else
#line 3085
  if (colndx > consys->varcnt) {
    {
#line 3086
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 3087
    return ((bool )0);
  }
  {
#line 3090
  colhdr = *(consys->mtx.cols + colndx);
#line 3109
  tmp = fabs(val);
  }
#line 3109
  if (tmp >= consys->inf) {
    {
#line 3110
    consys->opts |= 1U << 4;
#line 3111
    errmsg(128, rtnnme, consys->nme, rowndx, colndx, val, "coefficient", "<no name>");
    }
#line 3113
    return ((bool )0);
  }
#line 3118
  if (val != (double )0) {
#line 3119
    coeff = colhdr->coeffs;
    {
#line 3119
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3119
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 3119
        goto while_break;
      }
#line 3120
      rowhdr = coeff->rowhdr;
#line 3127
      lclndx = rowhdr->ndx;
#line 3137
      if (lclndx == rowndx) {
#line 3137
        goto while_break;
      }
#line 3119
      coeff = coeff->colnxt;
    }
    while_break: /* CIL Label */ ;
    }
#line 3141
    if ((unsigned long )coeff != (unsigned long )((void *)0)) {
#line 3142
      coeff->val = val;
#line 3143
      return ((bool )1);
    }
    {
#line 3147
    rowhdr = *(consys->mtx.rows + rowndx);
#line 3148
    tmp___0 = malloc(sizeof(coeff_struct ));
#line 3148
    coeff = (coeff_struct *)tmp___0;
#line 3149
    coeff->rowhdr = rowhdr;
#line 3150
    coeff->colhdr = colhdr;
#line 3151
    coeff->val = val;
#line 3152
    coeff->rownxt = rowhdr->coeffs;
#line 3153
    rowhdr->coeffs = coeff;
#line 3154
    (rowhdr->len) ++;
    }
#line 3155
    if (rowhdr->len > consys->maxrowlen) {
#line 3156
      consys->maxrowlen = rowhdr->len;
#line 3157
      consys->maxrowndx = rowndx;
    }
#line 3158
    (colhdr->len) ++;
#line 3159
    if (colhdr->len > consys->maxcollen) {
#line 3160
      consys->maxcollen = colhdr->len;
#line 3161
      consys->maxcolndx = colndx;
    }
  } else {
#line 3167
    pcoeff = & colhdr->coeffs;
#line 3167
    coeff = *pcoeff;
    {
#line 3167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3167
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 3167
        goto while_break___0;
      }
#line 3170
      rowhdr = coeff->rowhdr;
#line 3177
      lclndx = rowhdr->ndx;
#line 3187
      if (lclndx == rowndx) {
#line 3187
        goto while_break___0;
      }
#line 3167
      pcoeff = & coeff->colnxt;
#line 3167
      coeff = *pcoeff;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3191
    if ((unsigned long )coeff == (unsigned long )((void *)0)) {
#line 3191
      return ((bool )1);
    }
#line 3196
    *pcoeff = coeff->colnxt;
#line 3197
    pcoeff = & rowhdr->coeffs;
    {
#line 3197
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3197
      if (! ((unsigned long )*pcoeff != (unsigned long )((void *)0))) {
#line 3197
        goto while_break___1;
      }
#line 3200
      if ((unsigned long )*pcoeff == (unsigned long )coeff) {
#line 3200
        goto while_break___1;
      }
#line 3197
      pcoeff = & (*pcoeff)->rownxt;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3207
    *pcoeff = coeff->rownxt;
#line 3208
    free((void *)coeff);
#line 3213
    (consys->mtx.coeffcnt) --;
#line 3214
    (colhdr->len) --;
    }
#line 3215
    if (colndx == consys->maxcolndx) {
#line 3216
      scancols = (bool )1;
    } else {
#line 3218
      scancols = (bool )0;
    }
#line 3219
    (rowhdr->len) --;
#line 3220
    if (rowndx == consys->maxrowndx) {
#line 3221
      scanrows = (bool )1;
    } else {
#line 3223
      scanrows = (bool )0;
    }
#line 3224
    if ((int )scancols == 1) {
#line 3224
      goto _L;
    } else
#line 3224
    if ((int )scanrows == 1) {
      _L: /* CIL Label */ 
      {
#line 3225
      tmp___1 = find_maxes(consys, scancols, scanrows);
      }
#line 3225
      if ((int )tmp___1 == 0) {
        {
#line 3226
        errmsg(112, rtnnme, consys->nme, "maxima update", "column", colhdr->nme, colhdr->ndx);
        }
#line 3228
        return ((bool )0);
      }
    }
  }
#line 3230
  return ((bool )1);
}
}
#line 3234 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_utils.c"
bool consys_logicals(consys_struct *consys ) 
{ 
  int ndx ;
  char const   *rtnnme ;
  bool tmp ;
  char const   *tmp___0 ;
  bool tmp___1 ;

  {
#line 3246
  rtnnme = "consys_logicals";
#line 3266
  ndx = (consys->archvcnt + consys->concnt) - consys->colsze;
#line 3267
  if (ndx > 0) {
    {
#line 3268
    tmp = consys_realloc(consys, (char )'c', ndx);
    }
#line 3268
    if ((int )tmp == 0) {
      {
#line 3269
      consys->opts |= 1U << 4;
#line 3270
      errmsg(124, rtnnme, consys->nme);
      }
#line 3271
      return ((bool )0);
    }
  }
#line 3275
  ndx = 1;
  {
#line 3275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3275
    if (! (ndx <= consys->concnt)) {
#line 3275
      goto while_break;
    }
    {
#line 3276
    tmp___1 = add_logical(consys, ndx);
    }
#line 3276
    if ((int )tmp___1 == 0) {
      {
#line 3277
      consys->opts |= 1U << 4;
#line 3278
      tmp___0 = consys_nme(consys, (char )'c', ndx, (bool )0, (char *)((void *)0));
#line 3278
      errmsg(121, rtnnme, consys->nme, tmp___0, ndx);
      }
#line 3280
      return ((bool )0);
    }
#line 3275
    ndx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3284
  consys->opts |= 1U;
#line 3286
  return ((bool )1);
}
}
#line 184 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t QNaNbits___9  __attribute__((__unused__))  =    {{(unsigned char )'\376', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377',
     (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\377', (unsigned char )'\177'}};
#line 546 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys.h"
int consys_gcdrow(consys_struct *consys , int rowndx ) ;
#line 550
double consys_1normrow(consys_struct *consys , int rowndx ) ;
#line 550
double consys_ssqrow(consys_struct *consys , int rowndx ) ;
#line 550
double consys_infnormrow(consys_struct *consys , int rowndx ) ;
#line 550
double consys_1normcol(consys_struct *consys , int colndx ) ;
#line 559
bool consys_mulrow(consys_struct *consys , int rowndx , double scalar ) ;
#line 560
bool consys_divrow(consys_struct *consys , int rowndx , double scalar ) ;
#line 562
bool consys_accumcol(consys_struct *consys , int colndx , double *vec ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_dotrow(consys_struct *consys , int rowndx , double *vec ) 
{ 
  double dotprod ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 49
  rtnnme = "consys_dotrow";
#line 61
  if (rowndx <= 0) {
    {
#line 62
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 63
    return (QNaNbits___9.fpdbl);
  } else
#line 61
  if (rowndx > consys->concnt) {
    {
#line 62
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 63
    return (QNaNbits___9.fpdbl);
  }
#line 65
  rowhdr = *(consys->mtx.rows + rowndx);
#line 78
  dotprod = (double )0;
#line 79
  coeff = rowhdr->coeffs;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
#line 95
    dotprod += coeff->val * *(vec + (coeff->colhdr)->ndx);
#line 79
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (dotprod);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_dotcol(consys_struct *consys , int colndx , double *vec ) 
{ 
  double dotprod ;
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 120
  rtnnme = "consys_dotcol";
#line 132
  if (colndx <= 0) {
    {
#line 133
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 134
    return (QNaNbits___9.fpdbl);
  } else
#line 132
  if (colndx > consys->varcnt) {
    {
#line 133
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 134
    return (QNaNbits___9.fpdbl);
  }
#line 136
  colhdr = *(consys->mtx.cols + colndx);
#line 149
  dotprod = (double )0;
#line 150
  coeff = colhdr->coeffs;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 150
      goto while_break;
    }
#line 166
    dotprod += coeff->val * *(vec + (coeff->rowhdr)->ndx);
#line 150
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (dotprod);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_1normrow(consys_struct *consys , int rowndx ) 
{ 
  double norm ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp ;

  {
#line 189
  rtnnme = "consys_1normrow";
#line 201
  if (rowndx <= 0) {
    {
#line 202
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 203
    return (QNaNbits___9.fpdbl);
  } else
#line 201
  if (rowndx > consys->concnt) {
    {
#line 202
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 203
    return (QNaNbits___9.fpdbl);
  }
#line 205
  rowhdr = *(consys->mtx.rows + rowndx);
#line 215
  norm = (double )0;
#line 216
  coeff = rowhdr->coeffs;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 216
      goto while_break;
    }
    {
#line 232
    tmp = fabs(coeff->val);
#line 232
    norm += tmp;
#line 216
    coeff = coeff->rownxt;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (norm);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_ssqrow(consys_struct *consys , int rowndx ) 
{ 
  double norm ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 255
  rtnnme = "consys_ssqrow";
#line 270
  if (rowndx <= 0) {
    {
#line 271
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 272
    return (QNaNbits___9.fpdbl);
  } else
#line 270
  if (rowndx > consys->concnt) {
    {
#line 271
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 272
    return (QNaNbits___9.fpdbl);
  }
#line 274
  rowhdr = *(consys->mtx.rows + rowndx);
#line 284
  norm = (double )0;
#line 285
  coeff = rowhdr->coeffs;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 285
      goto while_break;
    }
#line 301
    norm += coeff->val * coeff->val;
#line 285
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return (norm);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_2normrow(consys_struct *consys , int rowndx ) 
{ 
  double norm ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp ;

  {
#line 323
  rtnnme = "consys_2normrow";
#line 338
  if (rowndx <= 0) {
    {
#line 339
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 340
    return (QNaNbits___9.fpdbl);
  } else
#line 338
  if (rowndx > consys->concnt) {
    {
#line 339
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 340
    return (QNaNbits___9.fpdbl);
  }
#line 342
  rowhdr = *(consys->mtx.rows + rowndx);
#line 352
  norm = (double )0;
#line 353
  coeff = rowhdr->coeffs;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 353
      goto while_break;
    }
#line 369
    norm += coeff->val * coeff->val;
#line 353
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 371
  tmp = sqrt(norm);
  }
#line 371
  return (tmp);
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_infnormrow(consys_struct *consys , int rowndx ) 
{ 
  double norm ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 391
  rtnnme = "consys_infnormrow";
#line 406
  if (rowndx <= 0) {
    {
#line 407
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 408
    return (QNaNbits___9.fpdbl);
  } else
#line 406
  if (rowndx > consys->concnt) {
    {
#line 407
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 408
    return (QNaNbits___9.fpdbl);
  }
#line 410
  rowhdr = *(consys->mtx.rows + rowndx);
#line 420
  norm = (double )0;
#line 421
  coeff = rowhdr->coeffs;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 421
      goto while_break;
    }
    {
#line 437
    tmp___1 = fabs(coeff->val);
    }
#line 437
    if (tmp___1 > norm) {
      {
#line 437
      tmp___0 = fabs(coeff->val);
#line 437
      norm = tmp___0;
      }
    } else {
#line 437
      norm = norm;
    }
#line 421
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return (norm);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_1normcol(consys_struct *consys , int colndx ) 
{ 
  double norm ;
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp ;

  {
#line 460
  rtnnme = "consys_1normcol";
#line 472
  if (colndx <= 0) {
    {
#line 473
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 474
    return (QNaNbits___9.fpdbl);
  } else
#line 472
  if (colndx > consys->varcnt) {
    {
#line 473
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 474
    return (QNaNbits___9.fpdbl);
  }
#line 476
  colhdr = *(consys->mtx.cols + colndx);
#line 486
  norm = (double )0;
#line 487
  coeff = colhdr->coeffs;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 487
      goto while_break;
    }
    {
#line 503
    tmp = fabs(coeff->val);
#line 503
    norm += tmp;
#line 487
    coeff = coeff->colnxt;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 505
  return (norm);
}
}
#line 508 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_ssqcol(consys_struct *consys , int colndx ) 
{ 
  double norm ;
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 526
  rtnnme = "consys_ssqcol";
#line 538
  if (colndx <= 0) {
    {
#line 539
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 540
    return (QNaNbits___9.fpdbl);
  } else
#line 538
  if (colndx > consys->varcnt) {
    {
#line 539
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 540
    return (QNaNbits___9.fpdbl);
  }
#line 542
  colhdr = *(consys->mtx.cols + colndx);
#line 552
  norm = (double )0;
#line 553
  coeff = colhdr->coeffs;
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 553
      goto while_break;
    }
#line 569
    norm += coeff->val * coeff->val;
#line 553
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (norm);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_2normcol(consys_struct *consys , int colndx ) 
{ 
  double norm ;
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp ;

  {
#line 591
  rtnnme = "consys_2normcol";
#line 603
  if (colndx <= 0) {
    {
#line 604
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 605
    return (QNaNbits___9.fpdbl);
  } else
#line 603
  if (colndx > consys->varcnt) {
    {
#line 604
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 605
    return (QNaNbits___9.fpdbl);
  }
#line 607
  colhdr = *(consys->mtx.cols + colndx);
#line 617
  norm = (double )0;
#line 618
  coeff = colhdr->coeffs;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 618
      goto while_break;
    }
#line 634
    norm += coeff->val * coeff->val;
#line 618
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 636
  tmp = sqrt(norm);
  }
#line 636
  return (tmp);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
double consys_infnormcol(consys_struct *consys , int colndx ) 
{ 
  double norm ;
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 656
  rtnnme = "consys_infnormcol";
#line 668
  if (colndx <= 0) {
    {
#line 669
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 670
    return (QNaNbits___9.fpdbl);
  } else
#line 668
  if (colndx > consys->varcnt) {
    {
#line 669
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 670
    return (QNaNbits___9.fpdbl);
  }
#line 672
  colhdr = *(consys->mtx.cols + colndx);
#line 682
  norm = (double )0;
#line 683
  coeff = colhdr->coeffs;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 683
      goto while_break;
    }
    {
#line 699
    tmp___1 = fabs(coeff->val);
    }
#line 699
    if (tmp___1 > norm) {
      {
#line 699
      tmp___0 = fabs(coeff->val);
#line 699
      norm = tmp___0;
      }
    } else {
#line 699
      norm = norm;
    }
#line 683
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 701
  return (norm);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
bool consys_mulrow(consys_struct *consys , int rowndx , double scalar ) 
{ 
  double tmprhs ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  conbnd_struct tmpbnd ;
  bool do_conbnds ;
  char const   *rtnnme ;
  int tmp ;

  {
#line 737
  rtnnme = "consys_mulrow";
#line 751
  if (rowndx <= 0) {
    {
#line 752
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 753
    return ((bool )0);
  } else
#line 751
  if (rowndx > consys->concnt) {
    {
#line 752
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 753
    return ((bool )0);
  }
#line 756
  rowhdr = *(consys->mtx.rows + rowndx);
#line 767
  if (scalar == (double )0) {
#line 767
    if (consys->opts & (1U << 1)) {
#line 767
      tmp = 1;
    } else {
#line 767
      tmp = 0;
    }
#line 767
    if (tmp) {
      {
#line 768
      warn(132, rtnnme, consys->nme, "row", rowhdr->nme, rowndx);
      }
    }
  }
#line 770
  if ((unsigned long )consys->cub != (unsigned long )((void *)0)) {
#line 770
    if ((unsigned long )consys->clb != (unsigned long )((void *)0)) {
#line 771
      do_conbnds = (bool )1;
    } else {
#line 773
      do_conbnds = (bool )0;
    }
  } else {
#line 773
    do_conbnds = (bool )0;
  }
#line 777
  coeff = rowhdr->coeffs;
  {
#line 777
  while (1) {
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 777
      goto while_break;
    }
#line 793
    coeff->val *= scalar;
#line 777
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 797
  if (scalar == (double )0) {
#line 798
    if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 798
      *(consys->rhs + rowndx) = (double )0;
    }
#line 799
    if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 799
      *(consys->rhslow + rowndx) = (double )0;
    }
#line 800
    if ((int )do_conbnds == 1) {
#line 801
      tmpbnd.revs = 0;
#line 802
      tmpbnd.inf = 0;
#line 803
      tmpbnd.bnd = (double )0;
#line 804
      *(consys->cub + rowndx) = tmpbnd;
#line 805
      *(consys->clb + rowndx) = tmpbnd;
    }
#line 806
    return ((bool )1);
  }
#line 811
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 811
    *(consys->rhs + rowndx) *= scalar;
  }
#line 812
  if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 812
    *(consys->rhslow + rowndx) *= scalar;
  }
#line 813
  if ((int )do_conbnds == 1) {
#line 814
    (consys->cub + rowndx)->bnd *= scalar;
#line 815
    (consys->clb + rowndx)->bnd *= scalar;
  }
#line 820
  if (scalar < (double )0) {
#line 821
    if ((int )do_conbnds == 1) {
#line 822
      tmpbnd = *(consys->cub + rowndx);
#line 823
      *(consys->cub + rowndx) = *(consys->clb + rowndx);
#line 824
      *(consys->clb + rowndx) = tmpbnd;
    }
    {
#line 826
    if ((unsigned int )*(consys->ctyp + rowndx) == 4U) {
#line 826
      goto case_4;
    }
#line 829
    if ((unsigned int )*(consys->ctyp + rowndx) == 2U) {
#line 829
      goto case_2;
    }
#line 832
    if ((unsigned int )*(consys->ctyp + rowndx) == 5U) {
#line 832
      goto case_5;
    }
#line 838
    if ((unsigned int )*(consys->ctyp + rowndx) == 1U) {
#line 838
      goto case_1;
    }
#line 838
    if ((unsigned int )*(consys->ctyp + rowndx) == 3U) {
#line 838
      goto case_1;
    }
#line 840
    goto switch_default;
    case_4: /* CIL Label */ 
#line 827
    *(consys->ctyp + rowndx) = (contyp_enum )2;
#line 828
    goto switch_break;
    case_2: /* CIL Label */ 
#line 830
    *(consys->ctyp + rowndx) = (contyp_enum )4;
#line 831
    goto switch_break;
    case_5: /* CIL Label */ 
#line 833
    tmprhs = *(consys->rhs + rowndx);
#line 834
    *(consys->rhs + rowndx) = *(consys->rhslow + rowndx);
#line 835
    *(consys->rhslow + rowndx) = tmprhs;
#line 836
    goto switch_break;
    case_1: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 839
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 841
    errmsg(1, rtnnme, 841);
    }
#line 842
    return ((bool )0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 844
  return ((bool )1);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
bool consys_divrow(consys_struct *consys , int rowndx , double scalar ) 
{ 
  double tmprhs ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  conbnd_struct tmpbnd ;
  bool do_conbnds ;
  char const   *rtnnme ;

  {
#line 880
  rtnnme = "consys_divrow";
#line 894
  if (rowndx <= 0) {
    {
#line 895
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 896
    return ((bool )0);
  } else
#line 894
  if (rowndx > consys->concnt) {
    {
#line 895
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 896
    return ((bool )0);
  }
#line 899
  rowhdr = *(consys->mtx.rows + rowndx);
#line 912
  if ((unsigned long )consys->cub != (unsigned long )((void *)0)) {
#line 912
    if ((unsigned long )consys->clb != (unsigned long )((void *)0)) {
#line 913
      do_conbnds = (bool )1;
    } else {
#line 915
      do_conbnds = (bool )0;
    }
  } else {
#line 915
    do_conbnds = (bool )0;
  }
#line 919
  coeff = rowhdr->coeffs;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 919
      goto while_break;
    }
#line 935
    coeff->val /= scalar;
#line 919
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 939
  if ((unsigned long )consys->rhs != (unsigned long )((void *)0)) {
#line 939
    *(consys->rhs + rowndx) /= scalar;
  }
#line 940
  if ((unsigned long )consys->rhslow != (unsigned long )((void *)0)) {
#line 940
    *(consys->rhslow + rowndx) /= scalar;
  }
#line 941
  if ((int )do_conbnds == 1) {
#line 942
    (consys->cub + rowndx)->bnd /= scalar;
#line 943
    (consys->clb + rowndx)->bnd /= scalar;
  }
#line 948
  if (scalar < (double )0) {
#line 949
    if ((int )do_conbnds == 1) {
#line 950
      tmpbnd = *(consys->cub + rowndx);
#line 951
      *(consys->cub + rowndx) = *(consys->clb + rowndx);
#line 952
      *(consys->clb + rowndx) = tmpbnd;
    }
    {
#line 954
    if ((unsigned int )*(consys->ctyp + rowndx) == 4U) {
#line 954
      goto case_4;
    }
#line 957
    if ((unsigned int )*(consys->ctyp + rowndx) == 2U) {
#line 957
      goto case_2;
    }
#line 960
    if ((unsigned int )*(consys->ctyp + rowndx) == 5U) {
#line 960
      goto case_5;
    }
#line 966
    if ((unsigned int )*(consys->ctyp + rowndx) == 1U) {
#line 966
      goto case_1;
    }
#line 966
    if ((unsigned int )*(consys->ctyp + rowndx) == 3U) {
#line 966
      goto case_1;
    }
#line 968
    goto switch_default;
    case_4: /* CIL Label */ 
#line 955
    *(consys->ctyp + rowndx) = (contyp_enum )2;
#line 956
    goto switch_break;
    case_2: /* CIL Label */ 
#line 958
    *(consys->ctyp + rowndx) = (contyp_enum )4;
#line 959
    goto switch_break;
    case_5: /* CIL Label */ 
#line 961
    tmprhs = *(consys->rhs + rowndx);
#line 962
    *(consys->rhs + rowndx) = *(consys->rhslow + rowndx);
#line 963
    *(consys->rhslow + rowndx) = tmprhs;
#line 964
    goto switch_break;
    case_1: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 967
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 969
    errmsg(1, rtnnme, 969);
    }
#line 970
    return ((bool )0);
    switch_break: /* CIL Label */ ;
    }
  }
#line 972
  return ((bool )1);
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
int consys_gcdrow(consys_struct *consys , int rowndx ) 
{ 
  double gcd ;
  double a1 ;
  double a2 ;
  double q ;
  double r ;
  rowhdr_struct *rowhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 1012
  rtnnme = "consys_gcdrow";
#line 1027
  if (rowndx <= 0) {
    {
#line 1028
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 1029
    return (-1);
  } else
#line 1027
  if (rowndx > consys->concnt) {
    {
#line 1028
    errmsg(102, rtnnme, consys->nme, "row", rowndx, 1, consys->concnt);
    }
#line 1029
    return (-1);
  }
#line 1031
  rowhdr = *(consys->mtx.rows + rowndx);
#line 1043
  if (rowhdr->len == 0) {
#line 1043
    return (1);
  }
#line 1044
  coeff = rowhdr->coeffs;
#line 1062
  a1 = coeff->val;
#line 1063
  if (a1 < (double )0) {
#line 1063
    a1 = - a1;
  }
  {
#line 1064
  tmp = floor(a1);
  }
#line 1064
  if (tmp != a1) {
#line 1064
    return (0);
  }
#line 1065
  if (rowhdr->len == 1) {
#line 1065
    return ((int )a1);
  }
#line 1072
  gcd = a1;
#line 1073
  coeff = coeff->rownxt;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (gcd > (double )1) {
#line 1073
      if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 1073
        goto while_break;
      }
    } else {
#line 1073
      goto while_break;
    }
#line 1089
    a1 = coeff->val;
#line 1090
    if (a1 < (double )0) {
#line 1090
      a1 = - a1;
    }
    {
#line 1091
    tmp___0 = floor(a1);
    }
#line 1091
    if (tmp___0 != a1) {
#line 1091
      return (0);
    }
#line 1092
    if (a1 > gcd) {
      {
#line 1093
      tmp___1 = floor(a1 / gcd);
      }
#line 1093
      if (tmp___1 == a1 / gcd) {
#line 1093
        goto __Cont;
      }
#line 1094
      a2 = gcd;
    } else {
#line 1096
      a2 = a1;
#line 1097
      a1 = gcd;
    }
    {
#line 1101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1101
      if (a1 > (double )0) {
#line 1101
        if (! (a2 > (double )0)) {
#line 1101
          goto while_break___0;
        }
      } else {
#line 1101
        goto while_break___0;
      }
      {
#line 1102
      q = floor(a1 / a2);
#line 1103
      r = a1 - q * a2;
#line 1104
      a1 = a2;
#line 1105
      a2 = r;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1106
    gcd = a1;
    __Cont: /* CIL Label */ 
#line 1073
    coeff = coeff->rownxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 1108
  return ((int )gcd);
}
}
#line 1112 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
bool consys_accumcol(consys_struct *consys , int colndx , double *vec ) 
{ 
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 1130
  rtnnme = "consys_accumcol";
#line 1142
  if (colndx <= 0) {
    {
#line 1143
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 1144
    return ((bool )0);
  } else
#line 1142
  if (colndx > consys->varcnt) {
    {
#line 1143
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 1144
    return ((bool )0);
  }
#line 1146
  colhdr = *(consys->mtx.cols + colndx);
#line 1159
  coeff = colhdr->coeffs;
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1159
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 1159
      goto while_break;
    }
#line 1175
    *(vec + (coeff->rowhdr)->ndx) += coeff->val;
#line 1159
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 1177
  return ((bool )1);
}
}
#line 1181 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_consys_mathutils.c"
bool consys_mulaccumcol(consys_struct *consys , int colndx , double scalar , double *vec ) 
{ 
  colhdr_struct *colhdr ;
  coeff_struct *coeff ;
  char const   *rtnnme ;

  {
#line 1202
  rtnnme = "consys_accumcol";
#line 1214
  if (colndx <= 0) {
    {
#line 1215
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 1216
    return ((bool )0);
  } else
#line 1214
  if (colndx > consys->varcnt) {
    {
#line 1215
    errmsg(102, rtnnme, consys->nme, "column", colndx, 1, consys->varcnt);
    }
#line 1216
    return ((bool )0);
  }
#line 1218
  colhdr = *(consys->mtx.cols + colndx);
#line 1231
  coeff = colhdr->coeffs;
  {
#line 1231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1231
    if (! ((unsigned long )coeff != (unsigned long )((void *)0))) {
#line 1231
      goto while_break;
    }
#line 1247
    *(vec + (coeff->rowhdr)->ndx) += scalar * coeff->val;
#line 1231
    coeff = coeff->colnxt;
  }
  while_break: /* CIL Label */ ;
  }
#line 1249
  return ((bool )1);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dual.c"
static dyret_enum preoptimality___0(dyret_enum lpretval , flags *result ) 
{ 
  flags checkflags ;
  dyret_enum retval ;
  char const   *rtnnme ;
  bool tmp ;
  dyret_enum tmp___0 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 171
  rtnnme = "preoptimality";
#line 181
  if (dy_opts->print.dual >= 4) {
    {
#line 182
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: validating optimality at iteration %d.",
                rtnnme, dy_lp->tot.iters);
    }
  }
#line 193
  *result = (flags )0;
#line 194
  checkflags = (flags )0;
#line 195
  checkflags |= (unsigned int )(((((((1 << 8) | (1 << 1)) | 1) | (1 << 2)) | (1 << 4)) | (1 << 3)) | (1 << 5));
#line 197
  if ((int )lpretval == 7) {
#line 197
    if (dy_lp->basis.etas == 0) {
#line 198
      checkflags &= (unsigned int )(~ (1 << 8));
    }
  }
#line 205
  if (dy_opts->print.dual >= 4) {
    {
#line 206
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tclearing pivot rejection machinery ... ");
    }
  }
  {
#line 209
  tmp = dy_clrpivrej((int *)((void *)0));
  }
#line 209
  if ((int )tmp != 1) {
#line 209
    return ((dyret_enum )-10);
  }
#line 210
  if (dy_lp->degen > 0) {
    {
#line 211
    tmp___0 = dy_dualdegenout(0);
    }
#line 211
    if ((int )tmp___0 == 4) {
#line 211
      checkflags |= (unsigned int )(1 << 8);
    }
  }
#line 216
  if (dy_opts->print.dual >= 4) {
#line 217
    if (checkflags & (unsigned int )(1 << 8)) {
#line 217
      tmp___3 = 1;
    } else {
#line 217
      tmp___3 = 0;
    }
#line 217
    if (tmp___3) {
#line 217
      tmp___2 = "refactoring and ";
    } else {
#line 217
      tmp___2 = "";
    }
    {
#line 217
    dyio_outfmt(dy_logchn, dy_gtxecho, "done.\n\t%schecking accuracy ... ", tmp___2);
    }
  }
  {
#line 220
  retval = dy_accchk(& checkflags);
#line 221
  *result = checkflags;
  }
#line 222
  if ((int )retval == 1) {
#line 222
    goto _L;
  } else
#line 222
  if ((int )retval == 2) {
    _L: /* CIL Label */ 
#line 231
    if (checkflags & (unsigned int )((1 << 1) | (1 << 4))) {
#line 231
      tmp___14 = 1;
    } else {
#line 231
      tmp___14 = 0;
    }
#line 231
    if (tmp___14) {
#line 234
      if (dy_opts->print.dual >= 4) {
#line 235
        if (dy_opts->print.dual >= 5) {
#line 235
          tmp___5 = "\n\t";
        } else {
#line 235
          tmp___5 = " ";
        }
        {
#line 235
        dyio_outfmt(dy_logchn, dy_gtxecho, "%sfailed", tmp___5);
        }
#line 237
        if (checkflags & (unsigned int )(1 << 1)) {
#line 237
          tmp___6 = 1;
        } else {
#line 237
          tmp___6 = 0;
        }
#line 237
        if (tmp___6) {
          {
#line 238
          dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
          }
        }
#line 239
        if (checkflags & (unsigned int )(1 << 4)) {
#line 239
          tmp___7 = 1;
        } else {
#line 239
          tmp___7 = 0;
        }
#line 239
        if (tmp___7) {
          {
#line 240
          dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
          }
        }
        {
#line 241
        dyio_outfmt(dy_logchn, dy_gtxecho, " check(s).");
        }
      }
#line 243
      retval = (dyret_enum )5;
    } else {
#line 245
      if (checkflags & (unsigned int )(1 | (1 << 3))) {
#line 245
        tmp___13 = 1;
      } else {
#line 245
        tmp___13 = 0;
      }
#line 245
      if (tmp___13) {
#line 248
        if (dy_opts->print.dual >= 4) {
          {
#line 249
          dyio_outfmt(dy_logchn, dy_gtxecho, "lost");
          }
#line 250
          if (checkflags & 1U) {
#line 250
            tmp___8 = 1;
          } else {
#line 250
            tmp___8 = 0;
          }
#line 250
          if (tmp___8) {
            {
#line 251
            dyio_outfmt(dy_logchn, dy_gtxecho, " primal");
            }
          }
#line 252
          if (checkflags & (unsigned int )(1 << 3)) {
#line 252
            tmp___9 = 1;
          } else {
#line 252
            tmp___9 = 0;
          }
#line 252
          if (tmp___9) {
            {
#line 253
            dyio_outfmt(dy_logchn, dy_gtxecho, " dual");
            }
          }
          {
#line 254
          dyio_outfmt(dy_logchn, dy_gtxecho, " feasibility.");
          }
        }
#line 256
        if (checkflags & (unsigned int )(1 << 3)) {
#line 256
          tmp___10 = 1;
        } else {
#line 256
          tmp___10 = 0;
        }
#line 256
        if (tmp___10) {
#line 257
          retval = (dyret_enum )-3;
        } else {
#line 259
          retval = (dyret_enum )-4;
        }
      } else
#line 262
      if (dy_opts->print.dual >= 4) {
#line 263
        if ((int )retval == 1) {
#line 263
          tmp___11 = "done";
        } else {
#line 263
          tmp___11 = "patched";
        }
#line 263
        if (dy_opts->print.dual >= 5) {
#line 263
          tmp___12 = "\n\t";
        } else {
#line 263
          tmp___12 = " ";
        }
        {
#line 263
        dyio_outfmt(dy_logchn, dy_gtxecho, "%s%s.", tmp___12, tmp___11);
        }
      }
    }
  } else {
#line 225
    if (dy_opts->print.dual >= 4) {
#line 226
      if (dy_opts->print.dual >= 5) {
#line 226
        tmp___4 = "\n\t";
      } else {
#line 226
        tmp___4 = " ";
      }
      {
#line 226
      dyio_outfmt(dy_logchn, dy_gtxecho, "%sfailed.", tmp___4);
      }
    }
#line 229
    return (retval);
  }
#line 268
  return (retval);
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dual.c"
static dyret_enum dual2(void) 
{ 
  int candxi ;
  int xindx ;
  int outdir ;
  int xjndx ;
  int indir ;
  int optcnt ;
  double cbarj ;
  double abarij ;
  double delta ;
  flags xistatus ;
  flags checks ;
  bool do_pivots ;
  dyret_enum lpretval ;
  dyret_enum outresult ;
  dyret_enum pivresult ;
  dyret_enum duennaresult ;
  dyret_enum preopresult ;
  int successiveDinf ;
  char const   *rtnnme ;
  int xipos ;
  bool uxpfeas ;
  bool uxnpfeas ;
  bool uxndfeas ;
  dyret_enum tmpretval ;
  bool tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  bool tmp___15 ;

  {
  {
#line 313
  successiveDinf = 40;
#line 315
  rtnnme = "dual2";
#line 332
  dy_lp->d2.pivs = 0;
#line 333
  dy_lp->pivok = (bool )0;
#line 334
  dy_lp->prev_pivok = (bool )0;
#line 335
  lpretval = (dyret_enum )0;
#line 336
  dy_lp->basis.dinf = 0;
#line 344
  tmp = dy_clrpivrej((int *)((void *)0));
  }
#line 344
  if ((int )tmp != 1) {
#line 344
    return ((dyret_enum )-10);
  }
#line 345
  optcnt = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! ((int )lpretval == 0)) {
#line 346
      goto while_break;
    }
    {
#line 357
    outresult = dy_dualout(& candxi);
    }
    {
#line 359
    if ((int )outresult == 1) {
#line 359
      goto case_1;
    }
#line 362
    if ((int )outresult == 6) {
#line 362
      goto case_6;
    }
#line 370
    goto switch_default;
    case_1: /* CIL Label */ 
#line 360
    do_pivots = (bool )1;
#line 361
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 363
    outresult = dy_dealWithPunt();
    }
#line 364
    if ((int )outresult == 3) {
#line 365
      goto while_continue;
    } else {
#line 367
      do_pivots = (bool )0;
#line 368
      lpretval = outresult;
    }
#line 369
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 371
    do_pivots = (bool )0;
#line 372
    lpretval = outresult;
#line 373
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 397
    xindx = candxi;
    {
#line 397
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 397
      if (! ((int )do_pivots == 1)) {
#line 397
        goto while_break___0;
      }
#line 409
      xistatus = *(dy_status + xindx);
#line 410
      if (xistatus & (unsigned int )(1 << 11)) {
#line 410
        tmp___0 = 1;
      } else {
#line 410
        tmp___0 = 0;
      }
#line 410
      if (tmp___0) {
#line 411
        outdir = 1;
      } else {
#line 413
        outdir = -1;
      }
#line 415
      if (dy_opts->print.pricing >= 2) {
        {
#line 416
        xipos = *(dy_var2basis + xindx);
#line 417
        tmp___1 = consys_nme(dy_sys, (char )'v', xindx, (bool )1, (char *)((void *)0));
#line 417
        tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 417
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: %s (%d) = %g, ", tmp___2,
                    dy_lp->tot.iters, tmp___1, xindx, *(dy_xbasic + xipos));
        }
#line 421
        if (outdir < 0) {
          {
#line 422
          tmp___3 = sqrt(*(dy_rho + xipos));
#line 422
          dyio_outfmt(dy_logchn, dy_gtxecho, "decreasing and leaving at ub = %g, price = %g.",
                      *(dy_sys->vub + xindx), (*(dy_xbasic + xipos) - *(dy_sys->vub + xindx)) / tmp___3);
          }
        } else {
          {
#line 427
          tmp___4 = sqrt(*(dy_rho + xipos));
#line 427
          dyio_outfmt(dy_logchn, dy_gtxecho, "increasing and leaving at lb = %g, price = %g.",
                      *(dy_sys->vlb + xindx), (*(dy_sys->vlb + xindx) - *(dy_xbasic + xipos)) / tmp___4);
          }
        }
      }
      {
#line 445
      xjndx = -1;
#line 446
      pivresult = dy_dualpivot(xindx, outdir, & xjndx, & indir, & cbarj, & abarij,
                               & delta, & candxi);
      }
#line 449
      if (dy_opts->print.dual >= 4) {
        {
#line 450
        dy_logpivot(pivresult, xjndx, indir, cbarj, xindx, outdir, abarij, delta);
        }
      }
      {
#line 490
      duennaresult = dy_duenna(pivresult, xjndx, xindx, -1, candxi);
      }
      {
#line 492
      if ((int )duennaresult == 1) {
#line 492
        goto case_1___0;
      }
#line 495
      if ((int )duennaresult == 3) {
#line 495
        goto case_3;
      }
#line 499
      if ((int )duennaresult == 6) {
#line 499
        goto case_6___0;
      }
#line 499
      if ((int )duennaresult == 7) {
#line 499
        goto case_6___0;
      }
#line 503
      if ((int )duennaresult == 8) {
#line 503
        goto case_8;
      }
#line 509
      if ((int )duennaresult == 9) {
#line 509
        goto case_9;
      }
#line 517
      if ((int )duennaresult == -3) {
#line 517
        goto case_neg_3;
      }
#line 547
      if ((int )duennaresult == -10) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == -5) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == -9) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == -8) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == -7) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == -6) {
#line 547
        goto case_neg_10;
      }
#line 547
      if ((int )duennaresult == 5) {
#line 547
        goto case_neg_10;
      }
#line 551
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
#line 493
      if (candxi <= 0) {
#line 493
        do_pivots = (bool )0;
      }
#line 494
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 496
      do_pivots = (bool )0;
#line 497
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      case_7: /* CIL Label */ 
#line 500
      lpretval = duennaresult;
#line 501
      do_pivots = (bool )0;
#line 502
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 504
      lpretval = (dyret_enum )8;
#line 505
      dy_lp->ubnd.ndx = xindx * outdir;
#line 506
      dy_lp->ubnd.ratio = (double )0;
#line 507
      do_pivots = (bool )0;
#line 508
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 510
      if (dy_lp->basis.pivs >= 10) {
#line 511
        lpretval = duennaresult;
#line 512
        do_pivots = (bool )0;
      } else
#line 514
      if (candxi <= 0) {
#line 515
        do_pivots = (bool )0;
      }
#line 516
      goto switch_break___0;
      case_neg_3: /* CIL Label */ 
#line 520
      if (dy_opts->print.dual >= 3) {
#line 520
        if (dy_lp->basis.dinf < successiveDinf) {
          {
#line 522
          tmp___5 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 522
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n(%s)%d: dual infeasible for %d successive refactors.",
                      tmp___5, dy_lp->tot.iters, dy_lp->basis.dinf);
          }
        }
      }
#line 526
      if (dy_opts->print.dual >= 1) {
#line 526
        if (dy_lp->basis.dinf >= successiveDinf) {
          {
#line 528
          tmp___6 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 528
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: dual infeasibility for %d successive",
                      tmp___6, dy_lp->tot.iters, successiveDinf);
#line 532
          dyio_outfmt(dy_logchn, dy_gtxecho, " refactors; aborting.");
          }
        }
      }
#line 534
      if (dy_lp->basis.dinf >= successiveDinf) {
#line 535
        lpretval = duennaresult;
#line 536
        do_pivots = (bool )0;
      } else
#line 538
      if (candxi <= 0) {
#line 539
        do_pivots = (bool )0;
      }
#line 540
      goto switch_break___0;
      case_neg_10: /* CIL Label */ 
      case_neg_5: /* CIL Label */ 
      case_neg_9: /* CIL Label */ 
      case_neg_8: /* CIL Label */ 
      case_neg_7: /* CIL Label */ 
      case_neg_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 548
      lpretval = duennaresult;
#line 549
      do_pivots = (bool )0;
#line 550
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 552
      errmsg(7, rtnnme, 552, "La Duenna return code", (int )duennaresult);
#line 554
      do_pivots = (bool )0;
#line 555
      lpretval = (dyret_enum )-10;
      }
#line 556
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 397
      xindx = candxi;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    if ((int )lpretval == 0) {
#line 562
      goto while_continue;
    }
#line 586
    if ((int )lpretval == 7) {
#line 586
      goto _L;
    } else
#line 586
    if ((int )lpretval == 8) {
#line 586
      goto _L;
    } else
#line 586
    if ((int )lpretval == 6) {
      _L: /* CIL Label */ 
      {
#line 588
      optcnt ++;
#line 590
      uxpfeas = (bool )0;
#line 591
      uxnpfeas = (bool )0;
#line 592
      uxndfeas = (bool )0;
#line 593
      tmpretval = lpretval;
#line 595
      preopresult = preoptimality___0(lpretval, & checks);
      }
      {
#line 598
      if ((int )preopresult == 2) {
#line 598
        goto case_2;
      }
#line 598
      if ((int )preopresult == 1) {
#line 598
        goto case_2;
      }
#line 605
      if ((int )preopresult == -3) {
#line 605
        goto case_neg_3___0;
      }
#line 620
      if ((int )preopresult == -4) {
#line 620
        goto case_neg_4;
      }
#line 632
      goto switch_default___1;
      case_2: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 601
      if ((int )lpretval == 8) {
#line 601
        uxpfeas = (bool )1;
      } else
#line 601
      if ((int )lpretval == 6) {
#line 601
        uxpfeas = (bool )1;
      }
#line 603
      lpretval = (dyret_enum )7;
#line 604
      goto switch_break___1;
      case_neg_3___0: /* CIL Label */ 
#line 608
      if (dy_opts->print.dual >= 1) {
        {
#line 609
        tmp___7 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 609
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: lost dual feasibility.", tmp___7,
                    dy_lp->tot.iters);
        }
      }
#line 612
      uxndfeas = (bool )1;
#line 613
      if (checks & 1U) {
#line 613
        tmp___8 = 1;
      } else {
#line 613
        tmp___8 = 0;
      }
#line 613
      if (tmp___8) {
#line 614
        if ((int )lpretval == 7) {
#line 614
          uxnpfeas = (bool )1;
        }
      } else
#line 616
      if ((int )lpretval != 7) {
#line 616
        uxpfeas = (bool )1;
      }
#line 618
      lpretval = (dyret_enum )-3;
#line 619
      goto switch_break___1;
      case_neg_4: /* CIL Label */ 
#line 621
      if (! ((int )lpretval == 8)) {
#line 621
        if (! ((int )lpretval == 6)) {
#line 624
          if ((int )lpretval == 7) {
            {
#line 625
            lpretval = (dyret_enum )0;
#line 626
            dy_setpivparms(1, 1);
#line 628
            uxnpfeas = (bool )1;
            }
          }
        }
      }
#line 631
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 633
      lpretval = preopresult;
#line 634
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 645
      if (dy_opts->print.dual >= 2) {
#line 646
        if ((int )uxndfeas == 1) {
          {
#line 647
          tmp___9 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 647
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of dual feasibility at iteration (%s)%d.",
                      tmp___9, dy_lp->tot.iters);
          }
        }
#line 650
        if ((int )uxpfeas == 1) {
          {
#line 651
          tmp___10 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 651
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected primal feasibility at iteration (%s)%d.",
                      tmp___10, dy_lp->tot.iters);
          }
        }
#line 654
        if ((int )uxnpfeas == 1) {
          {
#line 655
          tmp___11 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 655
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tunexpected loss of primal feasibility at iteration (%s)%d.",
                      tmp___11, dy_lp->tot.iters);
          }
        }
      }
#line 660
      if ((int )lpretval == 0) {
#line 661
        if (optcnt > 15) {
          {
#line 662
          tmp___12 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 662
          errmsg(387, rtnnme, dy_sys->nme, tmp___12, dy_lp->tot.iters, optcnt);
#line 664
          lpretval = (dyret_enum )-10;
          }
        } else
#line 667
        if (dy_opts->print.dual >= 2) {
          {
#line 668
          tmp___13 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 668
          tmp___14 = dy_prtdyret(tmpretval);
#line 668
          dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tfalse termination (%s) at (%s)%d; resuming pivoting.",
                      tmp___14, tmp___13, dy_lp->tot.iters);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  tmp___15 = dy_clrpivrej((int *)((void *)0));
  }
#line 677
  if ((int )tmp___15 != 1) {
#line 677
    lpretval = (dyret_enum )-10;
  }
#line 678
  if (dy_lp->degen > 0) {
    {
#line 678
    dy_dualdegenout(0);
    }
  }
#line 681
  if ((int )lpretval == 8) {
#line 681
    if (dy_opts->print.dual >= 2) {
      {
#line 682
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: system %s is (dual) unbounded.", rtnnme,
                  dy_sys->nme);
      }
    }
  }
#line 691
  return (lpretval);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_dual.c"
lpret_enum dy_dual(void) 
{ 
  lpret_enum retval ;
  dyret_enum dyret ;
  char const   *rtnnme ;
  double tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  double dualobj ;
  double primalobj ;
  double tmp___5 ;

  {
  {
#line 713
  rtnnme = "dy_dual";
#line 716
  retval = (lpret_enum )0;
#line 717
  dy_lp->phase = (dyphase_enum )4;
#line 718
  dy_lp->lpret = (lpret_enum )0;
#line 719
  dy_setpivparms(-100, -100);
#line 720
  dy_setpivparms(1, 1);
#line 721
  dy_lp->basis.pivs = 0;
#line 728
  dy_lp->z = dy_calcobj();
  }
#line 730
  if (dy_opts->print.dual >= 2) {
    {
#line 731
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: entering dual phase II, z = %g", rtnnme,
                dy_lp->z);
    }
#line 733
    if (dy_opts->print.dual >= 4) {
      {
#line 734
      tmp = dy_calcdualobj();
#line 734
      dyio_outfmt(dy_logchn, dy_gtxecho, ", dual active yb = %g", tmp);
      }
    }
    {
#line 736
    dyio_outchr(dy_logchn, dy_gtxecho, (char )'.');
    }
  }
  {
#line 739
  dy_lp->d2.iters = 0;
#line 740
  dyret = dual2();
  }
#line 741
  if ((int )dyret == 8) {
#line 741
    dyret = (dyret_enum )10;
  }
  {
#line 747
  retval = dyret2lpret(dyret);
  }
#line 750
  if ((int )retval == 1) {
#line 750
    goto _L;
  } else
#line 750
  if ((int )retval == 4) {
#line 750
    goto _L;
  } else
#line 750
  if ((int )retval == 3) {
    _L: /* CIL Label */ 
#line 751
    if (dy_opts->print.dual >= 2) {
      {
#line 752
      tmp___0 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 752
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n    (%s)%d: dual phase II ended, %d pivots, ",
                  tmp___0, dy_lp->tot.iters, dy_lp->d2.pivs);
      }
#line 756
      if ((int )retval == 1) {
        {
#line 757
        dyio_outfmt(dy_logchn, dy_gtxecho, "optimal z = %g.", dy_lp->z);
        }
      } else
#line 759
      if ((int )retval == 4) {
        {
#line 760
        dyio_outfmt(dy_logchn, dy_gtxecho, "infeas = %g.", dy_lp->infeas);
        }
      } else {
        {
#line 762
        tmp___1 = consys_nme(dy_sys, (char )'v', dy_lp->ubnd.ndx, (bool )0, (char *)((void *)0));
#line 762
        dyio_outfmt(dy_logchn, dy_gtxecho, "swing %e for %s (%d).", dy_lp->ubnd.ratio,
                    tmp___1, dy_lp->ubnd.ndx);
        }
      }
    }
  } else
#line 767
  if ((int )retval == 7) {
#line 768
    if (dy_opts->print.dual >= 1) {
      {
#line 769
      tmp___2 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 769
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: dual simplex terminated; iteration limit (%d).",
                  tmp___2, dy_lp->tot.iters, dy_opts->iterlim);
      }
    }
  } else
#line 774
  if (dy_opts->print.dual >= 1) {
    {
#line 775
    tmp___3 = dy_prtlpret(retval);
#line 775
    tmp___4 = dy_prtlpphase(dy_lp->phase, (bool )1);
#line 775
    dyio_outfmt(dy_logchn, dy_gtxecho, "\n  (%s)%d: dual phase II failed, status %s after %d pivots.",
                tmp___4, dy_lp->tot.iters, tmp___3, dy_lp->d2.pivs);
    }
  }
#line 783
  if (dy_opts->print.dual >= 4) {
#line 783
    if ((int )retval == 1) {
      {
#line 786
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n%s: comparing dual and primal objectives.",
                  rtnnme);
#line 788
      dualobj = dy_calcdualobj();
#line 789
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tdual objective yb = %g.", dualobj);
#line 791
      primalobj = dy_calcobj();
#line 792
      dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tprimal objective cx = %g.", primalobj);
#line 795
      tmp___5 = fabs(dualobj - primalobj);
      }
#line 795
      if (tmp___5 <= dy_tols->dchk) {
        {
#line 800
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tobjectives match.");
        }
      } else {
        {
#line 796
        dyio_outfmt(dy_logchn, dy_gtxecho, "\n\tWHOOPS! yb - cx = %g - %g = %g > %g.",
                    dualobj, primalobj, dualobj - primalobj, dy_tols->dchk);
        }
      }
    }
  }
#line 803
  dy_lp->lpret = retval;
#line 805
  return (retval);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_vector.h"
static fpunion_t Infbits___0  __attribute__((__unused__))  =    {{(unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\000',
     (unsigned char )'\000', (unsigned char )'\000', (unsigned char )'\360', (unsigned char )'\177'}};
#line 1850 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dylp.h"
void dy_defaults(lpopts_struct **opts , lptols_struct **tols ) ;
#line 1850
void dy_checkdefaults(consys_struct *sys , lpopts_struct *opts , lptols_struct *tols ) ;
#line 1850
void dy_setprintopts(int lvl , lpopts_struct *opts ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
static lpopts_struct dyopts_dflt  = 
#line 72 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
     {(cxtype_enum )2, -1, -1, -1, {-1, (bool )1, (bool )0}, {1}, 50, -1, 1, {1, 0,
                                                                            0}, 0,
    3, 5000, (bool )0, (bool )0, (bool )1, (bool )1, 1, 1, (bool )1, (bool )0, (bool )0,
    2, {(float ).25, (float ).25}, {.5, (bool )1, (double )90, (bool )0, (double )180,
                                    (bool )1, (bool )0, (double )0, (bool )1, (double )90},
    (ibtype_enum )1, {(bool )1, (bool )1}, {(bool )0, (bool )0, (bool )0}, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            1, 1,
                                                                            1, 1,
                                                                            0, 0,
                                                                            1, 0,
                                                                            0, 0}};
#line 139 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
static lpopts_struct dyopts_lb  = 
#line 139
     {(cxtype_enum )1, 200, 0, 0, {0, (bool )0, (bool )0}, {0}, 1, 1, 0, {0, 0, 0},
    0, 0, 0, (bool )0, (bool )0, (bool )0, (bool )0, 0, 0, (bool )0, (bool )0, (bool )0,
    0, {(float )0.0, (float )0.0}, {0.0, (bool )0, (double )0, (bool )0, (double )0,
                                    (bool )0, (bool )0, (double )0, (bool )0, (double )0},
    (ibtype_enum )1, {(bool )0, (bool )0}, {(bool )0, (bool )0, (bool )0}, {0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0,
                                                                            0, 0}};
#line 213 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
static lpopts_struct dyopts_ub  = 
#line 213
     {(cxtype_enum )3, 1000, (int )((1U << (sizeof(dyopts_ub.iterlim) * 8UL - 3UL)) - 1U),
    (int )((1U << (sizeof(dyopts_ub.iterlim) * 8UL - 3UL)) - 1U), {3, (bool )1, (bool )1},
    {1}, 100, -1, 2, {1, -1, 2}, -1, 3, 100000, (bool )1, (bool )1, (bool )1, (bool )1,
    -1, 5, (bool )1, (bool )1, (bool )1, 2, {(float )1.0, (float )1.0}, {1.0, (bool )1,
                                                                         (double )180,
                                                                         (bool )1,
                                                                         (double )180,
                                                                         (bool )1,
                                                                         (bool )1,
                                                                         (double )180,
                                                                         (bool )1,
                                                                         (double )180},
    (ibtype_enum )3, {(bool )1, (bool )1}, {(bool )1, (bool )1, (bool )1}, {1, 2,
                                                                            5, 4,
                                                                            3, 5,
                                                                            2, 5,
                                                                            7, 7,
                                                                            7, 5,
                                                                            5, 4,
                                                                            3, 6,
                                                                            4, 4}};
#line 342 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
static lptols_struct dytols_dflt  = 
#line 342
     {(double )0, 1.0e-11, 1.0e-5, (double )-1, (double )100, 1.0e-11, 1.0e-4, (double )-1,
    (double )100, 1.0e-5, (double )1, 1.0e15, 1.0e30, 1.0e-4, .5, .1};
#line 362 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
void dy_exposeOptDefaults(lpopts_struct **opts_lb , lpopts_struct **opts_dflt , lpopts_struct **opts_ub ) 
{ 


  {
#line 371
  if ((unsigned long )opts_lb != (unsigned long )((void *)0)) {
#line 371
    *opts_lb = & dyopts_lb;
  }
#line 372
  if ((unsigned long )opts_dflt != (unsigned long )((void *)0)) {
#line 372
    *opts_dflt = & dyopts_dflt;
  }
#line 373
  if ((unsigned long )opts_ub != (unsigned long )((void *)0)) {
#line 373
    *opts_ub = & dyopts_ub;
  }
#line 373
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
void dy_exposeTolDefaults(lptols_struct **tols_dflt ) 
{ 


  {
#line 382
  if ((unsigned long )tols_dflt != (unsigned long )((void *)0)) {
#line 382
    *tols_dflt = & dytols_dflt;
  }
#line 382
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
void dy_defaults(lpopts_struct **opts , lptols_struct **tols ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 415
  if ((unsigned long )*opts == (unsigned long )((void *)0)) {
    {
#line 416
    tmp = malloc(sizeof(lpopts_struct ));
#line 416
    *opts = (lpopts_struct *)tmp;
    }
  }
  {
#line 417
  memcpy((void */* __restrict  */)*opts, (void const   */* __restrict  */)(& dyopts_dflt),
         sizeof(lpopts_struct ));
  }
#line 419
  if ((unsigned long )*tols == (unsigned long )((void *)0)) {
    {
#line 420
    tmp___0 = malloc(sizeof(lptols_struct ));
#line 420
    *tols = (lptols_struct *)tmp___0;
    }
  }
  {
#line 421
  memcpy((void */* __restrict  */)*tols, (void const   */* __restrict  */)(& dytols_dflt),
         sizeof(lptols_struct ));
#line 422
  (*tols)->inf = Infbits___0.fpdbl;
  }
#line 424
  return;
}
}
#line 428 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
void dy_checkdefaults(consys_struct *sys , lpopts_struct *opts , lptols_struct *tols ) 
{ 
  int scalefactor ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 448
  if (opts->check < 0) {
#line 448
    opts->check = opts->factor / 2;
  }
#line 449
  if (opts->check <= 0) {
#line 449
    opts->check = 1;
  }
#line 451
  if (opts->scan < 0) {
#line 452
    if (dyopts_lb.scan > sys->archvcnt / 2) {
#line 452
      opts->scan = dyopts_lb.scan;
    } else {
#line 452
      opts->scan = sys->archvcnt / 2;
    }
#line 453
    if (opts->scan > dyopts_ub.scan) {
#line 453
      opts->scan = dyopts_ub.scan;
    } else {
#line 453
      opts->scan = opts->scan;
    }
  }
#line 455
  if (opts->iterlim < 0) {
#line 456
    if (5 * (sys->concnt + sys->varcnt) > 100000) {
#line 456
      opts->iterlim = 100000;
    } else {
#line 456
      opts->iterlim = 5 * (sys->concnt + sys->varcnt);
    }
#line 457
    if (opts->iterlim > 10000) {
#line 457
      opts->iterlim = opts->iterlim;
    } else {
#line 457
      opts->iterlim = 10000;
    }
  }
#line 459
  if (opts->idlelim < 0) {
#line 460
    if (2 * (sys->concnt + sys->varcnt) > 50000) {
#line 460
      opts->idlelim = 50000;
    } else {
#line 460
      opts->idlelim = 2 * (sys->concnt + sys->varcnt);
    }
#line 461
    if (opts->idlelim > 1000) {
#line 461
      opts->idlelim = opts->idlelim;
    } else {
#line 461
      opts->idlelim = 1000;
    }
  }
#line 463
  if (opts->degenpivlim < 0) {
#line 464
    if (1000 > sys->concnt / 2) {
#line 464
      opts->degenpivlim = sys->concnt / 2;
    } else {
#line 464
      opts->degenpivlim = 1000;
    }
#line 465
    if (100 > opts->degenpivlim) {
#line 465
      opts->degenpivlim = 100;
    } else {
#line 465
      opts->degenpivlim = opts->degenpivlim;
    }
  }
#line 471
  if (opts->dpsel.strat >= 0) {
#line 472
    opts->dpsel.flex = (bool )0;
  } else {
#line 474
    opts->dpsel.strat = 1;
#line 475
    opts->dpsel.flex = (bool )1;
  }
#line 477
  if ((int )opts->fullsys == 1) {
#line 478
    opts->active.vars = (float )1.0;
#line 479
    opts->active.cons = (float )1.0;
  }
  {
#line 485
  tmp = log10((double )sys->varcnt);
#line 485
  scalefactor = (int )(.5 + tmp) - 2;
  }
#line 486
  if (scalefactor > 0) {
    {
#line 487
    tmp___0 = pow(10.0, (double )scalefactor);
#line 487
    tols->pchk *= tmp___0;
#line 488
    tmp___1 = pow(10.0, (double )scalefactor);
#line 488
    tols->pfeas_scale *= tmp___1;
    }
  }
  {
#line 489
  tmp___2 = log10((double )sys->concnt);
#line 489
  scalefactor = (int )(.5 + tmp___2) - 2;
  }
#line 490
  if (scalefactor > 0) {
    {
#line 491
    tmp___3 = pow(10.0, (double )scalefactor);
#line 491
    tols->dchk *= tmp___3;
#line 492
    tmp___4 = pow(10.0, (double )scalefactor);
#line 492
    tols->dfeas_scale *= tmp___4;
    }
  }
#line 506
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/coinor-dylp-1.6.0/DyLP/src/Dylp/dy_setup.c"
void dy_setprintopts(int lvl , lpopts_struct *opts ) 
{ 


  {
#line 537
  if (lvl < 0) {
#line 537
    lvl = 0;
  }
  {
#line 540
  if (lvl == 0) {
#line 540
    goto case_0;
  }
#line 560
  if (lvl == 1) {
#line 560
    goto case_1;
  }
#line 589
  if (lvl == 2) {
#line 589
    goto case_2;
  }
#line 609
  if (lvl == 3) {
#line 609
    goto case_3;
  }
#line 629
  if (lvl == 4) {
#line 629
    goto case_4;
  }
#line 649
  goto switch_default;
  case_0: /* CIL Label */ 
#line 541
  opts->print.major = 0;
#line 542
  opts->print.scaling = 0;
#line 543
  opts->print.setup = 0;
#line 544
  opts->print.crash = 0;
#line 545
  opts->print.pricing = 0;
#line 546
  opts->print.pivoting = 0;
#line 547
  opts->print.pivreject = 0;
#line 548
  opts->print.degen = 0;
#line 549
  opts->print.phase1 = 0;
#line 550
  opts->print.phase2 = 0;
#line 551
  opts->print.dual = 0;
#line 552
  opts->print.basis = 0;
#line 553
  opts->print.conmgmt = 0;
#line 554
  opts->print.varmgmt = 0;
#line 555
  opts->print.force = 0;
#line 556
  opts->print.tableau = 0;
#line 557
  opts->print.rays = 0;
#line 558
  opts->print.soln = 0;
#line 559
  goto switch_break;
  case_1: /* CIL Label */ 
#line 561
  if (opts->print.major > dyopts_dflt.print.major) {
#line 561
    opts->print.major = opts->print.major;
  } else {
#line 561
    opts->print.major = dyopts_dflt.print.major;
  }
#line 562
  if (opts->print.scaling > dyopts_dflt.print.scaling) {
#line 562
    opts->print.scaling = opts->print.scaling;
  } else {
#line 562
    opts->print.scaling = dyopts_dflt.print.scaling;
  }
#line 564
  if (opts->print.setup > dyopts_dflt.print.setup) {
#line 564
    opts->print.setup = opts->print.setup;
  } else {
#line 564
    opts->print.setup = dyopts_dflt.print.setup;
  }
#line 565
  if (opts->print.crash > dyopts_dflt.print.crash) {
#line 565
    opts->print.crash = opts->print.crash;
  } else {
#line 565
    opts->print.crash = dyopts_dflt.print.crash;
  }
#line 566
  if (opts->print.pricing > dyopts_dflt.print.pricing) {
#line 566
    opts->print.pricing = opts->print.pricing;
  } else {
#line 566
    opts->print.pricing = dyopts_dflt.print.pricing;
  }
#line 568
  if (opts->print.pivoting > dyopts_dflt.print.pivoting) {
#line 568
    opts->print.pivoting = opts->print.pivoting;
  } else {
#line 568
    opts->print.pivoting = dyopts_dflt.print.pivoting;
  }
#line 570
  if (opts->print.pivreject > dyopts_dflt.print.pivreject) {
#line 570
    opts->print.pivreject = opts->print.pivreject;
  } else {
#line 570
    opts->print.pivreject = dyopts_dflt.print.pivreject;
  }
#line 572
  if (opts->print.degen > dyopts_dflt.print.degen) {
#line 572
    opts->print.degen = opts->print.degen;
  } else {
#line 572
    opts->print.degen = dyopts_dflt.print.degen;
  }
#line 573
  if (opts->print.phase1 > dyopts_dflt.print.phase1) {
#line 573
    opts->print.phase1 = opts->print.phase1;
  } else {
#line 573
    opts->print.phase1 = dyopts_dflt.print.phase1;
  }
#line 574
  if (opts->print.phase2 > dyopts_dflt.print.phase2) {
#line 574
    opts->print.phase2 = opts->print.phase2;
  } else {
#line 574
    opts->print.phase2 = dyopts_dflt.print.phase2;
  }
#line 575
  if (opts->print.dual > dyopts_dflt.print.dual) {
#line 575
    opts->print.dual = opts->print.dual;
  } else {
#line 575
    opts->print.dual = dyopts_dflt.print.dual;
  }
#line 576
  if (opts->print.basis > dyopts_dflt.print.basis) {
#line 576
    opts->print.basis = opts->print.basis;
  } else {
#line 576
    opts->print.basis = dyopts_dflt.print.basis;
  }
#line 577
  if (opts->print.conmgmt > dyopts_dflt.print.conmgmt) {
#line 577
    opts->print.conmgmt = opts->print.conmgmt;
  } else {
#line 577
    opts->print.conmgmt = dyopts_dflt.print.conmgmt;
  }
#line 579
  if (opts->print.varmgmt > dyopts_dflt.print.varmgmt) {
#line 579
    opts->print.varmgmt = opts->print.varmgmt;
  } else {
#line 579
    opts->print.varmgmt = dyopts_dflt.print.varmgmt;
  }
#line 581
  if (opts->print.force > dyopts_dflt.print.force) {
#line 581
    opts->print.force = opts->print.force;
  } else {
#line 581
    opts->print.force = dyopts_dflt.print.force;
  }
#line 582
  if (opts->print.tableau > dyopts_dflt.print.tableau) {
#line 582
    opts->print.tableau = opts->print.tableau;
  } else {
#line 582
    opts->print.tableau = dyopts_dflt.print.tableau;
  }
#line 584
  if (opts->print.rays > dyopts_dflt.print.rays) {
#line 584
    opts->print.rays = opts->print.rays;
  } else {
#line 584
    opts->print.rays = dyopts_dflt.print.rays;
  }
#line 586
  if (opts->print.soln > dyopts_dflt.print.soln) {
#line 586
    opts->print.soln = opts->print.soln;
  } else {
#line 586
    opts->print.soln = dyopts_dflt.print.soln;
  }
#line 588
  goto switch_break;
  case_2: /* CIL Label */ 
#line 590
  if (opts->print.major > 1) {
#line 590
    opts->print.major = opts->print.major;
  } else {
#line 590
    opts->print.major = 1;
  }
#line 591
  if (opts->print.scaling > 1) {
#line 591
    opts->print.scaling = opts->print.scaling;
  } else {
#line 591
    opts->print.scaling = 1;
  }
#line 592
  if (opts->print.setup > 1) {
#line 592
    opts->print.setup = opts->print.setup;
  } else {
#line 592
    opts->print.setup = 1;
  }
#line 593
  if (opts->print.crash > 1) {
#line 593
    opts->print.crash = opts->print.crash;
  } else {
#line 593
    opts->print.crash = 1;
  }
#line 594
  if (opts->print.pricing > 0) {
#line 594
    opts->print.pricing = opts->print.pricing;
  } else {
#line 594
    opts->print.pricing = 0;
  }
#line 595
  if (opts->print.pivoting > 0) {
#line 595
    opts->print.pivoting = opts->print.pivoting;
  } else {
#line 595
    opts->print.pivoting = 0;
  }
#line 596
  if (opts->print.pivreject > 0) {
#line 596
    opts->print.pivreject = opts->print.pivreject;
  } else {
#line 596
    opts->print.pivreject = 0;
  }
#line 597
  if (opts->print.degen > 1) {
#line 597
    opts->print.degen = opts->print.degen;
  } else {
#line 597
    opts->print.degen = 1;
  }
#line 598
  if (opts->print.phase1 > 1) {
#line 598
    opts->print.phase1 = opts->print.phase1;
  } else {
#line 598
    opts->print.phase1 = 1;
  }
#line 599
  if (opts->print.phase2 > 1) {
#line 599
    opts->print.phase2 = opts->print.phase2;
  } else {
#line 599
    opts->print.phase2 = 1;
  }
#line 600
  if (opts->print.dual > 1) {
#line 600
    opts->print.dual = opts->print.dual;
  } else {
#line 600
    opts->print.dual = 1;
  }
#line 601
  if (opts->print.basis > 1) {
#line 601
    opts->print.basis = opts->print.basis;
  } else {
#line 601
    opts->print.basis = 1;
  }
#line 602
  if (opts->print.conmgmt > 1) {
#line 602
    opts->print.conmgmt = opts->print.conmgmt;
  } else {
#line 602
    opts->print.conmgmt = 1;
  }
#line 603
  if (opts->print.varmgmt > 1) {
#line 603
    opts->print.varmgmt = opts->print.varmgmt;
  } else {
#line 603
    opts->print.varmgmt = 1;
  }
#line 604
  if (opts->print.force > 1) {
#line 604
    opts->print.force = opts->print.force;
  } else {
#line 604
    opts->print.force = 1;
  }
#line 605
  if (opts->print.tableau > 1) {
#line 605
    opts->print.tableau = opts->print.tableau;
  } else {
#line 605
    opts->print.tableau = 1;
  }
#line 606
  if (opts->print.rays > 1) {
#line 606
    opts->print.rays = opts->print.rays;
  } else {
#line 606
    opts->print.rays = 1;
  }
#line 607
  if (opts->print.soln > 1) {
#line 607
    opts->print.soln = opts->print.soln;
  } else {
#line 607
    opts->print.soln = 1;
  }
#line 608
  goto switch_break;
  case_3: /* CIL Label */ 
#line 610
  if (opts->print.major > 1) {
#line 610
    opts->print.major = opts->print.major;
  } else {
#line 610
    opts->print.major = 1;
  }
#line 611
  if (opts->print.scaling > 2) {
#line 611
    opts->print.scaling = opts->print.scaling;
  } else {
#line 611
    opts->print.scaling = 2;
  }
#line 612
  if (opts->print.setup > 2) {
#line 612
    opts->print.setup = opts->print.setup;
  } else {
#line 612
    opts->print.setup = 2;
  }
#line 613
  if (opts->print.crash > 2) {
#line 613
    opts->print.crash = opts->print.crash;
  } else {
#line 613
    opts->print.crash = 2;
  }
#line 614
  if (opts->print.pricing > 0) {
#line 614
    opts->print.pricing = opts->print.pricing;
  } else {
#line 614
    opts->print.pricing = 0;
  }
#line 615
  if (opts->print.pivoting > 0) {
#line 615
    opts->print.pivoting = opts->print.pivoting;
  } else {
#line 615
    opts->print.pivoting = 0;
  }
#line 616
  if (opts->print.pivreject > 0) {
#line 616
    opts->print.pivreject = opts->print.pivreject;
  } else {
#line 616
    opts->print.pivreject = 0;
  }
#line 617
  if (opts->print.degen > 1) {
#line 617
    opts->print.degen = opts->print.degen;
  } else {
#line 617
    opts->print.degen = 1;
  }
#line 618
  if (opts->print.phase1 > 3) {
#line 618
    opts->print.phase1 = opts->print.phase1;
  } else {
#line 618
    opts->print.phase1 = 3;
  }
#line 619
  if (opts->print.phase2 > 3) {
#line 619
    opts->print.phase2 = opts->print.phase2;
  } else {
#line 619
    opts->print.phase2 = 3;
  }
#line 620
  if (opts->print.dual > 3) {
#line 620
    opts->print.dual = opts->print.dual;
  } else {
#line 620
    opts->print.dual = 3;
  }
#line 621
  if (opts->print.basis > 2) {
#line 621
    opts->print.basis = opts->print.basis;
  } else {
#line 621
    opts->print.basis = 2;
  }
#line 622
  if (opts->print.conmgmt > 2) {
#line 622
    opts->print.conmgmt = opts->print.conmgmt;
  } else {
#line 622
    opts->print.conmgmt = 2;
  }
#line 623
  if (opts->print.varmgmt > 2) {
#line 623
    opts->print.varmgmt = opts->print.varmgmt;
  } else {
#line 623
    opts->print.varmgmt = 2;
  }
#line 624
  if (opts->print.force > 1) {
#line 624
    opts->print.force = opts->print.force;
  } else {
#line 624
    opts->print.force = 1;
  }
#line 625
  if (opts->print.tableau > 1) {
#line 625
    opts->print.tableau = opts->print.tableau;
  } else {
#line 625
    opts->print.tableau = 1;
  }
#line 626
  if (opts->print.rays > 1) {
#line 626
    opts->print.rays = opts->print.rays;
  } else {
#line 626
    opts->print.rays = 1;
  }
#line 627
  if (opts->print.soln > 1) {
#line 627
    opts->print.soln = opts->print.soln;
  } else {
#line 627
    opts->print.soln = 1;
  }
#line 628
  goto switch_break;
  case_4: /* CIL Label */ 
#line 630
  if (opts->print.major > 1) {
#line 630
    opts->print.major = opts->print.major;
  } else {
#line 630
    opts->print.major = 1;
  }
#line 631
  if (opts->print.scaling > 2) {
#line 631
    opts->print.scaling = opts->print.scaling;
  } else {
#line 631
    opts->print.scaling = 2;
  }
#line 632
  if (opts->print.setup > 3) {
#line 632
    opts->print.setup = opts->print.setup;
  } else {
#line 632
    opts->print.setup = 3;
  }
#line 633
  if (opts->print.crash > 3) {
#line 633
    opts->print.crash = opts->print.crash;
  } else {
#line 633
    opts->print.crash = 3;
  }
#line 634
  if (opts->print.pricing > 0) {
#line 634
    opts->print.pricing = opts->print.pricing;
  } else {
#line 634
    opts->print.pricing = 0;
  }
#line 635
  if (opts->print.pivoting > 0) {
#line 635
    opts->print.pivoting = opts->print.pivoting;
  } else {
#line 635
    opts->print.pivoting = 0;
  }
#line 636
  if (opts->print.pivreject > 0) {
#line 636
    opts->print.pivreject = opts->print.pivreject;
  } else {
#line 636
    opts->print.pivreject = 0;
  }
#line 637
  if (opts->print.degen > 2) {
#line 637
    opts->print.degen = opts->print.degen;
  } else {
#line 637
    opts->print.degen = 2;
  }
#line 638
  if (opts->print.phase1 > 4) {
#line 638
    opts->print.phase1 = opts->print.phase1;
  } else {
#line 638
    opts->print.phase1 = 4;
  }
#line 639
  if (opts->print.phase2 > 4) {
#line 639
    opts->print.phase2 = opts->print.phase2;
  } else {
#line 639
    opts->print.phase2 = 4;
  }
#line 640
  if (opts->print.dual > 4) {
#line 640
    opts->print.dual = opts->print.dual;
  } else {
#line 640
    opts->print.dual = 4;
  }
#line 641
  if (opts->print.basis > 3) {
#line 641
    opts->print.basis = opts->print.basis;
  } else {
#line 641
    opts->print.basis = 3;
  }
#line 642
  if (opts->print.conmgmt > 3) {
#line 642
    opts->print.conmgmt = opts->print.conmgmt;
  } else {
#line 642
    opts->print.conmgmt = 3;
  }
#line 643
  if (opts->print.varmgmt > 2) {
#line 643
    opts->print.varmgmt = opts->print.varmgmt;
  } else {
#line 643
    opts->print.varmgmt = 2;
  }
#line 644
  if (opts->print.force > 2) {
#line 644
    opts->print.force = opts->print.force;
  } else {
#line 644
    opts->print.force = 2;
  }
#line 645
  if (opts->print.tableau > 1) {
#line 645
    opts->print.tableau = opts->print.tableau;
  } else {
#line 645
    opts->print.tableau = 1;
  }
#line 646
  if (opts->print.rays > 3) {
#line 646
    opts->print.rays = opts->print.rays;
  } else {
#line 646
    opts->print.rays = 3;
  }
#line 647
  if (opts->print.soln > 3) {
#line 647
    opts->print.soln = opts->print.soln;
  } else {
#line 647
    opts->print.soln = 3;
  }
#line 648
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 650
  if (opts->print.major > 1) {
#line 650
    opts->print.major = opts->print.major;
  } else {
#line 650
    opts->print.major = 1;
  }
#line 651
  if (opts->print.scaling > 2) {
#line 651
    opts->print.scaling = opts->print.scaling;
  } else {
#line 651
    opts->print.scaling = 2;
  }
#line 652
  if (opts->print.setup > 5) {
#line 652
    opts->print.setup = opts->print.setup;
  } else {
#line 652
    opts->print.setup = 5;
  }
#line 653
  if (opts->print.crash > 4) {
#line 653
    opts->print.crash = opts->print.crash;
  } else {
#line 653
    opts->print.crash = 4;
  }
#line 654
  if (opts->print.pricing > 1) {
#line 654
    opts->print.pricing = opts->print.pricing;
  } else {
#line 654
    opts->print.pricing = 1;
  }
#line 655
  if (opts->print.pivoting > 1) {
#line 655
    opts->print.pivoting = opts->print.pivoting;
  } else {
#line 655
    opts->print.pivoting = 1;
  }
#line 656
  if (opts->print.pivreject > 1) {
#line 656
    opts->print.pivreject = opts->print.pivreject;
  } else {
#line 656
    opts->print.pivreject = 1;
  }
#line 657
  if (opts->print.degen > 2) {
#line 657
    opts->print.degen = opts->print.degen;
  } else {
#line 657
    opts->print.degen = 2;
  }
#line 658
  if (opts->print.phase1 > 5) {
#line 658
    opts->print.phase1 = opts->print.phase1;
  } else {
#line 658
    opts->print.phase1 = 5;
  }
#line 659
  if (opts->print.phase2 > 5) {
#line 659
    opts->print.phase2 = opts->print.phase2;
  } else {
#line 659
    opts->print.phase2 = 5;
  }
#line 660
  if (opts->print.dual > 5) {
#line 660
    opts->print.dual = opts->print.dual;
  } else {
#line 660
    opts->print.dual = 5;
  }
#line 661
  if (opts->print.basis > 5) {
#line 661
    opts->print.basis = opts->print.basis;
  } else {
#line 661
    opts->print.basis = 5;
  }
#line 662
  if (opts->print.conmgmt > 3) {
#line 662
    opts->print.conmgmt = opts->print.conmgmt;
  } else {
#line 662
    opts->print.conmgmt = 3;
  }
#line 663
  if (opts->print.varmgmt > 2) {
#line 663
    opts->print.varmgmt = opts->print.varmgmt;
  } else {
#line 663
    opts->print.varmgmt = 2;
  }
#line 664
  if (opts->print.force > 3) {
#line 664
    opts->print.force = opts->print.force;
  } else {
#line 664
    opts->print.force = 3;
  }
#line 665
  if (opts->print.tableau > 4) {
#line 665
    opts->print.tableau = opts->print.tableau;
  } else {
#line 665
    opts->print.tableau = 4;
  }
#line 666
  if (opts->print.rays > 4) {
#line 666
    opts->print.rays = opts->print.rays;
  } else {
#line 666
    opts->print.rays = 4;
  }
#line 667
  if (opts->print.soln > 4) {
#line 667
    opts->print.soln = opts->print.soln;
  } else {
#line 667
    opts->print.soln = 4;
  }
#line 668
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 670
  return;
}
}
