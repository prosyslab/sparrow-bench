/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 50 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 53 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_15 {
   char __size[36] ;
   long __align ;
};
#line 53 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_15 pthread_attr_t;
#line 67 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 67 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_17 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_17 __annonCompField1 ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_16 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_16 pthread_mutex_t;
#line 275 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 174 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/sys/socket.h"
struct sockaddr_in;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 36 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
typedef pthread_t icethread_t;
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
struct icemutex_St {
   long thread_id ;
   pthread_mutex_t mutex ;
   long mutexid ;
   int lineno ;
   long id ;
};
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
typedef struct icemutex_St mutex_t;
#line 56 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
struct avl_node {
   void *data ;
   struct avl_node *link[2] ;
   signed char bal ;
   char cache ;
   signed char pad[2] ;
};
#line 56 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
typedef struct avl_node avl_node;
#line 67 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
struct avl_traverser {
   int init ;
   int nstack ;
   avl_node const   *p ;
   avl_node const   *stack[32] ;
};
#line 67 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
typedef struct avl_traverser avl_traverser;
#line 85 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
struct avl_tree {
   avl_node root ;
   int (*cmp)(void const   *a , void const   *b , void *param ) ;
   int count ;
   void *param ;
   mutex_t mutex ;
};
#line 85 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
typedef struct avl_tree avl_tree;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
enum __anonenum_client_type_t_52 {
    listener_e = 0,
    pusher_e = 1,
    pulling_client_e = 2,
    unknown_client_e = -1
} ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_client_type_t_52 client_type_t;
#line 26
enum __anonenum_protocol_t_53 {
    icy_e = 0,
    xaudiocast_e = 1
} ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_protocol_t_53 protocol_t;
#line 27
enum __anonenum_source_type_t_54 {
    encoder_e = 0,
    puller_e = 1,
    on_demand_pull_e = 2,
    file_e = 3,
    unknown_source_e = -1
} ;
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_source_type_t_54 source_type_t;
#line 28
enum contype_e {
    client_e = 0,
    source_e = 1,
    admin_e = 2,
    unknown_connection_e = 3
} ;
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum contype_e contype_t;
#line 30
enum scheme_e {
    html_scheme_e = 0,
    default_scheme_e = 1,
    tagged_scheme_e = 2
} ;
#line 30 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum scheme_e scheme_t;
#line 32
enum __anonenum_resolv_type_t_57 {
    linux_gethostbyname_r_e = 1,
    solaris_gethostbyname_r_e = 2,
    standard_gethostbyname_e = 3
} ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_resolv_type_t_57 resolv_type_t;
#line 33
enum __anonenum_relay_type_t_58 {
    relay_pull_e = 1,
    relay_push_e = 2
} ;
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_relay_type_t_58 relay_type_t;
#line 38 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef avl_tree vartree_t;
#line 55 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef int SOCKET;
#line 95 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct request_St {
   char path[8192] ;
   char host[8192] ;
   int port ;
};
#line 95 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct request_St request_t;
#line 115 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct chunkSt {
   char data[12288] ;
   int len ;
   int metalen ;
   int clients_left ;
};
#line 115 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct chunkSt chunk_t;
#line 123 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct statistics_St {
   unsigned long read_bytes ;
   unsigned long read_megs ;
   unsigned long write_bytes ;
   unsigned long write_megs ;
   unsigned long client_connections ;
   unsigned long source_connections ;
   unsigned long client_connect_time ;
   unsigned long source_connect_time ;
};
#line 123 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct statistics_St statistics_t;
#line 136 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct audiocast_St {
   char *name ;
   char *genre ;
   int bitrate ;
   char *url ;
   char *mount ;
   char *description ;
   char *streammimetype ;
   char *contentid ;
   int public ;
};
#line 136 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct audiocast_St audiocast_t;
#line 154 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct songinfo_St {
   char *streamurl ;
   char *streamtitle ;
   char *streammsg ;
   long streamlength ;
   unsigned long udpseqnr ;
};
#line 154 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct songinfo_St songinfo_t;
#line 163 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct source_St {
   int connected ;
   source_type_t type ;
   protocol_t protocol ;
   mutex_t mutex ;
   audiocast_t audiocast ;
   avl_tree *clients ;
   icethread_t thread ;
   statistics_t stats ;
   unsigned long num_clients ;
   chunk_t chunk[64] ;
   int cid ;
   char *dumpfile ;
   int dumpfd ;
   avl_tree *relay_tree ;
   int priority ;
   songinfo_t info ;
};
#line 163 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct source_St source_t;
#line 183 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct client_St {
   unsigned int use_udp : 1 ;
   unsigned int use_icy : 1 ;
   int errors ;
   int offset ;
   int cid ;
   int alive ;
   client_type_t type ;
   unsigned long write_bytes ;
   int virgin ;
   source_t *source ;
   int use_icy_metadata ;
   unsigned long metadataoffset ;
   unsigned long metadatalen ;
   unsigned long metadatawritten ;
   unsigned long udpseqnr ;
};
#line 183 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct client_St client_t;
#line 203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct admin_St {
   unsigned int status : 1 ;
   unsigned int oper : 1 ;
   unsigned int tailing : 1 ;
   unsigned int alive : 1 ;
   int commands ;
   icethread_t thread ;
   int debuglevel ;
   scheme_t scheme ;
};
#line 203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct admin_St admin_t;
#line 225 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
union __anonunion_food_59 {
   client_t *client ;
   source_t *source ;
   admin_t *admin ;
};
#line 225 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct connectionSt {
   contype_t type ;
   union __anonunion_food_59 food ;
   unsigned long id ;
   struct sockaddr_in *sin ;
   socklen_t sinlen ;
   SOCKET sock ;
   time_t connect_time ;
   char *host ;
   char *hostname ;
   vartree_t *headervars ;
};
#line 225 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct connectionSt connection_t;
#line 242 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct relay_St {
   request_t req ;
   relay_type_t type ;
   char localmount[8192] ;
   connection_t *con ;
   int reconnects ;
   time_t last_reconnect ;
   char *password ;
   protocol_t protocol ;
   audiocast_t audiocast ;
   int reconnect_now ;
};
#line 242 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct relay_St relay_t;
#line 256 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct __anonstruct_server_info_t_60 {
   char *runpath ;
   int port[5] ;
   SOCKET listen_sock[5] ;
   char *etcdir ;
   char *logdir ;
   char *templatedir ;
   avl_tree *sources ;
   unsigned long num_sources ;
   unsigned long max_sources ;
   char *encoder_pass ;
   char *default_sourceopts ;
   char *oper_pass ;
   avl_tree *admins ;
   unsigned long num_admins ;
   unsigned long max_admins ;
   char *remote_admin_pass ;
   avl_tree *d_servers ;
   int touch_freq ;
   unsigned long max_directories ;
   time_t directorylasttime ;
   time_t udpupdatelasttime ;
   int udpupdatetime ;
   char *staticdir ;
   char *configfile ;
   char *userfile ;
   char *groupfile ;
   char *mountfile ;
   char *prompt ;
   char *logfilename ;
   int logfile ;
   char *usagefilename ;
   int usagefile ;
   char *accessfilename ;
   int accessfile ;
   char *statsfilename ;
   char *statshtmlfilename ;
   int statsfile ;
   int statstime ;
   time_t statslasttime ;
   long server_start_time ;
   time_t statuslasttime ;
   int statustime ;
   char *myhostname ;
   char *server_name ;
   int console_mode ;
   int detach ;
   int throttle_on ;
   double throttle ;
   double bandwidth_usage ;
   double sleep_ratio ;
   int reverse_lookups ;
   int force_servername ;
   int mount_fallback ;
   icethread_t main_thread ;
   pthread_attr_t defaultattr ;
   mutex_t source_mutex ;
   mutex_t admin_mutex ;
   mutex_t directory_mutex ;
   mutex_t alias_mutex ;
   mutex_t misc_mutex ;
   mutex_t mount_mutex ;
   mutex_t hostname_mutex ;
   mutex_t acl_mutex ;
   mutex_t double_mutex ;
   mutex_t thread_mutex ;
   mutex_t mutex_mutex ;
   mutex_t relay_mutex ;
   mutex_t resolvmutex ;
   resolv_type_t resolv_type ;
   int client_timeout ;
   char *client_pass ;
   unsigned long num_clients ;
   unsigned long max_clients ;
   unsigned long max_clients_per_source ;
   avl_tree *threads ;
   avl_tree *mutexes ;
   avl_tree *relays ;
   long threadid ;
   long mutexid ;
   unsigned long id ;
   avl_tree *aliases ;
   int transparent_proxy ;
   int kick_relays ;
   int relay_reconnect_time ;
   int relay_reconnect_tries ;
   int kick_clients ;
   avl_tree *my_hostnames ;
   avl_tree *all_acl ;
   avl_tree *admin_acl ;
   avl_tree *source_acl ;
   avl_tree *client_acl ;
   int policy ;
   int allow_http_admin ;
   statistics_t hourly_stats ;
   statistics_t daily_stats ;
   statistics_t total_stats ;
   char *location ;
   char *rp_email ;
   char *server_url ;
   int streamurllock ;
   char *streamtitle ;
   char *streamurl ;
   char *streamtitletemplate ;
   char *nametemplate ;
   char *descriptiontemplate ;
   int use_meta_data ;
   unsigned long metainterval ;
   int consoledebuglevel ;
   int logfiledebuglevel ;
};
#line 256 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct __anonstruct_server_info_t_60 server_info_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 80 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 400 "/usr/include/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 84 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct varpair_St {
   char *name ;
   char *value ;
};
#line 84 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct varpair_St varpair_t;
#line 68 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
struct mythread_st {
   icethread_t thread ;
   int line ;
   char *file ;
   char *name ;
   long id ;
   time_t created ;
   int ping ;
   int running ;
};
#line 68 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
typedef struct mythread_st mythread_t;
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef int wid_t;
#line 148 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct relay_idSt {
   char *host ;
   int id ;
};
#line 148 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct relay_idSt relay_id_t;
#line 421 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct com_requestSt {
   wid_t wid ;
   connection_t *con ;
   char *arg ;
};
#line 421 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct com_requestSt com_request_t;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.h"
struct output_item_t {
   char *name ;
   char *format ;
   void const   *value ;
};
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.h"
typedef struct output_item_t item_t;
#line 31
enum __anonenum_item_token_t_88 {
    token_header = 0,
    token_footer = 1
} ;
#line 31 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.h"
typedef enum __anonenum_item_token_t_88 item_token_t;
#line 32
enum __anonenum_item_type_t_89 {
    list_start = 0,
    list_end = 1,
    list_item = 2,
    header = 3,
    list_caption = 4,
    plaintext = 5,
    list_set_item = 6
} ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.h"
typedef enum __anonenum_item_type_t_89 item_type_t;
#line 102 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct alias_St {
   request_t *name ;
   request_t *real ;
};
#line 102 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct alias_St alias_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.h"
struct __anonstruct_dir_t_32 {
   DIR *directory ;
   struct dirent *entry ;
   char const   *filename ;
};
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.h"
typedef struct __anonstruct_dir_t_32 dir_t;
#line 31 "../../src/icetypes.h"
enum __anonenum_filetype_t_77 {
    conf_file_e = 1,
    log_file_e = 2,
    template_file_e = 3,
    static_file_e = 4
} ;
#line 31 "../../src/icetypes.h"
typedef enum __anonenum_filetype_t_77 filetype_t;
#line 31 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef avl_tree usertree_t;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef avl_tree grouptree_t;
#line 35 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
struct userSt {
   char *name ;
   char *pass ;
};
#line 35 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef struct userSt ice_user_t;
#line 40 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
struct groupSt {
   char *name ;
   usertree_t *usertree ;
};
#line 40 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef struct groupSt group_t;
#line 29 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
enum __anonenum_acltype_t_54 {
    deny = 0,
    allow = 1,
    all = 2
} ;
#line 29 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum __anonenum_acltype_t_54 acltype_t;
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct restrict_St {
   unsigned long id ;
   char *mask ;
   acltype_t type ;
};
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct restrict_St restrict_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 214 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct dirSt {
   int counter ;
   int touches ;
   int id ;
   char *host ;
   int port ;
   protocol_t type ;
   char *path ;
   time_t touchtime ;
};
#line 214 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct dirSt directory_server_t;
#line 45 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
struct mountSt {
   char *name ;
   grouptree_t *grouptree ;
};
#line 45 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef struct mountSt mount_t;
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.h"
struct ice_socket_St {
   SOCKET sock ;
   int domain ;
   int type ;
   int protocol ;
   int blocking ;
   int keepalive ;
   int linger ;
   int busy ;
};
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.h"
typedef struct ice_socket_St ice_socket_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 146 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_7 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_8 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_7 __wait_terminated ;
   struct __anonstruct___wait_stopped_8 __wait_stopped ;
};
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 84 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 28 "/usr/include/mcheck.h"
enum mcheck_status {
    MCHECK_DISABLED = -1,
    MCHECK_OK = 0,
    MCHECK_FREE = 1,
    MCHECK_HEAD = 2,
    MCHECK_TAIL = 3
} ;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 64 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef int sock_t;
#line 35 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef int icecast_function();
#line 36 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef char const   *htf;
#line 37 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef htf HttpFunction();
#line 41
enum type_e {
    integer_e = 0,
    real_e = 1,
    string_e = 2,
    function_e = 3
} ;
#line 41 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef enum type_e type_t;
#line 69 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct http_parsable_commandsSt {
   char *name ;
   HttpFunction *func ;
};
#line 69 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct http_parsable_commandsSt http_parsable_t;
#line 77 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
struct http_variableSt {
   char *name ;
   type_t type ;
   void *valueptr ;
};
#line 77 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/icetypes.h"
typedef struct http_variableSt http_variable_t;
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
struct __anonstruct_comp_element_86 {
   char *name ;
   icecast_function *func ;
   char *doc ;
   int oper ;
   char *doclong ;
};
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
typedef struct __anonstruct_comp_element_86 comp_element;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
struct __anonstruct_http_command_t_87 {
   char *name ;
   icecast_function *func ;
   int wrap ;
   char *argument ;
};
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
typedef struct __anonstruct_http_command_t_87 http_command_t;
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
struct __anonstruct_html_wrapper_t_88 {
   int message_type ;
   char *html ;
};
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
typedef struct __anonstruct_html_wrapper_t_88 html_wrapper_t;
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
typedef avl_tree mounttree_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 106 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_18 {
   char __size[4] ;
   int __align ;
};
#line 106 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_18 pthread_mutexattr_t;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
struct __anonstruct_set_element_83 {
   char *name ;
   type_t type ;
   char *doc ;
   void *setting ;
};
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
typedef struct __anonstruct_set_element_83 set_element;
#line 94 "/usr/include/malloc.h"
struct mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
#line 96 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
struct __anonstruct_conopt_t_87 {
   char opt ;
   char *longopt ;
   int arindex ;
};
#line 96 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
typedef struct __anonstruct_conopt_t_87 conopt_t;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 130 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 340
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 186 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 148 "/usr/include/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 83 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
void thread_mutex_lock_c(mutex_t *mutex , int line , char *file ) ;
#line 84
void thread_mutex_unlock_c(mutex_t *mutex , int line , char *file ) ;
#line 114 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
void *avl_traverse(avl_tree *tree , avl_traverser *trav ) ;
#line 118
void *avl_delete(avl_tree *tree , void const   *item ) ;
#line 119
void *avl_find(avl_tree *tree , void const   *item ) ;
#line 145
void *avl_replace(avl_tree *tree , void *item ) ;
#line 45 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void kick_connection(void *conarg , void *reasonarg ) ;
#line 61
connection_t *find_source_with_id(int id ) ;
#line 62
connection_t *find_source_with_mount(char *mount ) ;
#line 64
unsigned long new_id(void) ;
#line 82
void generate_http_request(char *line , request_t *req ) ;
#line 104
void zero_audiocast(audiocast_t *au ) ;
#line 105
void dispose_audiocast(audiocast_t *au ) ;
#line 106
int is_valid_http_request(request_t *req ) ;
#line 23 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *splitc(char *first , char *rest , char const   divider ) ;
#line 41
int ice_strncmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 42
int ice_strcmp(char const   *s1 , char const   *s2 ) ;
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.h"
connection_t *create_connection(void) ;
#line 4 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.h"
int relay_add_pull_to_list(char *arg ) ;
#line 5
int relay_add_push_to_list(char *arg ) ;
#line 6
void relay_insert(relay_t *relay ) ;
#line 7
void relay_dispose(relay_t *relay ) ;
#line 8
relay_t *relay_create(void) ;
#line 9
void relay_connect_all_relays(void) ;
#line 10
int relay_connected(relay_t *rel ) ;
#line 11
void relay_connect_list_item(relay_t *rel ) ;
#line 12
connection_t *relay_connect_push(relay_t *relay , int *err ) ;
#line 14
connection_t *relay_pull_stream(request_t *req , int *err ) ;
#line 15
connection_t *relay_connect_pull(relay_t *relay , int *err ) ;
#line 16
int login_as_client_on_server(connection_t *con , request_t *req , char *buf ) ;
#line 17
int relay_setup_connection(connection_t **con , request_t *req ) ;
#line 18
int relay_remove_with_con(connection_t *con ) ;
#line 19
int relay_remove_with_req(request_t *req ) ;
#line 20
relay_t *relay_find_with_req(request_t *req ) ;
#line 21
relay_t *relay_find_with_con(connection_t *con ) ;
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
void put_client(connection_t *con ) ;
#line 31
void util_increase_total_clients(void) ;
#line 58 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.h"
int sock_set_blocking(SOCKET sockfd , int const   block ) ;
#line 59
int sock_close(SOCKET sockfd ) ;
#line 69
SOCKET sock_connect_wto(char const   *hostname , int const   port , int const   timeout ) ;
#line 76
int sock_write_line(SOCKET sockfd , char const   *fmt  , ...) ;
#line 80
int sock_read_lines(SOCKET sockfd , char *buff , int const   len ) ;
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.h"
char *reverse(char const   *host ) ;
#line 40
char *forward(char const   *name , char *target ) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.h"
void source_login(connection_t *con , char *expr ) ;
#line 29
void put_source(connection_t *con ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.h"
void write_log(int whichlog , char *fmt  , ...) ;
#line 27
void xa_debug(int level , char *fmt  , ...) ;
#line 46 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.h"
void *n_malloc(unsigned int const   size , int const   lineno , char const   *file ) ;
#line 47
void n_free(void *ptr , int const   lineno , char const   *file ) ;
#line 48
char *n_strdup(char const   *ptr , int const   lineno , char const   *file ) ;
#line 50
char *ice_itoa(int num ) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.h"
void add_varpair2(vartree_t *request_vars , char *name , char *value ) ;
#line 27
vartree_t *create_header_vars(void) ;
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.h"
long get_time(void) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.h"
int pool_add(connection_t *con ) ;
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
server_info_t info ;
#line 90 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_add_pull_to_list(char *arg ) 
{ 
  relay_t *new ;
  char localmount[8192] ;
  request_t req ;
  char *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 97
  if (! arg) {
#line 98
    return (-2);
  } else
#line 97
  if (! *(arg + 0)) {
#line 98
    return (-2);
  }
  {
  {
#line 100
  xa_debug(2, (char *)"DEBUG: Adding [%s] to list of pulling relays", arg);
  }
#line 102
  localmount[0] = (char )'\000';
  }
#line 104
  if ((int )*(arg + 0) == 45) {
#line 104
    if ((int )*(arg + 1) == 109) {
      {
#line 105
      localmount[0] = (char )'\000';
      {
#line 106
      tmp = splitc(localmount, arg, (char const   )' ');
      }
      }
#line 106
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 107
        return (-3);
      }
      {
      {
#line 110
      generate_http_request(arg, & req);
      }
      }
#line 112
      if (! req.path[0]) {
#line 113
        return (-2);
      }
    }
  }
  {
  {
#line 117
  new = relay_create();
  }
  {
#line 119
  generate_http_request(arg, & new->req);
  }
  }
#line 121
  if (localmount[0]) {
    {
    {
#line 122
    strncpy((char */* __restrict  */)(new->localmount), (char const   */* __restrict  */)(localmount),
            (size_t )8192);
    }
    }
  } else {
    {
    {
#line 124
    snprintf((char */* __restrict  */)(new->localmount), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
             new->req.host, new->req.port, new->req.path);
    }
    }
  }
  {
  {
#line 126
  relay_insert(new);
  }
  {
#line 128
  xa_debug(3, (char *)"DEBUG: Insertion of pulling relay succeeded", arg);
  }
  }
#line 130
  return (1);
}
}
#line 142 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_add_push_to_list(char *arg ) 
{ 
  char id_or_localmount[8192] ;
  char password[8192] ;
  char url[8192] ;
  char description[8192] ;
  char name[8192] ;
  char genre[8192] ;
  char mimetype[8192] ;
  char buf[8192] ;
  char carg[8192] ;
  request_t req ;
  int bitrate ;
  int public ;
  int go_on ;
  relay_t *relay ;
  connection_t *con ;
  source_t *source ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 148
  go_on = 0;
#line 149
  relay = (relay_t *)((void *)0);
#line 150
  con = (connection_t *)((void *)0);
#line 153
  if (! arg) {
#line 154
    return (-2);
  } else
#line 153
  if (! *(arg + 0)) {
#line 154
    return (-2);
  } else {
    {
    {
#line 153
    tmp = splitc(id_or_localmount, arg, (char const   )' ');
    }
    }
#line 153
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 154
      return (-2);
    }
  }
  {
  {
#line 157
  xa_debug(2, (char *)"DEBUG: Adding [%s %s] to list of pushing relays", id_or_localmount,
           arg);
  }
  {
#line 159
  generate_http_request(arg, & req);
  }
  {
#line 161
  tmp___0 = is_valid_http_request(& req);
  }
  }
#line 161
  if (! tmp___0) {
#line 162
    return (-2);
  }
  {
  {
#line 165
  tmp___2 = __ctype_b_loc();
  }
  }
#line 165
  if ((int const   )*(*tmp___2 + (int )id_or_localmount[0]) & 2048) {
    {
    {
#line 166
    tmp___1 = atoi((char const   *)(id_or_localmount));
    }
    {
#line 166
    con = find_source_with_id(tmp___1);
    }
    }
  } else {
    {
    {
#line 168
    con = find_source_with_mount(id_or_localmount);
    }
    }
  }
#line 170
  if (! con) {
#line 171
    return (-9);
  }
  {
#line 173
  source = con->food.source;
  {
#line 175
  relay = relay_create();
  }
  {
#line 177
  strncpy((char */* __restrict  */)(relay->localmount), (char const   */* __restrict  */)(con->food.source)->audiocast.mount,
          (size_t )8192);
  }
  {
#line 178
  generate_http_request(arg, & relay->req);
  }
  {
#line 180
  strncpy((char */* __restrict  */)(password), (char const   */* __restrict  */)info.encoder_pass,
          (size_t )8192);
  }
  {
#line 181
  strncpy((char */* __restrict  */)(url), (char const   */* __restrict  */)source->audiocast.url,
          (size_t )8192);
  }
  {
#line 182
  strncpy((char */* __restrict  */)(description), (char const   */* __restrict  */)source->audiocast.description,
          (size_t )8192);
  }
  {
#line 183
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)source->audiocast.name,
          (size_t )8192);
  }
  {
#line 184
  strncpy((char */* __restrict  */)(genre), (char const   */* __restrict  */)source->audiocast.genre,
          (size_t )8192);
  }
  {
#line 185
  strncpy((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)source->audiocast.streammimetype,
          (size_t )8192);
  }
#line 187
  bitrate = source->audiocast.bitrate;
#line 188
  public = source->audiocast.public;
  }
  {
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 192
    tmp___5 = splitc(buf, arg, (char const   )' ');
    }
    }
#line 192
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 194
      go_on = 0;
      {
#line 195
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      }
    } else
#line 197
    if ((int )buf[0] == 45) {
#line 197
      if ((int )buf[1] != 105) {
        {
        {
#line 197
        tmp___4 = splitc(carg, arg, (char const   )' ');
        }
        }
#line 197
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 199
          if ((int )carg[0] == 45) {
#line 200
            return (-3);
          } else {
            {
            {
#line 199
            tmp___3 = ice_strcmp((char const   *)(carg), (char const   *)(buf));
            }
            }
#line 199
            if (tmp___3 == 0) {
#line 200
              return (-3);
            }
          }
        } else {
          {
          {
#line 202
          strncpy((char */* __restrict  */)(carg), (char const   */* __restrict  */)arg,
                  (size_t )8192);
          }
          }
        }
      } else {
        {
        {
#line 202
        strncpy((char */* __restrict  */)(carg), (char const   */* __restrict  */)arg,
                (size_t )8192);
        }
        }
      }
    } else {
      {
      {
#line 202
      strncpy((char */* __restrict  */)(carg), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      }
    }
#line 206
    if ((int )buf[0] == 45) {
      {
      {
#line 208
      xa_debug(2, (char *)"DEBUG: Relay push arguments, buf: [%s] arg: [%s] carg: [%s]",
               buf, arg, carg);
      }
      }
      {
#line 212
      if ((int )buf[1] == 112) {
#line 212
        goto case_112;
      }
#line 215
      if ((int )buf[1] == 117) {
#line 215
        goto case_117;
      }
#line 218
      if ((int )buf[1] == 110) {
#line 218
        goto case_110;
      }
#line 221
      if ((int )buf[1] == 103) {
#line 221
        goto case_103;
      }
#line 224
      if ((int )buf[1] == 80) {
#line 224
        goto case_80;
      }
#line 227
      if ((int )buf[1] == 98) {
#line 227
        goto case_98;
      }
#line 230
      if ((int )buf[1] == 100) {
#line 230
        goto case_100;
      }
#line 233
      if ((int )buf[1] == 105) {
#line 233
        goto case_105;
      }
#line 236
      if ((int )buf[1] == 109) {
#line 236
        goto case_109;
      }
#line 210
      goto switch_break;
      case_112: /* CIL Label */ 
      {
      {
#line 213
      strncpy((char */* __restrict  */)(password), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 214
      goto switch_break;
      case_117: /* CIL Label */ 
      {
      {
#line 216
      strncpy((char */* __restrict  */)(url), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 217
      goto switch_break;
      case_110: /* CIL Label */ 
      {
      {
#line 219
      strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 220
      goto switch_break;
      case_103: /* CIL Label */ 
      {
      {
#line 222
      strncpy((char */* __restrict  */)(genre), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 223
      goto switch_break;
      case_80: /* CIL Label */ 
      {
      {
#line 225
      public = atoi((char const   *)(carg));
      }
      }
#line 226
      goto switch_break;
      case_98: /* CIL Label */ 
      {
      {
#line 228
      bitrate = atoi((char const   *)(carg));
      }
      }
#line 229
      goto switch_break;
      case_100: /* CIL Label */ 
      {
      {
#line 231
      strncpy((char */* __restrict  */)(description), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 232
      goto switch_break;
      case_105: /* CIL Label */ 
#line 234
      relay->protocol = (protocol_t )0;
#line 235
      goto switch_break;
      case_109: /* CIL Label */ 
      {
      {
#line 237
      strncpy((char */* __restrict  */)(mimetype), (char const   */* __restrict  */)(carg),
              (size_t )8192);
      }
      }
#line 238
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 190
    if (! go_on) {
#line 190
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 243
  relay->password = n_strdup((char const   *)(password), (int const   )243, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 244
  relay->audiocast.url = n_strdup((char const   *)(url), (int const   )244, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 245
  relay->audiocast.name = n_strdup((char const   *)(name), (int const   )245, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 246
  relay->audiocast.genre = n_strdup((char const   *)(genre), (int const   )246, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
#line 247
  relay->audiocast.public = public;
#line 248
  relay->audiocast.bitrate = bitrate;
#line 249
  relay->audiocast.description = description;
#line 250
  relay->audiocast.streammimetype = mimetype;
  {
#line 251
  relay->audiocast.contentid = n_strdup((char const   *)(con->food.source)->audiocast.contentid,
                                        (int const   )251, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
#line 253
  relay->type = (relay_type_t )2;
  {
#line 255
  relay_insert(relay);
  }
  {
#line 257
  xa_debug(3, (char *)"DEBUG: Insertion of pushing relay succeeded");
  }
  }
#line 259
  return (1);
}
}
#line 269 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_remove(relay_t *relay ) 
{ 
  relay_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 274
  if (! relay) {
    {
    {
#line 275
    write_log(0, (char *)"WARNING: Trying to remove a NULL relay from tree");
    }
    }
#line 276
    return (-10);
  }
  {
  {
#line 279
  thread_mutex_lock_c(& info.relay_mutex, 279, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 280
  tmp = avl_delete(info.relays, (void const   *)relay);
  }
#line 280
  out = (relay_t *)tmp;
  {
#line 281
  thread_mutex_unlock_c(& info.relay_mutex, 281, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  }
#line 283
  if (out) {
    {
    {
#line 284
    xa_debug(2, (char *)"DEBUG: Removed relay [%s:%d%s]", out->req.host, out->req.port,
             out->req.path);
    }
    {
#line 285
    relay_dispose(out);
    }
    }
#line 286
    return (1);
  }
#line 289
  return (-11);
}
}
#line 292 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_remove_with_con(connection_t *con ) 
{ 
  relay_t *rel ;
  relay_t *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 295
  tmp = relay_find_with_con(con);
  }
#line 295
  rel = tmp;
  }
#line 297
  if (rel) {
    {
    {
#line 298
    tmp___0 = relay_remove(rel);
    }
    }
#line 298
    return (tmp___0);
  }
#line 299
  return (-11);
}
}
#line 302 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_remove_with_req(request_t *req ) 
{ 
  relay_t *rel ;
  relay_t *tmp ;
  int tmp___0 ;

  {
  {
  {
#line 305
  tmp = relay_find_with_req(req);
  }
#line 305
  rel = tmp;
  }
#line 307
  if (rel) {
    {
    {
#line 308
    tmp___0 = relay_remove(rel);
    }
    }
#line 308
    return (tmp___0);
  }
#line 309
  return (-11);
}
}
#line 316 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
relay_t *relay_find_with_req(request_t *req ) 
{ 
  relay_t rel ;
  relay_t *out ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 319
  out = (relay_t *)((void *)0);
  {
#line 321
  strncpy((char */* __restrict  */)(rel.req.host), (char const   */* __restrict  */)(req->host),
          (size_t )8192);
  }
#line 322
  rel.req.port = req->port;
  {
#line 323
  strncpy((char */* __restrict  */)(rel.req.path), (char const   */* __restrict  */)(req->path),
          (size_t )8192);
  }
  {
#line 325
  thread_mutex_lock_c(& info.relay_mutex, 325, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 326
  tmp = avl_find(info.relays, (void const   *)(& rel));
  }
#line 326
  out = (relay_t *)tmp;
  {
#line 327
  thread_mutex_unlock_c(& info.relay_mutex, 327, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  }
#line 329
  return (out);
}
}
#line 336 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
relay_t *relay_find_with_con(connection_t *con ) 
{ 
  avl_traverser trav ;
  relay_t *rel ;
  void *tmp ;

  {
#line 339
  trav.init = 0;
#line 339
  trav.nstack = 0;
#line 339
  trav.p = (avl_node const   *)0;
#line 339
  trav.stack[0] = (avl_node const   *)0;
#line 339
  trav.stack[1] = (avl_node const   *)0;
#line 339
  trav.stack[2] = (avl_node const   *)0;
#line 339
  trav.stack[3] = (avl_node const   *)0;
#line 339
  trav.stack[4] = (avl_node const   *)0;
#line 339
  trav.stack[5] = (avl_node const   *)0;
#line 339
  trav.stack[6] = (avl_node const   *)0;
#line 339
  trav.stack[7] = (avl_node const   *)0;
#line 339
  trav.stack[8] = (avl_node const   *)0;
#line 339
  trav.stack[9] = (avl_node const   *)0;
#line 339
  trav.stack[10] = (avl_node const   *)0;
#line 339
  trav.stack[11] = (avl_node const   *)0;
#line 339
  trav.stack[12] = (avl_node const   *)0;
#line 339
  trav.stack[13] = (avl_node const   *)0;
#line 339
  trav.stack[14] = (avl_node const   *)0;
#line 339
  trav.stack[15] = (avl_node const   *)0;
#line 339
  trav.stack[16] = (avl_node const   *)0;
#line 339
  trav.stack[17] = (avl_node const   *)0;
#line 339
  trav.stack[18] = (avl_node const   *)0;
#line 339
  trav.stack[19] = (avl_node const   *)0;
#line 339
  trav.stack[20] = (avl_node const   *)0;
#line 339
  trav.stack[21] = (avl_node const   *)0;
#line 339
  trav.stack[22] = (avl_node const   *)0;
#line 339
  trav.stack[23] = (avl_node const   *)0;
#line 339
  trav.stack[24] = (avl_node const   *)0;
#line 339
  trav.stack[25] = (avl_node const   *)0;
#line 339
  trav.stack[26] = (avl_node const   *)0;
#line 339
  trav.stack[27] = (avl_node const   *)0;
#line 339
  trav.stack[28] = (avl_node const   *)0;
#line 339
  trav.stack[29] = (avl_node const   *)0;
#line 339
  trav.stack[30] = (avl_node const   *)0;
#line 339
  trav.stack[31] = (avl_node const   *)0;
#line 342
  if (! con) {
#line 343
    return ((relay_t *)((void *)0));
  }
  {
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 345
    tmp = avl_traverse(info.relays, & trav);
    }
#line 345
    rel = (relay_t *)tmp;
    }
#line 345
    if (! rel) {
#line 345
      goto while_break;
    }
#line 346
    if ((unsigned long )rel->con == (unsigned long )con) {
#line 347
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if (rel) {
#line 350
    if ((unsigned long )rel->con == (unsigned long )con) {
#line 351
      return (rel);
    }
  }
#line 352
  return ((relay_t *)((void *)0));
}
}
#line 360 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
void relay_insert(relay_t *relay ) 
{ 
  relay_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 365
  if (! relay) {
    {
    {
#line 367
    write_log(0, (char *)"WARNING: Trying to insert NULL relay into relay tree");
    }
    }
#line 368
    return;
  }
  {
#line 371
  relay->reconnect_now = 1;
  {
#line 373
  thread_mutex_lock_c(& info.relay_mutex, 373, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 374
  tmp = avl_replace(info.relays, (void *)relay);
  }
#line 374
  out = (relay_t *)tmp;
  {
#line 375
  thread_mutex_unlock_c(& info.relay_mutex, 375, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  }
#line 377
  if (out) {
    {
    {
#line 378
    relay_dispose(out);
    }
    }
  }
#line 379
  return;
}
}
#line 385 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
void relay_dispose(relay_t *relay ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 388
  if (relay->con) {
#line 389
    relay->con = (connection_t *)((void *)0);
  }
#line 390
  if (relay->password) {
    {
    {
#line 391
    n_free((void *)relay->password, (int const   )391, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
    }
    }
  }
  {
#line 391
  relay->password = (char *)((void *)0);
  {
#line 392
  dispose_audiocast(& relay->audiocast);
  }
  {
#line 393
  n_free((void *)relay, (int const   )393, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
#line 393
  relay = (relay_t *)((void *)0);
  }
#line 394
  return;
}
}
#line 400 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
relay_t *relay_create(void) 
{ 
  relay_t *relay ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 403
  tmp = n_malloc((unsigned int const   )sizeof(relay_t ), (int const   )403, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
#line 403
  relay = (relay_t *)tmp;
#line 404
  relay->con = (connection_t *)((void *)0);
#line 405
  relay->localmount[0] = (char )'\000';
#line 406
  relay->reconnects = 0;
#line 407
  relay->last_reconnect = (time_t )0;
#line 408
  relay->password = (char *)((void *)0);
#line 409
  relay->type = (relay_type_t )1;
#line 410
  relay->protocol = (protocol_t )1;
  {
#line 411
  zero_audiocast(& relay->audiocast);
  }
  }
#line 413
  return (relay);
}
}
#line 421 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
void relay_connect_all_relays(void) 
{ 
  avl_traverser trav ;
  relay_t *rel ;
  time_t now ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 424
  trav.init = 0;
#line 424
  trav.nstack = 0;
#line 424
  trav.p = (avl_node const   *)0;
#line 424
  trav.stack[0] = (avl_node const   *)0;
#line 424
  trav.stack[1] = (avl_node const   *)0;
#line 424
  trav.stack[2] = (avl_node const   *)0;
#line 424
  trav.stack[3] = (avl_node const   *)0;
#line 424
  trav.stack[4] = (avl_node const   *)0;
#line 424
  trav.stack[5] = (avl_node const   *)0;
#line 424
  trav.stack[6] = (avl_node const   *)0;
#line 424
  trav.stack[7] = (avl_node const   *)0;
#line 424
  trav.stack[8] = (avl_node const   *)0;
#line 424
  trav.stack[9] = (avl_node const   *)0;
#line 424
  trav.stack[10] = (avl_node const   *)0;
#line 424
  trav.stack[11] = (avl_node const   *)0;
#line 424
  trav.stack[12] = (avl_node const   *)0;
#line 424
  trav.stack[13] = (avl_node const   *)0;
#line 424
  trav.stack[14] = (avl_node const   *)0;
#line 424
  trav.stack[15] = (avl_node const   *)0;
#line 424
  trav.stack[16] = (avl_node const   *)0;
#line 424
  trav.stack[17] = (avl_node const   *)0;
#line 424
  trav.stack[18] = (avl_node const   *)0;
#line 424
  trav.stack[19] = (avl_node const   *)0;
#line 424
  trav.stack[20] = (avl_node const   *)0;
#line 424
  trav.stack[21] = (avl_node const   *)0;
#line 424
  trav.stack[22] = (avl_node const   *)0;
#line 424
  trav.stack[23] = (avl_node const   *)0;
#line 424
  trav.stack[24] = (avl_node const   *)0;
#line 424
  trav.stack[25] = (avl_node const   *)0;
#line 424
  trav.stack[26] = (avl_node const   *)0;
#line 424
  trav.stack[27] = (avl_node const   *)0;
#line 424
  trav.stack[28] = (avl_node const   *)0;
#line 424
  trav.stack[29] = (avl_node const   *)0;
#line 424
  trav.stack[30] = (avl_node const   *)0;
#line 424
  trav.stack[31] = (avl_node const   *)0;
#line 425
  rel = (relay_t *)((void *)0);
  {
#line 428
  xa_debug(4, (char *)"DEBUG: Reconnecting unconnected relays....");
  }
  {
#line 430
  thread_mutex_lock_c(& info.double_mutex, 430, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 431
  thread_mutex_lock_c(& info.relay_mutex, 431, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  }
#line 433
  if (! info.relays) {
    {
    {
#line 434
    write_log(0, (char *)"WARNING: info.relays is NULL, weeird!");
    }
    }
  }
  {
  {
#line 437
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 437
    tmp___1 = avl_traverse(info.relays, & trav);
    }
#line 437
    rel = (relay_t *)tmp___1;
    }
#line 437
    if (! rel) {
#line 437
      goto while_break;
    }
    {
    {
#line 439
    now = get_time();
    }
    {
#line 440
    tmp___0 = relay_connected(rel);
    }
    }
#line 440
    if (tmp___0) {
      _L___0: /* CIL Label */ 
      {
      {
#line 446
      tmp = relay_connected(rel);
      }
      }
#line 446
      if (! tmp) {
#line 446
        if (rel->last_reconnect == 0L) {
#line 446
          goto _L;
        } else
#line 446
        if (rel->last_reconnect + (time_t )info.relay_reconnect_time < now) {
          _L: /* CIL Label */ 
#line 446
          if (info.relay_reconnect_tries == -1) {
            {
#line 450
            (rel->reconnects) ++;
#line 451
            rel->last_reconnect = now;
            {
#line 452
            relay_connect_list_item(rel);
            }
#line 453
            rel->reconnect_now = 0;
            }
          } else
#line 446
          if (rel->reconnects < info.relay_reconnect_tries) {
            {
#line 450
            (rel->reconnects) ++;
#line 451
            rel->last_reconnect = now;
            {
#line 452
            relay_connect_list_item(rel);
            }
#line 453
            rel->reconnect_now = 0;
            }
          }
        }
      }
    } else
#line 440
    if (rel->reconnect_now) {
      {
      {
#line 441
      xa_debug(3, (char *)"DEBUG: Immediately connecting relay");
      }
#line 442
      (rel->reconnects) ++;
#line 443
      rel->last_reconnect = now;
      {
#line 444
      relay_connect_list_item(rel);
      }
#line 445
      rel->reconnect_now = 0;
      }
    } else {
#line 440
      goto _L___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 457
  thread_mutex_unlock_c(& info.relay_mutex, 457, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 458
  thread_mutex_unlock_c(& info.double_mutex, 458, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 460
  xa_debug(4, (char *)"DEBUG: Done reconnecting relays.");
  }
  }
#line 461
  return;
}
}
#line 467 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_connected(relay_t *rel ) 
{ 
  char *__cil_tmp2 ;

  {
#line 470
  if (! rel) {
    {
    {
#line 471
    write_log(0, (char *)"WARNING: relay_connected(): Relay is NULL!");
    }
    }
#line 472
    return (0);
  }
#line 475
  if (rel->con) {
#line 476
    return (1);
  } else {
#line 478
    return (0);
  }
}
}
#line 485 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
void relay_connect_list_item(relay_t *rel ) 
{ 
  int err ;
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 490
  xa_debug(2, (char *)"DEBUG: Reconnecting relay [%s:%d%s]", rel->req.host, rel->req.port,
           rel->req.path);
  }
  }
#line 492
  if ((unsigned int )rel->type == 1U) {
    {
    {
#line 493
    rel->con = relay_connect_pull(rel, & err);
    }
    }
  } else {
    {
    {
#line 495
    rel->con = relay_connect_push(rel, & err);
    }
    }
  }
#line 497
  if (rel->con) {
#line 498
    rel->reconnects = 0;
#line 499
    rel->last_reconnect = (time_t )0;
  } else
#line 500
  if (rel->reconnects > info.relay_reconnect_tries) {
#line 500
    if (info.relay_reconnect_tries != -1) {
      {
      {
#line 501
      write_log(0, (char *)"Relay for [%s:%d%s] has exceeded the maximum number of reconnections.",
                rel->req.host, rel->req.port, rel->req.path);
      }
      }
    }
  }
#line 505
  if (rel->con) {
#line 505
    tmp = "succeeded";
  } else {
#line 505
    tmp = "failed";
  }
  {
  {
#line 505
  xa_debug(3, (char *)"DEBUG: Reconnect %s (%d)", tmp, err);
  }
  }
#line 506
  return;
}
}
#line 517 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
connection_t *relay_connect_push(relay_t *relay , int *err ) 
{ 
  SOCKET sockfd ;
  connection_t *relaycon ;
  connection_t *con ;
  char buf[8192] ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
#line 525
  *err = 1;
  {
#line 527
  xa_debug(2, (char *)"Connecting source %s to [%s:%d%s]", relay->localmount, relay->req.host,
           relay->req.port, relay->req.path);
  }
  {
#line 529
  sockfd = sock_connect_wto((char const   *)(relay->req.host), (int const   )relay->req.port,
                            (int const   )15);
  }
  }
#line 529
  if (sockfd == -1) {
#line 530
    *err = -1;
#line 531
    return ((connection_t *)((void *)0));
  }
#line 534
  if ((unsigned int )relay->protocol == 0U) {
    {
    {
#line 536
    sock_write_line(sockfd, "%s", relay->password);
    }
    {
#line 538
    tmp = recv(sockfd, (void *)(buf), (size_t )100, 0);
    }
    }
#line 538
    if (tmp < 0) {
      {
      {
#line 540
      sock_close(sockfd);
      }
#line 541
      *err = -5;
      }
#line 542
      return ((connection_t *)((void *)0));
    }
#line 545
    if ((int )buf[0] != 79) {
#line 545
      if ((int )buf[0] != 111) {
        {
        {
#line 547
        sock_close(sockfd);
        }
#line 548
        *err = -8;
        }
#line 549
        return ((connection_t *)((void *)0));
      }
    }
    {
    {
#line 552
    sock_write_line(sockfd, "icy-name:%s", relay->audiocast.name);
    }
    {
#line 553
    sock_write_line(sockfd, "icy-genre:%s", relay->audiocast.genre);
    }
    {
#line 554
    sock_write_line(sockfd, "icy-url:%s", relay->audiocast.url);
    }
    {
#line 555
    sock_write_line(sockfd, "icy-pub:%d", relay->audiocast.public);
    }
    {
#line 556
    sock_write_line(sockfd, "icy-br:%d", relay->audiocast.bitrate);
    }
    }
  } else {
    {
    {
#line 558
    sock_write_line(sockfd, "SOURCE %s %s\r\n", relay->password, relay->req.path);
    }
    {
#line 559
    sock_write_line(sockfd, "x-audiocast-name:%s", relay->audiocast.name);
    }
    {
#line 560
    sock_write_line(sockfd, "x-audiocast-genre:%s", relay->audiocast.genre);
    }
    {
#line 561
    sock_write_line(sockfd, "x-audiocast-url:%s", relay->audiocast.url);
    }
    {
#line 562
    sock_write_line(sockfd, "x-audiocast-public:%d", relay->audiocast.public);
    }
    {
#line 563
    sock_write_line(sockfd, "x-audiocast-bitrate:%d", relay->audiocast.bitrate);
    }
    {
#line 564
    sock_write_line(sockfd, "x-audiocast-description:%s", relay->audiocast.description);
    }
    {
#line 565
    sock_write_line(sockfd, "x-audiocast-mimetype:%s", relay->audiocast.streammimetype);
    }
    {
#line 566
    sock_write_line(sockfd, "x-audiocast-contentid:%s", relay->audiocast.contentid);
    }
    {
#line 567
    sock_write_line(sockfd, "x-audiocast-type:relay\r\n");
    }
    {
#line 569
    tmp___0 = recv(sockfd, (void *)(buf), (size_t )100, 0);
    }
    }
#line 569
    if (tmp___0 < 0) {
      {
      {
#line 570
      sock_close(sockfd);
      }
#line 571
      *err = -5;
      }
#line 572
      return ((connection_t *)((void *)0));
    }
#line 576
    if ((int )buf[0] != 79) {
#line 576
      if ((int )buf[0] != 111) {
        {
        {
#line 577
        sock_close(sockfd);
        }
#line 578
        *err = -8;
        }
#line 579
        return ((connection_t *)((void *)0));
      }
    }
  }
  {
  {
#line 583
  relaycon = create_connection();
  }
#line 584
  relaycon->sock = sockfd;
  {
#line 585
  sock_set_blocking(relaycon->sock, (int const   )0);
  }
  {
#line 587
  relaycon->host = n_strdup((char const   *)(relay->req.host), (int const   )587,
                            "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  }
#line 588
  if (info.reverse_lookups) {
    {
    {
#line 589
    relaycon->hostname = reverse((char const   *)relaycon->host);
    }
    }
  }
  {
  {
#line 591
  relaycon->id = new_id();
  }
  {
#line 593
  relaycon->connect_time = time((time_t *)((void *)0));
  }
  {
#line 594
  put_client(relaycon);
  }
#line 595
  (relaycon->food.client)->virgin = 1;
#line 596
  (relaycon->food.client)->write_bytes = 0UL;
#line 597
  (relaycon->food.client)->type = (client_type_t )1;
  {
#line 598
  relaycon->headervars = create_header_vars();
  }
  {
#line 599
  tmp___1 = n_strdup((char const   *)relay->password, (int const   )599, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 599
  tmp___2 = n_strdup("x-audiocast-source-password", (int const   )599, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 599
  add_varpair2(relaycon->headervars, tmp___2, tmp___1);
  }
  {
#line 600
  tmp___3 = ice_itoa(relay->req.port);
  }
  {
#line 600
  tmp___4 = n_strdup("x-audiocast-port", (int const   )600, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 600
  add_varpair2(relaycon->headervars, tmp___4, tmp___3);
  }
  {
#line 601
  tmp___5 = n_strdup((char const   *)(relay->req.path), (int const   )601, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 601
  tmp___6 = n_strdup("x-audiocast-mount", (int const   )601, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 601
  add_varpair2(relaycon->headervars, tmp___6, tmp___5);
  }
  {
#line 603
  con = find_source_with_mount(relay->localmount);
  }
  }
#line 605
  if (! con) {
    {
    {
#line 607
    write_log(0, (char *)"WARNING: Trying to insert pushing relay for nonexitant source");
    }
    }
#line 608
    return (relaycon);
  }
  {
#line 611
  (relaycon->food.client)->source = con->food.source;
  {
#line 612
  pool_add(relaycon);
  }
  {
#line 614
  util_increase_total_clients();
  }
  }
#line 616
  return (relaycon);
}
}
#line 624 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
connection_t *relay_pull_stream(request_t *req , int *err ) 
{ 
  connection_t *con ;
  relay_t rel ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 629
  xa_debug(2, (char *)"DEBUG: relay_pull_stream called with [%s:%d%s]", req->host,
           req->port, req->path);
  }
#line 631
  rel.req = *req;
  {
#line 633
  con = relay_connect_pull(& rel, err);
  }
  }
#line 633
  if (! con) {
#line 634
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 637
  xa_debug(3, (char *)"DEBUG: relay_pull_stream() succeeded");
  }
  }
#line 639
  return (con);
}
}
#line 649 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
connection_t *relay_connect_pull(relay_t *relay , int *err ) 
{ 
  connection_t *newcon ;
  connection_t *con ;
  int id ;
  char buf[8192] ;
  int tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 652
  newcon = (connection_t *)((void *)0);
#line 652
  con = (connection_t *)((void *)0);
#line 656
  *err = 1;
  {
#line 659
  tmp = relay_setup_connection(& newcon, & relay->req);
  }
  }
#line 659
  if (! tmp) {
    {
    {
#line 660
    xa_debug(4, (char *)"WARNING: relay_setup_connection() failed");
    }
#line 661
    *err = -12;
    }
#line 662
    return ((connection_t *)((void *)0));
  }
  {
#line 665
  id = (int )newcon->id;
  {
#line 668
  *err = login_as_client_on_server(newcon, & relay->req, buf);
  }
  }
#line 669
  if (*err < 0) {
    {
    {
#line 670
    xa_debug(4, (char *)"WARNING: login_as_client_on_server() failed (%d)", *err);
    }
    }
#line 671
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 675
  source_login(newcon, buf);
  }
  {
#line 678
  con = find_source_with_id(id);
  }
  }
#line 678
  if (con) {
#line 679
    return (con);
  }
  {
  {
#line 682
  xa_debug(4, (char *)"WARNING: find_source_with_id() didn\'t find new source");
  }
#line 684
  *err = -13;
  }
#line 685
  return ((connection_t *)((void *)0));
}
}
#line 696 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int login_as_client_on_server(connection_t *con , request_t *req , char *buf ) 
{ 
  SOCKET sockfd ;
  int tmp ;
  char *sptr ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *ptr ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 701
  sockfd = sock_connect_wto((char const   *)(req->host), (int const   )req->port,
                            (int const   )15);
  }
  }
#line 701
  if (sockfd == -1) {
    {
    {
#line 702
    xa_debug(4, (char *)"WARNING: sock_connect_wto() to [%s:%d] failed", req->host,
             req->port);
    }
    }
#line 703
    return (-1);
  }
  {
#line 706
  con->sock = sockfd;
  {
#line 707
  con->connect_time = get_time();
  }
  {
#line 709
  snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           req->host, req->port, req->path);
  }
  {
#line 711
  (con->food.source)->audiocast.mount = n_strdup((char const   *)buf, (int const   )711,
                                                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 714
  sock_write_line(sockfd, "GET %s HTTP/1.0\r\nHOST: %s", req->path, req->host);
  }
  {
#line 715
  sock_write_line(sockfd, "User-Agent: icecast/%s\r\nReferer: RELAY", "1.3.12");
  }
  {
#line 716
  sock_write_line(sockfd, "x-audiocast-port: %d", info.port[0]);
  }
  {
#line 717
  sock_write_line(sockfd, "x-audiocast-source-password: %s\r\n", info.encoder_pass);
  }
  {
#line 721
  tmp = sock_read_lines(sockfd, buf, (int const   )8192);
  }
  }
#line 721
  if (! tmp) {
    {
    {
#line 723
    kick_connection((void *)con, (void *)"Error in read");
    }
    }
#line 724
    return (-5);
  }
  {
  {
#line 729
  tmp___0 = strchr((char const   *)buf, ' ');
  }
#line 729
  sptr = tmp___0;
  }
#line 730
  if (! sptr) {
    {
    {
#line 732
    kick_connection((void *)con, (void *)"Erroneous header");
    }
    }
#line 733
    return (-4);
  }
  {
  {
#line 735
  tmp___1 = ice_strncmp((char const   *)buf, "HTTP/1.0 200", (size_t )12);
  }
  }
#line 735
  if (tmp___1 != 0) {
    {
    {
#line 735
    tmp___2 = ice_strncmp((char const   *)buf, "ICY 200", (size_t )7);
    }
    }
#line 735
    if (tmp___2 != 0) {
      {
      {
#line 737
      kick_connection((void *)con, (void *)"Error in request, relay refused entrance");
      }
      }
#line 738
      return (-4);
    }
  }
  {
  {
#line 742
  tmp___6 = ice_strncmp((char const   *)buf, "ICY", (size_t )3);
  }
  }
#line 742
  if (tmp___6 == 0) {
#line 744
    (con->food.source)->protocol = (protocol_t )0;
  } else {
    {
    {
#line 746
    tmp___3 = strstr((char const   *)buf, "Server:");
    }
#line 746
    ptr = tmp___3;
    }
#line 747
    if (ptr) {
      {
      {
#line 749
      tmp___4 = ice_strncmp((char const   *)(ptr + 1), " icecast/1.1", (size_t )12);
      }
      }
#line 749
      if (tmp___4 == 0) {
#line 751
        (con->food.source)->protocol = (protocol_t )0;
      } else {
        {
        {
#line 749
        tmp___5 = ice_strncmp((char const   *)(ptr + 1), " icecast/1.2", (size_t )12);
        }
        }
#line 749
        if (tmp___5 == 0) {
#line 751
          (con->food.source)->protocol = (protocol_t )0;
        } else {
#line 753
          (con->food.source)->protocol = (protocol_t )1;
        }
      }
    } else {
#line 755
      (con->food.source)->protocol = (protocol_t )0;
    }
  }
#line 759
  return (1);
}
}
#line 766 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c"
int relay_setup_connection(connection_t **con , request_t *req ) 
{ 
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 769
  *con = create_connection();
  }
#line 770
  (*con)->type = (contype_t )1;
  {
#line 771
  tmp = n_malloc((unsigned int const   )20, (int const   )771, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
  }
  {
#line 771
  (*con)->host = forward((char const   *)(req->host), (char *)tmp);
  }
  }
#line 772
  if ((unsigned long )(*con)->host == (unsigned long )((void *)0)) {
    {
    {
#line 773
    (*con)->host = n_strdup((char const   *)(req->host), (int const   )773, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/relay.c");
    }
    }
  }
  {
  {
#line 774
  (*con)->id = new_id();
  }
  }
#line 775
  if (info.reverse_lookups) {
    {
    {
#line 776
    (*con)->hostname = reverse((char const   *)(*con)->host);
    }
    }
  }
  {
  {
#line 778
  put_source(*con);
  }
#line 779
  ((*con)->food.source)->type = (source_type_t )1;
  }
#line 780
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 146 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 219
extern int fflush(FILE *__stream ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 367
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 357
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 64 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 141
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 190
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 368 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 370
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 74
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
#line 55 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.h"
int sock_set_keepalive(SOCKET sockfd , int const   keepalive ) ;
#line 56
int sock_set_no_linger(SOCKET sockfd ) ;
#line 57
int sock_valid(SOCKET const   sockfd ) ;
#line 60
SOCKET sock_socket(int domain , int type , int protocol ) ;
#line 61
SOCKET sock_accept(SOCKET s , struct sockaddr *addr , socklen_t *addrlen ) ;
#line 62
SOCKET sock_create_udp_socket(void) ;
#line 63
char *sock_get_local_ipaddress(void) ;
#line 64
void sock_close_all_sockets(void) ;
#line 65
void sock_dump_fd(SOCKET s , int ffd , int size ) ;
#line 68
SOCKET sock_get_server_socket(int const   port ) ;
#line 72
int sock_write_bytes(SOCKET sockfd , char const   *buff , int len ) ;
#line 73
int sock_read_line_nb(SOCKET sock , char *buff , int const   len ) ;
#line 74
int sock_write_bytes_or_kick(SOCKET sockfd , connection_t *clicon , char const   *buff ,
                             int const   len ) ;
#line 75
int sock_write(SOCKET sockfd , char const   *fmt  , ...) ;
#line 77
int sock_write_string(SOCKET sockfd , char const   *buff ) ;
#line 81
int sock_read_lines_np(SOCKET sockfd , char *buff , int const   len ) ;
#line 82
int sock_read_line(SOCKET sockfd , char *buff , int const   len ) ;
#line 36 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.h"
struct hostent *ice_gethostbyname(char const   *hostname , struct hostent *res , char *buffer ,
                                  int buflen , int *error ) ;
#line 38
void ice_clean_hostent(void) ;
#line 35 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.h"
int fd_close(int fd ) ;
#line 31 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.h"
void clean_shutdown(server_info_t *info___0 ) ;
#line 100 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void my_sleep(int microseconds ) ;
#line 102
int is_recoverable(int error ) ;
#line 37 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *makeasciihost(struct in_addr  const  *in , char *buf ) ;
#line 44
size_t ice_strlen(char const   *string ) ;
#line 90 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int running ;
#line 93
struct in_addr localaddr ;
#line 144 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
SOCKET sock_create_udp_socket(void) 
{ 
  SOCKET s ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 148
  xa_debug(1, (char *)"DEBUG: Creating udp socket\n");
  }
  {
#line 150
  s = sock_socket(2, 2, 0);
  }
  }
#line 152
  if (s < 0) {
    {
    {
#line 153
    xa_debug(1, (char *)"WARNING: Creation of udp socket failed!");
    }
    }
  }
#line 154
  return (s);
}
}
#line 163 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_valid(SOCKET const   sockfd ) 
{ 


  {
#line 166
  return ((int )sockfd >= 0);
}
}
#line 174 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_set_keepalive(SOCKET sockfd , int const   keepalive ) 
{ 
  int optval ;
  int res ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 176
  optval = (int )keepalive;
  {
#line 179
  xa_debug(4, (char *)"DEBUG: Setting socket %d keepalive to %d", sockfd, keepalive);
  }
  {
#line 181
  res = setsockopt(sockfd, 1, 9, (void const   *)((void *)(& optval)), (socklen_t )sizeof(int ));
  }
  }
#line 183
  if (res == -1) {
    {
    {
#line 184
    xa_debug(1, (char *)"WARNING: sock_set_keepalive() failed");
    }
    }
#line 185
    return (-1);
  }
#line 199
  return (res);
}
}
#line 203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_set_no_linger(SOCKET sockfd ) 
{ 
  struct linger lin ;
  int res ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 205
  lin.l_onoff = 0;
#line 205
  lin.l_linger = 0;
  {
#line 208
  xa_debug(4, (char *)"DEBUG: Setting socket %d to no linger", sockfd);
  }
  {
#line 210
  res = setsockopt(sockfd, 1, 13, (void const   *)((void *)(& lin)), (socklen_t )sizeof(struct linger ));
  }
  }
#line 212
  if (res == -1) {
    {
    {
#line 213
    xa_debug(1, (char *)"WARNING: sock_set_no_linger() failed");
    }
    }
#line 214
    return (-1);
  }
#line 227
  return (res);
}
}
#line 235 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_set_blocking(SOCKET sockfd , int const   block ) 
{ 
  int res ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 243
  if (block == 0) {
#line 243
    tmp = "blocking";
  } else {
#line 243
    tmp = "nonblocking";
  }
  {
  {
#line 243
  xa_debug(3, (char *)"Setting fd %d to %s", sockfd, tmp);
  }
  {
#line 246
  tmp___0 = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 246
  if (tmp___0) {
#line 250
    if (block < 0) {
      {
      {
#line 251
      xa_debug(1, (char *)"ERROR: sock_set_blocking() called with invalid block value");
      }
      }
#line 253
      return (-1);
    } else
#line 250
    if (block > 1) {
      {
      {
#line 251
      xa_debug(1, (char *)"ERROR: sock_set_blocking() called with invalid block value");
      }
      }
#line 253
      return (-1);
    }
  } else {
    {
    {
#line 247
    xa_debug(1, (char *)"ERROR: sock_set_blocking() called with invalid socket");
    }
    }
#line 249
    return (-1);
  }
#line 258
  if (block == 0) {
#line 258
    tmp___1 = 0;
  } else {
#line 258
    tmp___1 = 2048;
  }
  {
  {
#line 258
  res = fcntl(sockfd, 4, tmp___1);
  }
  }
#line 260
  if (res == -1) {
    {
    {
#line 261
    xa_debug(1, (char *)"WARNING: sock_set_blocking() on socket %d failed", sockfd);
    }
    }
#line 262
    return (-1);
  }
#line 276
  return (res);
}
}
#line 370 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
SOCKET sock_socket(int domain , int type , int protocol ) 
{ 
  SOCKET s ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 372
  tmp = socket(domain, type, protocol);
  }
#line 372
  s = tmp;
  {
#line 374
  xa_debug(4, (char *)"DEBUG: sock_socket() creating socket %d", s);
  }
  {
#line 376
  tmp___0 = sock_valid((SOCKET const   )s);
  }
  }
#line 376
  if (tmp___0) {
    {
    {
#line 383
    sock_set_keepalive(s, (int const   )1);
    }
    {
#line 389
    sock_set_no_linger(s);
    }
    }
  }
#line 393
  return (s);
}
}
#line 396 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
SOCKET sock_accept(SOCKET s , struct sockaddr *addr , socklen_t *addrlen ) 
{ 
  SOCKET rs ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 398
  tmp = accept(s, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)addrlen);
  }
#line 398
  rs = tmp;
  {
#line 400
  xa_debug(4, (char *)"DEBUG: sock_accept() created socket %d", s);
  }
  {
#line 402
  tmp___0 = sock_valid((SOCKET const   )rs);
  }
  }
#line 402
  if (tmp___0) {
    {
    {
#line 409
    sock_set_keepalive(rs, (int const   )1);
    }
    {
#line 415
    sock_set_no_linger(rs);
    }
    }
  }
#line 419
  return (rs);
}
}
#line 425 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
void sock_close_all_sockets(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 429
  write_log(0, (char *)"Closing all remaining sockets...");
  }
  {
#line 430
  my_sleep(30000);
  }
  }
#line 431
  return;
}
}
#line 437 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_close(SOCKET sockfd ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 439
  xa_debug(4, (char *)"DEBUG: sock_close: Closing socket %d", sockfd);
  }
  {
#line 453
  tmp = fd_close(sockfd);
  }
  }
#line 453
  return (tmp);
}
}
#line 463 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_write_bytes_or_kick(SOCKET sockfd , connection_t *clicon , char const   *buff ,
                             int const   len ) 
{ 
  int res ;
  int err ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 469
  tmp = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 469
  if (tmp) {
#line 473
    if (! clicon) {
      {
      {
#line 474
      xa_debug(1, (char *)"ERROR: sock_write_bytes_or_kick() called with NULL client");
      }
      }
#line 476
      return (-1);
    } else
#line 477
    if (! buff) {
      {
      {
#line 478
      xa_debug(1, (char *)"ERROR: sock_write_bytes_or_kick() called with NULL data");
      }
      }
#line 480
      return (-1);
    } else
#line 481
    if (len <= 0) {
      {
      {
#line 482
      xa_debug(1, (char *)"ERROR: sock_write_bytes_or_kick() called with invalid length");
      }
      }
#line 484
      return (-1);
    }
  } else {
    {
    {
#line 470
    xa_debug(1, (char *)"ERROR: sock_write_bytes_or_kick() called with invalid socket");
    }
    }
#line 472
    return (-1);
  }
  {
  {
#line 487
  tmp___0 = __errno_location();
  }
#line 487
  *tmp___0 = 666;
  {
#line 491
  res = sock_write_bytes(sockfd, buff, (int )len);
  }
  {
#line 492
  tmp___1 = __errno_location();
  }
#line 492
  err = *tmp___1;
  }
#line 494
  if (res < 0) {
    {
    {
#line 495
    xa_debug(4, (char *)"DEBUG: sock_write_bytes_or_kick: %d err [%d]", res, err);
    }
    {
#line 498
    tmp___2 = __errno_location();
    }
    {
#line 498
    tmp___3 = is_recoverable(*tmp___2);
    }
    }
#line 498
    if (! tmp___3) {
      {
      {
#line 499
      kick_connection((void *)clicon, (void *)"Client signed off");
      }
      }
#line 500
      return (-1);
    }
  }
#line 503
  return (res);
}
}
#line 511 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_write_bytes(SOCKET sockfd , char const   *buff , int len ) 
{ 
  int t ;
  int tmp ;
  int n ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 515
  if (! buff) {
    {
    {
#line 516
    xa_debug(1, (char *)"ERROR: sock_write_bytes() called with NULL data");
    }
    }
#line 518
    return (-1);
  } else
#line 519
  if (len <= 0) {
    {
    {
#line 520
    xa_debug(1, (char *)"ERROR: sock_write_bytes() called with zero or negative len");
    }
    }
#line 522
    return (-1);
  } else {
    {
    {
#line 523
    tmp = sock_valid((SOCKET const   )sockfd);
    }
    }
#line 523
    if (! tmp) {
      {
      {
#line 524
      xa_debug(1, (char *)"ERROR: sock_write_bytes() called with invalid socket");
      }
      }
#line 526
      return (-1);
    }
  }
#line 529
  t = 0;
  {
  {
#line 529
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 529
    if (! (len > 0)) {
#line 529
      goto while_break;
    }
    {
    {
#line 530
    tmp___0 = send(sockfd, (void const   *)(buff + t), (size_t )len, 0);
    }
#line 530
    n = tmp___0;
    }
#line 532
    if (n < 0) {
#line 533
      if (t == 0) {
#line 533
        tmp___1 = n;
      } else {
#line 533
        tmp___1 = t;
      }
#line 533
      return (tmp___1);
    }
#line 534
    t += n;
#line 535
    len -= n;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 538
  return (t);
}
}
#line 546 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_write_string(SOCKET sockfd , char const   *buff ) 
{ 
  int write_bytes ;
  int res ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 548
  write_bytes = 0;
#line 548
  res = 0;
  {
#line 548
  tmp = ice_strlen(buff);
  }
#line 548
  len = (int )tmp;
  {
#line 550
  tmp___0 = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 550
  if (tmp___0) {
#line 554
    if (! buff) {
      {
      {
#line 555
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: sock_write_string() called with NULL format\n");
      }
      }
#line 557
      return (-1);
    }
  } else {
    {
    {
#line 551
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: sock_write_string() called with invalid socket\n");
    }
    }
#line 553
    return (-1);
  }
#line 567
  if (sockfd == 1) {
#line 567
    goto _L;
  } else
#line 567
  if (sockfd == 0) {
    _L: /* CIL Label */ 
#line 568
    if (running == 1) {
#line 568
      if (info.console_mode == 1) {
        {
        {
#line 571
        write_bytes = fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                              buff);
        }
        {
#line 572
        fflush(stdout);
        }
        }
      } else
#line 568
      if (info.console_mode == 0) {
        {
        {
#line 571
        write_bytes = fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                              buff);
        }
        {
#line 572
        fflush(stdout);
        }
        }
      }
    }
  } else {
    {
    {
#line 575
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 575
      if (! (write_bytes < len)) {
#line 575
        goto while_break;
      }
      {
      {
#line 576
      res = send(sockfd, (void const   *)(buff + write_bytes), (size_t )(len - write_bytes),
                 0);
      }
      }
#line 579
      if (res < 0) {
        {
        {
#line 579
        tmp___1 = __errno_location();
        }
        {
#line 579
        tmp___2 = is_recoverable(*tmp___1);
        }
        }
#line 579
        if (! tmp___2) {
#line 580
          return (0);
        }
      }
#line 581
      if (res > 0) {
#line 582
        write_bytes += res;
      } else {
        {
        {
#line 584
        my_sleep(30000);
        }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 588
  if (write_bytes == len) {
#line 588
    tmp___3 = 1;
  } else {
#line 588
    tmp___3 = 0;
  }
#line 588
  return (tmp___3);
}
}
#line 599 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_write(SOCKET sockfd , char const   *fmt  , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp6 ;

  {
  {
  {
#line 604
  __builtin_va_start(ap, fmt);
  }
  {
#line 605
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 606
  __builtin_va_end(ap);
  }
  {
#line 608
  tmp = sock_write_string(sockfd, (char const   *)(buff));
  }
  }
#line 608
  return (tmp);
}
}
#line 619 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_write_line(SOCKET sockfd , char const   *fmt  , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 624
  __builtin_va_start(ap, fmt);
  }
  {
#line 625
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 626
  tmp = sock_write(sockfd, "%s\r\n", buff);
  }
  }
#line 626
  return (tmp);
}
}
#line 636 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_read_lines_np(SOCKET sockfd , char *buff , int const   len ) 
{ 
  char c ;
  int read_bytes ;
  int pos ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 638
  c = (char )'\000';
#line 639
  pos = 0;
  {
#line 641
  tmp = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 641
  if (tmp) {
#line 645
    if (! buff) {
      {
      {
#line 646
      xa_debug(1, (char *)"ERROR: sock_read_lines_np() called with NULL storage pointer");
      }
      }
#line 648
      return (0);
    } else
#line 649
    if (len <= 0) {
      {
      {
#line 650
      xa_debug(1, (char *)"ERROR: sock_read_lines_np() called with invalid length");
      }
      }
#line 652
      return (0);
    }
  } else {
    {
    {
#line 642
    xa_debug(1, (char *)"ERROR: sock_read_lines_np() called with invalid socket");
    }
    }
#line 644
    return (0);
  }
  {
  {
#line 657
  tmp___0 = __errno_location();
  }
#line 657
  *tmp___0 = 0;
  {
#line 660
  read_bytes = recv(sockfd, (void *)(& c), (size_t )1, 0);
  }
  }
#line 662
  if (read_bytes < 0) {
    {
    {
#line 663
    tmp___1 = __errno_location();
    }
    {
#line 663
    xa_debug(1, (char *)"DEBUG: Socket error on socket %d %d", sockfd, *tmp___1);
    }
    }
#line 665
    return (0);
  }
  {
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 668
    if (read_bytes == 1) {
#line 668
      if (! (pos < (int )(len - 1))) {
#line 668
        goto while_break;
      }
    } else {
#line 668
      goto while_break;
    }
#line 669
    if ((int )c != 13) {
#line 670
      tmp___2 = pos;
#line 670
      pos ++;
#line 670
      *(buff + tmp___2) = c;
    }
#line 671
    if (pos > 1) {
#line 671
      if ((int )*(buff + (pos - 1)) == 10) {
#line 671
        if ((int )*(buff + (pos - 2)) == 10) {
#line 673
          goto while_break;
        }
      }
    }
    {
    {
#line 677
    tmp___3 = __errno_location();
    }
#line 677
    *tmp___3 = 0;
    {
#line 679
    read_bytes = recv(sockfd, (void *)(& c), (size_t )1, 0);
    }
    }
#line 680
    if (read_bytes < 0) {
      {
      {
#line 681
      tmp___4 = __errno_location();
      }
      {
#line 681
      xa_debug(1, (char *)"DEBUG: Socket error on socket %d %d", sockfd, *tmp___4);
      }
      }
#line 683
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  if (read_bytes == 1) {
#line 688
    *(buff + pos) = (char )'\000';
#line 689
    return (1);
  } else {
#line 691
    return (0);
  }
}
}
#line 699 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_read_lines(SOCKET sockfd , char *buff , int const   len ) 
{ 
  char c[2] ;
  int read_bytes ;
  int pos ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 702
  pos = 0;
  {
#line 704
  tmp = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 704
  if (tmp) {
#line 708
    if (! buff) {
      {
      {
#line 709
      xa_debug(1, (char *)"ERROR: sock_read_lines() called with NULL storage pointer");
      }
      }
#line 711
      return (0);
    } else
#line 712
    if (len <= 0) {
      {
      {
#line 713
      xa_debug(1, (char *)"ERROR: sock_read_lines() called with invalid length");
      }
      }
#line 715
      return (0);
    }
  } else {
    {
    {
#line 705
    xa_debug(1, (char *)"ERROR: sock_read_lines() called with invalid socket");
    }
    }
#line 707
    return (0);
  }
  {
#line 718
  c[1] = (char )'\000';
#line 718
  c[0] = c[1];
  {
#line 723
  tmp___0 = __errno_location();
  }
#line 723
  *tmp___0 = 0;
  {
#line 726
  read_bytes = recv(sockfd, (void *)(& c[0]), (size_t )1, 0);
  }
  }
#line 728
  if (read_bytes < 0) {
    {
    {
#line 729
    tmp___1 = __errno_location();
    }
    {
#line 729
    xa_debug(1, (char *)"DEBUG: Socket error on socket %d %d", sockfd, *tmp___1);
    }
    }
#line 731
    return (0);
  }
  {
  {
#line 734
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 734
    if (read_bytes == 1) {
#line 734
      if (! (pos < (int )(len - 1))) {
#line 734
        goto while_break;
      }
    } else {
#line 734
      goto while_break;
    }
#line 735
    if ((int )c[0] == 10) {
#line 735
      if (pos < 1) {
#line 738
        return (2);
      }
    }
#line 739
    if ((int )c[0] != 13) {
#line 740
      tmp___2 = pos;
#line 740
      pos ++;
#line 740
      *(buff + tmp___2) = c[0];
    }
#line 741
    if (pos > 1) {
#line 741
      if ((int )*(buff + (pos - 1)) == 10) {
#line 741
        if ((int )*(buff + (pos - 2)) == 10) {
#line 743
          goto while_break;
        }
      }
    }
#line 744
    if ((int )c[0] == 10) {
      {
      {
#line 744
      tmp___3 = strchr((char const   *)buff, ' ');
      }
      }
#line 744
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 747
        goto while_break;
      }
    }
    {
    {
#line 751
    tmp___4 = __errno_location();
    }
#line 751
    *tmp___4 = 0;
    {
#line 753
    read_bytes = recv(sockfd, (void *)(& c[0]), (size_t )1, 0);
    }
    }
#line 754
    if (read_bytes < 0) {
      {
      {
#line 755
      tmp___5 = __errno_location();
      }
      {
#line 755
      xa_debug(1, (char *)"DEBUG: Socket error on socket %d %d", sockfd, *tmp___5);
      }
      }
#line 757
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  if (read_bytes == 1) {
#line 762
    *(buff + pos) = (char )'\000';
#line 763
    return (1);
  } else {
#line 765
    return (0);
  }
}
}
#line 775 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_read_line(SOCKET sockfd , char *buff , int const   len ) 
{ 
  char c ;
  int read_bytes ;
  int pos ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 777
  c = (char )'\000';
  {
#line 780
  tmp = sock_valid((SOCKET const   )sockfd);
  }
  }
#line 780
  if (tmp) {
#line 784
    if (! buff) {
      {
      {
#line 785
      xa_debug(1, (char *)"ERROR: sock_read_lines() called with NULL storage pointer");
      }
      }
#line 787
      return (0);
    } else
#line 788
    if (len <= 0) {
      {
      {
#line 789
      xa_debug(1, (char *)"ERROR: sock_read_lines() called with invalid length");
      }
      }
#line 791
      return (0);
    }
  } else {
    {
    {
#line 781
    xa_debug(1, (char *)"ERROR: sock_read_line() called with invalid socket");
    }
    }
#line 783
    return (0);
  }
  {
#line 794
  pos = 0;
  {
#line 795
  read_bytes = recv(sockfd, (void *)(& c), (size_t )1, 0);
  }
  }
#line 797
  if (read_bytes < 0) {
    {
    {
#line 798
    xa_debug(1, (char *)"DEBUG: Socket error on socket %d", sockfd);
    }
    }
#line 799
    return (0);
  }
  {
  {
#line 802
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 802
    if ((int )c != 10) {
#line 802
      if (pos < (int )len) {
#line 802
        if (! (read_bytes == 1)) {
#line 802
          goto while_break;
        }
      } else {
#line 802
        goto while_break;
      }
    } else {
#line 802
      goto while_break;
    }
#line 803
    if ((int )c != 13) {
#line 804
      tmp___0 = pos;
#line 804
      pos ++;
#line 804
      *(buff + tmp___0) = c;
    }
    {
    {
#line 805
    read_bytes = recv(sockfd, (void *)(& c), (size_t )1, 0);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  if (read_bytes == 1) {
#line 809
    *(buff + pos) = (char )'\000';
#line 810
    return (1);
  } else {
#line 812
    return (0);
  }
}
}
#line 816 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
int sock_read_line_nb(SOCKET sock , char *buff , int const   len ) 
{ 
  char c ;
  int read_bytes ;
  int pos ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 818
  c = (char )'\000';
#line 824
  if (! buff) {
    {
    {
#line 825
    xa_debug(1, (char *)"ERROR: sock_read_line_nb() called with NULL storage pointer");
    }
    }
#line 827
    return (0);
  } else
#line 828
  if (len <= 0) {
    {
    {
#line 829
    xa_debug(1, (char *)"ERROR: sock_read_line_nb() called with invalid length");
    }
    }
#line 831
    return (0);
  }
#line 834
  pos = 0;
#line 834
  read_bytes = pos;
  {
  {
#line 836
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 837
    read_bytes = recv(sock, (void *)(& c), (size_t )1, 0);
    }
    }
#line 839
    if (read_bytes <= 0) {
      {
      {
#line 840
      tmp___0 = __errno_location();
      }
      {
#line 840
      tmp___1 = is_recoverable(*tmp___0);
      }
      }
#line 840
      if (tmp___1) {
#line 840
        if (read_bytes == 0) {
          {
          {
#line 841
          tmp = __errno_location();
          }
          {
#line 841
          xa_debug(1, (char *)"DEBUG: read error on file descriptor %d [%d]", sock,
                   *tmp);
          }
          }
#line 844
          return (0);
        } else {
          {
          {
#line 846
          my_sleep(30000);
          }
          }
        }
      } else {
        {
        {
#line 841
        tmp = __errno_location();
        }
        {
#line 841
        xa_debug(1, (char *)"DEBUG: read error on file descriptor %d [%d]", sock,
                 *tmp);
        }
        }
#line 844
        return (0);
      }
    }
#line 850
    if ((int )c != 13) {
#line 850
      if (read_bytes > 0) {
#line 851
        tmp___2 = pos;
#line 851
        pos ++;
#line 851
        *(buff + tmp___2) = c;
      }
    }
#line 836
    if (pos < (int )len) {
#line 836
      if (! ((int )c != 10)) {
#line 836
        goto while_break;
      }
    } else {
#line 836
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  *(buff + pos) = (char )'\000';
#line 857
  if (pos > 0) {
#line 857
    tmp___3 = 1;
  } else
#line 857
  if ((int )c == 10) {
#line 857
    tmp___3 = 1;
  } else {
#line 857
    tmp___3 = 0;
  }
#line 857
  return (tmp___3);
}
}
#line 867 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
SOCKET sock_get_server_socket(int const   port ) 
{ 
  struct sockaddr_in sin ;
  char *buf ;
  int sin_len ;
  int error ;
  SOCKET sockfd ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct hostent *hostinfoptr ;
  struct hostent hostinfo ;
  char buf___0[8192] ;
  int error___0 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 874
  if (port < 0) {
    {
    {
#line 875
    write_log(0, (char *)"ERROR: Invalid port number %d. Cannot listen for requests, this is bad!",
              port);
    }
    }
#line 878
    return (-1);
  }
  {
  {
#line 881
  xa_debug(2, (char *)"DEBUG: Getting socket for port %d", port);
  }
  {
#line 883
  tmp = n_malloc((unsigned int const   )20, (int const   )883, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
  }
#line 883
  buf = (char *)tmp;
  {
#line 888
  sockfd = sock_socket(2, 1, 0);
  }
  }
#line 889
  if (sockfd == -1) {
#line 890
    return (-1);
  }
  {
#line 897
  tmp___0 = 1;
  {
#line 899
  tmp___1 = setsockopt(sockfd, 1, 2, (void const   *)(& tmp___0), (socklen_t )sizeof(tmp___0));
  }
  }
#line 899
  if (tmp___1 != 0) {
    {
    {
#line 902
    write_log(0, (char *)"ERROR: setsockopt() failed to set SO_REUSEADDR flag. (mostly harmless)");
    }
    }
  }
  {
#line 910
  sin_len = (int )sizeof(sin);
  {
#line 911
  memset((void *)(& sin), 0, (size_t )sin_len);
  }
#line 912
  sin.sin_family = (sa_family_t )2;
  }
#line 914
  if ((unsigned long )info.myhostname != (unsigned long )((void *)0)) {
#line 914
    if (*(info.myhostname + 0)) {
      {
      {
#line 915
      tmp___3 = __ctype_b_loc();
      }
      }
#line 915
      if ((int const   )*(*tmp___3 + (int )*(info.myhostname + 0)) & 2048) {
        {
        {
#line 915
        tmp___4 = __ctype_b_loc();
        }
        {
#line 915
        tmp___5 = ice_strlen((char const   *)info.myhostname);
        }
        }
#line 915
        if ((int const   )*(*tmp___4 + (int )*(info.myhostname + (tmp___5 - 1U))) & 2048) {
          {
          {
#line 918
          tmp___2 = inet_aton((char const   *)info.myhostname, & localaddr);
          }
          }
#line 918
          if (tmp___2 == 0) {
            {
            {
#line 921
            write_log(0, (char *)"ERROR: Invalid ip number %s, will die now", info.myhostname);
            }
            {
#line 924
            clean_shutdown(& info);
            }
            }
          }
        } else {
#line 915
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 931
        hostinfoptr = ice_gethostbyname((char const   *)info.myhostname, & hostinfo,
                                        buf___0, 8192, & error___0);
        }
        }
#line 934
        if ((unsigned long )hostinfoptr == (unsigned long )((void *)0)) {
          {
          {
#line 935
          write_log(0, (char *)"Unknown host %s, that\'s it for me!", info.myhostname);
          }
          {
#line 938
          ice_clean_hostent();
          }
          {
#line 939
          clean_shutdown(& info);
          }
          }
        }
        {
#line 941
        sin.sin_addr = *((struct in_addr *)*(hostinfoptr->h_addr_list + 0));
        {
#line 943
        memcpy((void */* __restrict  */)((void *)(& localaddr)), (void const   */* __restrict  */)*(hostinfoptr->h_addr_list + 0),
               (size_t )sizeof(localaddr));
        }
        {
#line 945
        ice_clean_hostent();
        }
        }
      }
    } else {
      {
      {
#line 948
      sin.sin_addr.s_addr = htonl((in_addr_t )0);
      }
      }
    }
  } else {
    {
    {
#line 948
    sin.sin_addr.s_addr = htonl((in_addr_t )0);
    }
    }
  }
  {
  {
#line 951
  sin.sin_port = htons((uint16_t )port);
  }
  {
#line 960
  error = bind(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
               (socklen_t )sin_len);
  }
  }
#line 961
  if (error == -1) {
    {
    {
#line 962
    write_log(0, (char *)"Bind to socket on port %d failed. Shutting down now.", port);
    }
    {
#line 965
    clean_shutdown(& info);
    }
    }
  }
#line 968
  return (sockfd);
}
}
#line 975 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
SOCKET sock_connect_wto(char const   *hostname , int const   port , int const   timeout ) 
{ 
  SOCKET sockfd ;
  struct sockaddr_in sin ;
  struct sockaddr_in server ;
  struct hostent *host ;
  struct hostent hostinfo ;
  char buf[8192] ;
  int error ;
  struct sockaddr_in localsin ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  char buf___0[50] ;
  fd_set wfds ;
  struct timeval tv ;
  int retval ;
  int val ;
  socklen_t valsize ;
  int __d0 ;
  int __d1 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 985
  if (! hostname) {
    {
    {
#line 986
    write_log(0, (char *)"ERROR: sock_connect() called with NULL or empty hostname");
    }
    }
#line 988
    return (-1);
  } else
#line 985
  if (! *(hostname + 0)) {
    {
    {
#line 986
    write_log(0, (char *)"ERROR: sock_connect() called with NULL or empty hostname");
    }
    }
#line 988
    return (-1);
  } else
#line 989
  if (port <= 0) {
    {
    {
#line 990
    write_log(0, (char *)"ERROR: sock_connect() called with invalid port number");
    }
    }
#line 992
    return (-1);
  }
  {
  {
#line 995
  sockfd = sock_socket(2, 1, 0);
  }
  }
#line 996
  if (sockfd == -1) {
    {
    {
#line 997
    sock_close(sockfd);
    }
    }
#line 998
    return (-1);
  }
#line 1001
  if ((unsigned long )info.myhostname != (unsigned long )((void *)0)) {
    {
    {
#line 1003
    memset((void *)(& localsin), 0, (size_t )sizeof(struct sockaddr_in ));
    }
    {
#line 1005
    xa_debug(2, (char *)"DEBUG: Trying to bind to %s", info.myhostname);
    }
#line 1007
    localsin.sin_addr = localaddr;
#line 1008
    localsin.sin_family = (sa_family_t )2;
#line 1009
    localsin.sin_port = (in_port_t )0;
    {
#line 1011
    tmp = bind(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& localsin)),
               (socklen_t )sizeof(localsin));
    }
    }
#line 1011
    if (tmp == -1) {
      {
      {
#line 1014
      xa_debug(2, (char *)"DEBUG: Unable to bind", info.myhostname);
      }
      {
#line 1015
      write_log(0, (char *)"ERROR: Bind to local address %s failed", info.myhostname);
      }
      {
#line 1018
      sock_close(sockfd);
      }
      }
#line 1019
      return (-1);
    }
  }
  {
  {
#line 1023
  memset((void *)(& sin), 0, (size_t )sizeof(sin));
  }
  {
#line 1024
  memset((void *)(& server), 0, (size_t )sizeof(struct sockaddr_in ));
  }
  {
#line 1026
  tmp___1 = __ctype_b_loc();
  }
  }
#line 1026
  if ((int const   )*(*tmp___1 + (int )*(hostname + 0)) & 2048) {
    {
    {
#line 1026
    tmp___2 = __ctype_b_loc();
    }
    {
#line 1026
    tmp___3 = ice_strlen(hostname);
    }
    }
#line 1026
    if ((int const   )*(*tmp___2 + (int )*(hostname + (tmp___3 - 1U))) & 2048) {
      {
      {
#line 1028
      tmp___0 = inet_aton(hostname, & sin.sin_addr);
      }
      }
#line 1028
      if (tmp___0 == 0) {
        {
        {
#line 1030
        write_log(0, (char *)"ERROR: Invalid ip number %s", hostname);
        }
        {
#line 1032
        sock_close(sockfd);
        }
        }
#line 1033
        return (-1);
      }
      {
      {
#line 1035
      memcpy((void */* __restrict  */)(& server.sin_addr), (void const   */* __restrict  */)(& sin.sin_addr),
             (size_t )sizeof(server.sin_addr));
      }
      }
    } else {
#line 1026
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 1037
    host = ice_gethostbyname(hostname, & hostinfo, buf, 8192, & error);
    }
    }
#line 1040
    if ((unsigned long )host == (unsigned long )((void *)0)) {
      {
      {
#line 1041
      xa_debug(1, (char *)"DEBUG: gethostbyname %s failed", hostname);
      }
      {
#line 1043
      sock_close(sockfd);
      }
      {
#line 1044
      ice_clean_hostent();
      }
      }
#line 1045
      return (-1);
    }
    {
    {
#line 1047
    memcpy((void */* __restrict  */)(& server.sin_addr), (void const   */* __restrict  */)*(host->h_addr_list + 0),
           (size_t )host->h_length);
    }
    {
#line 1048
    ice_clean_hostent();
    }
    }
  }
  {
#line 1051
  server.sin_family = (sa_family_t )2;
  {
#line 1052
  server.sin_port = htons((uint16_t )port);
  }
  {
#line 1057
  makeasciihost((struct in_addr  const  *)(& server.sin_addr), buf___0);
  }
  {
#line 1058
  xa_debug(1, (char *)"Trying to connect to %s:%d", buf___0, port);
  }
  }
#line 1068
  if (timeout > 0) {
    {
#line 1073
    valsize = (socklen_t )sizeof(int );
    {
#line 1075
    xa_debug(3, (char *)"DEBUG: sock_connect(): doing a connection w/ timeout");
    }
    }
    {
    {
#line 1078
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 1078
      __asm__  volatile   ("cld; rep; "
                           "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wfds.fds_bits[0]): "memory");
#line 1078
      goto while_break;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1079
    wfds.fds_bits[sockfd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sockfd % (8 * (int )sizeof(__fd_mask ));
#line 1080
    tv.tv_sec = (__time_t )timeout;
#line 1081
    tv.tv_usec = (__suseconds_t )0;
    {
#line 1083
    sock_set_blocking(sockfd, (int const   )1);
    }
    {
#line 1084
    retval = connect(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& server)),
                     (socklen_t )sizeof(server));
    }
    }
#line 1085
    if (retval == 0) {
      {
      {
#line 1086
      xa_debug(3, (char *)"DEBUG: sock_connect(): non blocking connect returned 0!");
      }
      {
#line 1087
      sock_set_blocking(sockfd, (int const   )0);
      }
      }
#line 1088
      return (sockfd);
    } else {
      {
      {
#line 1093
      tmp___5 = __errno_location();
      }
      {
#line 1093
      tmp___6 = is_recoverable(*tmp___5);
      }
      }
#line 1093
      if (! tmp___6) {
        {
        {
#line 1095
        tmp___4 = __errno_location();
        }
        {
#line 1095
        xa_debug(3, (char *)"DEBUG: sock_connect(): connect didn\'t return EINPROGRESS!, was: %d",
                 *tmp___4);
        }
        {
#line 1096
        sock_close(sockfd);
        }
        }
#line 1097
        return (-1);
      }
    }
    {
    {
#line 1101
    tmp___8 = select(sockfd + 1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)(& wfds),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
    }
#line 1101
    if (tmp___8) {
      {
      {
#line 1102
      retval = getsockopt(sockfd, 1, 4, (void */* __restrict  */)((void *)(& val)),
                          (socklen_t */* __restrict  */)(& valsize));
      }
      }
#line 1105
      if (retval == 0) {
#line 1105
        if (val == 0) {
          {
          {
#line 1106
          sock_set_blocking(sockfd, (int const   )0);
          }
          }
#line 1107
          return (sockfd);
        } else {
          {
          {
#line 1109
          tmp___7 = __errno_location();
          }
          {
#line 1109
          xa_debug(3, (char *)"DEBUG: sock_connect(): getsockopt returned %i, val = %i, valsize = %i, errno = %i!",
                   retval, val, valsize, *tmp___7);
          }
          {
#line 1112
          sock_close(sockfd);
          }
          }
#line 1113
          return (-1);
        }
      } else {
        {
        {
#line 1109
        tmp___7 = __errno_location();
        }
        {
#line 1109
        xa_debug(3, (char *)"DEBUG: sock_connect(): getsockopt returned %i, val = %i, valsize = %i, errno = %i!",
                 retval, val, valsize, *tmp___7);
        }
        {
#line 1112
        sock_close(sockfd);
        }
        }
#line 1113
        return (-1);
      }
    } else {
      {
      {
#line 1116
      xa_debug(3, (char *)"DEBUG: sock_connect(): select returned 0");
      }
      {
#line 1118
      sock_close(sockfd);
      }
      }
#line 1119
      return (-1);
    }
  } else {
    {
    {
#line 1122
    tmp___9 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& server)),
                      (socklen_t )sizeof(server));
    }
    }
#line 1122
    if (tmp___9 == 0) {
#line 1125
      return (sockfd);
    } else {
      {
      {
#line 1127
      sock_close(sockfd);
      }
      }
#line 1128
      return (-1);
    }
  }
}
}
#line 1186 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
char *sock_get_local_ipaddress(void) 
{ 
  SOCKET sockfd ;
  socklen_t sinlen ;
  struct sockaddr_in sin ;
  struct sockaddr_in cliaddr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 1190
  sinlen = (socklen_t )sizeof(struct sockaddr_in );
  {
#line 1193
  sockfd = sock_socket(2, 2, 0);
  }
  {
#line 1195
  memset((void *)(& sin), 0, (size_t )sizeof(sin));
  }
#line 1196
  sin.sin_family = (sa_family_t )2;
  {
#line 1197
  sin.sin_port = htons((uint16_t )info.port[0]);
  }
  {
#line 1202
  tmp___1 = inet_aton("130.240.1.1", & sin.sin_addr);
  }
  }
#line 1202
  if (! tmp___1) {
    {
    {
#line 1203
    tmp = __errno_location();
    }
    {
#line 1203
    xa_debug(1, (char *)"DEBUG: inet_aton() failed with [%d]", *tmp);
    }
    {
#line 1204
    tmp___0 = n_strdup("dynamic", (int const   )1204, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
    }
    }
#line 1204
    return (tmp___0);
  }
  {
  {
#line 1207
  tmp___4 = connect(sockfd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& sin)),
                    (socklen_t )sizeof(sin));
  }
  }
#line 1207
  if (tmp___4 == -1) {
    {
    {
#line 1208
    tmp___2 = __errno_location();
    }
    {
#line 1208
    xa_debug(1, (char *)"DEBUG: connect() failed with [%s]", *tmp___2);
    }
    {
#line 1209
    tmp___3 = n_strdup("dynamic", (int const   )1209, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
    }
    }
#line 1209
    return (tmp___3);
  }
  {
  {
#line 1213
  tmp___11 = getsockname(sockfd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& cliaddr)),
                         (socklen_t */* __restrict  */)(& sinlen));
  }
  }
#line 1213
  if (tmp___11 == 0) {
    {
    {
#line 1214
    close(sockfd);
    }
    {
#line 1215
    tmp___8 = inet_ntoa(cliaddr.sin_addr);
    }
    }
#line 1215
    if (tmp___8) {
      {
      {
#line 1216
      tmp___5 = inet_ntoa(cliaddr.sin_addr);
      }
      {
#line 1216
      tmp___6 = n_strdup((char const   *)tmp___5, (int const   )1216, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
      }
      }
#line 1216
      return (tmp___6);
    } else {
      {
      {
#line 1218
      tmp___7 = n_strdup("dynamic", (int const   )1218, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
      }
      }
#line 1218
      return (tmp___7);
    }
  } else {
    {
    {
#line 1220
    tmp___9 = __errno_location();
    }
    {
#line 1220
    xa_debug(1, (char *)"DEBUG: getsockname() failed with [%d]", *tmp___9);
    }
    {
#line 1221
    close(sockfd);
    }
    {
#line 1222
    tmp___10 = n_strdup("dynamic", (int const   )1222, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c");
    }
    }
#line 1222
    return (tmp___10);
  }
}
}
#line 1232 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/sock.c"
void sock_dump_fd(SOCKET s , int ffd , int size ) 
{ 
  char *fileptr ;
  int count ;
  int readlen ;
  int len ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1241
  tmp = malloc((size_t )(size + 2));
  }
#line 1241
  fileptr = (char *)tmp;
  }
#line 1242
  if (! fileptr) {
    {
    {
#line 1243
    sock_write_line(s, "ERROR: Cannot allocate enough memory, try again later");
    }
    }
#line 1245
    return;
  }
#line 1248
  readlen = 0;
#line 1248
  count = readlen;
  {
  {
#line 1249
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1249
    if (! (count < size)) {
#line 1249
      goto while_break;
    }
#line 1250
    if (2048 < size - count) {
#line 1250
      len = 2048;
    } else {
#line 1250
      len = size - count;
    }
    {
    {
#line 1251
    readlen = read(ffd, (void *)(fileptr + count), (size_t )len);
    }
    }
#line 1252
    if (readlen > 0) {
#line 1253
      count += readlen;
    } else {
      {
      {
#line 1255
      xa_debug(1, (char *)"DEBUG: Read error while parsing");
      }
      }
#line 1256
      return;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1260
  *(fileptr + count) = (char )'\000';
  {
#line 1261
  sock_close(ffd);
  }
#line 1263
  len = 0;
#line 1263
  readlen = len;
  }
  {
  {
#line 1264
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1264
    if (! (readlen < count)) {
#line 1264
      goto while_break___0;
    }
#line 1265
    if (2048 < count - readlen) {
#line 1265
      len = 2048;
    } else {
#line 1265
      len = count - readlen;
    }
    {
    {
#line 1266
    ffd = sock_write_bytes(s, (char const   *)(fileptr + readlen), len);
    }
    }
#line 1266
    if (ffd > 0) {
#line 1267
      readlen += ffd;
    } else {
      {
      {
#line 1269
      xa_debug(1, (char *)"DEBUG: write error while parsing ");
      }
      }
#line 1270
      return;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1273
  return;
}
}
#line 488 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 82 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
void thread_create_mutex_c(mutex_t *mutex , int line , char *file ) ;
#line 85
void thread_mutex_destroy(mutex_t *mutex ) ;
#line 87
void internal_lock_mutex(mutex_t *mutex ) ;
#line 88
void internal_unlock_mutex(mutex_t *mutex ) ;
#line 106
void thread_create_mutex_nl(mutex_t *mutex ) ;
#line 105 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.h"
avl_tree *avl_create(int (*cmp)(void const   *a , void const   *b , void *param ) ,
                     void *param ) ;
#line 106
avl_tree *avl_create_nl(int (*cmp)(void const   *a , void const   *b , void *param ) ,
                        void *param ) ;
#line 107
void avl_destroy(avl_tree *tree , void (*free_func)(void *data , void *param ) ) ;
#line 108
void avl_free(avl_tree *tree ) ;
#line 109
int avl_count(avl_tree const   *tree ) ;
#line 110
avl_tree *avl_copy(avl_tree *tree , void *(*copy)(void *data , void *param ) ) ;
#line 113
void avl_walk(avl_tree *tree , void (*walk_func)(void *data , void *param ) , void *param ) ;
#line 117
void **avl_probe(avl_tree *tree , void *item ) ;
#line 120
void *avl_find_close(avl_tree *tree , void const   *item ) ;
#line 144
void *avl_insert(avl_tree *tree , void *item ) ;
#line 157
void *avl_force_delete(avl_tree *tree , void *item ) ;
#line 86 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
static void *xmalloc(size_t size ) 
{ 
  void *vp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 90
  if (size == 0U) {
#line 91
    return ((void *)0);
  }
  {
  {
#line 92
  vp = malloc(size);
  }
  }
#line 94
  if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
    {
    {
#line 94
    __assert_fail("vp != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  94U, "xmalloc");
    }
    }
  }
#line 95
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"virtual memory exhausted\n");
    }
    {
#line 97
    exit(1);
    }
    }
  }
#line 100
  return (vp);
}
}
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
avl_tree *avl_create(int (*cmp)(void const   *a , void const   *b , void *param ) ,
                     void *param ) 
{ 
  avl_tree *tree ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 112
  if (! ((unsigned long )cmp != (unsigned long )((void *)0))) {
    {
    {
#line 112
    __assert_fail("cmp != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  112U, "avl_create");
    }
    }
  }
  {
  {
#line 118
  tmp = xmalloc((size_t )sizeof(avl_tree ));
  }
#line 118
  tree = (avl_tree *)tmp;
#line 123
  tree->root.link[0] = (struct avl_node *)((void *)0);
#line 124
  tree->root.link[1] = (struct avl_node *)((void *)0);
#line 125
  tree->cmp = cmp;
#line 126
  tree->count = 0;
#line 127
  tree->param = param;
  {
#line 128
  thread_create_mutex_c(& tree->mutex, 128, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c");
  }
  }
#line 130
  return (tree);
}
}
#line 137 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
avl_tree *avl_create_nl(int (*cmp)(void const   *a , void const   *b , void *param ) ,
                        void *param ) 
{ 
  avl_tree *tree ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 141
  if (! ((unsigned long )cmp != (unsigned long )((void *)0))) {
    {
    {
#line 141
    __assert_fail("cmp != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  141U, "avl_create_nl");
    }
    }
  }
  {
  {
#line 147
  tmp = xmalloc((size_t )sizeof(avl_tree ));
  }
#line 147
  tree = (avl_tree *)tmp;
#line 152
  tree->root.link[0] = (struct avl_node *)((void *)0);
#line 153
  tree->root.link[1] = (struct avl_node *)((void *)0);
#line 154
  tree->cmp = cmp;
#line 155
  tree->count = 0;
#line 156
  tree->param = param;
  {
#line 157
  thread_create_mutex_nl(& tree->mutex);
  }
  }
#line 158
  return (tree);
}
}
#line 169 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void avl_destroy(avl_tree *tree , void (*free_func)(void *data , void *param ) ) 
{ 
  avl_node *an[32] ;
  unsigned long ab ;
  int ap ;
  avl_node *p ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 171
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 171
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  171U, "avl_destroy");
    }
    }
  }
  {
  {
#line 173
  internal_lock_mutex(& tree->mutex);
  }
#line 183
  ab = 0UL;
#line 184
  ap = 0;
#line 185
  p = tree->root.link[0];
  }
  {
  {
#line 187
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 190
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 190
        goto while_break___0;
      }
#line 193
      ab &= ~ (1UL << ap);
#line 194
      tmp = ap;
#line 194
      ap ++;
#line 194
      an[tmp] = p;
#line 195
      p = p->link[0];
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 199
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 201
      if (ap == 0) {
#line 202
        goto done;
      }
#line 204
      ap --;
#line 204
      p = an[ap];
#line 205
      if ((ab & (1UL << ap)) == 0UL) {
#line 207
        tmp___0 = ap;
#line 207
        ap ++;
#line 207
        ab |= 1UL << tmp___0;
#line 208
        p = p->link[1];
#line 209
        goto while_break___1;
      }
#line 212
      if (free_func) {
        {
        {
#line 213
        (*free_func)(p->data, tree->param);
        }
        }
      }
      {
      {
#line 217
      free((void *)p);
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
  {
  {
#line 223
  internal_unlock_mutex(& tree->mutex);
  }
  {
#line 224
  thread_mutex_destroy(& tree->mutex);
  }
  {
#line 228
  free((void *)tree);
  }
  }
#line 229
  return;
}
}
#line 232 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void avl_free(avl_tree *tree ) 
{ 


  {
  {
  {
#line 235
  avl_destroy(tree, (void (*)(void *data , void *param ))(& free));
  }
  }
#line 236
  return;
}
}
#line 239 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
int avl_count(avl_tree const   *tree ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 242
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 242
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  242U, "avl_count");
    }
    }
  }
#line 243
  return ((int )tree->count);
}
}
#line 258 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
static avl_node *new_node(void) 
{ 
  void *tmp ;

  {
  {
  {
#line 261
  tmp = xmalloc((size_t )sizeof(avl_node ));
  }
  }
#line 261
  return ((avl_node *)tmp);
}
}
#line 273 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
avl_tree *avl_copy(avl_tree *tree , void *(*copy)(void *data , void *param ) ) 
{ 
  avl_tree *new_tree ;
  avl_node const   *pa[32] ;
  avl_node const   **pp ;
  avl_node const   *p ;
  avl_node *qa[32] ;
  avl_node **qp ;
  avl_node *q ;
  avl_node *r ;
  avl_node *tmp ;
  struct avl_node *tmp___0 ;
  avl_node const   **tmp___1 ;
  avl_node **tmp___2 ;
  avl_node *r___0 ;
  avl_node *tmp___3 ;
  struct avl_node *tmp___4 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 284
  pp = pa;
#line 285
  p = (avl_node const   *)(& tree->root);
#line 289
  qp = qa;
#line 292
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 292
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  292U, "avl_copy");
    }
    }
  }
  {
  {
#line 294
  internal_lock_mutex(& tree->mutex);
  }
  {
#line 299
  new_tree = avl_create(tree->cmp, tree->param);
  }
#line 301
  new_tree->count = tree->count;
#line 302
  q = & new_tree->root;
  }
  {
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 307
    if ((unsigned long )p->link[0] != (unsigned long )((void *)0)) {
      {
      {
#line 309
      tmp = new_node();
      }
#line 309
      r = tmp;
#line 310
      tmp___0 = (struct avl_node *)((void *)0);
#line 310
      r->link[1] = tmp___0;
#line 310
      r->link[0] = tmp___0;
#line 311
      q->link[0] = r;
      }
    }
#line 315
    goto start;
    {
    {
#line 316
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 319
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 319
        if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 319
          goto while_break___1;
        }
#line 321
        goto escape;
        start: 
#line 324
        tmp___1 = pp;
#line 324
        pp ++;
#line 324
        *tmp___1 = p;
#line 325
        tmp___2 = qp;
#line 325
        qp ++;
#line 325
        *tmp___2 = q;
#line 326
        p = (avl_node const   *)p->link[0];
#line 327
        q = q->link[0];
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 331
      if ((unsigned long )pp == (unsigned long )(pa)) {
#line 333
        if (! ((unsigned long )qp == (unsigned long )(qa))) {
          {
          {
#line 333
          __assert_fail("qp == qa", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                        333U, "avl_copy");
          }
          }
        }
        {
        {
#line 334
        internal_unlock_mutex(& tree->mutex);
        }
        }
#line 335
        return (new_tree);
      }
#line 338
      pp --;
#line 338
      p = *pp;
#line 339
      qp --;
#line 339
      q = *qp;
#line 342
      p = (avl_node const   *)p->link[1];
#line 343
      q = q->link[1];
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    escape: 
#line 348
    if (p->link[1]) {
      {
      {
#line 350
      tmp___3 = new_node();
      }
#line 350
      r___0 = tmp___3;
#line 351
      tmp___4 = (struct avl_node *)((void *)0);
#line 351
      r___0->link[1] = tmp___4;
#line 351
      r___0->link[0] = tmp___4;
#line 352
      q->link[1] = r___0;
      }
    }
#line 356
    q->bal = (signed char )p->bal;
#line 357
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 358
      q->data = (void *)p->data;
    } else {
      {
      {
#line 360
      q->data = (*copy)((void *)p->data, tree->param);
      }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 362
  internal_unlock_mutex(& tree->mutex);
  }
  }
}
}
#line 367 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void avl_walk(avl_tree *tree , void (*walk_func)(void *data , void *param ) , void *param ) 
{ 
  avl_node const   *an[32] ;
  avl_node const   **ap ;
  avl_node const   *p ;
  avl_node const   **tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 371
  if (tree) {
#line 371
    if (! walk_func) {
      {
      {
#line 371
      __assert_fail("tree && walk_func", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                    371U, "avl_walk");
      }
      }
    }
  } else {
    {
    {
#line 371
    __assert_fail("tree && walk_func", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  371U, "avl_walk");
    }
    }
  }
  {
  {
#line 372
  internal_lock_mutex(& tree->mutex);
  }
#line 376
  ap = an;
#line 377
  p = (avl_node const   *)tree->root.link[0];
  }
  {
  {
#line 379
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 382
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 382
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 382
        goto while_break___0;
      }
#line 385
      tmp = ap;
#line 385
      ap ++;
#line 385
      *tmp = p;
#line 386
      p = (avl_node const   *)p->link[0];
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    if ((unsigned long )ap == (unsigned long )(an)) {
      {
      {
#line 392
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 393
      return;
    }
    {
#line 395
    ap --;
#line 395
    p = *ap;
    {
#line 398
    (*walk_func)((void *)p->data, param);
    }
#line 399
    p = (avl_node const   *)p->link[1];
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 402
  internal_unlock_mutex(& tree->mutex);
  }
  }
}
}
#line 409 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_traverse(avl_tree *tree , avl_traverser *trav ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 412
  if (tree) {
#line 412
    if (! trav) {
      {
      {
#line 412
      __assert_fail("tree && trav", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                    412U, "avl_traverse");
      }
      }
    }
  } else {
    {
    {
#line 412
    __assert_fail("tree && trav", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  412U, "avl_traverse");
    }
    }
  }
  {
  {
#line 414
  internal_lock_mutex(& tree->mutex);
  }
  }
#line 417
  if (trav->init == 0) {
#line 420
    trav->init = 1;
#line 421
    trav->nstack = 0;
#line 422
    trav->p = (avl_node const   *)tree->root.link[0];
  } else {
#line 426
    trav->p = (avl_node const   *)(trav->p)->link[1];
  }
  {
  {
#line 428
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 431
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 431
      if (! ((unsigned long )trav->p != (unsigned long )((void *)0))) {
#line 431
        goto while_break___0;
      }
#line 434
      tmp = trav->nstack;
#line 434
      (trav->nstack) ++;
#line 434
      trav->stack[tmp] = trav->p;
#line 435
      trav->p = (avl_node const   *)(trav->p)->link[0];
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    if (trav->nstack == 0) {
      {
#line 441
      trav->init = 0;
      {
#line 442
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 443
      return ((void *)0);
    }
    {
#line 445
    (trav->nstack) --;
#line 445
    trav->p = trav->stack[trav->nstack];
    {
#line 448
    internal_unlock_mutex(& tree->mutex);
    }
    }
#line 449
    return ((void *)(trav->p)->data);
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 451
  internal_unlock_mutex(& tree->mutex);
  }
  }
}
}
#line 460 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void **avl_probe(avl_tree *tree , void *item ) 
{ 
  avl_node *t ;
  avl_node *s ;
  avl_node *p ;
  avl_node *q ;
  avl_node *r ;
  struct avl_node *tmp ;
  struct avl_node *tmp___0 ;
  int diff ;
  int tmp___1 ;
  struct avl_node *tmp___2 ;
  signed char tmp___3 ;
  signed char tmp___4 ;
  signed char tmp___5 ;
  signed char tmp___6 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
#line 472
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 472
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  472U, "avl_probe");
    }
    }
  }
  {
  {
#line 473
  internal_lock_mutex(& tree->mutex);
  }
#line 474
  t = & tree->root;
#line 475
  p = t->link[0];
#line 475
  s = p;
  }
#line 477
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 479
    (tree->count) ++;
#line 480
    if (! (tree->count == 1)) {
      {
      {
#line 480
      __assert_fail("tree->count == 1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                    480U, "avl_probe");
      }
      }
    }
    {
    {
#line 481
    tmp = new_node();
    }
#line 481
    t->link[0] = tmp;
#line 481
    q = tmp;
#line 482
    q->data = item;
#line 483
    tmp___0 = (struct avl_node *)((void *)0);
#line 483
    q->link[1] = tmp___0;
#line 483
    q->link[0] = tmp___0;
#line 484
    q->bal = (signed char)0;
    {
#line 485
    internal_unlock_mutex(& tree->mutex);
    }
    }
#line 486
    return (& q->data);
  }
  {
  {
#line 489
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 492
    tmp___1 = (*(tree->cmp))((void const   *)item, (void const   *)p->data, tree->param);
    }
#line 492
    diff = tmp___1;
    }
#line 495
    if (diff < 0) {
#line 497
      p->cache = (char)0;
#line 498
      q = p->link[0];
#line 499
      if ((unsigned long )q == (unsigned long )((void *)0)) {
        {
        {
#line 501
        q = new_node();
        }
#line 501
        p->link[0] = q;
        }
#line 502
        goto while_break;
      }
    } else
#line 506
    if (diff > 0) {
#line 508
      p->cache = (char)1;
#line 509
      q = p->link[1];
#line 510
      if ((unsigned long )q == (unsigned long )((void *)0)) {
        {
        {
#line 512
        q = new_node();
        }
#line 512
        p->link[1] = q;
        }
#line 513
        goto while_break;
      }
    } else {
      {
      {
#line 519
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 520
      return (& p->data);
    }
#line 524
    if ((int )q->bal != 0) {
#line 525
      t = p;
#line 525
      s = q;
    }
#line 526
    p = q;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  (tree->count) ++;
#line 531
  q->data = item;
#line 532
  tmp___2 = (struct avl_node *)((void *)0);
#line 532
  q->link[1] = tmp___2;
#line 532
  q->link[0] = tmp___2;
#line 533
  q->bal = (signed char)0;
#line 536
  p = s->link[(int )s->cache];
#line 536
  r = p;
  {
  {
#line 537
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 537
    if (! ((unsigned long )p != (unsigned long )q)) {
#line 537
      goto while_break___0;
    }
#line 539
    p->bal = (signed char )((int )p->cache * 2 - 1);
#line 540
    p = p->link[(int )p->cache];
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 544
  if ((int )s->cache == 0) {
#line 547
    if ((int )s->bal == 0) {
      {
#line 549
      s->bal = (signed char)-1;
      {
#line 550
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 551
      return (& q->data);
    } else
#line 553
    if ((int )s->bal == 1) {
      {
#line 555
      s->bal = (signed char)0;
      {
#line 556
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 557
      return (& q->data);
    }
#line 560
    if (! ((int )s->bal == -1)) {
      {
      {
#line 560
      __assert_fail("s->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                    560U, "avl_probe");
      }
      }
    }
#line 561
    if ((int )r->bal == -1) {
#line 564
      p = r;
#line 565
      s->link[0] = r->link[1];
#line 566
      r->link[1] = s;
#line 567
      tmp___3 = (signed char)0;
#line 567
      r->bal = tmp___3;
#line 567
      s->bal = tmp___3;
    } else {
#line 572
      if (! ((int )r->bal == 1)) {
        {
        {
#line 572
        __assert_fail("r->bal == +1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      572U, "avl_probe");
        }
        }
      }
#line 573
      p = r->link[1];
#line 574
      r->link[1] = p->link[0];
#line 575
      p->link[0] = r;
#line 576
      s->link[0] = p->link[1];
#line 577
      p->link[1] = s;
#line 578
      if ((int )p->bal == -1) {
#line 579
        s->bal = (signed char)1;
#line 579
        r->bal = (signed char)0;
      } else
#line 580
      if ((int )p->bal == 0) {
#line 581
        tmp___4 = (signed char)0;
#line 581
        r->bal = tmp___4;
#line 581
        s->bal = tmp___4;
      } else {
#line 584
        if (! ((int )p->bal == 1)) {
          {
          {
#line 584
          __assert_fail("p->bal == +1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                        584U, "avl_probe");
          }
          }
        }
#line 585
        s->bal = (signed char)0;
#line 585
        r->bal = (signed char)-1;
      }
#line 587
      p->bal = (signed char)0;
    }
  } else {
#line 593
    if ((int )s->bal == 0) {
      {
#line 595
      s->bal = (signed char)1;
      {
#line 596
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 597
      return (& q->data);
    } else
#line 599
    if ((int )s->bal == -1) {
      {
#line 601
      s->bal = (signed char)0;
      {
#line 602
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 603
      return (& q->data);
    }
#line 606
    if (! ((int )s->bal == 1)) {
      {
      {
#line 606
      __assert_fail("s->bal == +1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                    606U, "avl_probe");
      }
      }
    }
#line 607
    if ((int )r->bal == 1) {
#line 610
      p = r;
#line 611
      s->link[1] = r->link[0];
#line 612
      r->link[0] = s;
#line 613
      tmp___5 = (signed char)0;
#line 613
      r->bal = tmp___5;
#line 613
      s->bal = tmp___5;
    } else {
#line 618
      if (! ((int )r->bal == -1)) {
        {
        {
#line 618
        __assert_fail("r->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      618U, "avl_probe");
        }
        }
      }
#line 619
      p = r->link[0];
#line 620
      r->link[0] = p->link[1];
#line 621
      p->link[1] = r;
#line 622
      s->link[1] = p->link[0];
#line 623
      p->link[0] = s;
#line 624
      if ((int )p->bal == 1) {
#line 625
        s->bal = (signed char)-1;
#line 625
        r->bal = (signed char)0;
      } else
#line 626
      if ((int )p->bal == 0) {
#line 627
        tmp___6 = (signed char)0;
#line 627
        r->bal = tmp___6;
#line 627
        s->bal = tmp___6;
      } else {
#line 630
        if (! ((int )p->bal == -1)) {
          {
          {
#line 630
          __assert_fail("p->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                        630U, "avl_probe");
          }
          }
        }
#line 631
        s->bal = (signed char)0;
#line 631
        r->bal = (signed char)1;
      }
#line 633
      p->bal = (signed char)0;
    }
  }
#line 638
  if ((unsigned long )t != (unsigned long )(& tree->root)) {
#line 638
    if ((unsigned long )s == (unsigned long )t->link[1]) {
#line 639
      t->link[1] = p;
    } else {
#line 641
      t->link[0] = p;
    }
  } else {
#line 641
    t->link[0] = p;
  }
  {
  {
#line 643
  internal_unlock_mutex(& tree->mutex);
  }
  }
#line 644
  return (& q->data);
}
}
#line 648 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_find(avl_tree *tree , void const   *item ) 
{ 
  avl_node const   *p ;
  int diff ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 652
  p = (avl_node const   *)((void *)0);
#line 654
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 654
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  654U, "avl_find");
    }
    }
  }
  {
  {
#line 655
  internal_lock_mutex(& tree->mutex);
  }
#line 656
  p = (avl_node const   *)tree->root.link[0];
  }
  {
  {
#line 656
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 656
    if (! p) {
#line 656
      goto while_break;
    }
    {
    {
#line 658
    tmp = (*(tree->cmp))(item, (void const   *)p->data, tree->param);
    }
#line 658
    diff = tmp;
    }
#line 660
    if (diff < 0) {
#line 661
      p = (avl_node const   *)p->link[0];
    } else
#line 662
    if (diff > 0) {
#line 663
      p = (avl_node const   *)p->link[1];
    } else {
      {
      {
#line 666
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 667
      return ((void *)p->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 670
  internal_unlock_mutex(& tree->mutex);
  }
  }
#line 671
  return ((void *)0);
}
}
#line 676 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_find_close(avl_tree *tree , void const   *item ) 
{ 
  avl_node const   *p ;
  int diff ;
  int tmp ;
  int t ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 681
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 681
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  681U, "avl_find_close");
    }
    }
  }
#line 682
  p = (avl_node const   *)tree->root.link[0];
#line 683
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 684
    return ((void *)0);
  }
  {
  {
#line 685
  internal_lock_mutex(& tree->mutex);
  }
  }
  {
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 688
    tmp = (*(tree->cmp))(item, (void const   *)p->data, tree->param);
    }
#line 688
    diff = tmp;
    }
#line 691
    if (diff < 0) {
#line 692
      t = 0;
    } else
#line 693
    if (diff > 0) {
#line 694
      t = 1;
    } else {
      {
      {
#line 697
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 698
      return ((void *)p->data);
    }
#line 701
    if (p->link[t]) {
#line 702
      p = (avl_node const   *)p->link[t];
    } else {
      {
      {
#line 705
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 706
      return ((void *)p->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 709
  internal_unlock_mutex(& tree->mutex);
  }
  }
}
}
#line 716 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_delete(avl_tree *tree , void const   *item ) 
{ 
  avl_node *pa[32] ;
  char a[32] ;
  int k ;
  avl_node **q ;
  avl_node *p ;
  int diff ;
  int tmp ;
  avl_node *r ;
  int tmp___0 ;
  avl_node *s ;
  int l ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  avl_node *s___0 ;
  avl_node *r___0 ;
  signed char tmp___4 ;
  signed char tmp___5 ;
  signed char tmp___6 ;
  signed char tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 728
  k = 1;
#line 733
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 733
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  733U, "avl_delete");
    }
    }
  }
  {
  {
#line 734
  internal_lock_mutex(& tree->mutex);
  }
#line 736
  a[0] = (char)0;
#line 737
  pa[0] = & tree->root;
#line 738
  p = tree->root.link[0];
  }
  {
  {
#line 739
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 742
    tmp = (*(tree->cmp))(item, (void const   *)p->data, tree->param);
    }
#line 742
    diff = tmp;
    }
#line 744
    if (diff == 0) {
#line 745
      goto while_break;
    }
#line 748
    pa[k] = p;
#line 749
    if (diff < 0) {
#line 750
      p = p->link[0];
#line 750
      a[k] = (char)0;
    } else
#line 751
    if (diff > 0) {
#line 752
      p = p->link[1];
#line 752
      a[k] = (char)1;
    }
#line 753
    k ++;
#line 755
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
      {
#line 757
      internal_unlock_mutex(& tree->mutex);
      }
      }
#line 758
      return ((void *)0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  (tree->count) --;
#line 763
  item = (void const   *)p->data;
#line 766
  q = & (pa[k - 1])->link[(int )a[k - 1]];
#line 767
  if ((unsigned long )p->link[1] == (unsigned long )((void *)0)) {
#line 769
    *q = p->link[0];
#line 770
    if (*q) {
#line 771
      (*q)->bal = (signed char)0;
    }
  } else {
#line 776
    r = p->link[1];
#line 777
    if ((unsigned long )r->link[0] == (unsigned long )((void *)0)) {
#line 779
      r->link[0] = p->link[0];
#line 780
      *q = r;
#line 781
      r->bal = p->bal;
#line 782
      a[k] = (char)1;
#line 783
      tmp___0 = k;
#line 783
      k ++;
#line 783
      pa[tmp___0] = r;
    } else {
#line 788
      s = r->link[0];
#line 789
      tmp___1 = k;
#line 789
      k ++;
#line 789
      l = tmp___1;
#line 791
      a[k] = (char)0;
#line 792
      tmp___2 = k;
#line 792
      k ++;
#line 792
      pa[tmp___2] = r;
      {
      {
#line 795
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 795
        if (! ((unsigned long )s->link[0] != (unsigned long )((void *)0))) {
#line 795
          goto while_break___0;
        }
#line 797
        r = s;
#line 798
        s = r->link[0];
#line 799
        a[k] = (char)0;
#line 800
        tmp___3 = k;
#line 800
        k ++;
#line 800
        pa[tmp___3] = r;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 804
      a[l] = (char)1;
#line 805
      pa[l] = s;
#line 806
      s->link[0] = p->link[0];
#line 807
      r->link[0] = s->link[1];
#line 808
      s->link[1] = p->link[1];
#line 809
      s->bal = p->bal;
#line 810
      *q = s;
    }
  }
  {
  {
#line 817
  free((void *)p);
  }
  }
#line 819
  if (! (k > 0)) {
    {
    {
#line 819
    __assert_fail("k > 0", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  819U, "avl_delete");
    }
    }
  }
  {
  {
#line 821
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 821
    k --;
#line 821
    if (! k) {
#line 821
      goto while_break___1;
    }
#line 823
    s___0 = pa[k];
#line 825
    if ((int )a[k] == 0) {
#line 828
      if ((int )s___0->bal == -1) {
#line 830
        s___0->bal = (signed char)0;
#line 831
        goto while_continue___1;
      } else
#line 833
      if ((int )s___0->bal == 0) {
#line 835
        s___0->bal = (signed char)1;
#line 836
        goto while_break___1;
      }
#line 839
      if (! ((int )s___0->bal == 1)) {
        {
        {
#line 839
        __assert_fail("s->bal == +1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      839U, "avl_delete");
        }
        }
      }
#line 840
      r___0 = s___0->link[1];
#line 842
      if (! ((unsigned long )r___0 != (unsigned long )((void *)0))) {
        {
        {
#line 842
        __assert_fail("r != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      842U, "avl_delete");
        }
        }
      }
#line 843
      if ((int )r___0->bal == 0) {
#line 846
        s___0->link[1] = r___0->link[0];
#line 847
        r___0->link[0] = s___0;
#line 848
        r___0->bal = (signed char)-1;
#line 849
        (pa[k - 1])->link[(int )a[k - 1]] = r___0;
#line 850
        goto while_break___1;
      } else
#line 852
      if ((int )r___0->bal == 1) {
#line 855
        s___0->link[1] = r___0->link[0];
#line 856
        r___0->link[0] = s___0;
#line 857
        tmp___4 = (signed char)0;
#line 857
        r___0->bal = tmp___4;
#line 857
        s___0->bal = tmp___4;
#line 858
        (pa[k - 1])->link[(int )a[k - 1]] = r___0;
      } else {
#line 863
        if (! ((int )r___0->bal == -1)) {
          {
          {
#line 863
          __assert_fail("r->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                        863U, "avl_delete");
          }
          }
        }
#line 864
        p = r___0->link[0];
#line 865
        r___0->link[0] = p->link[1];
#line 866
        p->link[1] = r___0;
#line 867
        s___0->link[1] = p->link[0];
#line 868
        p->link[0] = s___0;
#line 869
        if ((int )p->bal == 1) {
#line 870
          s___0->bal = (signed char)-1;
#line 870
          r___0->bal = (signed char)0;
        } else
#line 871
        if ((int )p->bal == 0) {
#line 872
          tmp___5 = (signed char)0;
#line 872
          r___0->bal = tmp___5;
#line 872
          s___0->bal = tmp___5;
        } else {
#line 875
          if (! ((int )p->bal == -1)) {
            {
            {
#line 875
            __assert_fail("p->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                          875U, "avl_delete");
            }
            }
          }
#line 876
          s___0->bal = (signed char)0;
#line 876
          r___0->bal = (signed char)1;
        }
#line 878
        p->bal = (signed char)0;
#line 879
        (pa[k - 1])->link[(int )a[k - 1]] = p;
      }
    } else {
#line 884
      if (! ((int )a[k] == 1)) {
        {
        {
#line 884
        __assert_fail("a[k] == 1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      884U, "avl_delete");
        }
        }
      }
#line 887
      if ((int )s___0->bal == 1) {
#line 889
        s___0->bal = (signed char)0;
#line 890
        goto while_continue___1;
      } else
#line 892
      if ((int )s___0->bal == 0) {
#line 894
        s___0->bal = (signed char)-1;
#line 895
        goto while_break___1;
      }
#line 898
      if (! ((int )s___0->bal == -1)) {
        {
        {
#line 898
        __assert_fail("s->bal == -1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                      898U, "avl_delete");
        }
        }
      }
#line 899
      r___0 = s___0->link[0];
#line 901
      if ((unsigned long )r___0 == (unsigned long )((void *)0)) {
#line 904
        s___0->link[0] = r___0->link[1];
#line 905
        r___0->link[1] = s___0;
#line 906
        r___0->bal = (signed char)1;
#line 907
        (pa[k - 1])->link[(int )a[k - 1]] = r___0;
#line 908
        goto while_break___1;
      } else
#line 901
      if ((int )r___0->bal == 0) {
#line 904
        s___0->link[0] = r___0->link[1];
#line 905
        r___0->link[1] = s___0;
#line 906
        r___0->bal = (signed char)1;
#line 907
        (pa[k - 1])->link[(int )a[k - 1]] = r___0;
#line 908
        goto while_break___1;
      } else
#line 910
      if ((int )r___0->bal == -1) {
#line 913
        s___0->link[0] = r___0->link[1];
#line 914
        r___0->link[1] = s___0;
#line 915
        tmp___6 = (signed char)0;
#line 915
        r___0->bal = tmp___6;
#line 915
        s___0->bal = tmp___6;
#line 916
        (pa[k - 1])->link[(int )a[k - 1]] = r___0;
      } else
#line 918
      if ((int )r___0->bal == 1) {
#line 921
        p = r___0->link[1];
#line 922
        r___0->link[1] = p->link[0];
#line 923
        p->link[0] = r___0;
#line 924
        s___0->link[0] = p->link[1];
#line 925
        p->link[1] = s___0;
#line 926
        if ((int )p->bal == -1) {
#line 927
          s___0->bal = (signed char)1;
#line 927
          r___0->bal = (signed char)0;
        } else
#line 928
        if ((int )p->bal == 0) {
#line 929
          tmp___7 = (signed char)0;
#line 929
          r___0->bal = tmp___7;
#line 929
          s___0->bal = tmp___7;
        } else {
#line 932
          if (! ((int )p->bal == 1)) {
            {
            {
#line 932
            __assert_fail("p->bal == 1", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                          932U, "avl_delete");
            }
            }
          }
#line 933
          s___0->bal = (signed char)0;
#line 933
          r___0->bal = (signed char)-1;
        }
#line 935
        p->bal = (signed char)0;
#line 936
        (pa[k - 1])->link[(int )a[k - 1]] = p;
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 941
  internal_unlock_mutex(& tree->mutex);
  }
  }
#line 942
  return ((void *)item);
}
}
#line 947 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_insert(avl_tree *tree , void *item ) 
{ 
  void **p ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 952
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 952
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  952U, "avl_insert");
    }
    }
  }
  {
  {
#line 954
  p = avl_probe(tree, item);
  }
  }
#line 955
  if ((unsigned long )*p == (unsigned long )item) {
#line 955
    tmp = (void *)0;
  } else {
#line 955
    tmp = *p;
  }
#line 955
  return (tmp);
}
}
#line 962 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_replace(avl_tree *tree , void *item ) 
{ 
  void **p ;
  void *r ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 967
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    {
    {
#line 967
    __assert_fail("tree != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  967U, "avl_replace");
    }
    }
  }
  {
  {
#line 969
  p = avl_probe(tree, item);
  }
  }
#line 970
  if ((unsigned long )*p == (unsigned long )item) {
#line 971
    return ((void *)0);
  } else {
#line 974
    r = *p;
#line 975
    *p = item;
#line 976
    return (r);
  }
}
}
#line 982 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
void *avl_force_delete(avl_tree *tree , void *item ) 
{ 
  void *found ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 985
  tmp = avl_delete(tree, (void const   *)item);
  }
#line 985
  found = tmp;
  }
#line 986
  if (! ((unsigned long )found != (unsigned long )((void *)0))) {
    {
    {
#line 986
    __assert_fail("found != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  986U, "avl_force_delete");
    }
    }
  }
#line 987
  return (found);
}
}
#line 127 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 8 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.h"
int compare_vars(void const   *first , void const   *second , void *param ) ;
#line 23
void *avl_get_any_node(avl_tree *tree ) ;
#line 22 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.h"
void extract_vars(vartree_t *request_vars , char *requeststring ) ;
#line 23
void add_varpair(vartree_t *request_vars , char *varpair ) ;
#line 25
char const   *get_variable(vartree_t *request_vars , char const   *name ) ;
#line 26
void free_variables(vartree_t *request_vars ) ;
#line 28
void extract_header_vars(char *line , vartree_t *vars ) ;
#line 29
void free_con_variables(connection_t *con ) ;
#line 30
char const   *get_con_variable(connection_t *con , char const   *name ) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *clean_string(char *string ) ;
#line 71 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
vartree_t *create_header_vars(void) 
{ 
  avl_tree *t ;
  avl_tree *tmp ;

  {
  {
  {
#line 74
  tmp = avl_create(& compare_vars, (void *)(& info));
  }
#line 74
  t = tmp;
  }
#line 75
  return (t);
}
}
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void extract_header_vars(char *line , vartree_t *vars ) 
{ 
  char *colonptr ;
  char name[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 84
  if (! line) {
    {
    {
#line 86
    xa_debug(1, (char *)"ERROR: extract_header_vars() called with NULL pointers");
    }
    }
#line 87
    return;
  } else
#line 84
  if (! vars) {
    {
    {
#line 86
    xa_debug(1, (char *)"ERROR: extract_header_vars() called with NULL pointers");
    }
    }
#line 87
    return;
  }
  {
  {
#line 90
  colonptr = strchr((char const   *)line, ':');
  }
  }
#line 91
  if (! colonptr) {
#line 91
    if (*(line + 0)) {
      {
      {
#line 93
      xa_debug(1, (char *)"WARNING: Invalid header line [%s] without colon", line);
      }
      }
#line 94
      return;
    }
  }
  {
  {
#line 97
  tmp = splitc(name, line, (char const   )':');
  }
  }
#line 97
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 99
    if (*(line + 0)) {
      {
      {
#line 100
      xa_debug(1, (char *)"WARNING: Invalid header line [%s]", line);
      }
      }
    }
#line 101
    return;
  }
  {
  {
#line 104
  tmp___0 = clean_string(line);
  }
  {
#line 104
  tmp___1 = n_strdup((char const   *)tmp___0, (int const   )104, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
  }
  {
#line 104
  tmp___2 = clean_string(name);
  }
  {
#line 104
  tmp___3 = n_strdup((char const   *)tmp___2, (int const   )104, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
  }
  {
#line 104
  add_varpair2(vars, tmp___3, tmp___1);
  }
  }
#line 105
  return;
}
}
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
varpair_t *create_varpair(void) 
{ 
  varpair_t *vp ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 110
  tmp = n_malloc((unsigned int const   )sizeof(varpair_t ), (int const   )110, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
  }
#line 110
  vp = (varpair_t *)tmp;
  }
#line 111
  return (vp);
}
}
#line 114 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void add_varpair2(vartree_t *request_vars , char *name , char *value ) 
{ 
  varpair_t *vp ;
  varpair_t *out ;
  void *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 119
  if (! request_vars) {
    {
    {
#line 121
    xa_debug(2, (char *)"add_varpair2() called with NULL tree");
    }
    }
#line 122
    return;
  } else
#line 124
  if (! name) {
    {
    {
#line 126
    xa_debug(2, (char *)"add_varpair2() called with NULL values");
    }
    }
#line 127
    return;
  } else
#line 124
  if (! value) {
    {
    {
#line 126
    xa_debug(2, (char *)"add_varpair2() called with NULL values");
    }
    }
#line 127
    return;
  }
  {
  {
#line 130
  vp = create_varpair();
  }
#line 131
  vp->name = name;
#line 132
  vp->value = value;
  {
#line 134
  xa_debug(3, (char *)"DEBUG: Adding varpair [%s] == [%s]", vp->name, vp->value);
  }
  }
#line 136
  if (! vp->name) {
    {
    {
#line 138
    xa_debug(1, (char *)"WARNING: Adding NULL variables to tree");
    }
    }
#line 139
    return;
  } else
#line 136
  if (! vp->value) {
    {
    {
#line 138
    xa_debug(1, (char *)"WARNING: Adding NULL variables to tree");
    }
    }
#line 139
    return;
  }
  {
  {
#line 142
  tmp = avl_replace(request_vars, (void *)vp);
  }
#line 142
  out = (varpair_t *)tmp;
  }
#line 144
  if (out) {
    {
    {
#line 146
    n_free((void *)out->name, (int const   )146, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 146
    out->name = (char *)((void *)0);
    {
#line 147
    n_free((void *)out->value, (int const   )147, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 147
    out->value = (char *)((void *)0);
    {
#line 148
    n_free((void *)out, (int const   )148, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 148
    out = (varpair_t *)((void *)0);
    }
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void add_varpair(vartree_t *request_vars , char *varpair ) 
{ 
  char name[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 157
  if (! varpair) {
    {
    {
#line 159
    xa_debug(2, (char *)"WARNING: add_varpair called with NULL input");
    }
    }
#line 160
    return;
  }
  {
#line 163
  name[0] = (char )'\000';
  {
#line 165
  tmp = splitc(name, varpair, (char const   )'=');
  }
  }
#line 165
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 167
    xa_debug(1, (char *)"WARNING: Invalid varpair [%s]", varpair);
    }
    }
#line 168
    return;
  }
  {
  {
#line 171
  tmp___0 = n_strdup((char const   *)varpair, (int const   )171, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
  }
  {
#line 171
  tmp___1 = n_strdup((char const   *)(name), (int const   )171, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
  }
  {
#line 171
  add_varpair2(request_vars, tmp___1, tmp___0);
  }
  }
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void extract_vars(vartree_t *request_vars , char *requeststring ) 
{ 
  char varpair[8192] ;
  int go_on ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 178
  go_on = 1;
#line 180
  varpair[0] = (char )'\000';
#line 182
  if (! requeststring) {
    {
    {
#line 184
    xa_debug(1, (char *)"WARNING: Empty request string");
    }
    }
#line 185
    return;
  } else
#line 182
  if (! *(requeststring + 0)) {
    {
    {
#line 184
    xa_debug(1, (char *)"WARNING: Empty request string");
    }
    }
#line 185
    return;
  }
  {
  {
#line 188
  tmp = strchr((char const   *)requeststring, '?');
  }
  }
#line 188
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 190
    xa_debug(1, (char *)"WARNING: extract_vars called without vars");
    }
    }
#line 191
    return;
  }
  {
  {
#line 194
  splitc((char *)((void *)0), requeststring, (char const   )'?');
  }
  }
  {
  {
#line 196
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 198
    tmp___0 = splitc(varpair, requeststring, (char const   )'&');
    }
    }
#line 198
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 200
      strcpy((char */* __restrict  */)(varpair), (char const   */* __restrict  */)requeststring);
      }
#line 201
      go_on = 0;
      }
    }
    {
    {
#line 203
    add_varpair(request_vars, varpair);
    }
    }
#line 196
    if (! go_on) {
#line 196
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
char const   *get_con_variable(connection_t *con , char const   *name ) 
{ 
  char const   *tmp ;

  {
#line 210
  if (! con) {
#line 211
    return ((char const   *)((void *)0));
  } else
#line 210
  if (! con->headervars) {
#line 211
    return ((char const   *)((void *)0));
  }
  {
  {
#line 213
  tmp = get_variable(con->headervars, name);
  }
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
char const   *get_variable(vartree_t *request_vars , char const   *name ) 
{ 
  varpair_t search ;
  varpair_t *vp ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 221
  if (! request_vars) {
    {
    {
#line 223
    xa_debug(2, (char *)"WARNING: get_variable called with NULL pointers");
    }
    }
#line 224
    return ((char const   *)((void *)0));
  } else
#line 221
  if (! name) {
    {
    {
#line 223
    xa_debug(2, (char *)"WARNING: get_variable called with NULL pointers");
    }
    }
#line 224
    return ((char const   *)((void *)0));
  }
  {
  {
#line 227
  search.name = strchr(name, (int )*name);
  }
  {
#line 229
  tmp = avl_find(request_vars, (void const   *)(& search));
  }
#line 229
  vp = (varpair_t *)tmp;
  }
#line 230
  if (! vp) {
#line 231
    return ((char const   *)((void *)0));
  }
#line 232
  return ((char const   *)vp->value);
}
}
#line 235 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void free_con_variables(connection_t *con ) 
{ 


  {
#line 238
  if (! con) {
#line 239
    return;
  }
  {
  {
#line 240
  free_variables(con->headervars);
  }
#line 241
  con->headervars = (vartree_t *)((void *)0);
  }
#line 242
  return;
}
}
#line 244 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c"
void free_variables(vartree_t *request_vars ) 
{ 
  varpair_t *vp ;
  varpair_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 249
  if (! request_vars) {
    {
    {
#line 251
    xa_debug(2, (char *)"WARNING: free_variables called with NULL tree");
    }
    }
#line 252
    return;
  }
  {
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 255
    tmp___0 = avl_get_any_node(request_vars);
    }
#line 255
    vp = (varpair_t *)tmp___0;
    }
#line 255
    if (! vp) {
#line 255
      goto while_break;
    }
    {
    {
#line 257
    tmp = avl_delete(request_vars, (void const   *)vp);
    }
#line 257
    out = (varpair_t *)tmp;
    }
#line 259
    if (! out) {
      {
      {
#line 261
      xa_debug(2, (char *)"DEBUG: Fishy stuff in free_variables.");
      }
      }
#line 262
      goto while_continue;
    }
    {
    {
#line 265
    n_free((void *)out->name, (int const   )265, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 265
    out->name = (char *)((void *)0);
    {
#line 266
    n_free((void *)out->value, (int const   )266, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 266
    out->value = (char *)((void *)0);
    {
#line 267
    n_free((void *)out, (int const   )267, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/vars.c");
    }
#line 267
    out = (varpair_t *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 270
  avl_destroy(request_vars, (void (*)(void *data , void *param ))((void *)0));
  }
  }
#line 271
  return;
}
}
#line 135 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 81 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
icethread_t thread_create_c(char *name , void *(*start_routine)(void * ) , void *arg ,
                            int line , char *file ) ;
#line 86
void thread_exit_c(long val , int line , char *file ) ;
#line 95
void thread_init(void) ;
#line 98
int thread_alive(mythread_t *mt ) ;
#line 102
icethread_t thread_self(void) ;
#line 103
int thread_equal(icethread_t t1 , icethread_t t2 ) ;
#line 107
mythread_t *thread_get_mythread(void) ;
#line 110
void thread_rename(char const   *name ) ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
int password_match(char const   *crypted , char const   *uncrypted ) ;
#line 43
int find_frame_ofs(source_t *source ) ;
#line 52
void close_connection(void *data , void *param ) ;
#line 72
unsigned long transfer_average(unsigned long megabytes , unsigned long connections ) ;
#line 73
char *connect_average(unsigned long minutes , unsigned long connections , char *buf ) ;
#line 77
int hostname_local(char *name ) ;
#line 79
int mount_exists(char *mount ) ;
#line 80
void zero_request(request_t *req ) ;
#line 85
connection_t *get_pending_mount(char *mount ) ;
#line 86
void pending_connection(connection_t *con ) ;
#line 87
int pending_source_signoff(connection_t *con ) ;
#line 88
int hosteq(connection_t *con , connection_t *con2 ) ;
#line 91
int open_for_writing(char const   *filename ) ;
#line 96
void stat_add_write(statistics_t *stat___0 , int len ) ;
#line 97
void stat_add_read(statistics_t *stat___0 , int len ) ;
#line 99
void zero_song_info(songinfo_t *si ) ;
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char const   *con_host(connection_t *con ) ;
#line 29
char *my_strdup(char const   *string ) ;
#line 39
char *ice_sprintf(char const   *template , char const   *arg ) ;
#line 40
int ice_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 45
char *nice_time_minutes(unsigned long minutes , char *buf ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.h"
source_t *create_source(void) ;
#line 28
void *source_func(void *conarg ) ;
#line 30
void add_source(void) ;
#line 31
void del_source(void) ;
#line 32
connection_t *find_mount_with_req(request_t *req ) ;
#line 33
connection_t *get_default_mount(void) ;
#line 34
void add_chunk(connection_t *con ) ;
#line 35
void write_chunk(source_t *source , connection_t *clicon ) ;
#line 36
void kick_clients_on_cid(source_t *source , connection_t *smaller ) ;
#line 37
void kick_dead_clients(source_t *source ) ;
#line 38
void move_clients_to_default_mount(connection_t *con ) ;
#line 39
int originating_id(connection_t *sourcecon , char *dshost ) ;
#line 40
int write_data(connection_t *clicon , source_t *source ) ;
#line 41
int write_data_with_metadata(connection_t *clicon , source_t *source , int justnull ) ;
#line 42
void move_client(connection_t *clicon , source_t *source , int meta_after ) ;
#line 44
connection_t *get_source_with_mount(char const   *mount ) ;
#line 45
connection_t *get_source_from_host(connection_t *con ) ;
#line 46
void describe_source(com_request_t const   *req , connection_t const   *sourcecon ) ;
#line 47
char const   *sourceproto_to_string(protocol_t proto ) ;
#line 48
char const   *sourcetype_to_string(source_type_t type ) ;
#line 49
int start_chunk(source_t *source ) ;
#line 50
connection_t *get_twin_mount(source_t *source ) ;
#line 51
connection_t *get_twin_mount_wl(source_t *source ) ;
#line 52
void move_to_smaller_twin(source_t *source , connection_t *clicon ) ;
#line 53
void source_write_to_client(source_t *source , connection_t *clicon ) ;
#line 54
void source_get_new_clients(source_t *source ) ;
#line 55
int source_get_id(char *argument ) ;
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.h"
void describe_connection(com_request_t const   *req , connection_t const   *describecon ) ;
#line 10 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.h"
int compare_connection(void const   *first , void const   *second , void *param ) ;
#line 16
int compare_relay_ids(void const   *first , void const   *second , void *param ) ;
#line 22
void zero_trav(avl_traverser *trav ) ;
#line 15 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.h"
void zero_stats(statistics_t *stat___0 ) ;
#line 4 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.h"
request_t *get_alias(request_t *req ) ;
#line 33 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
void del_client(connection_t *client , source_t *source ) ;
#line 38
int client_errors(client_t const   *client ) ;
#line 65 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
void move_to(void *clientarg , void *sourcetargetarg ) ;
#line 11 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.h"
int allowed(connection_t *con , contype_t contype ) ;
#line 42 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.h"
int admin_write_line(com_request_t const   *req , int const   message_type , char const   *fmt 
                     , ...) ;
#line 57 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
void write_http_code_page(connection_t *con , int code , char const   *msg ) ;
#line 27 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.h"
connection_t *pool_get_my_clients(source_t const   *source ) ;
#line 92 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void source_login(connection_t *con , char *expr ) 
{ 
  char line[8192] ;
  char command[8192] ;
  char arg[8192] ;
  char pass[8192] ;
  unsigned int tmp ;
  int go_on ;
  int connected ;
  int password_accepted ;
  int need_lock ;
  source_t *source ;
  char *res ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char slash[8192] ;
  int tmp___4 ;
  char slash___0[8192] ;
  char host[8192] ;
  relay_id_t *rid ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  connection_t *clicon ;
  connection_t *scon ;
  connection_t *tmp___26 ;
  void *tmp___27 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;

  {
#line 95
  pass[0] = (char )'\000';
#line 95
  tmp = 1U;
  {
  {
#line 95
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 95
    if (tmp >= 8192U) {
#line 95
      goto while_break;
    }
#line 95
    pass[tmp] = (char)0;
#line 95
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  go_on = 2;
#line 97
  connected = 1;
#line 98
  password_accepted = 0;
#line 99
  need_lock = 1;
#line 116
  if ((unsigned int )con->type == 3U) {
#line 118
    if (info.throttle_on) {
      {
      {
#line 120
      sock_write(con->sock, "HTTP/1.0 406 Not Acceptable (Bandwidth usage too high)");
      }
      {
#line 121
      kick_connection((void *)con, (void *)"Bandwidth usage too high (throttling)");
      }
      }
#line 122
      return;
    }
    {
    {
#line 124
    put_source(con);
    }
#line 125
    (con->food.source)->type = (source_type_t )0;
    {
#line 126
    xa_debug(2, (char *)"DEBUG: Encoder logging in with [%s]", expr);
    }
    }
  } else
#line 128
  if ((int )(con->food.source)->type == 1) {
    {
    {
#line 130
    xa_debug(2, (char *)"DEBUG: Puller loggin in with [%s]", expr);
    }
#line 131
    go_on = 1;
#line 132
    need_lock = 0;
    }
  } else {
    {
    {
#line 134
    xa_debug(2, (char *)"DEBUG: Icy encoder logging in with [%s]", expr);
    }
    }
  }
#line 145
  if ((int )(con->food.source)->type == 0) {
    {
    {
#line 145
    tmp___0 = allowed(con, (contype_t )1);
    }
    }
#line 145
    if (! tmp___0) {
      {
      {
#line 147
      write_http_code_page(con, 403, "Forbidden");
      }
      {
#line 148
      kick_connection((void *)con, (void *)"Access Denied (internal acl list (source connection))");
      }
      }
#line 149
      return;
    }
  }
#line 152
  source = con->food.source;
  {
  {
#line 154
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
#line 155
    command[0] = (char )'\000';
#line 156
    arg[0] = (char )'\000';
    {
#line 158
    tmp___1 = splitc(line, expr, (char const   )'\n');
    }
    }
#line 158
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 159
      strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)expr,
              (size_t )8192);
      }
#line 160
      go_on --;
      }
#line 162
      if ((int )source->type == 1) {
#line 163
        go_on = 0;
      } else
#line 165
      if (go_on > 0) {
#line 165
        if (! source->protocol == 0) {
#line 165
          if ((int )source->type == 0) {
            {
            {
#line 167
            sock_read_lines_np(con->sock, expr, (int const   )8192);
            }
            }
          }
        }
      }
    }
#line 173
    if (go_on == 2) {
      {
      {
#line 174
      res = splitc(command, line, (char const   )' ');
      }
      }
    } else {
      {
      {
#line 176
      res = splitc(command, line, (char const   )':');
      }
      }
    }
#line 178
    if (! res) {
      {
      {
#line 180
      strncpy((char */* __restrict  */)(command), (char const   */* __restrict  */)(line),
              (size_t )8192);
      }
#line 181
      arg[0] = (char )'\000';
      }
    } else {
      {
      {
#line 183
      strncpy((char */* __restrict  */)(arg), (char const   */* __restrict  */)(line),
              (size_t )8192);
      }
      }
    }
#line 186
    if (line[0]) {
      {
      {
#line 187
      xa_debug(2, (char *)"DEBUG: Source line: [%s] [%s]", command, arg);
      }
      }
    }
    {
    {
#line 190
    tmp___24 = ice_strncmp((char const   *)(command), "SOURCE", (size_t )6);
    }
    }
#line 190
    if (tmp___24 == 0) {
      {
      {
#line 192
      tmp___2 = splitc(pass, arg, (char const   )' ');
      }
      }
#line 192
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
        {
#line 193
        sock_write_line(con->sock, "ERROR - Missing Mountpoint\r\n");
        }
        {
#line 194
        kick_connection((void *)con, (void *)"No Mountpoint supplied");
        }
#line 195
        connected = 0;
        }
#line 196
        return;
      }
      {
      {
#line 199
      tmp___3 = password_match((char const   *)info.encoder_pass, (char const   *)(pass));
      }
      }
#line 199
      if (tmp___3) {
#line 204
        password_accepted = 1;
      } else {
        {
        {
#line 200
        sock_write_line(con->sock, "ERROR - Bad Password\r\n");
        }
        {
#line 201
        kick_connection((void *)con, (void *)"Bad Password");
        }
        }
#line 202
        return;
      }
#line 206
      if (! source->audiocast.mount) {
        {
        {
#line 207
        source->audiocast.mount = my_strdup((char const   *)(arg));
        }
        }
      }
#line 211
      if ((int )*(source->audiocast.mount + 0) != 47) {
        {
        {
#line 213
        snprintf((char */* __restrict  */)(slash), (size_t )8192, (char const   */* __restrict  */)"/%s",
                 source->audiocast.mount);
        }
        {
#line 214
        n_free((void *)source->audiocast.mount, (int const   )214, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
#line 214
        source->audiocast.mount = (char *)((void *)0);
        {
#line 215
        source->audiocast.mount = my_strdup((char const   *)(slash));
        }
        }
      }
      {
      {
#line 219
      tmp___4 = mount_exists(source->audiocast.mount);
      }
      }
#line 219
      if (tmp___4) {
        {
        {
#line 220
        sock_write_line(con->sock, "ERROR - Mount Point Taken or Invalid\r\n");
        }
        {
#line 221
        kick_connection((void *)con, (void *)"Invalid Mount Point");
        }
        }
#line 222
        return;
      } else
#line 219
      if ((int )*(source->audiocast.mount + 0) == 0) {
        {
        {
#line 220
        sock_write_line(con->sock, "ERROR - Mount Point Taken or Invalid\r\n");
        }
        {
#line 221
        kick_connection((void *)con, (void *)"Invalid Mount Point");
        }
        }
#line 222
        return;
      }
#line 225
      if ((unsigned int )source->protocol != 0U) {
        {
        {
#line 226
        sock_write_line(con->sock, "OK");
        }
        }
      } else
#line 227
      if ((int )source->type == 0) {
#line 228
        go_on = 1;
      }
    } else {
      {
      {
#line 231
      tmp___23 = ice_strncmp((char const   *)(command), "icy-name", (size_t )8);
      }
      }
#line 231
      if (tmp___23 == 0) {
#line 233
        if (! source->audiocast.name) {
          {
          {
#line 234
          source->audiocast.name = ice_sprintf((char const   *)info.nametemplate,
                                               (char const   *)(arg));
          }
          }
        }
#line 235
        if (! source->audiocast.description) {
          {
          {
#line 236
          source->audiocast.description = n_strdup("Icy protocol in use", (int const   )236,
                                                   "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
          }
          }
        }
      } else {
        {
        {
#line 239
        tmp___22 = ice_strncmp((char const   *)(command), "icy-genre", (size_t )9);
        }
        }
#line 239
        if (tmp___22 == 0) {
#line 241
          if (! source->audiocast.genre) {
            {
            {
#line 242
            source->audiocast.genre = my_strdup((char const   *)(arg));
            }
            }
          }
        } else {
          {
          {
#line 245
          tmp___21 = ice_strncmp((char const   *)(command), "icy-url", (size_t )7);
          }
          }
#line 245
          if (tmp___21 == 0) {
#line 247
            if (! source->audiocast.url) {
              {
              {
#line 248
              source->audiocast.url = my_strdup((char const   *)(arg));
              }
              }
            }
          } else {
            {
            {
#line 251
            tmp___20 = ice_strncmp((char const   *)(command), "icy-pub", (size_t )7);
            }
            }
#line 251
            if (tmp___20 == 0) {
              {
              {
#line 252
              source->audiocast.public = atoi((char const   *)(arg));
              }
              }
            } else {
              {
              {
#line 253
              tmp___19 = ice_strncmp((char const   *)(command), "icy-br", (size_t )6);
              }
              }
#line 253
              if (tmp___19 == 0) {
                {
                {
#line 254
                source->audiocast.bitrate = atoi((char const   *)(arg));
                }
                }
              } else {
                {
                {
#line 256
                tmp___18 = ice_strncmp((char const   *)(command), "x-audiocast-name",
                                       (size_t )16);
                }
                }
#line 256
                if (tmp___18 == 0) {
#line 258
                  if (! source->audiocast.name) {
                    {
                    {
#line 259
                    source->audiocast.name = ice_sprintf((char const   *)info.nametemplate,
                                                         (char const   *)(arg));
                    }
                    }
                  }
                } else {
                  {
                  {
#line 262
                  tmp___17 = ice_strncmp((char const   *)(command), "x-audiocast-description",
                                         (size_t )23);
                  }
                  }
#line 262
                  if (tmp___17 == 0) {
#line 264
                    if (! source->audiocast.description) {
                      {
                      {
#line 265
                      source->audiocast.description = ice_sprintf((char const   *)info.descriptiontemplate,
                                                                  (char const   *)(arg));
                      }
                      }
                    }
                  } else {
                    {
                    {
#line 268
                    tmp___16 = ice_strncmp((char const   *)(command), "x-audiocast-url",
                                           (size_t )15);
                    }
                    }
#line 268
                    if (tmp___16 == 0) {
#line 270
                      if (! source->audiocast.url) {
                        {
                        {
#line 271
                        source->audiocast.url = my_strdup((char const   *)(arg));
                        }
                        }
                      }
                    } else {
                      {
                      {
#line 274
                      tmp___15 = ice_strncmp((char const   *)(command), "x-audiocast-genre",
                                             (size_t )17);
                      }
                      }
#line 274
                      if (tmp___15 == 0) {
#line 276
                        if (! source->audiocast.genre) {
                          {
                          {
#line 277
                          source->audiocast.genre = my_strdup((char const   *)(arg));
                          }
                          }
                        }
                      } else {
                        {
                        {
#line 280
                        tmp___14 = ice_strncmp((char const   *)(command), "x-audiocast-bitrate",
                                               (size_t )19);
                        }
                        }
#line 280
                        if (tmp___14 == 0) {
                          {
                          {
#line 281
                          source->audiocast.bitrate = atoi((char const   *)(arg));
                          }
                          }
                        } else {
                          {
                          {
#line 282
                          tmp___13 = ice_strncmp((char const   *)(command), "x-audiocast-public",
                                                 (size_t )18);
                          }
                          }
#line 282
                          if (tmp___13 == 0) {
                            {
                            {
#line 283
                            source->audiocast.public = atoi((char const   *)(arg));
                            }
                            }
                          } else {
                            {
                            {
#line 284
                            tmp___12 = ice_strncmp((char const   *)(command), "x-audiocast-dumpfile",
                                                   (size_t )20);
                            }
                            }
#line 284
                            if (tmp___12 == 0) {
#line 286
                              if (! source->dumpfile) {
                                {
                                {
#line 287
                                source->dumpfile = my_strdup((char const   *)(arg));
                                }
                                }
                              }
                            } else
#line 290
                            if ((int )(con->food.source)->type != 1) {
                              {
                              {
#line 290
                              tmp___11 = ice_strncmp((char const   *)(command), "x-audiocast-mount",
                                                     (size_t )17);
                              }
                              }
#line 290
                              if (tmp___11 == 0) {
                                {
                                {
#line 292
                                source->audiocast.mount = my_strdup((char const   *)(arg));
                                }
                                }
#line 293
                                if ((int )arg[0] != 47) {
                                  {
                                  {
#line 296
                                  snprintf((char */* __restrict  */)(slash___0), (size_t )8192,
                                           (char const   */* __restrict  */)"/%s",
                                           source->audiocast.mount);
                                  }
                                  {
#line 297
                                  n_free((void *)source->audiocast.mount, (int const   )297,
                                         "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
                                  }
#line 297
                                  source->audiocast.mount = (char *)((void *)0);
                                  {
#line 298
                                  source->audiocast.mount = my_strdup((char const   *)(slash___0));
                                  }
                                  }
                                }
                              } else {
#line 290
                                goto _L;
                              }
                            } else {
                              _L: /* CIL Label */ 
                              {
                              {
#line 302
                              tmp___10 = ice_strncmp((char const   *)(command), "x-audiocast-directory",
                                                     (size_t )21);
                              }
                              }
#line 302
                              if (tmp___10 == 0) {
                                {
                                {
#line 307
                                tmp___7 = avl_count((avl_tree const   *)(con->food.source)->relay_tree);
                                }
                                }
#line 307
                                if ((unsigned long )tmp___7 < info.max_directories) {
                                  {
                                  {
#line 309
                                  tmp___5 = splitc(host, arg, (char const   )':');
                                  }
                                  }
#line 309
                                  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
                                    {
                                    {
#line 311
                                    sock_write_line(con->sock, "ERROR - Invalid directory server specification");
                                    }
                                    {
#line 312
                                    kick_connection((void *)con, (void *)"Invalid directory server specification");
                                    }
                                    }
#line 313
                                    return;
                                  }
                                  {
                                  {
#line 316
                                  tmp___6 = n_malloc((unsigned int const   )sizeof(relay_id_t ),
                                                     (int const   )316, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
                                  }
#line 316
                                  rid = (relay_id_t *)tmp___6;
                                  {
#line 317
                                  xa_debug(1, (char *)"DEBUG: Adding directory-server: [%s] with id [%s] for %d",
                                           host, arg, con->id);
                                  }
                                  {
#line 318
                                  rid->host = my_strdup((char const   *)(host));
                                  }
                                  {
#line 319
                                  rid->id = atoi((char const   *)(arg));
                                  }
                                  {
#line 320
                                  avl_insert((con->food.source)->relay_tree, (void *)rid);
                                  }
                                  }
                                }
                              } else {
                                {
                                {
#line 324
                                tmp___9 = ice_strncmp((char const   *)(command), "x-audiocast-mimetype",
                                                      (size_t )20);
                                }
                                }
#line 324
                                if (tmp___9 == 0) {
#line 326
                                  if (! source->audiocast.streammimetype) {
                                    {
                                    {
#line 327
                                    source->audiocast.streammimetype = my_strdup((char const   *)(arg));
                                    }
                                    }
                                  }
                                } else {
                                  {
                                  {
#line 330
                                  tmp___8 = ice_strncmp((char const   *)(command),
                                                        "x-audiocast-contentid", (size_t )21);
                                  }
                                  }
#line 330
                                  if (tmp___8 == 0) {
#line 332
                                    if ((unsigned long )source->audiocast.contentid == (unsigned long )((void *)0)) {
                                      {
                                      {
#line 333
                                      source->audiocast.contentid = my_strdup((char const   *)(arg));
                                      }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 154
    if (go_on > 0) {
#line 154
      if (! connected) {
#line 154
        goto while_break___0;
      }
    } else {
#line 154
      goto while_break___0;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  if (connected) {
#line 339
    if ((unsigned long )source->audiocast.mount == (unsigned long )((void *)0)) {
      {
      {
#line 341
      sock_write_line(con->sock, "ERROR - Mount Point Taken or Invalid\r\n");
      }
      {
#line 342
      kick_connection((void *)con, (void *)"Invalid Mount Point");
      }
      }
#line 343
      return;
    }
  }
#line 347
  if (connected) {
#line 349
    if (! source->audiocast.name) {
      {
      {
#line 350
      source->audiocast.name = n_strdup("", (int const   )350, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
    }
#line 351
    if (! source->audiocast.url) {
      {
      {
#line 352
      source->audiocast.url = n_strdup("", (int const   )352, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
    }
#line 353
    if (! source->audiocast.genre) {
      {
      {
#line 354
      source->audiocast.genre = n_strdup("", (int const   )354, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
    }
#line 355
    if (! source->audiocast.description) {
      {
      {
#line 356
      source->audiocast.description = n_strdup("", (int const   )356, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
    }
#line 357
    if (source->audiocast.bitrate == -1) {
#line 358
      source->audiocast.bitrate = 128;
    }
#line 359
    if (source->audiocast.public == -1) {
#line 360
      source->audiocast.public = 0;
    }
  }
#line 363
  if (connected) {
#line 363
    if (! password_accepted) {
#line 363
      if ((int )(con->food.source)->type != 1) {
        {
        {
#line 365
        sock_write_line(con->sock, "Missing Password\r\n");
        }
        {
#line 366
        kick_connection((void *)con, (void *)"Missing Password");
        }
        }
#line 367
        return;
      }
    }
  }
#line 370
  if (connected) {
#line 372
    if (info.num_sources + 1UL > info.max_sources) {
      {
      {
#line 374
      sock_write_line(con->sock, "ERROR - Too many sources\r\n");
      }
      {
#line 375
      kick_connection((void *)con, (void *)"Server Full (too many streams)");
      }
      }
#line 376
      return;
    }
    {
    {
#line 379
    add_source();
    }
    }
#line 381
    if (! (con->food.source)->type == 1) {
      {
      {
#line 382
      sock_write_line(con->sock, "OK");
      }
      }
    }
    {
#line 384
    source->connected = 1;
    {
#line 385
    source->info.streamtitle = n_strdup((char const   *)info.streamtitle, (int const   )385,
                                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 386
    source->info.streamurl = n_strdup((char const   *)info.streamurl, (int const   )386,
                                      "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 388
    tmp___25 = con_host(con);
    }
    {
#line 388
    write_log(0, (char *)"Accepted encoder on mountpoint %s from %s. %d sources connected",
              source->audiocast.mount, tmp___25, info.num_sources);
    }
    {
#line 391
    thread_mutex_lock_c(& info.source_mutex, 391, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 392
    avl_insert(info.sources, (void *)con);
    }
    {
#line 393
    thread_mutex_unlock_c(& info.source_mutex, 393, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 396
    tmp___26 = get_pending_mount(source->audiocast.mount);
    }
#line 396
    scon = tmp___26;
    }
#line 398
    if (scon) {
      {
      {
#line 400
      write_log(0, (char *)"Assigning listeners from pending source %d", scon->id);
      }
      }
      {
      {
#line 401
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 401
        tmp___27 = avl_get_any_node((scon->food.source)->clients);
        }
#line 401
        clicon = (connection_t *)tmp___27;
        }
#line 401
        if (! clicon) {
#line 401
          goto while_break___1;
        }
        {
        {
#line 402
        move_to((void *)clicon, (void *)con);
        }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 403
      (scon->food.source)->connected = 0;
    }
#line 408
    if ((int )(con->food.source)->type == 1) {
      {
      {
#line 409
      thread_create_c((char *)"Source Thread", & source_func, (void *)con, 409, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 410
      return;
    } else {
      {
      {
#line 413
      thread_rename("Source Thread");
      }
      {
#line 415
      source_func((void *)con);
      }
      }
    }
  }
  {
  {
#line 419
  write_log(0, (char *)"WARNING: Thread exiting in source_login(), this should not happen");
  }
  {
#line 420
  thread_exit_c(0L, 420, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 421
  return;
}
}
#line 431 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void *source_func(void *conarg ) 
{ 
  source_t *source ;
  avl_traverser trav ;
  connection_t *clicon ;
  connection_t *con ;
  mythread_t *mt ;
  int i ;
  int *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 435
  trav.init = 0;
#line 435
  trav.nstack = 0;
#line 435
  trav.p = (avl_node const   *)0;
#line 435
  trav.stack[0] = (avl_node const   *)0;
#line 435
  trav.stack[1] = (avl_node const   *)0;
#line 435
  trav.stack[2] = (avl_node const   *)0;
#line 435
  trav.stack[3] = (avl_node const   *)0;
#line 435
  trav.stack[4] = (avl_node const   *)0;
#line 435
  trav.stack[5] = (avl_node const   *)0;
#line 435
  trav.stack[6] = (avl_node const   *)0;
#line 435
  trav.stack[7] = (avl_node const   *)0;
#line 435
  trav.stack[8] = (avl_node const   *)0;
#line 435
  trav.stack[9] = (avl_node const   *)0;
#line 435
  trav.stack[10] = (avl_node const   *)0;
#line 435
  trav.stack[11] = (avl_node const   *)0;
#line 435
  trav.stack[12] = (avl_node const   *)0;
#line 435
  trav.stack[13] = (avl_node const   *)0;
#line 435
  trav.stack[14] = (avl_node const   *)0;
#line 435
  trav.stack[15] = (avl_node const   *)0;
#line 435
  trav.stack[16] = (avl_node const   *)0;
#line 435
  trav.stack[17] = (avl_node const   *)0;
#line 435
  trav.stack[18] = (avl_node const   *)0;
#line 435
  trav.stack[19] = (avl_node const   *)0;
#line 435
  trav.stack[20] = (avl_node const   *)0;
#line 435
  trav.stack[21] = (avl_node const   *)0;
#line 435
  trav.stack[22] = (avl_node const   *)0;
#line 435
  trav.stack[23] = (avl_node const   *)0;
#line 435
  trav.stack[24] = (avl_node const   *)0;
#line 435
  trav.stack[25] = (avl_node const   *)0;
#line 435
  trav.stack[26] = (avl_node const   *)0;
#line 435
  trav.stack[27] = (avl_node const   *)0;
#line 435
  trav.stack[28] = (avl_node const   *)0;
#line 435
  trav.stack[29] = (avl_node const   *)0;
#line 435
  trav.stack[30] = (avl_node const   *)0;
#line 435
  trav.stack[31] = (avl_node const   *)0;
#line 436
  con = (connection_t *)conarg;
#line 440
  source = con->food.source;
  {
#line 441
  (con->food.source)->thread = thread_self();
  }
  {
#line 442
  thread_init();
  }
  {
#line 444
  mt = thread_get_mythread();
  }
  {
#line 446
  sock_set_blocking(con->sock, (int const   )1);
  }
  }
#line 448
  if (source->dumpfile) {
    {
    {
#line 449
    source->dumpfd = open_for_writing((char const   *)source->dumpfile);
    }
    }
#line 450
    if (source->dumpfd == -1) {
      {
      {
#line 451
      tmp = __errno_location();
      }
      {
#line 451
      write_log(0, (char *)"WARNING: Could not open dumpfile %s for source %d [%d]",
                source->dumpfile, con->id, *tmp);
      }
      {
#line 452
      n_free((void *)source->dumpfile, (int const   )452, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
#line 452
      source->dumpfile = (char *)((void *)0);
#line 453
      source->dumpfile = (char *)((void *)0);
      }
    }
  }
  {
  {
#line 457
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 457
    tmp___1 = thread_alive(mt);
    }
    }
#line 457
    if (tmp___1) {
#line 457
      if (! (source->connected == 1)) {
#line 457
        if (! (source->connected == 3)) {
#line 457
          goto while_break;
        }
      }
    } else {
#line 457
      goto while_break;
    }
    {
    {
#line 459
    source_get_new_clients(source);
    }
    {
#line 461
    add_chunk(con);
    }
#line 463
    i = 0;
    }
    {
    {
#line 463
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 463
      if (! (i < 10)) {
#line 463
        goto while_break___0;
      }
#line 465
      if (source->connected != 1) {
#line 466
        goto while_break___0;
      }
      {
      {
#line 468
      thread_mutex_lock_c(& source->mutex, 468, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 470
      zero_trav(& trav);
      }
      }
      {
      {
#line 472
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
        {
        {
#line 472
        tmp___0 = avl_traverse(source->clients, & trav);
        }
#line 472
        clicon = (connection_t *)tmp___0;
        }
#line 472
        if (! ((unsigned long )clicon != (unsigned long )((void *)0))) {
#line 472
          goto while_break___1;
        }
#line 474
        if (source->connected == 0) {
#line 475
          goto while_break___1;
        } else
#line 474
        if (source->connected == 3) {
#line 475
          goto while_break___1;
        }
        {
        {
#line 477
        source_write_to_client(source, clicon);
        }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 481
      thread_mutex_unlock_c(& source->mutex, 481, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 483
      if (mt->ping == 1) {
#line 484
        mt->ping = 0;
      }
#line 463
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 487
    thread_mutex_lock_c(& info.double_mutex, 487, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 488
    thread_mutex_lock_c(& source->mutex, 488, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 489
    kick_dead_clients(source);
    }
    {
#line 490
    thread_mutex_unlock_c(& source->mutex, 490, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 491
    thread_mutex_unlock_c(& info.double_mutex, 491, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 494
  thread_mutex_lock_c(& info.double_mutex, 494, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 496
  thread_mutex_lock_c(& info.source_mutex, 496, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 497
  thread_mutex_lock_c(& source->mutex, 497, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 499
  close_connection((void *)con, (void *)(& info));
  }
  {
#line 501
  thread_mutex_unlock_c(& info.source_mutex, 501, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 502
  thread_mutex_unlock_c(& info.double_mutex, 502, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 504
  thread_exit_c(0L, 504, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 505
  return ((void *)0);
}
}
#line 508 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
source_t *create_source(void) 
{ 
  source_t *source ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 511
  tmp = n_malloc((unsigned int const   )sizeof(source_t ), (int const   )511, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
#line 511
  source = (source_t *)tmp;
  {
#line 512
  memset((void *)source, 0, (size_t )sizeof(source_t ));
  }
#line 513
  source->type = (source_type_t )-1;
  }
#line 514
  return (source);
}
}
#line 517 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void put_source(connection_t *con ) 
{ 
  register int i ;
  socklen_t sin_len ;
  source_t *source ;
  source_t *tmp ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 522
  tmp = create_source();
  }
#line 522
  source = tmp;
#line 524
  con->food.source = source;
  {
#line 525
  zero_stats(& source->stats);
  }
#line 526
  source->connected = 2;
#line 527
  source->type = (source_type_t )-1;
  {
#line 528
  thread_create_mutex_c(& source->mutex, 528, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
#line 529
  source->dumpfile = (char *)((void *)0);
#line 530
  source->dumpfd = -1;
#line 531
  source->audiocast.name = (char *)((void *)0);
#line 532
  source->audiocast.genre = (char *)((void *)0);
#line 533
  source->audiocast.bitrate = -1;
#line 534
  source->audiocast.url = (char *)((void *)0);
#line 535
  source->audiocast.mount = (char *)((void *)0);
#line 536
  source->audiocast.description = (char *)((void *)0);
#line 537
  source->audiocast.streammimetype = (char *)((void *)0);
#line 538
  source->audiocast.public = -1;
#line 539
  source->protocol = (protocol_t )1;
#line 540
  source->cid = 0;
  {
#line 541
  source->clients = avl_create(& compare_connection, (void *)(& info));
  }
  {
#line 542
  source->relay_tree = avl_create(& compare_relay_ids, (void *)(& info));
  }
#line 543
  source->num_clients = 0UL;
#line 544
  source->priority = 0;
  {
#line 545
  zero_song_info(& source->info);
  }
#line 547
  i = 0;
  }
  {
  {
#line 547
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 547
    if (! (i < 64)) {
#line 547
      goto while_break;
    }
#line 549
    source->chunk[i].clients_left = 0;
#line 550
    source->chunk[i].len = 0;
#line 551
    source->chunk[i].metalen = 0;
#line 547
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  sin_len = (socklen_t )1;
#line 555
  con->type = (contype_t )1;
#line 556
  return;
}
}
#line 558 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void add_source(void) 
{ 


  {
#line 561
  (info.num_sources) ++;
#line 562
  (info.hourly_stats.source_connections) ++;
#line 563
  return;
}
}
#line 565 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void del_source(void) 
{ 


  {
#line 568
  (info.num_sources) --;
#line 569
  return;
}
}
#line 572 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *find_mount_with_req(request_t *req ) 
{ 
  char pathbuf[8192] ;
  unsigned int tmp ;
  char tempbuf[256] ;
  unsigned int tmp___0 ;
  connection_t *con ;
  request_t *alias ;
  request_t search ;
  int true ;
  avl_traverser trav ;
  int tmp___1 ;
  connection_t *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  connection_t *sourcecon ;
  int err ;
  connection_t *sourcecon___0 ;
  int err___0 ;
  int tmp___16 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;

  {
#line 575
  pathbuf[0] = (char )'\000';
#line 575
  tmp = 1U;
  {
  {
#line 575
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 575
    if (tmp >= 8192U) {
#line 575
      goto while_break;
    }
#line 575
    pathbuf[tmp] = (char)0;
#line 575
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  tempbuf[0] = (char )'\000';
#line 576
  tmp___0 = 1U;
  {
  {
#line 576
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 576
    if (tmp___0 >= 256U) {
#line 576
      goto while_break___0;
    }
#line 576
    tempbuf[tmp___0] = (char)0;
#line 576
    tmp___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 582
  true = 0;
#line 584
  trav.init = 0;
#line 584
  trav.nstack = 0;
#line 584
  trav.p = (avl_node const   *)0;
#line 584
  trav.stack[0] = (avl_node const   *)0;
#line 584
  trav.stack[1] = (avl_node const   *)0;
#line 584
  trav.stack[2] = (avl_node const   *)0;
#line 584
  trav.stack[3] = (avl_node const   *)0;
#line 584
  trav.stack[4] = (avl_node const   *)0;
#line 584
  trav.stack[5] = (avl_node const   *)0;
#line 584
  trav.stack[6] = (avl_node const   *)0;
#line 584
  trav.stack[7] = (avl_node const   *)0;
#line 584
  trav.stack[8] = (avl_node const   *)0;
#line 584
  trav.stack[9] = (avl_node const   *)0;
#line 584
  trav.stack[10] = (avl_node const   *)0;
#line 584
  trav.stack[11] = (avl_node const   *)0;
#line 584
  trav.stack[12] = (avl_node const   *)0;
#line 584
  trav.stack[13] = (avl_node const   *)0;
#line 584
  trav.stack[14] = (avl_node const   *)0;
#line 584
  trav.stack[15] = (avl_node const   *)0;
#line 584
  trav.stack[16] = (avl_node const   *)0;
#line 584
  trav.stack[17] = (avl_node const   *)0;
#line 584
  trav.stack[18] = (avl_node const   *)0;
#line 584
  trav.stack[19] = (avl_node const   *)0;
#line 584
  trav.stack[20] = (avl_node const   *)0;
#line 584
  trav.stack[21] = (avl_node const   *)0;
#line 584
  trav.stack[22] = (avl_node const   *)0;
#line 584
  trav.stack[23] = (avl_node const   *)0;
#line 584
  trav.stack[24] = (avl_node const   *)0;
#line 584
  trav.stack[25] = (avl_node const   *)0;
#line 584
  trav.stack[26] = (avl_node const   *)0;
#line 584
  trav.stack[27] = (avl_node const   *)0;
#line 584
  trav.stack[28] = (avl_node const   *)0;
#line 584
  trav.stack[29] = (avl_node const   *)0;
#line 584
  trav.stack[30] = (avl_node const   *)0;
#line 584
  trav.stack[31] = (avl_node const   *)0;
#line 586
  if (! req) {
    {
    {
#line 588
    write_log(0, (char *)"WARNING: find_mount_with_req called with NULL request!");
    }
    }
#line 589
    return ((connection_t *)((void *)0));
  } else
#line 586
  if (! (req->path)) {
    {
    {
#line 588
    write_log(0, (char *)"WARNING: find_mount_with_req called with NULL request!");
    }
    }
#line 589
    return ((connection_t *)((void *)0));
  } else
#line 586
  if (! (req->host)) {
    {
    {
#line 588
    write_log(0, (char *)"WARNING: find_mount_with_req called with NULL request!");
    }
    }
#line 589
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 592
  tmp___1 = ice_strcmp((char const   *)(req->path), "/list.cgi");
  }
  }
#line 592
  if (tmp___1 == 0) {
#line 593
    return ((connection_t *)(& info));
  }
  {
  {
#line 595
  xa_debug(1, (char *)"DEBUG: Looking for [%s] on host [%s] on port %d", req->path,
           req->host, req->port);
  }
  {
#line 596
  xa_debug(1, (char *)"DEBUG: Searching local aliases");
  }
  {
#line 599
  alias = get_alias(req);
  }
  }
#line 601
  if (alias) {
    {
    {
#line 601
    tmp___3 = hostname_local(req->host);
    }
    }
#line 601
    if (tmp___3) {
      {
      {
#line 601
      tmp___4 = hostname_local(alias->host);
      }
      }
#line 601
      if (tmp___4) {
#line 601
        if (req->port == alias->port) {
          {
          {
#line 604
          xa_debug(1, (char *)"DEBUG: Found alias [%s:%d%s] -> [%s:%d%s]", req->host,
                   req->port, req->path, alias->host, alias->port, alias->path);
          }
          {
#line 606
          tmp___2 = find_mount_with_req(alias);
          }
          }
#line 606
          return (tmp___2);
        }
      }
    }
  }
  {
  {
#line 609
  xa_debug(1, (char *)"DEBUG: Search local mount points");
  }
  }
#line 611
  if (req->host[0]) {
#line 611
    tmp___5 = (char const   *)(req->host);
  } else {
#line 611
    tmp___5 = "localhost";
  }
  {
  {
#line 611
  snprintf((char */* __restrict  */)(pathbuf), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           tmp___5, req->port, req->path);
  }
  }
  {
  {
#line 613
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 613
    tmp___15 = avl_traverse(info.sources, & trav);
    }
#line 613
    con = (connection_t *)tmp___15;
    }
#line 613
    if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 613
      goto while_break___1;
    }
    {
#line 615
    true = 0;
    {
#line 617
    xa_debug(2, (char *)"DEBUG: Looking on mount [%s]", (con->food.source)->audiocast.mount);
    }
    {
#line 619
    zero_request(& search);
    }
    {
#line 621
    generate_http_request((con->food.source)->audiocast.mount, & search);
    }
    {
#line 623
    strncpy((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)(con->food.source)->audiocast.mount,
            (size_t )252);
    }
    {
#line 624
    strcat((char */* __restrict  */)(tempbuf), (char const   */* __restrict  */)".mp3");
    }
    }
#line 626
    if (search.path[0]) {
      {
      {
#line 626
      tmp___12 = ice_strcasecmp((char const   *)(search.host), (char const   *)(req->host));
      }
      }
#line 626
      if (tmp___12 == 0) {
#line 626
        if (search.port == req->port) {
          {
          {
#line 626
          tmp___13 = ice_strcmp((char const   *)(search.path), (char const   *)(req->path));
          }
          }
#line 626
          if (tmp___13 == 0) {
#line 627
            true = 1;
          } else {
            {
            {
#line 626
            tmp___14 = ice_strcmp((char const   *)(tempbuf), (char const   *)(req->path));
            }
            }
#line 626
            if (tmp___14 == 0) {
#line 627
              true = 1;
            } else {
#line 626
              goto _L___1;
            }
          }
        } else {
#line 626
          goto _L___1;
        }
      } else {
#line 626
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 628
    if ((int )*((con->food.source)->audiocast.mount + 0) == 47) {
      {
      {
#line 629
      tmp___6 = hostname_local(req->host);
      }
      }
#line 629
      if (tmp___6) {
        {
        {
#line 629
        tmp___7 = ice_strcmp((char const   *)(con->food.source)->audiocast.mount,
                             (char const   *)(req->path));
        }
        }
#line 629
        if (tmp___7 == 0) {
#line 630
          true = 1;
        } else {
          {
          {
#line 629
          tmp___8 = ice_strcmp((char const   *)(tempbuf), (char const   *)(req->path));
          }
          }
#line 629
          if (tmp___8 == 0) {
#line 630
            true = 1;
          }
        }
      }
    } else {
      {
      {
#line 632
      tmp___9 = hostname_local(req->host);
      }
      }
#line 632
      if (tmp___9) {
        {
        {
#line 632
        tmp___10 = ice_strcmp((char const   *)(con->food.source)->audiocast.mount,
                              (char const   *)(req->path + 1));
        }
        }
#line 632
        if (tmp___10 == 0) {
#line 633
          true = 1;
        } else {
          {
          {
#line 632
          tmp___11 = ice_strcmp((char const   *)(tempbuf), (char const   *)(req->path + 1));
          }
          }
#line 632
          if (tmp___11 == 0) {
#line 633
            true = 1;
          }
        }
      }
    }
#line 636
    if (true) {
      {
      {
#line 637
      xa_debug(1, (char *)"DEBUG: Found local mount for [%s]", req->path);
      }
      }
#line 638
      return (con);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 642
  xa_debug(1, (char *)"DEBUG: Searching remote aliases");
  }
  {
#line 645
  alias = get_alias(req);
  }
  }
#line 647
  if (alias) {
    {
    {
#line 650
    xa_debug(1, (char *)"DEBUG: Found alias [%s:%d%s] -> [%s:%d%s]", req->host, req->port,
             req->path, alias->host, alias->port, alias->path);
    }
    {
#line 652
    sourcecon = find_mount_with_req(alias);
    }
    }
#line 653
    if (! sourcecon) {
      {
      {
#line 657
      thread_mutex_unlock_c(& info.mount_mutex, 657, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 658
      thread_mutex_unlock_c(& info.source_mutex, 658, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 659
      thread_mutex_unlock_c(& info.double_mutex, 659, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 661
      sourcecon = relay_pull_stream(alias, & err);
      }
      }
#line 661
      if (sourcecon) {
        {
        {
#line 663
        write_log(0, (char *)"Found [%s:%d%s] -> [%s:%d%s], pulling relay", req->host,
                  req->port, req->path, alias->host, alias->port, alias->path);
        }
#line 665
        (sourcecon->food.source)->type = (source_type_t )2;
        }
      } else {
        {
        {
#line 667
        write_log(0, (char *)"On demand relay for [%s:%d%s] -> [%s:%d%s] failed, damn!",
                  req->host, req->port, req->path, alias->host, alias->port, alias->path);
        }
        }
      }
      {
      {
#line 671
      thread_mutex_lock_c(& info.double_mutex, 671, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 672
      thread_mutex_lock_c(& info.mount_mutex, 672, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 673
      thread_mutex_lock_c(& info.source_mutex, 673, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 674
      return (sourcecon);
    } else {
#line 677
      return (sourcecon);
    }
  }
#line 681
  if (info.transparent_proxy) {
    {
    {
#line 681
    tmp___16 = hostname_local(req->host);
    }
    }
#line 681
    if (! tmp___16) {
      {
      {
#line 686
      xa_debug(1, (char *)"DEBUG: Trying transparent proxy with host: [%s]", req->host);
      }
      {
#line 687
      sourcecon___0 = relay_pull_stream(req, & err___0);
      }
      }
#line 687
      if (sourcecon___0) {
#line 689
        (sourcecon___0->food.source)->type = (source_type_t )2;
#line 690
        return (sourcecon___0);
      } else {
        {
        {
#line 692
        write_log(0, (char *)"Transparent proxy relay for [%s:%d%s] failed", req->host,
                  req->port, req->path);
        }
        }
#line 693
        return ((connection_t *)((void *)0));
      }
    }
  }
#line 697
  return ((connection_t *)((void *)0));
}
}
#line 701 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_default_mount(void) 
{ 
  avl_traverser trav ;
  connection_t *con ;
  connection_t *max ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 704
  trav.init = 0;
#line 704
  trav.nstack = 0;
#line 704
  trav.p = (avl_node const   *)0;
#line 704
  trav.stack[0] = (avl_node const   *)0;
#line 704
  trav.stack[1] = (avl_node const   *)0;
#line 704
  trav.stack[2] = (avl_node const   *)0;
#line 704
  trav.stack[3] = (avl_node const   *)0;
#line 704
  trav.stack[4] = (avl_node const   *)0;
#line 704
  trav.stack[5] = (avl_node const   *)0;
#line 704
  trav.stack[6] = (avl_node const   *)0;
#line 704
  trav.stack[7] = (avl_node const   *)0;
#line 704
  trav.stack[8] = (avl_node const   *)0;
#line 704
  trav.stack[9] = (avl_node const   *)0;
#line 704
  trav.stack[10] = (avl_node const   *)0;
#line 704
  trav.stack[11] = (avl_node const   *)0;
#line 704
  trav.stack[12] = (avl_node const   *)0;
#line 704
  trav.stack[13] = (avl_node const   *)0;
#line 704
  trav.stack[14] = (avl_node const   *)0;
#line 704
  trav.stack[15] = (avl_node const   *)0;
#line 704
  trav.stack[16] = (avl_node const   *)0;
#line 704
  trav.stack[17] = (avl_node const   *)0;
#line 704
  trav.stack[18] = (avl_node const   *)0;
#line 704
  trav.stack[19] = (avl_node const   *)0;
#line 704
  trav.stack[20] = (avl_node const   *)0;
#line 704
  trav.stack[21] = (avl_node const   *)0;
#line 704
  trav.stack[22] = (avl_node const   *)0;
#line 704
  trav.stack[23] = (avl_node const   *)0;
#line 704
  trav.stack[24] = (avl_node const   *)0;
#line 704
  trav.stack[25] = (avl_node const   *)0;
#line 704
  trav.stack[26] = (avl_node const   *)0;
#line 704
  trav.stack[27] = (avl_node const   *)0;
#line 704
  trav.stack[28] = (avl_node const   *)0;
#line 704
  trav.stack[29] = (avl_node const   *)0;
#line 704
  trav.stack[30] = (avl_node const   *)0;
#line 704
  trav.stack[31] = (avl_node const   *)0;
#line 705
  max = (connection_t *)((void *)0);
  {
#line 707
  thread_mutex_lock_c(& info.source_mutex, 707, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
  {
  {
#line 709
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 709
    tmp = avl_traverse(info.sources, & trav);
    }
#line 709
    con = (connection_t *)tmp;
    }
#line 709
    if (! con) {
#line 709
      goto while_break;
    }
#line 711
    if ((con->food.source)->connected == 1) {
#line 713
      if (! max) {
#line 714
        max = con;
      } else
#line 713
      if ((con->food.source)->priority > (max->food.source)->priority) {
#line 714
        max = con;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 718
  thread_mutex_unlock_c(& info.source_mutex, 718, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 720
  return (max);
}
}
#line 723 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void add_chunk(connection_t *con ) 
{ 
  int read_bytes ;
  int len ;
  int tries ;
  connection_t *smaller ;
  connection_t *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  int ulen ;
  int metalen ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 730
  if ((con->food.source)->chunk[(con->food.source)->cid].clients_left > 0) {
    {
    {
#line 732
    tmp = get_twin_mount_wl(con->food.source);
    }
#line 732
    smaller = tmp;
    {
#line 734
    xa_debug(2, (char *)"DEBUG: Kicking trailing clients [%d] on id %d", (con->food.source)->chunk[(con->food.source)->cid].clients_left,
             (con->food.source)->cid);
    }
    {
#line 737
    thread_mutex_lock_c(& info.double_mutex, 737, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 738
    thread_mutex_lock_c(& (con->food.source)->mutex, 738, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 740
    kick_clients_on_cid(con->food.source, smaller);
    }
    {
#line 742
    thread_mutex_unlock_c(& (con->food.source)->mutex, 742, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    {
#line 743
    thread_mutex_unlock_c(& info.double_mutex, 743, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
    }
    }
  }
#line 746
  len = 0;
#line 747
  read_bytes = 0;
#line 748
  tries = 0;
  {
  {
#line 750
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 751
    tmp___0 = __errno_location();
    }
#line 751
    *tmp___0 = 0;
    {
#line 756
    len = recv(con->sock, (void *)((con->food.source)->chunk[(con->food.source)->cid].data + read_bytes),
               (size_t )(4096 - read_bytes), 0);
    }
    {
#line 758
    tmp___1 = __errno_location();
    }
    {
#line 758
    xa_debug(5, (char *)"DEBUG: Source received %d bytes in try %d, total %d, errno: %d",
             len, tries, read_bytes, *tmp___1);
    }
    }
#line 764
    if ((con->food.source)->connected == 0) {
#line 765
      return;
    }
#line 767
    if (len == 0) {
#line 767
      goto _L___0;
    } else
#line 767
    if (len == -1) {
      {
      {
#line 767
      tmp___3 = __errno_location();
      }
      {
#line 767
      tmp___4 = is_recoverable(*tmp___3);
      }
      }
#line 767
      if (tmp___4) {
#line 767
        goto _L___1;
      } else
      _L___0: /* CIL Label */ 
#line 768
      if (info.client_timeout > 0) {
#line 768
        if ((con->food.source)->connected != 0) {
          {
          {
#line 770
          pending_connection(con);
          }
          {
#line 774
          tmp___2 = pending_source_signoff(con);
          }
          }
#line 774
          if (tmp___2) {
            {
            {
#line 776
            thread_mutex_lock_c(& info.double_mutex, 776, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 777
            thread_mutex_lock_c(& (con->food.source)->mutex, 777, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 778
            move_clients_to_default_mount(con);
            }
            {
#line 779
            kick_connection((void *)con, (void *)"Client timeout exceeded, removing source");
            }
            {
#line 780
            thread_mutex_unlock_c(& (con->food.source)->mutex, 780, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 781
            thread_mutex_unlock_c(& info.double_mutex, 781, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            }
#line 782
            return;
          } else {
            {
            {
#line 785
            thread_mutex_lock_c(& info.double_mutex, 785, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 786
            thread_mutex_lock_c(& (con->food.source)->mutex, 786, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 787
            kick_connection((void *)con, (void *)"Lost all clients to new source");
            }
            {
#line 788
            thread_mutex_unlock_c(& (con->food.source)->mutex, 788, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            {
#line 789
            thread_mutex_unlock_c(& info.double_mutex, 789, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
            }
            }
#line 790
            return;
          }
        } else {
#line 768
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 795
        thread_mutex_lock_c(& info.double_mutex, 795, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 796
        thread_mutex_lock_c(& (con->food.source)->mutex, 796, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 797
        write_log(0, (char *)"Source %s signed off, moving clients to default mount",
                  (con->food.source)->audiocast.mount);
        }
        }
#line 800
        if (! info.kick_clients) {
          {
          {
#line 801
          move_clients_to_default_mount(con);
          }
          }
        }
        {
        {
#line 802
        kick_connection((void *)con, (void *)"Source signed off (killed itself)");
        }
        {
#line 803
        thread_mutex_unlock_c(& (con->food.source)->mutex, 803, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 804
        thread_mutex_unlock_c(& info.double_mutex, 804, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        }
#line 805
        return;
      }
    } else
    _L___1: /* CIL Label */ 
#line 807
    if (len > 0) {
      {
#line 808
      read_bytes += len;
      {
#line 809
      stat_add_read(& (con->food.source)->stats, len);
      }
#line 810
      info.hourly_stats.read_bytes += (unsigned long )len;
      }
    } else {
      {
      {
#line 812
      my_sleep(400000);
      }
      }
    }
#line 815
    tries ++;
#line 750
    if (info.use_meta_data) {
#line 750
      if (! (read_bytes < 4096)) {
#line 750
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 750
    if (! info.use_meta_data) {
#line 750
      if ((double )read_bytes < ((double )4096 * 3.0) / 4.0) {
#line 750
        if (! (tries < 1250)) {
#line 750
          goto while_break;
        }
      } else {
#line 750
        goto while_break;
      }
    } else {
#line 750
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (read_bytes <= 0) {
    {
    {
#line 822
    write_log(0, (char *)"Didn\'t receive data from source after %d microseconds, assuming it died...",
              tries * 400);
    }
    {
#line 825
    pending_connection(con);
    }
    }
#line 827
    if (info.client_timeout > 0) {
      {
      {
#line 829
      tmp___5 = pending_source_signoff(con);
      }
      }
#line 829
      if (tmp___5) {
        {
        {
#line 830
        thread_mutex_lock_c(& info.double_mutex, 830, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 831
        thread_mutex_lock_c(& (con->food.source)->mutex, 831, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 832
        move_clients_to_default_mount(con);
        }
        {
#line 833
        kick_connection((void *)con, (void *)"Client timeout exceeded, removing source");
        }
        {
#line 834
        thread_mutex_unlock_c(& (con->food.source)->mutex, 834, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 835
        thread_mutex_unlock_c(& info.double_mutex, 835, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        }
#line 836
        return;
      } else {
        {
        {
#line 839
        thread_mutex_lock_c(& (con->food.source)->mutex, 839, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        {
#line 840
        kick_connection((void *)con, (void *)"Lost all clients to new source");
        }
        {
#line 841
        thread_mutex_unlock_c(& (con->food.source)->mutex, 841, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        }
#line 842
        return;
      }
    } else {
      {
      {
#line 846
      thread_mutex_lock_c(& info.double_mutex, 846, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 847
      thread_mutex_lock_c(& (con->food.source)->mutex, 847, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 848
      write_log(0, (char *)"Source %s died, moving clients to default mount", (con->food.source)->audiocast.mount);
      }
      }
#line 850
      if (! info.kick_clients) {
        {
        {
#line 851
        move_clients_to_default_mount(con);
        }
        }
      }
      {
      {
#line 852
      kick_connection((void *)con, (void *)"Source died");
      }
      {
#line 853
      thread_mutex_unlock_c(& (con->food.source)->mutex, 853, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      {
#line 854
      thread_mutex_unlock_c(& info.double_mutex, 854, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 855
      return;
    }
  }
  {
  {
#line 859
  thread_mutex_lock_c(& (con->food.source)->mutex, 859, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 861
  if ((con->food.source)->dumpfile) {
#line 861
    if ((con->food.source)->dumpfd != -1) {
      {
      {
#line 863
      tmp___6 = __errno_location();
      }
#line 863
      *tmp___6 = 0;
      {
#line 864
      tmp___8 = write((con->food.source)->dumpfd, (void const   *)((con->food.source)->chunk[(con->food.source)->cid].data),
                      (size_t )read_bytes);
      }
      }
#line 864
      if (tmp___8 <= 0) {
        {
        {
#line 865
        tmp___7 = __errno_location();
        }
        {
#line 865
        write_log(0, (char *)"Writing to dumpfile %s for source %d failed [%d] (closing file)",
                  (con->food.source)->dumpfile, con->id, *tmp___7);
        }
        {
#line 866
        fd_close((con->food.source)->dumpfd);
        }
        {
#line 867
        n_free((void *)(con->food.source)->dumpfile, (int const   )867, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
#line 867
        (con->food.source)->dumpfile = (char *)((void *)0);
#line 868
        (con->food.source)->dumpfile = (char *)((void *)0);
#line 869
        (con->food.source)->dumpfd = -1;
        }
      }
    }
  }
  {
  {
#line 872
  thread_mutex_unlock_c(& (con->food.source)->mutex, 872, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 875
  xa_debug(4, (char *)"-------add_chunk: Chunk %d was [%d] bytes", (con->food.source)->cid,
           read_bytes);
  }
  }
#line 879
  if (info.use_meta_data) {
    {
    {
#line 880
    tmp___9 = ice_strlen((char const   *)(con->food.source)->info.streamtitle);
    }
    {
#line 880
    tmp___10 = ice_strlen((char const   *)(con->food.source)->info.streamurl);
    }
#line 880
    metalen = (int )((tmp___9 + tmp___10) + 29U);
    }
#line 883
    if (metalen >= 4096) {
      {
      {
#line 884
      write_log(0, (char *)"WARNING: Avoided buffer overrun in metadata. Metadata to long!");
      }
#line 885
      metalen = 0;
      }
    }
    {
    {
#line 888
    snprintf((char */* __restrict  */)(& (con->food.source)->chunk[(con->food.source)->cid].data[read_bytes + 1]),
             (size_t )12288, (char const   */* __restrict  */)"StreamTitle=\'%s\';StreamUrl=\'%s\';%c",
             (con->food.source)->info.streamtitle, (con->food.source)->info.streamurl,
             '\000');
    }
#line 893
    ulen = (1 + (metalen + 1) / 16) * 16;
    }
#line 894
    if (ulen) {
#line 894
      (con->food.source)->chunk[(con->food.source)->cid].data[read_bytes] = (char )((unsigned char )((double )ulen / 16.0));
    } else {
#line 894
      (con->food.source)->chunk[(con->food.source)->cid].data[read_bytes] = (char)0;
    }
    {
#line 897
    (con->food.source)->chunk[(con->food.source)->cid].metalen = (read_bytes + ulen) + 1;
    {
#line 899
    xa_debug(4, (char *)"DEBUG: Adding chunk: metachunk: [%s], metalen: %d, complete length: %d, read: %d, ulen: %d, ulenc: %d",
             & (con->food.source)->chunk[(con->food.source)->cid].data[read_bytes + 1],
             metalen + 2, (con->food.source)->chunk[(con->food.source)->cid].metalen,
             read_bytes, ulen, (unsigned int )((double )ulen / 16.0));
    }
    }
  }
#line 906
  (con->food.source)->chunk[(con->food.source)->cid].len = read_bytes;
#line 907
  (con->food.source)->chunk[(con->food.source)->cid].clients_left = (int )(con->food.source)->num_clients;
#line 908
  (con->food.source)->cid = ((con->food.source)->cid + 1) % 64;
#line 910
  return;
}
}
#line 913 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void write_chunk(source_t *source , connection_t *clicon ) 
{ 
  int i ;
  long write_bytes ;
  long len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 916
  i = 0;
#line 917
  write_bytes = 0L;
#line 917
  len = 0L;
#line 920
  i = 0;
  {
  {
#line 920
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 920
    if (! (i < 2)) {
#line 920
      goto while_break;
    }
#line 923
    if (source->cid == (clicon->food.client)->cid) {
#line 924
      return;
    }
    {
#line 927
    len = (long )(source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset);
    {
#line 929
    xa_debug(5, (char *)"DEBUG: write_chunk(): Try: %d, writing chunk %d to client %d, len(%d) - offset(%d) == %d",
             i, (clicon->food.client)->cid, clicon->id, source->chunk[(clicon->food.client)->cid].len,
             (clicon->food.client)->offset, len);
    }
    }
#line 932
    if (len < 0L) {
      {
      {
#line 935
      xa_debug(5, (char *)"DEBUG: write_chunk: Empty chunk [%d] [%d]", source->chunk[(clicon->food.client)->cid].len,
               (clicon->food.client)->offset);
      }
#line 938
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 939
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 940
      (clicon->food.client)->offset = 0;
      }
#line 941
      goto __Cont;
    } else
#line 932
    if (source->chunk[(clicon->food.client)->cid].len == 0) {
      {
      {
#line 935
      xa_debug(5, (char *)"DEBUG: write_chunk: Empty chunk [%d] [%d]", source->chunk[(clicon->food.client)->cid].len,
               (clicon->food.client)->offset);
      }
#line 938
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 939
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 940
      (clicon->food.client)->offset = 0;
      }
#line 941
      goto __Cont;
    }
#line 945
    if ((clicon->food.client)->virgin == 2) {
      {
      {
#line 947
      move_client(clicon, source, -1);
      }
      }
#line 948
      return;
    }
    {
    {
#line 951
    tmp = write_data(clicon, source);
    }
#line 951
    write_bytes = (long )tmp;
    }
#line 953
    if (write_bytes < 0L) {
      {
      {
#line 956
      tmp___0 = client_errors((client_t const   *)clicon->food.client);
      }
      {
#line 956
      xa_debug(5, (char *)"DEBUG: client: [%2d] errors: [%3d]", clicon->id, tmp___0);
      }
      {
#line 958
      tmp___1 = is_recoverable((int )(0L - write_bytes));
      }
      }
#line 958
      if (tmp___1) {
#line 959
        goto __Cont;
      }
#line 960
      goto while_break;
    }
    {
#line 963
    (clicon->food.client)->write_bytes += (unsigned long )write_bytes;
#line 964
    info.hourly_stats.write_bytes += (unsigned long )write_bytes;
    {
#line 965
    stat_add_write(& source->stats, (int )write_bytes);
    }
    }
#line 967
    if (write_bytes + (long )(clicon->food.client)->offset >= (long )source->chunk[(clicon->food.client)->cid].len) {
#line 968
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 969
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 970
      (clicon->food.client)->offset = 0;
    } else {
      {
#line 973
      (clicon->food.client)->offset = (int )((long )(clicon->food.client)->offset + write_bytes);
      {
#line 975
      xa_debug(5, (char *)"DEBUG: client %d only read %d of %d bytes", clicon->id,
               write_bytes, source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset);
      }
      }
    }
    __Cont: /* CIL Label */ 
#line 920
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  if (source->cid < (clicon->food.client)->cid) {
#line 981
    tmp___2 = (source->cid + 64) - (clicon->food.client)->cid;
  } else {
#line 981
    tmp___2 = source->cid - (clicon->food.client)->cid;
  }
  {
  {
#line 981
  tmp___3 = client_errors((client_t const   *)clicon->food.client);
  }
  {
#line 981
  xa_debug(4, (char *)"DEBUG: client %d tried %d times, now has %d errors %d chunks behind source",
           clicon->id, i, tmp___3, tmp___2);
  }
  }
#line 984
  if ((clicon->food.client)->alive == 0) {
#line 985
    return;
  }
#line 986
  return;
}
}
#line 989 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void write_chunk_with_metadata(source_t *source , connection_t *clicon ) 
{ 
  int i ;
  long write_bytes ;
  long len ;
  long sourcelen ;
  long justnull ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 992
  i = 0;
#line 993
  write_bytes = 0L;
#line 993
  len = 0L;
#line 993
  sourcelen = 0L;
#line 993
  justnull = 0L;
#line 996
  i = 0;
  {
  {
#line 996
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 996
    if (! (i < 2)) {
#line 996
      goto while_break;
    }
#line 999
    if (source->cid == (clicon->food.client)->cid) {
#line 1000
      return;
    }
#line 1002
    if (source->info.udpseqnr == (clicon->food.client)->udpseqnr) {
#line 1003
      sourcelen = (long )(source->chunk[(clicon->food.client)->cid].len + 1);
#line 1004
      justnull = 1L;
    } else {
#line 1006
      sourcelen = (long )source->chunk[(clicon->food.client)->cid].metalen;
    }
    {
#line 1010
    len = sourcelen - (long )(clicon->food.client)->offset;
    {
#line 1012
    xa_debug(5, (char *)"DEBUG: write_chunk(): Try: %d, writing chunk %d to client %d, len(%d) - offset(%d) == %d",
             i, (clicon->food.client)->cid, clicon->id, sourcelen, (clicon->food.client)->offset,
             len);
    }
    }
#line 1015
    if (len < 0L) {
      {
      {
#line 1018
      xa_debug(5, (char *)"DEBUG: write_chunk: Empty chunk [%d] [%d]", sourcelen,
               (clicon->food.client)->offset);
      }
#line 1021
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 1022
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 1023
      (clicon->food.client)->offset = 0;
      }
#line 1024
      goto __Cont;
    } else
#line 1015
    if (sourcelen == 0L) {
      {
      {
#line 1018
      xa_debug(5, (char *)"DEBUG: write_chunk: Empty chunk [%d] [%d]", sourcelen,
               (clicon->food.client)->offset);
      }
#line 1021
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 1022
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 1023
      (clicon->food.client)->offset = 0;
      }
#line 1024
      goto __Cont;
    }
#line 1028
    if ((clicon->food.client)->virgin == 2) {
      {
      {
#line 1030
      move_client(clicon, source, -1);
      }
      }
#line 1031
      return;
    }
    {
    {
#line 1034
    tmp = write_data_with_metadata(clicon, source, (int )justnull);
    }
#line 1034
    write_bytes = (long )tmp;
    }
#line 1036
    if (write_bytes < 0L) {
      {
      {
#line 1039
      tmp___0 = client_errors((client_t const   *)clicon->food.client);
      }
      {
#line 1039
      xa_debug(5, (char *)"DEBUG: client: [%2d] errors: [%3d]", clicon->id, tmp___0);
      }
      {
#line 1041
      tmp___1 = is_recoverable((int )(0L - write_bytes));
      }
      }
#line 1041
      if (tmp___1) {
#line 1042
        goto __Cont;
      }
#line 1043
      goto while_break;
    }
    {
#line 1046
    (clicon->food.client)->write_bytes += (unsigned long )write_bytes;
#line 1047
    info.hourly_stats.write_bytes += (unsigned long )write_bytes;
    {
#line 1048
    stat_add_write(& source->stats, (int )write_bytes);
    }
    }
#line 1050
    if (write_bytes + (long )(clicon->food.client)->offset >= sourcelen) {
#line 1051
      if (justnull == 0L) {
#line 1052
        ((clicon->food.client)->udpseqnr) ++;
      }
#line 1053
      (source->chunk[(clicon->food.client)->cid].clients_left) --;
#line 1054
      (clicon->food.client)->cid = ((clicon->food.client)->cid + 1) % 64;
#line 1055
      (clicon->food.client)->offset = 0;
    } else {
      {
#line 1058
      (clicon->food.client)->offset = (int )((long )(clicon->food.client)->offset + write_bytes);
      {
#line 1060
      xa_debug(5, (char *)"DEBUG: client %d only read %d of %d bytes", clicon->id,
               write_bytes, sourcelen - (long )(clicon->food.client)->offset);
      }
      }
    }
    __Cont: /* CIL Label */ 
#line 996
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  if (source->cid < (clicon->food.client)->cid) {
#line 1066
    tmp___2 = (source->cid + 64) - (clicon->food.client)->cid;
  } else {
#line 1066
    tmp___2 = source->cid - (clicon->food.client)->cid;
  }
  {
  {
#line 1066
  tmp___3 = client_errors((client_t const   *)clicon->food.client);
  }
  {
#line 1066
  xa_debug(4, (char *)"DEBUG: client %d tried %d times, now has %d errors %d chunks behind source",
           clicon->id, i, tmp___3, tmp___2);
  }
  }
#line 1069
  if ((clicon->food.client)->alive == 0) {
#line 1070
    return;
  }
#line 1071
  return;
}
}
#line 1073 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void kick_clients_on_cid(source_t *source , connection_t *smaller ) 
{ 
  avl_traverser trav ;
  connection_t *clicon ;
  unsigned int max ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1076
  trav.init = 0;
#line 1076
  trav.nstack = 0;
#line 1076
  trav.p = (avl_node const   *)0;
#line 1076
  trav.stack[0] = (avl_node const   *)0;
#line 1076
  trav.stack[1] = (avl_node const   *)0;
#line 1076
  trav.stack[2] = (avl_node const   *)0;
#line 1076
  trav.stack[3] = (avl_node const   *)0;
#line 1076
  trav.stack[4] = (avl_node const   *)0;
#line 1076
  trav.stack[5] = (avl_node const   *)0;
#line 1076
  trav.stack[6] = (avl_node const   *)0;
#line 1076
  trav.stack[7] = (avl_node const   *)0;
#line 1076
  trav.stack[8] = (avl_node const   *)0;
#line 1076
  trav.stack[9] = (avl_node const   *)0;
#line 1076
  trav.stack[10] = (avl_node const   *)0;
#line 1076
  trav.stack[11] = (avl_node const   *)0;
#line 1076
  trav.stack[12] = (avl_node const   *)0;
#line 1076
  trav.stack[13] = (avl_node const   *)0;
#line 1076
  trav.stack[14] = (avl_node const   *)0;
#line 1076
  trav.stack[15] = (avl_node const   *)0;
#line 1076
  trav.stack[16] = (avl_node const   *)0;
#line 1076
  trav.stack[17] = (avl_node const   *)0;
#line 1076
  trav.stack[18] = (avl_node const   *)0;
#line 1076
  trav.stack[19] = (avl_node const   *)0;
#line 1076
  trav.stack[20] = (avl_node const   *)0;
#line 1076
  trav.stack[21] = (avl_node const   *)0;
#line 1076
  trav.stack[22] = (avl_node const   *)0;
#line 1076
  trav.stack[23] = (avl_node const   *)0;
#line 1076
  trav.stack[24] = (avl_node const   *)0;
#line 1076
  trav.stack[25] = (avl_node const   *)0;
#line 1076
  trav.stack[26] = (avl_node const   *)0;
#line 1076
  trav.stack[27] = (avl_node const   *)0;
#line 1076
  trav.stack[28] = (avl_node const   *)0;
#line 1076
  trav.stack[29] = (avl_node const   *)0;
#line 1076
  trav.stack[30] = (avl_node const   *)0;
#line 1076
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1079
  tmp = avl_count((avl_tree const   *)source->clients);
  }
  {
#line 1079
  tmp___0 = avl_count((avl_tree const   *)source->clients);
  }
#line 1079
  max = (unsigned int )(tmp * tmp___0 + 2);
  {
#line 1081
  xa_debug(3, (char *)"Clearing cid %d", source->cid);
  }
  {
#line 1083
  zero_trav(& trav);
  }
  {
#line 1086
  xa_debug(5, (char *)"DEBUG: In function kick_clients_on_cid. Source has %d clients",
           max);
  }
  }
  {
  {
#line 1088
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1088
    if (! (max >= 0U)) {
#line 1088
      goto while_break;
    }
    {
    {
#line 1090
    tmp___1 = avl_traverse(source->clients, & trav);
    }
#line 1090
    clicon = (connection_t *)tmp___1;
    }
#line 1091
    if (! clicon) {
#line 1092
      goto while_break;
    }
    {
    {
#line 1094
    tmp___3 = client_errors((client_t const   *)clicon->food.client);
    }
    }
#line 1094
    if (tmp___3 >= 63) {
#line 1094
      if ((clicon->food.client)->alive != 0) {
#line 1097
        if (smaller) {
          {
          {
#line 1099
          tmp___2 = con_host(clicon);
          }
          {
#line 1099
          write_log(0, (char *)"Moving client %d [%s] from mount %s to lower bitrate on mount %s",
                    clicon->id, tmp___2, source->audiocast.mount, (smaller->food.source)->audiocast.mount);
          }
          {
#line 1101
          move_to((void *)clicon, (void *)source);
          }
          }
        } else {
          {
          {
#line 1103
          kick_connection((void *)clicon, (void *)"Client cannot sustain sufficient bandwidth");
          }
          }
        }
        {
        {
#line 1105
        zero_trav(& trav);
        }
        }
      }
    }
#line 1107
    max --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1109
  source->chunk[source->cid].clients_left = 0;
  {
#line 1111
  xa_debug(5, (char *)"DEBUG: leaving function kick_clients_on_cid");
  }
  }
#line 1113
  return;
}
}
#line 1119 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void kick_dead_clients(source_t *source ) 
{ 
  avl_traverser trav ;
  connection_t *clicon ;
  int max ;
  int tmp ;
  int tmp___0 ;
  connection_t *smaller ;
  connection_t *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  connection_t *smaller___0 ;
  char const   *tmp___6 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 1122
  trav.init = 0;
#line 1122
  trav.nstack = 0;
#line 1122
  trav.p = (avl_node const   *)0;
#line 1122
  trav.stack[0] = (avl_node const   *)0;
#line 1122
  trav.stack[1] = (avl_node const   *)0;
#line 1122
  trav.stack[2] = (avl_node const   *)0;
#line 1122
  trav.stack[3] = (avl_node const   *)0;
#line 1122
  trav.stack[4] = (avl_node const   *)0;
#line 1122
  trav.stack[5] = (avl_node const   *)0;
#line 1122
  trav.stack[6] = (avl_node const   *)0;
#line 1122
  trav.stack[7] = (avl_node const   *)0;
#line 1122
  trav.stack[8] = (avl_node const   *)0;
#line 1122
  trav.stack[9] = (avl_node const   *)0;
#line 1122
  trav.stack[10] = (avl_node const   *)0;
#line 1122
  trav.stack[11] = (avl_node const   *)0;
#line 1122
  trav.stack[12] = (avl_node const   *)0;
#line 1122
  trav.stack[13] = (avl_node const   *)0;
#line 1122
  trav.stack[14] = (avl_node const   *)0;
#line 1122
  trav.stack[15] = (avl_node const   *)0;
#line 1122
  trav.stack[16] = (avl_node const   *)0;
#line 1122
  trav.stack[17] = (avl_node const   *)0;
#line 1122
  trav.stack[18] = (avl_node const   *)0;
#line 1122
  trav.stack[19] = (avl_node const   *)0;
#line 1122
  trav.stack[20] = (avl_node const   *)0;
#line 1122
  trav.stack[21] = (avl_node const   *)0;
#line 1122
  trav.stack[22] = (avl_node const   *)0;
#line 1122
  trav.stack[23] = (avl_node const   *)0;
#line 1122
  trav.stack[24] = (avl_node const   *)0;
#line 1122
  trav.stack[25] = (avl_node const   *)0;
#line 1122
  trav.stack[26] = (avl_node const   *)0;
#line 1122
  trav.stack[27] = (avl_node const   *)0;
#line 1122
  trav.stack[28] = (avl_node const   *)0;
#line 1122
  trav.stack[29] = (avl_node const   *)0;
#line 1122
  trav.stack[30] = (avl_node const   *)0;
#line 1122
  trav.stack[31] = (avl_node const   *)0;
#line 1123
  clicon = (connection_t *)((void *)0);
  {
#line 1125
  tmp = avl_count((avl_tree const   *)source->clients);
  }
  {
#line 1125
  tmp___0 = avl_count((avl_tree const   *)source->clients);
  }
#line 1125
  max = tmp * tmp___0 + 2;
  {
#line 1128
  xa_debug(5, (char *)"DEBUG: In function kick_dead_clients. Will run %d laps", max);
  }
  }
  {
  {
#line 1132
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1132
    tmp___4 = avl_traverse(source->clients, & trav);
    }
#line 1132
    clicon = (connection_t *)tmp___4;
    }
#line 1132
    if (! clicon) {
#line 1132
      goto while_break;
    }
    {
    {
#line 1133
    tmp___3 = client_errors((client_t const   *)clicon->food.client);
    }
    }
#line 1133
    if (tmp___3 >= 63) {
      {
      {
#line 1134
      tmp___1 = get_twin_mount_wl(source);
      }
#line 1134
      smaller = tmp___1;
      }
#line 1135
      if (smaller) {
        {
        {
#line 1137
        tmp___2 = con_host(clicon);
        }
        {
#line 1137
        write_log(0, (char *)"Moving client %d [%s] from mount %s to lower bitrate on mount %s",
                  clicon->id, tmp___2, source->audiocast.mount, (smaller->food.source)->audiocast.mount);
        }
        {
#line 1141
        move_to_smaller_twin(source, clicon);
        }
        }
      } else {
        {
        {
#line 1144
        kick_connection((void *)clicon, (void *)"Too many errors (client not receiving data fast enough)");
        }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1148
  zero_trav(& trav);
  }
  }
  {
  {
#line 1150
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1150
    if (! (max >= 0)) {
#line 1150
      goto while_break___0;
    }
    {
    {
#line 1152
    tmp___5 = avl_traverse(source->clients, & trav);
    }
#line 1152
    clicon = (connection_t *)tmp___5;
    }
#line 1153
    if (! clicon) {
#line 1154
      goto while_break___0;
    }
#line 1156
    if ((clicon->food.client)->alive == 5) {
#line 1158
      if (source->connected == 0) {
        {
        {
#line 1160
        smaller___0 = get_twin_mount(source);
        }
        }
      } else
#line 1158
      if (source->connected == 2) {
        {
        {
#line 1160
        smaller___0 = get_twin_mount(source);
        }
        }
      } else
#line 1158
      if (source->connected == 4) {
        {
        {
#line 1160
        smaller___0 = get_twin_mount(source);
        }
        }
      } else {
        {
        {
#line 1162
        smaller___0 = get_twin_mount_wl(source);
        }
        }
      }
#line 1164
      if (smaller___0) {
        {
        {
#line 1166
        tmp___6 = con_host(clicon);
        }
        {
#line 1166
        write_log(0, (char *)"Moving client %d [%s] from mount %s to lower bitrate on mount %s",
                  clicon->id, tmp___6, source->audiocast.mount, (smaller___0->food.source)->audiocast.mount);
        }
        {
#line 1168
        move_to((void *)clicon, (void *)smaller___0);
        }
        {
#line 1169
        zero_trav(& trav);
        }
        }
      } else {
        {
        {
#line 1172
        kick_connection((void *)clicon, (void *)"Smaller source stream signed off");
        }
        }
      }
    }
#line 1176
    if ((clicon->food.client)->alive == 0) {
      {
      {
#line 1177
      close_connection((void *)clicon, (void *)(& info));
      }
      {
#line 1178
      zero_trav(& trav);
      }
      }
    }
#line 1181
    max --;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1185
  xa_debug(5, (char *)"DEBUG: leaving function kick_dead_clients, %d laps left", max);
  }
  }
#line 1187
  return;
}
}
#line 1189 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void move_clients_to_default_mount(connection_t *con ) 
{ 
  connection_t *clicon ;
  connection_t *default_source ;
  connection_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 1192
  tmp = get_twin_mount_wl(con->food.source);
  }
#line 1192
  default_source = tmp;
  }
#line 1194
  if (! default_source) {
    {
    {
#line 1195
    default_source = get_default_mount();
    }
    }
  }
#line 1198
  if ((unsigned long )con != (unsigned long )default_source) {
#line 1198
    if (default_source) {
      {
      {
#line 1199
      thread_mutex_lock_c(& (default_source->food.source)->mutex, 1199, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
      {
      {
#line 1200
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 1200
        tmp___0 = avl_get_any_node((con->food.source)->clients);
        }
#line 1200
        clicon = (connection_t *)tmp___0;
        }
#line 1200
        if (! clicon) {
#line 1200
          goto while_break;
        }
        {
        {
#line 1201
        move_to((void *)clicon, (void *)default_source);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 1202
      thread_mutex_unlock_c(& (default_source->food.source)->mutex, 1202, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
    }
  }
#line 1204
  return;
}
}
#line 1206 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
int originating_id(connection_t *sourcecon , char *dshost ) 
{ 
  avl_traverser trav ;
  relay_id_t *rip ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1209
  trav.init = 0;
#line 1209
  trav.nstack = 0;
#line 1209
  trav.p = (avl_node const   *)0;
#line 1209
  trav.stack[0] = (avl_node const   *)0;
#line 1209
  trav.stack[1] = (avl_node const   *)0;
#line 1209
  trav.stack[2] = (avl_node const   *)0;
#line 1209
  trav.stack[3] = (avl_node const   *)0;
#line 1209
  trav.stack[4] = (avl_node const   *)0;
#line 1209
  trav.stack[5] = (avl_node const   *)0;
#line 1209
  trav.stack[6] = (avl_node const   *)0;
#line 1209
  trav.stack[7] = (avl_node const   *)0;
#line 1209
  trav.stack[8] = (avl_node const   *)0;
#line 1209
  trav.stack[9] = (avl_node const   *)0;
#line 1209
  trav.stack[10] = (avl_node const   *)0;
#line 1209
  trav.stack[11] = (avl_node const   *)0;
#line 1209
  trav.stack[12] = (avl_node const   *)0;
#line 1209
  trav.stack[13] = (avl_node const   *)0;
#line 1209
  trav.stack[14] = (avl_node const   *)0;
#line 1209
  trav.stack[15] = (avl_node const   *)0;
#line 1209
  trav.stack[16] = (avl_node const   *)0;
#line 1209
  trav.stack[17] = (avl_node const   *)0;
#line 1209
  trav.stack[18] = (avl_node const   *)0;
#line 1209
  trav.stack[19] = (avl_node const   *)0;
#line 1209
  trav.stack[20] = (avl_node const   *)0;
#line 1209
  trav.stack[21] = (avl_node const   *)0;
#line 1209
  trav.stack[22] = (avl_node const   *)0;
#line 1209
  trav.stack[23] = (avl_node const   *)0;
#line 1209
  trav.stack[24] = (avl_node const   *)0;
#line 1209
  trav.stack[25] = (avl_node const   *)0;
#line 1209
  trav.stack[26] = (avl_node const   *)0;
#line 1209
  trav.stack[27] = (avl_node const   *)0;
#line 1209
  trav.stack[28] = (avl_node const   *)0;
#line 1209
  trav.stack[29] = (avl_node const   *)0;
#line 1209
  trav.stack[30] = (avl_node const   *)0;
#line 1209
  trav.stack[31] = (avl_node const   *)0;
#line 1212
  if (! sourcecon) {
    {
    {
#line 1214
    xa_debug(1, (char *)"WARNING: originating_id called with NULL pointers");
    }
    }
#line 1215
    return (-1);
  } else
#line 1212
  if (! dshost) {
    {
    {
#line 1214
    xa_debug(1, (char *)"WARNING: originating_id called with NULL pointers");
    }
    }
#line 1215
    return (-1);
  }
#line 1218
  if ((int )(sourcecon->food.source)->type == 0) {
    {
    {
#line 1220
    xa_debug(2, (char *)"DEBUG: originating_id () return -1 cause type is encoder_e");
    }
    }
#line 1221
    return (-1);
  }
  {
  {
#line 1224
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1224
    tmp___0 = avl_traverse((sourcecon->food.source)->relay_tree, & trav);
    }
#line 1224
    rip = (relay_id_t *)tmp___0;
    }
#line 1224
    if (! rip) {
#line 1224
      goto while_break;
    }
#line 1226
    if (! rip) {
      {
      {
#line 1228
      write_log(0, (char *)"ERROR: Erroneous host in relay id");
      }
      }
#line 1229
      goto while_continue;
    } else
#line 1226
    if (! rip->host) {
      {
      {
#line 1228
      write_log(0, (char *)"ERROR: Erroneous host in relay id");
      }
      }
#line 1229
      goto while_continue;
    }
    {
    {
#line 1231
    tmp = ice_strcasecmp((char const   *)dshost, (char const   *)rip->host);
    }
    }
#line 1231
    if (tmp == 0) {
      {
      {
#line 1233
      xa_debug(2, (char *)"DEBUG: originating_id() returning %d, found hit", rip->id);
      }
      }
#line 1234
      return (rip->id);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1238
  xa_debug(2, (char *)"DEBUG: originating_id() for %s didn\'t match any hosts, returning -1",
           dshost);
  }
  }
#line 1239
  return (-1);
}
}
#line 1242 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void move_client(connection_t *clicon , source_t *source , int meta_after ) 
{ 
  int olen ;
  int tmp ;
  int write_bytes ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 1245
  tmp = find_frame_ofs(source);
  }
#line 1245
  olen = tmp;
  {
#line 1248
  tmp___0 = __errno_location();
  }
#line 1248
  *tmp___0 = 0;
  }
#line 1249
  if (olen < meta_after) {
#line 1249
    tmp___1 = olen;
  } else {
#line 1249
    tmp___1 = meta_after;
  }
  {
  {
#line 1249
  write_bytes = sock_write_bytes_or_kick(clicon->sock, clicon, (char const   *)(& source->chunk[(clicon->food.client)->cid].data[(clicon->food.client)->offset]),
                                         (int const   )tmp___1);
  }
  }
#line 1251
  if (write_bytes < 0) {
#line 1252
    return;
  }
#line 1254
  if (write_bytes > 0) {
#line 1256
    (clicon->food.client)->write_bytes += (unsigned long )write_bytes;
#line 1257
    info.hourly_stats.write_bytes += (unsigned long )write_bytes;
#line 1258
    source->stats.write_bytes += (unsigned long )write_bytes;
  }
  {
  {
#line 1261
  avl_delete(source->clients, (void const   *)clicon);
  }
  {
#line 1262
  del_client(clicon, source);
  }
#line 1263
  (clicon->food.client)->virgin = 1;
  {
#line 1264
  pool_add(clicon);
  }
  {
#line 1265
  util_increase_total_clients();
  }
  }
#line 1266
  return;
}
}
#line 1269 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
int write_data(connection_t *clicon , source_t *source ) 
{ 
  int write_bytes ;
  int *tmp ;
  char *__cil_tmp5 ;

  {
#line 1274
  if (source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset <= 0) {
#line 1275
    return (0);
  }
  {
  {
#line 1277
  write_bytes = sock_write_bytes_or_kick(clicon->sock, clicon, (char const   *)(& source->chunk[(clicon->food.client)->cid].data[(clicon->food.client)->offset]),
                                         (int const   )(source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset));
  }
  {
#line 1281
  xa_debug(4, (char *)"DEBUG: client %d in write_data(). Function write() returned %d of %d bytes, client on chunk %d (+%d), source on chunk %d",
           clicon->id, write_bytes, source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset,
           (clicon->food.client)->cid, (clicon->food.client)->offset, source->cid);
  }
  }
#line 1285
  if (write_bytes < 0) {
    {
    {
#line 1286
    tmp = __errno_location();
    }
    }
#line 1286
    return (0 - *tmp);
  }
#line 1287
  return (write_bytes);
}
}
#line 1290 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
int write_data_with_metadata(connection_t *clicon , source_t *source , int justnull ) 
{ 
  int write_bytes ;
  int res ;
  char nullc[1] ;
  int len ;
  int *tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1293
  res = 0;
#line 1296
  nullc[0] = (char )'\000';
#line 1298
  if (justnull == 1) {
    {
#line 1299
    len = source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset;
    {
#line 1301
    write_bytes = sock_write_bytes_or_kick(clicon->sock, clicon, (char const   *)(& source->chunk[(clicon->food.client)->cid].data[(clicon->food.client)->offset]),
                                           (int const   )len);
    }
    {
#line 1307
    xa_debug(4, (char *)"DEBUG: 1: Wrote %d initial bytes (len: %d offset: %d", write_bytes,
             source->chunk[(clicon->food.client)->cid].len, (clicon->food.client)->offset);
    }
    }
#line 1309
    if (write_bytes == len) {
      {
      {
#line 1310
      res = sock_write_bytes_or_kick(clicon->sock, clicon, (char const   *)(nullc),
                                     (int const   )1);
      }
      }
    }
#line 1313
    if (res > 0) {
#line 1314
      write_bytes += res;
    }
    {
    {
#line 1316
    xa_debug(4, (char *)"DEBUG: 2: Wrote %d supplemental bytes", res);
    }
    }
  } else {
    {
    {
#line 1319
    write_bytes = sock_write_bytes_or_kick(clicon->sock, clicon, (char const   *)(& source->chunk[(clicon->food.client)->cid].data[(clicon->food.client)->offset]),
                                           (int const   )(source->chunk[(clicon->food.client)->cid].metalen - (clicon->food.client)->offset));
    }
    {
#line 1325
    xa_debug(4, (char *)"DEBUG: 3: Wrote %d initial bytes (len: %d offset: %d", write_bytes,
             source->chunk[(clicon->food.client)->cid].metalen, (clicon->food.client)->offset);
    }
    }
  }
  {
  {
#line 1329
  xa_debug(4, (char *)"DEBUG: client %d in write_data_with_metadata(). Function write() returned %d of %d bytes, client on chunk %d (+%d), source on chunk %d",
           clicon->id, write_bytes, source->chunk[(clicon->food.client)->cid].len - (clicon->food.client)->offset,
           (clicon->food.client)->cid, (clicon->food.client)->offset, source->cid);
  }
  }
#line 1333
  if (write_bytes < 0) {
    {
    {
#line 1334
    tmp = __errno_location();
    }
    }
#line 1334
    return (0 - *tmp);
  }
#line 1335
  return (write_bytes);
}
}
#line 1338 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_source_with_mount(char const   *mount ) 
{ 
  avl_traverser trav ;
  connection_t *travcon ;
  char *alias ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1341
  trav.init = 0;
#line 1341
  trav.nstack = 0;
#line 1341
  trav.p = (avl_node const   *)0;
#line 1341
  trav.stack[0] = (avl_node const   *)0;
#line 1341
  trav.stack[1] = (avl_node const   *)0;
#line 1341
  trav.stack[2] = (avl_node const   *)0;
#line 1341
  trav.stack[3] = (avl_node const   *)0;
#line 1341
  trav.stack[4] = (avl_node const   *)0;
#line 1341
  trav.stack[5] = (avl_node const   *)0;
#line 1341
  trav.stack[6] = (avl_node const   *)0;
#line 1341
  trav.stack[7] = (avl_node const   *)0;
#line 1341
  trav.stack[8] = (avl_node const   *)0;
#line 1341
  trav.stack[9] = (avl_node const   *)0;
#line 1341
  trav.stack[10] = (avl_node const   *)0;
#line 1341
  trav.stack[11] = (avl_node const   *)0;
#line 1341
  trav.stack[12] = (avl_node const   *)0;
#line 1341
  trav.stack[13] = (avl_node const   *)0;
#line 1341
  trav.stack[14] = (avl_node const   *)0;
#line 1341
  trav.stack[15] = (avl_node const   *)0;
#line 1341
  trav.stack[16] = (avl_node const   *)0;
#line 1341
  trav.stack[17] = (avl_node const   *)0;
#line 1341
  trav.stack[18] = (avl_node const   *)0;
#line 1341
  trav.stack[19] = (avl_node const   *)0;
#line 1341
  trav.stack[20] = (avl_node const   *)0;
#line 1341
  trav.stack[21] = (avl_node const   *)0;
#line 1341
  trav.stack[22] = (avl_node const   *)0;
#line 1341
  trav.stack[23] = (avl_node const   *)0;
#line 1341
  trav.stack[24] = (avl_node const   *)0;
#line 1341
  trav.stack[25] = (avl_node const   *)0;
#line 1341
  trav.stack[26] = (avl_node const   *)0;
#line 1341
  trav.stack[27] = (avl_node const   *)0;
#line 1341
  trav.stack[28] = (avl_node const   *)0;
#line 1341
  trav.stack[29] = (avl_node const   *)0;
#line 1341
  trav.stack[30] = (avl_node const   *)0;
#line 1341
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1345
  thread_mutex_lock_c(& info.source_mutex, 1345, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
  {
  {
#line 1347
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1347
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 1347
    travcon = (connection_t *)tmp___1;
    }
#line 1347
    if (! travcon) {
#line 1347
      goto while_break;
    }
    {
    {
#line 1349
    alias = strchr((char const   *)(travcon->food.source)->audiocast.mount, '/');
    }
    }
#line 1349
    if (! alias) {
#line 1350
      alias = (travcon->food.source)->audiocast.mount;
    }
    {
    {
#line 1351
    tmp = ice_strcmp((char const   *)alias, mount);
    }
    }
#line 1351
    if (tmp == 0) {
      {
      {
#line 1354
      thread_mutex_unlock_c(& info.source_mutex, 1354, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 1355
      return (travcon);
    } else
#line 1351
    if ((int const   )*(mount + 0) != 47) {
      {
      {
#line 1351
      tmp___0 = ice_strcmp(mount + 0, (char const   *)(alias + 1));
      }
      }
#line 1351
      if (tmp___0 == 0) {
        {
        {
#line 1354
        thread_mutex_unlock_c(& info.source_mutex, 1354, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
        }
        }
#line 1355
        return (travcon);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1359
  thread_mutex_unlock_c(& info.source_mutex, 1359, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 1360
  return ((connection_t *)((void *)0));
}
}
#line 1363 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_source_from_host(connection_t *con ) 
{ 
  avl_traverser trav ;
  connection_t *travcon ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1366
  trav.init = 0;
#line 1366
  trav.nstack = 0;
#line 1366
  trav.p = (avl_node const   *)0;
#line 1366
  trav.stack[0] = (avl_node const   *)0;
#line 1366
  trav.stack[1] = (avl_node const   *)0;
#line 1366
  trav.stack[2] = (avl_node const   *)0;
#line 1366
  trav.stack[3] = (avl_node const   *)0;
#line 1366
  trav.stack[4] = (avl_node const   *)0;
#line 1366
  trav.stack[5] = (avl_node const   *)0;
#line 1366
  trav.stack[6] = (avl_node const   *)0;
#line 1366
  trav.stack[7] = (avl_node const   *)0;
#line 1366
  trav.stack[8] = (avl_node const   *)0;
#line 1366
  trav.stack[9] = (avl_node const   *)0;
#line 1366
  trav.stack[10] = (avl_node const   *)0;
#line 1366
  trav.stack[11] = (avl_node const   *)0;
#line 1366
  trav.stack[12] = (avl_node const   *)0;
#line 1366
  trav.stack[13] = (avl_node const   *)0;
#line 1366
  trav.stack[14] = (avl_node const   *)0;
#line 1366
  trav.stack[15] = (avl_node const   *)0;
#line 1366
  trav.stack[16] = (avl_node const   *)0;
#line 1366
  trav.stack[17] = (avl_node const   *)0;
#line 1366
  trav.stack[18] = (avl_node const   *)0;
#line 1366
  trav.stack[19] = (avl_node const   *)0;
#line 1366
  trav.stack[20] = (avl_node const   *)0;
#line 1366
  trav.stack[21] = (avl_node const   *)0;
#line 1366
  trav.stack[22] = (avl_node const   *)0;
#line 1366
  trav.stack[23] = (avl_node const   *)0;
#line 1366
  trav.stack[24] = (avl_node const   *)0;
#line 1366
  trav.stack[25] = (avl_node const   *)0;
#line 1366
  trav.stack[26] = (avl_node const   *)0;
#line 1366
  trav.stack[27] = (avl_node const   *)0;
#line 1366
  trav.stack[28] = (avl_node const   *)0;
#line 1366
  trav.stack[29] = (avl_node const   *)0;
#line 1366
  trav.stack[30] = (avl_node const   *)0;
#line 1366
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1369
  thread_mutex_lock_c(& info.source_mutex, 1369, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
  {
  {
#line 1371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1371
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 1371
    travcon = (connection_t *)tmp___0;
    }
#line 1371
    if (! travcon) {
#line 1371
      goto while_break;
    }
    {
    {
#line 1373
    tmp = hosteq(con, travcon);
    }
    }
#line 1373
    if (tmp) {
      {
      {
#line 1375
      thread_mutex_unlock_c(& info.source_mutex, 1375, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
      }
      }
#line 1376
      return (travcon);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1380
  thread_mutex_unlock_c(& info.source_mutex, 1380, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 1382
  return ((connection_t *)((void *)0));
}
}
#line 1385 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void describe_source(com_request_t const   *req , connection_t const   *sourcecon ) 
{ 
  source_t const   *source ;
  char buf[8192] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned long tmp___14 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 1391
  if (! req) {
    {
    {
#line 1393
    xa_debug(1, (char *)"WARNING: describe_source(): called with NULL pointers");
    }
    }
#line 1394
    return;
  } else
#line 1391
  if (! sourcecon) {
    {
    {
#line 1393
    xa_debug(1, (char *)"WARNING: describe_source(): called with NULL pointers");
    }
    }
#line 1394
    return;
  }
#line 1397
  if ((unsigned int const   )sourcecon->type != 1U) {
    {
    {
#line 1399
    xa_debug(1, (char *)"WARNING: describe_source(): called with invalid type");
    }
    }
#line 1400
    return;
  }
  {
  {
#line 1403
  describe_connection(req, sourcecon);
  }
#line 1405
  source = (source_t const   *)sourcecon->food.source;
  {
#line 1407
  admin_write_line(req, (int const   )485, "Misc source info:");
  }
  }
#line 1408
  if (source->connected) {
#line 1408
    tmp = "yes";
  } else {
#line 1408
    tmp = "no";
  }
  {
  {
#line 1408
  admin_write_line(req, (int const   )486, "Connected: %s", tmp);
  }
  {
#line 1409
  tmp___0 = sourcetype_to_string((source_type_t )source->type);
  }
  {
#line 1409
  admin_write_line(req, (int const   )486, "Source Type: %s", tmp___0);
  }
  }
#line 1411
  if ((unsigned int const   )source->protocol == 0U) {
#line 1411
    tmp___1 = "ICY";
  } else {
#line 1411
    tmp___1 = "x-audiocast";
  }
  {
  {
#line 1411
  admin_write_line(req, (int const   )486, "Protocol: %s", tmp___1);
  }
  {
#line 1412
  admin_write_line(req, (int const   )486, "Number of clients: %lu", source->num_clients);
  }
  }
#line 1413
  if (source->dumpfile) {
#line 1413
    tmp___2 = (char const   */* const  */)source->dumpfile;
  } else {
#line 1413
    tmp___2 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1413
  admin_write_line(req, (int const   )486, "Dumpfile and dumpfd: %s : %d", tmp___2,
                   source->dumpfd);
  }
  {
#line 1415
  admin_write_line(req, (int const   )486, "Stream priority: %d", source->priority);
  }
  }
#line 1416
  if (source->info.streamtitle) {
#line 1416
    tmp___3 = (char const   */* const  */)source->info.streamtitle;
  } else {
#line 1416
    tmp___3 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1416
  admin_write_line(req, (int const   )486, "Stream title: %s", tmp___3);
  }
  }
#line 1418
  if (source->info.streamurl) {
#line 1418
    tmp___4 = (char const   */* const  */)source->info.streamurl;
  } else {
#line 1418
    tmp___4 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1418
  admin_write_line(req, (int const   )486, "Stream url: %s", tmp___4);
  }
  }
#line 1419
  if (source->info.streammsg) {
#line 1419
    tmp___5 = (char const   */* const  */)source->info.streammsg;
  } else {
#line 1419
    tmp___5 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1419
  admin_write_line(req, (int const   )486, "Stream msg: %s", tmp___5);
  }
  {
#line 1420
  admin_write_line(req, (int const   )486, "Stream length: %ld", source->info.streamlength);
  }
  }
#line 1421
  if (source->audiocast.name) {
#line 1421
    tmp___6 = (char const   */* const  */)source->audiocast.name;
  } else {
#line 1421
    tmp___6 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1421
  admin_write_line(req, (int const   )486, "Source name: %s", tmp___6);
  }
  }
#line 1422
  if (source->audiocast.genre) {
#line 1422
    tmp___7 = (char const   */* const  */)source->audiocast.genre;
  } else {
#line 1422
    tmp___7 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1422
  admin_write_line(req, (int const   )486, "Source genre: %s", tmp___7);
  }
  {
#line 1423
  admin_write_line(req, (int const   )486, "Source bitrate: %d", source->audiocast.bitrate);
  }
  }
#line 1424
  if (source->audiocast.url) {
#line 1424
    tmp___8 = (char const   */* const  */)source->audiocast.url;
  } else {
#line 1424
    tmp___8 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1424
  admin_write_line(req, (int const   )486, "Source url: %s", tmp___8);
  }
  }
#line 1425
  if (source->audiocast.mount) {
#line 1425
    tmp___9 = (char const   */* const  */)source->audiocast.mount;
  } else {
#line 1425
    tmp___9 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1425
  admin_write_line(req, (int const   )486, "Source mount: %s", tmp___9);
  }
  }
#line 1426
  if (source->audiocast.contentid) {
#line 1426
    tmp___10 = (char const   */* const  */)source->audiocast.contentid;
  } else {
#line 1426
    tmp___10 = (char const   */* const  */)"(null";
  }
  {
  {
#line 1426
  admin_write_line(req, (int const   )486, "Source content id: %s", tmp___10);
  }
  }
#line 1427
  if (source->audiocast.description) {
#line 1427
    tmp___11 = (char const   */* const  */)source->audiocast.description;
  } else {
#line 1427
    tmp___11 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 1427
  admin_write_line(req, (int const   )486, "Source description: %s", tmp___11);
  }
  {
#line 1428
  admin_write_line(req, (int const   )486, "Megabytes read: %lu", source->stats.read_megs);
  }
  {
#line 1429
  admin_write_line(req, (int const   )486, "Megabytes written: %lu", source->stats.write_megs);
  }
  {
#line 1430
  admin_write_line(req, (int const   )486, "Client connections: %lu", source->stats.client_connections);
  }
  {
#line 1431
  tmp___12 = nice_time_minutes((unsigned long )source->stats.client_connect_time,
                               buf);
  }
  {
#line 1431
  admin_write_line(req, (int const   )486, "Client connect time: %s", tmp___12);
  }
  {
#line 1432
  tmp___13 = connect_average((unsigned long )source->stats.client_connect_time, (unsigned long )source->stats.client_connections,
                             buf);
  }
  {
#line 1432
  admin_write_line(req, (int const   )486, "Average client connect time: %s", tmp___13);
  }
  {
#line 1433
  tmp___14 = transfer_average((unsigned long )source->stats.write_megs, (unsigned long )source->stats.client_connections);
  }
  {
#line 1433
  admin_write_line(req, (int const   )486, "Average client transfer: %lu", tmp___14);
  }
  {
#line 1434
  admin_write_line(req, (int const   )486, "Stream Song Counter: %lu", source->info.udpseqnr);
  }
  {
#line 1436
  admin_write_line(req, (int const   )487, "End of source info");
  }
  }
#line 1437
  return;
}
}
#line 1439 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
char const   source_protos[2][12]  = { {        (char const   )'i',        (char const   )'c',        (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'x',        (char const   )'-',        (char const   )'a',        (char const   )'u', 
            (char const   )'d',        (char const   )'i',        (char const   )'o',        (char const   )'c', 
            (char const   )'a',        (char const   )'s',        (char const   )'t',        (char const   )'\000'}};
#line 1440 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
char const   source_types[5][16]  = { {        (char const   )'e',        (char const   )'n',        (char const   )'c',        (char const   )'o', 
            (char const   )'d',        (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'p',        (char const   )'u',        (char const   )'l',        (char const   )'l', 
            (char const   )'i',        (char const   )'n',        (char const   )'g',        (char const   )' ', 
            (char const   )'r',        (char const   )'e',        (char const   )'l',        (char const   )'a', 
            (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'o',        (char const   )'n',        (char const   )' ',        (char const   )'d', 
            (char const   )'e',        (char const   )'m',        (char const   )'a',        (char const   )'n', 
            (char const   )'d',        (char const   )' ',        (char const   )'r',        (char const   )'e', 
            (char const   )'l',        (char const   )'a',        (char const   )'y',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'i',        (char const   )'l',        (char const   )'e', 
            (char const   )' ',        (char const   )'t',        (char const   )'r',        (char const   )'a', 
            (char const   )'n',        (char const   )'s',        (char const   )'f',        (char const   )'e', 
            (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'u',        (char const   )'n',        (char const   )'k',        (char const   )'n', 
            (char const   )'o',        (char const   )'w',        (char const   )'n',        (char const   )' ', 
            (char const   )'s',        (char const   )'o',        (char const   )'u',        (char const   )'r', 
            (char const   )'c',        (char const   )'e',        (char const   )'\000'}};
#line 1442 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
char const   *sourceproto_to_string(protocol_t proto ) 
{ 


  {
#line 1445
  return (source_protos[proto]);
}
}
#line 1448 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
char const   *sourcetype_to_string(source_type_t type ) 
{ 


  {
#line 1451
  return (source_types[type]);
}
}
#line 1461 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
int start_chunk(source_t *source ) 
{ 
  int tmp ;

  {
#line 1464
  if (source->cid > 0) {
#line 1464
    tmp = source->cid - 1;
  } else {
#line 1464
    tmp = 63;
  }
#line 1464
  return (tmp);
}
}
#line 1467 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_twin_mount_proc(source_t *source ) 
{ 
  connection_t *target ;
  connection_t *max ;
  avl_traverser trav ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1469
  max = (connection_t *)((void *)0);
#line 1470
  trav.init = 0;
#line 1470
  trav.nstack = 0;
#line 1470
  trav.p = (avl_node const   *)0;
#line 1470
  trav.stack[0] = (avl_node const   *)0;
#line 1470
  trav.stack[1] = (avl_node const   *)0;
#line 1470
  trav.stack[2] = (avl_node const   *)0;
#line 1470
  trav.stack[3] = (avl_node const   *)0;
#line 1470
  trav.stack[4] = (avl_node const   *)0;
#line 1470
  trav.stack[5] = (avl_node const   *)0;
#line 1470
  trav.stack[6] = (avl_node const   *)0;
#line 1470
  trav.stack[7] = (avl_node const   *)0;
#line 1470
  trav.stack[8] = (avl_node const   *)0;
#line 1470
  trav.stack[9] = (avl_node const   *)0;
#line 1470
  trav.stack[10] = (avl_node const   *)0;
#line 1470
  trav.stack[11] = (avl_node const   *)0;
#line 1470
  trav.stack[12] = (avl_node const   *)0;
#line 1470
  trav.stack[13] = (avl_node const   *)0;
#line 1470
  trav.stack[14] = (avl_node const   *)0;
#line 1470
  trav.stack[15] = (avl_node const   *)0;
#line 1470
  trav.stack[16] = (avl_node const   *)0;
#line 1470
  trav.stack[17] = (avl_node const   *)0;
#line 1470
  trav.stack[18] = (avl_node const   *)0;
#line 1470
  trav.stack[19] = (avl_node const   *)0;
#line 1470
  trav.stack[20] = (avl_node const   *)0;
#line 1470
  trav.stack[21] = (avl_node const   *)0;
#line 1470
  trav.stack[22] = (avl_node const   *)0;
#line 1470
  trav.stack[23] = (avl_node const   *)0;
#line 1470
  trav.stack[24] = (avl_node const   *)0;
#line 1470
  trav.stack[25] = (avl_node const   *)0;
#line 1470
  trav.stack[26] = (avl_node const   *)0;
#line 1470
  trav.stack[27] = (avl_node const   *)0;
#line 1470
  trav.stack[28] = (avl_node const   *)0;
#line 1470
  trav.stack[29] = (avl_node const   *)0;
#line 1470
  trav.stack[30] = (avl_node const   *)0;
#line 1470
  trav.stack[31] = (avl_node const   *)0;
  {
  {
#line 1472
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1472
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 1472
    target = (connection_t *)tmp___1;
    }
#line 1472
    if (! target) {
#line 1472
      goto while_break;
    }
#line 1473
    if ((unsigned long )source->audiocast.contentid != (unsigned long )((void *)0)) {
#line 1473
      if (*(source->audiocast.contentid + 0)) {
#line 1473
        if ((unsigned long )(target->food.source)->audiocast.contentid != (unsigned long )((void *)0)) {
          {
          {
#line 1473
          tmp = ice_strcmp((char const   *)source->audiocast.contentid, (char const   *)(target->food.source)->audiocast.contentid);
          }
          }
#line 1473
          if (tmp == 0) {
#line 1473
            if ((target->food.source)->audiocast.bitrate <= source->audiocast.bitrate) {
              {
              {
#line 1473
              tmp___0 = thread_equal(source->thread, (target->food.source)->thread);
              }
              }
#line 1473
              if (! tmp___0) {
#line 1479
                max = target;
#line 1481
                goto while_break;
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1485
  return (max);
}
}
#line 1489 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_twin_mount(source_t *source ) 
{ 
  connection_t *tmp ;

  {
  {
  {
#line 1491
  tmp = get_twin_mount_proc(source);
  }
  }
#line 1491
  return (tmp);
}
}
#line 1494 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
connection_t *get_twin_mount_wl(source_t *source ) 
{ 
  connection_t *max ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 1496
  max = (connection_t *)((void *)0);
  {
#line 1498
  thread_mutex_lock_c(& info.source_mutex, 1498, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  {
#line 1500
  max = get_twin_mount_proc(source);
  }
  {
#line 1502
  thread_mutex_unlock_c(& info.source_mutex, 1502, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c");
  }
  }
#line 1504
  return (max);
}
}
#line 1507 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void move_to_smaller_twin(source_t *source , connection_t *clicon ) 
{ 


  {
#line 1509
  (clicon->food.client)->alive = 5;
#line 1510
  return;
}
}
#line 1512 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void source_write_to_client(source_t *source , connection_t *clicon ) 
{ 
  client_t *client ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1517
  if (! clicon) {
    {
    {
#line 1518
    xa_debug(1, (char *)"WARNING: source_write_to_client() called with NULL pointers");
    }
    }
#line 1519
    return;
  } else
#line 1517
  if (! source) {
    {
    {
#line 1518
    xa_debug(1, (char *)"WARNING: source_write_to_client() called with NULL pointers");
    }
    }
#line 1519
    return;
  }
#line 1522
  client = clicon->food.client;
#line 1524
  if (client->alive == 0) {
#line 1525
    return;
  }
#line 1527
  if (client->virgin == 3) {
#line 1528
    return;
  } else
#line 1527
  if (client->virgin == -1) {
#line 1528
    return;
  }
#line 1530
  if (client->virgin == 4) {
    {
    {
#line 1531
    client->cid = start_chunk(source);
    }
    {
#line 1532
    client->offset = find_frame_ofs(source);
    }
#line 1533
    client->virgin = 0;
    }
  }
#line 1536
  if (client->virgin == 1) {
    {
    {
#line 1537
    client->cid = start_chunk(source);
    }
    {
#line 1538
    client->offset = find_frame_ofs(source);
    }
    {
#line 1539
    xa_debug(2, (char *)"Client got offset %d", client->offset);
    }
#line 1540
    client->virgin = 0;
#line 1541
    (source->num_clients) ++;
    }
  }
#line 1544
  if ((clicon->food.client)->use_icy_metadata) {
#line 1544
    if (info.use_meta_data) {
      {
      {
#line 1545
      write_chunk_with_metadata(source, clicon);
      }
      }
    } else {
      {
      {
#line 1547
      write_chunk(source, clicon);
      }
      }
    }
  } else {
    {
    {
#line 1547
    write_chunk(source, clicon);
    }
    }
  }
#line 1548
  return;
}
}
#line 1550 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
void source_get_new_clients(source_t *source ) 
{ 
  connection_t *clicon ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 1555
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1555
    clicon = pool_get_my_clients((source_t const   *)source);
    }
    }
#line 1555
    if (! clicon) {
#line 1555
      goto while_break;
    }
    {
    {
#line 1556
    xa_debug(1, (char *)"DEBUG: source_get_new_clients(): Accepted client %d", clicon->id);
    }
    {
#line 1557
    avl_insert(source->clients, (void *)clicon);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1559
  return;
}
}
#line 1561 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/source.c"
int source_get_id(char *argument ) 
{ 
  connection_t *con ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1566
  if (! argument) {
#line 1567
    return (-1);
  } else
#line 1566
  if (! *(argument + 0)) {
#line 1567
    return (-1);
  }
  {
  {
#line 1569
  tmp___0 = __ctype_b_loc();
  }
  }
#line 1569
  if ((int const   )*(*tmp___0 + (int )*(argument + 0)) & 2048) {
    {
    {
#line 1569
    tmp___1 = strchr((char const   *)argument, '.');
    }
    }
#line 1569
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 1569
      tmp___2 = strchr((char const   *)argument, '/');
      }
      }
#line 1569
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        {
        {
#line 1570
        tmp = atoi((char const   *)argument);
        }
        }
#line 1570
        return (tmp);
      }
    }
  }
  {
  {
#line 1572
  con = find_source_with_mount(argument);
  }
  }
#line 1574
  if (con) {
#line 1575
    return ((int )con->id);
  }
#line 1577
  return (-1);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.h"
scheme_t admin_scheme(com_request_t *req ) ;
#line 40
int admin_write_raw(com_request_t const   *req , char const   *fmt  , ...) ;
#line 34 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.h"
void item_write_formatted_line(com_request_t *req , int type , item_type_t itype ,
                               int num  , ...) ;
#line 35
void item_write_type(com_request_t *req , int type , item_type_t itype , item_token_t token ,
                     char const   *firstvalue ) ;
#line 36
void item_write_item(com_request_t *req , item_type_t itype , item_t *item ) ;
#line 37
void item_write_item_default(com_request_t *req , item_type_t itype , item_t *item ) ;
#line 38
void item_write_item_html(com_request_t *req , item_type_t itype , item_t *item ) ;
#line 39
item_t *item_create(char const   *name , char const   *format , void const   *value ) ;
#line 40
void item_dispose(item_t *item ) ;
#line 41
void item_write_value(com_request_t const   *req , char const   *format , char const   *buf ,
                      void const   *value ) ;
#line 88 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_formatted_line(com_request_t *req , int type , item_type_t itype ,
                               int num  , ...) 
{ 
  va_list ap ;
  int first ;
  char valuefirst[8192] ;
  item_t *item ;
  item_t *tmp___0 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 92
  first = 1;
#line 95
  if (! req) {
    {
    {
#line 96
    write_log(0, (char *)"ERROR: Invalid arguments for admin_write_formatted_line()");
    }
    }
#line 97
    return;
  } else
#line 95
  if (num < 1) {
    {
    {
#line 96
    write_log(0, (char *)"ERROR: Invalid arguments for admin_write_formatted_line()");
    }
    }
#line 97
    return;
  }
  {
  {
#line 100
  __builtin_va_start(ap, num);
  }
  {
#line 102
  item_write_type(req, type, itype, (item_token_t )0, (char const   *)((void *)0));
  }
  }
  {
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 104
    if (! (num > 0)) {
#line 104
      goto while_break;
    }
    {
    {
#line 105
    tmp___0 = __builtin_va_arg(ap, item_t *);
    }
#line 105
    item = tmp___0;
    {
#line 106
    item_write_item(req, itype, item);
    }
    }
#line 108
    if (first) {
#line 109
      if ((int )*(item->format + 1) == 115) {
#line 109
        if ((unsigned long )item->value != (unsigned long )((void *)0)) {
          {
          {
#line 110
          snprintf((char */* __restrict  */)(valuefirst), (size_t )8192, (char const   */* __restrict  */)"%s",
                   (char *)item->value);
          }
          }
        }
      }
#line 111
      first = 0;
    }
    {
    {
#line 114
    item_dispose(item);
    }
#line 115
    num --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 118
  item_write_type(req, type, itype, (item_token_t )1, (char const   *)(valuefirst));
  }
  {
#line 120
  __builtin_va_end(ap);
  }
  }
#line 121
  return;
}
}
#line 123 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_type(com_request_t *req , int type , item_type_t itype , item_token_t token ,
                     char const   *firstvalue ) 
{ 
  scheme_t tmp ;
  scheme_t tmp___0 ;
  scheme_t tmp___1 ;
  scheme_t tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 126
  if (! req) {
    {
    {
#line 127
    write_log(0, (char *)"ERROR: item_write_type() called with invalid arguments");
    }
    }
#line 128
    return;
  }
  {
#line 132
  if ((unsigned int )token == 0U) {
#line 132
    goto case_0;
  }
#line 164
  if ((unsigned int )token == 1U) {
#line 164
    goto case_1___0;
  }
#line 131
  goto switch_break;
  case_0: /* CIL Label */ 
#line 133
  if (type == -1) {
#line 134
    return;
  } else {
    {
    {
#line 133
    tmp___1 = admin_scheme(req);
    }
    }
#line 133
    if ((unsigned int )tmp___1 == 1U) {
#line 134
      return;
    } else {
      {
      {
#line 135
      tmp___0 = admin_scheme(req);
      }
      }
#line 135
      if ((unsigned int )tmp___0 == 0U) {
        {
#line 137
        if ((unsigned int )itype == 0U) {
#line 137
          goto case_0___0;
        }
#line 140
        if ((unsigned int )itype == 4U) {
#line 140
          goto case_4;
        }
#line 143
        if ((unsigned int )itype == 1U) {
#line 143
          goto case_1;
        }
#line 146
        if ((unsigned int )itype == 3U) {
#line 146
          goto case_3;
        }
#line 150
        if ((unsigned int )itype == 6U) {
#line 150
          goto case_6;
        }
#line 150
        if ((unsigned int )itype == 2U) {
#line 150
          goto case_6;
        }
#line 153
        goto switch_default;
        case_0___0: /* CIL Label */ 
        {
        {
#line 138
        admin_write_raw((com_request_t const   *)req, "%s", "<h2>");
        }
        }
#line 139
        goto switch_break___0;
        case_4: /* CIL Label */ 
        {
        {
#line 141
        admin_write_raw((com_request_t const   *)req, "%s", "<tr>");
        }
        }
#line 142
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
        {
#line 144
        admin_write_raw((com_request_t const   *)req, "%s", "<h2>");
        }
        }
#line 145
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
        {
#line 147
        admin_write_raw((com_request_t const   *)req, "%s", "<h1>");
        }
        }
#line 148
        goto switch_break___0;
        case_6: /* CIL Label */ 
        case_2: /* CIL Label */ 
        {
        {
#line 151
        admin_write_raw((com_request_t const   *)req, "%s", "<tr>");
        }
        }
#line 152
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 154
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 156
        tmp = admin_scheme(req);
        }
        }
#line 156
        if ((unsigned int )tmp == 2U) {
#line 157
          if (req->wid == -1) {
            {
            {
#line 158
            admin_write_raw((com_request_t const   *)req, "M%d ", type);
            }
            }
          } else {
            {
            {
#line 160
            admin_write_raw((com_request_t const   *)req, "M%d W%d ", type, req->wid);
            }
            }
          }
        }
      }
    }
  }
#line 162
  goto switch_break;
  case_1___0: /* CIL Label */ 
  {
  {
#line 165
  tmp___2 = admin_scheme(req);
  }
  }
#line 165
  if ((unsigned int )tmp___2 == 0U) {
    {
#line 167
    if ((unsigned int )itype == 0U) {
#line 167
      goto case_0___1;
    }
#line 170
    if ((unsigned int )itype == 1U) {
#line 170
      goto case_1___1;
    }
#line 173
    if ((unsigned int )itype == 3U) {
#line 173
      goto case_3___0;
    }
#line 176
    if ((unsigned int )itype == 4U) {
#line 176
      goto case_4___0;
    }
#line 179
    if ((unsigned int )itype == 2U) {
#line 179
      goto case_2___0;
    }
#line 182
    if ((unsigned int )itype == 6U) {
#line 182
      goto case_6___0;
    }
#line 185
    goto switch_default___0;
    case_0___1: /* CIL Label */ 
    {
    {
#line 168
    admin_write_raw((com_request_t const   *)req, "%s", "</h2><table cellpadding=3 cellspacing=0 border=0>\r\n");
    }
    }
#line 169
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
    {
#line 171
    admin_write_raw((com_request_t const   *)req, "%s", "</h2>\r\n");
    }
    }
#line 172
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
    {
#line 174
    admin_write_raw((com_request_t const   *)req, "%s", "</h1>\r\n");
    }
    }
#line 175
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
    {
#line 177
    admin_write_raw((com_request_t const   *)req, "%s", "</tr>\r\n");
    }
    }
#line 178
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
    {
#line 180
    admin_write_raw((com_request_t const   *)req, "%s", "</tr>\r\n");
    }
    }
#line 181
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
    {
    {
#line 183
    admin_write_raw((com_request_t const   *)req, "<td><a href=\"/admin?mode=change&argument=%s\">Change</a></td><td><a href=\"/admin?mode=help#%s\">Help</a></td></tr>\r\n",
                    firstvalue, firstvalue);
    }
    }
#line 184
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
    {
#line 186
    admin_write_raw((com_request_t const   *)req, "%s", "<br>\r\n");
    }
    }
    switch_break___1: /* CIL Label */ ;
    }
  } else
#line 189
  if ((unsigned int )itype != 4U) {
    {
    {
#line 190
    admin_write_raw((com_request_t const   *)req, "%s", "\r\n");
    }
    }
  }
#line 192
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_item(com_request_t *req , item_type_t itype , item_t *item ) 
{ 
  scheme_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 199
  if (! req) {
    {
    {
#line 200
    write_log(0, (char *)"WARNING: item_write_item() called with invalid arguments");
    }
    }
#line 201
    return;
  } else
#line 199
  if (! item) {
    {
    {
#line 200
    write_log(0, (char *)"WARNING: item_write_item() called with invalid arguments");
    }
    }
#line 201
    return;
  } else
#line 199
  if (! item->name) {
    {
    {
#line 200
    write_log(0, (char *)"WARNING: item_write_item() called with invalid arguments");
    }
    }
#line 201
    return;
  }
  {
  {
#line 205
  tmp = admin_scheme(req);
  }
  }
  {
#line 207
  if ((unsigned int )tmp == 1U) {
#line 207
    goto case_1;
  }
#line 207
  if ((unsigned int )tmp == 2U) {
#line 207
    goto case_1;
  }
#line 210
  if ((unsigned int )tmp == 0U) {
#line 210
    goto case_0;
  }
#line 205
  goto switch_break;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
  {
#line 208
  item_write_item_default(req, itype, item);
  }
  }
#line 209
  goto switch_break;
  case_0: /* CIL Label */ 
  {
  {
#line 211
  item_write_item_html(req, itype, item);
  }
  }
#line 212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_item_default(com_request_t *req , item_type_t itype , item_t *item ) 
{ 
  char buf[8192] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 221
  buf[0] = (char )'\000';
  {
#line 226
  if ((unsigned int )itype == 3U) {
#line 226
    goto case_3;
  }
#line 226
  if ((unsigned int )itype == 1U) {
#line 226
    goto case_3;
  }
#line 226
  if ((unsigned int )itype == 0U) {
#line 226
    goto case_3;
  }
#line 235
  if ((unsigned int )itype == 6U) {
#line 235
    goto case_6;
  }
#line 235
  if ((unsigned int )itype == 2U) {
#line 235
    goto case_6;
  }
#line 242
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 227
  if ((unsigned long )item->value == (unsigned long )((void *)0)) {
    {
    {
#line 228
    admin_write_raw((com_request_t const   *)req, "%s", item->name);
    }
    }
  } else {
    {
    {
#line 230
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s",
             item->name);
    }
    {
#line 231
    item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                     item->value);
    }
    }
  }
#line 233
  goto switch_break;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 236
  if (item->name) {
#line 236
    if (*(item->name + 0)) {
      {
      {
#line 237
      snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"[%s: %s] ",
               item->name, item->format);
      }
      }
    } else {
      {
      {
#line 239
      snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s",
               item->format);
      }
      }
    }
  } else {
    {
    {
#line 239
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s",
             item->format);
    }
    }
  }
  {
  {
#line 240
  item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                   item->value);
  }
  }
#line 241
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 243
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 245
  return;
}
}
#line 247 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_item_html(com_request_t *req , item_type_t itype , item_t *item ) 
{ 
  char buf[8192] ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 252
  buf[0] = (char )'\000';
  {
#line 255
  if ((unsigned int )itype == 3U) {
#line 255
    goto case_3;
  }
#line 263
  if ((unsigned int )itype == 0U) {
#line 263
    goto case_0;
  }
#line 271
  if ((unsigned int )itype == 1U) {
#line 271
    goto case_1;
  }
#line 280
  if ((unsigned int )itype == 6U) {
#line 280
    goto case_6;
  }
#line 280
  if ((unsigned int )itype == 2U) {
#line 280
    goto case_6;
  }
#line 284
  if ((unsigned int )itype == 4U) {
#line 284
    goto case_4;
  }
#line 287
  goto switch_default;
  case_3: /* CIL Label */ 
#line 256
  if ((unsigned long )item->value == (unsigned long )((void *)0)) {
    {
    {
#line 257
    admin_write_raw((com_request_t const   *)req, "%s", item->name);
    }
    }
  } else {
    {
    {
#line 259
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s",
             item->name);
    }
    {
#line 260
    item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                     item->value);
    }
    }
  }
#line 262
  goto switch_break;
  case_0: /* CIL Label */ 
#line 264
  if ((unsigned long )item->value == (unsigned long )((void *)0)) {
    {
    {
#line 265
    admin_write_raw((com_request_t const   *)req, "%s<br>", item->name);
    }
    }
  } else {
    {
    {
#line 267
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s<br>",
             item->name);
    }
    {
#line 268
    item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                     item->value);
    }
    }
  }
#line 270
  goto switch_break;
  case_1: /* CIL Label */ 
#line 272
  if ((unsigned long )item->value == (unsigned long )((void *)0)) {
    {
    {
#line 273
    admin_write_raw((com_request_t const   *)req, "</table><br>%s<br>", item->name);
    }
    }
  } else {
    {
    {
#line 275
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"</table><br>%s<br>",
             item->name);
    }
    {
#line 276
    item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                     item->value);
    }
    }
  }
#line 278
  goto switch_break;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
  {
#line 281
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"<td>%s</td>",
           item->format);
  }
  {
#line 282
  item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                   item->value);
  }
  }
#line 283
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 285
  admin_write_raw((com_request_t const   *)req, "<td>%s</td>", item->name);
  }
  }
#line 286
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 288
  if ((unsigned long )item->value == (unsigned long )((void *)0)) {
    {
    {
#line 289
    admin_write_raw((com_request_t const   *)req, "%s", item->name);
    }
    }
  } else {
    {
    {
#line 291
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%s",
             item->name);
    }
    {
#line 292
    item_write_value((com_request_t const   *)req, (char const   *)item->format, (char const   *)(buf),
                     item->value);
    }
    }
  }
#line 294
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 296
  return;
}
}
#line 298 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
item_t *item_create(char const   *name , char const   *format , void const   *value ) 
{ 
  item_t *new ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 301
  tmp = n_malloc((unsigned int const   )sizeof(item_t ), (int const   )301, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
#line 301
  new = (item_t *)tmp;
  {
#line 302
  new->name = n_strdup(name, (int const   )302, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
  {
#line 303
  new->format = n_strdup(format, (int const   )303, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
#line 304
  new->value = value;
  }
#line 305
  return (new);
}
}
#line 308 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_dispose(item_t *item ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 311
  n_free((void *)item->name, (int const   )311, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
#line 311
  item->name = (char *)((void *)0);
  {
#line 312
  n_free((void *)item->format, (int const   )312, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
#line 312
  item->format = (char *)((void *)0);
  {
#line 313
  n_free((void *)item, (int const   )313, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c");
  }
#line 313
  item = (item_t *)((void *)0);
  }
#line 314
  return;
}
}
#line 316 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/item.c"
void item_write_value(com_request_t const   *req , char const   *format , char const   *buf ,
                      void const   *value ) 
{ 
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 319
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
    {
#line 320
    write_log(0, (char *)"ERROR: item_write_value() called with NULL buf");
    }
    }
#line 321
    return;
  }
#line 324
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 324
    goto _L;
  } else
#line 324
  if ((unsigned long )format == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 325
    if (buf) {
#line 325
      tmp = buf;
    } else {
#line 325
      tmp = "(null)";
    }
    {
    {
#line 325
    admin_write_raw(req, "%s", tmp);
    }
    }
#line 326
    return;
  }
#line 329
  if ((int const   )*(format + 1) == 100) {
    {
    {
#line 330
    admin_write_raw(req, buf, *((int *)value));
    }
    }
  } else
#line 331
  if ((int const   )*(format + 1) == 102) {
    {
    {
#line 332
    admin_write_raw(req, buf, *((double *)value));
    }
    }
  } else {
    {
    {
#line 334
    admin_write_raw(req, buf, value);
    }
    }
  }
#line 335
  return;
}
}
#line 1 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.h"
void list_aliases(com_request_t *req ) ;
#line 2
alias_t *create_alias(void) ;
#line 3
alias_t *add_alias(request_t *name , request_t *real ) ;
#line 5
int del_alias(char *name ) ;
#line 6
void remove_alias(alias_t *al ) ;
#line 7
void free_aliases(void) ;
#line 73 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
void list_aliases(com_request_t *req ) 
{ 
  avl_traverser trav ;
  alias_t *alias ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 76
  trav.init = 0;
#line 76
  trav.nstack = 0;
#line 76
  trav.p = (avl_node const   *)0;
#line 76
  trav.stack[0] = (avl_node const   *)0;
#line 76
  trav.stack[1] = (avl_node const   *)0;
#line 76
  trav.stack[2] = (avl_node const   *)0;
#line 76
  trav.stack[3] = (avl_node const   *)0;
#line 76
  trav.stack[4] = (avl_node const   *)0;
#line 76
  trav.stack[5] = (avl_node const   *)0;
#line 76
  trav.stack[6] = (avl_node const   *)0;
#line 76
  trav.stack[7] = (avl_node const   *)0;
#line 76
  trav.stack[8] = (avl_node const   *)0;
#line 76
  trav.stack[9] = (avl_node const   *)0;
#line 76
  trav.stack[10] = (avl_node const   *)0;
#line 76
  trav.stack[11] = (avl_node const   *)0;
#line 76
  trav.stack[12] = (avl_node const   *)0;
#line 76
  trav.stack[13] = (avl_node const   *)0;
#line 76
  trav.stack[14] = (avl_node const   *)0;
#line 76
  trav.stack[15] = (avl_node const   *)0;
#line 76
  trav.stack[16] = (avl_node const   *)0;
#line 76
  trav.stack[17] = (avl_node const   *)0;
#line 76
  trav.stack[18] = (avl_node const   *)0;
#line 76
  trav.stack[19] = (avl_node const   *)0;
#line 76
  trav.stack[20] = (avl_node const   *)0;
#line 76
  trav.stack[21] = (avl_node const   *)0;
#line 76
  trav.stack[22] = (avl_node const   *)0;
#line 76
  trav.stack[23] = (avl_node const   *)0;
#line 76
  trav.stack[24] = (avl_node const   *)0;
#line 76
  trav.stack[25] = (avl_node const   *)0;
#line 76
  trav.stack[26] = (avl_node const   *)0;
#line 76
  trav.stack[27] = (avl_node const   *)0;
#line 76
  trav.stack[28] = (avl_node const   *)0;
#line 76
  trav.stack[29] = (avl_node const   *)0;
#line 76
  trav.stack[30] = (avl_node const   *)0;
#line 76
  trav.stack[31] = (avl_node const   *)0;
#line 79
  if (! req) {
    {
    {
#line 81
    write_log(0, (char *)"WARNING: list_aliases called with NULL pointer");
    }
    }
#line 82
    return;
  }
  {
  {
#line 85
  admin_write_line((com_request_t const   *)req, (int const   )336, "Listing aliases");
  }
  {
#line 87
  thread_mutex_lock_c(& info.alias_mutex, 87, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
  {
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 89
    tmp = avl_traverse(info.aliases, & trav);
    }
#line 89
    alias = (alias_t *)tmp;
    }
#line 89
    if (! alias) {
#line 89
      goto while_break;
    }
    {
    {
#line 90
    admin_write_line((com_request_t const   *)req, (int const   )337, "\t[%s:%d%s]\t[%s:%d%s]",
                     (alias->name)->host, (alias->name)->port, (alias->name)->path,
                     (alias->real)->host, (alias->real)->port, (alias->real)->path);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 93
  thread_mutex_unlock_c(& info.alias_mutex, 93, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  {
#line 95
  tmp___0 = avl_count((avl_tree const   *)info.aliases);
  }
  {
#line 95
  admin_write_line((com_request_t const   *)req, (int const   )338, "End of alias listing (%d listed)",
                   tmp___0);
  }
  }
#line 96
  return;
}
}
#line 98 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
alias_t *create_alias(void) 
{ 
  alias_t *res ;
  void *tmp ;
  request_t *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 101
  tmp = n_malloc((unsigned int const   )sizeof(alias_t ), (int const   )101, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
#line 101
  res = (alias_t *)tmp;
#line 102
  tmp___0 = (request_t *)((void *)0);
#line 102
  res->name = tmp___0;
#line 102
  res->real = tmp___0;
  }
#line 103
  return (res);
}
}
#line 106 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
request_t *create_request(void) 
{ 
  request_t *req ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 109
  tmp = n_malloc((unsigned int const   )sizeof(request_t ), (int const   )109, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
#line 109
  req = (request_t *)tmp;
#line 110
  req->port = -1;
#line 111
  req->host[0] = (char )'\000';
#line 112
  req->path[0] = (char )'\000';
  }
#line 113
  return (req);
}
}
#line 116 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
alias_t *add_alias(request_t *name , request_t *real ) 
{ 
  alias_t *res ;
  alias_t *out ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 121
  if (! name) {
#line 122
    return ((alias_t *)((void *)0));
  } else
#line 121
  if (! real) {
#line 122
    return ((alias_t *)((void *)0));
  }
  {
  {
#line 124
  xa_debug(1, (char *)"DEBUG: adding alias [%s:%d%s] for [%s:%d%s]", name->host, name->port,
           name->path, real->host, real->port, real->path);
  }
  {
#line 127
  res = create_alias();
  }
  {
#line 128
  res->name = create_request();
  }
  {
#line 129
  res->real = create_request();
  }
  {
#line 131
  strcpy((char */* __restrict  */)((res->name)->host), (char const   */* __restrict  */)(name->host));
  }
  {
#line 132
  strcpy((char */* __restrict  */)((res->name)->path), (char const   */* __restrict  */)(name->path));
  }
#line 133
  (res->name)->port = name->port;
  {
#line 135
  strcpy((char */* __restrict  */)((res->real)->host), (char const   */* __restrict  */)(real->host));
  }
  {
#line 136
  strcpy((char */* __restrict  */)((res->real)->path), (char const   */* __restrict  */)(real->path));
  }
#line 137
  (res->real)->port = real->port;
  {
#line 139
  thread_mutex_lock_c(& info.alias_mutex, 139, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  {
#line 141
  tmp = avl_replace(info.aliases, (void *)res);
  }
#line 141
  out = (alias_t *)tmp;
  }
#line 143
  if (out) {
    {
    {
#line 145
    n_free((void *)out->name, (int const   )145, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 145
    out->name = (request_t *)((void *)0);
#line 146
    out->name = (request_t *)((void *)0);
    {
#line 147
    n_free((void *)out->real, (int const   )147, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 147
    out->real = (request_t *)((void *)0);
#line 148
    out->real = (request_t *)((void *)0);
    {
#line 149
    n_free((void *)out, (int const   )149, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 149
    out = (alias_t *)((void *)0);
#line 150
    out = (alias_t *)((void *)0);
    }
  }
  {
  {
#line 153
  thread_mutex_unlock_c(& info.alias_mutex, 153, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
#line 155
  return (res);
}
}
#line 158 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
request_t *get_alias(request_t *req ) 
{ 
  avl_traverser trav ;
  alias_t *res ;
  alias_t search ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  request_t *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 161
  trav.init = 0;
#line 161
  trav.nstack = 0;
#line 161
  trav.p = (avl_node const   *)0;
#line 161
  trav.stack[0] = (avl_node const   *)0;
#line 161
  trav.stack[1] = (avl_node const   *)0;
#line 161
  trav.stack[2] = (avl_node const   *)0;
#line 161
  trav.stack[3] = (avl_node const   *)0;
#line 161
  trav.stack[4] = (avl_node const   *)0;
#line 161
  trav.stack[5] = (avl_node const   *)0;
#line 161
  trav.stack[6] = (avl_node const   *)0;
#line 161
  trav.stack[7] = (avl_node const   *)0;
#line 161
  trav.stack[8] = (avl_node const   *)0;
#line 161
  trav.stack[9] = (avl_node const   *)0;
#line 161
  trav.stack[10] = (avl_node const   *)0;
#line 161
  trav.stack[11] = (avl_node const   *)0;
#line 161
  trav.stack[12] = (avl_node const   *)0;
#line 161
  trav.stack[13] = (avl_node const   *)0;
#line 161
  trav.stack[14] = (avl_node const   *)0;
#line 161
  trav.stack[15] = (avl_node const   *)0;
#line 161
  trav.stack[16] = (avl_node const   *)0;
#line 161
  trav.stack[17] = (avl_node const   *)0;
#line 161
  trav.stack[18] = (avl_node const   *)0;
#line 161
  trav.stack[19] = (avl_node const   *)0;
#line 161
  trav.stack[20] = (avl_node const   *)0;
#line 161
  trav.stack[21] = (avl_node const   *)0;
#line 161
  trav.stack[22] = (avl_node const   *)0;
#line 161
  trav.stack[23] = (avl_node const   *)0;
#line 161
  trav.stack[24] = (avl_node const   *)0;
#line 161
  trav.stack[25] = (avl_node const   *)0;
#line 161
  trav.stack[26] = (avl_node const   *)0;
#line 161
  trav.stack[27] = (avl_node const   *)0;
#line 161
  trav.stack[28] = (avl_node const   *)0;
#line 161
  trav.stack[29] = (avl_node const   *)0;
#line 161
  trav.stack[30] = (avl_node const   *)0;
#line 161
  trav.stack[31] = (avl_node const   *)0;
#line 162
  res = (alias_t *)((void *)0);
#line 164
  if (! req) {
    {
    {
#line 166
    write_log(0, (char *)"ERROR: get_alias called with NULL source");
    }
    }
#line 167
    return ((request_t *)((void *)0));
  }
  {
  {
#line 170
  thread_mutex_lock_c(& info.alias_mutex, 170, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 172
    tmp___2 = avl_traverse(info.aliases, & trav);
    }
#line 172
    res = (alias_t *)tmp___2;
    }
#line 172
    if (! res) {
#line 172
      goto while_break;
    }
    {
    {
#line 173
    tmp___0 = hostname_local((res->name)->host);
    }
    }
#line 173
    if (tmp___0) {
      {
      {
#line 173
      tmp___1 = hostname_local(req->host);
      }
      }
#line 173
      if (tmp___1) {
        {
        {
#line 174
        tmp = ice_strcmp((char const   *)((res->name)->path), (char const   *)(req->path));
        }
        }
#line 174
        if (tmp == 0) {
#line 175
          goto while_break;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if (! res) {
    {
#line 180
    search.name = req;
    {
#line 182
    tmp___3 = avl_find(info.aliases, (void const   *)(& search));
    }
#line 182
    res = (alias_t *)tmp___3;
    }
  }
  {
  {
#line 185
  thread_mutex_unlock_c(& info.alias_mutex, 185, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
#line 187
  if (res) {
#line 187
    tmp___4 = res->real;
  } else {
#line 187
    tmp___4 = (request_t *)((void *)0);
  }
#line 187
  return (tmp___4);
}
}
#line 190 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
int del_alias(char *name ) 
{ 
  avl_traverser trav ;
  alias_t *res ;
  char full[8192] ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 193
  trav.init = 0;
#line 193
  trav.nstack = 0;
#line 193
  trav.p = (avl_node const   *)0;
#line 193
  trav.stack[0] = (avl_node const   *)0;
#line 193
  trav.stack[1] = (avl_node const   *)0;
#line 193
  trav.stack[2] = (avl_node const   *)0;
#line 193
  trav.stack[3] = (avl_node const   *)0;
#line 193
  trav.stack[4] = (avl_node const   *)0;
#line 193
  trav.stack[5] = (avl_node const   *)0;
#line 193
  trav.stack[6] = (avl_node const   *)0;
#line 193
  trav.stack[7] = (avl_node const   *)0;
#line 193
  trav.stack[8] = (avl_node const   *)0;
#line 193
  trav.stack[9] = (avl_node const   *)0;
#line 193
  trav.stack[10] = (avl_node const   *)0;
#line 193
  trav.stack[11] = (avl_node const   *)0;
#line 193
  trav.stack[12] = (avl_node const   *)0;
#line 193
  trav.stack[13] = (avl_node const   *)0;
#line 193
  trav.stack[14] = (avl_node const   *)0;
#line 193
  trav.stack[15] = (avl_node const   *)0;
#line 193
  trav.stack[16] = (avl_node const   *)0;
#line 193
  trav.stack[17] = (avl_node const   *)0;
#line 193
  trav.stack[18] = (avl_node const   *)0;
#line 193
  trav.stack[19] = (avl_node const   *)0;
#line 193
  trav.stack[20] = (avl_node const   *)0;
#line 193
  trav.stack[21] = (avl_node const   *)0;
#line 193
  trav.stack[22] = (avl_node const   *)0;
#line 193
  trav.stack[23] = (avl_node const   *)0;
#line 193
  trav.stack[24] = (avl_node const   *)0;
#line 193
  trav.stack[25] = (avl_node const   *)0;
#line 193
  trav.stack[26] = (avl_node const   *)0;
#line 193
  trav.stack[27] = (avl_node const   *)0;
#line 193
  trav.stack[28] = (avl_node const   *)0;
#line 193
  trav.stack[29] = (avl_node const   *)0;
#line 193
  trav.stack[30] = (avl_node const   *)0;
#line 193
  trav.stack[31] = (avl_node const   *)0;
  {
#line 197
  thread_mutex_lock_c(& info.alias_mutex, 197, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
  {
  {
#line 199
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 199
    tmp___0 = avl_traverse(info.aliases, & trav);
    }
#line 199
    res = (alias_t *)tmp___0;
    }
#line 199
    if (! res) {
#line 199
      goto while_break;
    }
    {
    {
#line 201
    snprintf((char */* __restrict  */)(full), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
             (res->name)->host, (res->name)->port, (res->name)->path);
    }
    {
#line 202
    tmp = ice_strcmp((char const   *)(full), (char const   *)name);
    }
    }
#line 202
    if (tmp == 0) {
      {
      {
#line 204
      remove_alias(res);
      }
      {
#line 205
      thread_mutex_unlock_c(& info.alias_mutex, 205, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
      }
      }
#line 206
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 210
  zero_trav(& trav);
  }
  }
  {
  {
#line 212
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 212
    tmp___2 = avl_traverse(info.aliases, & trav);
    }
#line 212
    res = (alias_t *)tmp___2;
    }
#line 212
    if (! res) {
#line 212
      goto while_break___0;
    }
    {
    {
#line 214
    tmp___1 = ice_strcmp((char const   *)((res->name)->path), (char const   *)name);
    }
    }
#line 214
    if (tmp___1 == 0) {
      {
      {
#line 216
      remove_alias(res);
      }
      {
#line 217
      thread_mutex_unlock_c(& info.alias_mutex, 217, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
      }
      }
#line 218
      return (1);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 222
  thread_mutex_unlock_c(& info.alias_mutex, 222, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
#line 224
  return (0);
}
}
#line 227 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
void remove_alias(alias_t *al ) 
{ 
  alias_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 230
  tmp = avl_delete(info.aliases, (void const   *)al);
  }
#line 230
  out = (alias_t *)tmp;
  }
#line 232
  if (out) {
    {
    {
#line 234
    n_free((void *)out->real, (int const   )234, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 234
    out->real = (request_t *)((void *)0);
    {
#line 235
    n_free((void *)out->name, (int const   )235, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 235
    out->name = (request_t *)((void *)0);
    {
#line 236
    n_free((void *)out, (int const   )236, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
    }
#line 236
    out = (alias_t *)((void *)0);
    }
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c"
void free_aliases(void) 
{ 
  alias_t *alias ;
  alias_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 245
  if (! info.aliases) {
    {
    {
#line 246
    write_log(0, (char *)"WARNING: info.aliases is NULL, weird!");
    }
    }
#line 247
    return;
  }
  {
  {
#line 250
  thread_mutex_lock_c(& info.alias_mutex, 250, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
  {
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 252
    tmp___0 = avl_get_any_node(info.aliases);
    }
#line 252
    alias = (alias_t *)tmp___0;
    }
#line 252
    if (! alias) {
#line 252
      goto while_break;
    }
#line 254
    if (! alias) {
      {
      {
#line 255
      write_log(0, (char *)"WARNING: avl_get_any_node() returned NULL alias");
      }
      }
#line 256
      goto while_continue;
    }
    {
    {
#line 259
    tmp = avl_delete(info.aliases, (void const   *)alias);
    }
#line 259
    out = (alias_t *)tmp;
    }
#line 261
    if (out) {
      {
      {
#line 263
      n_free((void *)out->real, (int const   )263, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
      }
#line 263
      out->real = (request_t *)((void *)0);
      {
#line 264
      n_free((void *)out->name, (int const   )264, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
      }
#line 264
      out->name = (request_t *)((void *)0);
      {
#line 265
      n_free((void *)out, (int const   )265, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
      }
#line 265
      out = (alias_t *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 269
  thread_mutex_unlock_c(& info.alias_mutex, 269, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/alias.c");
  }
  }
#line 270
  return;
}
}
#line 397 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 143
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 171
extern int gethostbyaddr_r(void const   * __restrict  __addr , __socklen_t __len ,
                           int __type , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 178
extern int gethostbyname_r(char const   * __restrict  __name , struct hostent * __restrict  __result_buf ,
                           char * __restrict  __buf , size_t __buflen , struct hostent ** __restrict  __result ,
                           int * __restrict  __h_errnop ) ;
#line 37 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.h"
struct hostent *ice_gethostbyaddr(char const   *host , int hostlen , struct hostent *he ,
                                  char *buffer , int buflen , int *error ) ;
#line 42
struct hostent *standard_gethostbyname(char const   *hostname , struct hostent *res ,
                                       char *buffer , int buflen , int *error ) ;
#line 43
struct hostent *standard_gethostbyaddr(char const   *host , int hostlen , struct hostent *he ,
                                       char *buffer , int buflen , int *error ) ;
#line 51
struct hostent *linux_gethostbyname_r(char const   *hostname , struct hostent *res ,
                                      char *buffer , int buflen , int *error ) ;
#line 53
struct hostent *linux_gethostbyaddr_r(char const   *host , int hostlen , struct hostent *he ,
                                      char *buffer , int buflen , int *error ) ;
#line 90 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *ice_gethostbyname(char const   *hostname , struct hostent *res , char *buffer ,
                                  int buflen , int *error ) 
{ 
  struct hostent *tmp ;
  struct hostent *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 102
  if ((unsigned int )info.resolv_type == 1U) {
#line 102
    goto case_1;
  }
#line 107
  if ((unsigned int )info.resolv_type == 3U) {
#line 107
    goto case_3;
  }
#line 111
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  {
#line 103
  xa_debug(2, (char *)"Resolving %s using linux reentrant type function", hostname);
  }
  {
#line 104
  tmp = linux_gethostbyname_r(hostname, res, buffer, buflen, error);
  }
  }
#line 104
  return (tmp);
#line 105
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 108
  xa_debug(2, (char *)"Resolving %s using standard nonreentrant type function", hostname);
  }
  {
#line 109
  tmp___0 = standard_gethostbyname(hostname, res, buffer, buflen, error);
  }
  }
#line 109
  return (tmp___0);
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 112
  xa_debug(1, (char *)"DEBUG: gethostbyname (%s) failed cause no resolv function was defined (%d)",
           hostname, (unsigned int )info.resolv_type);
  }
  }
#line 114
  return ((struct hostent *)((void *)0));
#line 115
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 117
  return ((struct hostent *)0);
}
}
#line 119 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *ice_gethostbyaddr(char const   *host , int hostlen , struct hostent *he ,
                                  char *buffer , int buflen , int *error ) 
{ 
  char outhost[20] ;
  struct hostent *tmp ;
  struct hostent *tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 123
  makeasciihost((struct in_addr  const  *)((struct in_addr *)host), outhost);
  }
  }
  {
#line 134
  if ((unsigned int )info.resolv_type == 1U) {
#line 134
    goto case_1;
  }
#line 139
  if ((unsigned int )info.resolv_type == 3U) {
#line 139
    goto case_3;
  }
#line 143
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  {
#line 135
  xa_debug(2, (char *)"Resolving %s using linux reentrant type function", outhost);
  }
  {
#line 136
  tmp = linux_gethostbyaddr_r(host, hostlen, he, buffer, buflen, error);
  }
  }
#line 136
  return (tmp);
#line 137
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 140
  xa_debug(2, (char *)"Resolving %s using standard nonreentrant type function", outhost);
  }
  {
#line 141
  tmp___0 = standard_gethostbyaddr(host, hostlen, he, buffer, buflen, error);
  }
  }
#line 141
  return (tmp___0);
#line 142
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 144
  xa_debug(1, (char *)"DEBUG: gethostbyaddr (%s) failed cause no resolv function was defined",
           outhost);
  }
  }
#line 145
  return ((struct hostent *)((void *)0));
#line 146
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 148
  return ((struct hostent *)0);
}
}
#line 166 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *linux_gethostbyname_r(char const   *hostname , struct hostent *res ,
                                      char *buffer , int buflen , int *error ) 
{ 
  int tmp ;

  {
  {
#line 169
  *error = 0;
  {
#line 170
  tmp = gethostbyname_r((char const   */* __restrict  */)hostname, (struct hostent */* __restrict  */)res,
                        (char */* __restrict  */)buffer, (size_t )buflen, (struct hostent **/* __restrict  */)(& res),
                        (int */* __restrict  */)error);
  }
  }
#line 170
  if (tmp >= 0) {
#line 171
    return (res);
  } else {
#line 173
    return ((struct hostent *)((void *)0));
  }
}
}
#line 176 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *linux_gethostbyaddr_r(char const   *host , int hostlen , struct hostent *he ,
                                      char *buffer , int buflen , int *error ) 
{ 
  int out ;
  int tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 180
  *error = 0;
  {
#line 181
  tmp = gethostbyaddr_r((void const   */* __restrict  */)host, (__socklen_t )hostlen,
                        2, (struct hostent */* __restrict  */)he, (char */* __restrict  */)buffer,
                        (size_t )buflen, (struct hostent **/* __restrict  */)(& he),
                        (int */* __restrict  */)error);
  }
#line 181
  out = tmp >= 0;
  }
#line 181
  if (out) {
#line 183
    return (he);
  }
  {
  {
#line 185
  xa_debug(2, (char *)"gethostbyaddr_r() returned %d, error is %d", out, *error);
  }
  }
#line 186
  return ((struct hostent *)((void *)0));
}
}
#line 190 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *standard_gethostbyname(char const   *hostname , struct hostent *res ,
                                       char *buffer , int buflen , int *error ) 
{ 
  int *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 193
  thread_mutex_lock_c(& info.resolvmutex, 193, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c");
  }
#line 194
  *error = 0;
  {
#line 195
  res = gethostbyname(hostname);
  }
  }
#line 196
  if (! res) {
    {
    {
#line 197
    xa_debug(1, (char *)"DEBUG: gethostbyname (%s) failed", hostname);
    }
    {
#line 198
    tmp = __errno_location();
    }
#line 198
    *error = *tmp;
    }
  }
#line 200
  return (res);
}
}
#line 203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
struct hostent *standard_gethostbyaddr(char const   *host , int hostlen , struct hostent *he ,
                                       char *buffer , int buflen , int *error ) 
{ 
  int *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 206
  *error = 0;
  {
#line 207
  thread_mutex_lock_c(& info.resolvmutex, 207, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c");
  }
  {
#line 208
  he = gethostbyaddr((void const   *)host, (__socklen_t )hostlen, 2);
  }
  {
#line 209
  tmp = __errno_location();
  }
#line 209
  *error = *tmp;
  }
#line 210
  return (he);
}
}
#line 213 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
void ice_clean_hostent(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 218
  if ((unsigned int )info.resolv_type == 3U) {
    {
    {
#line 219
    thread_mutex_unlock_c(& info.resolvmutex, 219, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c");
    }
    }
  }
#line 220
  return;
}
}
#line 222 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
char *reverse(char const   *host ) 
{ 
  struct hostent hostinfo ;
  struct hostent *hostinfoptr ;
  struct in_addr addr ;
  int error ;
  char *outhost ;
  char buffer[8192] ;
  int tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 231
  if (! host) {
    {
    {
#line 233
    write_log(0, (char *)"ERROR: reverse() called with NULL host");
    }
    }
#line 234
    return ((char *)((void *)0));
  }
  {
  {
#line 237
  xa_debug(1, (char *)"reverse() reverse resolving %s", host);
  }
  {
#line 239
  tmp = inet_aton(host, & addr);
  }
  }
#line 239
  if (tmp) {
    {
    {
#line 241
    hostinfoptr = ice_gethostbyaddr((char const   *)((char *)(& addr)), (int )sizeof(struct in_addr ),
                                    & hostinfo, buffer, 8192, & error);
    }
    }
#line 243
    if (hostinfoptr) {
#line 243
      if (hostinfoptr->h_name) {
        {
        {
#line 244
        outhost = n_strdup((char const   *)hostinfoptr->h_name, (int const   )244,
                           "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c");
        }
        }
      } else {
#line 246
        outhost = (char *)((void *)0);
      }
    } else {
#line 246
      outhost = (char *)((void *)0);
    }
    {
    {
#line 248
    ice_clean_hostent();
    }
    }
#line 249
    return (outhost);
  } else {
#line 252
    return ((char *)((void *)0));
  }
}
}
#line 255 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_resolv.c"
char *forward(char const   *name , char *target ) 
{ 
  struct hostent hostinfo ;
  struct hostent *hostinfoptr ;
  struct sockaddr_in sin ;
  char buf[8192] ;
  int error ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 263
  xa_debug(1, (char *)"forward() resolving %s", name);
  }
  {
#line 265
  tmp = __ctype_b_loc();
  }
  }
#line 265
  if ((int const   )*(*tmp + (int )*(name + 0)) & 2048) {
    {
    {
#line 265
    tmp___0 = __ctype_b_loc();
    }
    {
#line 265
    tmp___1 = strlen(name);
    }
    }
#line 265
    if ((int const   )*(*tmp___0 + (int )*(name + (tmp___1 - 1U))) & 2048) {
#line 266
      return ((char *)((void *)0));
    }
  }
  {
  {
#line 268
  hostinfoptr = ice_gethostbyname(name, & hostinfo, buf, 8192, & error);
  }
  }
#line 270
  if (! hostinfoptr) {
    {
    {
#line 272
    ice_clean_hostent();
    }
    }
#line 273
    return ((char *)((void *)0));
  }
  {
  {
#line 276
  memset((void *)(& sin), 0, (size_t )sizeof(sin));
  }
#line 278
  sin.sin_addr.s_addr = (in_addr_t )*((unsigned long *)*(hostinfoptr->h_addr_list + 0));
  {
#line 280
  makeasciihost((struct in_addr  const  *)(& sin.sin_addr), target);
  }
  {
#line 282
  ice_clean_hostent();
  }
  }
#line 284
  return (target);
}
}
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 37 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.h"
dir_t *dir_findfirst(char const   *name ) ;
#line 38
int dir_findnext(dir_t *dir ) ;
#line 39
int dir_findclose(dir_t *dir ) ;
#line 58 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c"
dir_t *dir_findfirst(char const   *name ) 
{ 
  dir_t *dir ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 63
  tmp = n_malloc((unsigned int const   )sizeof(dir_t ), (int const   )63, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c");
  }
#line 63
  dir = (dir_t *)tmp;
  {
#line 73
  dir->directory = opendir(name);
  }
  }
#line 75
  if ((unsigned long )dir->directory == (unsigned long )((void *)0)) {
    {
    {
#line 76
    n_free((void *)dir, (int const   )76, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c");
    }
#line 76
    dir = (dir_t *)((void *)0);
#line 77
    dir = (dir_t *)((void *)0);
    }
  }
#line 80
  return (dir);
}
}
#line 83 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c"
int dir_findnext(dir_t *dir ) 
{ 
  int result ;

  {
  {
#line 86
  result = 1;
  {
#line 100
  dir->entry = readdir(dir->directory);
  }
#line 101
  dir->filename = (char const   *)((dir->entry)->d_name);
  }
#line 102
  if ((unsigned long )dir->entry == (unsigned long )((void *)0)) {
#line 103
    result = 0;
  }
#line 106
  return (result);
}
}
#line 109 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c"
int dir_findclose(dir_t *dir ) 
{ 
  int result ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 117
  result = closedir(dir->directory);
  }
  {
#line 119
  n_free((void *)dir, (int const   )119, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/dir.c");
  }
#line 119
  dir = (dir_t *)((void *)0);
  }
#line 121
  return (result);
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 90 "../../src/utility.h"
int open_for_reading(char const   *filename ) ;
#line 92
int open_for_append(char const   *filename ) ;
#line 93
char *get_icecast_file(char const   *filename , filetype_t type , int flags ) ;
#line 33 "../../src/log.h"
int fd_read_line(int fd , char *buff , int const   len ) ;
#line 36
int fd_write_line(int fd , char const   *fmt  , ...) ;
#line 4 "../../src/avl_functions.h"
int compare_groups(void const   *first , void const   *second , void *param ) ;
#line 41 "../../src/admin.h"
int admin_write(com_request_t const   *req , int const   message_type , char const   *fmt 
                , ...) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.h"
void parse_group_authentication_file(void) ;
#line 25
group_t *create_group_from_line(char *line ) ;
#line 26
group_t *create_group(void) ;
#line 27
grouptree_t *create_group_tree(void) ;
#line 28
void add_authentication_group(group_t *group ) ;
#line 29
void free_group_tree(grouptree_t *gt ) ;
#line 30
int is_member_of(char *user , group_t *group ) ;
#line 31
group_t *find_group_from_tree(grouptree_t *gt , char const   *name ) ;
#line 32
void con_display_groups(com_request_t *req ) ;
#line 33
int runtime_add_group(char const   *name ) ;
#line 34
int runtime_add_group_with_user(char const   *name , char *users ) ;
#line 29 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.h"
usertree_t *create_user_tree(void) ;
#line 30
void free_user_tree(usertree_t *ut ) ;
#line 32
ice_user_t *find_user_from_tree(usertree_t *ut , char const   *name ) ;
#line 80 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
mutex_t authentication_mutex ;
#line 82
usertree_t *usertree ;
#line 83
grouptree_t *grouptree ;
#line 85 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
void parse_group_authentication_file(void) 
{ 
  int fd ;
  char *groupfile ;
  char *tmp ;
  group_t *group ;
  char line[8192] ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 88
  tmp = get_icecast_file((char const   *)info.groupfile, (filetype_t )1, 4);
  }
#line 88
  groupfile = tmp;
  }
#line 92
  if (! groupfile) {
#line 92
    goto _L;
  } else {
    {
    {
#line 92
    fd = open_for_reading((char const   *)groupfile);
    }
    }
#line 92
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 93
      if (groupfile) {
        {
        {
#line 94
        n_free((void *)groupfile, (int const   )94, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
        }
        }
      }
      {
#line 94
      groupfile = (char *)((void *)0);
      {
#line 95
      xa_debug(1, (char *)"WARNING: Could not open group authentication file");
      }
      }
#line 96
      return;
    }
  }
  {
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 98
    tmp___0 = fd_read_line(fd, line, (int const   )8192);
    }
    }
#line 98
    if (! tmp___0) {
#line 98
      goto while_break;
    }
#line 99
    if ((int )line[0] == 35) {
#line 100
      goto while_continue;
    } else
#line 99
    if ((int )line[0] == 32) {
#line 100
      goto while_continue;
    }
    {
    {
#line 102
    group = create_group_from_line(line);
    }
    }
#line 104
    if (group) {
      {
      {
#line 105
      add_authentication_group(group);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if (groupfile) {
    {
    {
#line 109
    n_free((void *)groupfile, (int const   )109, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
    }
  }
  {
#line 109
  groupfile = (char *)((void *)0);
  {
#line 110
  fd_close(fd);
  }
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
group_t *create_group_from_line(char *line ) 
{ 
  group_t *group ;
  ice_user_t *user ;
  char name[8192] ;
  char cuser[8192] ;
  int go_on ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 119
  go_on = 1;
#line 121
  if (! line) {
    {
    {
#line 122
    xa_debug(1, (char *)"WARNING: create_group_from_line() called with NULL pointer");
    }
    }
#line 123
    return ((group_t *)((void *)0));
  }
  {
  {
#line 125
  tmp = splitc(name, line, (char const   )':');
  }
  }
#line 125
  if (! tmp) {
    {
    {
#line 126
    xa_debug(1, (char *)"ERROR: Syntax error in group file, with line [%s]", line);
    }
    }
#line 127
    return ((group_t *)((void *)0));
  }
  {
  {
#line 129
  group = create_group();
  }
  {
#line 131
  tmp___0 = clean_string(name);
  }
  {
#line 131
  group->name = n_strdup((char const   *)tmp___0, (int const   )131, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  }
  {
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 134
    tmp___1 = splitc(cuser, line, (char const   )',');
    }
    }
#line 134
    if (! tmp___1) {
      {
      {
#line 135
      strcpy((char */* __restrict  */)(cuser), (char const   */* __restrict  */)line);
      }
#line 136
      go_on = 0;
      }
    }
    {
    {
#line 138
    tmp___2 = clean_string(cuser);
    }
    {
#line 138
    user = find_user_from_tree(usertree, (char const   *)tmp___2);
    }
    }
#line 140
    if (! user) {
      {
      {
#line 141
      write_log(0, (char *)"WARNING: Unrecognized user [%s] specified for group [%s]",
                cuser, name);
      }
      }
    } else {
      {
      {
#line 144
      avl_insert(group->usertree, (void *)user);
      }
      }
    }
#line 133
    if (! go_on) {
#line 133
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (group);
}
}
#line 151 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
group_t *create_group(void) 
{ 
  group_t *group ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 154
  tmp = n_malloc((unsigned int const   )sizeof(group_t ), (int const   )154, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
#line 154
  group = (group_t *)tmp;
  {
#line 156
  group->usertree = create_user_tree();
  }
#line 157
  group->name = (char *)((void *)0);
  }
#line 158
  return (group);
}
}
#line 161 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
grouptree_t *create_group_tree(void) 
{ 
  grouptree_t *gt ;
  avl_tree *tmp ;

  {
  {
  {
#line 164
  tmp = avl_create(& compare_groups, (void *)(& info));
  }
#line 164
  gt = tmp;
  }
#line 166
  return (gt);
}
}
#line 169 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
void add_authentication_group(group_t *group ) 
{ 
  group_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 173
  if (! group) {
    {
    {
#line 174
    xa_debug(1, (char *)"ERROR: add_authentication_group() called with NULL pointers");
    }
    }
#line 175
    return;
  } else
#line 173
  if (! grouptree) {
    {
    {
#line 174
    xa_debug(1, (char *)"ERROR: add_authentication_group() called with NULL pointers");
    }
    }
#line 175
    return;
  } else
#line 173
  if (! group->name) {
    {
    {
#line 174
    xa_debug(1, (char *)"ERROR: add_authentication_group() called with NULL pointers");
    }
    }
#line 175
    return;
  } else
#line 173
  if (! group->usertree) {
    {
    {
#line 174
    xa_debug(1, (char *)"ERROR: add_authentication_group() called with NULL pointers");
    }
    }
#line 175
    return;
  }
  {
  {
#line 177
  tmp = avl_replace(grouptree, (void *)group);
  }
#line 177
  out = (group_t *)tmp;
  }
#line 179
  if (out) {
    {
    {
#line 180
    write_log(0, (char *)"WARNING: Duplicate group record %s, using latter", group->name);
    }
    {
#line 181
    n_free((void *)out->name, (int const   )181, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
#line 181
    out->name = (char *)((void *)0);
    {
#line 182
    free_user_tree(out->usertree);
    }
    {
#line 183
    n_free((void *)out, (int const   )183, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
#line 183
    out = (group_t *)((void *)0);
    }
  }
  {
  {
#line 185
  xa_debug(1, (char *)"DEBUG: add_authentication_group(): Inserted group [%s]", group->name);
  }
  }
#line 186
  return;
}
}
#line 188 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
void free_group_tree(grouptree_t *gt ) 
{ 
  avl_traverser trav ;
  group_t *group ;
  group_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 190
  trav.init = 0;
#line 190
  trav.nstack = 0;
#line 190
  trav.p = (avl_node const   *)0;
#line 190
  trav.stack[0] = (avl_node const   *)0;
#line 190
  trav.stack[1] = (avl_node const   *)0;
#line 190
  trav.stack[2] = (avl_node const   *)0;
#line 190
  trav.stack[3] = (avl_node const   *)0;
#line 190
  trav.stack[4] = (avl_node const   *)0;
#line 190
  trav.stack[5] = (avl_node const   *)0;
#line 190
  trav.stack[6] = (avl_node const   *)0;
#line 190
  trav.stack[7] = (avl_node const   *)0;
#line 190
  trav.stack[8] = (avl_node const   *)0;
#line 190
  trav.stack[9] = (avl_node const   *)0;
#line 190
  trav.stack[10] = (avl_node const   *)0;
#line 190
  trav.stack[11] = (avl_node const   *)0;
#line 190
  trav.stack[12] = (avl_node const   *)0;
#line 190
  trav.stack[13] = (avl_node const   *)0;
#line 190
  trav.stack[14] = (avl_node const   *)0;
#line 190
  trav.stack[15] = (avl_node const   *)0;
#line 190
  trav.stack[16] = (avl_node const   *)0;
#line 190
  trav.stack[17] = (avl_node const   *)0;
#line 190
  trav.stack[18] = (avl_node const   *)0;
#line 190
  trav.stack[19] = (avl_node const   *)0;
#line 190
  trav.stack[20] = (avl_node const   *)0;
#line 190
  trav.stack[21] = (avl_node const   *)0;
#line 190
  trav.stack[22] = (avl_node const   *)0;
#line 190
  trav.stack[23] = (avl_node const   *)0;
#line 190
  trav.stack[24] = (avl_node const   *)0;
#line 190
  trav.stack[25] = (avl_node const   *)0;
#line 190
  trav.stack[26] = (avl_node const   *)0;
#line 190
  trav.stack[27] = (avl_node const   *)0;
#line 190
  trav.stack[28] = (avl_node const   *)0;
#line 190
  trav.stack[29] = (avl_node const   *)0;
#line 190
  trav.stack[30] = (avl_node const   *)0;
#line 190
  trav.stack[31] = (avl_node const   *)0;
#line 194
  if (! gt) {
#line 195
    return;
  }
  {
  {
#line 197
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 197
    tmp___0 = avl_traverse(gt, & trav);
    }
#line 197
    group = (group_t *)tmp___0;
    }
#line 197
    if (! group) {
#line 197
      goto while_break;
    }
    {
    {
#line 198
    tmp = avl_delete(gt, (void const   *)group);
    }
#line 198
    out = (group_t *)tmp;
    }
#line 200
    if (! out) {
      {
      {
#line 201
      xa_debug(1, (char *)"WARNING: Weird ass things going on in grouptree!");
      }
      }
#line 202
      goto while_continue;
    }
    {
    {
#line 204
    n_free((void *)group->name, (int const   )204, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
#line 204
    group->name = (char *)((void *)0);
    {
#line 205
    avl_destroy(group->usertree, (void (*)(void *data , void *param ))((void *)0));
    }
    {
#line 206
    n_free((void *)group, (int const   )206, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
#line 206
    group = (group_t *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
int is_member_of(char *user , group_t *group ) 
{ 
  ice_user_t *up ;
  ice_user_t search ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 215
  if (! user) {
    {
    {
#line 216
    xa_debug(1, (char *)"WARNING: is_member_of() called with NULL pointers");
    }
    }
#line 217
    return (0);
  } else
#line 215
  if (! group) {
    {
    {
#line 216
    xa_debug(1, (char *)"WARNING: is_member_of() called with NULL pointers");
    }
    }
#line 217
    return (0);
  } else
#line 215
  if (! group->usertree) {
    {
    {
#line 216
    xa_debug(1, (char *)"WARNING: is_member_of() called with NULL pointers");
    }
    }
#line 217
    return (0);
  }
  {
#line 219
  search.name = user;
  {
#line 221
  tmp = avl_find(group->usertree, (void const   *)(& search));
  }
#line 221
  up = (ice_user_t *)tmp;
  }
#line 223
  if (up) {
#line 223
    tmp___0 = 1;
  } else {
#line 223
    tmp___0 = 0;
  }
#line 223
  return (tmp___0);
}
}
#line 226 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
group_t *find_group_from_tree(grouptree_t *gt , char const   *name ) 
{ 
  group_t search ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 231
  search.name = strchr(name, (int )*(name + 0));
  }
  }
#line 233
  if (! gt) {
    {
    {
#line 234
    xa_debug(1, (char *)"WARNING: find_group_from_tree() called with NULL pointers");
    }
    }
#line 235
    return ((group_t *)((void *)0));
  } else
#line 233
  if (! name) {
    {
    {
#line 234
    xa_debug(1, (char *)"WARNING: find_group_from_tree() called with NULL pointers");
    }
    }
#line 235
    return ((group_t *)((void *)0));
  }
  {
  {
#line 237
  tmp = avl_find(gt, (void const   *)(& search));
  }
  }
#line 237
  return ((group_t *)tmp);
}
}
#line 240 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
void con_display_groups(com_request_t *req ) 
{ 
  avl_traverser trav ;
  avl_traverser usertrav ;
  group_t *group ;
  ice_user_t *user ;
  int listed ;
  char const   *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 242
  trav.init = 0;
#line 242
  trav.nstack = 0;
#line 242
  trav.p = (avl_node const   *)0;
#line 242
  trav.stack[0] = (avl_node const   *)0;
#line 242
  trav.stack[1] = (avl_node const   *)0;
#line 242
  trav.stack[2] = (avl_node const   *)0;
#line 242
  trav.stack[3] = (avl_node const   *)0;
#line 242
  trav.stack[4] = (avl_node const   *)0;
#line 242
  trav.stack[5] = (avl_node const   *)0;
#line 242
  trav.stack[6] = (avl_node const   *)0;
#line 242
  trav.stack[7] = (avl_node const   *)0;
#line 242
  trav.stack[8] = (avl_node const   *)0;
#line 242
  trav.stack[9] = (avl_node const   *)0;
#line 242
  trav.stack[10] = (avl_node const   *)0;
#line 242
  trav.stack[11] = (avl_node const   *)0;
#line 242
  trav.stack[12] = (avl_node const   *)0;
#line 242
  trav.stack[13] = (avl_node const   *)0;
#line 242
  trav.stack[14] = (avl_node const   *)0;
#line 242
  trav.stack[15] = (avl_node const   *)0;
#line 242
  trav.stack[16] = (avl_node const   *)0;
#line 242
  trav.stack[17] = (avl_node const   *)0;
#line 242
  trav.stack[18] = (avl_node const   *)0;
#line 242
  trav.stack[19] = (avl_node const   *)0;
#line 242
  trav.stack[20] = (avl_node const   *)0;
#line 242
  trav.stack[21] = (avl_node const   *)0;
#line 242
  trav.stack[22] = (avl_node const   *)0;
#line 242
  trav.stack[23] = (avl_node const   *)0;
#line 242
  trav.stack[24] = (avl_node const   *)0;
#line 242
  trav.stack[25] = (avl_node const   *)0;
#line 242
  trav.stack[26] = (avl_node const   *)0;
#line 242
  trav.stack[27] = (avl_node const   *)0;
#line 242
  trav.stack[28] = (avl_node const   *)0;
#line 242
  trav.stack[29] = (avl_node const   *)0;
#line 242
  trav.stack[30] = (avl_node const   *)0;
#line 242
  trav.stack[31] = (avl_node const   *)0;
#line 244
  usertrav.init = 0;
#line 244
  usertrav.nstack = 0;
#line 244
  usertrav.p = (avl_node const   *)0;
#line 244
  usertrav.stack[0] = (avl_node const   *)0;
#line 244
  usertrav.stack[1] = (avl_node const   *)0;
#line 244
  usertrav.stack[2] = (avl_node const   *)0;
#line 244
  usertrav.stack[3] = (avl_node const   *)0;
#line 244
  usertrav.stack[4] = (avl_node const   *)0;
#line 244
  usertrav.stack[5] = (avl_node const   *)0;
#line 244
  usertrav.stack[6] = (avl_node const   *)0;
#line 244
  usertrav.stack[7] = (avl_node const   *)0;
#line 244
  usertrav.stack[8] = (avl_node const   *)0;
#line 244
  usertrav.stack[9] = (avl_node const   *)0;
#line 244
  usertrav.stack[10] = (avl_node const   *)0;
#line 244
  usertrav.stack[11] = (avl_node const   *)0;
#line 244
  usertrav.stack[12] = (avl_node const   *)0;
#line 244
  usertrav.stack[13] = (avl_node const   *)0;
#line 244
  usertrav.stack[14] = (avl_node const   *)0;
#line 244
  usertrav.stack[15] = (avl_node const   *)0;
#line 244
  usertrav.stack[16] = (avl_node const   *)0;
#line 244
  usertrav.stack[17] = (avl_node const   *)0;
#line 244
  usertrav.stack[18] = (avl_node const   *)0;
#line 244
  usertrav.stack[19] = (avl_node const   *)0;
#line 244
  usertrav.stack[20] = (avl_node const   *)0;
#line 244
  usertrav.stack[21] = (avl_node const   *)0;
#line 244
  usertrav.stack[22] = (avl_node const   *)0;
#line 244
  usertrav.stack[23] = (avl_node const   *)0;
#line 244
  usertrav.stack[24] = (avl_node const   *)0;
#line 244
  usertrav.stack[25] = (avl_node const   *)0;
#line 244
  usertrav.stack[26] = (avl_node const   *)0;
#line 244
  usertrav.stack[27] = (avl_node const   *)0;
#line 244
  usertrav.stack[28] = (avl_node const   *)0;
#line 244
  usertrav.stack[29] = (avl_node const   *)0;
#line 244
  usertrav.stack[30] = (avl_node const   *)0;
#line 244
  usertrav.stack[31] = (avl_node const   *)0;
#line 248
  listed = 0;
  {
#line 250
  admin_write_line((com_request_t const   *)req, (int const   )434, "Listing groups in the authentication module:");
  }
  {
#line 252
  thread_mutex_lock_c(& authentication_mutex, 252, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  }
  {
  {
#line 254
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 254
    tmp___1 = avl_traverse(grouptree, & trav);
    }
#line 254
    group = (group_t *)tmp___1;
    }
#line 254
    if (! group) {
#line 254
      goto while_break;
    }
    {
    {
#line 255
    zero_trav(& usertrav);
    }
    }
#line 257
    if (group->name) {
#line 257
      tmp = (char const   *)group->name;
    } else {
#line 257
      tmp = "(null)";
    }
    {
    {
#line 257
    admin_write((com_request_t const   *)req, (int const   )435, "%s: ", tmp);
    }
    }
    {
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 259
      tmp___0 = avl_traverse(group->usertree, & usertrav);
      }
#line 259
      user = (ice_user_t *)tmp___0;
      }
#line 259
      if (! user) {
#line 259
        goto while_break___0;
      }
      {
      {
#line 260
      admin_write((com_request_t const   *)req, (int const   )-1, "%s ", user->name);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 261
    admin_write_line((com_request_t const   *)req, (int const   )-1, "");
    }
#line 262
    listed ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 265
  thread_mutex_unlock_c(& authentication_mutex, 265, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  {
#line 267
  admin_write_line((com_request_t const   *)req, (int const   )436, "End of group listing (%d listed)",
                   listed);
  }
  }
#line 268
  return;
}
}
#line 271 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
int runtime_add_group(char const   *name ) 
{ 
  char line[8192] ;
  char *groupfile ;
  int fd ;
  group_t *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 277
  if (! name) {
#line 278
    return (-2);
  } else
#line 277
  if (! *(name + 0)) {
#line 278
    return (-2);
  }
  {
  {
#line 282
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s:\n",
          name);
  }
  {
#line 285
  thread_mutex_lock_c(& authentication_mutex, 285, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  {
#line 287
  tmp = find_group_from_tree(grouptree, name);
  }
  }
#line 287
  if (tmp) {
    {
    {
#line 288
    thread_mutex_unlock_c(& authentication_mutex, 288, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
    }
#line 289
    return (-6);
  }
  {
  {
#line 291
  groupfile = get_icecast_file((char const   *)info.groupfile, (filetype_t )1, 2);
  }
  }
#line 293
  if (! groupfile) {
#line 293
    goto _L;
  } else {
    {
    {
#line 293
    fd = open_for_append((char const   *)groupfile);
    }
    }
#line 293
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 294
      if (groupfile) {
        {
        {
#line 295
        n_free((void *)groupfile, (int const   )295, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
        }
        }
      }
      {
#line 295
      groupfile = (char *)((void *)0);
      {
#line 296
      xa_debug(1, (char *)"WARNING: Could not open group authentication file for writing");
      }
      {
#line 297
      thread_mutex_unlock_c(& authentication_mutex, 297, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
      }
      }
#line 298
      return (-7);
    }
  }
  {
  {
#line 300
  fd_write_line(fd, "%s", line);
  }
  {
#line 301
  fd_close(fd);
  }
  }
#line 302
  if (groupfile) {
    {
    {
#line 303
    n_free((void *)groupfile, (int const   )303, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
    }
  }
  {
#line 303
  groupfile = (char *)((void *)0);
  {
#line 304
  thread_mutex_unlock_c(& authentication_mutex, 304, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  }
#line 305
  return (1);
}
}
#line 309 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c"
int runtime_add_group_with_user(char const   *name , char *users ) 
{ 
  char line[8192] ;
  char *groupfile ;
  char *s ;
  int fd ;
  group_t *tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 315
  if (! name) {
#line 316
    return (-2);
  } else
#line 315
  if (! users) {
#line 316
    return (-2);
  } else
#line 315
  if (! *(name + 0)) {
#line 316
    return (-2);
  } else
#line 315
  if (! *(users + 0)) {
#line 316
    return (-2);
  }
  {
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 318
    s = strchr((char const   *)users, ' ');
    }
    }
#line 318
    if (! s) {
#line 318
      goto while_break;
    }
#line 319
    *s = (char )',';
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 324
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s:%s\n",
          name, users);
  }
  {
#line 327
  thread_mutex_lock_c(& authentication_mutex, 327, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  {
#line 329
  tmp = find_group_from_tree(grouptree, name);
  }
  }
#line 329
  if (tmp) {
    {
    {
#line 330
    thread_mutex_unlock_c(& authentication_mutex, 330, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
    }
#line 331
    return (-6);
  }
  {
  {
#line 333
  groupfile = get_icecast_file((char const   *)info.groupfile, (filetype_t )1, 2);
  }
  }
#line 335
  if (! groupfile) {
#line 335
    goto _L;
  } else {
    {
    {
#line 335
    fd = open_for_append((char const   *)groupfile);
    }
    }
#line 335
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 336
      if (groupfile) {
        {
        {
#line 337
        n_free((void *)groupfile, (int const   )337, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
        }
        }
      }
      {
#line 337
      groupfile = (char *)((void *)0);
      {
#line 338
      xa_debug(1, (char *)"WARNING: Could not open group authentication file for writing");
      }
      {
#line 339
      thread_mutex_unlock_c(& authentication_mutex, 339, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
      }
      }
#line 340
      return (-7);
    }
  }
  {
  {
#line 342
  fd_write_line(fd, "%s", line);
  }
  {
#line 343
  fd_close(fd);
  }
  }
#line 344
  if (groupfile) {
    {
    {
#line 345
    n_free((void *)groupfile, (int const   )345, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
    }
    }
  }
  {
#line 345
  groupfile = (char *)((void *)0);
  {
#line 346
  thread_mutex_unlock_c(& authentication_mutex, 346, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/group.c");
  }
  }
#line 347
  return (1);
}
}
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 31 "../../src/ice_string.h"
char *util_base64_decode(char *message ) ;
#line 5 "../../src/avl_functions.h"
int compare_users(void const   *first , void const   *second , void *param ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.h"
void parse_user_authentication_file(void) ;
#line 26
ice_user_t *create_user_from_line(char *line ) ;
#line 27
ice_user_t *create_user(void) ;
#line 28
void add_authentication_user(ice_user_t *user ) ;
#line 31
int user_authenticate(char *cuser , char const   *password ) ;
#line 33
ice_user_t *con_get_user(connection_t *con , ice_user_t *outuser ) ;
#line 34
void con_display_users(com_request_t *req ) ;
#line 35
int runtime_add_user(char const   *name , char const   *password ) ;
#line 79 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
void parse_user_authentication_file(void) 
{ 
  int fd ;
  ice_user_t *user ;
  char line[8192] ;
  char *userfile ;
  char *tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 84
  tmp = get_icecast_file((char const   *)info.userfile, (filetype_t )1, 4);
  }
#line 84
  userfile = tmp;
  }
#line 86
  if (! userfile) {
#line 86
    goto _L;
  } else {
    {
    {
#line 86
    fd = open_for_reading((char const   *)userfile);
    }
    }
#line 86
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 87
      if (userfile) {
        {
        {
#line 88
        n_free((void *)userfile, (int const   )88, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
        }
        }
      }
      {
#line 88
      userfile = (char *)((void *)0);
      {
#line 89
      xa_debug(1, (char *)"WARNING: Could not open user authentication file");
      }
      }
#line 90
      return;
    }
  }
  {
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    tmp___0 = fd_read_line(fd, line, (int const   )8192);
    }
    }
#line 92
    if (! tmp___0) {
#line 92
      goto while_break;
    }
#line 93
    if ((int )line[0] == 35) {
#line 94
      goto while_continue;
    } else
#line 93
    if ((int )line[0] == 32) {
#line 94
      goto while_continue;
    }
    {
    {
#line 96
    user = create_user_from_line(line);
    }
    }
#line 98
    if (user) {
      {
      {
#line 99
      add_authentication_user(user);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (userfile) {
    {
    {
#line 103
    n_free((void *)userfile, (int const   )103, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
    }
  }
  {
#line 103
  userfile = (char *)((void *)0);
  {
#line 104
  fd_close(fd);
  }
  }
#line 105
  return;
}
}
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
int runtime_add_user(char const   *name , char const   *password ) 
{ 
  char line[8192] ;
  char *userfile ;
  int fd ;
  ice_user_t *tmp ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 113
  if (! name) {
#line 114
    return (-2);
  } else
#line 113
  if (! password) {
#line 114
    return (-2);
  } else
#line 113
  if (! *(name + 0)) {
#line 114
    return (-2);
  } else
#line 113
  if (! *(password + 0)) {
#line 114
    return (-2);
  }
  {
  {
#line 118
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s:%s\n",
          name, password);
  }
  {
#line 121
  thread_mutex_lock_c(& authentication_mutex, 121, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  {
#line 123
  tmp = find_user_from_tree(usertree, name);
  }
  }
#line 123
  if (tmp) {
    {
    {
#line 124
    thread_mutex_unlock_c(& authentication_mutex, 124, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
    }
#line 125
    return (-6);
  }
  {
  {
#line 127
  userfile = get_icecast_file((char const   *)info.userfile, (filetype_t )1, 2);
  }
  }
#line 129
  if (! userfile) {
#line 129
    goto _L;
  } else {
    {
    {
#line 129
    fd = open_for_append((char const   *)userfile);
    }
    }
#line 129
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 130
      if (userfile) {
        {
        {
#line 131
        n_free((void *)userfile, (int const   )131, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
        }
        }
      }
      {
#line 131
      userfile = (char *)((void *)0);
      {
#line 132
      xa_debug(1, (char *)"WARNING: Could not open user authentication file for writing");
      }
      {
#line 133
      thread_mutex_unlock_c(& authentication_mutex, 133, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
      }
      }
#line 134
      return (-7);
    }
  }
  {
  {
#line 136
  fd_write_line(fd, "%s", line);
  }
  {
#line 137
  fd_close(fd);
  }
  }
#line 138
  if (userfile) {
    {
    {
#line 139
    n_free((void *)userfile, (int const   )139, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
    }
  }
  {
#line 139
  userfile = (char *)((void *)0);
  {
#line 140
  thread_mutex_unlock_c(& authentication_mutex, 140, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  }
#line 141
  return (1);
}
}
#line 144 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
ice_user_t *create_user_from_line(char *line ) 
{ 
  ice_user_t *user ;
  char name[8192] ;
  char pass[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 150
  if (! line) {
    {
    {
#line 151
    xa_debug(1, (char *)"WARNING: create_user_from_line() called with NULL pointer");
    }
    }
#line 152
    return ((ice_user_t *)((void *)0));
  }
  {
  {
#line 154
  tmp = splitc(name, line, (char const   )':');
  }
  }
#line 154
  if (! tmp) {
    {
    {
#line 155
    xa_debug(1, (char *)"ERROR: Syntax error in user file, with line [%s]", line);
    }
    }
#line 156
    return ((ice_user_t *)((void *)0));
  }
  {
  {
#line 158
  tmp___0 = splitc(pass, line, (char const   )':');
  }
  }
#line 158
  if (! tmp___0) {
    {
    {
#line 159
    strcpy((char */* __restrict  */)(pass), (char const   */* __restrict  */)line);
    }
    }
  }
  {
  {
#line 161
  user = create_user();
  }
  {
#line 162
  tmp___1 = clean_string(name);
  }
  {
#line 162
  user->name = n_strdup((char const   *)tmp___1, (int const   )162, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  {
#line 163
  tmp___2 = clean_string(pass);
  }
  {
#line 163
  user->pass = n_strdup((char const   *)tmp___2, (int const   )163, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  }
#line 165
  return (user);
}
}
#line 168 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
ice_user_t *create_user(void) 
{ 
  ice_user_t *user ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 171
  tmp = n_malloc((unsigned int const   )sizeof(ice_user_t ), (int const   )171, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
#line 171
  user = (ice_user_t *)tmp;
#line 173
  user->name = (char *)((void *)0);
#line 174
  user->pass = (char *)((void *)0);
  }
#line 175
  return (user);
}
}
#line 178 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
usertree_t *create_user_tree(void) 
{ 
  usertree_t *ut ;
  avl_tree *tmp ;

  {
  {
  {
#line 181
  tmp = avl_create(& compare_users, (void *)(& info));
  }
#line 181
  ut = tmp;
  }
#line 183
  return (ut);
}
}
#line 187 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
void add_authentication_user(ice_user_t *user ) 
{ 
  ice_user_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 191
  if (! user) {
    {
    {
#line 192
    xa_debug(1, (char *)"ERROR: add_authentication_user() called with NULL pointers");
    }
    }
#line 193
    return;
  } else
#line 191
  if (! usertree) {
    {
    {
#line 192
    xa_debug(1, (char *)"ERROR: add_authentication_user() called with NULL pointers");
    }
    }
#line 193
    return;
  } else
#line 191
  if (! user->name) {
    {
    {
#line 192
    xa_debug(1, (char *)"ERROR: add_authentication_user() called with NULL pointers");
    }
    }
#line 193
    return;
  } else
#line 191
  if (! user->pass) {
    {
    {
#line 192
    xa_debug(1, (char *)"ERROR: add_authentication_user() called with NULL pointers");
    }
    }
#line 193
    return;
  }
  {
  {
#line 195
  tmp = avl_replace(usertree, (void *)user);
  }
#line 195
  out = (ice_user_t *)tmp;
  }
#line 197
  if (out) {
    {
    {
#line 198
    write_log(0, (char *)"WARNING: Duplicate user record %s, using latter", user->name);
    }
    {
#line 199
    n_free((void *)out->name, (int const   )199, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 199
    out->name = (char *)((void *)0);
    {
#line 200
    n_free((void *)out->pass, (int const   )200, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 200
    out->pass = (char *)((void *)0);
    {
#line 201
    n_free((void *)out, (int const   )201, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 201
    out = (ice_user_t *)((void *)0);
    }
  }
  {
  {
#line 203
  xa_debug(1, (char *)"DEBUG: add_authentication_user(): Inserted user [%s:%s]", user->name,
           user->pass);
  }
  }
#line 204
  return;
}
}
#line 206 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
void free_user_tree(usertree_t *ut ) 
{ 
  avl_traverser trav ;
  ice_user_t *user ;
  ice_user_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 208
  trav.init = 0;
#line 208
  trav.nstack = 0;
#line 208
  trav.p = (avl_node const   *)0;
#line 208
  trav.stack[0] = (avl_node const   *)0;
#line 208
  trav.stack[1] = (avl_node const   *)0;
#line 208
  trav.stack[2] = (avl_node const   *)0;
#line 208
  trav.stack[3] = (avl_node const   *)0;
#line 208
  trav.stack[4] = (avl_node const   *)0;
#line 208
  trav.stack[5] = (avl_node const   *)0;
#line 208
  trav.stack[6] = (avl_node const   *)0;
#line 208
  trav.stack[7] = (avl_node const   *)0;
#line 208
  trav.stack[8] = (avl_node const   *)0;
#line 208
  trav.stack[9] = (avl_node const   *)0;
#line 208
  trav.stack[10] = (avl_node const   *)0;
#line 208
  trav.stack[11] = (avl_node const   *)0;
#line 208
  trav.stack[12] = (avl_node const   *)0;
#line 208
  trav.stack[13] = (avl_node const   *)0;
#line 208
  trav.stack[14] = (avl_node const   *)0;
#line 208
  trav.stack[15] = (avl_node const   *)0;
#line 208
  trav.stack[16] = (avl_node const   *)0;
#line 208
  trav.stack[17] = (avl_node const   *)0;
#line 208
  trav.stack[18] = (avl_node const   *)0;
#line 208
  trav.stack[19] = (avl_node const   *)0;
#line 208
  trav.stack[20] = (avl_node const   *)0;
#line 208
  trav.stack[21] = (avl_node const   *)0;
#line 208
  trav.stack[22] = (avl_node const   *)0;
#line 208
  trav.stack[23] = (avl_node const   *)0;
#line 208
  trav.stack[24] = (avl_node const   *)0;
#line 208
  trav.stack[25] = (avl_node const   *)0;
#line 208
  trav.stack[26] = (avl_node const   *)0;
#line 208
  trav.stack[27] = (avl_node const   *)0;
#line 208
  trav.stack[28] = (avl_node const   *)0;
#line 208
  trav.stack[29] = (avl_node const   *)0;
#line 208
  trav.stack[30] = (avl_node const   *)0;
#line 208
  trav.stack[31] = (avl_node const   *)0;
#line 212
  if (! ut) {
#line 213
    return;
  }
  {
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 215
    tmp___0 = avl_traverse(ut, & trav);
    }
#line 215
    user = (ice_user_t *)tmp___0;
    }
#line 215
    if (! user) {
#line 215
      goto while_break;
    }
    {
    {
#line 216
    tmp = avl_delete(ut, (void const   *)user);
    }
#line 216
    out = (ice_user_t *)tmp;
    }
#line 218
    if (! out) {
      {
      {
#line 219
      xa_debug(1, (char *)"WARNING: Weird ass things going on in usertree!");
      }
      }
#line 220
      goto while_continue;
    }
    {
    {
#line 222
    n_free((void *)out->name, (int const   )222, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 222
    out->name = (char *)((void *)0);
    {
#line 223
    n_free((void *)out->pass, (int const   )223, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 223
    out->pass = (char *)((void *)0);
    {
#line 224
    n_free((void *)out, (int const   )224, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
    }
#line 224
    out = (ice_user_t *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return;
}
}
#line 228 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
int user_authenticate(char *cuser , char const   *password ) 
{ 
  ice_user_t const   *user ;
  ice_user_t search ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 233
  search.name = cuser;
#line 235
  if (! cuser) {
    {
    {
#line 236
    xa_debug(1, (char *)"WARNING: user_authenticate() called with NULL pointer");
    }
    }
#line 237
    return (0);
  } else
#line 235
  if (! password) {
    {
    {
#line 236
    xa_debug(1, (char *)"WARNING: user_authenticate() called with NULL pointer");
    }
    }
#line 237
    return (0);
  }
  {
  {
#line 239
  tmp = avl_find(usertree, (void const   *)(& search));
  }
#line 239
  user = (ice_user_t const   *)tmp;
  }
#line 241
  if (! user) {
#line 242
    return (0);
  }
  {
  {
#line 243
  tmp___0 = password_match((char const   *)user->pass, password);
  }
  }
#line 243
  return (tmp___0);
}
}
#line 246 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
ice_user_t *find_user_from_tree(usertree_t *ut , char const   *name ) 
{ 
  ice_user_t search ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 251
  search.name = strchr(name, (int )*(name + 0));
  }
  }
#line 255
  if (! ut) {
    {
    {
#line 256
    xa_debug(1, (char *)"WARNING: find_user_from_tree() called with NULL pointers");
    }
    }
#line 257
    return ((ice_user_t *)((void *)0));
  } else
#line 255
  if (! name) {
    {
    {
#line 256
    xa_debug(1, (char *)"WARNING: find_user_from_tree() called with NULL pointers");
    }
    }
#line 257
    return ((ice_user_t *)((void *)0));
  }
  {
  {
#line 259
  tmp = avl_find(ut, (void const   *)(& search));
  }
  }
#line 259
  return ((ice_user_t *)tmp);
}
}
#line 262 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
ice_user_t *con_get_user(connection_t *con , ice_user_t *outuser ) 
{ 
  char const   *cauth ;
  char *decoded ;
  char *ptr ;
  char user[8192] ;
  char auth[8192] ;
  char pass[8192] ;
  char *tmp ;
  char *tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 271
  if (! con) {
    {
    {
#line 272
    xa_debug(1, (char *)"WARNING: con_get_user() called with NULL pointers");
    }
    }
#line 273
    return ((ice_user_t *)((void *)0));
  } else
#line 271
  if (! outuser) {
    {
    {
#line 272
    xa_debug(1, (char *)"WARNING: con_get_user() called with NULL pointers");
    }
    }
#line 273
    return ((ice_user_t *)((void *)0));
  }
  {
#line 275
  outuser->name = (char *)((void *)0);
#line 276
  outuser->pass = (char *)((void *)0);
  {
#line 278
  cauth = get_con_variable(con, "Authorization");
  }
  }
#line 280
  if (! cauth) {
#line 281
    return ((ice_user_t *)((void *)0));
  }
  {
  {
#line 283
  strcpy((char */* __restrict  */)(auth), (char const   */* __restrict  */)cauth);
  }
  {
#line 285
  splitc((char *)((void *)0), auth, (char const   )' ');
  }
  {
#line 287
  xa_debug(1, (char *)"DEBUG: con_get_user() decoding: [%s]", auth);
  }
  {
#line 289
  decoded = util_base64_decode(auth);
  }
#line 289
  ptr = decoded;
  {
#line 291
  xa_debug(1, (char *)"DEBUG: con_get_user() decoded: [%s]", decoded);
  }
  {
#line 293
  tmp = splitc(user, decoded, (char const   )':');
  }
  }
#line 293
  if (! tmp) {
    {
    {
#line 294
    free((void *)ptr);
    }
    {
#line 295
    xa_debug(1, (char *)"DEBUG: con_get_user() Invalid authentication string");
    }
    }
#line 296
    return ((ice_user_t *)((void *)0));
  }
  {
  {
#line 298
  tmp___0 = splitc(pass, decoded, (char const   )':');
  }
  }
#line 298
  if (! tmp___0) {
    {
    {
#line 299
    strcpy((char */* __restrict  */)(pass), (char const   */* __restrict  */)decoded);
    }
    }
  }
  {
  {
#line 301
  outuser->name = strdup((char const   *)(user));
  }
  {
#line 302
  outuser->pass = strdup((char const   *)(pass));
  }
  {
#line 304
  free((void *)ptr);
  }
  }
#line 306
  return (outuser);
}
}
#line 309 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c"
void con_display_users(com_request_t *req ) 
{ 
  ice_user_t *user ;
  avl_traverser trav ;
  int listed ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 312
  trav.init = 0;
#line 312
  trav.nstack = 0;
#line 312
  trav.p = (avl_node const   *)0;
#line 312
  trav.stack[0] = (avl_node const   *)0;
#line 312
  trav.stack[1] = (avl_node const   *)0;
#line 312
  trav.stack[2] = (avl_node const   *)0;
#line 312
  trav.stack[3] = (avl_node const   *)0;
#line 312
  trav.stack[4] = (avl_node const   *)0;
#line 312
  trav.stack[5] = (avl_node const   *)0;
#line 312
  trav.stack[6] = (avl_node const   *)0;
#line 312
  trav.stack[7] = (avl_node const   *)0;
#line 312
  trav.stack[8] = (avl_node const   *)0;
#line 312
  trav.stack[9] = (avl_node const   *)0;
#line 312
  trav.stack[10] = (avl_node const   *)0;
#line 312
  trav.stack[11] = (avl_node const   *)0;
#line 312
  trav.stack[12] = (avl_node const   *)0;
#line 312
  trav.stack[13] = (avl_node const   *)0;
#line 312
  trav.stack[14] = (avl_node const   *)0;
#line 312
  trav.stack[15] = (avl_node const   *)0;
#line 312
  trav.stack[16] = (avl_node const   *)0;
#line 312
  trav.stack[17] = (avl_node const   *)0;
#line 312
  trav.stack[18] = (avl_node const   *)0;
#line 312
  trav.stack[19] = (avl_node const   *)0;
#line 312
  trav.stack[20] = (avl_node const   *)0;
#line 312
  trav.stack[21] = (avl_node const   *)0;
#line 312
  trav.stack[22] = (avl_node const   *)0;
#line 312
  trav.stack[23] = (avl_node const   *)0;
#line 312
  trav.stack[24] = (avl_node const   *)0;
#line 312
  trav.stack[25] = (avl_node const   *)0;
#line 312
  trav.stack[26] = (avl_node const   *)0;
#line 312
  trav.stack[27] = (avl_node const   *)0;
#line 312
  trav.stack[28] = (avl_node const   *)0;
#line 312
  trav.stack[29] = (avl_node const   *)0;
#line 312
  trav.stack[30] = (avl_node const   *)0;
#line 312
  trav.stack[31] = (avl_node const   *)0;
#line 314
  listed = 0;
  {
#line 316
  admin_write_line((com_request_t const   *)req, (int const   )431, "Listing users in the authentication module");
  }
  {
#line 318
  thread_mutex_lock_c(& authentication_mutex, 318, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  }
  {
  {
#line 320
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 320
    tmp = avl_traverse(usertree, & trav);
    }
#line 320
    user = (ice_user_t *)tmp;
    }
#line 320
    if (! user) {
#line 320
      goto while_break;
    }
    {
    {
#line 321
    admin_write_line((com_request_t const   *)req, (int const   )432, "User: [%s]",
                     user->name);
    }
#line 322
    listed ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 325
  thread_mutex_unlock_c(& authentication_mutex, 325, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/user.c");
  }
  {
#line 327
  admin_write_line((com_request_t const   *)req, (int const   )433, "End of user listing (%d listed)",
                   listed);
  }
  }
#line 328
  return;
}
}
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
int is_pattern(char const   *string ) ;
#line 27
int is_number(char const   *string ) ;
#line 4 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.h"
void list_rule(com_request_t *req , restrict_t *res ) ;
#line 5
int list_restrict(com_request_t *req , avl_tree *tree , acltype_t type ) ;
#line 6
void list_acl_control(com_request_t *req , avl_tree *acl , acltype_t type ) ;
#line 7
void list_all_acls(com_request_t *req ) ;
#line 8
restrict_t *create_restrict(void) ;
#line 9
restrict_t *add_restrict(avl_tree *tree , char *mask___0 , acltype_t type ) ;
#line 10
int del_restrict(avl_tree *tree , char *name , acltype_t type ) ;
#line 12
avl_tree *get_acl_list(contype_t contype ) ;
#line 13
int restrict_list(connection_t *con , avl_tree *list ) ;
#line 14
void free_acl_lists(void) ;
#line 15
void free_acl_list(avl_tree *list ) ;
#line 16
int allowed_no_policy(connection_t *con , contype_t contype ) ;
#line 5 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.h"
int wild_match(unsigned char const   *m , unsigned char const   *n ) ;
#line 72 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
void list_rule(com_request_t *req , restrict_t *res ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 75
  if (res->type) {
#line 75
    tmp = "allow";
  } else {
#line 75
    tmp = "deny";
  }
  {
  {
#line 75
  admin_write_line((com_request_t const   *)req, (int const   )387, "%d\t%s\t[%s]",
                   res->id, tmp, res->mask);
  }
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
int list_restrict(com_request_t *req , avl_tree *tree , acltype_t type ) 
{ 
  avl_traverser trav ;
  restrict_t *res ;
  int listed ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 81
  trav.init = 0;
#line 81
  trav.nstack = 0;
#line 81
  trav.p = (avl_node const   *)0;
#line 81
  trav.stack[0] = (avl_node const   *)0;
#line 81
  trav.stack[1] = (avl_node const   *)0;
#line 81
  trav.stack[2] = (avl_node const   *)0;
#line 81
  trav.stack[3] = (avl_node const   *)0;
#line 81
  trav.stack[4] = (avl_node const   *)0;
#line 81
  trav.stack[5] = (avl_node const   *)0;
#line 81
  trav.stack[6] = (avl_node const   *)0;
#line 81
  trav.stack[7] = (avl_node const   *)0;
#line 81
  trav.stack[8] = (avl_node const   *)0;
#line 81
  trav.stack[9] = (avl_node const   *)0;
#line 81
  trav.stack[10] = (avl_node const   *)0;
#line 81
  trav.stack[11] = (avl_node const   *)0;
#line 81
  trav.stack[12] = (avl_node const   *)0;
#line 81
  trav.stack[13] = (avl_node const   *)0;
#line 81
  trav.stack[14] = (avl_node const   *)0;
#line 81
  trav.stack[15] = (avl_node const   *)0;
#line 81
  trav.stack[16] = (avl_node const   *)0;
#line 81
  trav.stack[17] = (avl_node const   *)0;
#line 81
  trav.stack[18] = (avl_node const   *)0;
#line 81
  trav.stack[19] = (avl_node const   *)0;
#line 81
  trav.stack[20] = (avl_node const   *)0;
#line 81
  trav.stack[21] = (avl_node const   *)0;
#line 81
  trav.stack[22] = (avl_node const   *)0;
#line 81
  trav.stack[23] = (avl_node const   *)0;
#line 81
  trav.stack[24] = (avl_node const   *)0;
#line 81
  trav.stack[25] = (avl_node const   *)0;
#line 81
  trav.stack[26] = (avl_node const   *)0;
#line 81
  trav.stack[27] = (avl_node const   *)0;
#line 81
  trav.stack[28] = (avl_node const   *)0;
#line 81
  trav.stack[29] = (avl_node const   *)0;
#line 81
  trav.stack[30] = (avl_node const   *)0;
#line 81
  trav.stack[31] = (avl_node const   *)0;
#line 83
  listed = 0;
  {
#line 85
  thread_mutex_lock_c(& info.acl_mutex, 85, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
  {
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 87
    tmp = avl_traverse(tree, & trav);
    }
#line 87
    res = (restrict_t *)tmp;
    }
#line 87
    if (! res) {
#line 87
      goto while_break;
    }
#line 89
    if ((unsigned int )type == 2U) {
      {
      {
#line 91
      list_rule(req, res);
      }
#line 92
      listed ++;
      }
    } else
#line 89
    if ((unsigned int )res->type == (unsigned int )type) {
      {
      {
#line 91
      list_rule(req, res);
      }
#line 92
      listed ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 96
  thread_mutex_unlock_c(& info.acl_mutex, 96, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
#line 98
  return (listed);
}
}
#line 101 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
void list_acl_control(com_request_t *req , avl_tree *acl , acltype_t type ) 
{ 
  int listed ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 104
  listed = 0;
  {
#line 107
  if ((unsigned int )type == 0U) {
#line 107
    goto case_0;
  }
#line 110
  if ((unsigned int )type == 1U) {
#line 110
    goto case_1;
  }
#line 114
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 108
  admin_write((com_request_t const   *)req, (int const   )386, "Listing deny rules");
  }
  }
#line 109
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 111
  admin_write((com_request_t const   *)req, (int const   )389, "Listing allow rules");
  }
  }
#line 112
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 115
  tmp = avl_count((avl_tree const   *)acl);
  }
  {
#line 115
  admin_write((com_request_t const   *)req, (int const   )390, "Listing all control rules (%d)",
              tmp);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 118
  listed = list_restrict(req, acl, type);
  }
  {
#line 120
  admin_write_line((com_request_t const   *)req, (int const   )388, "End of restriction listing (%d listed)",
                   listed);
  }
  }
#line 121
  return;
}
}
#line 123 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
void list_all_acls(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 126
  admin_write_line((com_request_t const   *)req, (int const   )391, "Rules affecting all connections:");
  }
  {
#line 127
  list_acl_control(req, info.all_acl, (acltype_t )2);
  }
  {
#line 129
  admin_write_line((com_request_t const   *)req, (int const   )394, "Rules affecting admin connections:");
  }
  {
#line 130
  list_acl_control(req, info.admin_acl, (acltype_t )2);
  }
  {
#line 132
  admin_write_line((com_request_t const   *)req, (int const   )393, "Rules affecting source connections:");
  }
  {
#line 133
  list_acl_control(req, info.source_acl, (acltype_t )2);
  }
  {
#line 135
  admin_write_line((com_request_t const   *)req, (int const   )392, "Rules affecting client connections:");
  }
  {
#line 136
  list_acl_control(req, info.client_acl, (acltype_t )2);
  }
  }
#line 137
  return;
}
}
#line 139 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
restrict_t *create_restrict(void) 
{ 
  restrict_t *res ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 142
  tmp = n_malloc((unsigned int const   )sizeof(restrict_t ), (int const   )142, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
#line 142
  res = (restrict_t *)tmp;
  }
#line 143
  return (res);
}
}
#line 146 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
restrict_t *add_restrict(avl_tree *tree , char *mask___0 , acltype_t type ) 
{ 
  restrict_t *res ;
  restrict_t *out ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 151
  if (! mask___0) {
#line 152
    return ((restrict_t *)((void *)0));
  } else
#line 151
  if (! *(mask___0 + 0)) {
#line 152
    return ((restrict_t *)((void *)0));
  }
  {
  {
#line 154
  res = create_restrict();
  }
  {
#line 155
  res->mask = n_strdup((char const   *)mask___0, (int const   )155, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  {
#line 156
  tmp = avl_count((avl_tree const   *)tree);
  }
#line 156
  res->id = (unsigned long )tmp;
#line 157
  res->type = type;
  {
#line 159
  thread_mutex_lock_c(& info.acl_mutex, 159, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  {
#line 161
  tmp___0 = avl_replace(tree, (void *)res);
  }
#line 161
  out = (restrict_t *)tmp___0;
  {
#line 163
  thread_mutex_unlock_c(& info.acl_mutex, 163, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
#line 165
  if (out) {
    {
    {
#line 167
    n_free((void *)out->mask, (int const   )167, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
#line 167
    out->mask = (char *)((void *)0);
    {
#line 168
    n_free((void *)out, (int const   )168, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
#line 168
    out = (restrict_t *)((void *)0);
    }
  }
#line 171
  return (res);
}
}
#line 174 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
int del_restrict(avl_tree *tree , char *name , acltype_t type ) 
{ 
  avl_traverser trav ;
  restrict_t *res ;
  restrict_t *out ;
  int tmp ;
  void *tmp___0 ;
  restrict_t search ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 177
  trav.init = 0;
#line 177
  trav.nstack = 0;
#line 177
  trav.p = (avl_node const   *)0;
#line 177
  trav.stack[0] = (avl_node const   *)0;
#line 177
  trav.stack[1] = (avl_node const   *)0;
#line 177
  trav.stack[2] = (avl_node const   *)0;
#line 177
  trav.stack[3] = (avl_node const   *)0;
#line 177
  trav.stack[4] = (avl_node const   *)0;
#line 177
  trav.stack[5] = (avl_node const   *)0;
#line 177
  trav.stack[6] = (avl_node const   *)0;
#line 177
  trav.stack[7] = (avl_node const   *)0;
#line 177
  trav.stack[8] = (avl_node const   *)0;
#line 177
  trav.stack[9] = (avl_node const   *)0;
#line 177
  trav.stack[10] = (avl_node const   *)0;
#line 177
  trav.stack[11] = (avl_node const   *)0;
#line 177
  trav.stack[12] = (avl_node const   *)0;
#line 177
  trav.stack[13] = (avl_node const   *)0;
#line 177
  trav.stack[14] = (avl_node const   *)0;
#line 177
  trav.stack[15] = (avl_node const   *)0;
#line 177
  trav.stack[16] = (avl_node const   *)0;
#line 177
  trav.stack[17] = (avl_node const   *)0;
#line 177
  trav.stack[18] = (avl_node const   *)0;
#line 177
  trav.stack[19] = (avl_node const   *)0;
#line 177
  trav.stack[20] = (avl_node const   *)0;
#line 177
  trav.stack[21] = (avl_node const   *)0;
#line 177
  trav.stack[22] = (avl_node const   *)0;
#line 177
  trav.stack[23] = (avl_node const   *)0;
#line 177
  trav.stack[24] = (avl_node const   *)0;
#line 177
  trav.stack[25] = (avl_node const   *)0;
#line 177
  trav.stack[26] = (avl_node const   *)0;
#line 177
  trav.stack[27] = (avl_node const   *)0;
#line 177
  trav.stack[28] = (avl_node const   *)0;
#line 177
  trav.stack[29] = (avl_node const   *)0;
#line 177
  trav.stack[30] = (avl_node const   *)0;
#line 177
  trav.stack[31] = (avl_node const   *)0;
#line 179
  res = (restrict_t *)((void *)0);
  {
#line 181
  tmp___4 = is_pattern((char const   *)name);
  }
  }
#line 181
  if (tmp___4) {
    {
    {
#line 183
    thread_mutex_lock_c(& info.acl_mutex, 183, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
    {
    {
#line 185
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 185
      tmp___0 = avl_traverse(tree, & trav);
      }
#line 185
      res = (restrict_t *)tmp___0;
      }
#line 185
      if (! res) {
#line 185
        goto while_break;
      }
      {
      {
#line 187
      tmp = ice_strcasecmp((char const   *)res->mask, (char const   *)name);
      }
      }
#line 187
      if (tmp == 0) {
#line 187
        if ((unsigned int )type == (unsigned int )res->type) {
#line 188
          goto while_break;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 190
    tmp___3 = is_number((char const   *)name);
    }
    }
#line 190
    if (tmp___3) {
      {
      {
#line 193
      tmp___1 = atoi((char const   *)name);
      }
#line 193
      search.id = (unsigned long )tmp___1;
      {
#line 195
      thread_mutex_lock_c(& info.acl_mutex, 195, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
      {
#line 197
      tmp___2 = avl_find(tree, (void const   *)(& search));
      }
#line 197
      res = (restrict_t *)tmp___2;
      }
    }
  }
#line 200
  if (res) {
    {
    {
#line 202
    tmp___5 = avl_delete(tree, (void const   *)res);
    }
#line 202
    out = (restrict_t *)tmp___5;
    }
#line 203
    if (out) {
      {
      {
#line 205
      n_free((void *)out->mask, (int const   )205, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
#line 205
      out->mask = (char *)((void *)0);
      {
#line 206
      n_free((void *)out, (int const   )206, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
#line 206
      out = (restrict_t *)((void *)0);
      {
#line 207
      thread_mutex_unlock_c(& info.acl_mutex, 207, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
      }
#line 208
      return (1);
    }
  }
  {
  {
#line 211
  thread_mutex_unlock_c(& info.acl_mutex, 211, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
#line 212
  return (0);
}
}
#line 216 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
int allowed_no_policy(connection_t *con , contype_t contype ) 
{ 
  int result ;
  avl_tree *tmp ;
  int tmp___0 ;
  avl_tree *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 221
  thread_mutex_lock_c(& info.acl_mutex, 221, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  {
#line 225
  tmp = get_acl_list(contype);
  }
  {
#line 225
  result = restrict_list(con, tmp);
  }
  }
#line 227
  if (result != -1) {
    {
    {
#line 229
    thread_mutex_unlock_c(& info.acl_mutex, 229, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
#line 230
    if (result) {
#line 230
      tmp___0 = 1;
    } else {
#line 230
      tmp___0 = 0;
    }
#line 230
    return (tmp___0);
  }
  {
  {
#line 235
  tmp___1 = get_acl_list((contype_t )-1);
  }
  {
#line 235
  result = restrict_list(con, tmp___1);
  }
  }
#line 237
  if (result != -1) {
    {
    {
#line 239
    thread_mutex_unlock_c(& info.acl_mutex, 239, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
#line 240
    if (result) {
#line 240
      tmp___2 = 1;
    } else {
#line 240
      tmp___2 = 0;
    }
#line 240
    return (tmp___2);
  }
  {
  {
#line 243
  thread_mutex_unlock_c(& info.acl_mutex, 243, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
#line 246
  return (-1);
}
}
#line 250 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
int allowed(connection_t *con , contype_t contype ) 
{ 
  int result ;
  avl_tree *tmp ;
  int tmp___0 ;
  avl_tree *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 255
  thread_mutex_lock_c(& info.acl_mutex, 255, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  {
#line 259
  tmp = get_acl_list(contype);
  }
  {
#line 259
  result = restrict_list(con, tmp);
  }
  }
#line 261
  if (result != -1) {
    {
    {
#line 263
    thread_mutex_unlock_c(& info.acl_mutex, 263, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
#line 264
    if (result) {
#line 264
      tmp___0 = 1;
    } else {
#line 264
      tmp___0 = 0;
    }
#line 264
    return (tmp___0);
  }
  {
  {
#line 269
  tmp___1 = get_acl_list((contype_t )-1);
  }
  {
#line 269
  result = restrict_list(con, tmp___1);
  }
  }
#line 271
  if (result != -1) {
    {
    {
#line 273
    thread_mutex_unlock_c(& info.acl_mutex, 273, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
#line 274
    if (result) {
#line 274
      tmp___2 = 1;
    } else {
#line 274
      tmp___2 = 0;
    }
#line 274
    return (tmp___2);
  }
  {
  {
#line 277
  thread_mutex_unlock_c(& info.acl_mutex, 277, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
  }
  }
#line 280
  return (info.policy);
}
}
#line 283 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
avl_tree *get_acl_list(contype_t contype ) 
{ 


  {
  {
#line 288
  if ((unsigned int )contype == 0U) {
#line 288
    goto case_0;
  }
#line 291
  if ((unsigned int )contype == 1U) {
#line 291
    goto case_1;
  }
#line 294
  if ((unsigned int )contype == 2U) {
#line 294
    goto case_2;
  }
#line 297
  goto switch_default;
  case_0: /* CIL Label */ 
#line 289
  return (info.client_acl);
#line 290
  goto switch_break;
  case_1: /* CIL Label */ 
#line 292
  return (info.source_acl);
#line 293
  goto switch_break;
  case_2: /* CIL Label */ 
#line 295
  return (info.admin_acl);
#line 296
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 298
  return (info.all_acl);
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 301
  return ((avl_tree *)0);
}
}
#line 303 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
int restrict_list(connection_t *con , avl_tree *list ) 
{ 
  avl_traverser trav ;
  restrict_t *res ;
  int out ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 306
  trav.init = 0;
#line 306
  trav.nstack = 0;
#line 306
  trav.p = (avl_node const   *)0;
#line 306
  trav.stack[0] = (avl_node const   *)0;
#line 306
  trav.stack[1] = (avl_node const   *)0;
#line 306
  trav.stack[2] = (avl_node const   *)0;
#line 306
  trav.stack[3] = (avl_node const   *)0;
#line 306
  trav.stack[4] = (avl_node const   *)0;
#line 306
  trav.stack[5] = (avl_node const   *)0;
#line 306
  trav.stack[6] = (avl_node const   *)0;
#line 306
  trav.stack[7] = (avl_node const   *)0;
#line 306
  trav.stack[8] = (avl_node const   *)0;
#line 306
  trav.stack[9] = (avl_node const   *)0;
#line 306
  trav.stack[10] = (avl_node const   *)0;
#line 306
  trav.stack[11] = (avl_node const   *)0;
#line 306
  trav.stack[12] = (avl_node const   *)0;
#line 306
  trav.stack[13] = (avl_node const   *)0;
#line 306
  trav.stack[14] = (avl_node const   *)0;
#line 306
  trav.stack[15] = (avl_node const   *)0;
#line 306
  trav.stack[16] = (avl_node const   *)0;
#line 306
  trav.stack[17] = (avl_node const   *)0;
#line 306
  trav.stack[18] = (avl_node const   *)0;
#line 306
  trav.stack[19] = (avl_node const   *)0;
#line 306
  trav.stack[20] = (avl_node const   *)0;
#line 306
  trav.stack[21] = (avl_node const   *)0;
#line 306
  trav.stack[22] = (avl_node const   *)0;
#line 306
  trav.stack[23] = (avl_node const   *)0;
#line 306
  trav.stack[24] = (avl_node const   *)0;
#line 306
  trav.stack[25] = (avl_node const   *)0;
#line 306
  trav.stack[26] = (avl_node const   *)0;
#line 306
  trav.stack[27] = (avl_node const   *)0;
#line 306
  trav.stack[28] = (avl_node const   *)0;
#line 306
  trav.stack[29] = (avl_node const   *)0;
#line 306
  trav.stack[30] = (avl_node const   *)0;
#line 306
  trav.stack[31] = (avl_node const   *)0;
#line 309
  out = -1;
  {
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 312
    tmp___1 = avl_traverse(list, & trav);
    }
#line 312
    res = (restrict_t *)tmp___1;
    }
#line 312
    if (! res) {
#line 312
      goto while_break;
    }
    {
    {
#line 314
    tmp = wild_match((unsigned char const   *)((unsigned char *)res->mask), (unsigned char const   *)((unsigned char *)con->host));
    }
    }
#line 314
    if (tmp) {
#line 314
      goto _L;
    } else
#line 314
    if (con->hostname) {
      {
      {
#line 314
      tmp___0 = wild_match((unsigned char const   *)((unsigned char *)res->mask),
                           (unsigned char const   *)((unsigned char *)con->hostname));
      }
      }
#line 314
      if (tmp___0) {
        _L: /* CIL Label */ 
#line 316
        out = (int )res->type;
#line 317
        if (out == 1) {
#line 317
          return (1);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return (out);
}
}
#line 324 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
void free_acl_list(avl_tree *list ) 
{ 
  restrict_t *res ;
  restrict_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 329
  if (! list) {
    {
    {
#line 330
    write_log(0, (char *)"WARNING: NULL list passed to free_acl_list()");
    }
    }
#line 331
    return;
  }
  {
  {
#line 334
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 334
    tmp___0 = avl_get_any_node(list);
    }
#line 334
    res = (restrict_t *)tmp___0;
    }
#line 334
    if (! res) {
#line 334
      goto while_break;
    }
#line 336
    if (! res) {
      {
      {
#line 337
      write_log(0, (char *)"WARNING: NULL item passed from avl_get_any_node()");
      }
      }
#line 338
      goto while_continue;
    }
    {
    {
#line 341
    tmp = avl_delete(list, (void const   *)res);
    }
#line 341
    out = (restrict_t *)tmp;
    }
#line 342
    if (out) {
      {
      {
#line 343
      n_free((void *)out->mask, (int const   )343, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
#line 343
      out->mask = (char *)((void *)0);
      {
#line 344
      n_free((void *)out, (int const   )344, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
      }
#line 344
      out = (restrict_t *)((void *)0);
      }
    } else {
      {
      {
#line 346
      write_log(0, (char *)"WARNING: avl_delete() of acl item failed!");
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 349
  return;
}
}
#line 351 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c"
void free_acl_lists(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 355
  if (! info.client_acl) {
    {
    {
#line 356
    write_log(0, (char *)"WARNING: NULL acl tree pointers, this is weird! (info at %p)",
              & info);
    }
    }
  } else
#line 355
  if (! info.source_acl) {
    {
    {
#line 356
    write_log(0, (char *)"WARNING: NULL acl tree pointers, this is weird! (info at %p)",
              & info);
    }
    }
  } else
#line 355
  if (! info.admin_acl) {
    {
    {
#line 356
    write_log(0, (char *)"WARNING: NULL acl tree pointers, this is weird! (info at %p)",
              & info);
    }
    }
  } else
#line 355
  if (! info.all_acl) {
    {
    {
#line 356
    write_log(0, (char *)"WARNING: NULL acl tree pointers, this is weird! (info at %p)",
              & info);
    }
    }
  } else {
    {
    {
#line 359
    thread_mutex_lock_c(& info.acl_mutex, 359, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    {
#line 361
    free_acl_list(info.client_acl);
    }
    {
#line 362
    free_acl_list(info.source_acl);
    }
    {
#line 363
    free_acl_list(info.admin_acl);
    }
    {
#line 364
    free_acl_list(info.all_acl);
    }
    {
#line 366
    thread_mutex_unlock_c(& info.acl_mutex, 366, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/restrict.c");
    }
    }
  }
#line 369
  return;
}
}
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
mythread_t *thread_check_created(void) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.h"
void write_clf(connection_t *clicon , source_t *source ) ;
#line 29
void stats_write(server_info_t *info___0 ) ;
#line 30
int open_log_file(char *name , int oldfd ) ;
#line 31
void open_log_files(void) ;
#line 32
int fd_write(int fd , char const   *fmt  , ...) ;
#line 34
int fd_read_line_nb(int fd , char *buff , int const   len ) ;
#line 37
int fd_write_bytes(int fd , char const   *buff , int const   len ) ;
#line 38
void stats_write_html(server_info_t *info___0 ) ;
#line 39
int get_log_fd(int whichlog ) ;
#line 40
void write_log_not_me(int whichlog , connection_t *nothim , char *fmt  , ...) ;
#line 41
void log_no_thread(int whichlog , char *fmt  , ...) ;
#line 29 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.h"
char *get_log_time(void) ;
#line 31
char *get_clf_log_time(void) ;
#line 36 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void print_source_verbose(void *data , void *param ) ;
#line 37
void print_clients(void *data , void *param ) ;
#line 40
void print_admin(void *data , void *param ) ;
#line 94
char *get_template(char const   *filename ) ;
#line 95
char *get_log_file(char const   *filename ) ;
#line 38 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *nice_time(unsigned long seconds , char *buf ) ;
#line 47
char const   *nullcheck_string(char const   *string ) ;
#line 18 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.h"
void get_running_stats(statistics_t *stat___0 ) ;
#line 51 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.h"
char *ice_utoa(unsigned long num ) ;
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
int write_template_parsed_html_page(connection_t *clicon , connection_t *sourcecon ,
                                    char const   *template_file , int fd , vartree_t *variables ) ;
#line 29 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.h"
char const   *get_user_agent(connection_t *con ) ;
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void write_clf(connection_t *clicon , source_t *source ) 
{ 
  char *mount ;
  char *timeptr ;
  char const   *refptr ;
  char const   *uaptr ;
  ice_user_t user ;
  long tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 85
  if (info.accessfile == -1) {
#line 86
    return;
  }
#line 87
  if (! clicon) {
#line 88
    return;
  }
  {
  {
#line 90
  con_get_user(clicon, & user);
  }
  }
#line 92
  if (source) {
#line 92
    if (source->audiocast.mount) {
#line 92
      mount = source->audiocast.mount;
    } else {
#line 92
      mount = (char *)"/";
    }
  } else {
#line 92
    mount = (char *)"/";
  }
  {
  {
#line 94
  refptr = get_con_variable(clicon, "Referer");
  }
  {
#line 95
  uaptr = get_user_agent(clicon);
  }
  {
#line 97
  tmp = get_time();
  }
  }
#line 97
  if (uaptr) {
#line 97
    tmp___0 = uaptr;
  } else {
#line 97
    tmp___0 = "-";
  }
#line 97
  if (refptr) {
#line 97
    tmp___1 = refptr;
  } else {
#line 97
    tmp___1 = "-";
  }
  {
  {
#line 97
  timeptr = get_clf_log_time();
  }
  }
#line 97
  if (user.name) {
#line 97
    tmp___2 = (char const   *)user.name;
  } else {
#line 97
    tmp___2 = "-";
  }
  {
  {
#line 97
  tmp___3 = con_host(clicon);
  }
  {
#line 97
  fd_write_line(info.accessfile, "%s %s - [%s] \"GET %s HTTP/1.0\" 200 %lu \"%s\" \"%s\" %d",
                tmp___3, tmp___2, timeptr, mount, (clicon->food.client)->write_bytes,
                tmp___1, tmp___0, tmp - clicon->connect_time);
  }
  }
#line 101
  if (timeptr) {
    {
    {
#line 102
    free((void *)timeptr);
    }
    }
  }
#line 103
  return;
}
}
#line 105 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int get_log_fd(int whichlog ) 
{ 


  {
#line 108
  if (whichlog == 1) {
#line 109
    if (info.usagefile != -1) {
#line 110
      return (info.usagefile);
    }
  }
#line 111
  if (whichlog == 2) {
#line 112
    if (info.accessfile != -1) {
#line 113
      return (info.accessfile);
    }
  }
#line 114
  if (info.logfile != -1) {
#line 115
    return (info.logfile);
  }
#line 117
  return (-1);
}
}
#line 121 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void write_log(int whichlog , char *fmt  , ...) 
{ 
  char buf[8192] ;
  va_list ap ;
  char *logtime ;
  avl_traverser trav ;
  connection_t *con ;
  admin_t *admin ;
  mythread_t *mt ;
  mythread_t *tmp ;
  int fd ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 127
  trav.init = 0;
#line 127
  trav.nstack = 0;
#line 127
  trav.p = (avl_node const   *)0;
#line 127
  trav.stack[0] = (avl_node const   *)0;
#line 127
  trav.stack[1] = (avl_node const   *)0;
#line 127
  trav.stack[2] = (avl_node const   *)0;
#line 127
  trav.stack[3] = (avl_node const   *)0;
#line 127
  trav.stack[4] = (avl_node const   *)0;
#line 127
  trav.stack[5] = (avl_node const   *)0;
#line 127
  trav.stack[6] = (avl_node const   *)0;
#line 127
  trav.stack[7] = (avl_node const   *)0;
#line 127
  trav.stack[8] = (avl_node const   *)0;
#line 127
  trav.stack[9] = (avl_node const   *)0;
#line 127
  trav.stack[10] = (avl_node const   *)0;
#line 127
  trav.stack[11] = (avl_node const   *)0;
#line 127
  trav.stack[12] = (avl_node const   *)0;
#line 127
  trav.stack[13] = (avl_node const   *)0;
#line 127
  trav.stack[14] = (avl_node const   *)0;
#line 127
  trav.stack[15] = (avl_node const   *)0;
#line 127
  trav.stack[16] = (avl_node const   *)0;
#line 127
  trav.stack[17] = (avl_node const   *)0;
#line 127
  trav.stack[18] = (avl_node const   *)0;
#line 127
  trav.stack[19] = (avl_node const   *)0;
#line 127
  trav.stack[20] = (avl_node const   *)0;
#line 127
  trav.stack[21] = (avl_node const   *)0;
#line 127
  trav.stack[22] = (avl_node const   *)0;
#line 127
  trav.stack[23] = (avl_node const   *)0;
#line 127
  trav.stack[24] = (avl_node const   *)0;
#line 127
  trav.stack[25] = (avl_node const   *)0;
#line 127
  trav.stack[26] = (avl_node const   *)0;
#line 127
  trav.stack[27] = (avl_node const   *)0;
#line 127
  trav.stack[28] = (avl_node const   *)0;
#line 127
  trav.stack[29] = (avl_node const   *)0;
#line 127
  trav.stack[30] = (avl_node const   *)0;
#line 127
  trav.stack[31] = (avl_node const   *)0;
  {
#line 130
  tmp = thread_check_created();
  }
#line 130
  mt = tmp;
  {
#line 131
  tmp___0 = get_log_fd(whichlog);
  }
#line 131
  fd = tmp___0;
  {
#line 133
  __builtin_va_start(ap, fmt);
  }
  {
#line 134
  vsnprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  }
#line 136
  if (! mt) {
    {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: No mt while outputting [%s]",
            buf);
    }
    }
  }
  {
  {
#line 139
  logtime = get_log_time();
  }
  {
#line 141
  tmp___1 = strstr((char const   *)(buf), "%s");
  }
  }
#line 141
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
    {
    {
#line 142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING, write_log () called with \'%%s\' formatted string [%s]!",
            buf);
    }
    }
#line 143
    return;
  }
#line 146
  if (mt) {
#line 146
    if (fd != -1) {
      {
      {
#line 147
      tmp___2 = nullcheck_string((char const   *)mt->name);
      }
      {
#line 147
      fd_write(fd, "[%s] [%d:%s] %s\n", logtime, mt->id, tmp___2, buf);
      }
      }
    }
  }
#line 150
  if (whichlog != 0) {
    {
    {
#line 152
    free((void *)logtime);
    }
    {
#line 153
    __builtin_va_end(ap);
    }
    }
#line 154
    return;
  }
#line 157
  if (info.console_mode == 2) {
    {
    {
#line 158
    printf((char const   */* __restrict  */)"\r[%s] %s\n", logtime, buf);
    }
    {
#line 159
    fflush(stdout);
    }
    }
  }
#line 162
  if (running == 1) {
    {
    {
#line 163
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 163
      tmp___4 = avl_traverse(info.admins, & trav);
      }
#line 163
      con = (connection_t *)tmp___4;
      }
#line 163
      if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 163
        goto while_break;
      }
#line 164
      admin = con->food.admin;
#line 165
      if ((unsigned int )con->type != 2U) {
        {
        {
#line 166
        printf((char const   */* __restrict  */)"ERROR IN TYPE in id %ld\n", con->id);
        }
        }
#line 167
        goto while_continue;
      }
#line 169
      if (admin->tailing) {
#line 169
        if (admin->alive) {
          {
          {
#line 170
          tmp___3 = ice_strcmp((char const   *)con->host, "icecast console");
          }
          }
#line 170
          if (tmp___3 == 0) {
            {
            {
#line 172
            printf((char const   */* __restrict  */)"[%s] %s\n-> ", logtime, buf);
            }
            {
#line 173
            fflush(stdout);
            }
            }
          } else {
            {
            {
#line 177
            sock_write_line(con->sock, "[%s] %s", logtime, buf);
            }
            {
#line 178
            sock_write(con->sock, "->");
            }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 182
  if (info.console_mode != 2) {
    {
    {
#line 183
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] %s\n",
            logtime, buf);
    }
    }
  }
#line 186
  if (logtime) {
    {
    {
#line 187
    free((void *)logtime);
    }
    }
  }
  {
  {
#line 188
  __builtin_va_end(ap);
  }
  }
#line 189
  return;
}
}
#line 191 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void log_no_thread(int whichlog , char *fmt  , ...) 
{ 
  char buf[8192] ;
  va_list ap ;
  char *logtime ;
  avl_traverser trav ;
  connection_t *con ;
  admin_t *admin ;
  int fd ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 197
  trav.init = 0;
#line 197
  trav.nstack = 0;
#line 197
  trav.p = (avl_node const   *)0;
#line 197
  trav.stack[0] = (avl_node const   *)0;
#line 197
  trav.stack[1] = (avl_node const   *)0;
#line 197
  trav.stack[2] = (avl_node const   *)0;
#line 197
  trav.stack[3] = (avl_node const   *)0;
#line 197
  trav.stack[4] = (avl_node const   *)0;
#line 197
  trav.stack[5] = (avl_node const   *)0;
#line 197
  trav.stack[6] = (avl_node const   *)0;
#line 197
  trav.stack[7] = (avl_node const   *)0;
#line 197
  trav.stack[8] = (avl_node const   *)0;
#line 197
  trav.stack[9] = (avl_node const   *)0;
#line 197
  trav.stack[10] = (avl_node const   *)0;
#line 197
  trav.stack[11] = (avl_node const   *)0;
#line 197
  trav.stack[12] = (avl_node const   *)0;
#line 197
  trav.stack[13] = (avl_node const   *)0;
#line 197
  trav.stack[14] = (avl_node const   *)0;
#line 197
  trav.stack[15] = (avl_node const   *)0;
#line 197
  trav.stack[16] = (avl_node const   *)0;
#line 197
  trav.stack[17] = (avl_node const   *)0;
#line 197
  trav.stack[18] = (avl_node const   *)0;
#line 197
  trav.stack[19] = (avl_node const   *)0;
#line 197
  trav.stack[20] = (avl_node const   *)0;
#line 197
  trav.stack[21] = (avl_node const   *)0;
#line 197
  trav.stack[22] = (avl_node const   *)0;
#line 197
  trav.stack[23] = (avl_node const   *)0;
#line 197
  trav.stack[24] = (avl_node const   *)0;
#line 197
  trav.stack[25] = (avl_node const   *)0;
#line 197
  trav.stack[26] = (avl_node const   *)0;
#line 197
  trav.stack[27] = (avl_node const   *)0;
#line 197
  trav.stack[28] = (avl_node const   *)0;
#line 197
  trav.stack[29] = (avl_node const   *)0;
#line 197
  trav.stack[30] = (avl_node const   *)0;
#line 197
  trav.stack[31] = (avl_node const   *)0;
  {
#line 200
  tmp = get_log_fd(whichlog);
  }
#line 200
  fd = tmp;
  {
#line 202
  __builtin_va_start(ap, fmt);
  }
  {
#line 203
  vsnprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 205
  logtime = get_log_time();
  }
  {
#line 207
  tmp___0 = strstr((char const   *)(buf), "%s");
  }
  }
#line 207
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
    {
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING, write_log () called with \'%%s\' formatted string [%s]!",
            buf);
    }
    }
#line 209
    return;
  }
#line 212
  if (fd != -1) {
    {
    {
#line 213
    fd_write(fd, "[%s] %s\n", logtime, buf);
    }
    }
  }
#line 216
  if (whichlog != 0) {
    {
    {
#line 218
    free((void *)logtime);
    }
    {
#line 219
    __builtin_va_end(ap);
    }
    }
#line 220
    return;
  }
#line 223
  if (info.console_mode == 2) {
    {
    {
#line 224
    printf((char const   */* __restrict  */)"\r[%s] %s\n", logtime, buf);
    }
    {
#line 225
    fflush(stdout);
    }
    }
  }
#line 228
  if (running == 1) {
    {
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 229
      tmp___2 = avl_traverse(info.admins, & trav);
      }
#line 229
      con = (connection_t *)tmp___2;
      }
#line 229
      if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 229
        goto while_break;
      }
#line 230
      admin = con->food.admin;
#line 231
      if ((unsigned int )con->type != 2U) {
        {
        {
#line 232
        printf((char const   */* __restrict  */)"ERROR IN TYPE in id %ld\n", con->id);
        }
        }
#line 233
        goto while_continue;
      }
#line 235
      if (admin->tailing) {
#line 235
        if (admin->alive) {
          {
          {
#line 236
          tmp___1 = ice_strcmp((char const   *)con->host, "icecast console");
          }
          }
#line 236
          if (tmp___1 == 0) {
            {
            {
#line 238
            printf((char const   */* __restrict  */)"[%s] %s\n-> ", logtime, buf);
            }
            {
#line 239
            fflush(stdout);
            }
            }
          } else {
            {
            {
#line 243
            sock_write_line(con->sock, "[%s] %s", logtime, buf);
            }
            {
#line 244
            sock_write(con->sock, "->");
            }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 248
  if (info.console_mode != 2) {
    {
    {
#line 249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] %s\n",
            logtime, buf);
    }
    }
  }
#line 252
  if (logtime) {
    {
    {
#line 253
    free((void *)logtime);
    }
    }
  }
  {
  {
#line 254
  __builtin_va_end(ap);
  }
  }
#line 255
  return;
}
}
#line 257 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void write_log_not_me(int whichlog , connection_t *nothim , char *fmt  , ...) 
{ 
  char buf[8192] ;
  va_list ap ;
  char *logtime ;
  avl_traverser trav ;
  connection_t *con ;
  admin_t *admin ;
  int fd ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 263
  trav.init = 0;
#line 263
  trav.nstack = 0;
#line 263
  trav.p = (avl_node const   *)0;
#line 263
  trav.stack[0] = (avl_node const   *)0;
#line 263
  trav.stack[1] = (avl_node const   *)0;
#line 263
  trav.stack[2] = (avl_node const   *)0;
#line 263
  trav.stack[3] = (avl_node const   *)0;
#line 263
  trav.stack[4] = (avl_node const   *)0;
#line 263
  trav.stack[5] = (avl_node const   *)0;
#line 263
  trav.stack[6] = (avl_node const   *)0;
#line 263
  trav.stack[7] = (avl_node const   *)0;
#line 263
  trav.stack[8] = (avl_node const   *)0;
#line 263
  trav.stack[9] = (avl_node const   *)0;
#line 263
  trav.stack[10] = (avl_node const   *)0;
#line 263
  trav.stack[11] = (avl_node const   *)0;
#line 263
  trav.stack[12] = (avl_node const   *)0;
#line 263
  trav.stack[13] = (avl_node const   *)0;
#line 263
  trav.stack[14] = (avl_node const   *)0;
#line 263
  trav.stack[15] = (avl_node const   *)0;
#line 263
  trav.stack[16] = (avl_node const   *)0;
#line 263
  trav.stack[17] = (avl_node const   *)0;
#line 263
  trav.stack[18] = (avl_node const   *)0;
#line 263
  trav.stack[19] = (avl_node const   *)0;
#line 263
  trav.stack[20] = (avl_node const   *)0;
#line 263
  trav.stack[21] = (avl_node const   *)0;
#line 263
  trav.stack[22] = (avl_node const   *)0;
#line 263
  trav.stack[23] = (avl_node const   *)0;
#line 263
  trav.stack[24] = (avl_node const   *)0;
#line 263
  trav.stack[25] = (avl_node const   *)0;
#line 263
  trav.stack[26] = (avl_node const   *)0;
#line 263
  trav.stack[27] = (avl_node const   *)0;
#line 263
  trav.stack[28] = (avl_node const   *)0;
#line 263
  trav.stack[29] = (avl_node const   *)0;
#line 263
  trav.stack[30] = (avl_node const   *)0;
#line 263
  trav.stack[31] = (avl_node const   *)0;
  {
#line 267
  tmp = get_log_fd(whichlog);
  }
#line 267
  fd = tmp;
  {
#line 269
  __builtin_va_start(ap, fmt);
  }
  {
#line 270
  vsnprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 272
  logtime = get_log_time();
  }
  {
#line 274
  tmp___0 = strstr((char const   *)(buf), "%s");
  }
  }
#line 274
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
    {
#line 275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING, xa_debug() called with \'%%s\' formatted string [%s]!",
            buf);
    }
    }
#line 276
    return;
  }
#line 279
  if (fd != -1) {
    {
    {
#line 280
    fd_write(fd, "[%s] %s\n", logtime, buf);
    }
    }
  }
#line 283
  if (whichlog != 0) {
    {
    {
#line 285
    free((void *)logtime);
    }
    {
#line 286
    __builtin_va_end(ap);
    }
    }
#line 287
    return;
  }
#line 290
  if (info.console_mode == 2) {
    {
    {
#line 291
    printf((char const   */* __restrict  */)"\r[%s] %s\n", logtime, buf);
    }
    {
#line 292
    fflush(stdout);
    }
    }
  }
#line 295
  if (running == 1) {
    {
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 296
      tmp___2 = avl_traverse(info.admins, & trav);
      }
#line 296
      con = (connection_t *)tmp___2;
      }
#line 296
      if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 296
        goto while_break;
      }
#line 297
      admin = con->food.admin;
#line 298
      if ((unsigned int )con->type != 2U) {
        {
        {
#line 299
        printf((char const   */* __restrict  */)"ERROR IN TYPE in id %ld\n", con->id);
        }
        }
#line 300
        goto while_continue;
      }
#line 302
      if (admin->tailing) {
#line 302
        if (admin->alive) {
#line 302
          if (con->id != nothim->id) {
            {
            {
#line 303
            tmp___1 = ice_strcmp((char const   *)con->host, "icecast console");
            }
            }
#line 303
            if (tmp___1 == 0) {
              {
              {
#line 305
              printf((char const   */* __restrict  */)"[%s] %s\n-> ", logtime, buf);
              }
              {
#line 306
              fflush(stdout);
              }
              }
            } else {
              {
              {
#line 310
              sock_write_line(con->sock, "[%s] %s", logtime, buf);
              }
              {
#line 311
              sock_write(con->sock, "->");
              }
              }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 315
  if (info.console_mode != 2) {
    {
    {
#line 316
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] %s\n",
            logtime, buf);
    }
    }
  }
#line 319
  if (logtime) {
    {
    {
#line 320
    free((void *)logtime);
    }
    }
  }
  {
  {
#line 321
  __builtin_va_end(ap);
  }
  }
#line 322
  return;
}
}
#line 324 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void xa_debug(int level , char *fmt  , ...) 
{ 
  char buf[8192] ;
  va_list ap ;
  char *logtime ;
  avl_traverser trav ;
  connection_t *con ;
  admin_t *admin ;
  mythread_t *mt ;
  mythread_t *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 329
  logtime = (char *)((void *)0);
#line 330
  trav.init = 0;
#line 330
  trav.nstack = 0;
#line 330
  trav.p = (avl_node const   *)0;
#line 330
  trav.stack[0] = (avl_node const   *)0;
#line 330
  trav.stack[1] = (avl_node const   *)0;
#line 330
  trav.stack[2] = (avl_node const   *)0;
#line 330
  trav.stack[3] = (avl_node const   *)0;
#line 330
  trav.stack[4] = (avl_node const   *)0;
#line 330
  trav.stack[5] = (avl_node const   *)0;
#line 330
  trav.stack[6] = (avl_node const   *)0;
#line 330
  trav.stack[7] = (avl_node const   *)0;
#line 330
  trav.stack[8] = (avl_node const   *)0;
#line 330
  trav.stack[9] = (avl_node const   *)0;
#line 330
  trav.stack[10] = (avl_node const   *)0;
#line 330
  trav.stack[11] = (avl_node const   *)0;
#line 330
  trav.stack[12] = (avl_node const   *)0;
#line 330
  trav.stack[13] = (avl_node const   *)0;
#line 330
  trav.stack[14] = (avl_node const   *)0;
#line 330
  trav.stack[15] = (avl_node const   *)0;
#line 330
  trav.stack[16] = (avl_node const   *)0;
#line 330
  trav.stack[17] = (avl_node const   *)0;
#line 330
  trav.stack[18] = (avl_node const   *)0;
#line 330
  trav.stack[19] = (avl_node const   *)0;
#line 330
  trav.stack[20] = (avl_node const   *)0;
#line 330
  trav.stack[21] = (avl_node const   *)0;
#line 330
  trav.stack[22] = (avl_node const   *)0;
#line 330
  trav.stack[23] = (avl_node const   *)0;
#line 330
  trav.stack[24] = (avl_node const   *)0;
#line 330
  trav.stack[25] = (avl_node const   *)0;
#line 330
  trav.stack[26] = (avl_node const   *)0;
#line 330
  trav.stack[27] = (avl_node const   *)0;
#line 330
  trav.stack[28] = (avl_node const   *)0;
#line 330
  trav.stack[29] = (avl_node const   *)0;
#line 330
  trav.stack[30] = (avl_node const   *)0;
#line 330
  trav.stack[31] = (avl_node const   *)0;
  {
#line 333
  tmp = thread_check_created();
  }
#line 333
  mt = tmp;
  {
#line 337
  __builtin_va_start(ap, fmt);
  }
  {
#line 338
  vsnprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  }
#line 340
  if (! mt) {
    {
    {
#line 341
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: No mt while outputting [%s]",
            buf);
    }
    }
  }
  {
  {
#line 343
  logtime = get_log_time();
  }
  }
#line 345
  if (! mt) {
#line 346
    return;
  }
  {
  {
#line 352
  tmp___0 = strstr((char const   *)(buf), "%s");
  }
  }
#line 352
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
    {
#line 353
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING, xa_debug() called with \'%%s\' formatted string [%s]!",
            buf);
    }
    }
#line 354
    return;
  }
#line 358
  if (info.logfiledebuglevel >= level) {
#line 359
    if (info.logfile != -1) {
      {
      {
#line 360
      tmp___1 = nullcheck_string((char const   *)mt->name);
      }
      {
#line 360
      fd_write(info.logfile, "[%s] [%ld:%s] %s\n", logtime, mt->id, tmp___1, buf);
      }
      }
    }
  }
#line 363
  if (info.consoledebuglevel >= level) {
#line 364
    if (info.console_mode == 2) {
      {
      {
#line 365
      tmp___2 = nullcheck_string((char const   *)mt->name);
      }
      {
#line 365
      printf((char const   */* __restrict  */)"\r[%s] [%ld:%s] %s\n", logtime, mt->id,
             tmp___2, buf);
      }
      {
#line 366
      fflush(stdout);
      }
      }
    }
  }
#line 369
  if (running == 1) {
    {
    {
#line 370
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 370
      tmp___5 = avl_traverse(info.admins, & trav);
      }
#line 370
      con = (connection_t *)tmp___5;
      }
#line 370
      if (! ((unsigned long )con != (unsigned long )((void *)0))) {
#line 370
        goto while_break;
      }
#line 371
      admin = con->food.admin;
#line 372
      if ((unsigned int )con->type != 2U) {
        {
        {
#line 373
        printf((char const   */* __restrict  */)"ERROR IN TYPE in id %ld\n", con->id);
        }
        }
#line 374
        goto while_continue;
      }
#line 376
      if (admin->tailing) {
#line 376
        if (admin->alive) {
#line 376
          if (admin->debuglevel >= level) {
            {
            {
#line 377
            tmp___4 = ice_strcmp((char const   *)con->host, "icecast console");
            }
            }
#line 377
            if (tmp___4 == 0) {
              {
              {
#line 379
              tmp___3 = nullcheck_string((char const   *)mt->name);
              }
              {
#line 379
              printf((char const   */* __restrict  */)"[%s] [%ld:%s] %s\n-> ", logtime,
                     mt->id, tmp___3, buf);
              }
              {
#line 380
              fflush(stdout);
              }
              }
            } else {
              {
              {
#line 384
              sock_write_line(con->sock, "[%s] %s", logtime, buf);
              }
              {
#line 385
              sock_write(con->sock, "-> ");
              }
              }
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 390
  if (info.consoledebuglevel >= level) {
    {
    {
#line 391
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[%s] %s\n",
            logtime, buf);
    }
    }
  }
#line 394
  if (logtime) {
    {
    {
#line 395
    free((void *)logtime);
    }
    }
  }
  {
  {
#line 396
  __builtin_va_end(ap);
  }
  }
#line 397
  return;
}
}
#line 399 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void stats_write_html(server_info_t *info___0 ) 
{ 
  int fd ;
  int outfd ;
  char *template_file ;
  char *tmp ;
  char *logfilename ;
  char *tmp___0 ;
  char timebuf[8192] ;
  statistics_t stat___0 ;
  avl_tree *variables ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  unsigned long tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;

  {
  {
  {
#line 403
  tmp = get_template("statistics.html");
  }
#line 403
  template_file = tmp;
  {
#line 404
  tmp___0 = get_log_file((char const   *)info___0->statshtmlfilename);
  }
#line 404
  logfilename = tmp___0;
  }
#line 409
  if (! template_file) {
#line 409
    goto _L;
  } else {
    {
    {
#line 409
    fd = open_for_reading((char const   *)template_file);
    }
    }
#line 409
    if (fd == -1) {
      _L: /* CIL Label */ 
      {
      {
#line 411
      xa_debug(1, (char *)"DEBUG: stats_write_html(): Couldn\'t open template file");
      }
      {
#line 412
      n_free((void *)template_file, (int const   )412, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
      }
#line 412
      template_file = (char *)((void *)0);
      {
#line 413
      n_free((void *)logfilename, (int const   )413, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
      }
#line 413
      logfilename = (char *)((void *)0);
      }
#line 414
      return;
    }
  }
  {
  {
#line 417
  fd_close(fd);
  }
  {
#line 419
  outfd = open_for_writing((char const   *)logfilename);
  }
  }
#line 421
  if (outfd < 0) {
    {
    {
#line 423
    xa_debug(1, (char *)"WARNING: Could not create logfile for html statistics");
    }
    {
#line 424
    n_free((void *)template_file, (int const   )424, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
    }
#line 424
    template_file = (char *)((void *)0);
    {
#line 425
    n_free((void *)logfilename, (int const   )425, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
    }
#line 425
    logfilename = (char *)((void *)0);
    }
#line 426
    return;
  }
  {
  {
#line 430
  get_running_stats(& stat___0);
  }
  {
#line 431
  variables = avl_create(& compare_vars, (void *)(& info___0));
  }
  {
#line 433
  tmp___1 = ice_utoa(stat___0.read_bytes);
  }
  {
#line 433
  tmp___2 = n_strdup("TOTAL_READ", (int const   )433, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 433
  add_varpair2(variables, tmp___2, tmp___1);
  }
  {
#line 434
  tmp___3 = ice_utoa(stat___0.write_bytes);
  }
  {
#line 434
  tmp___4 = n_strdup("TOTAL_WRITTEN", (int const   )434, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 434
  add_varpair2(variables, tmp___4, tmp___3);
  }
  {
#line 435
  tmp___5 = ice_utoa(stat___0.source_connections);
  }
  {
#line 435
  tmp___6 = n_strdup("SOURCE_CONNECTIONS", (int const   )435, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 435
  add_varpair2(variables, tmp___6, tmp___5);
  }
  {
#line 436
  tmp___7 = ice_utoa(stat___0.client_connections);
  }
  {
#line 436
  tmp___8 = n_strdup("CLIENT_CONNECTIONS", (int const   )436, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 436
  add_varpair2(variables, tmp___8, tmp___7);
  }
  {
#line 437
  tmp___9 = connect_average(stat___0.client_connect_time, stat___0.client_connections,
                            timebuf);
  }
  {
#line 437
  tmp___10 = n_strdup((char const   *)tmp___9, (int const   )437, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 437
  tmp___11 = n_strdup("AVERAGE_LISTENER_TIME", (int const   )437, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 437
  add_varpair2(variables, tmp___11, tmp___10);
  }
  {
#line 438
  tmp___12 = transfer_average(stat___0.write_megs, stat___0.client_connections);
  }
  {
#line 438
  tmp___13 = ice_utoa(tmp___12);
  }
  {
#line 438
  tmp___14 = n_strdup("AVERAGE_LISTENER_TRANSFER", (int const   )438, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 438
  add_varpair2(variables, tmp___14, tmp___13);
  }
  {
#line 439
  tmp___15 = connect_average(stat___0.source_connect_time, stat___0.source_connections,
                             timebuf);
  }
  {
#line 439
  tmp___16 = n_strdup((char const   *)tmp___15, (int const   )439, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 439
  tmp___17 = n_strdup("AVERAGE_SOURCE_TIME", (int const   )439, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 439
  add_varpair2(variables, tmp___17, tmp___16);
  }
  {
#line 440
  tmp___18 = transfer_average(stat___0.read_megs, stat___0.source_connections);
  }
  {
#line 440
  tmp___19 = ice_utoa(tmp___18);
  }
  {
#line 440
  tmp___20 = n_strdup("AVERAGE_SOURCE_TRANSFER", (int const   )440, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
  {
#line 440
  add_varpair2(variables, tmp___20, tmp___19);
  }
  {
#line 442
  xa_debug(3, (char *)"DEBUG: Parsing statistics template file %s", template_file);
  }
  {
#line 444
  write_template_parsed_html_page((connection_t *)((void *)0), (connection_t *)((void *)0),
                                  (char const   *)template_file, outfd, variables);
  }
  {
#line 445
  fd_close(outfd);
  }
  {
#line 446
  n_free((void *)template_file, (int const   )446, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
#line 446
  template_file = (char *)((void *)0);
  {
#line 447
  n_free((void *)logfilename, (int const   )447, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
#line 447
  logfilename = (char *)((void *)0);
  }
#line 448
  return;
}
}
#line 450 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void stats_write(server_info_t *info___0 ) 
{ 
  time_t uptime ;
  time_t t ;
  long tmp ;
  char *logfilename ;
  char *tmp___0 ;
  statistics_t stat___0 ;
  char timebuf[8192] ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
  {
#line 453
  tmp = get_time();
  }
#line 453
  t = tmp;
  {
#line 454
  tmp___0 = get_log_file((char const   *)info___0->statsfilename);
  }
#line 454
  logfilename = tmp___0;
  }
#line 458
  if (! logfilename) {
    {
    {
#line 460
    xa_debug(1, (char *)"WARNING: Could not find a valid logfile for statistics, skipping write");
    }
    }
#line 461
    return;
  }
  {
  {
#line 464
  tmp___7 = open_for_writing((char const   *)logfilename);
  }
#line 464
  info___0->statsfile = tmp___7;
  }
#line 464
  if (tmp___7 == -1) {
#line 466
    if (info___0->statsfilename) {
#line 466
      tmp___1 = (char const   *)info___0->statsfilename;
    } else {
#line 466
      tmp___1 = "null";
    }
    {
    {
#line 466
    write_log(0, (char *)"WARNING: Could not open stats logfile %s for writing", tmp___1);
    }
    }
  } else {
    {
#line 469
    uptime = t - info___0->server_start_time;
    {
#line 470
    tmp___2 = nice_time((unsigned long )uptime, timebuf);
    }
    {
#line 470
    fd_write(info___0->statsfile, "Icecast %s server uptime: %s\n", "1.3.12", tmp___2);
    }
    }
#line 472
    if (info___0->location) {
      {
      {
#line 473
      fd_write(info___0->statsfile, "Icecast server location: %s\n", info___0->location);
      }
      }
    }
#line 475
    if (info___0->rp_email) {
      {
      {
#line 476
      fd_write(info___0->statsfile, "Resposible person: %s\n", info___0->rp_email);
      }
      }
    }
    {
    {
#line 480
    fd_write(info___0->statsfile, "Listing admins (%lu):\n", info___0->num_admins);
    }
    {
#line 481
    avl_walk(info___0->admins, & print_admin, (void *)0);
    }
    {
#line 484
    fd_write(info___0->statsfile, "Listing sources (%lu):\n", info___0->num_sources);
    }
    {
#line 485
    avl_walk(info___0->sources, & print_source_verbose, (void *)0);
    }
    {
#line 488
    fd_write(info___0->statsfile, "Listing listeners (%lu):\n", info___0->num_clients);
    }
    {
#line 489
    avl_walk(info___0->sources, & print_clients, (void *)0);
    }
    {
#line 491
    get_running_stats(& stat___0);
    }
    {
#line 493
    fd_write(info___0->statsfile, "Displaying server statistics:\n");
    }
    {
#line 494
    fd_write(info___0->statsfile, "Total Mbytes read: %lu\n", stat___0.read_bytes);
    }
    {
#line 495
    fd_write(info___0->statsfile, "Total Mbytes written: %lu\n", stat___0.write_bytes);
    }
    {
#line 496
    fd_write(info___0->statsfile, "Number of source connects: %lu\n", stat___0.source_connections);
    }
    {
#line 497
    fd_write(info___0->statsfile, "Number of client connects: %lu\n", stat___0.client_connections);
    }
    }
#line 499
    if (stat___0.client_connections > 0UL) {
      {
      {
#line 500
      tmp___3 = connect_average(stat___0.client_connect_time, stat___0.client_connections,
                                timebuf);
      }
      {
#line 500
      fd_write(info___0->statsfile, "Average listener time: %s\n", tmp___3);
      }
      {
#line 501
      tmp___4 = transfer_average(stat___0.write_bytes, stat___0.client_connections);
      }
      {
#line 501
      fd_write(info___0->statsfile, "Average listener transfer: %lu Mbytes\n", tmp___4);
      }
      }
    }
#line 503
    if (stat___0.source_connections > 0UL) {
      {
      {
#line 504
      tmp___5 = connect_average(stat___0.source_connect_time, stat___0.source_connections,
                                timebuf);
      }
      {
#line 504
      fd_write(info___0->statsfile, "Average source connect time: %s\n", tmp___5);
      }
      {
#line 506
      tmp___6 = transfer_average(stat___0.read_bytes, stat___0.source_connections);
      }
      {
#line 506
      fd_write(info___0->statsfile, "Average source transfer: %lu Mbytes\n", tmp___6);
      }
      }
    }
  }
  {
  {
#line 509
  n_free((void *)logfilename, (int const   )509, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
#line 509
  logfilename = (char *)((void *)0);
  {
#line 510
  fd_close(info___0->statsfile);
  }
  }
#line 511
  return;
}
}
#line 513 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
void open_log_files(void) 
{ 


  {
  {
  {
#line 515
  info.logfile = open_log_file(info.logfilename, info.logfile);
  }
  {
#line 516
  info.accessfile = open_log_file(info.accessfilename, info.accessfile);
  }
  {
#line 517
  info.usagefile = open_log_file(info.usagefilename, info.usagefile);
  }
  }
#line 518
  return;
}
}
#line 523 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int open_log_file(char *name , int oldfd ) 
{ 
  char *logfile ;
  int outfd ;
  char const   *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 528
  if (! name) {
#line 529
    return (-1);
  }
  {
  {
#line 531
  logfile = get_log_file((char const   *)name);
  }
  }
#line 533
  if (! logfile) {
#line 534
    return (-1);
  }
#line 536
  if (oldfd != -1) {
    {
    {
#line 537
    fd_close(oldfd);
    }
    }
  }
  {
  {
#line 539
  outfd = open_for_append((char const   *)logfile);
  }
  }
#line 541
  if (outfd == -1) {
#line 542
    if (logfile) {
#line 542
      tmp = (char const   *)logfile;
    } else {
#line 542
      tmp = "null";
    }
    {
    {
#line 542
    write_log(0, (char *)"WARNING: Could not open logfile %s for writing, damn!",
              tmp);
    }
    }
#line 543
    return (-1);
  }
  {
  {
#line 546
  xa_debug(1, (char *)"DEBUG: Using logfile %s [fd %d] for %s", logfile, outfd, name);
  }
  {
#line 548
  n_free((void *)logfile, (int const   )548, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c");
  }
#line 548
  logfile = (char *)((void *)0);
  }
#line 550
  return (outfd);
}
}
#line 553 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_write_bytes(int fd , char const   *buff , int const   len ) 
{ 
  ssize_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 556
  if (! buff) {
    {
    {
#line 557
    xa_debug(1, (char *)"ERROR: fd_write_bytes() called with NULL data");
    }
    }
#line 558
    return (-1);
  } else
#line 559
  if (len <= 0) {
    {
    {
#line 560
    xa_debug(1, (char *)"ERROR: fd_write_bytes() called with zero or negative len");
    }
    }
#line 561
    return (-1);
  }
  {
  {
#line 564
  tmp = write(fd, (void const   *)buff, (size_t )len);
  }
  }
#line 564
  return (tmp);
}
}
#line 567 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_write_line(int fd , char const   *fmt  , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 573
  __builtin_va_start(ap, fmt);
  }
  {
#line 574
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 575
  tmp = fd_write(fd, "%s\n", buff);
  }
  }
#line 575
  return (tmp);
}
}
#line 578 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_write(int fd , char const   *fmt  , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  size_t tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 584
  __builtin_va_start(ap, fmt);
  }
  {
#line 585
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 586
  __builtin_va_end(ap);
  }
  }
#line 588
  if (fd == 1) {
#line 588
    goto _L;
  } else
#line 588
  if (fd == 0) {
    _L: /* CIL Label */ 
#line 589
    if (running == 1) {
#line 589
      if (info.console_mode == 1) {
        {
        {
#line 590
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                buff);
        }
        {
#line 591
        fflush(stdout);
        }
        }
#line 592
        return (1);
      } else
#line 589
      if (info.console_mode == 0) {
        {
        {
#line 590
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                buff);
        }
        {
#line 591
        fflush(stdout);
        }
        }
#line 592
        return (1);
      } else {
        {
        {
#line 595
        tmp = ice_strlen((char const   *)(buff));
        }
        {
#line 595
        tmp___0 = write(fd, (void const   *)(buff), tmp);
        }
        }
#line 595
        return (tmp___0);
      }
    } else {
      {
      {
#line 595
      tmp = ice_strlen((char const   *)(buff));
      }
      {
#line 595
      tmp___0 = write(fd, (void const   *)(buff), tmp);
      }
      }
#line 595
      return (tmp___0);
    }
  } else {
    {
    {
#line 601
    tmp___1 = ice_strlen((char const   *)(buff));
    }
    {
#line 601
    tmp___2 = write(fd, (void const   *)(buff), tmp___1);
    }
    }
#line 601
    return (tmp___2);
  }
#line 603
  return (0);
}
}
#line 612 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_read_line(int fd , char *buff , int const   len ) 
{ 
  char c ;
  int read_bytes ;
  int pos ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 615
  c = (char )'\000';
#line 619
  if (! buff) {
    {
    {
#line 620
    xa_debug(1, (char *)"ERROR: fd_read_line () called with NULL storage pointer");
    }
    }
#line 621
    return (0);
  } else
#line 622
  if (len <= 0) {
    {
    {
#line 623
    xa_debug(1, (char *)"ERROR: fd_read_line () called with invalid length");
    }
    }
#line 624
    return (0);
  }
  {
#line 627
  pos = 0;
  {
#line 628
  read_bytes = read(fd, (void *)(& c), (size_t )1);
  }
  }
#line 630
  if (read_bytes < 0) {
    {
    {
#line 632
    tmp = __errno_location();
    }
    {
#line 632
    xa_debug(1, (char *)"DEBUG: read error on file descriptor %d [%d]", fd, *tmp);
    }
    }
#line 633
    return (0);
  }
  {
  {
#line 636
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 636
    if ((int )c != 10) {
#line 636
      if (pos < (int )len) {
#line 636
        if (! (read_bytes == 1)) {
#line 636
          goto while_break;
        }
      } else {
#line 636
        goto while_break;
      }
    } else {
#line 636
      goto while_break;
    }
#line 637
    if ((int )c != 13) {
#line 638
      tmp___0 = pos;
#line 638
      pos ++;
#line 638
      *(buff + tmp___0) = c;
    }
    {
    {
#line 639
    read_bytes = read(fd, (void *)(& c), (size_t )1);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  *(buff + pos) = (char )'\000';
#line 643
  if (pos > 0) {
#line 643
    tmp___1 = 1;
  } else
#line 643
  if ((int )c == 10) {
#line 643
    tmp___1 = 1;
  } else {
#line 643
    tmp___1 = 0;
  }
#line 643
  return (tmp___1);
}
}
#line 646 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_read_line_nb(int fd , char *buff , int const   len ) 
{ 
  char c ;
  int read_bytes ;
  int pos ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 649
  c = (char )'\000';
#line 653
  if (! buff) {
    {
    {
#line 654
    xa_debug(1, (char *)"ERROR: fd_read_line_nb () called with NULL storage pointer");
    }
    }
#line 655
    return (0);
  } else
#line 656
  if (len <= 0) {
    {
    {
#line 657
    xa_debug(1, (char *)"ERROR: fd_read_line_nb () called with invalid length");
    }
    }
#line 658
    return (0);
  }
#line 661
  pos = 0;
#line 661
  read_bytes = pos;
  {
  {
#line 663
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 665
    read_bytes = read(fd, (void *)(& c), (size_t )1);
    }
    }
#line 667
    if (read_bytes < 0) {
      {
      {
#line 668
      tmp___1 = __errno_location();
      }
      {
#line 668
      tmp___2 = is_recoverable(*tmp___1);
      }
      }
#line 668
      if (tmp___2) {
        {
        {
#line 672
        my_sleep(30000);
        }
        }
      } else {
        {
        {
#line 669
        tmp = __errno_location();
        }
        {
#line 669
        tmp___0 = strerror(*tmp);
        }
        {
#line 669
        xa_debug(1, (char *)"DEBUG: read error on file descriptor %d [%s]", fd, tmp___0);
        }
        }
#line 670
        return (0);
      }
    }
#line 677
    if (read_bytes == 0) {
#line 678
      goto while_break;
    }
#line 680
    if ((int )c != 13) {
#line 680
      if (read_bytes > 0) {
#line 681
        tmp___3 = pos;
#line 681
        pos ++;
#line 681
        *(buff + tmp___3) = c;
      }
    }
#line 663
    if (pos < (int )len) {
#line 663
      if (! ((int )c != 10)) {
#line 663
        goto while_break;
      }
    } else {
#line 663
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  *(buff + pos) = (char )'\000';
#line 687
  if (pos > 0) {
#line 687
    tmp___4 = 1;
  } else
#line 687
  if ((int )c == 10) {
#line 687
    tmp___4 = 1;
  } else {
#line 687
    tmp___4 = 0;
  }
#line 687
  return (tmp___4);
}
}
#line 690 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/log.c"
int fd_close(int fd ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 693
  if (fd < 2) {
    {
    {
#line 694
    xa_debug(1, (char *)"DEBUG: Closing fd %d", fd);
    }
    }
  } else {
    {
    {
#line 696
    xa_debug(1, (char *)"DEBUG: Closing fd %d", fd);
    }
    }
  }
#line 698
  if (fd >= 0) {
    {
    {
#line 699
    tmp = close(fd);
    }
    }
#line 699
    return (tmp);
  } else {
#line 702
    return (-1);
  }
}
}
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 248
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 30 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.h"
char *get_string_time(time_t tt , char *format ) ;
#line 64 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.c"
long get_time(void) 
{ 
  time_t tmp ;

  {
  {
  {
#line 66
  tmp = time((time_t *)((void *)0));
  }
  }
#line 66
  return (tmp);
}
}
#line 69 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.c"
char *get_log_time(void) 
{ 
  long tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 71
  tmp = get_time();
  }
  {
#line 71
  tmp___0 = get_string_time(tmp, (char *)"%d/%b/%Y:%H:%M:%S");
  }
  }
#line 71
  return (tmp___0);
}
}
#line 74 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.c"
char *get_clf_log_time(void) 
{ 
  long tmp ;
  char *tmp___0 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 76
  tmp = get_time();
  }
  {
#line 76
  tmp___0 = get_string_time(tmp, (char *)"%d/%b/%Y:%H:%M:%S %z");
  }
  }
#line 76
  return (tmp___0);
}
}
#line 79 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/logtime.c"
char *get_string_time(time_t tt , char *format ) 
{ 
  char *buff ;
  void *tmp ;
  struct tm mt ;
  struct tm *pmt ;
  size_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 84
  tmp = malloc((size_t )40);
  }
#line 84
  buff = (char *)tmp;
  {
#line 85
  memset((void *)buff, 0, (size_t )40);
  }
  {
#line 91
  pmt = localtime_r((time_t const   */* __restrict  */)(& tt), (struct tm */* __restrict  */)(& mt));
  }
  }
#line 91
  if (pmt) {
    {
    {
#line 94
    tmp___0 = strftime((char */* __restrict  */)buff, (size_t )40, (char const   */* __restrict  */)format,
                       (struct tm  const  */* __restrict  */)pmt);
    }
    }
#line 94
    if (tmp___0 == 0U) {
      {
      {
#line 95
      strcpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"error");
      }
      }
    }
  } else {
    {
    {
#line 92
    strcpy((char */* __restrict  */)buff, (char const   */* __restrict  */)"error");
    }
    }
  }
#line 109
  return (buff);
}
}
#line 6 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.h"
int compare_mounts(void const   *first , void const   *second , void *param ) ;
#line 7
int compare_restricts(void const   *first , void const   *second , void *param ) ;
#line 9
int compare_strings(void const   *first , void const   *second , void *param ) ;
#line 11
int compare_aliases(void const   *first , void const   *second , void *param ) ;
#line 12
int compare_threads(void const   *first , void const   *second , void *param ) ;
#line 13
int compare_mutexes(void const   *first , void const   *second , void *param ) ;
#line 14
int compare_directories(void const   *first , void const   *second , void *param ) ;
#line 15
int compare_relays(void const   *first , void const   *second , void *param ) ;
#line 19
int compare_sockets(void const   *first , void const   *second , void *param ) ;
#line 65 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_groups(void const   *first , void const   *second , void *param ) 
{ 
  group_t *v1 ;
  group_t *v2 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 68
  v1 = (group_t *)first;
#line 68
  v2 = (group_t *)second;
#line 70
  if (! first) {
    {
    {
#line 72
    xa_debug(2, (char *)"WARNING: compare_groups called with NULL pointers!");
    }
    }
#line 73
    return (0);
  } else
#line 70
  if (! second) {
    {
    {
#line 72
    xa_debug(2, (char *)"WARNING: compare_groups called with NULL pointers!");
    }
    }
#line 73
    return (0);
  } else
#line 70
  if (! v1->name) {
    {
    {
#line 72
    xa_debug(2, (char *)"WARNING: compare_groups called with NULL pointers!");
    }
    }
#line 73
    return (0);
  } else
#line 70
  if (! v2->name) {
    {
    {
#line 72
    xa_debug(2, (char *)"WARNING: compare_groups called with NULL pointers!");
    }
    }
#line 73
    return (0);
  }
  {
  {
#line 76
  tmp = ice_strcmp((char const   *)v1->name, (char const   *)v2->name);
  }
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_users(void const   *first , void const   *second , void *param ) 
{ 
  ice_user_t *v1 ;
  ice_user_t *v2 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 82
  v1 = (ice_user_t *)first;
#line 82
  v2 = (ice_user_t *)second;
#line 84
  if (! first) {
    {
    {
#line 86
    xa_debug(2, (char *)"WARNING: compare_users called with NULL pointers!");
    }
    }
#line 87
    return (0);
  } else
#line 84
  if (! second) {
    {
    {
#line 86
    xa_debug(2, (char *)"WARNING: compare_users called with NULL pointers!");
    }
    }
#line 87
    return (0);
  } else
#line 84
  if (! v1->name) {
    {
    {
#line 86
    xa_debug(2, (char *)"WARNING: compare_users called with NULL pointers!");
    }
    }
#line 87
    return (0);
  } else
#line 84
  if (! v2->name) {
    {
    {
#line 86
    xa_debug(2, (char *)"WARNING: compare_users called with NULL pointers!");
    }
    }
#line 87
    return (0);
  }
  {
  {
#line 90
  tmp = ice_strcmp((char const   *)v1->name, (char const   *)v2->name);
  }
  }
#line 90
  return (tmp);
}
}
#line 93 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_mounts(void const   *first , void const   *second , void *param ) 
{ 
  mount_t *v1 ;
  mount_t *v2 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 96
  v1 = (mount_t *)first;
#line 96
  v2 = (mount_t *)second;
#line 98
  if (! first) {
    {
    {
#line 100
    xa_debug(2, (char *)"WARNING: compare_mounts called with NULL pointers!");
    }
    }
#line 101
    return (0);
  } else
#line 98
  if (! second) {
    {
    {
#line 100
    xa_debug(2, (char *)"WARNING: compare_mounts called with NULL pointers!");
    }
    }
#line 101
    return (0);
  } else
#line 98
  if (! v1->name) {
    {
    {
#line 100
    xa_debug(2, (char *)"WARNING: compare_mounts called with NULL pointers!");
    }
    }
#line 101
    return (0);
  } else
#line 98
  if (! v2->name) {
    {
    {
#line 100
    xa_debug(2, (char *)"WARNING: compare_mounts called with NULL pointers!");
    }
    }
#line 101
    return (0);
  }
  {
  {
#line 104
  tmp = ice_strcmp((char const   *)v1->name, (char const   *)v2->name);
  }
  }
#line 104
  return (tmp);
}
}
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_vars(void const   *first , void const   *second , void *param ) 
{ 
  varpair_t *v1 ;
  varpair_t *v2 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 110
  v1 = (varpair_t *)first;
#line 110
  v2 = (varpair_t *)second;
#line 112
  if (! first) {
    {
    {
#line 114
    xa_debug(2, (char *)"WARNING: compare_vars called with NULL pointers!");
    }
    }
#line 115
    return (0);
  } else
#line 112
  if (! second) {
    {
    {
#line 114
    xa_debug(2, (char *)"WARNING: compare_vars called with NULL pointers!");
    }
    }
#line 115
    return (0);
  } else
#line 112
  if (! v1->name) {
    {
    {
#line 114
    xa_debug(2, (char *)"WARNING: compare_vars called with NULL pointers!");
    }
    }
#line 115
    return (0);
  } else
#line 112
  if (! v2->name) {
    {
    {
#line 114
    xa_debug(2, (char *)"WARNING: compare_vars called with NULL pointers!");
    }
    }
#line 115
    return (0);
  }
  {
  {
#line 118
  tmp = ice_strcmp((char const   *)v1->name, (char const   *)v2->name);
  }
  }
#line 118
  return (tmp);
}
}
#line 141 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_relay_ids(void const   *first , void const   *second , void *param ) 
{ 
  relay_id_t *r1 ;
  relay_id_t *r2 ;
  int tmp ;

  {
  {
#line 144
  r1 = (relay_id_t *)first;
#line 144
  r2 = (relay_id_t *)second;
  {
#line 146
  tmp = compare_strings((void const   *)r1->host, (void const   *)r2->host, param);
  }
  }
#line 146
  return (tmp);
}
}
#line 149 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_relays(void const   *first , void const   *second , void *param ) 
{ 
  relay_t *r1 ;
  relay_t *r2 ;
  char cfirst[8192] ;
  char csecond[8192] ;
  int tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 152
  r1 = (relay_t *)first;
#line 152
  r2 = (relay_t *)second;
#line 155
  if (! r1) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  } else
#line 155
  if (! (r1->req.host)) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  } else
#line 155
  if (! (r1->req.path)) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  } else
#line 155
  if (! r2) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  } else
#line 155
  if (! (r2->req.host)) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  } else
#line 155
  if (! (r2->req.path)) {
    {
    {
#line 156
    write_log(0, (char *)"WARNING: compare_relays() called with NULL pointers!");
    }
    }
  }
  {
  {
#line 159
  snprintf((char */* __restrict  */)(cfirst), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           r1->req.host, r1->req.port, r1->req.path);
  }
  {
#line 160
  snprintf((char */* __restrict  */)(csecond), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           r2->req.host, r2->req.port, r2->req.path);
  }
  {
#line 161
  tmp = ice_strcmp((char const   *)(cfirst), (char const   *)(csecond));
  }
  }
#line 161
  return (tmp);
}
}
#line 164 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_strings(void const   *first , void const   *second , void *param ) 
{ 
  char *a1 ;
  char *a2 ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 167
  a1 = (char *)first;
#line 167
  a2 = (char *)second;
#line 169
  if (! first) {
    {
    {
#line 171
    write_log(0, (char *)"WARNING: compare_strings called with null pointers");
    }
    }
#line 172
    return (0);
  } else
#line 169
  if (! second) {
    {
    {
#line 171
    write_log(0, (char *)"WARNING: compare_strings called with null pointers");
    }
    }
#line 172
    return (0);
  }
  {
  {
#line 175
  xa_debug(4, (char *)"DEBUG: Comparing [%s] with [%s]", a1, a2);
  }
  {
#line 176
  tmp = ice_strcasecmp((char const   *)a1, (char const   *)a2);
  }
  }
#line 176
  return (tmp);
}
}
#line 179 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_aliases(void const   *first , void const   *second , void *param ) 
{ 
  alias_t *a1 ;
  alias_t *a2 ;
  char full[8192] ;
  char full2[8192] ;
  int tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 182
  a1 = (alias_t *)first;
#line 182
  a2 = (alias_t *)second;
#line 185
  if (! a1) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! a2) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! a1->name) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! a2->name) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! ((a1->name)->host)) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! ((a1->name)->path)) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! ((a2->name)->host)) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  } else
#line 185
  if (! ((a2->name)->path)) {
    {
    {
#line 187
    write_log(0, (char *)"WARNING: NULL pointers in comparison");
    }
    }
#line 188
    return (-1);
  }
  {
  {
#line 191
  snprintf((char */* __restrict  */)(full), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           (a1->name)->host, (a1->name)->port, (a1->name)->path);
  }
  {
#line 192
  snprintf((char */* __restrict  */)(full2), (size_t )8192, (char const   */* __restrict  */)"%s:%d%s",
           (a2->name)->host, (a2->name)->port, (a2->name)->path);
  }
  {
#line 194
  tmp = ice_strcmp((char const   *)(full), (char const   *)(full2));
  }
  }
#line 194
  return (tmp);
}
}
#line 197 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_restricts(void const   *first , void const   *second , void *param ) 
{ 
  restrict_t *t1 ;
  restrict_t *t2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 200
  t1 = (restrict_t *)first;
#line 200
  t2 = (restrict_t *)second;
#line 202
  if (! first) {
    {
    {
#line 204
    write_log(0, (char *)"WARNING: compare_restricts called with NULL pointers");
    }
    }
#line 205
    return (0);
  } else
#line 202
  if (! second) {
    {
    {
#line 204
    write_log(0, (char *)"WARNING: compare_restricts called with NULL pointers");
    }
    }
#line 205
    return (0);
  }
#line 208
  if (t1->id > t2->id) {
#line 209
    return (1);
  }
#line 210
  if (t1->id < t2->id) {
#line 211
    return (-1);
  }
#line 212
  return (0);
}
}
#line 215 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_threads(void const   *first , void const   *second , void *param ) 
{ 
  mythread_t *t1 ;
  mythread_t *t2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 219
  t1 = (mythread_t *)first;
#line 220
  t2 = (mythread_t *)second;
#line 222
  if (! first) {
    {
    {
#line 224
    write_log(0, (char *)"WARNING: compare_threads called with NULL pointers");
    }
    }
#line 225
    return (0);
  } else
#line 222
  if (! second) {
    {
    {
#line 224
    write_log(0, (char *)"WARNING: compare_threads called with NULL pointers");
    }
    }
#line 225
    return (0);
  }
#line 228
  if (t1->id > t2->id) {
#line 229
    return (1);
  }
#line 230
  if (t1->id < t2->id) {
#line 231
    return (-1);
  }
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_mutexes(void const   *first , void const   *second , void *param ) 
{ 
  mutex_t *t1 ;
  mutex_t *t2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 239
  t1 = (mutex_t *)first;
#line 240
  t2 = (mutex_t *)second;
#line 242
  if (! first) {
    {
    {
#line 244
    write_log(0, (char *)"WARNING: compare_mutex called with NULL pointers");
    }
    }
#line 245
    return (0);
  } else
#line 242
  if (! second) {
    {
    {
#line 244
    write_log(0, (char *)"WARNING: compare_mutex called with NULL pointers");
    }
    }
#line 245
    return (0);
  }
#line 248
  if (t1->mutexid > t2->mutexid) {
#line 249
    return (1);
  }
#line 250
  if (t1->mutexid < t2->mutexid) {
#line 251
    return (-1);
  }
#line 252
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_connection(void const   *first , void const   *second , void *param ) 
{ 
  connection_t *a1 ;
  connection_t *a2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 259
  if (! first) {
    {
    {
#line 261
    write_log(0, (char *)"WARNING!!! - Null pointer connection!");
    }
    }
#line 262
    return (-1);
  } else
#line 259
  if (! second) {
    {
    {
#line 261
    write_log(0, (char *)"WARNING!!! - Null pointer connection!");
    }
    }
#line 262
    return (-1);
  }
#line 265
  a1 = (connection_t *)first;
#line 266
  a2 = (connection_t *)second;
#line 268
  if ((unsigned int )a1->type != (unsigned int )a2->type) {
    {
    {
#line 270
    write_log(0, (char *)"WARNING!!!! - Comparing different type connections");
    }
    }
#line 271
    return (-1);
  }
#line 274
  if (a1->id > a2->id) {
#line 275
    return (1);
  } else
#line 276
  if (a1->id < a2->id) {
#line 277
    return (-1);
  } else {
#line 279
    return (0);
  }
}
}
#line 282 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
void zero_trav(avl_traverser *trav ) 
{ 
  char *__cil_tmp2 ;

  {
#line 285
  if (! trav) {
    {
    {
#line 287
    write_log(0, (char *)"WARNING: zero_trav called with NULL trav");
    }
    }
#line 288
    return;
  }
#line 290
  trav->init = 0;
#line 291
  trav->nstack = 0;
#line 292
  trav->p = (avl_node const   *)((void *)0);
#line 293
  return;
}
}
#line 295 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_directories(void const   *first , void const   *second , void *param ) 
{ 
  directory_server_t *dir1 ;
  directory_server_t *dir2 ;
  char s1[8192] ;
  char s2[8192] ;
  int tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 300
  dir1 = (directory_server_t *)first;
#line 301
  dir2 = (directory_server_t *)second;
#line 303
  if (! first) {
    {
    {
#line 305
    write_log(0, (char *)"WARNING: compare_directory called with NULL pointers");
    }
    }
#line 306
    return (0);
  } else
#line 303
  if (! second) {
    {
    {
#line 305
    write_log(0, (char *)"WARNING: compare_directory called with NULL pointers");
    }
    }
#line 306
    return (0);
  }
  {
  {
#line 309
  snprintf((char */* __restrict  */)(s1), (size_t )8192, (char const   */* __restrict  */)"%s:%d",
           dir1->host, dir1->port);
  }
  {
#line 310
  snprintf((char */* __restrict  */)(s2), (size_t )8192, (char const   */* __restrict  */)"%s:%d",
           dir2->host, dir2->port);
  }
  {
#line 312
  tmp = compare_strings((void const   *)(s1), (void const   *)(s2), param);
  }
  }
#line 312
  return (tmp);
}
}
#line 315 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
int compare_sockets(void const   *first , void const   *second , void *param ) 
{ 
  ice_socket_t *is1 ;
  ice_socket_t *is2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 318
  is1 = (ice_socket_t *)first;
#line 318
  is2 = (ice_socket_t *)second;
#line 320
  if ((unsigned long )is1 == (unsigned long )((void *)0)) {
    {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: compare_sockets called with NULL values");
    }
    }
#line 322
    return (-1);
  } else
#line 320
  if ((unsigned long )is2 == (unsigned long )((void *)0)) {
    {
    {
#line 321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: compare_sockets called with NULL values");
    }
    }
#line 322
    return (-1);
  } else
#line 323
  if (is1->sock < 0) {
    {
    {
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: compare_sockets called with negative socket number");
    }
    }
#line 325
    return (-1);
  } else
#line 323
  if (is2->sock < 0) {
    {
    {
#line 324
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: compare_sockets called with negative socket number");
    }
    }
#line 325
    return (-1);
  }
#line 328
  if (is1->sock > is2->sock) {
#line 329
    return (1);
  } else
#line 330
  if (is1->sock < is2->sock) {
#line 331
    return (-1);
  }
#line 332
  return (0);
}
}
#line 358 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl_functions.c"
void *avl_get_any_node(avl_tree *tree ) 
{ 
  avl_traverser trav ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 361
  trav.init = 0;
#line 361
  trav.nstack = 0;
#line 361
  trav.p = (avl_node const   *)0;
#line 361
  trav.stack[0] = (avl_node const   *)0;
#line 361
  trav.stack[1] = (avl_node const   *)0;
#line 361
  trav.stack[2] = (avl_node const   *)0;
#line 361
  trav.stack[3] = (avl_node const   *)0;
#line 361
  trav.stack[4] = (avl_node const   *)0;
#line 361
  trav.stack[5] = (avl_node const   *)0;
#line 361
  trav.stack[6] = (avl_node const   *)0;
#line 361
  trav.stack[7] = (avl_node const   *)0;
#line 361
  trav.stack[8] = (avl_node const   *)0;
#line 361
  trav.stack[9] = (avl_node const   *)0;
#line 361
  trav.stack[10] = (avl_node const   *)0;
#line 361
  trav.stack[11] = (avl_node const   *)0;
#line 361
  trav.stack[12] = (avl_node const   *)0;
#line 361
  trav.stack[13] = (avl_node const   *)0;
#line 361
  trav.stack[14] = (avl_node const   *)0;
#line 361
  trav.stack[15] = (avl_node const   *)0;
#line 361
  trav.stack[16] = (avl_node const   *)0;
#line 361
  trav.stack[17] = (avl_node const   *)0;
#line 361
  trav.stack[18] = (avl_node const   *)0;
#line 361
  trav.stack[19] = (avl_node const   *)0;
#line 361
  trav.stack[20] = (avl_node const   *)0;
#line 361
  trav.stack[21] = (avl_node const   *)0;
#line 361
  trav.stack[22] = (avl_node const   *)0;
#line 361
  trav.stack[23] = (avl_node const   *)0;
#line 361
  trav.stack[24] = (avl_node const   *)0;
#line 361
  trav.stack[25] = (avl_node const   *)0;
#line 361
  trav.stack[26] = (avl_node const   *)0;
#line 361
  trav.stack[27] = (avl_node const   *)0;
#line 361
  trav.stack[28] = (avl_node const   *)0;
#line 361
  trav.stack[29] = (avl_node const   *)0;
#line 361
  trav.stack[30] = (avl_node const   *)0;
#line 361
  trav.stack[31] = (avl_node const   *)0;
#line 362
  if (! tree) {
    {
    {
#line 364
    write_log(0, (char *)"WARNING: avl_get_any_node called with NULL tree");
    }
    }
#line 365
    return ((void *)0);
  }
  {
  {
#line 368
  tmp = avl_count((avl_tree const   *)tree);
  }
  }
#line 368
  if (tmp <= 0) {
#line 369
    return ((void *)0);
  }
  {
  {
#line 371
  tmp___0 = avl_traverse(tree, & trav);
  }
  }
#line 371
  return (tmp___0);
}
}
#line 58 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
int parse_config_file(char *file ) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.h"
void usage(void) ;
#line 27
void parse_args(int argc , char **argv ) ;
#line 28
void parse_directory_args_only(int argc , char **argv ) ;
#line 61 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c"
void usage(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 63
  printf((char const   */* __restrict  */)"i c e c a s t - Version %s\n", "1.3.12");
  }
  {
#line 64
  printf((char const   */* __restrict  */)" ` ` ` ` ` `\n");
  }
  {
#line 65
  printf((char const   */* __restrict  */)"Usage:\n");
  }
  {
#line 66
  printf((char const   */* __restrict  */)"icecast [-P <port>] [-p password] [-l <file>] [-d <directory>] [-c <configfile>] [-b]\n");
  }
  {
#line 67
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 68
  printf((char const   */* __restrict  */)"\tOptions explained (compiled default in parenthesis):\n");
  }
  {
#line 69
  printf((char const   */* __restrict  */)"\t-c: Configuration file to use (%s)\n",
         "icecast.conf");
  }
  {
#line 70
  printf((char const   */* __restrict  */)"\t-P: port on which the server will listen for client connections (%d)\n",
         8000);
  }
  {
#line 71
  printf((char const   */* __restrict  */)"\t-p: password to validate encoders (%s)\n",
         "letmein");
  }
  {
#line 72
  printf((char const   */* __restrict  */)"\t-l: file for logging (%s)\n", "icecast.log");
  }
  {
#line 73
  printf((char const   */* __restrict  */)"\t-b: Force icecast server into the background\n");
  }
  {
#line 74
  printf((char const   */* __restrict  */)"\t-d: Use this directory as the location of the config files\n");
  }
  {
#line 75
  printf((char const   */* __restrict  */)"\n\n");
  }
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c"
void parse_directory_args_only(int argc , char **argv ) 
{ 
  int arg ;
  char *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 84
  arg = 1;
#line 86
  if (! argv) {
    {
    {
#line 87
    write_log(0, (char *)"WARNING: parse_directory_args_only() called with invalid argv");
    }
    }
#line 88
    return;
  } else
#line 86
  if (! *(argv + 0)) {
    {
    {
#line 87
    write_log(0, (char *)"WARNING: parse_directory_args_only() called with invalid argv");
    }
    }
#line 88
    return;
  }
  {
  {
#line 91
  xa_debug(1, (char *)"DEBUG: Parsing command line directory arguments");
  }
  }
  {
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 93
    if (! (arg < argc)) {
#line 93
      goto while_break;
    }
#line 94
    s = *(argv + arg);
#line 96
    if ((int )*(s + 0) == 45) {
#line 97
      if ((int )*(s + 1) == 100) {
#line 97
        if (arg >= argc - 1) {
          {
          {
#line 99
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %c requires an argument!\n",
                  (int )*(s + 1));
          }
          {
#line 100
          exit(1);
          }
          }
        }
      }
      {
#line 103
      if ((int )*(s + 1) == 100) {
#line 103
        goto case_100;
      }
#line 102
      goto switch_break;
      case_100: /* CIL Label */ 
#line 104
      arg ++;
#line 105
      if (info.etcdir) {
        {
        {
#line 106
        n_free((void *)info.etcdir, (int const   )106, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
        }
        }
      }
      {
#line 106
      info.etcdir = (char *)((void *)0);
      {
#line 107
      info.etcdir = n_strdup((char const   *)*(argv + arg), (int const   )107, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
      }
      }
#line 108
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 111
    arg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c"
void parse_args(int argc , char **argv ) 
{ 
  int arg ;
  char *s ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 121
  arg = 1;
  {
#line 123
  xa_debug(1, (char *)"DEBUG: Parsing command line arguments");
  }
  }
  {
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 125
    if (! (arg < argc)) {
#line 125
      goto while_break;
    }
#line 126
    s = *(argv + arg);
#line 128
    if ((int )*(s + 0) == 45) {
#line 129
      if ((int )*(s + 1) != 98) {
#line 129
        if ((int )*(s + 1) != 86) {
#line 129
          if ((int )*(s + 1) != 104) {
#line 129
            if (arg >= argc - 1) {
              {
              {
#line 131
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %c requires an argument!\n",
                      (int )*(s + 1));
              }
              {
#line 132
              exit(1);
              }
              }
            }
          }
        }
      }
      {
#line 135
      if ((int )*(s + 1) == 99) {
#line 135
        goto case_99;
      }
#line 142
      if ((int )*(s + 1) == 80) {
#line 142
        goto case_80;
      }
#line 146
      if ((int )*(s + 1) == 112) {
#line 146
        goto case_112;
      }
#line 152
      if ((int )*(s + 1) == 98) {
#line 152
        goto case_98;
      }
#line 155
      if ((int )*(s + 1) == 108) {
#line 155
        goto case_108;
      }
#line 161
      if ((int )*(s + 1) == 100) {
#line 161
        goto case_100;
      }
#line 164
      if ((int )*(s + 1) == 86) {
#line 164
        goto case_86;
      }
#line 168
      goto switch_default;
      case_99: /* CIL Label */ 
#line 136
      arg ++;
#line 137
      if (info.configfile) {
        {
        {
#line 138
        n_free((void *)info.configfile, (int const   )138, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
        }
        }
      }
      {
#line 138
      info.configfile = (char *)((void *)0);
      {
#line 139
      info.configfile = n_strdup((char const   *)*(argv + arg), (int const   )139,
                                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
      }
      {
#line 140
      parse_config_file(info.configfile);
      }
      }
#line 141
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 143
      arg ++;
      {
#line 144
      info.port[0] = atoi((char const   *)*(argv + arg));
      }
      }
#line 145
      goto switch_break;
      case_112: /* CIL Label */ 
#line 147
      arg ++;
#line 148
      if (info.encoder_pass) {
        {
        {
#line 149
        n_free((void *)info.encoder_pass, (int const   )149, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
        }
        }
      }
      {
#line 149
      info.encoder_pass = (char *)((void *)0);
      {
#line 150
      info.encoder_pass = n_strdup((char const   *)*(argv + arg), (int const   )150,
                                   "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
      }
      }
#line 151
      goto switch_break;
      case_98: /* CIL Label */ 
#line 153
      info.console_mode = 3;
#line 154
      goto switch_break;
      case_108: /* CIL Label */ 
#line 156
      arg ++;
#line 157
      if (info.logfilename) {
        {
        {
#line 158
        n_free((void *)info.logfilename, (int const   )158, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
        }
        }
      }
      {
#line 158
      info.logfilename = (char *)((void *)0);
      {
#line 159
      info.logfilename = n_strdup((char const   *)*(argv + arg), (int const   )159,
                                  "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commandline.c");
      }
      }
#line 160
      goto switch_break;
      case_100: /* CIL Label */ 
#line 162
      arg ++;
#line 163
      goto switch_break;
      case_86: /* CIL Label */ 
#line 165
      info.logfiledebuglevel = 8;
#line 166
      info.consoledebuglevel = 8;
#line 167
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
      {
#line 169
      usage();
      }
      {
#line 170
      exit(1);
      }
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
      {
#line 173
      usage();
      }
      {
#line 174
      exit(1);
      }
      }
    }
#line 176
    arg ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  return;
}
}
#line 312 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 204 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 101 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 51 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 70
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 116 "/usr/include/netdb.h"
extern void sethostent(int __stay_open ) ;
#line 80 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
void thread_lib_init(void) ;
#line 91
void thread_library_lock(void) ;
#line 92
void thread_library_unlock(void) ;
#line 96
void thread_wait_for_solitude(void) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/globals.h"
int running  =    0;
#line 56 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
void setup_admin_settings(void) ;
#line 57
void setup_config_file_settings(void) ;
#line 67
int parse_default_config_file(void) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.h"
void *threaded_server_proc(void *infoarg ) ;
#line 27
void setup_defaults(void) ;
#line 28
void setup_signal_traps(void) ;
#line 29
void allocate_resources(void) ;
#line 30
void startup_mode(void) ;
#line 33
void setup_listeners(void) ;
#line 34
void initialize_network(void) ;
#line 38
void sig_hup(int signo ) ;
#line 39
void sig_die(int signo ) ;
#line 40
void sig_die_hard(int signo ) ;
#line 41
void sig_child(int signo ) ;
#line 50 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void close_directory(void *data , void *param ) ;
#line 56
int server_detach(void) ;
#line 63
void kill_threads(void) ;
#line 69
void write_icecast_header(void) ;
#line 70
void print_startup_server_info(void) ;
#line 71
void sanity_check(void) ;
#line 83
void init_thread_tree(int line , char *file ) ;
#line 101
void show_runtime_configuration(void) ;
#line 103
void set_run_path(char **argv ) ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.h"
void add_icecast_console(void) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.h"
void *handle_connection(void *arg ) ;
#line 26
connection_t *get_connection(int *sock ) ;
#line 4 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.h"
void *startup_timer_thread(void *arg ) ;
#line 6
void *startup_udp_info_thread(void *arg ) ;
#line 7
void *startup_relay_connector_thread(void *arg ) ;
#line 53 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.h"
void initialize_memory_checker(void) ;
#line 23 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
void init_authentication_scheme(void) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.h"
void pool_init(void) ;
#line 25
void pool_shutdown(void) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/interpreter.h"
void interpreter_init(void) ;
#line 25
void interpreter_shutdown(void) ;
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
server_info_t info  ;
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
struct in_addr localaddr  ;
#line 131 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
int main(int argc , char **argv ) 
{ 
  char *__cil_tmp3 ;

  {
  {
  {
#line 135
  initialize_memory_checker();
  }
  {
#line 138
  set_run_path(argv);
  }
  {
#line 141
  thread_lib_init();
  }
  {
#line 144
  init_thread_tree(144, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 147
  setup_defaults();
  }
  {
#line 150
  setup_signal_traps();
  }
  {
#line 153
  allocate_resources();
  }
  {
#line 156
  parse_directory_args_only(argc, argv);
  }
  {
#line 159
  parse_default_config_file();
  }
  {
#line 162
  parse_args(argc, argv);
  }
  {
#line 165
  initialize_network();
  }
  {
#line 168
  interpreter_init();
  }
  {
#line 171
  init_authentication_scheme();
  }
  {
#line 174
  sanity_check();
  }
  {
#line 177
  startup_mode();
  }
  }
#line 180
  return (0);
}
}
#line 189 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void increase_maximum_number_of_open_files(void) 
{ 
  struct rlimit before ;
  struct rlimit after ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 195
  tmp = getrlimit((__rlimit_resource_t )7, & before);
  }
  }
#line 195
  if (tmp == 0) {
    {
    {
#line 196
    xa_debug(1, (char *)"DEBUG: Max number of open files: soft: %d hard: %d", (int )before.rlim_cur,
             (int )before.rlim_max);
    }
    }
  } else {
    {
    {
#line 199
    xa_debug(1, (char *)"WARNING: getrlimit() failed.");
    }
    }
#line 200
    return;
  }
#line 203
  after.rlim_cur = ((info.max_clients + info.max_sources) + info.max_admins) + 20UL;
#line 204
  if (before.rlim_max > after.rlim_cur) {
#line 204
    after.rlim_max = before.rlim_max;
  } else {
#line 204
    after.rlim_max = after.rlim_cur;
  }
  {
  {
#line 206
  tmp___0 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& after));
  }
  }
#line 206
  if (tmp___0 == 0) {
    {
    {
#line 208
    xa_debug(1, (char *)"DEBUG: Max number of open files raised from: soft %d hard: %d, to soft: %d hard: %d",
             before.rlim_cur, before.rlim_max, after.rlim_cur, after.rlim_max);
    }
    }
  } else {
    {
    {
#line 210
    write_log(0, (char *)"ERROR: Increasing maximum number of open files from %d:%d to: %d:%d failed, try lowering the maximum values for listeners, admins, and sources.",
              before.rlim_cur, before.rlim_max, after.rlim_cur, after.rlim_max);
    }
    {
#line 211
    write_log(0, (char *)"WARNING: The server will run out of file descriptors before the reaching specified limits!");
    }
    }
  }
#line 214
  return;
}
}
#line 217 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void initialize_network(void) 
{ 


  {
  {
  {
#line 227
  increase_maximum_number_of_open_files();
  }
  {
#line 230
  sethostent(1);
  }
  }
#line 232
  return;
}
}
#line 235 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void startup_mode(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 239
  open_log_files();
  }
  {
#line 242
  write_icecast_header();
  }
  {
#line 245
  show_runtime_configuration();
  }
#line 248
  running = 1;
  }
#line 259
  if (info.console_mode == 3) {
    {
    {
#line 261
    server_detach();
    }
#line 262
    info.detach = 1;
    }
  } else
#line 263
  if (info.console_mode == 1) {
    {
    {
#line 264
    add_icecast_console();
    }
    }
  } else
#line 263
  if (info.console_mode == 0) {
    {
    {
#line 264
    add_icecast_console();
    }
    }
  } else {
    {
    {
#line 266
    write_log(0, (char *)"Using stdout as icecast logging window");
    }
    }
  }
  {
  {
#line 270
  threaded_server_proc((void *)(& info));
  }
  }
#line 271
  return;
}
}
#line 278 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void setup_signal_traps(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 281
  xa_debug(1, (char *)"DEBUG: Activating signal handler");
  }
  {
#line 292
  signal(1, & sig_hup);
  }
  {
#line 293
  signal(2, & sig_die);
  }
  {
#line 294
  signal(15, & sig_die);
  }
  {
#line 295
  signal(17, & sig_child);
  }
  {
#line 296
  signal(13, (void (*)(int  ))1);
  }
  }
#line 298
  return;
}
}
#line 301 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void setup_defaults(void) 
{ 
  int i ;
  mode_t before ;
  mode_t after ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;

  {
  {
  {
#line 306
  xa_debug(1, (char *)"DEBUG: Setting up default values");
  }
#line 308
  info.consoledebuglevel = 0;
#line 309
  info.logfiledebuglevel = 0;
#line 313
  after = (mode_t )18;
  {
#line 314
  before = umask(after);
  }
  {
#line 315
  xa_debug(1, (char *)"DEBUG: Changed umask from %d to %d", before, after);
  }
  {
#line 320
  thread_create_mutex_c(& info.double_mutex, 320, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 321
  thread_create_mutex_c(& info.source_mutex, 321, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 322
  thread_create_mutex_c(& info.admin_mutex, 322, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 323
  thread_create_mutex_c(& info.directory_mutex, 323, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 324
  thread_create_mutex_c(& info.misc_mutex, 324, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 325
  thread_create_mutex_c(& info.alias_mutex, 325, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 326
  thread_create_mutex_c(& info.mount_mutex, 326, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 327
  thread_create_mutex_c(& info.hostname_mutex, 327, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 328
  thread_create_mutex_c(& info.resolvmutex, 328, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 329
  thread_create_mutex_c(& info.relay_mutex, 329, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 330
  thread_create_mutex_c(& info.acl_mutex, 330, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 335
  info.resolv_type = (resolv_type_t )1;
  {
#line 337
  memset((void *)(& localaddr), 0, (size_t )sizeof(localaddr));
  }
  {
#line 340
  info.main_thread = thread_self();
  }
#line 343
  info.detach = 0;
#line 346
  info.reverse_lookups = 1;
  {
#line 349
  zero_stats(& info.daily_stats);
  }
  {
#line 350
  zero_stats(& info.hourly_stats);
  }
  {
#line 351
  zero_stats(& info.total_stats);
  }
#line 354
  info.directorylasttime = (time_t )0;
#line 355
  info.udpupdatelasttime = (time_t )0;
#line 356
  info.statslasttime = (time_t )0;
  {
#line 357
  info.server_start_time = get_time();
  }
#line 358
  info.statuslasttime = (time_t )0;
#line 360
  info.mount_fallback = 1;
#line 361
  info.force_servername = 0;
#line 363
  info.throttle = 1.2;
#line 364
  info.sleep_ratio = 0.10;
#line 365
  info.throttle_on = 0;
#line 366
  info.bandwidth_usage = (double )0;
#line 368
  info.id = 0UL;
#line 370
  info.policy = 1;
#line 371
  info.allow_http_admin = 1;
#line 373
  info.port[0] = 8000;
#line 374
  i = 1;
  }
  {
  {
#line 374
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < 5)) {
#line 374
      goto while_break;
    }
#line 375
    info.port[i] = 0;
#line 374
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 378
  info.streamtitle = n_strdup("", (int const   )378, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 379
  info.streamurl = n_strdup("http://www.icecast.org/", (int const   )379, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 380
  info.streamurllock = 0;
  {
#line 381
  info.streamtitletemplate = n_strdup("%s", (int const   )381, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 382
  info.nametemplate = n_strdup("%s", (int const   )382, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 383
  info.descriptiontemplate = n_strdup("%s", (int const   )383, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 385
  info.metainterval = 4096UL;
#line 386
  info.use_meta_data = 0;
#line 389
  info.num_clients = 0UL;
#line 390
  info.max_clients = 800UL;
#line 391
  info.max_clients_per_source = 800UL;
#line 392
  info.client_timeout = 30;
  {
#line 393
  info.client_pass = n_strdup("prettyplease", (int const   )393, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 396
  info.num_sources = 0UL;
#line 397
  info.max_sources = 5UL;
  {
#line 398
  info.encoder_pass = n_strdup("letmein", (int const   )398, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 399
  info.default_sourceopts = n_strdup("istphecyocdrlumnagbUMDRWCT", (int const   )399,
                                     "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 402
  info.num_admins = 0UL;
#line 403
  info.max_admins = 5UL;
  {
#line 404
  info.remote_admin_pass = n_strdup("letmein", (int const   )404, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 407
  info.max_directories = 50UL;
#line 408
  info.touch_freq = 5;
#line 409
  info.udpupdatetime = 10;
  {
#line 412
  info.statsfilename = n_strdup("stats.log", (int const   )412, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 413
  info.statshtmlfilename = n_strdup("stats.html", (int const   )413, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 414
  info.statsfile = -1;
#line 415
  info.statstime = 120;
#line 416
  info.statustime = 120;
#line 419
  info.console_mode = 0;
#line 421
  info.myhostname = (char *)((void *)0);
  {
#line 422
  info.server_name = n_strdup("localhost", (int const   )422, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 423
  info.prompt = n_strdup("-> ", (int const   )423, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 425
  info.oper_pass = n_strdup("breakin", (int const   )425, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 427
  info.staticdir = n_strdup("static", (int const   )427, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
#line 429
  if (! info.runpath) {
    {
    {
#line 430
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: info.runpath == NULL!!\n");
    }
    }
  }
#line 432
  if ((int )*(info.staticdir + 0) != 47) {
    {
    {
#line 433
    n_free((void *)info.staticdir, (int const   )433, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 433
    info.staticdir = (char *)((void *)0);
    {
#line 434
    tmp = strlen((char const   *)info.runpath);
    }
    {
#line 434
    tmp___0 = strlen("static");
    }
    {
#line 434
    tmp___1 = n_malloc((unsigned int const   )((tmp + tmp___0) + 1U), (int const   )434,
                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 434
    info.staticdir = (char *)tmp___1;
    {
#line 435
    strcpy((char */* __restrict  */)info.staticdir, (char const   */* __restrict  */)info.runpath);
    }
    {
#line 436
    strcat((char */* __restrict  */)info.staticdir, (char const   */* __restrict  */)"static");
    }
    }
  }
  {
  {
#line 438
  info.logdir = n_strdup("logs", (int const   )438, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
#line 439
  if ((int )*(info.logdir + 0) != 47) {
    {
    {
#line 440
    n_free((void *)info.logdir, (int const   )440, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 440
    info.logdir = (char *)((void *)0);
    {
#line 441
    tmp___2 = strlen((char const   *)info.runpath);
    }
    {
#line 441
    tmp___3 = strlen("logs");
    }
    {
#line 441
    tmp___4 = n_malloc((unsigned int const   )((tmp___2 + tmp___3) + 1U), (int const   )441,
                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 441
    info.logdir = (char *)tmp___4;
    {
#line 442
    strcpy((char */* __restrict  */)info.logdir, (char const   */* __restrict  */)info.runpath);
    }
    {
#line 443
    strcat((char */* __restrict  */)info.logdir, (char const   */* __restrict  */)"logs");
    }
    }
  }
  {
  {
#line 445
  info.etcdir = n_strdup("conf", (int const   )445, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
#line 446
  if ((int )*(info.etcdir + 0) != 47) {
    {
    {
#line 447
    n_free((void *)info.etcdir, (int const   )447, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 447
    info.etcdir = (char *)((void *)0);
    {
#line 448
    tmp___5 = strlen((char const   *)info.runpath);
    }
    {
#line 448
    tmp___6 = strlen("conf");
    }
    {
#line 448
    tmp___7 = n_malloc((unsigned int const   )((tmp___5 + tmp___6) + 1U), (int const   )448,
                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 448
    info.etcdir = (char *)tmp___7;
    {
#line 449
    strcpy((char */* __restrict  */)info.etcdir, (char const   */* __restrict  */)info.runpath);
    }
    {
#line 450
    strcat((char */* __restrict  */)info.etcdir, (char const   */* __restrict  */)"conf");
    }
    }
  }
  {
  {
#line 452
  info.templatedir = n_strdup("templates", (int const   )452, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
#line 453
  if ((int )*(info.templatedir + 0) != 47) {
    {
    {
#line 454
    n_free((void *)info.templatedir, (int const   )454, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 454
    info.templatedir = (char *)((void *)0);
    {
#line 455
    tmp___8 = strlen((char const   *)info.runpath);
    }
    {
#line 455
    tmp___9 = strlen("templates");
    }
    {
#line 455
    tmp___10 = n_malloc((unsigned int const   )((tmp___8 + tmp___9) + 1U), (int const   )455,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 455
    info.templatedir = (char *)tmp___10;
    {
#line 456
    strcpy((char */* __restrict  */)info.templatedir, (char const   */* __restrict  */)info.runpath);
    }
    {
#line 457
    strcat((char */* __restrict  */)info.templatedir, (char const   */* __restrict  */)"templates");
    }
    }
  }
  {
  {
#line 460
  info.configfile = n_strdup("icecast.conf", (int const   )460, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 461
  info.userfile = n_strdup("users.aut", (int const   )461, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 462
  info.mountfile = n_strdup("mounts.aut", (int const   )462, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 463
  info.groupfile = n_strdup("groups.aut", (int const   )463, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 465
  info.accessfilename = n_strdup("access.log", (int const   )465, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 466
  info.accessfile = -1;
  {
#line 468
  info.usagefilename = n_strdup("usage.log", (int const   )468, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 469
  info.usagefile = -1;
  {
#line 471
  info.logfilename = n_strdup("icecast.log", (int const   )471, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
#line 472
  info.logfile = -1;
#line 475
  info.transparent_proxy = 0;
#line 477
  info.kick_relays = 10;
#line 478
  info.relay_reconnect_time = 90;
#line 479
  info.relay_reconnect_tries = -1;
#line 480
  info.kick_clients = 0;
  {
#line 483
  info.location = n_strdup("Tellus, Sol, Milkyway", (int const   )483, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 484
  info.rp_email = n_strdup("unset@unset.org", (int const   )484, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 485
  info.server_url = n_strdup("http://www.icecast.org", (int const   )485, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 488
  setup_config_file_settings();
  }
  {
#line 489
  setup_admin_settings();
  }
  }
#line 490
  return;
}
}
#line 495 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void allocate_resources(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 498
  xa_debug(1, (char *)"DEBUG: Allocating server resources");
  }
  {
#line 501
  info.sources = avl_create(& compare_connection, (void *)(& info));
  }
  {
#line 504
  info.admins = avl_create(& compare_connection, (void *)(& info));
  }
  {
#line 507
  info.d_servers = avl_create(& compare_directories, (void *)(& info));
  }
  {
#line 510
  info.aliases = avl_create(& compare_aliases, (void *)(& info));
  }
  {
#line 513
  info.relays = avl_create(& compare_relays, (void *)(& info));
  }
  {
#line 516
  info.my_hostnames = avl_create(& compare_strings, (void *)(& info));
  }
  {
#line 522
  info.all_acl = avl_create(& compare_restricts, (void *)(& info));
  }
  {
#line 523
  info.admin_acl = avl_create(& compare_restricts, (void *)(& info));
  }
  {
#line 524
  info.source_acl = avl_create(& compare_restricts, (void *)(& info));
  }
  {
#line 525
  info.client_acl = avl_create(& compare_restricts, (void *)(& info));
  }
  {
#line 527
  pool_init();
  }
  }
#line 531
  if (! info.sources) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.relays) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.admins) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.d_servers) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.threads) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.aliases) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  } else
#line 531
  if (! info.my_hostnames) {
    {
    {
#line 533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dammit, cannot allocate tree resources, exiting");
    }
    {
#line 534
    clean_shutdown(& info);
    }
    }
  }
#line 537
  return;
}
}
#line 547 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
static int main_shutting_down  =    0;
#line 540 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void clean_shutdown(server_info_t *info___0 ) 
{ 
  connection_t *con ;
  directory_server_t *ds ;
  int i ;
  avl_traverser trav ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 546
  trav.init = 0;
#line 546
  trav.nstack = 0;
#line 546
  trav.p = (avl_node const   *)0;
#line 546
  trav.stack[0] = (avl_node const   *)0;
#line 546
  trav.stack[1] = (avl_node const   *)0;
#line 546
  trav.stack[2] = (avl_node const   *)0;
#line 546
  trav.stack[3] = (avl_node const   *)0;
#line 546
  trav.stack[4] = (avl_node const   *)0;
#line 546
  trav.stack[5] = (avl_node const   *)0;
#line 546
  trav.stack[6] = (avl_node const   *)0;
#line 546
  trav.stack[7] = (avl_node const   *)0;
#line 546
  trav.stack[8] = (avl_node const   *)0;
#line 546
  trav.stack[9] = (avl_node const   *)0;
#line 546
  trav.stack[10] = (avl_node const   *)0;
#line 546
  trav.stack[11] = (avl_node const   *)0;
#line 546
  trav.stack[12] = (avl_node const   *)0;
#line 546
  trav.stack[13] = (avl_node const   *)0;
#line 546
  trav.stack[14] = (avl_node const   *)0;
#line 546
  trav.stack[15] = (avl_node const   *)0;
#line 546
  trav.stack[16] = (avl_node const   *)0;
#line 546
  trav.stack[17] = (avl_node const   *)0;
#line 546
  trav.stack[18] = (avl_node const   *)0;
#line 546
  trav.stack[19] = (avl_node const   *)0;
#line 546
  trav.stack[20] = (avl_node const   *)0;
#line 546
  trav.stack[21] = (avl_node const   *)0;
#line 546
  trav.stack[22] = (avl_node const   *)0;
#line 546
  trav.stack[23] = (avl_node const   *)0;
#line 546
  trav.stack[24] = (avl_node const   *)0;
#line 546
  trav.stack[25] = (avl_node const   *)0;
#line 546
  trav.stack[26] = (avl_node const   *)0;
#line 546
  trav.stack[27] = (avl_node const   *)0;
#line 546
  trav.stack[28] = (avl_node const   *)0;
#line 546
  trav.stack[29] = (avl_node const   *)0;
#line 546
  trav.stack[30] = (avl_node const   *)0;
#line 546
  trav.stack[31] = (avl_node const   *)0;
  {
#line 549
  thread_library_lock();
  }
  }
#line 550
  if (! main_shutting_down) {
#line 551
    main_shutting_down = 1;
  } else {
    {
    {
#line 553
    thread_exit_c(0L, 553, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
    }
  }
  {
  {
#line 554
  thread_library_unlock();
  }
  {
#line 557
  write_log(0, (char *)"Cleanly shutting down...");
  }
  {
#line 559
  write_log(0, (char *)"Closing all listening sockets...");
  }
#line 561
  i = 0;
  }
  {
  {
#line 561
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 561
    if (! (i < 5)) {
#line 561
      goto while_break;
    }
    {
    {
#line 563
    tmp = sock_valid((SOCKET const   )info___0->listen_sock[i]);
    }
    }
#line 563
    if (tmp) {
      {
      {
#line 564
      sock_close(info___0->listen_sock[i]);
      }
      }
    }
#line 561
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 567
  pool_shutdown();
  }
  {
#line 569
  interpreter_shutdown();
  }
  {
#line 572
  kill_threads();
  }
  {
#line 575
  sock_close_all_sockets();
  }
  {
#line 578
  thread_wait_for_solitude();
  }
  {
#line 580
  write_log(0, (char *)"Closing and removing directory servers...");
  }
  {
#line 582
  thread_mutex_lock_c(& info___0->directory_mutex, 582, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
  {
  {
#line 583
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 583
    tmp___0 = avl_get_any_node(info___0->d_servers);
    }
#line 583
    ds = (directory_server_t *)tmp___0;
    }
#line 583
    if (! ds) {
#line 583
      goto while_break___0;
    }
    {
    {
#line 584
    close_directory((void *)ds, (void *)(& info___0));
    }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 585
  thread_mutex_unlock_c(& info___0->directory_mutex, 585, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 587
  thread_mutex_lock_c(& info___0->source_mutex, 587, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 589
  write_log(0, (char *)"Removing remaining sources...");
  }
  }
  {
  {
#line 590
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 590
    tmp___1 = avl_traverse(info___0->sources, & trav);
    }
#line 590
    con = (connection_t *)tmp___1;
    }
#line 590
    if (! con) {
#line 590
      goto while_break___1;
    }
    {
    {
#line 591
    kick_connection((void *)con, (void *)"Server shutting down");
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 593
  thread_mutex_unlock_c(& info___0->source_mutex, 593, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 595
  zero_trav(& trav);
  }
  {
#line 602
  write_log(0, (char *)"Exiting..");
  }
  }
#line 603
  if (info___0->logfile != -1) {
    {
    {
#line 604
    fd_close(info___0->logfile);
    }
    }
  }
  {
  {
#line 619
  exit(0);
  }
  }
}
}
#line 625 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void *threaded_server_proc(void *infoarg ) 
{ 
  connection_t *con ;
  mythread_t *mt ;
  mythread_t *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 629
  tmp = thread_get_mythread();
  }
#line 629
  mt = tmp;
  {
#line 631
  write_log(0, (char *)"Starting main connection handler...");
  }
  {
#line 634
  setup_listeners();
  }
  {
#line 637
  print_startup_server_info();
  }
  {
#line 639
  write_log(0, (char *)"Starting Calender Thread...");
  }
  {
#line 641
  thread_create_c((char *)"Calendar Thread", & startup_timer_thread, (void *)0, 641,
                  (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 652
  write_log(0, (char *)"Starting UDP handler thread...");
  }
  {
#line 653
  thread_create_c((char *)"UDP Handler Thread", & startup_udp_info_thread, (void *)0,
                  653, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  {
#line 656
  write_log(0, (char *)"Starting relay connector thread...");
  }
  {
#line 658
  thread_create_c((char *)"Relay Connector Thread", & startup_relay_connector_thread,
                  (void *)0, 658, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
  }
  }
  {
  {
#line 660
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 660
    if (! (running == 1)) {
#line 660
      goto while_break;
    }
    {
    {
#line 663
    con = get_connection(info.listen_sock);
    }
    }
#line 665
    if (con) {
      {
      {
#line 667
      thread_create_c((char *)"Connection Handler", & handle_connection, (void *)con,
                      667, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
      }
      }
    }
#line 670
    if (mt->ping == 1) {
#line 671
      mt->ping = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 675
  clean_shutdown(& info);
  }
  }
#line 677
  return ((void *)0);
}
}
#line 692 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void sig_child(int signo ) 
{ 
  pid_t pid ;
  int stat___0 ;

  {
  {
  {
#line 698
  pid = wait((union wait *)(& stat___0));
  }
  {
#line 700
  signal(17, & sig_child);
  }
  }
#line 702
  return;
}
}
#line 705 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void sig_hup(int signo ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 708
  parse_default_config_file();
  }
  {
#line 709
  open_log_files();
  }
  {
#line 711
  write_log(0, (char *)"Caught SIGHUP, rehashed config and reopened logfiles...");
  }
  {
#line 714
  signal(1, & sig_hup);
  }
  }
#line 715
  return;
}
}
#line 718 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void sig_die(int signo ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 721
  write_log(0, (char *)"Caught signal %d, perhaps someone is at the door?", signo);
  }
#line 722
  running = 0;
  }
#line 723
  return;
}
}
#line 726 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void sig_die_hard(int signo ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 729
  printf((char const   */* __restrict  */)"Caught signal %d, shutting down!\n", signo);
  }
  {
#line 730
  exit(1);
  }
  }
}
}
#line 740 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
void setup_listeners(void) 
{ 
  int i ;
  int tmp ;
  char *res ;
  char *buf ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 745
  i = 0;
  {
  {
#line 745
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 745
    if (! (i < 5)) {
#line 745
      goto while_break;
    }
#line 746
    info.listen_sock[i] = -1;
#line 745
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  i = 0;
  {
  {
#line 749
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 749
    if (! (i < 5)) {
#line 749
      goto while_break___0;
    }
#line 751
    if (info.port[i] <= 0) {
#line 752
      info.port[i] = -1;
#line 753
      goto __Cont;
    }
    {
    {
#line 756
    info.listen_sock[i] = sock_get_server_socket((int const   )info.port[i]);
    }
    }
#line 758
    if (info.listen_sock[i] == -1) {
      {
      {
#line 760
      write_log(0, (char *)"ERROR: Could not listen to port %d. Perhaps another process is using it?",
                info.port[i]);
      }
      {
#line 761
      clean_shutdown(& info);
      }
      }
    }
    {
    {
#line 765
    sock_set_blocking(info.listen_sock[i], (int const   )1);
    }
    {
#line 767
    tmp = listen(info.listen_sock[i], 128);
    }
    }
#line 767
    if (tmp == -1) {
      {
      {
#line 769
      write_log(0, (char *)"Could not listen for clients on port %d", info.port[i]);
      }
      {
#line 770
      clean_shutdown(& info);
      }
      }
    }
    __Cont: /* CIL Label */ 
#line 749
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 774
  tmp___1 = ice_strcasecmp((char const   *)info.server_name, "dynamic");
  }
  }
#line 774
  if (tmp___1 == 0) {
    {
    {
#line 776
    info.server_name = sock_get_local_ipaddress();
    }
    {
#line 777
    write_log(0, (char *)"Dynamic server name, using the local ip [%s]", info.server_name);
    }
    }
  } else {
    {
    {
#line 779
    tmp___0 = n_malloc((unsigned int const   )20, (int const   )779, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
#line 779
    buf = (char *)tmp___0;
    {
#line 780
    res = forward((char const   *)info.server_name, buf);
    }
    }
#line 781
    if (! res) {
      {
      {
#line 782
      n_free((void *)buf, (int const   )782, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
      }
#line 782
      buf = (char *)((void *)0);
      {
#line 783
      write_log(0, (char *)"WARNING: Resolving the server name [%s] does not work!",
                info.server_name);
      }
      }
#line 784
      return;
    }
    {
    {
#line 787
    thread_mutex_lock_c(& info.hostname_mutex, 787, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
    {
#line 789
    avl_insert(info.my_hostnames, (void *)info.server_name);
    }
    {
#line 790
    avl_insert(info.my_hostnames, (void *)res);
    }
    {
#line 792
    thread_mutex_unlock_c(& info.hostname_mutex, 792, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c");
    }
    }
  }
#line 794
  return;
}
}
#line 86 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
static void *xmalloc___0(size_t size ) 
{ 
  void *vp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 90
  if (size == 0U) {
#line 91
    return ((void *)0);
  }
  {
  {
#line 92
  vp = malloc(size);
  }
  }
#line 94
  if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
    {
    {
#line 94
    __assert_fail("vp != ((void *)0)", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c",
                  94U, "xmalloc");
    }
    }
  }
#line 95
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
    {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"virtual memory exhausted\n");
    }
    {
#line 97
    exit(1);
    }
    }
  }
#line 100
  return (vp);
}
}
#line 258 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/avl.c"
static avl_node *new_node___0(void) 
{ 
  void *tmp ;

  {
  {
  {
#line 261
  tmp = xmalloc___0((size_t )sizeof(avl_node ));
  }
  }
#line 261
  return ((avl_node *)tmp);
}
}
#line 48 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void kick_not_connected(connection_t *con , char *reason ) ;
#line 49
void kick_silently(connection_t *con ) ;
#line 84
char *next_mount_point(void) ;
#line 36 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *create_malloced_ascii_host(struct in_addr *in ) ;
#line 46
void catsnprintf(char *line , size_t sz , char const   *fmt  , ...) ;
#line 31 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.h"
void build_source_con_line_with_opts(connection_t *con , char *line , int *opt , int maxlen ) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
void client_login(connection_t *con , char *expr ) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.h"
void admin_login(connection_t *con , char *expr ) ;
#line 81 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
char const   cnull[7]  = {      (char const   )'(',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )')',      (char const   )'\000'};
#line 88 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
void *handle_connection(void *arg ) 
{ 
  connection_t *con ;
  char line[8192] ;
  unsigned int tmp ;
  int res ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char pass[8192] ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char newline[8212] ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
#line 90
  con = (connection_t *)arg;
#line 91
  line[0] = (char )'\000';
#line 91
  tmp = 1U;
  {
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 91
    if (tmp >= 8192U) {
#line 91
      goto while_break;
    }
#line 91
    line[tmp] = (char)0;
#line 91
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 94
  thread_init();
  }
  }
#line 96
  if (! con) {
    {
    {
#line 97
    write_log(0, (char *)"handle_connection: got NULL connection");
    }
    {
#line 98
    thread_exit_c(0L, 98, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
    }
    }
  }
#line 101
  if (info.reverse_lookups) {
    {
    {
#line 102
    con->hostname = reverse((char const   *)con->host);
    }
    }
  }
  {
  {
#line 104
  tmp___0 = allowed_no_policy(con, (contype_t )3);
  }
  }
#line 104
  if (! tmp___0) {
    {
    {
#line 105
    write_http_code_page(con, 403, "Forbidden");
    }
    {
#line 106
    kick_not_connected(con, (char *)"Access Denied (internal acl list (generic connection))");
    }
    {
#line 107
    thread_exit_c(0L, 107, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
    }
    }
  }
  {
  {
#line 110
  sock_set_blocking(con->sock, (int const   )0);
  }
  {
#line 113
  res = sock_read_lines(con->sock, line, (int const   )8192);
  }
  }
#line 113
  if (res <= 0) {
    {
    {
#line 114
    write_log(0, (char *)"Socket error on connection %d", con->id);
    }
    {
#line 115
    kick_not_connected(con, (char *)"Socket error");
    }
    {
#line 116
    thread_exit_c(0L, 116, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
    }
    }
  }
#line 119
  if (res == 2) {
    {
    {
#line 120
    strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)"GET / HTTP/1.0\nUser-Agent:stupid-xaudio\n\n",
            (size_t )8192);
    }
    }
  }
  {
  {
#line 128
  tmp___11 = ice_strncmp((char const   *)(line), "GET", (size_t )3);
  }
  }
#line 128
  if (tmp___11 == 0) {
    {
    {
#line 129
    client_login(con, line);
    }
    }
  } else {
    {
    {
#line 130
    tmp___10 = ice_strncmp((char const   *)(line), "ADMIN", (size_t )5);
    }
    }
#line 130
    if (tmp___10 == 0) {
      {
      {
#line 131
      admin_login(con, line);
      }
      }
    } else {
      {
      {
#line 132
      tmp___9 = ice_strncmp((char const   *)(line), "SOURCE", (size_t )5);
      }
      }
#line 132
      if (tmp___9 == 0) {
        {
        {
#line 133
        source_login(con, line);
        }
        }
      } else {
        {
        {
#line 134
        tmp___8 = ice_strncmp((char const   *)(line), "PING", (size_t )4);
        }
        }
#line 134
        if (tmp___8 == 0) {
          {
          {
#line 135
          thread_rename("PING Handler Thread");
          }
#line 136
          line[1] = (char )'O';
          {
#line 137
          sock_write_line(con->sock, "%s", line);
          }
          {
#line 138
          tmp___1 = con_host(con);
          }
          {
#line 138
          xa_debug(1, (char *)"Replied to ping from [%s]", tmp___1);
          }
          {
#line 139
          kick_silently(con);
          }
          {
#line 140
          thread_exit_c(0L, 140, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
          }
          }
        } else {
          {
          {
#line 143
          tmp___6 = splitc(pass, line, (char const   )'\n');
          }
          }
#line 143
          if (tmp___6) {
#line 143
            goto _L;
          } else {
            {
            {
#line 143
            tmp___7 = strncpy((char */* __restrict  */)(pass), (char const   */* __restrict  */)(line),
                              (size_t )8192);
            }
            }
#line 143
            if (tmp___7) {
              _L: /* CIL Label */ 
              {
              {
#line 144
              tmp___3 = ice_strlen((char const   *)(pass));
              }
              }
#line 144
              if ((int )pass[tmp___3 - 1U] == 10) {
                {
                {
#line 145
                tmp___2 = ice_strlen((char const   *)(pass));
                }
#line 145
                pass[tmp___2 - 1U] = (char )'\000';
                }
              }
              {
              {
#line 146
              tmp___5 = password_match((char const   *)info.encoder_pass, (char const   *)(pass));
              }
              }
#line 146
              if (tmp___5) {
                {
                {
#line 148
                sock_write_line(con->sock, "OK2");
                }
                {
#line 149
                sock_write_line(con->sock, "icy-caps:11\r\n");
                }
                {
#line 150
                res = sock_read_lines_np(con->sock, line, (int const   )8192);
                }
                }
#line 150
                if (res <= 0) {
                  {
                  {
#line 151
                  write_log(0, (char *)"Socket error on connection %d", con->id);
                  }
                  {
#line 152
                  kick_not_connected(con, (char *)"Socket error");
                  }
                  {
#line 153
                  thread_exit_c(0L, 153, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
                  }
                  }
                }
                {
                {
#line 155
                put_source(con);
                }
#line 156
                (con->food.source)->protocol = (protocol_t )0;
#line 157
                (con->food.source)->type = (source_type_t )0;
                {
#line 158
                tmp___4 = next_mount_point();
                }
                {
#line 158
                snprintf((char */* __restrict  */)(newline), (size_t )8212, (char const   */* __restrict  */)"SOURCE %s %s\n%s",
                         pass, tmp___4, line);
                }
                {
#line 159
                source_login(con, newline);
                }
                {
#line 160
                thread_exit_c(0L, 160, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
                }
                }
              }
            }
          }
          {
          {
#line 164
          write_http_code_page(con, 306, "Grow up");
          }
          {
#line 165
          kick_not_connected(con, (char *)"Stupid headers");
          }
          }
        }
      }
    }
  }
  {
  {
#line 168
  thread_exit_c(0L, 168, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
  }
  }
#line 169
  return ((void *)0);
}
}
#line 172 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
connection_t *create_connection(void) 
{ 
  connection_t *con ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 175
  tmp = n_malloc((unsigned int const   )sizeof(connection_t ), (int const   )175,
                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
  }
#line 175
  con = (connection_t *)tmp;
#line 176
  con->type = (contype_t )3;
#line 177
  con->headervars = (vartree_t *)((void *)0);
#line 178
  con->sin = (struct sockaddr_in *)((void *)0);
#line 179
  con->hostname = (char *)((void *)0);
#line 180
  con->headervars = (vartree_t *)((void *)0);
#line 181
  con->food.source = (source_t *)((void *)0);
  }
#line 182
  return (con);
}
}
#line 185 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
connection_t *get_connection(int *sock ) 
{ 
  int sockfd ;
  socklen_t sin_len ;
  connection_t *con ;
  fd_set rfds ;
  struct timeval tv ;
  int i ;
  int maxport ;
  struct sockaddr_in *sin ;
  void *tmp ;
  int __d0 ;
  int __d1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 193
  maxport = 0;
  {
#line 194
  tmp = n_malloc((unsigned int const   )sizeof(struct sockaddr_in ), (int const   )194,
                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
  }
#line 194
  sin = (struct sockaddr_in *)tmp;
  }
#line 197
  if (! sin) {
    {
    {
#line 199
    write_log(0, (char *)"WARNING: Weird stuff in get_connection. nmalloc returned NULL sin");
    }
    }
#line 200
    return ((connection_t *)((void *)0));
  }
  {
#line 204
  sin_len = (socklen_t )sizeof(struct sockaddr_in );
  {
#line 205
  memset((void *)sin, 0, sin_len);
  }
  }
  {
  {
#line 208
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 208
    __asm__  volatile   ("cld; rep; "
                         "stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.fds_bits[0]): "memory");
#line 208
    goto while_break;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  i = 0;
  {
  {
#line 210
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 210
    if (! (i < 5)) {
#line 210
      goto while_break___0;
    }
    {
    {
#line 211
    tmp___0 = sock_valid((SOCKET const   )*(sock + i));
    }
    }
#line 211
    if (tmp___0) {
#line 212
      rfds.fds_bits[*(sock + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(sock + i) % (8 * (int )sizeof(__fd_mask ));
#line 213
      if (*(sock + i) > maxport) {
#line 214
        maxport = *(sock + i);
      }
    }
#line 210
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 217
  maxport ++;
#line 219
  tv.tv_sec = (__time_t )0;
#line 220
  tv.tv_usec = (__suseconds_t )30000;
  {
#line 222
  tmp___2 = select(maxport, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
  }
#line 222
  if (tmp___2 > 0) {
#line 223
    i = 0;
    {
    {
#line 223
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 223
      if (! (i < 5)) {
#line 223
        goto while_break___1;
      }
      {
      {
#line 224
      tmp___1 = sock_valid((SOCKET const   )*(sock + i));
      }
      }
#line 224
      if (tmp___1) {
#line 224
        if ((rfds.fds_bits[*(sock + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(sock + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 225
          goto while_break___1;
        }
      }
#line 223
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 228
    n_free((void *)sin, (int const   )228, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
    }
#line 228
    sin = (struct sockaddr_in *)((void *)0);
    }
#line 229
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 232
  sockfd = sock_accept(*(sock + i), (struct sockaddr *)sin, & sin_len);
  }
  }
#line 234
  if (sockfd >= 0) {
    {
    {
#line 235
    con = create_connection();
    }
    }
#line 236
    if (! sin) {
      {
      {
#line 238
      xa_debug(1, (char *)"ERROR: NULL sockaddr struct, wft???");
      }
      }
#line 239
      return ((connection_t *)((void *)0));
    }
    {
    {
#line 242
    con->host = create_malloced_ascii_host(& sin->sin_addr);
    }
#line 243
    con->sock = sockfd;
#line 244
    con->sin = sin;
#line 245
    con->sinlen = sin_len;
    }
#line 246
    if (con->host) {
#line 246
      tmp___3 = (char const   *)con->host;
    } else {
#line 246
      tmp___3 = "(null)";
    }
    {
    {
#line 246
    xa_debug(2, (char *)"DEBUG: Getting new connection on socket %d from host %s",
             sockfd, tmp___3);
    }
#line 247
    con->hostname = (char *)((void *)0);
#line 248
    con->headervars = (vartree_t *)((void *)0);
    {
#line 249
    con->id = new_id();
    }
    {
#line 250
    con->connect_time = get_time();
    }
    }
#line 259
    return (con);
  }
  {
  {
#line 263
  tmp___7 = __errno_location();
  }
  {
#line 263
  tmp___8 = is_recoverable(*tmp___7);
  }
  }
#line 263
  if (! tmp___8) {
    {
    {
#line 264
    tmp___4 = __errno_location();
    }
    {
#line 264
    tmp___5 = strerror(*tmp___4);
    }
    {
#line 264
    tmp___6 = __errno_location();
    }
    {
#line 264
    xa_debug(1, (char *)"WARNING: accept() failed with on socket %d, max: %d, [%d:%s]",
             *(sock + i), maxport, *tmp___6, tmp___5);
    }
    }
  }
  {
  {
#line 266
  n_free((void *)sin, (int const   )266, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c");
  }
#line 266
  sin = (struct sockaddr_in *)((void *)0);
  }
#line 267
  return ((connection_t *)((void *)0));
}
}
#line 270 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
void describe_connection(com_request_t const   *req , connection_t const   *describecon ) 
{ 
  char buf[8192] ;
  avl_traverser trav ;
  varpair_t const   *vp ;
  long tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 274
  trav.init = 0;
#line 274
  trav.nstack = 0;
#line 274
  trav.p = (avl_node const   *)0;
#line 274
  trav.stack[0] = (avl_node const   *)0;
#line 274
  trav.stack[1] = (avl_node const   *)0;
#line 274
  trav.stack[2] = (avl_node const   *)0;
#line 274
  trav.stack[3] = (avl_node const   *)0;
#line 274
  trav.stack[4] = (avl_node const   *)0;
#line 274
  trav.stack[5] = (avl_node const   *)0;
#line 274
  trav.stack[6] = (avl_node const   *)0;
#line 274
  trav.stack[7] = (avl_node const   *)0;
#line 274
  trav.stack[8] = (avl_node const   *)0;
#line 274
  trav.stack[9] = (avl_node const   *)0;
#line 274
  trav.stack[10] = (avl_node const   *)0;
#line 274
  trav.stack[11] = (avl_node const   *)0;
#line 274
  trav.stack[12] = (avl_node const   *)0;
#line 274
  trav.stack[13] = (avl_node const   *)0;
#line 274
  trav.stack[14] = (avl_node const   *)0;
#line 274
  trav.stack[15] = (avl_node const   *)0;
#line 274
  trav.stack[16] = (avl_node const   *)0;
#line 274
  trav.stack[17] = (avl_node const   *)0;
#line 274
  trav.stack[18] = (avl_node const   *)0;
#line 274
  trav.stack[19] = (avl_node const   *)0;
#line 274
  trav.stack[20] = (avl_node const   *)0;
#line 274
  trav.stack[21] = (avl_node const   *)0;
#line 274
  trav.stack[22] = (avl_node const   *)0;
#line 274
  trav.stack[23] = (avl_node const   *)0;
#line 274
  trav.stack[24] = (avl_node const   *)0;
#line 274
  trav.stack[25] = (avl_node const   *)0;
#line 274
  trav.stack[26] = (avl_node const   *)0;
#line 274
  trav.stack[27] = (avl_node const   *)0;
#line 274
  trav.stack[28] = (avl_node const   *)0;
#line 274
  trav.stack[29] = (avl_node const   *)0;
#line 274
  trav.stack[30] = (avl_node const   *)0;
#line 274
  trav.stack[31] = (avl_node const   *)0;
#line 277
  if (! req) {
    {
    {
#line 279
    xa_debug(1, (char *)"WARNING: describe_connection() called with NULL pointers");
    }
    }
#line 280
    return;
  } else
#line 277
  if (! describecon) {
    {
    {
#line 279
    xa_debug(1, (char *)"WARNING: describe_connection() called with NULL pointers");
    }
    }
#line 280
    return;
  }
  {
  {
#line 283
  admin_write_line(req, (int const   )491, "Connection info");
  }
  {
#line 285
  admin_write_line(req, (int const   )492, "Connection id: %lu", describecon->id);
  }
  {
#line 286
  admin_write_line(req, (int const   )492, "Connection socket: %d", describecon->sock);
  }
  {
#line 287
  tmp = get_time();
  }
  {
#line 287
  tmp___0 = nice_time((unsigned long )(tmp - (long )describecon->connect_time), buf);
  }
  {
#line 287
  admin_write_line(req, (int const   )492, "Connect time: %s", tmp___0);
  }
  }
#line 288
  if (describecon->hostname) {
#line 288
    tmp___1 = (char const   */* const  */)describecon->hostname;
  } else {
#line 288
    tmp___1 = (char const   */* const  */)"(null)";
  }
  {
  {
#line 288
  admin_write_line(req, (int const   )492, "Connection host and ip: %s [%s]", tmp___1,
                   describecon->host);
  }
  }
#line 290
  if (describecon->headervars) {
    {
    {
#line 292
    admin_write_line(req, (int const   )494, "Header variables:");
    }
    }
    {
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 293
      tmp___2 = avl_traverse((avl_tree *)describecon->headervars, & trav);
      }
#line 293
      vp = (varpair_t const   *)tmp___2;
      }
#line 293
      if (! vp) {
#line 293
        goto while_break;
      }
      {
      {
#line 294
      admin_write_line(req, (int const   )495, "\'%s\' = \'%s\'", vp->name, vp->value);
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 295
    admin_write_line(req, (int const   )496, "End of header variable listing");
    }
    }
  }
  {
  {
#line 298
  admin_write_line(req, (int const   )493, "End of connection info");
  }
  }
#line 299
  return;
}
}
#line 301 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
char const   *get_user_agent(connection_t *con ) 
{ 
  char const   *res ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 306
  if (! con) {
#line 307
    return (cnull);
  }
  {
  {
#line 309
  res = get_con_variable(con, "User-Agent");
  }
  }
#line 311
  if (! res) {
    {
    {
#line 312
    res = get_con_variable(con, "User-agent");
    }
    }
  }
#line 314
  if (! res) {
    {
    {
#line 315
    res = get_con_variable(con, "user-agent");
    }
    }
  }
#line 317
  if (! res) {
#line 318
    return (cnull);
  } else {
#line 320
    return (res);
  }
}
}
#line 323 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/connection.c"
void build_source_con_line_with_opts(connection_t *con , char *line , int *opt , int maxlen ) 
{ 
  char buf[8192] ;
  char *ct ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  long tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 328
  *(line + 0) = (char )'\000';
#line 329
  buf[0] = (char )'\000';
#line 332
  if (*(opt + 0)) {
    {
    {
#line 333
    catsnprintf(line, (size_t )8192, "[Id: %d] ", con->id);
    }
    }
  }
#line 334
  if (*(opt + 1)) {
    {
    {
#line 335
    catsnprintf(line, (size_t )8192, "[Sock: %d] ", con->sock);
    }
    }
  }
#line 336
  if (*(opt + 2)) {
    {
    {
#line 338
    tmp = get_string_time(con->connect_time, (char *)"%d/%b/%Y:%H:%M:%S");
    }
#line 338
    ct = tmp;
    {
#line 339
    catsnprintf(line, (size_t )8192, "[Time of connect: %s] ", ct);
    }
    }
#line 340
    if (ct) {
      {
      {
#line 341
      free((void *)ct);
      }
      }
    }
  }
#line 344
  if (*(opt + 3)) {
#line 344
    if (con->host) {
      {
      {
#line 345
      catsnprintf(line, (size_t )8192, "[IP: %s] ", con->host);
      }
      }
    }
  }
#line 346
  if (*(opt + 4)) {
#line 346
    if (con->hostname) {
      {
      {
#line 347
      catsnprintf(line, (size_t )8192, "[Host: %s] ", con->hostname);
      }
      }
    }
  }
#line 348
  if (*(opt + 6)) {
    {
    {
#line 349
    catsnprintf(line, (size_t )8192, "[State: %d] ", (con->food.source)->connected);
    }
    }
  }
#line 350
  if (*(opt + 7)) {
    {
    {
#line 351
    tmp___0 = sourcetype_to_string((con->food.source)->type);
    }
    {
#line 351
    catsnprintf(line, (size_t )8192, "[Type: %s] ", tmp___0);
    }
    }
  }
#line 352
  if (*(opt + 8)) {
    {
    {
#line 353
    tmp___1 = sourceproto_to_string((con->food.source)->protocol);
    }
    {
#line 353
    catsnprintf(line, (size_t )8192, "[Proto: %s] ", tmp___1);
    }
    }
  }
#line 354
  if (*(opt + 9)) {
    {
    {
#line 355
    catsnprintf(line, (size_t )8192, "[Clients: %d] ", (con->food.source)->num_clients);
    }
    }
  }
#line 356
  if (*(opt + 10)) {
    {
    {
#line 357
    tmp___2 = nullcheck_string((char const   *)(con->food.source)->dumpfile);
    }
    {
#line 357
    catsnprintf(line, (size_t )8192, "[Dumpfile/fd: %s/%d] ", tmp___2, (con->food.source)->dumpfd);
    }
    }
  }
#line 358
  if (*(opt + 11)) {
    {
    {
#line 359
    catsnprintf(line, (size_t )8192, "[Priority: %d] ", (con->food.source)->priority);
    }
    }
  }
#line 360
  if (*(opt + 12)) {
    {
    {
#line 361
    tmp___3 = nullcheck_string((char const   *)(con->food.source)->info.streamtitle);
    }
    {
#line 361
    catsnprintf(line, (size_t )8192, "[Song Title: %s] ", tmp___3);
    }
    }
  }
#line 362
  if (*(opt + 13)) {
    {
    {
#line 363
    tmp___4 = nullcheck_string((char const   *)(con->food.source)->info.streamurl);
    }
    {
#line 363
    catsnprintf(line, (size_t )8192, "[Song URL: %s] ", tmp___4);
    }
    }
  }
#line 364
  if (*(opt + 14)) {
    {
    {
#line 365
    tmp___5 = nullcheck_string((char const   *)(con->food.source)->info.streammsg);
    }
    {
#line 365
    catsnprintf(line, (size_t )8192, "[Stream Message: %s] ", tmp___5);
    }
    }
  }
#line 366
  if (*(opt + 15)) {
    {
    {
#line 367
    catsnprintf(line, (size_t )8192, "[Song Length: %ld bytes] ", (con->food.source)->info.streamlength);
    }
    }
  }
#line 368
  if (*(opt + 16)) {
    {
    {
#line 369
    tmp___6 = nullcheck_string((char const   *)(con->food.source)->audiocast.name);
    }
    {
#line 369
    catsnprintf(line, (size_t )8192, "[Stream Name: %s] ", tmp___6);
    }
    }
  }
#line 370
  if (*(opt + 17)) {
    {
    {
#line 371
    tmp___7 = nullcheck_string((char const   *)(con->food.source)->audiocast.genre);
    }
    {
#line 371
    catsnprintf(line, (size_t )8192, "[Stream Genre: %s] ", tmp___7);
    }
    }
  }
#line 372
  if (*(opt + 18)) {
    {
    {
#line 373
    catsnprintf(line, (size_t )8192, "[Stream Bitrate: %d] ", (con->food.source)->audiocast.bitrate);
    }
    }
  }
#line 374
  if (*(opt + 19)) {
    {
    {
#line 375
    tmp___8 = nullcheck_string((char const   *)(con->food.source)->audiocast.url);
    }
    {
#line 375
    catsnprintf(line, (size_t )8192, "[Stream URL: %s] ", tmp___8);
    }
    }
  }
#line 376
  if (*(opt + 20)) {
    {
    {
#line 377
    tmp___9 = nullcheck_string((char const   *)(con->food.source)->audiocast.mount);
    }
    {
#line 377
    catsnprintf(line, (size_t )8192, "[Mountpoint: %s] ", tmp___9);
    }
    }
  }
#line 378
  if (*(opt + 21)) {
    {
    {
#line 379
    tmp___10 = nullcheck_string((char const   *)(con->food.source)->audiocast.description);
    }
    {
#line 379
    catsnprintf(line, (size_t )8192, "[Description: %s] ", tmp___10);
    }
    }
  }
#line 380
  if (*(opt + 22)) {
    {
    {
#line 381
    catsnprintf(line, (size_t )8192, "[MBytes read: %lu] ", (con->food.source)->stats.read_megs);
    }
    }
  }
#line 382
  if (*(opt + 23)) {
    {
    {
#line 383
    catsnprintf(line, (size_t )8192, "[MBytes written: %lu] ", (con->food.source)->stats.write_megs);
    }
    }
  }
#line 384
  if (*(opt + 24)) {
    {
    {
#line 385
    catsnprintf(line, (size_t )8192, "[Client connections: %lu] ", (con->food.source)->stats.client_connections);
    }
    }
  }
#line 386
  if (*(opt + 25)) {
    {
    {
#line 387
    tmp___11 = get_time();
    }
    {
#line 387
    tmp___12 = nice_time((unsigned long )(tmp___11 - con->connect_time), buf);
    }
    {
#line 387
    catsnprintf(line, (size_t )8192, "[Connected for: %s] ", tmp___12);
    }
    }
  }
#line 388
  return;
}
}
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.h"
void pool_lock_write(void) ;
#line 29
void pool_unlock_write(void) ;
#line 30
void pool_cleaner(void) ;
#line 73 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
static mutex_t pool_mutex  =    {-3L, {{0, 0U, 0, 0, 0U, {.__list = {(struct __pthread_internal_slist *)0}}}},
    0L, 0, 0L};
#line 74 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
static avl_tree *pool  =    (avl_tree *)((void *)0);
#line 80 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
void pool_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 83
  xa_debug(1, (char *)"DEBUG: Initializing Connection Pool.");
  }
  {
#line 84
  thread_create_mutex_c(& pool_mutex, 84, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c");
  }
  {
#line 85
  pool = avl_create(& compare_connection, (void *)(& info));
  }
  }
#line 86
  return;
}
}
#line 92 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
void pool_shutdown(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 95
  xa_debug(1, (char *)"DEBUG: Closing the pool.");
  }
  {
#line 96
  pool_cleaner();
  }
  {
#line 97
  avl_destroy(pool, (void (*)(void *data , void *param ))((void *)0));
  }
  {
#line 98
  xa_debug(1, (char *)"DEBUG: Pool closed.");
  }
  }
#line 99
  return;
}
}
#line 108 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
int pool_add(connection_t *con ) 
{ 
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 111
  if (! con) {
#line 112
    return (-10);
  }
#line 114
  if (pool_mutex.thread_id == -3L) {
    {
    {
#line 115
    xa_debug(1, (char *)"WARNING: Tried to use an unitialized pool");
    }
    }
#line 116
    return (-14);
  } else
#line 114
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
    {
    {
#line 115
    xa_debug(1, (char *)"WARNING: Tried to use an unitialized pool");
    }
    }
#line 116
    return (-14);
  }
  {
  {
#line 120
  pool_lock_write();
  }
  {
#line 123
  tmp = avl_replace(pool, (void *)con);
  }
  }
#line 123
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
    {
#line 124
    xa_debug(1, (char *)"WARNING: Duplicate connections in the pool (id = %d)", con->id);
    }
    }
  }
  {
  {
#line 127
  pool_unlock_write();
  }
  }
#line 129
  return (1);
}
}
#line 138 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
connection_t *pool_get_my_clients(source_t const   *source ) 
{ 
  avl_traverser trav ;
  connection_t *clicon ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 141
  trav.init = 0;
#line 141
  trav.nstack = 0;
#line 141
  trav.p = (avl_node const   *)0;
#line 141
  trav.stack[0] = (avl_node const   *)0;
#line 141
  trav.stack[1] = (avl_node const   *)0;
#line 141
  trav.stack[2] = (avl_node const   *)0;
#line 141
  trav.stack[3] = (avl_node const   *)0;
#line 141
  trav.stack[4] = (avl_node const   *)0;
#line 141
  trav.stack[5] = (avl_node const   *)0;
#line 141
  trav.stack[6] = (avl_node const   *)0;
#line 141
  trav.stack[7] = (avl_node const   *)0;
#line 141
  trav.stack[8] = (avl_node const   *)0;
#line 141
  trav.stack[9] = (avl_node const   *)0;
#line 141
  trav.stack[10] = (avl_node const   *)0;
#line 141
  trav.stack[11] = (avl_node const   *)0;
#line 141
  trav.stack[12] = (avl_node const   *)0;
#line 141
  trav.stack[13] = (avl_node const   *)0;
#line 141
  trav.stack[14] = (avl_node const   *)0;
#line 141
  trav.stack[15] = (avl_node const   *)0;
#line 141
  trav.stack[16] = (avl_node const   *)0;
#line 141
  trav.stack[17] = (avl_node const   *)0;
#line 141
  trav.stack[18] = (avl_node const   *)0;
#line 141
  trav.stack[19] = (avl_node const   *)0;
#line 141
  trav.stack[20] = (avl_node const   *)0;
#line 141
  trav.stack[21] = (avl_node const   *)0;
#line 141
  trav.stack[22] = (avl_node const   *)0;
#line 141
  trav.stack[23] = (avl_node const   *)0;
#line 141
  trav.stack[24] = (avl_node const   *)0;
#line 141
  trav.stack[25] = (avl_node const   *)0;
#line 141
  trav.stack[26] = (avl_node const   *)0;
#line 141
  trav.stack[27] = (avl_node const   *)0;
#line 141
  trav.stack[28] = (avl_node const   *)0;
#line 141
  trav.stack[29] = (avl_node const   *)0;
#line 141
  trav.stack[30] = (avl_node const   *)0;
#line 141
  trav.stack[31] = (avl_node const   *)0;
#line 142
  clicon = (connection_t *)((void *)0);
#line 144
  if (! source) {
    {
    {
#line 145
    xa_debug(1, (char *)"WARNING: pool_get_my_clients() called with NULL source!");
    }
    }
#line 146
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 150
  pool_lock_write();
  }
  }
  {
  {
#line 153
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 153
    tmp = avl_traverse(pool, & trav);
    }
#line 153
    clicon = (connection_t *)tmp;
    }
#line 153
    if (! clicon) {
#line 153
      goto while_break;
    }
#line 154
    if ((unsigned long )(clicon->food.client)->source == (unsigned long )source) {
#line 155
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  if (clicon) {
    {
    {
#line 159
    tmp___0 = avl_delete(pool, (void const   *)clicon);
    }
    }
#line 159
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 160
      xa_debug(1, (char *)"WARNING: pool_get_my_clients(): Connection Pool Security Comprimised!");
      }
      }
    }
  }
  {
  {
#line 163
  pool_unlock_write();
  }
  }
#line 165
  return (clicon);
}
}
#line 171 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
void pool_lock_write(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 174
  if (! (pool_mutex.thread_id != -3L)) {
    {
    {
#line 174
    __assert_fail("pool_mutex.thread_id != -3", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c",
                  174U, "pool_lock_write");
    }
    }
  }
  {
  {
#line 175
  internal_lock_mutex(& pool_mutex);
  }
  }
#line 176
  return;
}
}
#line 178 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
void pool_unlock_write(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 181
  if (! (pool_mutex.thread_id != -3L)) {
    {
    {
#line 181
    __assert_fail("pool_mutex.thread_id != -3", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c",
                  181U, "pool_unlock_write");
    }
    }
  }
  {
  {
#line 182
  internal_unlock_mutex(& pool_mutex);
  }
  }
#line 183
  return;
}
}
#line 185 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
void pool_cleaner(void) 
{ 


  {
#line 189
  return;
}
}
#line 110 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.h"
char *ice_cat(char const   *first , char const   *second ) ;
#line 56
void icecast_mcheck_status(enum mcheck_status STATUS ) ;
#line 80 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
void icecast_mcheck_status(enum mcheck_status STATUS ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING MEMORY INTEGRITY COMPRIMISED!!! (Oh sheit)\n");
  }
  }
  {
#line 86
  if ((int )STATUS == 2) {
#line 86
    goto case_2;
  }
#line 89
  if ((int )STATUS == 3) {
#line 89
    goto case_3;
  }
#line 92
  if ((int )STATUS == 1) {
#line 92
    goto case_1;
  }
#line 95
  goto switch_default;
  case_2: /* CIL Label */ 
  {
  {
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MCHECK_HEAD (pointer decremented to far)\n");
  }
  }
#line 88
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 90
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MCHECK_TAIL (pointer incremented to far)\n");
  }
  }
#line 91
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 93
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"MCHECK_FREE (block already free)\n");
  }
  }
#line 94
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 96
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown mcheck status\n");
  }
  }
#line 97
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 129 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
void *n_malloc(unsigned int const   size , int const   lineno , char const   *file ) 
{ 
  void *buf ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 134
  if (size <= 0U) {
    {
    {
#line 136
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: n_malloc called with negative or zero size\n");
    }
    }
#line 137
    return ((void *)0);
  }
  {
  {
#line 140
  buf = malloc((size_t )size);
  }
  }
#line 142
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OUCH, out of memory!");
    }
    {
#line 144
    clean_shutdown(& info);
    }
    }
  }
#line 147
  if (size <= 0U) {
    {
    {
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING - Tried to allocate zero or negative size");
    }
    }
#line 149
    return ((void *)0);
  }
#line 173
  return (buf);
}
}
#line 180 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
char *n_strdup(char const   *ptr , int const   lineno , char const   *file ) 
{ 
  char *buf ;
  char *__cil_tmp5 ;

  {
#line 185
  if (! ptr) {
#line 187
    ptr = "(null)";
  }
  {
  {
#line 190
  buf = strdup(ptr);
  }
  }
#line 209
  return (buf);
}
}
#line 216 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
void n_free(void *ptr , int const   lineno , char const   *file ) 
{ 


  {
#line 236
  if (ptr) {
    {
    {
#line 237
    free(ptr);
    }
    }
  }
#line 238
  return;
}
}
#line 240 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
char *ice_cat(char const   *first , char const   *second ) 
{ 
  size_t sz ;
  size_t tmp ;
  size_t tmp___0 ;
  char *res ;
  void *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 243
  tmp = ice_strlen(first);
  }
  {
#line 243
  tmp___0 = ice_strlen(second);
  }
#line 243
  sz = (tmp + tmp___0) + 1U;
  {
#line 244
  tmp___1 = n_malloc((unsigned int const   )sz, (int const   )244, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c");
  }
#line 244
  res = (char *)tmp___1;
  {
#line 245
  snprintf((char */* __restrict  */)res, sz, (char const   */* __restrict  */)"%s%s",
           first, second);
  }
  }
#line 246
  return (res);
}
}
#line 249 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
int bytes_for(int bytes ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
  {
  {
#line 252
  tmp = log((double )2);
  }
  {
#line 252
  tmp___0 = log((double )10);
  }
  }
#line 252
  return (bytes * (int )((double )8 * (tmp / tmp___0)) + 2);
}
}
#line 255 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
char *ice_itoa(int num ) 
{ 
  size_t sz ;
  int tmp ;
  char *res ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 258
  tmp = bytes_for((int )sizeof(int ));
  }
#line 258
  sz = (size_t )tmp;
  {
#line 259
  tmp___0 = n_malloc((unsigned int const   )sz, (int const   )259, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c");
  }
#line 259
  res = (char *)tmp___0;
  {
#line 260
  snprintf((char */* __restrict  */)res, sz, (char const   */* __restrict  */)"%d",
           num);
  }
  }
#line 261
  return (res);
}
}
#line 264 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
char *ice_utoa(unsigned long num ) 
{ 
  size_t sz ;
  int tmp ;
  char *res ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 267
  tmp = bytes_for((int )sizeof(unsigned long ));
  }
#line 267
  sz = (size_t )tmp;
  {
#line 268
  tmp___0 = n_malloc((unsigned int const   )sz, (int const   )268, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c");
  }
#line 268
  res = (char *)tmp___0;
  {
#line 269
  snprintf((char */* __restrict  */)res, sz, (char const   */* __restrict  */)"%lu",
           num);
  }
  }
#line 270
  return (res);
}
}
#line 273 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/memory.c"
void initialize_memory_checker(void) 
{ 


  {
#line 281
  return;
}
}
#line 81 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/interpreter.c"
void interpreter_init(void) 
{ 


  {
#line 87
  return;
}
}
#line 89 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/interpreter.c"
void interpreter_shutdown(void) 
{ 


  {
#line 95
  return;
}
}
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.h"
admin_t *create_admin(void) ;
#line 27
void *handle_admin(void *vcon ) ;
#line 28
void handle_remote_admin(connection_t *con ) ;
#line 29
void put_admin(connection_t *con ) ;
#line 30
void add_admin(void) ;
#line 31
void del_admin(void) ;
#line 33
void describe_admin(com_request_t const   *req , connection_t const   *admcon ) ;
#line 34
void write_admin_prompt(connection_t const   *con ) ;
#line 35
char const   *admin2string(admin_t *adm , char *buf ) ;
#line 38
void put_http_admin(connection_t *con ) ;
#line 43
int admin_write_string(com_request_t const   *req , int const   message_type , char const   *buff ) ;
#line 44
int http_write_string(com_request_t const   *req , int const   message_type , char const   *buff ) ;
#line 54 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
void handle_admin_command(connection_t *con , char *command , int command_len ) ;
#line 88 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
connection_t *local_admin_console  =    (connection_t *)((void *)0);
#line 96 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void admin_login(connection_t *con , char *expr ) 
{ 
  char line[8192] ;
  char command[8192] ;
  char arg[8192] ;
  int go_on ;
  int connected ;
  mythread_t *mt ;
  mythread_t *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 100
  go_on = 1;
#line 100
  connected = 1;
  {
#line 101
  tmp = thread_get_mythread();
  }
#line 101
  mt = tmp;
  {
#line 103
  thread_rename("Remote Admin Thread");
  }
  {
#line 104
  xa_debug(2, (char *)"DEBUG: admin_login: called with connection %d", con->id);
  }
  {
#line 113
  tmp___0 = allowed(con, (contype_t )2);
  }
  }
#line 113
  if (! tmp___0) {
    {
    {
#line 114
    write_http_code_page(con, 403, "Forbidden");
    }
    {
#line 115
    kick_not_connected(con, (char *)"Access Denied (internal acl list (admin connection))");
    }
    {
#line 116
    thread_exit_c(0L, 116, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
    }
    }
  }
  {
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 120
    tmp___1 = splitc(line, expr, (char const   )'\n');
    }
    }
#line 120
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 121
      strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)expr,
              (size_t )8192);
      }
#line 122
      go_on = 0;
      }
    }
    {
    {
#line 125
    tmp___2 = splitc(command, line, (char const   )' ');
    }
    }
#line 125
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      {
      {
#line 126
      strncpy((char */* __restrict  */)(command), (char const   */* __restrict  */)(line),
              (size_t )8192);
      }
#line 127
      arg[0] = (char )'\000';
      }
    } else {
      {
      {
#line 129
      strncpy((char */* __restrict  */)(arg), (char const   */* __restrict  */)(line),
              (size_t )8192);
      }
      }
    }
    {
    {
#line 132
    tmp___4 = ice_strncmp((char const   *)(command), "ADMIN", (size_t )5);
    }
    }
#line 132
    if (tmp___4 == 0) {
      {
      {
#line 133
      tmp___3 = password_match((char const   *)info.remote_admin_pass, (char const   *)(arg));
      }
      }
#line 133
      if (tmp___3) {
#line 139
        if (info.num_admins >= info.max_admins) {
          {
          {
#line 141
          sock_write_line(con->sock, "ERROR - Too many connected admins");
          }
          {
#line 142
          kick_connection((void *)con, (void *)"Too many connected admins");
          }
#line 143
          connected = 0;
          }
        } else {
          {
          {
#line 146
          write_log(0, (char *)"Accepted admin pass from connection %d. %d admins connected",
                    con->id, info.num_admins + 1UL);
          }
          }
        }
      } else {
        {
        {
#line 134
        sock_write_line(con->sock, "ERROR - Bad Password");
        }
        {
#line 135
        kick_connection((void *)con, (void *)"Invalid admin password");
        }
#line 136
        connected = 0;
        }
#line 137
        goto while_break;
      }
    }
#line 151
    if (mt->ping == 1) {
#line 152
      mt->ping = 0;
    }
#line 119
    if (go_on) {
#line 119
      if (! connected) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (connected) {
    {
    {
#line 157
    sock_write_line(con->sock, "OK");
    }
    {
#line 159
    put_admin(con);
    }
    {
#line 161
    thread_mutex_lock_c(& info.admin_mutex, 161, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
    }
    {
#line 162
    avl_insert(info.admins, (void *)con);
    }
    {
#line 163
    thread_mutex_unlock_c(& info.admin_mutex, 163, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
    }
    {
#line 164
    handle_remote_admin(con);
    }
    }
  }
  {
  {
#line 167
  thread_exit_c(0L, 167, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
  }
#line 168
  return;
}
}
#line 171 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void *handle_admin(void *vcon ) 
{ 
  char line[8192] ;
  connection_t *con ;
  mythread_t *mt ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 175
  con = (connection_t *)vcon;
#line 177
  line[0] = (char )'\000';
  {
#line 178
  (con->food.admin)->thread = thread_self();
  }
  {
#line 180
  thread_init();
  }
  {
#line 182
  mt = thread_get_mythread();
  }
  {
#line 184
  fd_write(con->sock, "-> ");
  }
  {
#line 186
  sock_set_blocking(con->sock, (int const   )1);
  }
  {
#line 187
  sock_set_no_linger(con->sock);
  }
  }
  {
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if ((con->food.admin)->alive) {
      {
      {
#line 189
      tmp___2 = thread_alive(mt);
      }
      }
#line 189
      if (! tmp___2) {
#line 189
        goto while_break;
      }
    } else {
#line 189
      goto while_break;
    }
    {
    {
#line 191
    tmp___0 = fileno(stdin);
    }
    {
#line 191
    tmp___1 = fd_read_line_nb(tmp___0, line, (int const   )8192);
    }
    }
#line 191
    if (tmp___1) {
      {
      {
#line 192
      tmp = ice_strlen((char const   *)(line));
      }
      {
#line 192
      handle_admin_command(con, line, (int )tmp);
      }
      }
    } else {
      {
      {
#line 194
      fd_write_line(con->sock, "You can run, but you can\'t hide!");
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 197
  close_connection((void *)con, (void *)(& info));
  }
  {
#line 198
  thread_exit_c(0L, 198, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
  }
#line 199
  return ((void *)0);
}
}
#line 309 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void handle_remote_admin(connection_t *con ) 
{ 
  char line[8192] ;
  unsigned int tmp ;
  mythread_t *mt ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 312
  line[0] = (char )'\000';
#line 312
  tmp = 1U;
  {
  {
#line 312
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 312
    if (tmp >= 8192U) {
#line 312
      goto while_break;
    }
#line 312
    line[tmp] = (char)0;
#line 312
    tmp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 314
  (con->food.admin)->thread = thread_self();
  }
  {
#line 316
  thread_init();
  }
  {
#line 318
  mt = thread_get_mythread();
  }
  {
#line 320
  sock_write(con->sock, "-> ");
  }
  {
#line 322
  sock_set_blocking(con->sock, (int const   )1);
  }
  }
  {
  {
#line 324
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 324
    if ((con->food.admin)->alive) {
      {
      {
#line 324
      tmp___2 = thread_alive(mt);
      }
      }
#line 324
      if (! tmp___2) {
#line 324
        goto while_break___0;
      }
    } else {
#line 324
      goto while_break___0;
    }
    {
    {
#line 325
    tmp___1 = sock_read_line_nb(con->sock, line, (int const   )8192);
    }
    }
#line 325
    if (tmp___1) {
      {
      {
#line 326
      tmp___0 = ice_strlen((char const   *)(line));
      }
      {
#line 326
      handle_admin_command(con, line, (int )tmp___0);
      }
      }
    } else {
#line 328
      goto while_break___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 331
  if ((con->food.admin)->alive) {
    {
    {
#line 332
    kick_connection((void *)con, (void *)"Admin signed off");
    }
    }
  }
  {
  {
#line 334
  close_connection((void *)con, (void *)(& info));
  }
  {
#line 335
  thread_exit_c(0L, 335, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
  }
#line 336
  return;
}
}
#line 338 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
admin_t *create_admin(void) 
{ 
  admin_t *admin ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 340
  tmp = n_malloc((unsigned int const   )sizeof(admin_t ), (int const   )340, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
#line 340
  admin = (admin_t *)tmp;
  }
#line 341
  return (admin);
}
}
#line 344 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void put_admin(connection_t *con ) 
{ 
  admin_t *adm ;
  admin_t *tmp ;

  {
  {
  {
#line 346
  tmp = create_admin();
  }
#line 346
  adm = tmp;
#line 347
  con->food.admin = adm;
#line 348
  con->type = (contype_t )2;
#line 349
  adm->commands = 0;
#line 350
  adm->oper = 0U;
#line 351
  adm->tailing = 0U;
#line 352
  adm->status = 1U;
#line 353
  adm->alive = 1U;
#line 354
  adm->scheme = (scheme_t )1;
#line 355
  adm->debuglevel = 0;
  {
#line 356
  add_admin();
  }
  }
#line 357
  return;
}
}
#line 359 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void put_http_admin(connection_t *con ) 
{ 
  admin_t *adm ;
  admin_t *tmp ;

  {
  {
  {
#line 362
  tmp = create_admin();
  }
#line 362
  adm = tmp;
#line 363
  con->food.admin = adm;
#line 364
  con->type = (contype_t )2;
#line 365
  adm->commands = 0;
#line 366
  adm->oper = 0U;
#line 367
  adm->tailing = 0U;
#line 368
  adm->status = 1U;
#line 369
  adm->alive = 1U;
#line 370
  adm->scheme = (scheme_t )0;
#line 371
  adm->debuglevel = 0;
  }
#line 372
  return;
}
}
#line 374 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void add_admin(void) 
{ 


  {
  {
  {
#line 376
  internal_lock_mutex(& info.misc_mutex);
  }
#line 377
  (info.num_admins) ++;
  {
#line 378
  internal_unlock_mutex(& info.misc_mutex);
  }
  }
#line 379
  return;
}
}
#line 381 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void del_admin(void) 
{ 


  {
  {
  {
#line 383
  internal_lock_mutex(& info.misc_mutex);
  }
#line 384
  (info.num_admins) --;
  {
#line 385
  internal_unlock_mutex(& info.misc_mutex);
  }
  }
#line 386
  return;
}
}
#line 388 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void add_icecast_console(void) 
{ 
  connection_t *con ;
  admin_t *adm ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 394
  write_log(0, (char *)"Using stdin as icecast operator console");
  }
  {
#line 395
  con = create_connection();
  }
  {
#line 396
  con->sock = fileno(stdin);
  }
  {
#line 397
  con->host = n_strdup("icecast console", (int const   )397, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
#line 398
  con->hostname = (char *)((void *)0);
  {
#line 399
  con->connect_time = get_time();
  }
  {
#line 400
  put_admin(con);
  }
#line 401
  adm = con->food.admin;
#line 402
  adm->oper = 1U;
  }
#line 404
  if (info.console_mode == 0) {
    {
    {
#line 405
    write_log(0, (char *)"Tailing file to icecast operator console");
    }
#line 406
    adm->tailing = 1U;
    }
  }
  {
  {
#line 409
  con->id = new_id();
  }
  {
#line 417
  avl_insert(info.admins, (void *)con);
  }
  {
#line 419
  write_log(0, (char *)"Starting Admin Console Thread...");
  }
  {
#line 424
  thread_create_c((char *)"Admin Console Thread", & handle_admin, (void *)con, 424,
                  (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c");
  }
#line 426
  local_admin_console = con;
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void describe_admin(com_request_t const   *req , connection_t const   *admcon ) 
{ 
  admin_t const   *admin ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 434
  if (! req) {
    {
    {
#line 436
    xa_debug(1, (char *)"WARNING: describe_admin(): called with NULL pointers");
    }
    }
#line 437
    return;
  } else
#line 434
  if (! admcon) {
    {
    {
#line 436
    xa_debug(1, (char *)"WARNING: describe_admin(): called with NULL pointers");
    }
    }
#line 437
    return;
  }
#line 440
  if ((unsigned int const   )admcon->type != 2U) {
    {
    {
#line 442
    xa_debug(1, (char *)"WARNING: describe_admin(): called with invalid type");
    }
    }
#line 443
    return;
  }
  {
  {
#line 446
  describe_connection(req, admcon);
  }
#line 448
  admin = (admin_t const   *)admcon->food.admin;
  {
#line 450
  admin_write_line(req, (int const   )488, "Misc admin info:");
  }
  }
#line 451
  if (admin->status) {
#line 451
    tmp = "yes";
  } else {
#line 451
    tmp = "no";
  }
  {
  {
#line 451
  admin_write_line(req, (int const   )489, "Display regular status information: %s",
                   tmp);
  }
  }
#line 453
  if (admin->oper) {
#line 453
    tmp___0 = "yes";
  } else {
#line 453
    tmp___0 = "no";
  }
  {
  {
#line 453
  admin_write_line(req, (int const   )489, "Icecast operator: %s", tmp___0);
  }
  }
#line 454
  if (admin->tailing) {
#line 454
    tmp___1 = "yes";
  } else {
#line 454
    tmp___1 = "no";
  }
  {
  {
#line 454
  admin_write_line(req, (int const   )489, "Tailing logfile: %s", tmp___1);
  }
  {
#line 455
  admin_write_line(req, (int const   )489, "Commands executed: %d", admin->commands);
  }
  {
#line 456
  admin_write_line(req, (int const   )489, "Debuglevel: %d", admin->debuglevel);
  }
  {
#line 457
  admin_write_line(req, (int const   )490, "End of admin info");
  }
  }
#line 458
  return;
}
}
#line 460 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
char const   *admin2string(admin_t *adm , char *buf ) 
{ 
  char const   *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 463
  if (! adm) {
    {
    {
#line 464
    tmp = nullcheck_string((char const   *)((void *)0));
    }
    }
#line 464
    return (tmp);
  } else
#line 463
  if (! buf) {
    {
    {
#line 464
    tmp = nullcheck_string((char const   *)((void *)0));
    }
    }
#line 464
    return (tmp);
  }
#line 466
  *(buf + 0) = (char )'\000';
#line 468
  if (adm->oper) {
    {
    {
#line 469
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O");
    }
    }
  }
#line 470
  if (adm->tailing) {
    {
    {
#line 471
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"T");
    }
    }
  }
#line 472
  if (adm->status) {
    {
    {
#line 473
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"S");
    }
    }
  }
#line 474
  return ((char const   *)buf);
}
}
#line 477 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void write_admin_prompt(connection_t const   *con ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 484
  sock_write((SOCKET )con->sock, "> ");
  }
  }
#line 486
  return;
}
}
#line 488 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
scheme_t admin_scheme(com_request_t *req ) 
{ 


  {
#line 491
  return (((req->con)->food.admin)->scheme);
}
}
#line 494 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
int admin_write_raw(com_request_t const   *req , char const   *fmt  , ...) 
{ 
  char buf[8192] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 500
  if (! req) {
#line 501
    return (0);
  } else
#line 500
  if (! fmt) {
#line 501
    return (0);
  }
  {
  {
#line 503
  __builtin_va_start(ap, fmt);
  }
  {
#line 505
  vsnprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 507
  tmp = sock_write((req->con)->sock, "%s", buf);
  }
  }
#line 507
  return (tmp);
}
}
#line 512 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
int admin_write(com_request_t const   *req , int const   message_type , char const   *fmt 
                , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp7 ;

  {
#line 519
  if (! req) {
#line 520
    return (0);
  } else
#line 519
  if (! fmt) {
#line 520
    return (0);
  } else
#line 519
  if (! req->con) {
#line 520
    return (0);
  } else
#line 519
  if (! (req->con)->type == 2) {
#line 520
    return (0);
  }
  {
  {
#line 522
  __builtin_va_start(ap, fmt);
  }
  {
#line 523
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 524
  __builtin_va_end(ap);
  }
  {
#line 526
  tmp = admin_write_string(req, message_type, (char const   *)(buff));
  }
  }
#line 526
  return (tmp);
}
}
#line 529 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
int admin_write_string(com_request_t const   *req , int const   message_type , char const   *buff ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 533
  if (message_type == -1) {
#line 533
    goto _L;
  } else
#line 533
  if ((unsigned int )((req->con)->food.admin)->scheme == 1U) {
    _L: /* CIL Label */ 
#line 535
    if (req->wid == -1) {
      {
      {
#line 536
      tmp = sock_write((req->con)->sock, "%s", buff);
      }
      }
#line 536
      return (tmp);
    } else {
      {
      {
#line 538
      tmp___0 = sock_write((req->con)->sock, "W%d %s", req->wid, buff);
      }
      }
#line 538
      return (tmp___0);
    }
  } else
#line 540
  if ((unsigned int )((req->con)->food.admin)->scheme == 0U) {
    {
    {
#line 541
    tmp___1 = http_write_string(req, message_type, buff);
    }
    }
#line 541
    return (tmp___1);
  } else
#line 543
  if (req->wid == -1) {
    {
    {
#line 544
    tmp___2 = sock_write((req->con)->sock, "M%d %s", message_type, buff);
    }
    }
#line 544
    return (tmp___2);
  } else {
    {
    {
#line 547
    tmp___3 = sock_write((req->con)->sock, "M%d W%d %s", message_type, req->wid, buff);
    }
    }
#line 547
    return (tmp___3);
  }
}
}
#line 552 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
int admin_write_line(com_request_t const   *req , int const   message_type , char const   *fmt 
                     , ...) 
{ 
  char buff[8192] ;
  char buff2[8200] ;
  va_list ap ;
  int tmp ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 560
  if (! req) {
#line 561
    return (0);
  } else
#line 560
  if (! fmt) {
#line 561
    return (0);
  } else
#line 560
  if (! req->con) {
#line 561
    return (0);
  } else
#line 560
  if (! (req->con)->type == 2) {
#line 561
    return (0);
  }
  {
  {
#line 563
  __builtin_va_start(ap, fmt);
  }
  {
#line 564
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
#line 565
  buff2[0] = (char )'\000';
  }
#line 566
  if ((unsigned int )((req->con)->food.admin)->scheme == 0U) {
    {
    {
#line 567
    catsnprintf(buff2, (size_t )8200, "%s<br>\r\n", buff);
    }
    }
  } else {
    {
    {
#line 569
    catsnprintf(buff2, (size_t )8200, "%s\r\n", buff);
    }
    }
  }
  {
  {
#line 570
  tmp = admin_write_string(req, message_type, (char const   *)(buff2));
  }
  }
#line 570
  return (tmp);
}
}
#line 573 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/admin.c"
void admin_die(void) 
{ 


  {
#line 576
  return;
}
}
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 331 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *safe_strcat(char *dest , char const   *src , unsigned int maxsize ) ;
#line 43
char *ice_strstr(char const   *haystack , char const   *needle ) ;
#line 22 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.h"
void list_directory(connection_t *con , char *directory ) ;
#line 23
void send_file(connection_t *con , request_t *req ) ;
#line 24
void send_file_to_socket(connection_t *con , char *filename ) ;
#line 43 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
void write_http_header(sock_t sockfd , int error , char const   *msg ) ;
#line 46
char *url_decode(char const   *intarget ) ;
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c"
void list_directory(connection_t *con , char *directory ) 
{ 
  int i ;
  dir_t *od ;
  char *filename ;
  char *tmp ;
  char fullfilename[16384] ;
  char fullpath[8192] ;
  struct stat st ;
  avl_tree *variables ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 81
  i = 0;
#line 82
  od = (dir_t *)((void *)0);
  {
#line 83
  tmp = get_template("list_directory.html");
  }
#line 83
  filename = tmp;
#line 86
  variables = (avl_tree *)((void *)0);
  }
#line 88
  if (! directory) {
    {
    {
#line 90
    write_http_code_page(con, 400, "Bad Request");
    }
    }
#line 91
    return;
  } else {
    {
    {
#line 88
    tmp___0 = ice_strlen((char const   *)directory);
    }
    }
#line 88
    if (tmp___0 < 6U) {
      {
      {
#line 90
      write_http_code_page(con, 400, "Bad Request");
      }
      }
#line 91
      return;
    }
  }
#line 94
  if (*directory) {
#line 94
    tmp___1 = '/';
  } else {
#line 94
    tmp___1 = '\000';
  }
#line 94
  if (info.staticdir) {
#line 94
    tmp___2 = (char const   *)info.staticdir;
  } else {
#line 94
    tmp___2 = "";
  }
  {
  {
#line 94
  snprintf((char */* __restrict  */)(fullpath), (size_t )8192, (char const   */* __restrict  */)"%s%c%s",
           tmp___2, tmp___1, directory + 6);
  }
  {
#line 96
  tmp___3 = con_host(con);
  }
  {
#line 96
  xa_debug(1, (char *)"DEBUG: [%s] Listing directory [%s]", tmp___3, fullpath);
  }
  {
#line 98
  od = dir_findfirst((char const   *)(fullpath));
  }
  }
#line 98
  if (! od) {
    {
    {
#line 100
    write_http_code_page(con, 404, "Not Found");
    }
    }
#line 101
    return;
  }
#line 104
  if (filename) {
    {
    {
#line 106
    xa_debug(1, (char *)"DEBUG: list_directory(): using template %s", filename);
    }
    {
#line 107
    dir_findclose(od);
    }
    {
#line 108
    variables = avl_create(& compare_vars, (void *)(& info));
    }
    {
#line 109
    tmp___4 = n_strdup((char const   *)(fullpath), (int const   )109, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c");
    }
    {
#line 109
    tmp___5 = n_strdup("LISTED_DIRECTORY", (int const   )109, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c");
    }
    {
#line 109
    add_varpair2(variables, tmp___5, tmp___4);
    }
    {
#line 110
    write_template_parsed_html_page(con, (connection_t *)((void *)0), (char const   *)filename,
                                    -1, variables);
    }
    {
#line 111
    n_free((void *)filename, (int const   )111, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c");
    }
#line 111
    filename = (char *)((void *)0);
    }
#line 112
    return;
  } else {
    {
    {
#line 115
    write_http_header(con->sock, 200, "OK");
    }
    {
#line 117
    sock_write_line(con->sock, "Connection: close");
    }
    {
#line 118
    sock_write_line(con->sock, "Content-Type: text/html\r\n");
    }
    {
#line 120
    sock_write_line(con->sock, "<html><head><title>icecast server, version %s, running on %s</title></head>",
                    "1.3.12", info.server_name);
    }
    {
#line 121
    sock_write_line(con->sock, "<body bgcolor=black text=white link=lightblue alink=lightblue vlink=lightblue>");
    }
    {
#line 123
    sock_write_line(con->sock, "<font face=\"sans-serif\" size=+2>Files in directory %s:</font><br>",
                    directory);
    }
    {
#line 125
    sock_write_line(con->sock, "<table border=0 cellspacing=0 cellpadding=3><tr><td><font face=\"sans-serif\" size=+2>Filename</font></td><td><font face=\"sans-serif\" size=+2>Filesize</font></td></tr><br>");
    }
    }
  }
  {
  {
#line 128
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 128
    tmp___8 = dir_findnext(od);
    }
    }
#line 128
    if (! tmp___8) {
#line 128
      goto while_break;
    }
    {
    {
#line 130
    snprintf((char */* __restrict  */)(fullfilename), (size_t )16384, (char const   */* __restrict  */)"%s/%s",
             fullpath, od->filename);
    }
    {
#line 131
    tmp___6 = stat((char const   */* __restrict  */)(fullfilename), (struct stat */* __restrict  */)(& st));
    }
    }
#line 131
    if (tmp___6 == 0) {
      {
      {
#line 131
      tmp___7 = wild_match((unsigned char const   *)((unsigned char *)"*.mp3"), (unsigned char const   *)((unsigned char *)od->filename));
      }
      }
#line 131
      if (tmp___7) {
#line 133
        if (i % 2) {
          {
          {
#line 133
          sock_write_line(con->sock, "<tr bgcolor=#000000>");
          }
          }
        } else {
          {
          {
#line 133
          sock_write_line(con->sock, "<tr bgcolor=#333333>");
          }
          }
        }
        {
        {
#line 134
        sock_write_line(con->sock, "<td><tt><a href=\"/playlist.pls?mount=/file/%s&file=dummy.pls\">%s</a></tt><td><tt>%d</tt></td></tr>",
                        od->filename, od->filename, st.st_size);
        }
#line 136
        i ++;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 140
  dir_findclose(od);
  }
  {
#line 142
  sock_write_line(con->sock, "</table><br>");
  }
  {
#line 144
  sock_write_line(con->sock, "Total files in directory: %d<br>", i);
  }
  {
#line 146
  sock_write_line(con->sock, "</body></html>");
  }
  }
#line 147
  return;
}
}
#line 149 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c"
void send_file(connection_t *con , request_t *req ) 
{ 
  struct stat buf ;
  int mp3file ;
  char *filename ;
  char *suffix ;
  long length ;
  char buff[8192] ;
  char *decoded ;
  char *tmp ;
  char const   *startpos ;
  int pos ;
  vartree_t *req_vars ;
  avl_tree *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
  {
#line 158
  tmp = url_decode((char const   *)(& req->path[6]));
  }
#line 158
  decoded = tmp;
  {
#line 162
  tmp___0 = avl_create(& compare_vars, (void *)(& info));
  }
#line 162
  req_vars = tmp___0;
  {
#line 163
  extract_vars(req_vars, req->path);
  }
  {
#line 164
  startpos = get_variable(req_vars, "pos");
  }
  {
#line 167
  memset((void *)(buff), 0, (size_t )8192);
  }
  {
#line 169
  filename = strncpy((char */* __restrict  */)(buff), (char const   */* __restrict  */)info.staticdir,
                     (size_t )8192);
  }
  {
#line 175
  tmp___1 = ice_strlen((char const   *)info.staticdir);
  }
  }
#line 175
  if ((int )*(info.staticdir + (tmp___1 - 1U)) != 47) {
    {
    {
#line 176
    filename = safe_strcat(buff, "/", 8192U);
    }
    }
  }
  {
  {
#line 178
  filename = safe_strcat(buff, (char const   *)decoded, 8192U);
  }
  {
#line 179
  n_free((void *)decoded, (int const   )179, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c");
  }
#line 179
  decoded = (char *)((void *)0);
  {
#line 180
  xa_debug(1, (char *)"DEBUG: Static filename: %s...", filename);
  }
  {
#line 181
  suffix = strrchr((char const   *)filename, '.');
  }
  {
#line 183
  tmp___5 = ice_strlen((char const   *)filename);
  }
  }
#line 183
  if (tmp___5 > 3U) {
#line 183
    if (suffix) {
      {
      {
#line 183
      tmp___6 = ice_strcasecmp((char const   *)suffix, ".mp3");
      }
      }
#line 183
      if (tmp___6 == 0) {
        {
        {
#line 183
        tmp___7 = ice_strstr((char const   *)filename, "/../");
        }
        }
#line 183
        if (tmp___7) {
          {
          {
#line 222
          xa_debug(1, (char *)"DEBUG: Static file [%s] invalid", filename);
          }
          {
#line 223
          write_http_code_page(con, 404, "Not found");
          }
          {
#line 224
          sock_write_line(con->sock, "Connection: close");
          }
          }
        } else {
          {
          {
#line 183
          tmp___8 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& buf));
          }
          }
#line 183
          if (tmp___8 == 0) {
            {
#line 184
            length = buf.st_size;
            {
#line 187
            mp3file = open_for_reading((char const   *)filename);
            }
            }
#line 187
            if (mp3file) {
              {
              {
#line 189
              tmp___2 = is_number(startpos);
              }
              }
#line 189
              if (tmp___2) {
                {
                {
#line 194
                pos = atoi(startpos);
                }
                {
#line 195
                xa_debug(1, (char *)"DEBUG: send_file() startpos=%d, filelen=%d",
                         pos, length);
                }
                {
#line 196
                lseek(mp3file, (__off_t )pos, 0);
                }
#line 197
                length -= (long )pos;
                }
              }
              {
              {
#line 201
              tmp___3 = con_host(con);
              }
              {
#line 201
              write_log(0, (char *)"Sending static file %s to %d [%s]", filename,
                        con->id, tmp___3);
              }
              {
#line 202
              write_http_header(con->sock, 200, "OK");
              }
              {
#line 203
              sock_write_line(con->sock, "Connection: close");
              }
              {
#line 204
              sock_write_line(con->sock, "Content-type: audio/mpeg");
              }
              {
#line 205
              sock_write_line(con->sock, "Content-length: %i\r\n", length);
              }
              }
              {
              {
#line 207
              while (1) {
                while_continue___0: /* CIL Label */ ;
                while_continue: /* CIL Label */ ;
                {
                {
#line 207
                tmp___4 = read(mp3file, (void *)(buff), (size_t )8192);
                }
#line 207
                length = (long )tmp___4;
                }
#line 207
                if (! (length > 0L)) {
#line 207
                  goto while_break;
                }
                {
                {
#line 209
                sock_write_bytes(con->sock, (char const   *)(buff), (int )length);
                }
#line 210
                info.hourly_stats.write_bytes += (unsigned long )length;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              while_break: /* CIL Label */ ;
              }
              {
              {
#line 213
              fd_close(mp3file);
              }
              }
            } else {
              {
              {
#line 216
              xa_debug(1, (char *)"DEBUG: Static file doesn\'t exist");
              }
              {
#line 218
              write_http_code_page(con, 404, "Not found");
              }
              {
#line 219
              sock_write_line(con->sock, "Connection: close");
              }
              }
            }
          } else {
            {
            {
#line 222
            xa_debug(1, (char *)"DEBUG: Static file [%s] invalid", filename);
            }
            {
#line 223
            write_http_code_page(con, 404, "Not found");
            }
            {
#line 224
            sock_write_line(con->sock, "Connection: close");
            }
            }
          }
        }
      } else {
        {
        {
#line 222
        xa_debug(1, (char *)"DEBUG: Static file [%s] invalid", filename);
        }
        {
#line 223
        write_http_code_page(con, 404, "Not found");
        }
        {
#line 224
        sock_write_line(con->sock, "Connection: close");
        }
        }
      }
    } else {
      {
      {
#line 222
      xa_debug(1, (char *)"DEBUG: Static file [%s] invalid", filename);
      }
      {
#line 223
      write_http_code_page(con, 404, "Not found");
      }
      {
#line 224
      sock_write_line(con->sock, "Connection: close");
      }
      }
    }
  } else {
    {
    {
#line 222
    xa_debug(1, (char *)"DEBUG: Static file [%s] invalid", filename);
    }
    {
#line 223
    write_http_code_page(con, 404, "Not found");
    }
    {
#line 224
    sock_write_line(con->sock, "Connection: close");
    }
    }
  }
  {
  {
#line 228
  free_variables(req_vars);
  }
  }
#line 230
  return;
}
}
#line 232 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/static.c"
void send_file_to_socket(connection_t *con , char *filename ) 
{ 
  int mp3file ;
  long length ;
  char buff[8192] ;
  char const   *tmp ;
  ssize_t tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 239
  mp3file = open_for_reading((char const   *)filename);
  }
  }
#line 239
  if (mp3file) {
    {
    {
#line 241
    tmp = con_host(con);
    }
    {
#line 241
    write_log(0, (char *)"Sending static file %s to %d [%s]", filename, con->id, tmp);
    }
    }
    {
    {
#line 243
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 243
      tmp___0 = read(mp3file, (void *)(buff), (size_t )8192);
      }
#line 243
      length = (long )tmp___0;
      }
#line 243
      if (! (length > 0L)) {
#line 243
        goto while_break;
      }
      {
      {
#line 244
      sock_write_bytes(con->sock, (char const   *)(buff), (int )length);
      }
#line 245
      info.hourly_stats.write_bytes += (unsigned long )length;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 248
    fd_close(mp3file);
    }
    }
  } else {
    {
    {
#line 251
    xa_debug(1, (char *)"DEBUG: Static file doesn\'t exist");
    }
    {
#line 253
    write_http_code_page(con, 404, "Not found");
    }
    {
#line 254
    sock_write_line(con->sock, "Connection: close");
    }
    }
  }
#line 256
  return;
}
}
#line 20 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.h"
void get_running_stats_nl(statistics_t *stat___0 ) ;
#line 45 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
char *url_encode(char const   *str , char **result_p ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.h"
void directory_add(directory_server_t *ds , connection_t *con ) ;
#line 26
void directory_touch(directory_server_t *ds , connection_t *con ) ;
#line 27
void directory_touch_xa(directory_server_t *ds ) ;
#line 28
void directory_remove(directory_server_t *ds ) ;
#line 29
void avl_touch_directory(void *data , void *param ) ;
#line 30
void update_stream_id(char *dshost , char *mountpoint , int id ) ;
#line 31
void free_directory_servers(void) ;
#line 72 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void directory_touch_xa(directory_server_t *ds ) 
{ 
  int sockfd ;
  int error ;
  int err ;
  char s[65535] ;
  char *temp ;
  statistics_t stat___0 ;
  avl_traverser trav ;
  connection_t *sourcecon ;
  int i ;
  int c ;
  char *url_p[7] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned long alt ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  long tmp___21 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;

  {
#line 78
  error = 0;
#line 78
  err = error;
#line 79
  temp = (char *)((void *)0);
#line 80
  s[0] = (char )'\000';
#line 82
  if (! ds) {
    {
    {
#line 83
    write_log(0, (char *)"WARNING: Refuse to connect to NULL host");
    }
    }
#line 84
    return;
  } else
#line 82
  if (! ds->host) {
    {
    {
#line 83
    write_log(0, (char *)"WARNING: Refuse to connect to NULL host");
    }
    }
#line 84
    return;
  }
  {
  {
#line 87
  xa_debug(1, (char *)"DEBUG: Touching xaudiocast directory server [%s:%d/%s]", ds->host,
           ds->port, ds->path);
  }
  {
#line 88
  sockfd = sock_connect_wto((char const   *)ds->host, (int const   )ds->port, (int const   )15);
  }
  }
#line 88
  if (sockfd != -1) {
    {
#line 89
    trav.init = 0;
#line 89
    trav.nstack = 0;
#line 89
    trav.p = (avl_node const   *)0;
#line 89
    trav.stack[0] = (avl_node const   *)0;
#line 89
    trav.stack[1] = (avl_node const   *)0;
#line 89
    trav.stack[2] = (avl_node const   *)0;
#line 89
    trav.stack[3] = (avl_node const   *)0;
#line 89
    trav.stack[4] = (avl_node const   *)0;
#line 89
    trav.stack[5] = (avl_node const   *)0;
#line 89
    trav.stack[6] = (avl_node const   *)0;
#line 89
    trav.stack[7] = (avl_node const   *)0;
#line 89
    trav.stack[8] = (avl_node const   *)0;
#line 89
    trav.stack[9] = (avl_node const   *)0;
#line 89
    trav.stack[10] = (avl_node const   *)0;
#line 89
    trav.stack[11] = (avl_node const   *)0;
#line 89
    trav.stack[12] = (avl_node const   *)0;
#line 89
    trav.stack[13] = (avl_node const   *)0;
#line 89
    trav.stack[14] = (avl_node const   *)0;
#line 89
    trav.stack[15] = (avl_node const   *)0;
#line 89
    trav.stack[16] = (avl_node const   *)0;
#line 89
    trav.stack[17] = (avl_node const   *)0;
#line 89
    trav.stack[18] = (avl_node const   *)0;
#line 89
    trav.stack[19] = (avl_node const   *)0;
#line 89
    trav.stack[20] = (avl_node const   *)0;
#line 89
    trav.stack[21] = (avl_node const   *)0;
#line 89
    trav.stack[22] = (avl_node const   *)0;
#line 89
    trav.stack[23] = (avl_node const   *)0;
#line 89
    trav.stack[24] = (avl_node const   *)0;
#line 89
    trav.stack[25] = (avl_node const   *)0;
#line 89
    trav.stack[26] = (avl_node const   *)0;
#line 89
    trav.stack[27] = (avl_node const   *)0;
#line 89
    trav.stack[28] = (avl_node const   *)0;
#line 89
    trav.stack[29] = (avl_node const   *)0;
#line 89
    trav.stack[30] = (avl_node const   *)0;
#line 89
    trav.stack[31] = (avl_node const   *)0;
#line 91
    i = 1;
    {
#line 94
    xa_debug(2, (char *)"DEBUG: Connecting, sending info\n");
    }
#line 96
    c = 0;
    }
    {
    {
#line 96
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 96
      if (! (c < 7)) {
#line 96
        goto while_break;
      }
#line 96
      url_p[c] = (char *)((void *)0);
#line 96
      c ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 98
    get_running_stats_nl(& stat___0);
    }
    {
#line 101
    snprintf((char */* __restrict  */)(s), (size_t )65535, (char const   */* __restrict  */)"GET /%s?",
             ds->path);
    }
    }
#line 104
    if (ds->id != -1) {
      {
      {
#line 105
      catsnprintf(s, (size_t )65535, "id=%d&", ds->id);
      }
      }
    }
#line 108
    if (info.location) {
      {
      {
#line 108
      tmp = url_encode((char const   *)info.location, & url_p[4]);
      }
#line 108
      tmp___1 = tmp;
      }
    } else {
      {
      {
#line 108
      tmp___0 = url_encode("n/a", & url_p[4]);
      }
#line 108
      tmp___1 = tmp___0;
      }
    }
#line 108
    if (info.rp_email) {
      {
      {
#line 108
      tmp___2 = url_encode((char const   *)info.rp_email, & url_p[2]);
      }
#line 108
      tmp___4 = tmp___2;
      }
    } else {
      {
      {
#line 108
      tmp___3 = url_encode("n/a", & url_p[3]);
      }
#line 108
      tmp___4 = tmp___3;
      }
    }
#line 108
    if (stat___0.source_connections > 0UL) {
#line 108
      tmp___5 = stat___0.source_connections;
    } else {
#line 108
      tmp___5 = 1UL;
    }
#line 108
    if (stat___0.client_connections > 0UL) {
#line 108
      tmp___6 = stat___0.client_connections;
    } else {
#line 108
      tmp___6 = 1UL;
    }
    {
    {
#line 108
    tmp___7 = url_encode("1.3.12", & url_p[1]);
    }
    {
#line 108
    tmp___8 = url_encode((char const   *)info.server_name, & url_p[0]);
    }
    {
#line 108
    catsnprintf(s, (size_t )65535, "force=%d&name=%s&type=%s&version=%s&port=%d&listeners=%ld&maxlisteners=%ld&maxstreamlisteners=%ld&alt=%ld&ast=%ld&maxsources=%ld&url=%s&email=%s&location=%s",
                info.force_servername, tmp___8, "icecast", tmp___7, info.port[0],
                info.num_clients, info.max_clients, info.max_clients_per_source, stat___0.client_connect_time / tmp___6,
                stat___0.source_connect_time / tmp___5, info.max_sources, info.server_url,
                tmp___4, tmp___1);
    }
#line 115
    c = 0;
    }
    {
    {
#line 115
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! (c < 7)) {
#line 115
        goto while_break___0;
      }
#line 116
      if (url_p[c]) {
        {
        {
#line 116
        n_free((void *)url_p[c], (int const   )116, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
        }
        }
      }
#line 116
      url_p[c] = (char *)((void *)0);
#line 117
      url_p[c] = (char *)((void *)0);
#line 115
      c ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 120
    thread_mutex_lock_c(& info.source_mutex, 120, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
    }
    }
    {
    {
#line 121
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 121
      tmp___16 = avl_traverse(info.sources, & trav);
      }
#line 121
      sourcecon = (connection_t *)tmp___16;
      }
#line 121
      if (! sourcecon) {
#line 121
        goto while_break___1;
      }
#line 122
      if ((sourcecon->food.source)->audiocast.public) {
#line 124
        if ((sourcecon->food.source)->stats.client_connections > 0UL) {
#line 125
          alt = ((sourcecon->food.source)->stats.client_connect_time / (sourcecon->food.source)->stats.client_connections) * 60UL;
        } else {
#line 127
          alt = (sourcecon->food.source)->stats.client_connect_time * 60UL;
        }
        {
        {
#line 129
        tmp___9 = url_encode((char const   *)(sourcecon->food.source)->info.streamurl,
                             & url_p[6]);
        }
        {
#line 129
        tmp___10 = url_encode((char const   *)(sourcecon->food.source)->info.streamtitle,
                              & url_p[5]);
        }
        {
#line 129
        tmp___11 = url_encode((char const   *)(sourcecon->food.source)->audiocast.url,
                              & url_p[4]);
        }
        {
#line 129
        tmp___12 = url_encode((char const   *)(sourcecon->food.source)->audiocast.genre,
                              & url_p[3]);
        }
        {
#line 129
        tmp___13 = url_encode((char const   *)(sourcecon->food.source)->audiocast.description,
                              & url_p[2]);
        }
        {
#line 129
        tmp___14 = url_encode((char const   *)(sourcecon->food.source)->audiocast.name,
                              & url_p[1]);
        }
        {
#line 129
        tmp___15 = url_encode((char const   *)(sourcecon->food.source)->audiocast.mount,
                              & url_p[0]);
        }
        {
#line 129
        catsnprintf(s, (size_t )65535, "&source_mount_%d=%s&source_name_%d=%s&source_desc_%d=%s&source_genre_%d=%s&source_url_%d=%s&source_listeners_%d=%ld&source_alt_%d=%d&source_bitrate_%d=%d&stream_title_%d=%s&stream_url_%d=%s",
                    i, tmp___15, i, tmp___14, i, tmp___13, i, tmp___12, i, tmp___11,
                    i, (sourcecon->food.source)->num_clients, i, alt, i, (sourcecon->food.source)->audiocast.bitrate,
                    i, tmp___10, i, tmp___9);
        }
#line 140
        i ++;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 143
    thread_mutex_unlock_c(& info.source_mutex, 143, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
    }
#line 145
    c = 0;
    }
    {
    {
#line 145
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 145
      if (! (c < 7)) {
#line 145
        goto while_break___2;
      }
#line 146
      if (url_p[c]) {
        {
        {
#line 146
        n_free((void *)url_p[c], (int const   )146, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
        }
        }
      }
#line 146
      url_p[c] = (char *)((void *)0);
#line 147
      url_p[c] = (char *)((void *)0);
#line 145
      c ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 151
    catsnprintf(s, (size_t )65535, " HTTP/1.0\nHost: %s\n\n", ds->host);
    }
    {
#line 154
    tmp___17 = ice_strlen((char const   *)(s));
    }
    {
#line 154
    err = sock_write_bytes(sockfd, (char const   *)(s), (int )tmp___17);
    }
    }
#line 155
    if (err < 0) {
#line 156
      if (ds->id == -1) {
#line 157
        (ds->counter) ++;
      } else {
#line 159
        ds->counter = 1;
      }
      {
#line 161
      ds->id = -1;
      {
#line 163
      tmp___18 = get_time();
      }
      {
#line 163
      write_log(0, (char *)"directory_touch_xa([%s:%d]) failed... could not send data to server... (retry in %d seconds)",
                (long )((info.touch_freq * ds->counter) * 60) - (tmp___18 - ds->touchtime));
      }
      }
    } else {
      {
      {
#line 167
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
        {
        {
#line 168
        err = sock_read_line(sockfd, s, (int const   )8192);
        }
        {
#line 169
        xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
        }
        }
#line 167
        if (err == 1) {
          {
          {
#line 167
          tmp___19 = ice_strcmp((char const   *)(s), "");
          }
          }
#line 167
          if (! (tmp___19 != 0)) {
#line 167
            goto while_break___3;
          }
        } else {
#line 167
          goto while_break___3;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      {
#line 172
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 173
        err = sock_read_line(sockfd, s, (int const   )8192);
        }
        }
#line 175
        if (err == 1) {
          {
          {
#line 176
          xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
          }
          {
#line 178
          temp = strstr((char const   *)(s), "x-audiocast-yp-id: ");
          }
          }
#line 179
          if ((unsigned long )temp != (unsigned long )((void *)0)) {
            {
            {
#line 180
            ds->id = atoi((char const   *)(temp + 19));
            }
            }
          }
          {
          {
#line 181
          temp = strstr((char const   *)(s), "x-audiocast-yp-error: ");
          }
          }
#line 182
          if ((unsigned long )temp != (unsigned long )((void *)0)) {
            {
            {
#line 183
            error = atoi((char const   *)(temp + 22));
            }
            }
          }
        }
#line 172
        if (err == 1) {
          {
          {
#line 172
          tmp___20 = ice_strcmp((char const   *)(s), "");
          }
          }
#line 172
          if (! (tmp___20 != 0)) {
#line 172
            goto while_break___4;
          }
        } else {
#line 172
          goto while_break___4;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 187
      if (error == 0) {
        {
        {
#line 188
        write_log(0, (char *)"directory_touch_xa([%s:%d]) completed...server id = %i",
                  ds->host, ds->port, ds->id);
        }
#line 189
        (ds->touches) ++;
        }
      } else {
#line 191
        if (ds->id == -1) {
#line 192
          (ds->counter) ++;
        } else {
#line 194
          ds->counter = 1;
        }
        {
#line 196
        ds->id = -1;
        {
#line 198
        tmp___21 = get_time();
        }
        {
#line 198
        write_log(0, (char *)"directory_touch_xa([%s:%d]) failed... directory server error #%i... (retry in %d seconds)",
                  ds->host, ds->port, error, (long )((info.touch_freq * ds->counter) * 60) - (tmp___21 - ds->touchtime));
        }
        }
      }
    }
  } else {
    {
    {
#line 203
    write_log(0, (char *)"WARNING: Connect to %s failed.", ds->host);
    }
    }
  }
  {
  {
#line 206
  sock_close(sockfd);
  }
  }
#line 207
  return;
}
}
#line 211 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void directory_add(directory_server_t *ds , connection_t *con ) 
{ 
  int sockfd ;
  int error ;
  int err ;
  char s[8192] ;
  char *temp ;
  char *response ;
  source_t *source ;
  char *url_p[3] ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 221
  c = 0;
  {
  {
#line 221
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 221
    if (! (c < 3)) {
#line 221
      goto while_break;
    }
#line 222
    url_p[c] = (char *)((void *)0);
#line 221
    c ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (con) {
#line 225
    source = con->food.source;
  } else {
    {
    {
#line 227
    xa_debug(1, (char *)"DEBUG: No touch of %s:%d cause no encoders are connected",
             ds->host, ds->port);
    }
    }
#line 228
    return;
  }
#line 231
  err = 0;
#line 231
  error = err;
#line 232
  response = (char *)((void *)0);
#line 234
  if (! ds) {
    {
    {
#line 235
    write_log(0, (char *)"Refuse to connect to null hostname");
    }
    }
#line 236
    return;
  } else
#line 234
  if ((unsigned long )ds->host == (unsigned long )((void *)0)) {
    {
    {
#line 235
    write_log(0, (char *)"Refuse to connect to null hostname");
    }
    }
#line 236
    return;
  }
  {
  {
#line 239
  xa_debug(1, (char *)"DEBUG: Adding server to directory server [%s]", ds->host);
  }
  {
#line 242
  tmp = url_encode((char const   *)source->audiocast.url, & url_p[2]);
  }
  {
#line 242
  tmp___0 = url_encode((char const   *)source->audiocast.genre, & url_p[1]);
  }
  {
#line 242
  tmp___1 = url_encode((char const   *)source->audiocast.name, & url_p[0]);
  }
  {
#line 242
  xa_debug(2, (char *)"Sending GET /addsrv?v=1&br=%i&p=%i&m=%i&t=%s&g=%s&url=%s&irc=&icq=&aim= HTTP/1.0",
           source->audiocast.bitrate, info.port[0], info.max_clients, tmp___1, tmp___0,
           tmp);
  }
#line 245
  c = 0;
  }
  {
  {
#line 245
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 245
    if (! (c < 3)) {
#line 245
      goto while_break___0;
    }
#line 246
    if (url_p[c]) {
      {
      {
#line 246
      n_free((void *)url_p[c], (int const   )246, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
      }
      }
    }
#line 246
    url_p[c] = (char *)((void *)0);
#line 247
    url_p[c] = (char *)((void *)0);
#line 245
    c ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 250
  sockfd = sock_connect_wto((char const   *)ds->host, (int const   )ds->port, (int const   )15);
  }
  }
#line 250
  if (sockfd != -1) {
    {
    {
#line 251
    tmp___2 = url_encode((char const   *)source->audiocast.url, & url_p[2]);
    }
    {
#line 251
    tmp___3 = url_encode((char const   *)source->audiocast.genre, & url_p[1]);
    }
    {
#line 251
    tmp___4 = url_encode((char const   *)source->audiocast.name, & url_p[0]);
    }
    {
#line 251
    sock_write_line(sockfd, "GET /addsrv?v=1&br=%i&p=%i&m=%i&t=%s&g=%s&url=%s&irc=&icq=&aim= HTTP/1.0",
                    source->audiocast.bitrate, info.port[0], info.max_clients, tmp___4,
                    tmp___3, tmp___2);
    }
    {
#line 253
    sock_write_line(sockfd, "Host: %s\r\nAccept: */*\r\n", ds->host);
    }
#line 255
    c = 0;
    }
    {
    {
#line 255
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 255
      if (! (c < 3)) {
#line 255
        goto while_break___1;
      }
#line 256
      if (url_p[c]) {
        {
        {
#line 256
        n_free((void *)url_p[c], (int const   )256, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
        }
        }
      }
#line 256
      url_p[c] = (char *)((void *)0);
#line 257
      url_p[c] = (char *)((void *)0);
#line 255
      c ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 261
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
      {
      {
#line 262
      err = sock_read_line(sockfd, s, (int const   )8192);
      }
      {
#line 263
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      }
#line 261
      if (err == 1) {
        {
        {
#line 261
        tmp___5 = ice_strcmp((char const   *)(s), "");
        }
        }
#line 261
        if (! (tmp___5 != 0)) {
#line 261
          goto while_break___2;
        }
      } else {
#line 261
        goto while_break___2;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 266
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
      {
      {
#line 267
      err = sock_read_line(sockfd, s, (int const   )8192);
      }
      {
#line 268
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      {
#line 270
      temp = strstr((char const   *)(s), "icy-response:");
      }
      }
#line 271
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 272
        response = temp + 13;
      }
      {
      {
#line 273
      temp = strstr((char const   *)(s), "icy-id:");
      }
      }
#line 274
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
        {
#line 275
        ds->id = atoi((char const   *)(temp + 7));
        }
        }
      }
      {
      {
#line 276
      temp = strstr((char const   *)(s), "icy-tchfrq:");
      }
      }
#line 277
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
        {
#line 278
        info.touch_freq = atoi((char const   *)(temp + 11));
        }
        }
      }
      {
      {
#line 279
      temp = strstr((char const   *)(s), "icy-error:");
      }
      }
#line 280
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
        {
#line 281
        error = atoi((char const   *)(temp + 10));
        }
        }
      }
#line 266
      if (err == 1) {
        {
        {
#line 266
        tmp___6 = ice_strcmp((char const   *)(s), "");
        }
        }
#line 266
        if (! (tmp___6 != 0)) {
#line 266
          goto while_break___3;
        }
      } else {
#line 266
        goto while_break___3;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 284
    if (error == 0) {
#line 284
      if (ds->id != -1) {
        {
        {
#line 285
        write_log(0, (char *)"directory_add([%s:%d]) completed...server id = %i",
                  ds->host, ds->port, ds->id);
        }
        }
      } else {
        {
#line 287
        ds->id = -1;
#line 288
        (ds->counter) ++;
        {
#line 289
        tmp___7 = get_time();
        }
        {
#line 289
        write_log(0, (char *)"directory_add([%s:%d]) failed... directory server error #%i... (retry in %d seconds)",
                  ds->host, ds->port, error, (long )((info.touch_freq * ds->counter) * 60) - (tmp___7 - ds->touchtime));
        }
        }
      }
    } else {
      {
#line 287
      ds->id = -1;
#line 288
      (ds->counter) ++;
      {
#line 289
      tmp___7 = get_time();
      }
      {
#line 289
      write_log(0, (char *)"directory_add([%s:%d]) failed... directory server error #%i... (retry in %d seconds)",
                ds->host, ds->port, error, (long )((info.touch_freq * ds->counter) * 60) - (tmp___7 - ds->touchtime));
      }
      }
    }
    {
    {
#line 292
    sock_close(sockfd);
    }
    }
  } else {
    {
#line 294
    ds->id = -1;
#line 295
    (ds->counter) ++;
    {
#line 296
    tmp___8 = get_time();
    }
    {
#line 296
    write_log(0, (char *)"directory_add([%s:%d]) failed, could not connect. (retry in %d seconds)",
              ds->host, ds->port, error, (long )((info.touch_freq * ds->counter) * 60) - (tmp___8 - ds->touchtime));
    }
    }
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void directory_touch(directory_server_t *ds , connection_t *con ) 
{ 
  int sockfd ;
  int error ;
  int err ;
  int avt ;
  char s[8192] ;
  char *temp ;
  char *response ;
  char *title ;
  statistics_t stat___0 ;
  unsigned long tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 302
  avt = 0;
#line 307
  if ((unsigned long )con == (unsigned long )((void *)0)) {
    {
    {
#line 308
    directory_remove(ds);
    }
    }
#line 309
    return;
  }
#line 312
  err = 0;
#line 312
  error = err;
#line 313
  response = (char *)((void *)0);
#line 315
  if (! ds) {
    {
    {
#line 316
    write_log(0, (char *)"Refuse to touch a NULL host");
    }
    }
#line 317
    return;
  } else
#line 315
  if ((unsigned long )ds->host == (unsigned long )((void *)0)) {
    {
    {
#line 316
    write_log(0, (char *)"Refuse to touch a NULL host");
    }
    }
#line 317
    return;
  }
  {
  {
#line 320
  get_running_stats_nl(& stat___0);
  }
  }
#line 322
  if (stat___0.client_connections > 0UL) {
#line 322
    tmp = stat___0.client_connections;
  } else {
#line 322
    tmp = 1UL;
  }
  {
#line 322
  avt = (int )(stat___0.client_connect_time / tmp);
  {
#line 324
  xa_debug(2, (char *)"Sending: GET /cgi-bin/tchsrv?id=%i&p=%i&li=%i&alt=%d&ct=%s HTTP/1.0",
           ds->id, info.port[0], info.num_clients, avt, info.streamtitle);
  }
  {
#line 325
  sockfd = sock_connect_wto((char const   *)ds->host, (int const   )ds->port, (int const   )15);
  }
  }
#line 325
  if (sockfd != -1) {
    {
    {
#line 326
    tmp___0 = url_encode((char const   *)info.streamtitle, & title);
    }
    {
#line 326
    sock_write(sockfd, "GET /cgi-bin/tchsrv?id=%i&p=%i&li=%i&alt=%d&ct=%s HTTP/1.0\nHost: %s:%d\n\n",
               ds->id, info.port[0], info.num_clients, avt, tmp___0, ds->host, ds->port);
    }
    {
#line 327
    n_free((void *)title, (int const   )327, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
    }
#line 327
    title = (char *)((void *)0);
    }
    {
    {
#line 330
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 331
      err = sock_read_line(sockfd, s, (int const   )8192);
      }
      {
#line 332
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      }
#line 330
      if (err == 1) {
        {
        {
#line 330
        tmp___1 = ice_strcmp((char const   *)(s), "");
        }
        }
#line 330
        if (! (tmp___1 != 0)) {
#line 330
          goto while_break;
        }
      } else {
#line 330
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 335
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 336
      err = sock_read_line(sockfd, s, (int const   )8192);
      }
      {
#line 337
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      {
#line 338
      temp = strstr((char const   *)(s), "icy-response:");
      }
      }
#line 339
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 340
        response = temp + 13;
      }
      {
      {
#line 341
      temp = strstr((char const   *)(s), "icy-error:");
      }
      }
#line 342
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
        {
#line 343
        error = atoi((char const   *)(temp + 10));
        }
        }
      }
#line 335
      if (err == 1) {
        {
        {
#line 335
        tmp___2 = ice_strcmp((char const   *)(s), "");
        }
        }
#line 335
        if (! (tmp___2 != 0)) {
#line 335
          goto while_break___0;
        }
      } else {
#line 335
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    if (error == 0) {
      {
      {
#line 347
      write_log(0, (char *)"directory_touch([%s]) completed...", ds->host);
      }
#line 348
      (ds->touches) ++;
      }
    } else {
#line 350
      if (ds->id == -1) {
#line 351
        (ds->counter) ++;
      } else {
#line 353
        ds->counter = 1;
      }
      {
#line 354
      ds->id = -1;
      {
#line 356
      tmp___3 = get_time();
      }
      {
#line 356
      write_log(0, (char *)"directory_touch([%s:%d]) failed... directory server error #%i... (retry in %d seconds)",
                ds->host, ds->port, error, (long )((info.touch_freq * ds->counter) * 60) - (tmp___3 - ds->touchtime));
      }
      }
    }
    {
    {
#line 359
    sock_close(sockfd);
    }
    }
  } else {
    {
    {
#line 361
    write_log(0, (char *)"directory_touch([%s]) failed", ds->host);
    }
    }
  }
#line 363
  return;
}
}
#line 365 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void directory_remove(directory_server_t *ds ) 
{ 
  int sockfd ;
  int error ;
  int err ;
  char s[8192] ;
  char *temp ;
  char *response ;
  char buf[8192] ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 372
  err = 0;
#line 372
  error = err;
#line 373
  response = (char *)((void *)0);
#line 375
  if (! ds) {
    {
    {
#line 376
    write_log(0, (char *)"Refuse to remove null host");
    }
    }
#line 377
    return;
  } else
#line 375
  if ((unsigned long )ds->host == (unsigned long )((void *)0)) {
    {
    {
#line 376
    write_log(0, (char *)"Refuse to remove null host");
    }
    }
#line 377
    return;
  }
  {
  {
#line 380
  sockfd = sock_connect_wto((char const   *)ds->host, (int const   )ds->port, (int const   )15);
  }
  }
#line 380
  if (sockfd != -1) {
    {
    {
#line 381
    sock_write(sockfd, "GET /cgi-bin/remsrv?id=%i&p=%i HTTP/1.0\nHost: %s:%d\n\n",
               ds->id, info.port[0], ds->host, ds->port);
    }
    }
    {
    {
#line 384
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 385
      err = sock_read_line(sockfd, buf, (int const   )8192);
      }
      {
#line 386
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      }
#line 384
      if (err == 1) {
        {
        {
#line 384
        tmp = ice_strcmp((char const   *)(s), "");
        }
        }
#line 384
        if (! (tmp != 0)) {
#line 384
          goto while_break;
        }
      } else {
#line 384
        goto while_break;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 389
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 390
      err = sock_read_line(sockfd, buf, (int const   )8192);
      }
      {
#line 391
      xa_debug(2, (char *)"DEBUG: server-response: [%s]", s);
      }
      {
#line 392
      temp = strstr((char const   *)(s), "icy-response:");
      }
      }
#line 393
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
#line 394
        response = temp + 13;
      }
      {
      {
#line 395
      temp = strstr((char const   *)(s), "icy-error:");
      }
      }
#line 396
      if ((unsigned long )temp != (unsigned long )((void *)0)) {
        {
        {
#line 397
        error = atoi((char const   *)(temp + 10));
        }
        }
      }
#line 389
      if (err == 1) {
        {
        {
#line 389
        tmp___0 = ice_strcmp((char const   *)(s), "");
        }
        }
#line 389
        if (! (tmp___0 != 0)) {
#line 389
          goto while_break___0;
        }
      } else {
#line 389
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 400
    if (error == 0) {
      {
      {
#line 401
      write_log(0, (char *)"directory_remove([%s]) completed...", ds->host);
      }
#line 402
      ds->id = -1;
      }
    } else {
      {
      {
#line 404
      write_log(0, (char *)"directory_remove([%s]) failed... directory server error #%i...",
                ds->host, error);
      }
      }
    }
    {
    {
#line 407
    sock_close(sockfd);
    }
    }
  } else {
    {
    {
#line 409
    write_log(0, (char *)"directory_remove([%s]) failed", ds->host);
    }
    }
  }
#line 411
  return;
}
}
#line 413 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void avl_touch_directory(void *data , void *param ) 
{ 
  directory_server_t *dir ;
  connection_t *defcon ;
  connection_t *tmp ;

  {
  {
#line 415
  dir = (directory_server_t *)data;
  {
#line 416
  tmp = get_default_mount();
  }
#line 416
  defcon = tmp;
  }
#line 418
  if ((unsigned int )dir->type == 0U) {
#line 419
    if (dir->id >= 0) {
      {
      {
#line 420
      directory_touch(dir, defcon);
      }
      }
    } else {
      {
      {
#line 422
      directory_add(dir, defcon);
      }
      }
    }
  } else {
    {
    {
#line 424
    directory_touch_xa(dir);
    }
    }
  }
#line 426
  return;
}
}
#line 428 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void update_stream_id(char *dshost , char *mountpoint , int id ) 
{ 
  avl_traverser trav ;
  connection_t *sourcecon ;
  relay_id_t *out ;
  relay_id_t *rip ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 430
  trav.init = 0;
#line 430
  trav.nstack = 0;
#line 430
  trav.p = (avl_node const   *)0;
#line 430
  trav.stack[0] = (avl_node const   *)0;
#line 430
  trav.stack[1] = (avl_node const   *)0;
#line 430
  trav.stack[2] = (avl_node const   *)0;
#line 430
  trav.stack[3] = (avl_node const   *)0;
#line 430
  trav.stack[4] = (avl_node const   *)0;
#line 430
  trav.stack[5] = (avl_node const   *)0;
#line 430
  trav.stack[6] = (avl_node const   *)0;
#line 430
  trav.stack[7] = (avl_node const   *)0;
#line 430
  trav.stack[8] = (avl_node const   *)0;
#line 430
  trav.stack[9] = (avl_node const   *)0;
#line 430
  trav.stack[10] = (avl_node const   *)0;
#line 430
  trav.stack[11] = (avl_node const   *)0;
#line 430
  trav.stack[12] = (avl_node const   *)0;
#line 430
  trav.stack[13] = (avl_node const   *)0;
#line 430
  trav.stack[14] = (avl_node const   *)0;
#line 430
  trav.stack[15] = (avl_node const   *)0;
#line 430
  trav.stack[16] = (avl_node const   *)0;
#line 430
  trav.stack[17] = (avl_node const   *)0;
#line 430
  trav.stack[18] = (avl_node const   *)0;
#line 430
  trav.stack[19] = (avl_node const   *)0;
#line 430
  trav.stack[20] = (avl_node const   *)0;
#line 430
  trav.stack[21] = (avl_node const   *)0;
#line 430
  trav.stack[22] = (avl_node const   *)0;
#line 430
  trav.stack[23] = (avl_node const   *)0;
#line 430
  trav.stack[24] = (avl_node const   *)0;
#line 430
  trav.stack[25] = (avl_node const   *)0;
#line 430
  trav.stack[26] = (avl_node const   *)0;
#line 430
  trav.stack[27] = (avl_node const   *)0;
#line 430
  trav.stack[28] = (avl_node const   *)0;
#line 430
  trav.stack[29] = (avl_node const   *)0;
#line 430
  trav.stack[30] = (avl_node const   *)0;
#line 430
  trav.stack[31] = (avl_node const   *)0;
  {
#line 432
  tmp = n_malloc((unsigned int const   )sizeof(relay_id_t ), (int const   )432, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
#line 432
  rip = (relay_id_t *)tmp;
#line 434
  rip->id = id;
  {
#line 435
  rip->host = n_strdup((char const   *)dshost, (int const   )435, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
  {
#line 437
  thread_mutex_lock_c(& info.source_mutex, 437, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
  }
  {
  {
#line 438
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 438
    tmp___2 = avl_traverse(info.sources, & trav);
    }
#line 438
    sourcecon = (connection_t *)tmp___2;
    }
#line 438
    if (! sourcecon) {
#line 438
      goto while_break;
    }
    {
    {
#line 439
    xa_debug(2, (char *)"DEBUG: update_stream_id () Looking for mountpoint [%s] on dshost: [%s]",
             mountpoint, dshost);
    }
    {
#line 440
    tmp___1 = ice_strcmp((char const   *)(sourcecon->food.source)->audiocast.mount,
                         (char const   *)mountpoint);
    }
    }
#line 440
    if (tmp___1 == 0) {
      {
      {
#line 441
      tmp___0 = avl_replace((sourcecon->food.source)->relay_tree, (void *)rip);
      }
#line 441
      out = (relay_id_t *)tmp___0;
      {
#line 442
      xa_debug(2, (char *)"DEBUG: update_stream_id () Gave source %d new id for dshost: [%s] with %d",
               sourcecon->id, dshost, id);
      }
      }
#line 444
      if (out) {
        {
        {
#line 445
        n_free((void *)out->host, (int const   )445, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
        }
#line 445
        out->host = (char *)((void *)0);
        {
#line 446
        n_free((void *)out, (int const   )446, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
        }
#line 446
        out = (relay_id_t *)((void *)0);
        }
      }
      {
      {
#line 449
      thread_mutex_unlock_c(& info.source_mutex, 449, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
      }
      }
#line 450
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 454
  n_free((void *)rip->host, (int const   )454, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
#line 454
  rip->host = (char *)((void *)0);
  {
#line 455
  n_free((void *)rip, (int const   )455, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
#line 455
  rip = (relay_id_t *)((void *)0);
  {
#line 457
  thread_mutex_unlock_c(& info.source_mutex, 457, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
  {
#line 458
  xa_debug(2, (char *)"DEBUG: update_stream_id (): Found no stream with mountpoint %s for dshost [%s]",
           mountpoint, dshost);
  }
  }
#line 459
  return;
}
}
#line 461 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c"
void free_directory_servers(void) 
{ 
  directory_server_t *ds ;
  directory_server_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 465
  if (! info.d_servers) {
    {
    {
#line 466
    write_log(0, (char *)"WARNING: info.d_servers is NULL, weird!");
    }
    }
#line 467
    return;
  }
  {
  {
#line 470
  thread_mutex_lock_c(& info.directory_mutex, 470, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
  }
  {
  {
#line 471
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 471
    tmp___0 = avl_get_any_node(info.d_servers);
    }
#line 471
    ds = (directory_server_t *)tmp___0;
    }
#line 471
    if (! ds) {
#line 471
      goto while_break;
    }
#line 473
    if (! ds) {
      {
      {
#line 474
      write_log(0, (char *)"WARNING: avl_get_any_node() returned NULL directory server");
      }
      }
#line 475
      goto while_continue;
    }
    {
    {
#line 478
    tmp = avl_delete(info.d_servers, (void const   *)ds);
    }
#line 478
    out = (directory_server_t *)tmp;
    }
#line 479
    if (out) {
      {
      {
#line 480
      n_free((void *)out->path, (int const   )480, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
      }
#line 480
      out->path = (char *)((void *)0);
      {
#line 481
      n_free((void *)out->host, (int const   )481, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
      }
#line 481
      out->host = (char *)((void *)0);
      {
#line 482
      n_free((void *)out, (int const   )482, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
      }
#line 482
      out = (directory_server_t *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 485
  thread_mutex_unlock_c(& info.directory_mutex, 485, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/directory.c");
  }
  }
#line 486
  return;
}
}
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.c"
static unsigned char tolowertab[256]  = 
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
#line 89 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.c"
int wild_match(unsigned char const   *m , unsigned char const   *n ) 
{ 
  unsigned char const   *ma ;
  unsigned char const   *lsm ;
  unsigned char const   *lsn ;
  unsigned char const   *lpm ;
  unsigned char const   *lpn ;
  int match ;
  int saved ;
  register unsigned int sofar ;
  int space ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 92
  ma = m;
#line 92
  lsm = (unsigned char const   *)0;
#line 92
  lsn = (unsigned char const   *)0;
#line 92
  lpm = (unsigned char const   *)0;
#line 92
  lpn = (unsigned char const   *)0;
#line 93
  match = 1;
#line 93
  saved = 0;
#line 94
  sofar = 0U;
#line 100
  if ((unsigned long )m == (unsigned long )((unsigned char const   *)0)) {
#line 101
    return (0);
  } else
#line 100
  if ((unsigned long )n == (unsigned long )((unsigned char const   *)0)) {
#line 101
    return (0);
  } else
#line 100
  if (! *n) {
#line 101
    return (0);
  }
  {
  {
#line 109
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 109
    if (! *n) {
#line 109
      goto while_break;
    }
#line 112
    if ((int const   )*m == 126) {
#line 113
      space = 0;
      {
      {
#line 114
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 115
        m ++;
#line 116
        space ++;
#line 114
        if (! ((int const   )*m == 126)) {
#line 114
          if (! ((int const   )*m == 32)) {
#line 114
            goto while_break___0;
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 119
      sofar += (unsigned int )space;
      {
      {
#line 120
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 120
        if (! ((int const   )*n == 32)) {
#line 120
          goto while_break___1;
        }
#line 121
        n ++;
#line 122
        space --;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 124
      if (space <= 0) {
#line 125
        goto while_continue;
      }
    } else {
      {
#line 131
      if ((int const   )*m == 0) {
#line 131
        goto case_0;
      }
#line 138
      if ((int const   )*m == 37) {
#line 138
        goto case_37;
      }
#line 150
      if ((int const   )*m == 42) {
#line 150
        goto case_42;
      }
#line 160
      if ((int const   )*m == 63) {
#line 160
        goto case_63;
      }
#line 164
      if ((int const   )*m == 92) {
#line 164
        goto case_92;
      }
#line 130
      goto switch_break;
      case_0: /* CIL Label */ 
      {
      {
#line 132
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 133
        m --;
#line 132
        if ((unsigned long )m > (unsigned long )ma) {
#line 132
          if (! ((int const   )*m == 63)) {
#line 132
            goto while_break___2;
          }
        } else {
#line 132
          goto while_break___2;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 135
      if ((unsigned long )m > (unsigned long )ma) {
#line 135
        if ((int const   )*m == 42) {
#line 135
          if ((int const   )*(m + -1) != 92) {
#line 135
            tmp = 1;
          } else {
#line 135
            tmp = 0;
          }
        } else {
#line 135
          tmp = 0;
        }
#line 135
        tmp___0 = tmp;
      } else {
#line 135
        tmp___0 = (int const   )*m == 42;
      }
#line 135
      if (tmp___0) {
#line 136
        return ((int )((unsigned int )(match + saved) + sofar));
      }
#line 137
      goto switch_break;
      case_37: /* CIL Label */ 
      {
      {
#line 139
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 139
        m ++;
#line 139
        if (! ((int const   )*m == 37)) {
#line 139
          goto while_break___3;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 140
      if ((int const   )*m != 42) {
#line 141
        if ((int const   )*n != 32) {
#line 142
          lpm = m;
#line 143
          lpn = n;
#line 144
          saved = (int )((unsigned int )saved + sofar);
#line 145
          sofar = 0U;
        }
#line 147
        goto while_continue;
      }
      case_42: /* CIL Label */ 
      {
      {
#line 151
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 152
        m ++;
#line 151
        if (! ((int const   )*m == 42)) {
#line 151
          if (! ((int const   )*m == 37)) {
#line 151
            goto while_break___4;
          }
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 154
      lsm = m;
#line 155
      lsn = n;
#line 156
      lpm = (unsigned char const   *)0;
#line 157
      match = (int )((unsigned int )match + ((unsigned int )saved + sofar));
#line 158
      sofar = 0U;
#line 158
      saved = (int )sofar;
#line 159
      goto while_continue;
      case_63: /* CIL Label */ 
#line 161
      m ++;
#line 162
      n ++;
#line 163
      goto while_continue;
      case_92: /* CIL Label */ 
#line 165
      m ++;
      switch_break: /* CIL Label */ ;
      }
#line 168
      if ((int )tolowertab[*m] == (int )tolowertab[*n]) {
#line 169
        m ++;
#line 170
        n ++;
#line 171
        sofar ++;
#line 172
        goto while_continue;
      }
    }
#line 177
    if (lpm) {
#line 178
      lpn ++;
#line 178
      n = lpn;
#line 179
      m = lpm;
#line 180
      sofar = 0U;
#line 181
      if (((int const   )*n | 32) == 32) {
#line 182
        lpm = (unsigned char const   *)0;
      }
#line 183
      goto while_continue;
    }
#line 185
    if (lsm) {
#line 186
      lsn ++;
#line 186
      n = lsn;
#line 187
      m = lsm;
#line 189
      sofar = 0U;
#line 189
      saved = (int )sofar;
#line 190
      goto while_continue;
    }
#line 192
    return (0);
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 194
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___5: /* CIL Label */ ;
#line 194
    if (! ((int const   )*m == 42)) {
#line 194
      if (! ((int const   )*m == 37)) {
#line 194
        goto while_break___5;
      }
    }
#line 195
    m ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 196
  if (*m) {
#line 196
    tmp___1 = 0U;
  } else {
#line 196
    tmp___1 = (unsigned int )(match + saved) + sofar;
  }
#line 196
  return ((int )tmp___1);
}
}
#line 138 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 155 "/usr/include/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 166
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 151 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 59 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
connection_t *find_con_with_host_and_udpport(char const   *hostptr , int const   portnr ) ;
#line 60
connection_t *find_con_with_host(struct sockaddr_in  const  *sin ) ;
#line 68
time_t tree_time(avl_tree *tree ) ;
#line 5 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.h"
void *startup_heartbeat_thread(void *arg ) ;
#line 8
void status_write(server_info_t *infostruct ) ;
#line 9
void get_hourly_stats(statistics_t *stat___0 ) ;
#line 10
void write_hourly_stats(statistics_t *stat___0 ) ;
#line 11
void update_daily_statistics(statistics_t *stat___0 ) ;
#line 12
void get_daily_stats(statistics_t *stat___0 ) ;
#line 13
void update_total_statistics(statistics_t *stat___0 ) ;
#line 14
void write_daily_stats(statistics_t *stat___0 ) ;
#line 16
void get_current_stats(statistics_t *stat___0 ) ;
#line 17
void get_current_stats_proc(statistics_t *stat___0 , int lock ) ;
#line 19
void get_running_stats_proc(statistics_t *stat___0 , int lock ) ;
#line 21
void add_stats(statistics_t *target , statistics_t *source , unsigned long factor ) ;
#line 23
int udp_update_metainfo(SOCKET s , connection_t *sourcecon , connection_t *clicon ) ;
#line 24
void timer_update_stats_files(time_t stime___0 ) ;
#line 25
void timer_handle_directory_servers(time_t stime___0 ) ;
#line 26
void timer_handle_status_lines(time_t stime___0 ) ;
#line 27
void timer_handle_transfer_statistics(time_t stime___0 , time_t *trottime , time_t *justone ,
                                      statistics_t *trotstat ) ;
#line 28
void timer_kick_abandoned_relays(time_t stime___0 ) ;
#line 37 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
int client_wants_udp_info(connection_t *con ) ;
#line 86 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void display_stats(statistics_t *stat___0 ) ;
#line 89 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void status_write(server_info_t *infostruct ) 
{ 
  char timebuf[8192] ;
  avl_traverser trav ;
  connection_t *con ;
  char *lt ;
  char *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 92
  trav.init = 0;
#line 92
  trav.nstack = 0;
#line 92
  trav.p = (avl_node const   *)0;
#line 92
  trav.stack[0] = (avl_node const   *)0;
#line 92
  trav.stack[1] = (avl_node const   *)0;
#line 92
  trav.stack[2] = (avl_node const   *)0;
#line 92
  trav.stack[3] = (avl_node const   *)0;
#line 92
  trav.stack[4] = (avl_node const   *)0;
#line 92
  trav.stack[5] = (avl_node const   *)0;
#line 92
  trav.stack[6] = (avl_node const   *)0;
#line 92
  trav.stack[7] = (avl_node const   *)0;
#line 92
  trav.stack[8] = (avl_node const   *)0;
#line 92
  trav.stack[9] = (avl_node const   *)0;
#line 92
  trav.stack[10] = (avl_node const   *)0;
#line 92
  trav.stack[11] = (avl_node const   *)0;
#line 92
  trav.stack[12] = (avl_node const   *)0;
#line 92
  trav.stack[13] = (avl_node const   *)0;
#line 92
  trav.stack[14] = (avl_node const   *)0;
#line 92
  trav.stack[15] = (avl_node const   *)0;
#line 92
  trav.stack[16] = (avl_node const   *)0;
#line 92
  trav.stack[17] = (avl_node const   *)0;
#line 92
  trav.stack[18] = (avl_node const   *)0;
#line 92
  trav.stack[19] = (avl_node const   *)0;
#line 92
  trav.stack[20] = (avl_node const   *)0;
#line 92
  trav.stack[21] = (avl_node const   *)0;
#line 92
  trav.stack[22] = (avl_node const   *)0;
#line 92
  trav.stack[23] = (avl_node const   *)0;
#line 92
  trav.stack[24] = (avl_node const   *)0;
#line 92
  trav.stack[25] = (avl_node const   *)0;
#line 92
  trav.stack[26] = (avl_node const   *)0;
#line 92
  trav.stack[27] = (avl_node const   *)0;
#line 92
  trav.stack[28] = (avl_node const   *)0;
#line 92
  trav.stack[29] = (avl_node const   *)0;
#line 92
  trav.stack[30] = (avl_node const   *)0;
#line 92
  trav.stack[31] = (avl_node const   *)0;
  {
#line 95
  tmp = get_log_time();
  }
#line 95
  lt = tmp;
  }
  {
  {
#line 97
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 97
    tmp___7 = avl_traverse(info.admins, & trav);
    }
#line 97
    con = (connection_t *)tmp___7;
    }
#line 97
    if (con) {
#line 97
      if (! (running == 1)) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 98
    if ((con->food.admin)->status) {
#line 98
      if ((con->food.admin)->alive) {
#line 99
        if (con->host) {
          {
          {
#line 99
          tmp___6 = ice_strcmp((char const   *)con->host, "icecast console");
          }
          }
#line 99
          if (tmp___6 == 0) {
            {
            {
#line 100
            tmp___0 = get_time();
            }
            {
#line 100
            tmp___1 = nice_time((unsigned long )(tmp___0 - info.server_start_time),
                                timebuf);
            }
            {
#line 100
            printf((char const   */* __restrict  */)"[%s] [Bandwidth: %fMB/s] [Sources: %ld] [Clients: %ld] [Admins: %ld] [Uptime: %s]\n-> ",
                   lt, info.bandwidth_usage, info.num_sources, info.num_clients, info.num_admins,
                   tmp___1);
            }
            {
#line 103
            fflush(stdout);
            }
            }
          } else {
#line 99
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 105
          if ((unsigned int )(con->food.admin)->scheme != 2U) {
            {
            {
#line 106
            tmp___2 = get_time();
            }
            {
#line 106
            tmp___3 = nice_time((unsigned long )(tmp___2 - info.server_start_time),
                                timebuf);
            }
            {
#line 106
            sock_write_line(con->sock, "[%s] [Bandwidth: %fMB/s] [Sources: %ld] [Clients: %ld] [Admins: %ld] [Uptime: %s]",
                            lt, info.bandwidth_usage, info.num_sources, info.num_clients,
                            info.num_admins, tmp___3);
            }
            }
          } else {
            {
            {
#line 110
            tmp___4 = get_time();
            }
            {
#line 110
            tmp___5 = nice_time((unsigned long )(tmp___4 - info.server_start_time),
                                timebuf);
            }
            {
#line 110
            sock_write_line(con->sock, "M%d [%s] [Bandwidth: %fMB/s] [Sources: %ld] [Clients: %ld] [Admins: %ld] [Uptime: %s]",
                            352, lt, info.bandwidth_usage, info.num_sources, info.num_clients,
                            info.num_admins, tmp___5);
            }
            }
          }
          {
          {
#line 115
          sock_write(con->sock, "-> ");
          }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 120
  write_log(1, (char *)"[%s] Bandwidth:%fMB/s Sources:%ld Clients:%ld Admins:%ld",
            lt, info.bandwidth_usage, info.num_sources, info.num_clients, info.num_admins);
  }
  }
#line 122
  if (lt) {
    {
    {
#line 123
    free((void *)lt);
    }
    }
  }
#line 124
  return;
}
}
#line 129 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void *startup_timer_thread(void *arg ) 
{ 
  time_t justone ;
  time_t trottime ;
  statistics_t trotstat ;
  mythread_t *mt ;
  time_t stime___0 ;
  long tmp ;
  int tmp___0 ;
  char *__cil_tmp9 ;

  {
  {
#line 131
  justone = (time_t )0;
#line 131
  trottime = (time_t )0;
  {
#line 135
  thread_init();
  }
  {
#line 137
  mt = thread_get_mythread();
  }
  }
  {
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 139
    tmp___0 = thread_alive(mt);
    }
    }
#line 139
    if (! tmp___0) {
#line 139
      goto while_break;
    }
    {
    {
#line 140
    tmp = get_time();
    }
#line 140
    stime___0 = tmp;
    {
#line 142
    timer_update_stats_files(stime___0);
    }
    {
#line 144
    timer_handle_directory_servers(stime___0);
    }
    {
#line 146
    timer_handle_status_lines(stime___0);
    }
    {
#line 148
    timer_handle_transfer_statistics(stime___0, & trottime, & justone, & trotstat);
    }
    {
#line 150
    timer_kick_abandoned_relays(stime___0);
    }
    }
#line 152
    if (mt->ping == 1) {
#line 153
      mt->ping = 0;
    }
    {
    {
#line 155
    my_sleep(400000);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 160
  thread_exit_c(7L, 160, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 161
  return ((void *)0);
}
}
#line 164 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void timer_update_stats_files(time_t stime___0 ) 
{ 


  {
#line 167
  if (info.statstime > 0) {
#line 168
    if (stime___0 - info.statslasttime >= (time_t )info.statstime) {
      {
#line 169
      info.statslasttime = stime___0;
      {
#line 170
      stats_write(& info);
      }
      {
#line 171
      stats_write_html(& info);
      }
      }
    }
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void timer_handle_directory_servers(time_t stime___0 ) 
{ 
  avl_traverser trav ;
  directory_server_t *ds ;
  connection_t *defcon ;
  connection_t *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 179
  trav.init = 0;
#line 179
  trav.nstack = 0;
#line 179
  trav.p = (avl_node const   *)0;
#line 179
  trav.stack[0] = (avl_node const   *)0;
#line 179
  trav.stack[1] = (avl_node const   *)0;
#line 179
  trav.stack[2] = (avl_node const   *)0;
#line 179
  trav.stack[3] = (avl_node const   *)0;
#line 179
  trav.stack[4] = (avl_node const   *)0;
#line 179
  trav.stack[5] = (avl_node const   *)0;
#line 179
  trav.stack[6] = (avl_node const   *)0;
#line 179
  trav.stack[7] = (avl_node const   *)0;
#line 179
  trav.stack[8] = (avl_node const   *)0;
#line 179
  trav.stack[9] = (avl_node const   *)0;
#line 179
  trav.stack[10] = (avl_node const   *)0;
#line 179
  trav.stack[11] = (avl_node const   *)0;
#line 179
  trav.stack[12] = (avl_node const   *)0;
#line 179
  trav.stack[13] = (avl_node const   *)0;
#line 179
  trav.stack[14] = (avl_node const   *)0;
#line 179
  trav.stack[15] = (avl_node const   *)0;
#line 179
  trav.stack[16] = (avl_node const   *)0;
#line 179
  trav.stack[17] = (avl_node const   *)0;
#line 179
  trav.stack[18] = (avl_node const   *)0;
#line 179
  trav.stack[19] = (avl_node const   *)0;
#line 179
  trav.stack[20] = (avl_node const   *)0;
#line 179
  trav.stack[21] = (avl_node const   *)0;
#line 179
  trav.stack[22] = (avl_node const   *)0;
#line 179
  trav.stack[23] = (avl_node const   *)0;
#line 179
  trav.stack[24] = (avl_node const   *)0;
#line 179
  trav.stack[25] = (avl_node const   *)0;
#line 179
  trav.stack[26] = (avl_node const   *)0;
#line 179
  trav.stack[27] = (avl_node const   *)0;
#line 179
  trav.stack[28] = (avl_node const   *)0;
#line 179
  trav.stack[29] = (avl_node const   *)0;
#line 179
  trav.stack[30] = (avl_node const   *)0;
#line 179
  trav.stack[31] = (avl_node const   *)0;
  {
#line 181
  tmp = get_default_mount();
  }
#line 181
  defcon = tmp;
  }
#line 183
  if (stime___0 - info.directorylasttime >= (time_t )(info.touch_freq * 60)) {
    {
    {
#line 189
    zero_trav(& trav);
    }
    {
#line 191
    thread_mutex_lock_c(& info.double_mutex, 191, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    {
#line 192
    thread_mutex_lock_c(& info.directory_mutex, 192, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
    {
    {
#line 194
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 194
      tmp___0 = avl_traverse(info.d_servers, & trav);
      }
#line 194
      ds = (directory_server_t *)tmp___0;
      }
#line 194
      if (! ds) {
#line 194
        goto while_break;
      }
#line 195
      if ((unsigned int )ds->type == 0U) {
#line 196
        goto while_continue;
      }
#line 198
      if (ds->id < 0) {
#line 198
        if (ds->counter > 0) {
#line 198
          if (stime___0 - ds->touchtime < (time_t )((info.touch_freq * ds->counter) * 60)) {
            {
            {
#line 200
            xa_debug(2, (char *)"DEBUG: Directory server [%s] still has %d seconds to go",
                     ds->host, (stime___0 - ds->touchtime) - (time_t )((info.touch_freq * ds->counter) * 60));
            }
            }
#line 202
            goto while_continue;
          }
        }
      }
      {
      {
#line 205
      directory_touch_xa(ds);
      }
#line 206
      ds->touchtime = stime___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 209
    thread_mutex_unlock_c(& info.directory_mutex, 209, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    {
#line 210
    thread_mutex_unlock_c(& info.double_mutex, 210, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    {
#line 212
    thread_mutex_lock_c(& info.directory_mutex, 212, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
    {
    {
#line 214
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 214
      tmp___1 = avl_traverse(info.d_servers, & trav);
      }
#line 214
      ds = (directory_server_t *)tmp___1;
      }
#line 214
      if (! ds) {
#line 214
        goto while_break___0;
      }
#line 215
      if ((unsigned int )ds->type != 0U) {
#line 215
        goto while_continue___0;
      }
#line 217
      if (ds->id < 0) {
#line 217
        if (ds->counter > 0) {
#line 217
          if (stime___0 - ds->touchtime < (time_t )((info.touch_freq * ds->counter) * 60)) {
            {
            {
#line 219
            xa_debug(2, (char *)"DEBUG: Directory server [%s] still has %d seconds to go",
                     ds->host, (stime___0 - ds->touchtime) - (time_t )((info.touch_freq * ds->counter) * 60));
            }
            }
#line 221
            goto while_continue___0;
          }
        }
      }
#line 224
      if (ds->id == -1) {
#line 225
        if ((unsigned long )defcon != (unsigned long )((void *)0)) {
          {
          {
#line 226
          directory_add(ds, defcon);
          }
          {
#line 227
          directory_touch(ds, defcon);
          }
          }
        }
      } else {
        {
        {
#line 230
        directory_touch(ds, defcon);
        }
        }
      }
#line 232
      ds->touchtime = stime___0;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 235
    thread_mutex_unlock_c(& info.directory_mutex, 235, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
#line 237
    info.directorylasttime = stime___0;
    }
  } else
#line 238
  if ((unsigned long )defcon == (unsigned long )((void *)0)) {
    {
    {
#line 239
    thread_mutex_lock_c(& info.directory_mutex, 239, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
    {
    {
#line 240
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 240
      tmp___2 = avl_traverse(info.d_servers, & trav);
      }
#line 240
      ds = (directory_server_t *)tmp___2;
      }
#line 240
      if (! ds) {
#line 240
        goto while_break___1;
      }
#line 241
      if ((unsigned int )ds->type != 0U) {
#line 241
        goto while_continue___1;
      }
#line 242
      if (ds->id != -1) {
        {
        {
#line 242
        directory_remove(ds);
        }
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 244
    thread_mutex_unlock_c(& info.directory_mutex, 244, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
#line 246
  return;
}
}
#line 248 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void timer_handle_status_lines(time_t stime___0 ) 
{ 


  {
#line 251
  if (stime___0 - info.statuslasttime >= (time_t )info.statustime) {
    {
#line 252
    info.statuslasttime = stime___0;
    {
#line 253
    status_write(& info);
    }
    }
  }
#line 256
  return;
}
}
#line 258 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void timer_handle_transfer_statistics(time_t stime___0 , time_t *trottime , time_t *justone ,
                                      statistics_t *trotstat ) 
{ 
  statistics_t stat___0 ;
  statistics_t hourlystats ;
  statistics_t stat___1 ;
  time_t delta ;
  statistics_t stat___2 ;
  unsigned int total_bytes ;
  double MB_per_sec ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 265
  tmp___1 = get_time();
  }
  }
#line 265
  if (tmp___1 != *justone) {
    {
    {
#line 266
    *justone = get_time();
    }
    }
#line 269
    if (stime___0 % 86400L == 0L) {
      {
      {
#line 272
      get_hourly_stats(& hourlystats);
      }
      {
#line 273
      zero_stats(& info.hourly_stats);
      }
      {
#line 274
      update_daily_statistics(& hourlystats);
      }
      {
#line 276
      get_daily_stats(& stat___0);
      }
      {
#line 277
      zero_stats(& info.daily_stats);
      }
      {
#line 278
      update_total_statistics(& stat___0);
      }
      {
#line 279
      write_daily_stats(& stat___0);
      }
      }
    } else
#line 280
    if (stime___0 % 3600L == 0L) {
      {
      {
#line 282
      get_hourly_stats(& stat___1);
      }
      {
#line 283
      zero_stats(& info.hourly_stats);
      }
      {
#line 284
      update_daily_statistics(& stat___1);
      }
      {
#line 285
      write_hourly_stats(& stat___1);
      }
      }
    }
#line 288
    if (stime___0 % 60L == 0L) {
      {
#line 292
      MB_per_sec = (double )0;
      {
#line 294
      get_running_stats(& stat___2);
      }
      }
#line 296
      if (*trottime == 0L) {
        {
        {
#line 297
        *trottime = get_time();
        }
        {
#line 298
        get_running_stats(trotstat);
        }
        }
      } else {
        {
#line 300
        total_bytes = (unsigned int )((stat___2.read_bytes - trotstat->read_bytes) + (stat___2.write_bytes - trotstat->write_bytes));
        {
#line 301
        tmp = get_time();
        }
#line 301
        delta = tmp - *trottime;
        }
#line 302
        if (delta <= 0L) {
          {
          {
#line 303
          tmp___0 = get_time();
          }
          {
#line 303
          write_log(0, (char *)"ERROR: Losing track of time.. is it xmas already? [%d - %d == %d <= 0]",
                    tmp___0, *trottime, delta);
          }
          }
        } else {
#line 307
          MB_per_sec = (double )total_bytes / (double )delta;
#line 312
          if (MB_per_sec < (double )40000) {
#line 313
            info.bandwidth_usage = MB_per_sec;
#line 314
            if (! info.throttle_on) {
#line 314
              if (info.throttle > 0.0) {
#line 314
                if (MB_per_sec > info.throttle) {
                  {
                  {
#line 315
                  write_log(0, (char *)"Throttling bandwidth: [Usage %f, specified throttle value: %f]",
                            MB_per_sec, info.throttle);
                  }
#line 317
                  info.throttle_on = 1;
                  }
                } else {
#line 314
                  goto _L___0;
                }
              } else {
#line 314
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 318
            if (info.throttle_on) {
#line 318
              if (MB_per_sec < info.throttle) {
                {
                {
#line 319
                write_log(0, (char *)"Bandwidth [%f] back below limit [%f], allowing access",
                          MB_per_sec, info.throttle);
                }
#line 321
                info.throttle_on = 0;
                }
              }
            }
          }
        }
        {
        {
#line 326
        get_running_stats(trotstat);
        }
        {
#line 327
        *trottime = get_time();
        }
        }
      }
    }
  }
#line 331
  return;
}
}
#line 333 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void timer_kick_abandoned_relays(time_t stime___0 ) 
{ 
  avl_traverser trav ;
  connection_t *sourcecon ;
  long tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 336
  if (stime___0 % 100L == 0L) {
#line 336
    if (info.kick_relays) {
      {
#line 337
      trav.init = 0;
#line 337
      trav.nstack = 0;
#line 337
      trav.p = (avl_node const   *)0;
#line 337
      trav.stack[0] = (avl_node const   *)0;
#line 337
      trav.stack[1] = (avl_node const   *)0;
#line 337
      trav.stack[2] = (avl_node const   *)0;
#line 337
      trav.stack[3] = (avl_node const   *)0;
#line 337
      trav.stack[4] = (avl_node const   *)0;
#line 337
      trav.stack[5] = (avl_node const   *)0;
#line 337
      trav.stack[6] = (avl_node const   *)0;
#line 337
      trav.stack[7] = (avl_node const   *)0;
#line 337
      trav.stack[8] = (avl_node const   *)0;
#line 337
      trav.stack[9] = (avl_node const   *)0;
#line 337
      trav.stack[10] = (avl_node const   *)0;
#line 337
      trav.stack[11] = (avl_node const   *)0;
#line 337
      trav.stack[12] = (avl_node const   *)0;
#line 337
      trav.stack[13] = (avl_node const   *)0;
#line 337
      trav.stack[14] = (avl_node const   *)0;
#line 337
      trav.stack[15] = (avl_node const   *)0;
#line 337
      trav.stack[16] = (avl_node const   *)0;
#line 337
      trav.stack[17] = (avl_node const   *)0;
#line 337
      trav.stack[18] = (avl_node const   *)0;
#line 337
      trav.stack[19] = (avl_node const   *)0;
#line 337
      trav.stack[20] = (avl_node const   *)0;
#line 337
      trav.stack[21] = (avl_node const   *)0;
#line 337
      trav.stack[22] = (avl_node const   *)0;
#line 337
      trav.stack[23] = (avl_node const   *)0;
#line 337
      trav.stack[24] = (avl_node const   *)0;
#line 337
      trav.stack[25] = (avl_node const   *)0;
#line 337
      trav.stack[26] = (avl_node const   *)0;
#line 337
      trav.stack[27] = (avl_node const   *)0;
#line 337
      trav.stack[28] = (avl_node const   *)0;
#line 337
      trav.stack[29] = (avl_node const   *)0;
#line 337
      trav.stack[30] = (avl_node const   *)0;
#line 337
      trav.stack[31] = (avl_node const   *)0;
      {
#line 340
      thread_mutex_lock_c(& info.source_mutex, 340, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      }
      {
      {
#line 341
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
        {
        {
#line 341
        tmp___0 = avl_traverse(info.sources, & trav);
        }
#line 341
        sourcecon = (connection_t *)tmp___0;
        }
#line 341
        if (! sourcecon) {
#line 341
          goto while_break;
        }
#line 342
        if ((int )(sourcecon->food.source)->type == 2) {
#line 342
          if ((sourcecon->food.source)->num_clients <= 0UL) {
#line 342
            if ((sourcecon->food.source)->connected == 1) {
              {
              {
#line 342
              tmp = get_time();
              }
              }
#line 342
              if (tmp - sourcecon->connect_time > (long )info.kick_relays) {
                {
                {
#line 346
                kick_connection((void *)sourcecon, (void *)"Closing relay [saving bandwidth]");
                }
                }
              }
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 349
      thread_mutex_unlock_c(& info.source_mutex, 349, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      }
    }
  }
#line 351
  return;
}
}
#line 353 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_hourly_stats(statistics_t *stat___0 ) 
{ 


  {
#line 355
  stat___0->read_bytes = info.hourly_stats.read_bytes;
#line 356
  stat___0->write_bytes = info.hourly_stats.write_bytes;
#line 357
  stat___0->client_connections = info.hourly_stats.client_connections;
#line 358
  stat___0->source_connections = info.hourly_stats.source_connections;
#line 359
  stat___0->client_connect_time = info.hourly_stats.client_connect_time;
#line 360
  stat___0->source_connect_time = info.hourly_stats.source_connect_time;
#line 361
  return;
}
}
#line 363 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void write_hourly_stats(statistics_t *stat___0 ) 
{ 
  char cct[8192] ;
  char sct[8192] ;
  char timebuf[8192] ;
  statistics_t running___0 ;
  char *tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 369
  get_current_stats(& running___0);
  }
  {
#line 370
  add_stats(stat___0, & running___0, 0UL);
  }
  {
#line 372
  tmp = connect_average(stat___0->client_connect_time, stat___0->client_connections + info.num_clients,
                        timebuf);
  }
  {
#line 372
  strncpy((char */* __restrict  */)(cct), (char const   */* __restrict  */)tmp, (size_t )8192);
  }
  {
#line 373
  tmp___0 = connect_average(stat___0->source_connect_time, stat___0->source_connections + info.num_sources,
                            timebuf);
  }
  {
#line 373
  strncpy((char */* __restrict  */)(sct), (char const   */* __restrict  */)tmp___0,
          (size_t )8192);
  }
  {
#line 375
  write_log(1, (char *)"Hourly statistics: [Client connects: %lu] [Source connects: %lu] [Bytes read: %lu] [Bytes written: %lu]",
            stat___0->client_connections, stat___0->source_connections, stat___0->read_bytes,
            stat___0->write_bytes);
  }
  {
#line 377
  tmp___1 = transfer_average(stat___0->read_bytes, stat___0->source_connections);
  }
  {
#line 377
  tmp___2 = transfer_average(stat___0->write_bytes, stat___0->client_connections);
  }
  {
#line 377
  write_log(1, (char *)"Hourly averages: [Client transfer: %lu bytes] [Source transfer: %lu] [Client connect time: %s] [Source connect time: %s]",
            tmp___2, tmp___1, cct, sct);
  }
  }
#line 380
  return;
}
}
#line 382 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void update_daily_statistics(statistics_t *stat___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 384
  thread_mutex_lock_c(& info.misc_mutex, 384, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
#line 385
  info.daily_stats.read_bytes += stat___0->read_bytes / 1000UL;
#line 386
  info.daily_stats.write_bytes += stat___0->write_bytes / 1000UL;
#line 387
  info.daily_stats.client_connections += stat___0->client_connections;
#line 388
  info.daily_stats.source_connections += stat___0->source_connections;
#line 389
  info.daily_stats.client_connect_time += stat___0->client_connect_time;
#line 390
  info.daily_stats.source_connect_time += stat___0->source_connect_time;
  {
#line 391
  thread_mutex_unlock_c(& info.misc_mutex, 391, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 392
  return;
}
}
#line 394 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_daily_stats(statistics_t *stat___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 396
  thread_mutex_lock_c(& info.misc_mutex, 396, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
#line 397
  stat___0->read_bytes = info.daily_stats.read_bytes;
#line 398
  stat___0->write_bytes = info.daily_stats.write_bytes;
#line 399
  stat___0->client_connections = info.daily_stats.client_connections;
#line 400
  stat___0->source_connections = info.daily_stats.source_connections;
#line 401
  stat___0->client_connect_time = info.daily_stats.client_connect_time;
#line 402
  stat___0->source_connect_time = info.daily_stats.source_connect_time;
  {
#line 403
  thread_mutex_unlock_c(& info.misc_mutex, 403, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 404
  return;
}
}
#line 406 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void update_total_statistics(statistics_t *stat___0 ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 408
  thread_mutex_lock_c(& info.misc_mutex, 408, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
#line 409
  info.total_stats.read_bytes += stat___0->read_bytes / 1000UL;
#line 410
  info.total_stats.write_bytes += stat___0->write_bytes / 1000UL;
#line 411
  info.total_stats.client_connections += stat___0->client_connections;
#line 412
  info.total_stats.source_connections += stat___0->source_connections;
#line 413
  info.total_stats.client_connect_time += stat___0->client_connect_time;
#line 414
  info.total_stats.source_connect_time += stat___0->source_connect_time;
  {
#line 415
  thread_mutex_unlock_c(& info.misc_mutex, 415, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 416
  return;
}
}
#line 418 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void write_daily_stats(statistics_t *stat___0 ) 
{ 
  char cct[8192] ;
  char sct[8192] ;
  statistics_t running___0 ;
  char timebuf[8192] ;
  char *tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 424
  get_current_stats(& running___0);
  }
  {
#line 425
  add_stats(stat___0, & running___0, 0UL);
  }
  {
#line 427
  tmp = connect_average(stat___0->client_connect_time, stat___0->client_connections + info.num_clients,
                        timebuf);
  }
  {
#line 427
  strncpy((char */* __restrict  */)(cct), (char const   */* __restrict  */)tmp, (size_t )8192);
  }
  {
#line 428
  tmp___0 = connect_average(stat___0->source_connect_time, stat___0->source_connections + info.num_sources,
                            timebuf);
  }
  {
#line 428
  strncpy((char */* __restrict  */)(sct), (char const   */* __restrict  */)tmp___0,
          (size_t )8192);
  }
  {
#line 430
  write_log(1, (char *)"Daily statistics: [Client connects: %lu] [Source connects: %lu] [Kbytes read: %lu] [Kbytes written: %lu]",
            stat___0->client_connections, stat___0->source_connections, stat___0->read_bytes,
            stat___0->write_bytes);
  }
  {
#line 432
  tmp___1 = transfer_average(stat___0->read_bytes, stat___0->source_connections);
  }
  {
#line 432
  tmp___2 = transfer_average(stat___0->write_bytes, stat___0->client_connections);
  }
  {
#line 432
  write_log(1, (char *)"Daily averages: [Client transfer: %lu Kbytes] [Source transfer: %lu Kbytes] [Client connect time: %s] [Source connect time: %s]",
            tmp___2, tmp___1, cct, sct);
  }
  }
#line 435
  return;
}
}
#line 437 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_current_stats(statistics_t *stat___0 ) 
{ 


  {
  {
  {
#line 439
  get_current_stats_proc(stat___0, 1);
  }
  }
#line 440
  return;
}
}
#line 442 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_current_stats_proc(statistics_t *stat___0 , int lock ) 
{ 
  avl_traverser trav ;
  time_t ec ;
  time_t cc ;
  connection_t *travcon ;
  time_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 444
  trav.init = 0;
#line 444
  trav.nstack = 0;
#line 444
  trav.p = (avl_node const   *)0;
#line 444
  trav.stack[0] = (avl_node const   *)0;
#line 444
  trav.stack[1] = (avl_node const   *)0;
#line 444
  trav.stack[2] = (avl_node const   *)0;
#line 444
  trav.stack[3] = (avl_node const   *)0;
#line 444
  trav.stack[4] = (avl_node const   *)0;
#line 444
  trav.stack[5] = (avl_node const   *)0;
#line 444
  trav.stack[6] = (avl_node const   *)0;
#line 444
  trav.stack[7] = (avl_node const   *)0;
#line 444
  trav.stack[8] = (avl_node const   *)0;
#line 444
  trav.stack[9] = (avl_node const   *)0;
#line 444
  trav.stack[10] = (avl_node const   *)0;
#line 444
  trav.stack[11] = (avl_node const   *)0;
#line 444
  trav.stack[12] = (avl_node const   *)0;
#line 444
  trav.stack[13] = (avl_node const   *)0;
#line 444
  trav.stack[14] = (avl_node const   *)0;
#line 444
  trav.stack[15] = (avl_node const   *)0;
#line 444
  trav.stack[16] = (avl_node const   *)0;
#line 444
  trav.stack[17] = (avl_node const   *)0;
#line 444
  trav.stack[18] = (avl_node const   *)0;
#line 444
  trav.stack[19] = (avl_node const   *)0;
#line 444
  trav.stack[20] = (avl_node const   *)0;
#line 444
  trav.stack[21] = (avl_node const   *)0;
#line 444
  trav.stack[22] = (avl_node const   *)0;
#line 444
  trav.stack[23] = (avl_node const   *)0;
#line 444
  trav.stack[24] = (avl_node const   *)0;
#line 444
  trav.stack[25] = (avl_node const   *)0;
#line 444
  trav.stack[26] = (avl_node const   *)0;
#line 444
  trav.stack[27] = (avl_node const   *)0;
#line 444
  trav.stack[28] = (avl_node const   *)0;
#line 444
  trav.stack[29] = (avl_node const   *)0;
#line 444
  trav.stack[30] = (avl_node const   *)0;
#line 444
  trav.stack[31] = (avl_node const   *)0;
#line 445
  ec = (time_t )0;
#line 445
  cc = (time_t )0;
  {
#line 448
  zero_stats(stat___0);
  }
  }
#line 451
  if (lock) {
    {
    {
#line 452
    thread_mutex_lock_c(& info.double_mutex, 452, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
  {
  {
#line 453
  thread_mutex_lock_c(& info.source_mutex, 453, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  {
#line 455
  tmp = tree_time(info.sources);
  }
#line 455
  ec = tmp;
  }
  {
  {
#line 456
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 456
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 456
    travcon = (connection_t *)tmp___1;
    }
#line 456
    if (! travcon) {
#line 456
      goto while_break;
    }
    {
    {
#line 457
    thread_mutex_lock_c(& (travcon->food.source)->mutex, 457, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    {
#line 458
    tmp___0 = tree_time((travcon->food.source)->clients);
    }
#line 458
    cc += tmp___0;
    {
#line 459
    thread_mutex_unlock_c(& (travcon->food.source)->mutex, 459, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 462
  thread_mutex_unlock_c(& info.source_mutex, 462, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 464
  if (lock) {
    {
    {
#line 465
    thread_mutex_unlock_c(& info.double_mutex, 465, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
#line 467
  stat___0->client_connect_time = (unsigned long )cc;
#line 468
  stat___0->source_connect_time = (unsigned long )ec;
#line 469
  return;
}
}
#line 471 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_running_stats(statistics_t *stat___0 ) 
{ 


  {
  {
  {
#line 473
  get_running_stats_proc(stat___0, 1);
  }
  }
#line 474
  return;
}
}
#line 476 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_running_stats_nl(statistics_t *stat___0 ) 
{ 


  {
  {
  {
#line 478
  get_running_stats_proc(stat___0, 0);
  }
  }
#line 479
  return;
}
}
#line 481 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void get_running_stats_proc(statistics_t *stat___0 , int lock ) 
{ 
  statistics_t bufstat ;

  {
  {
#line 486
  stat___0->read_bytes = info.total_stats.read_bytes;
#line 487
  stat___0->read_megs = info.total_stats.read_megs;
#line 488
  stat___0->write_bytes = info.total_stats.write_bytes;
#line 489
  stat___0->write_megs = info.total_stats.write_megs;
#line 490
  stat___0->client_connections = info.total_stats.client_connections;
#line 491
  stat___0->source_connections = info.total_stats.source_connections;
#line 492
  stat___0->client_connect_time = info.total_stats.client_connect_time;
#line 493
  stat___0->source_connect_time = info.total_stats.source_connect_time;
  {
#line 496
  get_current_stats_proc(& bufstat, lock);
  }
  {
#line 497
  add_stats(stat___0, & bufstat, 0UL);
  }
  {
#line 500
  get_hourly_stats(& bufstat);
  }
  {
#line 501
  add_stats(stat___0, & bufstat, 0UL);
  }
  {
#line 504
  get_daily_stats(& bufstat);
  }
  {
#line 505
  add_stats(stat___0, & bufstat, 1000UL);
  }
  }
#line 506
  return;
}
}
#line 508 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void zero_stats(statistics_t *stat___0 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 510
  if (! stat___0) {
    {
    {
#line 511
    write_log(0, (char *)"WARNING: zero_stats() called with NULL stat pointer");
    }
    }
#line 512
    return;
  }
#line 515
  stat___0->read_bytes = 0UL;
#line 516
  stat___0->read_megs = 0UL;
#line 517
  stat___0->write_bytes = 0UL;
#line 518
  stat___0->write_megs = 0UL;
#line 519
  stat___0->client_connections = 0UL;
#line 520
  stat___0->source_connections = 0UL;
#line 521
  stat___0->client_connect_time = 0UL;
#line 522
  stat___0->source_connect_time = 0UL;
#line 523
  return;
}
}
#line 525 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void add_stats(statistics_t *target , statistics_t *source , unsigned long factor ) 
{ 
  double div___0 ;

  {
#line 529
  if (factor == 0UL) {
#line 530
    div___0 = 1000000.0;
  } else {
#line 532
    div___0 = 1000000.0 / (double )factor;
  }
#line 534
  target->read_bytes += (unsigned long )((double )source->read_bytes / div___0);
#line 535
  target->write_bytes += (unsigned long )((double )source->write_bytes / div___0);
#line 536
  target->client_connections += source->client_connections;
#line 537
  target->client_connect_time += source->client_connect_time;
#line 538
  target->source_connections += source->source_connections;
#line 539
  target->source_connect_time += source->source_connect_time;
#line 540
  return;
}
}
#line 542 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void display_stats(statistics_t *stat___0 ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 544
  xa_debug(1, (char *)"DEBUG: rb: %lu wb: %lu", stat___0->read_bytes, stat___0->write_bytes);
  }
  }
#line 545
  return;
}
}
#line 547 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void *startup_udp_info_thread(void *arg ) 
{ 
  SOCKET sends ;
  avl_traverser trav ;
  avl_traverser sourcetrav ;
  connection_t *clicon ;
  connection_t *sourcecon ;
  struct sockaddr_in serv ;
  struct sockaddr_in *recv_addr ;
  socklen_t sinlen ;
  socklen_t outlen ;
  char buf[8192] ;
  mythread_t *mt ;
  void *tmp ;
  int tmp___0 ;
  time_t stime___0 ;
  long tmp___1 ;
  int n ;
  ssize_t tmp___2 ;
  char *seqnr ;
  char *tmp___3 ;
  connection_t *updatecon ;
  connection_t *tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  char hbuf[8192] ;
  char *hostptr ;
  char *portptr ;
  char *tmp___7 ;
  connection_t *updatecon___0 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  time_t t ;
  long tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 550
  trav.init = 0;
#line 550
  trav.nstack = 0;
#line 550
  trav.p = (avl_node const   *)0;
#line 550
  trav.stack[0] = (avl_node const   *)0;
#line 550
  trav.stack[1] = (avl_node const   *)0;
#line 550
  trav.stack[2] = (avl_node const   *)0;
#line 550
  trav.stack[3] = (avl_node const   *)0;
#line 550
  trav.stack[4] = (avl_node const   *)0;
#line 550
  trav.stack[5] = (avl_node const   *)0;
#line 550
  trav.stack[6] = (avl_node const   *)0;
#line 550
  trav.stack[7] = (avl_node const   *)0;
#line 550
  trav.stack[8] = (avl_node const   *)0;
#line 550
  trav.stack[9] = (avl_node const   *)0;
#line 550
  trav.stack[10] = (avl_node const   *)0;
#line 550
  trav.stack[11] = (avl_node const   *)0;
#line 550
  trav.stack[12] = (avl_node const   *)0;
#line 550
  trav.stack[13] = (avl_node const   *)0;
#line 550
  trav.stack[14] = (avl_node const   *)0;
#line 550
  trav.stack[15] = (avl_node const   *)0;
#line 550
  trav.stack[16] = (avl_node const   *)0;
#line 550
  trav.stack[17] = (avl_node const   *)0;
#line 550
  trav.stack[18] = (avl_node const   *)0;
#line 550
  trav.stack[19] = (avl_node const   *)0;
#line 550
  trav.stack[20] = (avl_node const   *)0;
#line 550
  trav.stack[21] = (avl_node const   *)0;
#line 550
  trav.stack[22] = (avl_node const   *)0;
#line 550
  trav.stack[23] = (avl_node const   *)0;
#line 550
  trav.stack[24] = (avl_node const   *)0;
#line 550
  trav.stack[25] = (avl_node const   *)0;
#line 550
  trav.stack[26] = (avl_node const   *)0;
#line 550
  trav.stack[27] = (avl_node const   *)0;
#line 550
  trav.stack[28] = (avl_node const   *)0;
#line 550
  trav.stack[29] = (avl_node const   *)0;
#line 550
  trav.stack[30] = (avl_node const   *)0;
#line 550
  trav.stack[31] = (avl_node const   *)0;
#line 550
  sourcetrav.init = 0;
#line 550
  sourcetrav.nstack = 0;
#line 550
  sourcetrav.p = (avl_node const   *)0;
#line 550
  sourcetrav.stack[0] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[1] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[2] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[3] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[4] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[5] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[6] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[7] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[8] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[9] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[10] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[11] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[12] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[13] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[14] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[15] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[16] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[17] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[18] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[19] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[20] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[21] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[22] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[23] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[24] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[25] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[26] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[27] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[28] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[29] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[30] = (avl_node const   *)0;
#line 550
  sourcetrav.stack[31] = (avl_node const   *)0;
  {
#line 557
  thread_init();
  }
  {
#line 559
  mt = thread_get_mythread();
  }
#line 561
  sinlen = (socklen_t )sizeof(serv);
#line 561
  outlen = sinlen;
  {
#line 563
  tmp = n_malloc((unsigned int const   )sizeof(struct sockaddr_in ), (int const   )563,
                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
#line 563
  recv_addr = (struct sockaddr_in *)tmp;
  {
#line 565
  memset((void *)(& serv), 0, sinlen);
  }
  {
#line 566
  memset((void *)recv_addr, 0, sinlen);
  }
#line 568
  serv.sin_family = (sa_family_t )2;
  {
#line 569
  serv.sin_addr.s_addr = htonl((in_addr_t )0);
  }
  {
#line 570
  serv.sin_port = htons((uint16_t )info.port[0]);
  }
  {
#line 572
  sends = sock_create_udp_socket();
  }
  }
#line 572
  if (sends < 0) {
    {
    {
#line 573
    write_log(0, (char *)"ERROR: Cannot create a udp socket for sending metainfo, shutting down udp traffic");
    }
    {
#line 574
    thread_exit_c(0L, 574, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
  {
  {
#line 577
  tmp___0 = bind(sends, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& serv)),
                 sinlen);
  }
  }
#line 577
  if (tmp___0 < 0) {
    {
    {
#line 578
    write_log(0, (char *)"ERROR: Bind to udp interface failed, shutting down udp traffic");
    }
    {
#line 579
    thread_exit_c(0L, 579, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
    }
    }
  }
  {
  {
#line 582
  sock_set_blocking(sends, (int const   )1);
  }
  }
  {
  {
#line 584
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 584
    tmp___17 = thread_alive(mt);
    }
    }
#line 584
    if (! tmp___17) {
#line 584
      goto while_break;
    }
    {
    {
#line 585
    tmp___1 = get_time();
    }
#line 585
    stime___0 = tmp___1;
    {
#line 587
    tmp___2 = recvfrom(sends, (void */* __restrict  */)(buf), (size_t )8191, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)recv_addr),
                       (socklen_t */* __restrict  */)(& outlen));
    }
#line 587
    n = tmp___2;
    }
#line 589
    if (mt->ping == 1) {
#line 590
      mt->ping = 0;
    }
#line 592
    if (n > 0) {
      {
#line 593
      buf[n] = (char )'\000';
      {
#line 594
      tmp___12 = strstr((char const   *)(buf), "PING");
      }
      }
#line 594
      if (tmp___12) {
        {
        {
#line 595
        sendto(sends, (void const   *)(buf), (size_t )n, 64, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)recv_addr),
               outlen);
        }
        {
#line 596
        xa_debug(1, (char *)"DEBUG: echoed back [%s]", buf);
        }
        }
      } else {
        {
        {
#line 597
        tmp___11 = strstr((char const   *)(buf), "x-audiocast-ack:");
        }
        }
#line 597
        if (tmp___11) {
          {
          {
#line 598
          tmp___3 = strchr((char const   *)(buf), ':');
          }
#line 598
          seqnr = tmp___3;
          }
#line 599
          if (seqnr) {
            {
            {
#line 600
            tmp___4 = find_con_with_host((struct sockaddr_in  const  *)recv_addr);
            }
#line 600
            updatecon = tmp___4;
            }
#line 602
            if (updatecon) {
#line 602
              if ((unsigned int )updatecon->type == 0U) {
#line 602
                if (updatecon->food.client) {
                  {
                  {
#line 603
                  tmp___5 = atol((char const   *)(seqnr + 1));
                  }
#line 603
                  (updatecon->food.client)->udpseqnr = (unsigned long )tmp___5;
                  {
#line 604
                  tmp___6 = con_host(updatecon);
                  }
                  {
#line 604
                  xa_debug(3, (char *)"DEBUG: Received ack from %s", tmp___6);
                  }
                  }
                } else {
                  {
                  {
#line 606
                  xa_debug(1, (char *)"Warning: udp ack from unknown client connection");
                  }
                  }
                }
              } else {
                {
                {
#line 606
                xa_debug(1, (char *)"Warning: udp ack from unknown client connection");
                }
                }
              }
            } else {
              {
              {
#line 606
              xa_debug(1, (char *)"Warning: udp ack from unknown client connection");
              }
              }
            }
          }
        } else {
          {
          {
#line 609
          tmp___10 = strstr((char const   *)(buf), "x-audiocast-udpport");
          }
          }
#line 609
          if (tmp___10) {
            {
            {
#line 611
            tmp___7 = strchr((char const   *)(buf), ':');
            }
#line 611
            portptr = tmp___7;
            }
#line 613
            if (portptr) {
              {
              {
#line 614
              tmp___8 = atoi((char const   *)(portptr + 1));
              }
              {
#line 614
              xa_debug(2, (char *)"DEBUG: udp port change from %d to %d", tmp___8,
                       (int )recv_addr->sin_port);
              }
              {
#line 617
              hostptr = makeasciihost((struct in_addr  const  *)(& recv_addr->sin_addr),
                                      hbuf);
              }
              {
#line 618
              tmp___9 = atoi((char const   *)(portptr + 1));
              }
              {
#line 618
              updatecon___0 = find_con_with_host_and_udpport((char const   *)hostptr,
                                                             (int const   )tmp___9);
              }
              }
#line 619
              if (! updatecon___0) {
                {
                {
#line 620
                xa_debug(1, (char *)"DEBUG: Invalid port change from [%s]", hostptr);
                }
                }
              } else {
#line 622
                (updatecon___0->sin)->sin_port = recv_addr->sin_port;
#line 623
                if ((unsigned int )updatecon___0->type == 0U) {
#line 623
                  if (updatecon___0->food.client) {
#line 623
                    if ((updatecon___0->food.client)->udpseqnr > 0UL) {
#line 624
                      ((updatecon___0->food.client)->udpseqnr) --;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 630
    if (stime___0 - info.udpupdatelasttime >= (time_t )info.udpupdatetime) {
      {
      {
#line 632
      thread_mutex_lock_c(& info.double_mutex, 632, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      {
#line 633
      thread_mutex_lock_c(& info.source_mutex, 633, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      {
#line 634
      zero_trav(& sourcetrav);
      }
      }
      {
      {
#line 635
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
        {
        {
#line 635
        tmp___16 = avl_traverse(info.sources, & sourcetrav);
        }
#line 635
        sourcecon = (connection_t *)tmp___16;
        }
#line 635
        if (! sourcecon) {
#line 635
          goto while_break___0;
        }
        {
        {
#line 636
        tmp___13 = get_time();
        }
#line 636
        t = tmp___13;
        }
#line 637
        if (sourcecon) {
#line 637
          if (sourcecon->food.source) {
#line 637
            if ((sourcecon->food.source)->connected == 1) {
              {
              {
#line 638
              zero_trav(& trav);
              }
              {
#line 639
              thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 639, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
              }
              }
              {
              {
#line 640
              while (1) {
                while_continue___4: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
                {
                {
#line 640
                tmp___15 = avl_traverse((sourcecon->food.source)->clients, & trav);
                }
#line 640
                clicon = (connection_t *)tmp___15;
                }
#line 640
                if (! clicon) {
#line 640
                  goto while_break___1;
                }
                {
                {
#line 642
                tmp___14 = client_wants_udp_info(clicon);
                }
                }
#line 642
                if (tmp___14) {
#line 642
                  if (t - clicon->connect_time > 5L) {
#line 642
                    if ((clicon->food.client)->udpseqnr < (sourcecon->food.source)->info.udpseqnr) {
                      {
                      {
#line 644
                      udp_update_metainfo(sends, sourcecon, clicon);
                      }
                      }
                    }
                  }
                }
              }
              while_break___4: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
              {
              {
#line 646
              thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 646, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
              }
              }
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 649
      thread_mutex_unlock_c(& info.source_mutex, 649, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      {
#line 650
      thread_mutex_unlock_c(& info.double_mutex, 650, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
      }
      }
    }
    {
    {
#line 653
    my_sleep(500000);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 656
  thread_exit_c(2L, 656, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 657
  return ((void *)0);
}
}
#line 660 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void *startup_relay_connector_thread(void *arg ) 
{ 
  mythread_t *mt ;
  mythread_t *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 664
  if (! info.relays) {
    {
    {
#line 665
    write_log(0, (char *)"WARNING: startup_relay_connector_thread(): info.relays is NULL, weeird!");
    }
    }
  }
  {
  {
#line 668
  thread_init();
  }
  {
#line 670
  tmp = thread_get_mythread();
  }
#line 670
  mt = tmp;
  }
  {
  {
#line 672
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 672
    tmp___0 = thread_alive(mt);
    }
    }
#line 672
    if (! tmp___0) {
#line 672
      goto while_break;
    }
    {
    {
#line 674
    relay_connect_all_relays();
    }
    {
#line 675
    my_sleep((info.relay_reconnect_time / 2) * 1000000);
    }
    }
#line 677
    if (mt->ping == 1) {
#line 678
      mt->ping = 0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 681
  thread_exit_c(2L, 681, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 682
  return ((void *)0);
}
}
#line 685 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void *startup_heartbeat_thread(void *arg ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 687
  thread_init();
  }
  {
#line 701
  thread_exit_c(0L, 701, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c");
  }
  }
#line 702
  return ((void *)0);
}
}
#line 712 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void add_fmt_string(char *buf , char const   *fmt , char *val ) 
{ 
  char buf2[256] ;
  size_t tmp ;
  size_t tmp___0 ;
  void *__cil_tmp7 ;

  {
#line 715
  if (! buf) {
#line 716
    return;
  } else
#line 715
  if (! fmt) {
#line 716
    return;
  } else
#line 715
  if (! val) {
#line 716
    return;
  }
  {
  {
#line 718
  tmp = ice_strlen((char const   *)val);
  }
  }
#line 718
  if (tmp > 230U) {
#line 719
    *(val + 230) = (char )'\000';
  }
  {
  {
#line 721
  snprintf((char */* __restrict  */)(buf2), (size_t )256, (char const   */* __restrict  */)fmt,
           val);
  }
  {
#line 722
  tmp___0 = ice_strlen((char const   *)buf);
  }
  {
#line 722
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(buf2), 1023U - tmp___0);
  }
  }
#line 723
  return;
}
}
#line 725 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
void add_fmt_int(char *buf , char const   *fmt , long val ) 
{ 
  char buf2[256] ;
  size_t tmp ;
  void *__cil_tmp6 ;

  {
#line 728
  if (! buf) {
#line 729
    return;
  } else
#line 728
  if (! fmt) {
#line 729
    return;
  }
  {
  {
#line 730
  snprintf((char */* __restrict  */)(buf2), (size_t )256, (char const   */* __restrict  */)fmt,
           val);
  }
  {
#line 731
  tmp = ice_strlen((char const   *)buf);
  }
  {
#line 731
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(buf2), 1023U - tmp);
  }
  }
#line 732
  return;
}
}
#line 734 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/timer.c"
int udp_update_metainfo(SOCKET s , connection_t *sourcecon , connection_t *clicon ) 
{ 
  char buf[1024] ;
  char const   *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 739
  tmp = con_host(clicon);
  }
  {
#line 739
  xa_debug(1, (char *)"Updating metadata for host %s", tmp);
  }
  }
#line 741
  if (! sourcecon) {
    {
    {
#line 742
    xa_debug(1, (char *)"WARNING: udp_update_metainfo: called with NULL pointers");
    }
    }
#line 743
    return (0);
  } else
#line 741
  if (! clicon) {
    {
    {
#line 742
    xa_debug(1, (char *)"WARNING: udp_update_metainfo: called with NULL pointers");
    }
    }
#line 743
    return (0);
  } else {
    {
    {
#line 744
    tmp___0 = sock_valid((SOCKET const   )s);
    }
    }
#line 744
    if (! tmp___0) {
      {
      {
#line 745
      xa_debug(1, (char *)"WARNING: udp_update_metainfo(): called with invalid socket");
      }
      }
#line 746
      return (0);
    }
  }
  {
#line 749
  buf[0] = (char )'\000';
  {
#line 751
  add_fmt_int(buf, "x-audiocast-udpseqnr: %ld\r\n", (long )(sourcecon->food.source)->info.udpseqnr);
  }
  {
#line 752
  add_fmt_string(buf, "x-audiocast-streamtitle: %s\r\n", (sourcecon->food.source)->info.streamtitle);
  }
  {
#line 753
  add_fmt_string(buf, "x-audiocast-streamurl: %s\r\n", (sourcecon->food.source)->info.streamurl);
  }
  {
#line 754
  add_fmt_string(buf, "x-audiocast-streammsg: %s\r\n", (sourcecon->food.source)->info.streammsg);
  }
  {
#line 755
  add_fmt_int(buf, "x-audiocast-streamlength: %ld\r\n", (sourcecon->food.source)->info.streamlength);
  }
  {
#line 757
  tmp___3 = ice_strlen((char const   *)(buf));
  }
  {
#line 757
  tmp___4 = sendto(s, (void const   *)(buf), tmp___3, 64, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)clicon->sin),
                   clicon->sinlen);
  }
  }
#line 757
  if (tmp___4 == -1) {
    {
    {
#line 758
    tmp___1 = __errno_location();
    }
    {
#line 758
    tmp___2 = con_host(clicon);
    }
    {
#line 758
    xa_debug(1, (char *)"WARNING: sendto(%s) failed with [%d]", tmp___2, *tmp___1);
    }
    }
#line 759
    return (0);
  }
#line 762
  return (1);
}
}
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 214 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
#line 34 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char const   *skip_after(char const   *ptr , char const   *search ) ;
#line 35
char const   *skip_before(char const   *ptr , char const   *search ) ;
#line 43 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
int com_admins(com_request_t *req ) ;
#line 43
int com_tail(com_request_t *req ) ;
#line 43
int com_untail(com_request_t *req ) ;
#line 43
int com_sources(com_request_t *req ) ;
#line 43
int com_listeners(com_request_t *req ) ;
#line 43
int com_rehash(com_request_t *req ) ;
#line 43
int com_set(com_request_t *req ) ;
#line 43
int com_sel(com_request_t *req ) ;
#line 43
int com_uptime(com_request_t *req ) ;
#line 43
int com_tell(com_request_t *req ) ;
#line 43
int com_shutdown(com_request_t *req ) ;
#line 43
int com_kick(com_request_t *req ) ;
#line 43
int com_touch(com_request_t *req ) ;
#line 43
int com_dir(com_request_t *req ) ;
#line 43
int com_stats(com_request_t *req ) ;
#line 43
int com_relay(com_request_t *req ) ;
#line 43
int com_list(com_request_t *req ) ;
#line 43
int com_alias(com_request_t *req ) ;
#line 43
int com_threads(com_request_t *req ) ;
#line 43
int com_allow(com_request_t *req ) ;
#line 43
int com_deny(com_request_t *req ) ;
#line 43
int com_pause(com_request_t *req ) ;
#line 43
int com_unpause(com_request_t *req ) ;
#line 43
int com_modify(com_request_t *req ) ;
#line 43
int com_dump(com_request_t *req ) ;
#line 43
int com_locks(com_request_t *req ) ;
#line 43
int com_mem(com_request_t *req ) ;
#line 43
int com_streamtitle(com_request_t *req ) ;
#line 43
int com_streamurl(com_request_t *req ) ;
#line 43
int com_describe(com_request_t *req ) ;
#line 43
int com_acl(com_request_t *req ) ;
#line 43
int com_auth(com_request_t *req ) ;
#line 43
int com_runtime(com_request_t *req ) ;
#line 59
void log_command(char const   *command , com_request_t const   *req ) ;
#line 68
char *com_arg(com_request_t const   *req ) ;
#line 72
comp_element const   *find_comp_element(char const   *name , comp_element const   *el ) ;
#line 76
char *variable_to_string(char *varname ) ;
#line 39 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.h"
int updinfo(connection_t *con , vartree_t *request_vars ) ;
#line 40
void handle_http_admin_command(connection_t *con , vartree_t *request_vars ) ;
#line 41
int http_admin_command(connection_t *con , request_t *req ) ;
#line 42
void display_admin_page(connection_t *con , request_t *req ) ;
#line 44
int print_http_variable(vartree_t *request_vars , char const   *name , connection_t *clicon ,
                        int fd ) ;
#line 47
char *html_escape(char const   *str ) ;
#line 48
char const   *parse_template_file(connection_t *clicon , connection_t *sourcecon ,
                                  char const   *ptr , int fd , vartree_t *variables ) ;
#line 50
char const   *http_loop_sources(char *ident , connection_t *clicon , char const   *ptr ,
                                int fd , vartree_t *variables ) ;
#line 51
char const   *http_loop_admins(char *ident , connection_t *clicon , char const   *ptr ,
                               int fd , vartree_t *variables ) ;
#line 52
char const   *http_loop_listeners(char *ident , connection_t *clicon , char const   *ptr ,
                                  int fd , vartree_t *variables ) ;
#line 53
char const   *http_loop_directory(char *ident , connection_t *clicon , char const   *ptr ,
                                  int fd , vartree_t *variables ) ;
#line 54
char *ice_uptime(void) ;
#line 55
char *ice_starttime(void) ;
#line 56
void const   *get_http_variable(vartree_t *request_vars , char const   *name ) ;
#line 58
void write_401(connection_t *con , char *realm ) ;
#line 59
void write_didnt_find_html_page(connection_t *con , char *file ) ;
#line 60
void display_generic_admin_page(connection_t *con ) ;
#line 62
http_command_t const   *find_http_command(char const   *name , http_command_t const   *el ) ;
#line 63
int http_display(com_request_t *req ) ;
#line 64
void write_no_such_command(connection_t *con , char const   *name ) ;
#line 65
int http_help(com_request_t *req ) ;
#line 66
int http_change(com_request_t *req ) ;
#line 67
void update_metadata_on_relays(connection_t *con , char const   *mount , char const   *song ,
                               char const   *msg , char const   *length , char const   *url ) ;
#line 68
void update_metadata_on_relay(connection_t *con , char const   *mount , char const   *song ,
                              char const   *msg , char const   *length , char const   *url ) ;
#line 69
void http_puke_file_to_socket(SOCKET s , char const   *template_file ) ;
#line 26 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
int authenticate_user_request(connection_t *con , request_t *req ) ;
#line 27
int need_authentication(request_t *req ) ;
#line 90 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
comp_element commands[44] ;
#line 92 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_command_t http_commands[37]  = 
#line 92
  {      {(char *)"alias", & com_alias, 0, (char *)((void *)0)}, 
        {(char *)"allow", & com_allow, 0, (char *)((void *)0)}, 
        {(char *)"deny", & com_deny, 0, (char *)((void *)0)}, 
        {(char *)"acl", & com_acl, 0, (char *)((void *)0)}, 
        {(char *)"admins", & com_admins, 0, (char *)((void *)0)}, 
        {(char *)"dir", & com_dir, 0, (char *)((void *)0)}, 
        {(char *)"dump", & com_dump, 0, (char *)((void *)0)}, 
        {(char *)"help", (icecast_function *)(& http_help), 1, (char *)((void *)0)}, 
        {(char *)"kick", & com_kick, 0, (char *)((void *)0)}, 
        {(char *)"listeners", & com_listeners, 0, (char *)((void *)0)}, 
        {(char *)"modify", & com_modify, 0, (char *)((void *)0)}, 
        {(char *)"pause", & com_pause, 0, (char *)((void *)0)}, 
        {(char *)"rehash", & com_rehash, 0, (char *)((void *)0)}, 
        {(char *)"select", & com_sel, 0, (char *)((void *)0)}, 
        {(char *)"sources", & com_sources, 0, (char *)((void *)0)}, 
        {(char *)"shutdown", & com_shutdown, 0, (char *)((void *)0)}, 
        {(char *)"set", & com_set, 0, (char *)((void *)0)}, 
        {(char *)"stats", & com_stats, 0, (char *)((void *)0)}, 
        {(char *)"tail", & com_tail, 0, (char *)((void *)0)}, 
        {(char *)"tell", & com_tell, 0, (char *)((void *)0)}, 
        {(char *)"touch", & com_touch, 0, (char *)((void *)0)}, 
        {(char *)"unpause", & com_unpause, 0, (char *)((void *)0)}, 
        {(char *)"untail", & com_untail, 0, (char *)((void *)0)}, 
        {(char *)"uptime", & com_uptime, 0, (char *)((void *)0)}, 
        {(char *)"list", & com_list, 0, (char *)((void *)0)}, 
        {(char *)"relay", & com_relay, 0, (char *)((void *)0)}, 
        {(char *)"threads", & com_threads, 0, (char *)((void *)0)}, 
        {(char *)"locks", & com_locks, 0, (char *)((void *)0)}, 
        {(char *)"mem", & com_mem, 0, (char *)((void *)0)}, 
        {(char *)"streamtitle", & com_streamtitle, 0, (char *)((void *)0)}, 
        {(char *)"streamurl", & com_streamurl, 0, (char *)((void *)0)}, 
        {(char *)"describe", & com_describe, 0, (char *)((void *)0)}, 
        {(char *)"auth", & com_auth, 0, (char *)((void *)0)}, 
        {(char *)"server_info", & com_runtime, 0, (char *)((void *)0)}, 
        {(char *)"display", (icecast_function *)(& http_display), 0, (char *)((void *)0)}, 
        {(char *)"change",
      (icecast_function *)(& http_change), 0, (char *)((void *)0)}, 
        {(char *)((void *)0), (icecast_function *)((void *)0), 0, (char *)((void *)0)}};
#line 135 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_variable_t http_variables[23]  = 
#line 135
  {      {(char *)"PORT", (type_t )0, (void *)(& info.port[0])}, 
        {(char *)"SOURCES", (type_t )0, (void *)(& info.num_sources)}, 
        {(char *)"LISTENERS", (type_t )0, (void *)(& info.num_clients)}, 
        {(char *)"MAXSOURCES", (type_t )0, (void *)(& info.max_sources)}, 
        {(char *)"MAXLISTENERS", (type_t )0, (void *)(& info.max_clients)}, 
        {(char *)"MAXLISTENERSPERSOURCE", (type_t )0, (void *)(& info.max_clients_per_source)}, 
        {(char *)"ADMINS",
      (type_t )0, (void *)(& info.num_admins)}, 
        {(char *)"MAXADMINS", (type_t )0, (void *)(& info.max_admins)}, 
        {(char *)"STATICDIR", (type_t )2, (void *)(& info.staticdir)}, 
        {(char *)"CONFIGFILE", (type_t )2, (void *)(& info.configfile)}, 
        {(char *)"LOGFILE", (type_t )2, (void *)(& info.logfile)}, 
        {(char *)"STATSFILE", (type_t )2, (void *)(& info.statsfile)}, 
        {(char *)"SERVERNAME", (type_t )2, (void *)(& info.server_name)}, 
        {(char *)"THROTTLE", (type_t )1, (void *)(& info.throttle)}, 
        {(char *)"BANDWIDTH", (type_t )1, (void *)(& info.bandwidth_usage)}, 
        {(char *)"LOCATION", (type_t )2, (void *)(& info.location)}, 
        {(char *)"RPEMAIL", (type_t )2, (void *)(& info.rp_email)}, 
        {(char *)"URL", (type_t )2, (void *)(& info.server_url)}, 
        {(char *)"HOSTNAME", (type_t )2, (void *)(& info.myhostname)}, 
        {(char *)"CLIENT_TIMEOUT", (type_t )0, (void *)(& info.client_timeout)}, 
        {(char *)"UPTIME", (type_t )3, (void *)(& ice_uptime)}, 
        {(char *)"STARTTIME", (type_t )3, (void *)(& ice_starttime)}, 
        {(char *)((void *)0), (type_t )0, (void *)0}};
#line 163
char const   *http_foreach(char *command , connection_t *clicon , connection_t *sourcecon ,
                           char const   *ptr , int fd , vartree_t *variables ) ;
#line 164
char const   *http_include(char *command , connection_t *clicon , connection_t *sourcecon ,
                           char const   *ptr , int fd , vartree_t *variables ) ;
#line 165
char const   *http_even(char *command , connection_t *clicon , connection_t *sourcecon ,
                        char const   *ptr , int fd , vartree_t *variables ) ;
#line 165
char const   *http_odd(char *command , connection_t *clicon , connection_t *sourcecon ,
                       char const   *ptr , int fd , vartree_t *variables ) ;
#line 166
void wrap_http_function(http_command_t const   *http_command , com_request_t *req ,
                        comp_element const   *command ) ;
#line 169 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_parsable_t http_parsables[5]  = {      {(char *)"FOREACH", & http_foreach}, 
        {(char *)"INCLUDE", & http_include}, 
        {(char *)"EVEN", & http_even}, 
        {(char *)"ODD", & http_odd}, 
        {(char *)((void *)0), (HttpFunction *)((void *)0)}};
#line 178 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void write_http_code_page(connection_t *con , int code , char const   *msg ) 
{ 
  char template_file[8192] ;
  char *filename ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 184
  snprintf((char */* __restrict  */)(template_file), (size_t )8192, (char const   */* __restrict  */)"%d.html",
           code);
  }
  {
#line 185
  filename = get_template((char const   *)(template_file));
  }
  {
#line 187
  write_http_header(con->sock, code, msg);
  }
  {
#line 188
  sock_write_line(con->sock, "Connection: close");
  }
  {
#line 189
  sock_write_line(con->sock, "Content-Type: text/html\r\n");
  }
  }
#line 191
  if (filename) {
    {
    {
#line 193
    write_template_parsed_html_page(con, (connection_t *)((void *)0), (char const   *)filename,
                                    -2, (vartree_t *)((void *)0));
    }
    {
#line 194
    n_free((void *)filename, (int const   )194, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 194
    filename = (char *)((void *)0);
    }
#line 195
    return;
  }
  {
  {
#line 198
  sock_write_line(con->sock, "<html><head><title>%d %s</title></head>%s", code, msg,
                  "<body bgcolor=black text=white link=blue alink=red>");
  }
  {
#line 199
  sock_write_line(con->sock, "%d %s", code, msg);
  }
  {
#line 200
  sock_write_line(con->sock, "</body></html>");
  }
  }
#line 201
  return;
}
}
#line 203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void write_401(connection_t *con , char *realm ) 
{ 
  char *filename ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 206
  tmp = get_template("401.html");
  }
#line 206
  filename = tmp;
  {
#line 207
  write_http_header(con->sock, 401, "Unauthorized");
  }
  {
#line 208
  sock_write_line(con->sock, "WWW-Authenticate: Basic realm=\"%s\"", realm);
  }
  {
#line 209
  sock_write_line(con->sock, "Content-Type: text/html");
  }
  {
#line 210
  sock_write_line(con->sock, "Connection: close\r\n");
  }
  }
#line 212
  if (filename) {
    {
    {
#line 214
    write_template_parsed_html_page(con, (connection_t *)((void *)0), (char const   *)filename,
                                    -2, (vartree_t *)((void *)0));
    }
    {
#line 215
    n_free((void *)filename, (int const   )215, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 215
    filename = (char *)((void *)0);
    }
#line 216
    return;
  }
  {
  {
#line 219
  sock_write_line(con->sock, "<html><head><title>%d %s</title></head>%s", 401, "Unauthorized",
                  "<body bgcolor=black text=white link=blue alink=red>");
  }
  {
#line 220
  sock_write_line(con->sock, "<h1><center>The server does not recognize your privileges to the requested entity/stream</center></h1>\r\n");
  }
  {
#line 221
  sock_write_line(con->sock, "</body></html>");
  }
  }
#line 222
  return;
}
}
#line 225 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_parsable_t *find_http_element(char *name , http_parsable_t *el ) 
{ 
  register int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 229
  i = 0;
  {
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 229
    if (! (el + i)->name) {
#line 229
      goto while_break;
    }
    {
    {
#line 231
    tmp = ice_strlen((char const   *)(el + i)->name);
    }
    {
#line 231
    tmp___0 = ice_strncmp((char const   *)name, (char const   *)(el + i)->name, tmp);
    }
    }
#line 231
    if (tmp___0 == 0) {
#line 232
      return (el + i);
    }
#line 229
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return ((http_parsable_t *)((void *)0));
}
}
#line 237 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_variable_t const   *find_http_variable(char const   *name , http_variable_t const   *el ) 
{ 
  register int i ;
  int tmp ;

  {
#line 241
  i = 0;
  {
  {
#line 241
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 241
    if (! (el + i)->name) {
#line 241
      goto while_break;
    }
    {
    {
#line 243
    tmp = ice_strcmp(name, (char const   *)(el + i)->name);
    }
    }
#line 243
    if (tmp == 0) {
#line 244
      return (el + i);
    }
#line 241
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return ((http_variable_t const   *)((http_variable_t *)((void *)0)));
}
}
#line 249 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
http_command_t const   *find_http_command(char const   *name , http_command_t const   *el ) 
{ 
  register int i ;
  int tmp ;

  {
#line 253
  i = 0;
  {
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 253
    if (! (el + i)->name) {
#line 253
      goto while_break;
    }
    {
    {
#line 254
    tmp = ice_strcmp(name, (char const   *)(el + i)->name);
    }
    }
#line 254
    if (tmp == 0) {
#line 255
      return (el + i);
    }
#line 253
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return ((http_command_t const   *)((http_command_t *)((void *)0)));
}
}
#line 263 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
unsigned char isAcceptable[96]  = 
#line 263
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)15,      (unsigned char)14, 
        (unsigned char)0,      (unsigned char)15,      (unsigned char)15,      (unsigned char)12, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)8,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)15, 
        (unsigned char)0,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)15,      (unsigned char)15,      (unsigned char)15,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 272 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *hex  =    (char *)"0123456789ABCDEF";
#line 273 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int mask  =    8;
#line 275 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *url_decode(char const   *intarget ) 
{ 
  char *temp ;
  char *target ;
  char c1 ;
  char c2 ;
  int len ;
  int run ;
  int j ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 282
  if (! intarget) {
    {
    {
#line 284
    xa_debug(1, (char *)"WARNING: url_decode called with NULL pointer");
    }
    }
#line 285
    return ((char *)((void *)0));
  }
  {
  {
#line 288
  target = n_strdup(intarget, (int const   )288, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 290
  tmp = ice_strlen((char const   *)target);
  }
#line 290
  len = (int )tmp;
  {
#line 291
  tmp___0 = n_malloc((unsigned int const   )(len + 1), (int const   )291, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 291
  temp = (char *)tmp___0;
  {
#line 292
  strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)target,
          (size_t )(len + 1));
  }
#line 294
  j = 0;
#line 294
  run = 0;
  }
  {
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 294
    if (! (j < len)) {
#line 294
      goto while_break;
    }
    {
#line 298
    if ((int )*(temp + j) == 43) {
#line 298
      goto case_43;
    }
#line 301
    if ((int )*(temp + j) == 37) {
#line 301
      goto case_37;
    }
#line 318
    goto switch_default;
    case_43: /* CIL Label */ 
#line 299
    *(target + run) = (char )' ';
#line 300
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 302
    j ++;
    {
#line 302
    tmp___1 = tolower((int )*(temp + j));
    }
#line 302
    c1 = (char )tmp___1;
    {
#line 303
    tmp___2 = __ctype_b_loc();
    }
    }
#line 303
    if ((int const   )*(*tmp___2 + (int )c1) & 2048) {
#line 305
      c1 = (char )((int )c1 - 48);
    } else {
#line 307
      c1 = (char )(((int )c1 - 97) + 10);
    }
    {
#line 309
    j ++;
    {
#line 309
    tmp___3 = tolower((int )*(temp + j));
    }
#line 309
    c2 = (char )tmp___3;
    {
#line 310
    tmp___4 = __ctype_b_loc();
    }
    }
#line 310
    if ((int const   )*(*tmp___4 + (int )c2) & 2048) {
#line 312
      c2 = (char )((int )c2 - 48);
    } else {
#line 314
      c2 = (char )(((int )c2 - 97) + 10);
    }
#line 316
    *(target + run) = (char )((int )c1 * 16 + (int )c2);
#line 317
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 319
    *(target + run) = *(temp + j);
#line 320
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 294
    j ++;
#line 294
    run ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  *(target + run) = (char )'\000';
  {
#line 325
  n_free((void *)temp, (int const   )325, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 325
  temp = (char *)((void *)0);
  }
#line 326
  return (target);
}
}
#line 329 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *html_escape(char const   *str ) 
{ 
  char const   *p ;
  char *q ;
  char *result ;
  int toescape ;
  void *tmp ;
  unsigned char a ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 335
  toescape = 0;
#line 337
  if (! str) {
    {
    {
#line 338
    xa_debug(1, (char *)"WARNING: html_escape() called with NULL string");
    }
    }
#line 339
    return ((char *)((void *)0));
  }
#line 342
  p = str;
  {
  {
#line 342
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 342
    if (! *p) {
#line 342
      goto while_break;
    }
#line 343
    if ((int )((unsigned char )*p) == 38) {
#line 343
      toescape += 4;
    }
#line 344
    if ((int )((unsigned char )*p) == 34) {
#line 344
      toescape += 5;
    }
#line 345
    if ((int )((unsigned char )*p) == 60) {
#line 345
      toescape += 3;
    }
#line 346
    if ((int )((unsigned char )*p) == 62) {
#line 346
      toescape += 3;
    }
#line 342
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 349
  tmp = n_malloc((unsigned int const   )(((p - str) + (long )toescape) + 1L), (int const   )349,
                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 349
  result = (char *)tmp;
#line 351
  q = result;
#line 351
  p = str;
  }
  {
  {
#line 351
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 351
    if (! *p) {
#line 351
      goto while_break___0;
    }
#line 352
    a = (unsigned char )*p;
#line 353
    if ((int )a == 38) {
#line 354
      tmp___0 = q;
#line 354
      q ++;
#line 354
      *tmp___0 = (char )'&';
#line 355
      tmp___1 = q;
#line 355
      q ++;
#line 355
      *tmp___1 = (char )'a';
#line 356
      tmp___2 = q;
#line 356
      q ++;
#line 356
      *tmp___2 = (char )'m';
#line 357
      tmp___3 = q;
#line 357
      q ++;
#line 357
      *tmp___3 = (char )'p';
#line 358
      tmp___4 = q;
#line 358
      q ++;
#line 358
      *tmp___4 = (char )';';
    } else
#line 359
    if ((int )a == 34) {
#line 360
      tmp___5 = q;
#line 360
      q ++;
#line 360
      *tmp___5 = (char )'&';
#line 361
      tmp___6 = q;
#line 361
      q ++;
#line 361
      *tmp___6 = (char )'q';
#line 362
      tmp___7 = q;
#line 362
      q ++;
#line 362
      *tmp___7 = (char )'u';
#line 363
      tmp___8 = q;
#line 363
      q ++;
#line 363
      *tmp___8 = (char )'o';
#line 364
      tmp___9 = q;
#line 364
      q ++;
#line 364
      *tmp___9 = (char )'t';
#line 365
      tmp___10 = q;
#line 365
      q ++;
#line 365
      *tmp___10 = (char )';';
    } else
#line 366
    if ((int )a == 60) {
#line 367
      tmp___11 = q;
#line 367
      q ++;
#line 367
      *tmp___11 = (char )'&';
#line 368
      tmp___12 = q;
#line 368
      q ++;
#line 368
      *tmp___12 = (char )'l';
#line 369
      tmp___13 = q;
#line 369
      q ++;
#line 369
      *tmp___13 = (char )'t';
#line 370
      tmp___14 = q;
#line 370
      q ++;
#line 370
      *tmp___14 = (char )';';
    } else
#line 371
    if ((int )a == 62) {
#line 372
      tmp___15 = q;
#line 372
      q ++;
#line 372
      *tmp___15 = (char )'&';
#line 373
      tmp___16 = q;
#line 373
      q ++;
#line 373
      *tmp___16 = (char )'g';
#line 374
      tmp___17 = q;
#line 374
      q ++;
#line 374
      *tmp___17 = (char )'t';
#line 375
      tmp___18 = q;
#line 375
      q ++;
#line 375
      *tmp___18 = (char )';';
    } else {
#line 376
      tmp___19 = q;
#line 376
      q ++;
#line 376
      *tmp___19 = (char )*p;
    }
#line 351
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 378
  tmp___20 = q;
#line 378
  q ++;
#line 378
  *tmp___20 = (char)0;
#line 379
  return (result);
}
}
#line 382 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *url_encode(char const   *str , char **result_p ) 
{ 
  char const   *p ;
  char *q ;
  char *result ;
  int unacceptable ;
  void *tmp ;
  unsigned char a ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 388
  unacceptable = 0;
#line 390
  if (! str) {
    {
    {
#line 392
    xa_debug(1, (char *)"WARNING: url_encode() called with NULL string");
    }
    }
#line 393
    return ((char *)((void *)0));
  }
#line 396
  p = str;
  {
  {
#line 396
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 396
    if (! *p) {
#line 396
      goto while_break;
    }
#line 397
    if ((int )((unsigned char )*p) >= 32) {
#line 397
      if ((int )((unsigned char )*p) < 128) {
#line 397
        if (! ((int )isAcceptable[(int )((unsigned char )*p) - 32] & mask)) {
#line 398
          unacceptable ++;
        }
      } else {
#line 398
        unacceptable ++;
      }
    } else {
#line 398
      unacceptable ++;
    }
#line 396
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 400
  tmp = n_malloc((unsigned int const   )((((p - str) + (long )unacceptable) + (long )unacceptable) + 1L),
                 (int const   )400, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 400
  result = (char *)tmp;
#line 401
  *result_p = result;
#line 403
  q = result;
#line 403
  p = str;
  }
  {
  {
#line 403
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 403
    if (! *p) {
#line 403
      goto while_break___0;
    }
#line 405
    a = (unsigned char )*p;
#line 406
    if ((int )a >= 32) {
#line 406
      if ((int )a < 128) {
#line 406
        if ((int )isAcceptable[(int )a - 32] & mask) {
#line 412
          tmp___3 = q;
#line 412
          q ++;
#line 412
          *tmp___3 = (char )*p;
        } else {
#line 406
          goto _L___0;
        }
      } else {
#line 406
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 408
      tmp___0 = q;
#line 408
      q ++;
#line 408
      *tmp___0 = (char )'%';
#line 409
      tmp___1 = q;
#line 409
      q ++;
#line 409
      *tmp___1 = *(hex + ((int )a >> 4));
#line 410
      tmp___2 = q;
#line 410
      q ++;
#line 410
      *tmp___2 = *(hex + ((int )a & 15));
    }
#line 403
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 414
  tmp___4 = q;
#line 414
  q ++;
#line 414
  *tmp___4 = (char)0;
#line 415
  return (result);
}
}
#line 418 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int updinfo(connection_t *con , vartree_t *request_vars ) 
{ 
  char const   *song ;
  char const   *tmp ;
  char const   *url ;
  char const   *tmp___0 ;
  char const   *mount ;
  char const   *tmp___1 ;
  char const   *msg ;
  char const   *tmp___2 ;
  char const   *length ;
  char const   *tmp___3 ;
  char *ptr ;
  connection_t *sourcecon ;
  char *ptr2 ;
  char *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 421
  tmp = get_variable(request_vars, "song");
  }
#line 421
  song = tmp;
  {
#line 422
  tmp___0 = get_variable(request_vars, "url");
  }
#line 422
  url = tmp___0;
  {
#line 423
  tmp___1 = get_variable(request_vars, "mount");
  }
#line 423
  mount = tmp___1;
  {
#line 424
  tmp___2 = get_variable(request_vars, "msg");
  }
#line 424
  msg = tmp___2;
  {
#line 425
  tmp___3 = get_variable(request_vars, "length");
  }
#line 425
  length = tmp___3;
  }
#line 429
  if (! con) {
    {
    {
#line 431
    xa_debug(2, (char *)"WARNING: updinfo called with NULL pointers");
    }
    }
#line 432
    return (0);
  } else
#line 429
  if (! request_vars) {
    {
    {
#line 431
    xa_debug(2, (char *)"WARNING: updinfo called with NULL pointers");
    }
    }
#line 432
    return (0);
  }
#line 435
  if (! mount) {
    {
    {
#line 436
    sourcecon = get_source_from_host(con);
    }
    }
  } else {
    {
    {
#line 438
    sourcecon = get_source_with_mount(mount);
    }
    }
  }
#line 440
  if (! sourcecon) {
    {
    {
#line 442
    sock_write_line(con->sock, "Invalid request");
    }
    }
#line 443
    return (0);
  }
#line 446
  ((sourcecon->food.source)->info.udpseqnr) ++;
#line 449
  if (length) {
    {
    {
#line 451
    ptr = url_decode(length);
    }
    {
#line 452
    (sourcecon->food.source)->info.streamlength = atol((char const   *)ptr);
    }
    {
#line 453
    n_free((void *)ptr, (int const   )453, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 453
    ptr = (char *)((void *)0);
    {
#line 454
    xa_debug(2, (char *)"DEBUG: updinfo() changed song length to %ld bytes", (sourcecon->food.source)->info.streamlength);
    }
    }
  }
#line 457
  if (msg) {
    {
#line 459
    ptr = (sourcecon->food.source)->info.streammsg;
    {
#line 460
    (sourcecon->food.source)->info.streammsg = url_decode(msg);
    }
    {
#line 461
    n_free((void *)ptr, (int const   )461, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 461
    ptr = (char *)((void *)0);
    {
#line 462
    xa_debug(2, (char *)"DEBUG: updinfo() changed msg info to %s", (sourcecon->food.source)->info.streammsg);
    }
    }
  }
#line 465
  if (song) {
    {
    {
#line 467
    tmp___4 = url_decode(song);
    }
#line 467
    ptr2 = tmp___4;
#line 469
    ptr = (sourcecon->food.source)->info.streamtitle;
    {
#line 470
    (sourcecon->food.source)->info.streamtitle = ice_sprintf((char const   *)info.streamtitletemplate,
                                                             (char const   *)ptr2);
    }
    {
#line 471
    n_free((void *)ptr, (int const   )471, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 471
    ptr = (char *)((void *)0);
#line 473
    ptr = info.streamtitle;
    {
#line 474
    info.streamtitle = ice_sprintf((char const   *)info.streamtitletemplate, (char const   *)ptr2);
    }
    {
#line 475
    n_free((void *)ptr, (int const   )475, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 475
    ptr = (char *)((void *)0);
    {
#line 477
    n_free((void *)ptr2, (int const   )477, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 477
    ptr2 = (char *)((void *)0);
#line 478
    info.directorylasttime = (time_t )0;
    {
#line 480
    xa_debug(2, (char *)"DEBUG: updinfo() changed song info to %s", (sourcecon->food.source)->info.streamtitle);
    }
    }
  }
#line 483
  if (url) {
#line 485
    if (info.streamurllock) {
      {
      {
#line 487
      sock_write_line(con->sock, "Error: StreamUrl is locked by admin and cannot be changed");
      }
      }
#line 488
      return (0);
    }
    {
#line 490
    ptr = (sourcecon->food.source)->info.streamurl;
    {
#line 491
    (sourcecon->food.source)->info.streamurl = url_decode(url);
    }
    {
#line 493
    n_free((void *)ptr, (int const   )493, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 493
    ptr = (char *)((void *)0);
    {
#line 494
    xa_debug(2, (char *)"DEBUG: updinfo() changed url info to %s", url);
    }
    }
  }
  {
  {
#line 497
  update_metadata_on_relays(sourcecon, mount, song, msg, length, url);
  }
  }
#line 498
  return (1);
}
}
#line 501 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void update_metadata_on_relays(connection_t *con , char const   *mount , char const   *song ,
                               char const   *msg , char const   *length , char const   *url ) 
{ 
  connection_t *relaycon ;
  avl_traverser trav ;
  void *tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 505
  trav.init = 0;
#line 505
  trav.nstack = 0;
#line 505
  trav.p = (avl_node const   *)0;
#line 505
  trav.stack[0] = (avl_node const   *)0;
#line 505
  trav.stack[1] = (avl_node const   *)0;
#line 505
  trav.stack[2] = (avl_node const   *)0;
#line 505
  trav.stack[3] = (avl_node const   *)0;
#line 505
  trav.stack[4] = (avl_node const   *)0;
#line 505
  trav.stack[5] = (avl_node const   *)0;
#line 505
  trav.stack[6] = (avl_node const   *)0;
#line 505
  trav.stack[7] = (avl_node const   *)0;
#line 505
  trav.stack[8] = (avl_node const   *)0;
#line 505
  trav.stack[9] = (avl_node const   *)0;
#line 505
  trav.stack[10] = (avl_node const   *)0;
#line 505
  trav.stack[11] = (avl_node const   *)0;
#line 505
  trav.stack[12] = (avl_node const   *)0;
#line 505
  trav.stack[13] = (avl_node const   *)0;
#line 505
  trav.stack[14] = (avl_node const   *)0;
#line 505
  trav.stack[15] = (avl_node const   *)0;
#line 505
  trav.stack[16] = (avl_node const   *)0;
#line 505
  trav.stack[17] = (avl_node const   *)0;
#line 505
  trav.stack[18] = (avl_node const   *)0;
#line 505
  trav.stack[19] = (avl_node const   *)0;
#line 505
  trav.stack[20] = (avl_node const   *)0;
#line 505
  trav.stack[21] = (avl_node const   *)0;
#line 505
  trav.stack[22] = (avl_node const   *)0;
#line 505
  trav.stack[23] = (avl_node const   *)0;
#line 505
  trav.stack[24] = (avl_node const   *)0;
#line 505
  trav.stack[25] = (avl_node const   *)0;
#line 505
  trav.stack[26] = (avl_node const   *)0;
#line 505
  trav.stack[27] = (avl_node const   *)0;
#line 505
  trav.stack[28] = (avl_node const   *)0;
#line 505
  trav.stack[29] = (avl_node const   *)0;
#line 505
  trav.stack[30] = (avl_node const   *)0;
#line 505
  trav.stack[31] = (avl_node const   *)0;
  {
#line 507
  thread_mutex_lock_c(& (con->food.source)->mutex, 507, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
  {
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 509
    tmp = avl_traverse((con->food.source)->clients, & trav);
    }
#line 509
    relaycon = (connection_t *)tmp;
    }
#line 509
    if (! relaycon) {
#line 509
      goto while_break;
    }
#line 511
    if ((int )(relaycon->food.client)->type == 1) {
      {
      {
#line 512
      update_metadata_on_relay(relaycon, mount, song, msg, length, url);
      }
      }
    } else
#line 511
    if ((int )(relaycon->food.client)->type == 2) {
      {
      {
#line 512
      update_metadata_on_relay(relaycon, mount, song, msg, length, url);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 515
  thread_mutex_unlock_c(& (con->food.source)->mutex, 515, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 516
  return;
}
}
#line 518 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void update_metadata_on_relay(connection_t *con , char const   *mount , char const   *song ,
                              char const   *msg , char const   *length , char const   *url ) 
{ 
  char const   *ports ;
  char const   *tmp ;
  char const   *password ;
  char const   *tmp___0 ;
  char const   *smount ;
  char const   *tmp___1 ;
  int port ;
  SOCKET sockfd ;
  char const   *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 521
  tmp = get_con_variable(con, "x-audiocast-port");
  }
#line 521
  ports = tmp;
  {
#line 522
  tmp___0 = get_con_variable(con, "x-audiocast-source-password");
  }
#line 522
  password = tmp___0;
  {
#line 523
  tmp___1 = get_con_variable(con, "x-audiocast-mount");
  }
#line 523
  smount = tmp___1;
  }
#line 527
  if (! password) {
    {
    {
#line 529
    tmp___2 = con_host(con);
    }
    {
#line 529
    xa_debug(2, (char *)"DEBUG: Cannot update metainfo on %s, cause I don\'t know the password",
             tmp___2);
    }
    }
#line 530
    return;
  }
#line 533
  if (ports) {
    {
    {
#line 534
    port = atoi(ports);
    }
    }
  } else {
#line 536
    port = info.port[0];
  }
#line 538
  if (! smount) {
#line 539
    smount = mount;
  }
  {
  {
#line 541
  sockfd = sock_connect_wto((char const   *)con->host, (int const   )port, (int const   )15);
  }
  }
#line 541
  if (sockfd != -1) {
    {
    {
#line 543
    sock_write(sockfd, "GET /admin.cgi?pass=%s&mode=updinfo&song=%s&mount=%s&length=%ld HTTP/1.0\r\nHost:%s:%d\rUser-Agent: icecast/%s\r\n\r\n",
               password, song, smount, length, con->host, port, "1.3.12");
    }
    {
#line 545
    sock_close(sockfd);
    }
    }
  }
#line 547
  return;
}
}
#line 549 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void handle_http_admin_command(connection_t *con , vartree_t *request_vars ) 
{ 
  char const   *inmode ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 552
  tmp = get_variable(request_vars, "mode");
  }
#line 552
  inmode = tmp;
  }
#line 554
  if (inmode) {
#line 554
    tmp___0 = inmode;
  } else {
#line 554
    tmp___0 = "null";
  }
  {
  {
#line 554
  xa_debug(2, (char *)"DEBUG: handle_http_admin_command() doing command [%s]", tmp___0);
  }
  }
#line 556
  if (inmode) {
    {
    {
#line 556
    tmp___2 = ice_strcmp(inmode, "updinfo");
    }
    }
#line 556
    if (tmp___2 == 0) {
      {
      {
#line 557
      updinfo(con, request_vars);
      }
      }
    } else {
#line 556
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 560
    if (inmode) {
#line 560
      tmp___1 = inmode;
    } else {
#line 560
      tmp___1 = "null";
    }
    {
    {
#line 560
    sock_write_line(con->sock, "Unknown command %s", tmp___1);
    }
    }
  }
#line 562
  return;
}
}
#line 564 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int http_admin_command(connection_t *con , request_t *req ) 
{ 
  vartree_t *request_vars ;
  avl_tree *tmp ;
  char const   *inpass ;
  char const   *inmode ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *inmount ;
  connection_t *source ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
  {
  {
#line 567
  tmp = avl_create(& compare_vars, (void *)(& info));
  }
#line 567
  request_vars = tmp;
  }
#line 571
  if (! req) {
    {
    {
#line 573
    xa_debug(1, (char *)"WARNING: http_admin_command called with NULL request");
    }
    }
#line 574
    return (0);
  } else
#line 571
  if (! (req->path)) {
    {
    {
#line 573
    xa_debug(1, (char *)"WARNING: http_admin_command called with NULL request");
    }
    }
#line 574
    return (0);
  }
  {
  {
#line 577
  tmp___4 = strstr((char const   *)(req->path), "updinfo");
  }
  }
#line 577
  if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
    {
    {
#line 586
    tmp___0 = allowed(con, (contype_t )2);
    }
    }
#line 586
    if (tmp___0) {
#line 586
      if (! info.allow_http_admin) {
        {
        {
#line 587
        write_http_code_page(con, 403, "Forbidden");
        }
        {
#line 588
        kick_not_connected(con, (char *)"Access Denied (internal acl list (admin connection))");
        }
        {
#line 589
        thread_exit_c(0L, 589, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
        }
        }
      }
    } else {
      {
      {
#line 587
      write_http_code_page(con, 403, "Forbidden");
      }
      {
#line 588
      kick_not_connected(con, (char *)"Access Denied (internal acl list (admin connection))");
      }
      {
#line 589
      thread_exit_c(0L, 589, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
      }
    }
    {
    {
#line 592
    tmp___1 = ice_strncmp((char const   *)(req->path), "admin", (size_t )5);
    }
    }
#line 592
    if (tmp___1 == 0) {
      {
      {
#line 595
      thread_rename("HTTP Admin Thread");
      }
      {
#line 597
      put_http_admin(con);
      }
      {
#line 599
      display_admin_page(con, req);
      }
      }
#line 601
      return (1);
    } else {
      {
      {
#line 592
      tmp___2 = ice_strncmp((char const   *)(req->path), "/admin", (size_t )6);
      }
      }
#line 592
      if (tmp___2 == 0) {
        {
        {
#line 595
        thread_rename("HTTP Admin Thread");
        }
        {
#line 597
        put_http_admin(con);
        }
        {
#line 599
        display_admin_page(con, req);
        }
        }
#line 601
        return (1);
      } else {
        {
        {
#line 592
        tmp___3 = ice_strncmp((char const   *)(req->path), "admin/", (size_t )6);
        }
        }
#line 592
        if (tmp___3 == 0) {
          {
          {
#line 595
          thread_rename("HTTP Admin Thread");
          }
          {
#line 597
          put_http_admin(con);
          }
          {
#line 599
          display_admin_page(con, req);
          }
          }
#line 601
          return (1);
        }
      }
    }
  }
  {
  {
#line 605
  extract_vars(request_vars, req->path);
  }
  {
#line 607
  inpass = get_variable(request_vars, "pass");
  }
  {
#line 608
  inmode = get_variable(request_vars, "mode");
  }
  {
#line 610
  xa_debug(3, (char *)"DEBUG: http_admin_command() adding variables from [%s]", req->path);
  }
  }
#line 612
  if (inpass) {
#line 612
    tmp___5 = inpass;
  } else {
#line 612
    tmp___5 = "null";
  }
  {
  {
#line 612
  xa_debug(3, (char *)"DEBUG: http_admin_command() checking password [%s] vs [%s]",
           info.remote_admin_pass, tmp___5);
  }
  }
#line 614
  if (inpass) {
    {
    {
#line 614
    tmp___10 = password_match((char const   *)info.remote_admin_pass, inpass);
    }
    }
#line 614
    if (tmp___10) {
      {
      {
#line 616
      handle_http_admin_command(con, request_vars);
      }
      {
#line 617
      free_variables(request_vars);
      }
      }
#line 618
      return (1);
    } else {
#line 614
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 619
  if (inpass) {
#line 619
    if (inmode) {
      {
      {
#line 619
      tmp___8 = ice_strcmp(inmode, "updinfo");
      }
      }
#line 619
      if (tmp___8 == 0) {
        {
        {
#line 619
        tmp___9 = password_match((char const   *)info.encoder_pass, inpass);
        }
        }
#line 619
        if (tmp___9) {
          {
          {
#line 622
          handle_http_admin_command(con, request_vars);
          }
          {
#line 623
          free_variables(request_vars);
          }
          }
#line 624
          return (1);
        } else {
#line 619
          goto _L___1;
        }
      } else {
#line 619
        goto _L___1;
      }
    } else {
#line 619
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 631
    if (inpass) {
      {
      {
#line 631
      inmount = get_variable(request_vars, "mount");
      }
      }
#line 631
      if (inmount) {
        {
        {
#line 631
        source = get_source_with_mount(inmount);
        }
        }
#line 631
        if (source) {
#line 631
          if ((unsigned int )source->type != 0U) {
            {
            {
#line 631
            tmp___6 = ice_strcmp(inmode, "updinfo");
            }
            }
#line 631
            if (tmp___6 == 0) {
              {
              {
#line 631
              tmp___7 = ice_strcmp((char const   *)info.encoder_pass, inpass);
              }
              }
#line 631
              if (tmp___7 == 0) {
                {
                {
#line 638
                handle_http_admin_command(con, request_vars);
                }
                {
#line 639
                free_variables(request_vars);
                }
                }
#line 640
                return (1);
              }
            }
          }
        }
      }
    }
    {
    {
#line 643
    free_variables(request_vars);
    }
    }
#line 644
    return (0);
  }
}
}
#line 648 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void display_admin_page(connection_t *con , request_t *req ) 
{ 
  vartree_t *request_vars ;
  avl_tree *tmp ;
  char const   *basic_command ;
  char const   *commandptr ;
  char commandstr[8192] ;
  request_t checkreq ;
  comp_element const   *com ;
  http_command_t const   *http_command ;
  com_request_t comreq ;
  int argcount ;
  char argstring[8192] ;
  char buff[8192] ;
  int tmp___0 ;
  int tmp___1 ;
  char *header ;
  char *tmp___2 ;
  char *footer ;
  char *tmp___3 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
  {
#line 651
  tmp = avl_create(& compare_vars, (void *)(& info));
  }
#line 651
  request_vars = tmp;
#line 659
  argcount = 1;
  {
#line 662
  extract_vars(request_vars, req->path);
  }
#line 664
  comreq.con = con;
#line 665
  comreq.wid = -1;
  {
#line 666
  commandptr = get_variable(request_vars, "argument");
  }
  }
#line 668
  if (commandptr) {
    {
    {
#line 670
    strncpy((char */* __restrict  */)(commandstr), (char const   */* __restrict  */)commandptr,
            (size_t )8192);
    }
#line 671
    comreq.arg = commandstr;
    }
    {
    {
#line 672
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 674
      snprintf((char */* __restrict  */)(argstring), (size_t )8192, (char const   */* __restrict  */)"argument%d",
               argcount);
      }
      {
#line 675
      commandptr = get_variable(request_vars, (char const   *)(argstring));
      }
      }
#line 676
      if (commandptr) {
        {
        {
#line 678
        snprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)"%s %s",
                 comreq.arg, commandptr);
        }
        {
#line 679
        strncpy((char */* __restrict  */)comreq.arg, (char const   */* __restrict  */)(buff),
                (size_t )8192);
        }
        }
      }
#line 681
      argcount ++;
#line 672
      if (! (argcount < 10)) {
#line 672
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 684
    comreq.arg = (char *)((void *)0);
  }
  {
  {
#line 686
  basic_command = get_variable(request_vars, "mode");
  }
  }
#line 688
  if (! basic_command) {
    {
    {
#line 690
    display_generic_admin_page(con);
    }
    {
#line 691
    free_variables(request_vars);
    }
    }
#line 692
    return;
  }
  {
  {
#line 696
  http_command = find_http_command(basic_command, (http_command_t const   *)(http_commands));
  }
  }
#line 697
  if (! http_command) {
    {
    {
#line 699
    write_no_such_command(con, basic_command);
    }
    {
#line 700
    free_variables(request_vars);
    }
    }
#line 701
    return;
  }
  {
  {
#line 705
  com = find_comp_element(basic_command, (comp_element const   *)(commands));
  }
  {
#line 707
  zero_request(& checkreq);
  }
  }
#line 709
  if (com) {
#line 709
    if (com->oper) {
      {
      {
#line 710
      strncpy((char */* __restrict  */)(checkreq.path), (char const   */* __restrict  */)"/oper",
              (size_t )8192);
      }
      }
    } else {
      {
      {
#line 712
      strncpy((char */* __restrict  */)(checkreq.path), (char const   */* __restrict  */)"/admin",
              (size_t )8192);
      }
      }
    }
  } else {
    {
    {
#line 712
    strncpy((char */* __restrict  */)(checkreq.path), (char const   */* __restrict  */)"/admin",
            (size_t )8192);
    }
    }
  }
#line 714
  if (info.allow_http_admin == 0) {
#line 714
    goto _L;
  } else {
    {
    {
#line 714
    tmp___1 = need_authentication(& checkreq);
    }
    }
#line 714
    if (tmp___1) {
      _L: /* CIL Label */ 
#line 716
      if (info.allow_http_admin == 0) {
        {
        {
#line 718
        write_401(con, checkreq.path);
        }
        {
#line 719
        free_variables(request_vars);
        }
        }
#line 720
        return;
      } else {
        {
        {
#line 716
        tmp___0 = authenticate_user_request(con, & checkreq);
        }
        }
#line 716
        if (! tmp___0) {
          {
          {
#line 718
          write_401(con, checkreq.path);
          }
          {
#line 719
          free_variables(request_vars);
          }
          }
#line 720
          return;
        }
      }
    }
  }
  {
  {
#line 724
  log_command(basic_command, (com_request_t const   *)(& comreq));
  }
  }
#line 726
  if (! http_command->wrap) {
    {
    {
#line 727
    tmp___2 = get_template("header.html");
    }
#line 727
    header = tmp___2;
    {
#line 728
    tmp___3 = get_template("footer.html");
    }
#line 728
    footer = tmp___3;
    }
#line 730
    if (header) {
      {
      {
#line 731
      write_template_parsed_html_page(comreq.con, (connection_t *)((void *)0), (char const   *)header,
                                      -1, (vartree_t *)((void *)0));
      }
      {
#line 732
      n_free((void *)header, (int const   )732, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
#line 732
      header = (char *)((void *)0);
      }
    }
    {
    {
#line 735
    (*(http_command->func))(& comreq);
    }
    }
#line 737
    if (footer) {
      {
      {
#line 738
      write_template_parsed_html_page(comreq.con, (connection_t *)((void *)0), (char const   *)footer,
                                      -2, (vartree_t *)((void *)0));
      }
      {
#line 739
      n_free((void *)footer, (int const   )739, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
#line 739
      footer = (char *)((void *)0);
      }
    }
  } else {
    {
    {
#line 743
    (*(http_command->func))(& comreq);
    }
    }
  }
  {
  {
#line 745
  free_variables(request_vars);
  }
  }
#line 746
  return;
}
}
#line 748 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void display_generic_admin_page(connection_t *con ) 
{ 
  char *file ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 751
  tmp = get_template("admin.html");
  }
#line 751
  file = tmp;
  }
#line 753
  if (file) {
    {
    {
#line 755
    write_template_parsed_html_page(con, (connection_t *)((void *)0), (char const   *)file,
                                    -1, (vartree_t *)((void *)0));
    }
    {
#line 756
    n_free((void *)file, (int const   )756, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 756
    file = (char *)((void *)0);
    }
  } else {
    {
    {
#line 758
    write_http_header(con->sock, 200, "OK");
    }
    {
#line 759
    sock_write_line(con->sock, "Connection: close");
    }
    {
#line 760
    sock_write_line(con->sock, "Content-Type: text/html\r\n");
    }
    {
#line 761
    sock_write_line(con->sock, "<html>No admin template page found. Create one and try again<br></html>");
    }
    }
  }
#line 763
  return;
}
}
#line 765 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void write_http_header(sock_t sockfd , int error , char const   *msg ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 768
  sock_write_line(sockfd, "HTTP/1.0 %i %s", error, msg);
  }
  {
#line 769
  sock_write_line(sockfd, "Server: icecast/%s", "1.3.12");
  }
  }
#line 770
  return;
}
}
#line 772 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int print_http_variable(vartree_t *request_vars , char const   *name , connection_t *clicon ,
                        int fd ) 
{ 
  char const   *out ;
  char const   *tmp ;
  http_variable_t const   *var ;
  http_variable_t const   *tmp___0 ;
  char *ptr ;
  htf tmp___1 ;
  char *ptr___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
  {
#line 775
  tmp = get_variable(request_vars, name);
  }
#line 775
  out = tmp;
  }
#line 777
  if (out) {
#line 779
    if (fd < 0) {
      {
      {
#line 780
      sock_write(clicon->sock, "%s", out);
      }
      }
    } else {
      {
      {
#line 782
      fd_write(fd, out);
      }
      }
    }
#line 784
    return (1);
  } else {
    {
    {
#line 786
    tmp___0 = find_http_variable(name, (http_variable_t const   *)(http_variables));
    }
#line 786
    var = tmp___0;
    }
#line 787
    if (! var) {
#line 788
      return (0);
    }
#line 789
    if ((unsigned int const   )var->type == 0U) {
#line 791
      if (fd < 0) {
        {
        {
#line 792
        sock_write(clicon->sock, "%d", *((int *)var->valueptr));
        }
        }
      } else {
        {
        {
#line 794
        fd_write(fd, "%d", *((int *)var->valueptr));
        }
        }
      }
    } else
#line 796
    if ((unsigned int const   )var->type == 1U) {
#line 798
      if (fd < 0) {
        {
        {
#line 799
        sock_write(clicon->sock, "%f", *((double *)var->valueptr));
        }
        }
      } else {
        {
        {
#line 801
        fd_write(fd, "%f", *((double *)var->valueptr));
        }
        }
      }
    } else
#line 803
    if ((unsigned int const   )var->type == 3U) {
      {
      {
#line 806
      tmp___1 = (*((HttpFunction *)var->valueptr))();
      }
#line 806
      ptr = (char *)tmp___1;
      }
#line 807
      if (fd < 0) {
        {
        {
#line 808
        sock_write(clicon->sock, "%s", ptr);
        }
        }
      } else {
        {
        {
#line 810
        fd_write(fd, "%s", ptr);
        }
        }
      }
      {
      {
#line 811
      n_free((void *)ptr, (int const   )811, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
#line 811
      ptr = (char *)((void *)0);
      }
    } else {
#line 816
      if (! var->valueptr) {
#line 817
        ptr___0 = (char *)"(null)";
      } else {
#line 819
        ptr___0 = *((char **)var->valueptr);
      }
#line 821
      if (fd < 0) {
        {
        {
#line 822
        sock_write(clicon->sock, "%s", ptr___0);
        }
        }
      } else {
        {
        {
#line 824
        fd_write(fd, "%s", ptr___0);
        }
        }
      }
    }
#line 826
    return (1);
  }
}
}
#line 830 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int write_template_parsed_html_page(connection_t *clicon , connection_t *sourcecon ,
                                    char const   *template_file , int fd , vartree_t *variables ) 
{ 
  int len ;
  int ffd ;
  int tmp ;
  struct stat st ;
  char *fileptr ;
  char const   *res ;
  int count ;
  int readlen ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
  {
#line 834
  tmp = open_for_reading(template_file);
  }
#line 834
  ffd = tmp;
#line 836
  fileptr = (char *)((void *)0);
#line 838
  count = 0;
#line 838
  readlen = 0;
  {
#line 840
  xa_debug(2, (char *)"DEBUG: wtphp(): Entering function with file=%s fd=%d", template_file,
           fd);
  }
  }
#line 842
  if (fd == -1) {
#line 842
    if (clicon) {
      {
      {
#line 844
      write_http_header(clicon->sock, 200, "OK");
      }
      {
#line 845
      sock_write_line(clicon->sock, "Connection: close");
      }
      {
#line 846
      sock_write_line(clicon->sock, "Content-Type: text/html\r\n");
      }
      }
    }
  }
#line 849
  if (ffd < 0) {
    {
    {
#line 851
    xa_debug(1, (char *)"ERROR: Cannot open file [%s]", template_file);
    }
    }
#line 852
    if (fd < 0) {
      {
      {
#line 853
      sock_write_line(clicon->sock, "ERROR: Cannot open file [%s]", template_file);
      }
      }
    }
#line 854
    return (0);
  }
  {
  {
#line 857
  tmp___0 = fstat(ffd, & st);
  }
  }
#line 857
  if (tmp___0 == -1) {
    {
    {
#line 859
    xa_debug(1, (char *)"ERROR: Cannot stat file [%s]", template_file);
    }
    }
#line 860
    if (fd < 0) {
      {
      {
#line 861
      sock_write_line(clicon->sock, "ERROR: Cannot stat file [%s]", template_file);
      }
      }
    }
#line 862
    return (0);
  }
  {
  {
#line 865
  xa_debug(3, (char *)"DEBUG: wtphp(): Parsing page %s", template_file);
  }
  {
#line 868
  tmp___1 = malloc((size_t )(st.st_size + 2L));
  }
#line 868
  fileptr = (char *)tmp___1;
  }
#line 869
  if (! fileptr) {
#line 871
    if (fd < 0) {
      {
      {
#line 872
      sock_write_line(clicon->sock, "ERROR: Cannot allocate enough memory, try again later");
      }
      }
    }
#line 873
    return (0);
  }
#line 876
  readlen = 0;
#line 876
  count = readlen;
  {
  {
#line 877
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 877
    if (! ((__off_t )count < st.st_size)) {
#line 877
      goto while_break;
    }
#line 878
    if (2048L < st.st_size - (__off_t )count) {
#line 878
      len = 2048;
    } else {
#line 878
      len = (int )(st.st_size - (__off_t )count);
    }
    {
    {
#line 879
    readlen = read(ffd, (void *)(fileptr + count), (size_t )len);
    }
    }
#line 880
    if (readlen > 0) {
#line 881
      count += readlen;
    } else {
      {
      {
#line 883
      xa_debug(1, (char *)"Read error while parsing %s", template_file);
      }
      }
#line 884
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  *(fileptr + count) = (char )'\000';
#line 890
  if (! variables) {
    {
    {
#line 891
    variables = avl_create(& compare_vars, (void *)(& info));
    }
    }
  }
  {
  {
#line 893
  xa_debug(3, (char *)"DEBUG: wtphp(): Done reading template file into memory, read %d bytes, starting parsing",
           count);
  }
  {
#line 895
  res = parse_template_file(clicon, sourcecon, (char const   *)fileptr, fd, variables);
  }
  {
#line 897
  xa_debug(3, (char *)"DEBUG: wtphp(): Done parsing, freeing variables and saying goodbye");
  }
  }
#line 899
  if (fileptr) {
    {
    {
#line 900
    free((void *)fileptr);
    }
    }
  }
  {
  {
#line 902
  fd_close(ffd);
  }
  {
#line 903
  free_variables(variables);
  }
  }
#line 905
  if (res) {
#line 905
    tmp___2 = 1;
  } else {
#line 905
    tmp___2 = 0;
  }
#line 905
  return (tmp___2);
}
}
#line 911 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *parse_template_file(connection_t *clicon , connection_t *sourcecon ,
                                  char const   *ptr , int fd , vartree_t *variables ) 
{ 
  char const   *start ;
  char line[8192] ;
  char const   *tmpptr ;
  char const   *nextptr ;
  http_parsable_t *ht ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 914
  start = ptr;
  {
#line 920
  xa_debug(6, (char *)"DEBUG: parsing template file starting at [%s], fd: %d", ptr,
           fd);
  }
  }
  {
  {
#line 922
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 922
    if (ptr) {
#line 922
      if (! *ptr) {
#line 922
        goto while_break;
      }
    } else {
#line 922
      goto while_break;
    }
#line 924
    if ((int const   )*(ptr + 0) == 64) {
      {
      {
#line 926
      memset((void *)(line), 0, (size_t )8192);
      }
      {
#line 927
      tmp___1 = strchr(ptr + 1, '@');
      }
#line 927
      nextptr = (char const   *)tmp___1;
      }
#line 927
      if (nextptr) {
#line 929
        if (nextptr - ptr < 8192L) {
          {
          {
#line 930
          memcpy((void */* __restrict  */)(line), (void const   */* __restrict  */)(ptr + 1),
                 (size_t )(nextptr - (ptr + 1)));
          }
          }
        } else {
#line 933
          if (fd < 0) {
            {
            {
#line 934
            sock_write_bytes(clicon->sock, ptr, 1);
            }
            }
          } else {
            {
            {
#line 936
            fd_write_bytes(fd, ptr, (int const   )1);
            }
            }
          }
#line 937
          ptr ++;
#line 938
          goto while_continue;
        }
        {
        {
#line 941
        ht = find_http_element(line, http_parsables);
        }
        }
#line 943
        if (ht) {
          {
          {
#line 945
          xa_debug(4, (char *)"DEBUG: parse_template_file(): Calling function for [%s]",
                   line);
          }
          {
#line 946
          tmpptr = (*(ht->func))(line, clicon, sourcecon, nextptr + 1, fd, variables);
          }
          }
#line 948
          if (tmpptr) {
#line 950
            ptr = tmpptr;
          } else {
#line 954
            ptr = nextptr + 1;
          }
        } else {
          {
          {
#line 957
          tmp___0 = print_http_variable(variables, (char const   *)(line), clicon,
                                        fd);
          }
          }
#line 957
          if (tmp___0) {
            {
            {
#line 959
            xa_debug(4, (char *)"DEBUG: parse_template_file(): Evaluated variable [%s]",
                     line);
            }
#line 960
            ptr = nextptr + 1;
            }
          } else {
            {
            {
#line 962
            tmp = ice_strncmp((char const   *)(line), "ENDFOR", (size_t )6);
            }
            }
#line 962
            if (tmp == 0) {
              {
              {
#line 964
              xa_debug(4, (char *)"DEBUG: parse_tempate_file(): Returning from For-loop [%s:%s]",
                       line, nextptr + 1);
              }
              }
#line 965
              return (nextptr + 1);
            } else {
#line 967
              if (fd < 0) {
                {
                {
#line 968
                sock_write(clicon->sock, "@%s@", line);
                }
                }
              } else {
                {
                {
#line 970
                fd_write(fd, "@%s@", line);
                }
                }
              }
#line 971
              ptr = nextptr + 1;
            }
          }
        }
      } else {
#line 976
        if (fd < 0) {
          {
          {
#line 977
          sock_write_bytes(clicon->sock, ptr, 1);
          }
          }
        } else {
          {
          {
#line 979
          fd_write_bytes(fd, ptr, (int const   )1);
          }
          }
        }
#line 980
        ptr ++;
      }
    } else {
#line 985
      if (fd < 0) {
        {
        {
#line 986
        sock_write_bytes(clicon->sock, ptr, 1);
        }
        }
      } else {
        {
        {
#line 988
        fd_write_bytes(fd, ptr, (int const   )1);
        }
        }
      }
#line 989
      ptr ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  return (start);
}
}
#line 996 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_odd(char *command , connection_t *clicon , connection_t *sourcecon ,
                       char const   *ptr , int fd , vartree_t *variables ) 
{ 
  void const   *varptr ;
  char endat[8192] ;
  char const   *nextline ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1003
  if (! command) {
    {
    {
#line 1005
    xa_debug(1, (char *)"ERROR: http_odd() called with NULL arguments");
    }
    }
#line 1006
    return ((char const   *)((void *)0));
  } else
#line 1003
  if (! clicon) {
    {
    {
#line 1005
    xa_debug(1, (char *)"ERROR: http_odd() called with NULL arguments");
    }
    }
#line 1006
    return ((char const   *)((void *)0));
  } else
#line 1003
  if (! ptr) {
    {
    {
#line 1005
    xa_debug(1, (char *)"ERROR: http_odd() called with NULL arguments");
    }
    }
#line 1006
    return ((char const   *)((void *)0));
  } else
#line 1003
  if (! variables) {
    {
    {
#line 1005
    xa_debug(1, (char *)"ERROR: http_odd() called with NULL arguments");
    }
    }
#line 1006
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1009
  splitc((char *)((void *)0), command, (char const   )' ');
  }
  {
#line 1011
  varptr = get_http_variable(variables, (char const   *)command);
  }
  }
#line 1013
  if (! varptr) {
    {
    {
#line 1015
    xa_debug(3, (char *)"ERROR: http_odd() called with invalid counter variable");
    }
    }
#line 1016
    if (fd < 0) {
      {
      {
#line 1017
      sock_write_line(clicon->sock, "No such variable [%s]", command);
      }
      }
    } else {
      {
      {
#line 1019
      fd_write_line(fd, "No such variable [%s]", command);
      }
      }
    }
#line 1020
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1023
  snprintf((char */* __restrict  */)(endat), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
           command);
  }
  {
#line 1025
  tmp = strchr(ptr, '\n');
  }
#line 1025
  nextline = (char const   *)tmp;
  {
#line 1027
  tmp___0 = atoi((char const   *)((char *)varptr));
  }
  {
#line 1027
  xa_debug(3, (char *)"DEBUG: http_odd(): Checking %d", tmp___0);
  }
  }
#line 1029
  if (nextline) {
    {
    {
#line 1029
    tmp___2 = atoi((char const   *)((char *)varptr));
    }
    }
#line 1029
    if (tmp___2 % 2 != 0) {
      {
      {
#line 1031
      parse_template_file(clicon, sourcecon, ptr, fd, variables);
      }
      {
#line 1032
      tmp___1 = skip_before(ptr, (char const   *)(endat));
      }
      }
#line 1032
      return (tmp___1);
    }
  }
#line 1035
  if (nextline) {
    {
    {
#line 1037
    tmp___3 = strchr(nextline + 1, '\n');
    }
#line 1037
    nextline = (char const   *)tmp___3;
    }
  }
#line 1039
  if (nextline) {
#line 1039
    tmp___4 = nextline + 1;
  } else {
#line 1039
    tmp___4 = (char const   *)((void *)0);
  }
#line 1039
  return (tmp___4);
}
}
#line 1042 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_even(char *command , connection_t *clicon , connection_t *sourcecon ,
                        char const   *ptr , int fd , vartree_t *variables ) 
{ 
  void const   *varptr ;
  char endat[8192] ;
  char const   *nextline ;
  char *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1049
  if (! command) {
    {
    {
#line 1051
    xa_debug(1, (char *)"ERROR: http_even() called with NULL arguments");
    }
    }
#line 1052
    return ((char const   *)((void *)0));
  } else
#line 1049
  if (! clicon) {
    {
    {
#line 1051
    xa_debug(1, (char *)"ERROR: http_even() called with NULL arguments");
    }
    }
#line 1052
    return ((char const   *)((void *)0));
  } else
#line 1049
  if (! ptr) {
    {
    {
#line 1051
    xa_debug(1, (char *)"ERROR: http_even() called with NULL arguments");
    }
    }
#line 1052
    return ((char const   *)((void *)0));
  } else
#line 1049
  if (! variables) {
    {
    {
#line 1051
    xa_debug(1, (char *)"ERROR: http_even() called with NULL arguments");
    }
    }
#line 1052
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1055
  splitc((char *)((void *)0), command, (char const   )' ');
  }
  {
#line 1057
  varptr = get_http_variable(variables, (char const   *)command);
  }
  }
#line 1059
  if (! varptr) {
    {
    {
#line 1061
    xa_debug(3, (char *)"ERROR: http_even() called with invalid counter variable");
    }
    }
#line 1062
    if (fd < 0) {
      {
      {
#line 1063
      sock_write_line(clicon->sock, "No such variable [%s]", command);
      }
      }
    } else {
      {
      {
#line 1065
      fd_write_line(fd, "No such variable [%s]", command);
      }
      }
    }
#line 1066
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1069
  snprintf((char */* __restrict  */)(endat), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
           command);
  }
  {
#line 1071
  tmp = strchr(ptr, '\n');
  }
#line 1071
  nextline = (char const   *)tmp;
  {
#line 1073
  tmp___0 = atoi((char const   *)((char *)varptr));
  }
  {
#line 1073
  xa_debug(3, (char *)"DEBUG: http_even(): Checking %d", tmp___0);
  }
  }
#line 1075
  if (nextline) {
    {
    {
#line 1075
    tmp___2 = atoi((char const   *)((char *)varptr));
    }
    }
#line 1075
    if (tmp___2 % 2 == 0) {
      {
      {
#line 1077
      parse_template_file(clicon, sourcecon, ptr, fd, variables);
      }
      {
#line 1078
      tmp___1 = skip_before(ptr, (char const   *)(endat));
      }
      }
#line 1078
      return (tmp___1);
    }
  }
#line 1081
  if (nextline) {
    {
    {
#line 1083
    tmp___3 = strchr(nextline + 1, '\n');
    }
#line 1083
    nextline = (char const   *)tmp___3;
    }
  }
#line 1085
  if (nextline) {
#line 1085
    tmp___4 = nextline + 1;
  } else {
#line 1085
    tmp___4 = (char const   *)((void *)0);
  }
#line 1085
  return (tmp___4);
}
}
#line 1088 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_include(char *command , connection_t *clicon , connection_t *sourcecon ,
                           char const   *ptr , int fd , vartree_t *variables ) 
{ 
  int ffd ;
  int len ;
  struct stat st ;
  char *fileptr ;
  char *filename ;
  char const   *res ;
  int count ;
  int readlen ;
  int tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
  {
#line 1094
  filename = (char *)((void *)0);
#line 1096
  count = 0;
#line 1096
  readlen = 0;
  {
#line 1098
  splitc((char *)((void *)0), command, (char const   )' ');
  }
  {
#line 1100
  filename = get_template((char const   *)command);
  }
  }
#line 1102
  if (! filename) {
    {
    {
#line 1104
    xa_debug(1, (char *)"ERROR: Cannot find template file [%s]", command);
    }
    }
#line 1105
    if (fd < 0) {
      {
      {
#line 1106
      sock_write_line(clicon->sock, "ERROR: Cannot find template file %s", command);
      }
      }
    } else {
      {
      {
#line 1108
      fd_write_line(fd, "ERROR: Cannot find template file %s", command);
      }
      }
    }
#line 1109
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1112
  xa_debug(5, (char *)"DEBUG: http_include(): including file [%s]", command);
  }
  {
#line 1113
  ffd = open_for_reading((char const   *)filename);
  }
  }
#line 1115
  if (ffd < 0) {
    {
    {
#line 1117
    xa_debug(1, (char *)"ERROR: Cannot open file [%s]", filename);
    }
    }
#line 1118
    if (fd < 0) {
      {
      {
#line 1119
      sock_write_line(clicon->sock, "ERROR: Cannot open file [%s]", filename);
      }
      }
    } else {
      {
      {
#line 1121
      fd_write_line(fd, "ERROR: Cannot open file [%s]", filename);
      }
      }
    }
    {
    {
#line 1122
    n_free((void *)filename, (int const   )1122, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 1122
    filename = (char *)((void *)0);
    }
#line 1123
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1126
  tmp = fstat(ffd, & st);
  }
  }
#line 1126
  if (tmp == -1) {
    {
    {
#line 1128
    xa_debug(1, (char *)"ERROR: Cannot stat file [%s]", filename);
    }
    }
#line 1129
    if (fd < 0) {
      {
      {
#line 1130
      sock_write_line(clicon->sock, "ERROR: Cannot stat file [%s]", filename);
      }
      }
    } else {
      {
      {
#line 1132
      fd_write_line(fd, "ERROR: Cannot stat file [%s]", filename);
      }
      }
    }
    {
    {
#line 1133
    n_free((void *)filename, (int const   )1133, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 1133
    filename = (char *)((void *)0);
    }
#line 1134
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1137
  n_free((void *)filename, (int const   )1137, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 1137
  filename = (char *)((void *)0);
  {
#line 1140
  tmp___0 = malloc((size_t )(st.st_size + 2L));
  }
#line 1140
  fileptr = (char *)tmp___0;
  }
#line 1141
  if (! fileptr) {
#line 1143
    if (fd < 0) {
      {
      {
#line 1144
      sock_write_line(clicon->sock, "ERROR: Cannot allocate enough memory, try again later");
      }
      }
    } else {
      {
      {
#line 1146
      fd_write_line(fd, "ERROR: Cannot allocate enough memory, try again later");
      }
      }
    }
#line 1147
    return ((char const   *)((void *)0));
  }
#line 1150
  readlen = 0;
#line 1150
  count = readlen;
  {
  {
#line 1151
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1151
    if (! ((__off_t )count < st.st_size)) {
#line 1151
      goto while_break;
    }
#line 1153
    if (2048L < st.st_size - (__off_t )count) {
#line 1153
      len = 2048;
    } else {
#line 1153
      len = (int )(st.st_size - (__off_t )count);
    }
    {
    {
#line 1154
    readlen = read(ffd, (void *)(fileptr + count), (size_t )len);
    }
    }
#line 1155
    if (readlen >= 0) {
#line 1156
      count += readlen;
    } else {
      {
      {
#line 1157
      tmp___1 = __errno_location();
      }
      {
#line 1157
      tmp___2 = is_recoverable(*tmp___1);
      }
      }
#line 1157
      if (! tmp___2) {
        {
        {
#line 1159
        xa_debug(1, (char *)"Read error while parsing %s", filename);
        }
        }
#line 1160
        return ((char const   *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1164
  *(fileptr + count) = (char )'\000';
  {
#line 1166
  res = parse_template_file(clicon, sourcecon, (char const   *)fileptr, fd, variables);
  }
  }
#line 1168
  if (fileptr) {
    {
    {
#line 1169
    free((void *)fileptr);
    }
    }
  }
  {
  {
#line 1171
  fd_close(ffd);
  }
  }
#line 1173
  return ((char const   *)((void *)0));
}
}
#line 1177 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_foreach(char *command , connection_t *clicon , connection_t *sourcecon ,
                           char const   *ptr , int fd , vartree_t *variables ) 
{ 
  char ident[8192] ;
  char *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
  {
#line 1182
  tmp = splitc((char *)((void *)0), command, (char const   )' ');
  }
  }
#line 1182
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1183
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1185
  tmp___0 = splitc(ident, command, (char const   )' ');
  }
  }
#line 1185
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 1186
    return ((char const   *)((void *)0));
  }
  {
  {
#line 1188
  xa_debug(6, (char *)"DEBUG: http_foreach: called with [%s] [%s]", command, ptr);
  }
  {
#line 1190
  tmp___8 = ice_strcasecmp((char const   *)command, "SOURCES");
  }
  }
#line 1190
  if (tmp___8 == 0) {
    {
    {
#line 1191
    tmp___1 = http_loop_sources(ident, clicon, ptr, fd, variables);
    }
    }
#line 1191
    return (tmp___1);
  } else {
    {
    {
#line 1192
    tmp___7 = ice_strcasecmp((char const   *)command, "LISTENERS");
    }
    }
#line 1192
    if (tmp___7 == 0) {
      {
      {
#line 1193
      tmp___2 = http_loop_listeners(ident, clicon, ptr, fd, variables);
      }
      }
#line 1193
      return (tmp___2);
    } else {
      {
      {
#line 1194
      tmp___6 = ice_strcasecmp((char const   *)command, "ADMINS");
      }
      }
#line 1194
      if (tmp___6 == 0) {
        {
        {
#line 1195
        tmp___3 = http_loop_admins(ident, clicon, ptr, fd, variables);
        }
        }
#line 1195
        return (tmp___3);
      } else {
        {
        {
#line 1196
        tmp___5 = ice_strcasecmp((char const   *)command, "FILES");
        }
        }
#line 1196
        if (tmp___5 == 0) {
          {
          {
#line 1197
          tmp___4 = http_loop_directory(ident, clicon, ptr, fd, variables);
          }
          }
#line 1197
          return (tmp___4);
        } else {
          {
          {
#line 1199
          xa_debug(1, (char *)"WARNING: Unknown Traverse type for FOREACH [%s]", command);
          }
          }
#line 1200
          if (fd < 0) {
            {
            {
#line 1201
            sock_write(clicon->sock, "Unknown Traverse type [%s]", command);
            }
            }
          } else {
            {
            {
#line 1203
            fd_write(fd, "Unknown Traverse type [%s]", command);
            }
            }
          }
#line 1204
          return ((char const   *)((void *)0));
        }
      }
    }
  }
}
}
#line 1208 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_loop_sources(char *ident , connection_t *clicon , char const   *ptr ,
                                int fd , vartree_t *variables ) 
{ 
  char const   *runptr ;
  char const   *endptr ;
  char buf[8192] ;
  int i ;
  connection_t *travcon ;
  avl_traverser trav ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  long tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  void *tmp___32 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
  {
#line 1211
  runptr = ptr;
#line 1211
  endptr = (char const   *)((void *)0);
#line 1213
  i = 0;
#line 1216
  trav.init = 0;
#line 1216
  trav.nstack = 0;
#line 1216
  trav.p = (avl_node const   *)0;
#line 1216
  trav.stack[0] = (avl_node const   *)0;
#line 1216
  trav.stack[1] = (avl_node const   *)0;
#line 1216
  trav.stack[2] = (avl_node const   *)0;
#line 1216
  trav.stack[3] = (avl_node const   *)0;
#line 1216
  trav.stack[4] = (avl_node const   *)0;
#line 1216
  trav.stack[5] = (avl_node const   *)0;
#line 1216
  trav.stack[6] = (avl_node const   *)0;
#line 1216
  trav.stack[7] = (avl_node const   *)0;
#line 1216
  trav.stack[8] = (avl_node const   *)0;
#line 1216
  trav.stack[9] = (avl_node const   *)0;
#line 1216
  trav.stack[10] = (avl_node const   *)0;
#line 1216
  trav.stack[11] = (avl_node const   *)0;
#line 1216
  trav.stack[12] = (avl_node const   *)0;
#line 1216
  trav.stack[13] = (avl_node const   *)0;
#line 1216
  trav.stack[14] = (avl_node const   *)0;
#line 1216
  trav.stack[15] = (avl_node const   *)0;
#line 1216
  trav.stack[16] = (avl_node const   *)0;
#line 1216
  trav.stack[17] = (avl_node const   *)0;
#line 1216
  trav.stack[18] = (avl_node const   *)0;
#line 1216
  trav.stack[19] = (avl_node const   *)0;
#line 1216
  trav.stack[20] = (avl_node const   *)0;
#line 1216
  trav.stack[21] = (avl_node const   *)0;
#line 1216
  trav.stack[22] = (avl_node const   *)0;
#line 1216
  trav.stack[23] = (avl_node const   *)0;
#line 1216
  trav.stack[24] = (avl_node const   *)0;
#line 1216
  trav.stack[25] = (avl_node const   *)0;
#line 1216
  trav.stack[26] = (avl_node const   *)0;
#line 1216
  trav.stack[27] = (avl_node const   *)0;
#line 1216
  trav.stack[28] = (avl_node const   *)0;
#line 1216
  trav.stack[29] = (avl_node const   *)0;
#line 1216
  trav.stack[30] = (avl_node const   *)0;
#line 1216
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1218
  xa_debug(3, (char *)"DEBUG: http_loop_sources(): Traversing sources");
  }
  }
#line 1220
  if (info.num_sources <= 0UL) {
    {
    {
#line 1222
    xa_debug(3, (char *)"DEBUG: http_loop_sources(): Empty tree");
    }
    }
#line 1223
    if (fd < 0) {
      {
      {
#line 1224
      sock_write(clicon->sock, "No sources available<br>");
      }
      }
    } else {
      {
      {
#line 1226
      fd_write(fd, "No sources available<br>");
      }
      }
    }
    {
    {
#line 1227
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
             ident);
    }
    {
#line 1228
    tmp = skip_after(ptr, (char const   *)(buf));
    }
    }
#line 1228
    return (tmp);
  }
  {
  {
#line 1231
  thread_mutex_lock_c(& info.source_mutex, 1231, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
  {
  {
#line 1233
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1233
    tmp___32 = avl_traverse(info.sources, & trav);
    }
#line 1233
    travcon = (connection_t *)tmp___32;
    }
#line 1233
    if (! travcon) {
#line 1233
      goto while_break;
    }
    {
    {
#line 1235
    tmp___0 = con_host(travcon);
    }
    {
#line 1235
    xa_debug(3, (char *)"DEBUG: http_loop_sources(): Running for source [%s]", tmp___0);
    }
#line 1236
    runptr = ptr;
    {
#line 1238
    tmp___1 = ice_itoa(i);
    }
    {
#line 1238
    tmp___2 = n_strdup((char const   *)ident, (int const   )1238, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1238
    add_varpair2(variables, tmp___2, tmp___1);
    }
    {
#line 1239
    tmp___3 = con_host(travcon);
    }
    {
#line 1239
    tmp___4 = n_strdup(tmp___3, (int const   )1239, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1239
    tmp___5 = ice_cat((char const   *)ident, ".host");
    }
    {
#line 1239
    add_varpair2(variables, tmp___5, tmp___4);
    }
    {
#line 1240
    tmp___6 = ice_utoa((travcon->food.source)->num_clients);
    }
    {
#line 1240
    tmp___7 = ice_cat((char const   *)ident, ".clients");
    }
    {
#line 1240
    add_varpair2(variables, tmp___7, tmp___6);
    }
    {
#line 1241
    tmp___8 = n_strdup((char const   *)(travcon->food.source)->dumpfile, (int const   )1241,
                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1241
    tmp___9 = ice_cat((char const   *)ident, ".dumpfile");
    }
    {
#line 1241
    add_varpair2(variables, tmp___9, tmp___8);
    }
    {
#line 1242
    tmp___10 = n_strdup((char const   *)(travcon->food.source)->info.streamurl, (int const   )1242,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1242
    tmp___11 = ice_cat((char const   *)ident, ".streamurl");
    }
    {
#line 1242
    add_varpair2(variables, tmp___11, tmp___10);
    }
    {
#line 1243
    tmp___12 = n_strdup((char const   *)(travcon->food.source)->info.streamtitle,
                        (int const   )1243, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1243
    tmp___13 = ice_cat((char const   *)ident, ".streamtitle");
    }
    {
#line 1243
    add_varpair2(variables, tmp___13, tmp___12);
    }
    {
#line 1244
    tmp___14 = n_strdup((char const   *)(travcon->food.source)->audiocast.name, (int const   )1244,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1244
    tmp___15 = ice_cat((char const   *)ident, ".name");
    }
    {
#line 1244
    add_varpair2(variables, tmp___15, tmp___14);
    }
    {
#line 1245
    tmp___16 = n_strdup((char const   *)(travcon->food.source)->audiocast.genre, (int const   )1245,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1245
    tmp___17 = ice_cat((char const   *)ident, ".genre");
    }
    {
#line 1245
    add_varpair2(variables, tmp___17, tmp___16);
    }
    {
#line 1246
    tmp___18 = n_strdup((char const   *)(travcon->food.source)->audiocast.url, (int const   )1246,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1246
    tmp___19 = ice_cat((char const   *)ident, ".url");
    }
    {
#line 1246
    add_varpair2(variables, tmp___19, tmp___18);
    }
    {
#line 1247
    tmp___20 = n_strdup((char const   *)(travcon->food.source)->audiocast.mount, (int const   )1247,
                        "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1247
    tmp___21 = ice_cat((char const   *)ident, ".mount");
    }
    {
#line 1247
    add_varpair2(variables, tmp___21, tmp___20);
    }
    {
#line 1248
    tmp___22 = n_strdup((char const   *)(travcon->food.source)->audiocast.description,
                        (int const   )1248, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1248
    tmp___23 = ice_cat((char const   *)ident, ".description");
    }
    {
#line 1248
    add_varpair2(variables, tmp___23, tmp___22);
    }
    {
#line 1249
    tmp___24 = ice_itoa((travcon->food.source)->audiocast.public);
    }
    {
#line 1249
    tmp___25 = ice_cat((char const   *)ident, ".public");
    }
    {
#line 1249
    add_varpair2(variables, tmp___25, tmp___24);
    }
    {
#line 1250
    tmp___26 = ice_itoa((travcon->food.source)->audiocast.bitrate);
    }
    {
#line 1250
    tmp___27 = ice_cat((char const   *)ident, ".bitrate");
    }
    {
#line 1250
    add_varpair2(variables, tmp___27, tmp___26);
    }
    {
#line 1251
    tmp___28 = get_time();
    }
    {
#line 1251
    tmp___29 = nice_time((unsigned long )(tmp___28 - travcon->connect_time), buf);
    }
    {
#line 1251
    tmp___30 = n_strdup((char const   *)tmp___29, (int const   )1251, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1251
    tmp___31 = ice_cat((char const   *)ident, ".connecttime");
    }
    {
#line 1251
    add_varpair2(variables, tmp___31, tmp___30);
    }
    {
#line 1252
    endptr = parse_template_file(clicon, (connection_t *)((void *)0), runptr, fd,
                                 variables);
    }
#line 1253
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1257
  thread_mutex_unlock_c(& info.source_mutex, 1257, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 1259
  return (endptr);
}
}
#line 1262 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_loop_admins(char *ident , connection_t *clicon , char const   *ptr ,
                               int fd , vartree_t *variables ) 
{ 
  char const   *runptr ;
  char const   *endptr ;
  char buf[8192] ;
  int i ;
  connection_t *travcon ;
  avl_traverser trav ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
#line 1265
  runptr = ptr;
#line 1265
  endptr = (char const   *)((void *)0);
#line 1267
  i = 0;
#line 1270
  trav.init = 0;
#line 1270
  trav.nstack = 0;
#line 1270
  trav.p = (avl_node const   *)0;
#line 1270
  trav.stack[0] = (avl_node const   *)0;
#line 1270
  trav.stack[1] = (avl_node const   *)0;
#line 1270
  trav.stack[2] = (avl_node const   *)0;
#line 1270
  trav.stack[3] = (avl_node const   *)0;
#line 1270
  trav.stack[4] = (avl_node const   *)0;
#line 1270
  trav.stack[5] = (avl_node const   *)0;
#line 1270
  trav.stack[6] = (avl_node const   *)0;
#line 1270
  trav.stack[7] = (avl_node const   *)0;
#line 1270
  trav.stack[8] = (avl_node const   *)0;
#line 1270
  trav.stack[9] = (avl_node const   *)0;
#line 1270
  trav.stack[10] = (avl_node const   *)0;
#line 1270
  trav.stack[11] = (avl_node const   *)0;
#line 1270
  trav.stack[12] = (avl_node const   *)0;
#line 1270
  trav.stack[13] = (avl_node const   *)0;
#line 1270
  trav.stack[14] = (avl_node const   *)0;
#line 1270
  trav.stack[15] = (avl_node const   *)0;
#line 1270
  trav.stack[16] = (avl_node const   *)0;
#line 1270
  trav.stack[17] = (avl_node const   *)0;
#line 1270
  trav.stack[18] = (avl_node const   *)0;
#line 1270
  trav.stack[19] = (avl_node const   *)0;
#line 1270
  trav.stack[20] = (avl_node const   *)0;
#line 1270
  trav.stack[21] = (avl_node const   *)0;
#line 1270
  trav.stack[22] = (avl_node const   *)0;
#line 1270
  trav.stack[23] = (avl_node const   *)0;
#line 1270
  trav.stack[24] = (avl_node const   *)0;
#line 1270
  trav.stack[25] = (avl_node const   *)0;
#line 1270
  trav.stack[26] = (avl_node const   *)0;
#line 1270
  trav.stack[27] = (avl_node const   *)0;
#line 1270
  trav.stack[28] = (avl_node const   *)0;
#line 1270
  trav.stack[29] = (avl_node const   *)0;
#line 1270
  trav.stack[30] = (avl_node const   *)0;
#line 1270
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1272
  xa_debug(3, (char *)"DEBUG: http_loop_admins(): Traversing admins");
  }
  }
#line 1274
  if (info.num_admins <= 0UL) {
    {
    {
#line 1276
    xa_debug(3, (char *)"DEBUG: http_loop_admins(): Empty tree");
    }
    }
#line 1277
    if (fd < 0) {
      {
      {
#line 1278
      sock_write(clicon->sock, "No admins available<br>");
      }
      }
    } else {
      {
      {
#line 1280
      fd_write(fd, "No admins available<br>");
      }
      }
    }
    {
    {
#line 1281
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
             ident);
    }
    {
#line 1282
    tmp = skip_after(ptr, (char const   *)(buf));
    }
    }
#line 1282
    return (tmp);
  }
  {
  {
#line 1285
  thread_mutex_lock_c(& info.admin_mutex, 1285, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
  {
  {
#line 1287
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1287
    tmp___10 = avl_traverse(info.admins, & trav);
    }
#line 1287
    travcon = (connection_t *)tmp___10;
    }
#line 1287
    if (! travcon) {
#line 1287
      goto while_break;
    }
    {
    {
#line 1289
    tmp___0 = con_host(travcon);
    }
    {
#line 1289
    xa_debug(3, (char *)"DEBUG: http_loop_admins(): Running for admins [%s]", tmp___0);
    }
#line 1290
    runptr = ptr;
    {
#line 1292
    tmp___1 = ice_itoa(i);
    }
    {
#line 1292
    tmp___2 = n_strdup((char const   *)ident, (int const   )1292, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1292
    add_varpair2(variables, tmp___2, tmp___1);
    }
    {
#line 1293
    tmp___3 = con_host(travcon);
    }
    {
#line 1293
    tmp___4 = n_strdup(tmp___3, (int const   )1293, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1293
    tmp___5 = ice_cat((char const   *)ident, ".host");
    }
    {
#line 1293
    add_varpair2(variables, tmp___5, tmp___4);
    }
    {
#line 1294
    tmp___6 = get_time();
    }
    {
#line 1294
    tmp___7 = nice_time((unsigned long )(tmp___6 - travcon->connect_time), buf);
    }
    {
#line 1294
    tmp___8 = n_strdup((char const   *)tmp___7, (int const   )1294, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    {
#line 1294
    tmp___9 = ice_cat((char const   *)ident, ".connecttime");
    }
    {
#line 1294
    add_varpair2(variables, tmp___9, tmp___8);
    }
    {
#line 1295
    endptr = parse_template_file(clicon, (connection_t *)((void *)0), runptr, fd,
                                 variables);
    }
#line 1296
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1300
  thread_mutex_unlock_c(& info.admin_mutex, 1300, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 1302
  return (endptr);
}
}
#line 1306 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_loop_directory(char *ident , connection_t *clicon , char const   *ptr ,
                                  int fd , vartree_t *variables ) 
{ 
  char const   *runptr ;
  char const   *endptr ;
  char buf[8192] ;
  char fullfilename[16384] ;
  struct stat st ;
  int i ;
  dir_t *od ;
  char const   *directoryname ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *escaped ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
  {
#line 1309
  runptr = ptr;
#line 1309
  endptr = (char const   *)((void *)0);
#line 1313
  i = 0;
#line 1314
  od = (dir_t *)((void *)0);
  {
#line 1315
  tmp = get_variable(variables, "LISTED_DIRECTORY");
  }
#line 1315
  directoryname = tmp;
  }
#line 1317
  if (directoryname) {
    {
    {
#line 1318
    od = dir_findfirst(directoryname);
    }
    }
  }
#line 1320
  if (! directoryname) {
    {
    {
#line 1322
    xa_debug(2, (char *)"DEBUG: http_loop_directory(): Could not open directory");
    }
    {
#line 1323
    sock_write(clicon->sock, "No such directory<br>");
    }
    {
#line 1324
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
             ident);
    }
    {
#line 1325
    tmp___0 = skip_after(ptr, (char const   *)(buf));
    }
    }
#line 1325
    return (tmp___0);
  } else
#line 1320
  if (! od) {
    {
    {
#line 1322
    xa_debug(2, (char *)"DEBUG: http_loop_directory(): Could not open directory");
    }
    {
#line 1323
    sock_write(clicon->sock, "No such directory<br>");
    }
    {
#line 1324
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
             ident);
    }
    {
#line 1325
    tmp___0 = skip_after(ptr, (char const   *)(buf));
    }
    }
#line 1325
    return (tmp___0);
  }
  {
  {
#line 1328
  xa_debug(3, (char *)"DEBUG: http_loop_directory(): Traversing directory");
  }
  }
  {
  {
#line 1330
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1330
    tmp___10 = dir_findnext(od);
    }
    }
#line 1330
    if (! tmp___10) {
#line 1330
      goto while_break;
    }
    {
    {
#line 1332
    snprintf((char */* __restrict  */)(fullfilename), (size_t )8192, (char const   */* __restrict  */)"%s/%s",
             directoryname, od->filename);
    }
    {
#line 1333
    tmp___8 = stat((char const   */* __restrict  */)(fullfilename), (struct stat */* __restrict  */)(& st));
    }
    }
#line 1333
    if (tmp___8 == 0) {
      {
      {
#line 1333
      tmp___9 = wild_match((unsigned char const   *)((unsigned char *)"*.mp3"), (unsigned char const   *)((unsigned char *)od->filename));
      }
      }
#line 1333
      if (tmp___9) {
        {
        {
#line 1337
        tmp___1 = ice_itoa(i);
        }
        {
#line 1337
        tmp___2 = n_strdup((char const   *)ident, (int const   )1337, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
        }
        {
#line 1337
        add_varpair2(variables, tmp___2, tmp___1);
        }
        {
#line 1338
        url_encode(od->filename, & escaped);
        }
        {
#line 1339
        tmp___3 = ice_cat((char const   *)ident, ".urlname");
        }
        {
#line 1339
        add_varpair2(variables, tmp___3, escaped);
        }
        {
#line 1340
        tmp___4 = n_strdup(od->filename, (int const   )1340, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
        }
        {
#line 1340
        tmp___5 = ice_cat((char const   *)ident, ".name");
        }
        {
#line 1340
        add_varpair2(variables, tmp___5, tmp___4);
        }
        {
#line 1341
        tmp___6 = ice_itoa((int )st.st_size);
        }
        {
#line 1341
        tmp___7 = ice_cat((char const   *)ident, ".size");
        }
        {
#line 1341
        add_varpair2(variables, tmp___7, tmp___6);
        }
        {
#line 1342
        endptr = parse_template_file(clicon, (connection_t *)((void *)0), runptr,
                                     fd, variables);
        }
#line 1343
        i ++;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1347
  dir_findclose(od);
  }
  }
#line 1349
  return (endptr);
}
}
#line 1352 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char const   *http_loop_listeners(char *ident , connection_t *clicon , char const   *ptr ,
                                  int fd , vartree_t *variables ) 
{ 
  char const   *runptr ;
  char const   *endptr ;
  char buf[8192] ;
  int i ;
  connection_t *travclients ;
  connection_t *travsources ;
  avl_traverser trav ;
  avl_traverser travc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  long tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 1355
  runptr = ptr;
#line 1355
  endptr = (char const   *)((void *)0);
#line 1357
  i = 0;
#line 1360
  trav.init = 0;
#line 1360
  trav.nstack = 0;
#line 1360
  trav.p = (avl_node const   *)0;
#line 1360
  trav.stack[0] = (avl_node const   *)0;
#line 1360
  trav.stack[1] = (avl_node const   *)0;
#line 1360
  trav.stack[2] = (avl_node const   *)0;
#line 1360
  trav.stack[3] = (avl_node const   *)0;
#line 1360
  trav.stack[4] = (avl_node const   *)0;
#line 1360
  trav.stack[5] = (avl_node const   *)0;
#line 1360
  trav.stack[6] = (avl_node const   *)0;
#line 1360
  trav.stack[7] = (avl_node const   *)0;
#line 1360
  trav.stack[8] = (avl_node const   *)0;
#line 1360
  trav.stack[9] = (avl_node const   *)0;
#line 1360
  trav.stack[10] = (avl_node const   *)0;
#line 1360
  trav.stack[11] = (avl_node const   *)0;
#line 1360
  trav.stack[12] = (avl_node const   *)0;
#line 1360
  trav.stack[13] = (avl_node const   *)0;
#line 1360
  trav.stack[14] = (avl_node const   *)0;
#line 1360
  trav.stack[15] = (avl_node const   *)0;
#line 1360
  trav.stack[16] = (avl_node const   *)0;
#line 1360
  trav.stack[17] = (avl_node const   *)0;
#line 1360
  trav.stack[18] = (avl_node const   *)0;
#line 1360
  trav.stack[19] = (avl_node const   *)0;
#line 1360
  trav.stack[20] = (avl_node const   *)0;
#line 1360
  trav.stack[21] = (avl_node const   *)0;
#line 1360
  trav.stack[22] = (avl_node const   *)0;
#line 1360
  trav.stack[23] = (avl_node const   *)0;
#line 1360
  trav.stack[24] = (avl_node const   *)0;
#line 1360
  trav.stack[25] = (avl_node const   *)0;
#line 1360
  trav.stack[26] = (avl_node const   *)0;
#line 1360
  trav.stack[27] = (avl_node const   *)0;
#line 1360
  trav.stack[28] = (avl_node const   *)0;
#line 1360
  trav.stack[29] = (avl_node const   *)0;
#line 1360
  trav.stack[30] = (avl_node const   *)0;
#line 1360
  trav.stack[31] = (avl_node const   *)0;
#line 1360
  travc.init = 0;
#line 1360
  travc.nstack = 0;
#line 1360
  travc.p = (avl_node const   *)0;
#line 1360
  travc.stack[0] = (avl_node const   *)0;
#line 1360
  travc.stack[1] = (avl_node const   *)0;
#line 1360
  travc.stack[2] = (avl_node const   *)0;
#line 1360
  travc.stack[3] = (avl_node const   *)0;
#line 1360
  travc.stack[4] = (avl_node const   *)0;
#line 1360
  travc.stack[5] = (avl_node const   *)0;
#line 1360
  travc.stack[6] = (avl_node const   *)0;
#line 1360
  travc.stack[7] = (avl_node const   *)0;
#line 1360
  travc.stack[8] = (avl_node const   *)0;
#line 1360
  travc.stack[9] = (avl_node const   *)0;
#line 1360
  travc.stack[10] = (avl_node const   *)0;
#line 1360
  travc.stack[11] = (avl_node const   *)0;
#line 1360
  travc.stack[12] = (avl_node const   *)0;
#line 1360
  travc.stack[13] = (avl_node const   *)0;
#line 1360
  travc.stack[14] = (avl_node const   *)0;
#line 1360
  travc.stack[15] = (avl_node const   *)0;
#line 1360
  travc.stack[16] = (avl_node const   *)0;
#line 1360
  travc.stack[17] = (avl_node const   *)0;
#line 1360
  travc.stack[18] = (avl_node const   *)0;
#line 1360
  travc.stack[19] = (avl_node const   *)0;
#line 1360
  travc.stack[20] = (avl_node const   *)0;
#line 1360
  travc.stack[21] = (avl_node const   *)0;
#line 1360
  travc.stack[22] = (avl_node const   *)0;
#line 1360
  travc.stack[23] = (avl_node const   *)0;
#line 1360
  travc.stack[24] = (avl_node const   *)0;
#line 1360
  travc.stack[25] = (avl_node const   *)0;
#line 1360
  travc.stack[26] = (avl_node const   *)0;
#line 1360
  travc.stack[27] = (avl_node const   *)0;
#line 1360
  travc.stack[28] = (avl_node const   *)0;
#line 1360
  travc.stack[29] = (avl_node const   *)0;
#line 1360
  travc.stack[30] = (avl_node const   *)0;
#line 1360
  travc.stack[31] = (avl_node const   *)0;
  {
#line 1362
  xa_debug(3, (char *)"DEBUG: http_loop_listeners(): Traversing clients");
  }
  }
#line 1364
  if (info.num_clients <= 0UL) {
    {
    {
#line 1366
    xa_debug(3, (char *)"DEBUG: http_loop_listeners(): Empty tree");
    }
    }
#line 1367
    if (fd < 0) {
      {
      {
#line 1368
      sock_write(clicon->sock, "No listeners available<br>");
      }
      }
    } else {
      {
      {
#line 1370
      fd_write(fd, "No listeners available<br>");
      }
      }
    }
    {
    {
#line 1371
    snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"@ENDFOR %s@",
             ident);
    }
    {
#line 1372
    tmp = skip_after(ptr, (char const   *)(buf));
    }
    }
#line 1372
    return (tmp);
  }
  {
  {
#line 1375
  thread_mutex_lock_c(& info.double_mutex, 1375, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 1376
  thread_mutex_lock_c(& info.source_mutex, 1376, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
  {
  {
#line 1378
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1378
    tmp___19 = avl_traverse(info.sources, & trav);
    }
#line 1378
    travsources = (connection_t *)tmp___19;
    }
#line 1378
    if (! travsources) {
#line 1378
      goto while_break;
    }
    {
    {
#line 1380
    tmp___0 = con_host(travsources);
    }
    {
#line 1380
    xa_debug(3, (char *)"DEBUG: http_loop_listeners(): Running for listeners for source [%s]",
             tmp___0);
    }
#line 1381
    runptr = ptr;
#line 1382
    i = 0;
    {
#line 1384
    thread_mutex_lock_c(& (travsources->food.source)->mutex, 1384, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    }
    {
    {
#line 1386
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 1386
      tmp___18 = avl_traverse((travsources->food.source)->clients, & travc);
      }
#line 1386
      travclients = (connection_t *)tmp___18;
      }
#line 1386
      if (! travclients) {
#line 1386
        goto while_break___0;
      }
      {
      {
#line 1388
      tmp___1 = ice_itoa(i);
      }
      {
#line 1388
      tmp___2 = n_strdup((char const   *)ident, (int const   )1388, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
      {
#line 1388
      add_varpair2(variables, tmp___2, tmp___1);
      }
      {
#line 1389
      tmp___3 = ice_itoa((int )travclients->id);
      }
      {
#line 1389
      tmp___4 = ice_cat((char const   *)ident, ".id");
      }
      {
#line 1389
      add_varpair2(variables, tmp___4, tmp___3);
      }
      {
#line 1390
      tmp___5 = con_host(travclients);
      }
      {
#line 1390
      tmp___6 = n_strdup(tmp___5, (int const   )1390, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
      {
#line 1390
      tmp___7 = ice_cat((char const   *)ident, ".host");
      }
      {
#line 1390
      add_varpair2(variables, tmp___7, tmp___6);
      }
      {
#line 1391
      tmp___8 = get_user_agent(travclients);
      }
      {
#line 1391
      tmp___9 = html_escape(tmp___8);
      }
      {
#line 1391
      tmp___10 = n_strdup((char const   *)tmp___9, (int const   )1391, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
      {
#line 1391
      tmp___11 = ice_cat((char const   *)ident, ".user_agent");
      }
      {
#line 1391
      add_varpair2(variables, tmp___11, tmp___10);
      }
      {
#line 1392
      tmp___12 = ice_utoa((travclients->food.client)->write_bytes);
      }
      {
#line 1392
      tmp___13 = ice_cat((char const   *)ident, ".writebytes");
      }
      {
#line 1392
      add_varpair2(variables, tmp___13, tmp___12);
      }
      {
#line 1393
      tmp___14 = get_time();
      }
      {
#line 1393
      tmp___15 = nice_time((unsigned long )(tmp___14 - travclients->connect_time),
                           buf);
      }
      {
#line 1393
      tmp___16 = n_strdup((char const   *)tmp___15, (int const   )1393, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
      }
      {
#line 1393
      tmp___17 = ice_cat((char const   *)ident, ".connecttime");
      }
      {
#line 1393
      add_varpair2(variables, tmp___17, tmp___16);
      }
      {
#line 1394
      endptr = parse_template_file(clicon, (connection_t *)((void *)0), runptr, fd,
                                   variables);
      }
#line 1395
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1398
    thread_mutex_unlock_c(& (travsources->food.source)->mutex, 1398, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1402
  thread_mutex_unlock_c(& info.source_mutex, 1402, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 1403
  thread_mutex_unlock_c(& info.double_mutex, 1403, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 1405
  return (endptr);
}
}
#line 1408 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *ice_uptime(void) 
{ 
  char buf[8192] ;
  long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1412
  tmp = get_time();
  }
  {
#line 1412
  tmp___0 = nice_time((unsigned long )(tmp - info.server_start_time), buf);
  }
  {
#line 1412
  tmp___1 = n_strdup((char const   *)tmp___0, (int const   )1412, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 1412
  return (tmp___1);
}
}
#line 1415 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *ice_starttime(void) 
{ 
  char *res ;
  char *ptr ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1419
  tmp = get_string_time(info.server_start_time, (char *)"%d/%b/%Y:%H:%M:%S");
  }
#line 1419
  ptr = tmp;
  {
#line 1420
  res = n_strdup((char const   *)ptr, (int const   )1420, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  }
#line 1421
  if (ptr) {
    {
    {
#line 1422
    free((void *)ptr);
    }
    }
  }
#line 1423
  return (res);
}
}
#line 1426 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void const   *get_http_variable(vartree_t *request_vars , char const   *name ) 
{ 
  char const   *out ;
  char const   *tmp ;
  http_variable_t const   *var ;
  http_variable_t const   *tmp___0 ;

  {
  {
  {
#line 1429
  tmp = get_variable(request_vars, name);
  }
#line 1429
  out = tmp;
  }
#line 1431
  if (out) {
#line 1432
    return ((void const   *)out);
  } else {
    {
    {
#line 1435
    tmp___0 = find_http_variable(name, (http_variable_t const   *)(http_variables));
    }
#line 1435
    var = tmp___0;
    }
#line 1436
    if (! var) {
#line 1437
      return ((void const   *)((void *)0));
    }
#line 1438
    return ((void const   *)var->valueptr);
  }
}
}
#line 1442 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void write_didnt_find_html_page(connection_t *con , char *file ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1445
  write_http_header(con->sock, 200, "OK");
  }
  {
#line 1446
  sock_write_line(con->sock, "Connection: close");
  }
  {
#line 1447
  sock_write_line(con->sock, "Content-Type: text/html\r\n");
  }
  {
#line 1448
  sock_write_line(con->sock, "<html>Template file %s not found.<br></html>", file);
  }
  }
#line 1449
  return;
}
}
#line 1451 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
html_wrapper_t html_wrappers[7]  = {      {100, (char *)"<h3>Connected Admins</h3><br><ul>\n"}, 
        {101, (char *)"<li>%s</li>\n"}, 
        {102, (char *)"End of admin listing<br></ul>\n"}, 
        {160, (char *)"<h3>Connected Listeners</h3><br><ul>\n"}, 
        {161, (char *)"<li>%s</li>\n"}, 
        {162, (char *)"End of client listing<br></ul>\n"}, 
        {0, (char *)((void *)0)}};
#line 1462 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
char *find_html_wrapper(int message_type ) 
{ 
  register int i ;

  {
#line 1466
  i = 0;
  {
  {
#line 1466
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1466
    if (! html_wrappers[i].message_type) {
#line 1466
      goto while_break;
    }
#line 1467
    if (message_type == html_wrappers[i].message_type) {
#line 1468
      return (html_wrappers[i].html);
    }
#line 1466
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1469
  return ((char *)((void *)0));
}
}
#line 1472 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int http_write_string(com_request_t const   *req , int const   message_type , char const   *buff ) 
{ 
  char *wrappertext ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 1475
  tmp = find_html_wrapper((int )message_type);
  }
#line 1475
  wrappertext = tmp;
  }
#line 1477
  if (wrappertext) {
    {
    {
#line 1479
    tmp___1 = strstr((char const   *)wrappertext, "%s");
    }
    }
#line 1479
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
      {
#line 1480
      tmp___0 = sock_write((req->con)->sock, (char const   *)wrappertext, buff);
      }
      }
#line 1480
      return (tmp___0);
    }
    {
    {
#line 1481
    tmp___2 = sock_write_string((req->con)->sock, (char const   *)wrappertext);
    }
    }
#line 1481
    return (tmp___2);
  }
  {
  {
#line 1483
  tmp___3 = sock_write_string((req->con)->sock, buff);
  }
  }
#line 1483
  return (tmp___3);
}
}
#line 1488 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void wrap_http_function(http_command_t const   *http_command , com_request_t *req ,
                        comp_element const   *command ) 
{ 


  {
#line 1491
  return;
}
}
#line 1494 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int http_display(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char command[8196] ;
  char *file ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1497
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1497
  arg = tmp;
  }
#line 1501
  if (! arg) {
    {
    {
#line 1503
    write_no_such_command(req->con, "NULL");
    }
    }
#line 1504
    return (0);
  } else
#line 1501
  if (! *(arg + 0)) {
    {
    {
#line 1503
    write_no_such_command(req->con, "NULL");
    }
    }
#line 1504
    return (0);
  }
  {
  {
#line 1507
  snprintf((char */* __restrict  */)(command), (size_t )8196, (char const   */* __restrict  */)"%s.html",
           arg);
  }
  {
#line 1509
  file = get_template((char const   *)(command));
  }
  }
#line 1511
  if (file) {
    {
    {
#line 1513
    write_template_parsed_html_page(req->con, (connection_t *)((void *)0), (char const   *)file,
                                    -1, (vartree_t *)((void *)0));
    }
    {
#line 1514
    n_free((void *)file, (int const   )1514, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 1514
    file = (char *)((void *)0);
    }
#line 1515
    return (1);
  } else {
    {
    {
#line 1517
    write_http_header((req->con)->sock, 200, "OK");
    }
    {
#line 1518
    sock_write_line((req->con)->sock, "Connection: close");
    }
    {
#line 1519
    sock_write_line((req->con)->sock, "Content-Type: text/html\r\n");
    }
    {
#line 1520
    sock_write_line((req->con)->sock, "<html>No admin template page found for command %s. Create one and try again<br>",
                    arg);
    }
    {
#line 1521
    sock_write_line((req->con)->sock, "Or, you could try the raw command output here:<a href=\"/admin?mode=%s\">%s<br></html>",
                    arg, arg);
    }
    }
#line 1522
    return (0);
  }
}
}
#line 1526 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int http_help(com_request_t *req ) 
{ 
  char *file ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 1529
  tmp = get_template("manual.html");
  }
#line 1529
  file = tmp;
  }
#line 1531
  if (! file) {
    {
    {
#line 1533
    write_didnt_find_html_page(req->con, file);
    }
    }
#line 1534
    return (1);
  }
  {
  {
#line 1537
  http_puke_file_to_socket((req->con)->sock, (char const   *)file);
  }
  }
#line 1538
  return (1);
}
}
#line 1541 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
int http_change(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char helpfile[8192] ;
  char *file ;
  vartree_t *extravars ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
  {
#line 1544
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1544
  arg = tmp;
  }
#line 1549
  if (! arg) {
    {
    {
#line 1550
    sock_write_line((req->con)->sock, "You must supply a variable to be changed<br>\r\n");
    }
    }
#line 1551
    return (0);
  } else
#line 1549
  if (! *(arg + 0)) {
    {
    {
#line 1550
    sock_write_line((req->con)->sock, "You must supply a variable to be changed<br>\r\n");
    }
    }
#line 1551
    return (0);
  }
  {
  {
#line 1554
  snprintf((char */* __restrict  */)(helpfile), (size_t )8192, (char const   */* __restrict  */)"%s.html",
           arg);
  }
  {
#line 1556
  file = get_template((char const   *)(helpfile));
  }
  }
#line 1558
  if (file) {
    {
    {
#line 1559
    write_template_parsed_html_page(req->con, (connection_t *)((void *)0), (char const   *)file,
                                    -2, (vartree_t *)((void *)0));
    }
    {
#line 1560
    n_free((void *)file, (int const   )1560, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
    }
#line 1560
    file = (char *)((void *)0);
    }
  }
  {
  {
#line 1563
  file = get_template("admin_change.html");
  }
  }
#line 1565
  if (! file) {
    {
    {
#line 1566
    write_didnt_find_html_page(req->con, (char *)"admin_change.html");
    }
    }
#line 1567
    return (1);
  }
  {
  {
#line 1570
  extravars = avl_create(& compare_vars, (void *)(& info));
  }
  {
#line 1572
  tmp___0 = n_strdup((char const   *)arg, (int const   )1572, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 1572
  tmp___1 = n_strdup("varname", (int const   )1572, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 1572
  add_varpair2(extravars, tmp___1, tmp___0);
  }
  {
#line 1573
  tmp___2 = variable_to_string(arg);
  }
  {
#line 1573
  tmp___3 = n_strdup("currentvalue", (int const   )1573, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
  {
#line 1573
  add_varpair2(extravars, tmp___3, tmp___2);
  }
  {
#line 1575
  write_template_parsed_html_page(req->con, (connection_t *)((void *)0), (char const   *)file,
                                  -2, extravars);
  }
  {
#line 1577
  n_free((void *)file, (int const   )1577, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c");
  }
#line 1577
  file = (char *)((void *)0);
  }
#line 1579
  return (1);
}
}
#line 1583 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void write_no_such_command(connection_t *con , char const   *name ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1586
  write_http_header(con->sock, 200, "OK");
  }
  {
#line 1587
  sock_write_line(con->sock, "Connection: close");
  }
  {
#line 1588
  sock_write_line(con->sock, "Content-Type: text/html\r\n");
  }
  {
#line 1589
  sock_write_line(con->sock, "<html><h1>You tried to execute a nonexistant command, %s, which was stupid, and won\'t work!<br></html>",
                  name);
  }
  }
#line 1590
  return;
}
}
#line 1592 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/http.c"
void http_puke_file_to_socket(SOCKET s , char const   *template_file ) 
{ 
  struct stat st ;
  int ffd ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1595
  tmp = open_for_reading(template_file);
  }
#line 1595
  ffd = tmp;
  {
#line 1597
  write_http_header(s, 200, "OK");
  }
  {
#line 1598
  sock_write_line(s, "Connection: close");
  }
  {
#line 1599
  sock_write_line(s, "Content-Type: text/html\r\n");
  }
  }
#line 1602
  if (ffd == -1) {
    {
    {
#line 1603
    sock_write_line(s, "ERROR: Cannot open file [%s]<br>", template_file);
    }
    }
#line 1605
    return;
  }
  {
  {
#line 1608
  tmp___0 = fstat(ffd, & st);
  }
  }
#line 1608
  if (tmp___0 == -1) {
    {
    {
#line 1609
    sock_write_line(s, "ERROR: Cannot stat file [%s]", template_file);
    }
    }
#line 1611
    return;
  }
  {
  {
#line 1613
  sock_dump_fd(s, ffd, (int )st.st_size);
  }
  }
#line 1614
  return;
}
}
#line 155 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 255
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 288 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
#line 650
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 773
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 328 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 100 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
void thread_catch_signals(void) ;
#line 101
void thread_setup_default_attributes(void) ;
#line 34 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.h"
void print_connection(void *data , void *param ) ;
#line 35
void print_source(void *data , void *param ) ;
#line 38
void print_client(void *data , void *param ) ;
#line 39
void print_directory(void *data , void *param ) ;
#line 41
directory_server_t *create_directory(void) ;
#line 42
int field_ok(char *xac , char *field ) ;
#line 44
void kick_connection_not_me(void *conarg , void *reasonarg ) ;
#line 46
void kick_everything(void) ;
#line 47
void kick_if_match(char *pattern ) ;
#line 51
connection_t *get_admin_with_id(int id ) ;
#line 54
source_t *source_with_client(connection_t *con ) ;
#line 57
connection_t *find_id(int id ) ;
#line 58
connection_t *find_client_with_id(int id ) ;
#line 65
void do_if_match_all(char *pattern , void (*func)(void *data , void *param ) , void *buf ,
                     int destructive ) ;
#line 66
void do_if_match_tree(avl_tree *tree , char *pattern , void (*func)(void *data , void *param ) ,
                      void *buf , int destructive ) ;
#line 67
void do_if_match_tree_destructive(avl_tree *tree , char *pattern , void (*func)(void *data ,
                                                                                void *param ) ,
                                  void *buf ) ;
#line 74
void clear_source_stats(void *data , void *param ) ;
#line 75
void clear_client_stats(void *data , void *param ) ;
#line 76
void clear_admin_stats(void *data , void *param ) ;
#line 78
void build_request(char *line , request_t *req ) ;
#line 81
void generate_request(char *line , request_t *req ) ;
#line 89
int hostmatch(connection_t const   *con , char const   *pattern ) ;
#line 98
char *type_of_str(contype_t type , char *buf ) ;
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
void flags2string(admin_t *adm , void *param ) ;
#line 32 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
void util_decrease_total_clients(void) ;
#line 92 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int password_match(char const   *crypted , char const   *uncrypted ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 95
  if (! crypted) {
    {
    {
#line 96
    write_log(0, (char *)"ERROR: password_match called with NULL arguments");
    }
    }
#line 97
    return (0);
  } else
#line 95
  if (! uncrypted) {
    {
    {
#line 96
    write_log(0, (char *)"ERROR: password_match called with NULL arguments");
    }
    }
#line 97
    return (0);
  }
  {
  {
#line 100
  tmp = ice_strcmp(crypted, uncrypted);
  }
  }
#line 100
  if (tmp == 0) {
#line 101
    return (1);
  }
#line 103
  return (0);
}
}
#line 142 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_admin(void *data , void *param ) 
{ 
  connection_t *con ;
  admin_t *admin ;
  sock_t *sock ;
  char buf[8192] ;
  char timebuf[8192] ;
  long tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  icethread_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 145
  con = (connection_t *)data;
#line 147
  sock = (sock_t *)((void *)0);
#line 150
  if (! data) {
    {
    {
#line 152
    xa_debug(1, (char *)"DEBUG: print_admin() called with NULL pointer");
    }
    }
#line 153
    return;
  }
#line 156
  admin = con->food.admin;
#line 157
  if (param) {
#line 158
    sock = (sock_t *)param;
  }
  {
  {
#line 160
  tmp = get_time();
  }
  {
#line 160
  tmp___0 = nice_time((unsigned long )(tmp - con->connect_time), timebuf);
  }
  {
#line 160
  tmp___1 = con_host(con);
  }
  {
#line 160
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Admin %ld\t[%s] connected for %s. %d commands issued.\tFlags:",
           con->id, tmp___1, tmp___0, admin->commands);
  }
  }
#line 163
  if (! param) {
    {
    {
#line 164
    fd_write(info.statsfile, "%s", buf);
    }
    {
#line 165
    flags2string(admin, (void *)0);
    }
    {
#line 166
    fd_write(info.statsfile, "\n");
    }
    }
  } else {
    {
    {
#line 168
    sock_write(*sock, "%s", buf);
    }
    {
#line 169
    flags2string(admin, param);
    }
    {
#line 170
    tmp___2 = thread_self();
    }
    {
#line 170
    tmp___3 = thread_equal(tmp___2, (con->food.admin)->thread);
    }
    }
#line 170
    if (tmp___3) {
      {
      {
#line 171
      sock_write(*sock, " - It\'s you! -");
      }
      }
    }
    {
    {
#line 172
    sock_write_line(*sock, "");
    }
    }
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_connection(void *data , void *param ) 
{ 
  char buf[8192] ;
  char timebuf[8192] ;
  connection_t *con ;
  sock_t *sock ;
  char *type ;
  long tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 180
  con = (connection_t *)data;
#line 181
  sock = (sock_t *)((void *)0);
#line 184
  if (param) {
#line 185
    sock = (sock_t *)param;
  }
#line 187
  if ((unsigned int )con->type == 1U) {
#line 188
    type = (char *)"source";
  } else
#line 189
  if ((unsigned int )con->type == 0U) {
#line 190
    type = (char *)"client";
  } else
#line 191
  if ((unsigned int )con->type == 2U) {
#line 192
    type = (char *)"admin";
  } else {
#line 194
    type = (char *)"unknown";
  }
  {
  {
#line 196
  tmp = get_time();
  }
  {
#line 196
  tmp___0 = nice_time((unsigned long )(tmp - con->connect_time), timebuf);
  }
  {
#line 196
  tmp___1 = con_host(con);
  }
  {
#line 196
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"%ld\t [%s] connected for %s. Type: [%s]\r\n",
           con->id, tmp___1, tmp___0, type);
  }
  }
#line 199
  if (! param) {
    {
    {
#line 200
    fd_write(info.statsfile, "%s", buf);
    }
    }
  } else {
    {
    {
#line 202
    sock_write(*sock, "%s", buf);
    }
    }
  }
#line 203
  return;
}
}
#line 207 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_source(void *data , void *param ) 
{ 
  connection_t *con ;
  source_t *source ;
  sock_t *sock ;
  char buf[8192] ;
  char timebuf[8192] ;
  char const   *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 210
  con = (connection_t *)data;
#line 212
  sock = (sock_t *)((void *)0);
#line 215
  source = con->food.source;
#line 216
  if (param) {
#line 217
    sock = (sock_t *)param;
  }
#line 219
  if ((int )source->type == 0) {
#line 219
    tmp = "encoder";
  } else {
#line 219
    tmp = "relay";
  }
  {
  {
#line 219
  tmp___0 = get_time();
  }
  {
#line 219
  tmp___1 = nice_time((unsigned long )(tmp___0 - con->connect_time), timebuf);
  }
  {
#line 219
  tmp___2 = con_host(con);
  }
  {
#line 219
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Source %ld\t[%s] connected for %s, %lu megs transfered, type: %s, streaming to %lu clients.\r\n",
           con->id, tmp___2, tmp___1, source->stats.read_megs, tmp, source->num_clients);
  }
  }
#line 224
  if (! param) {
    {
    {
#line 225
    fd_write(info.statsfile, "%s", buf);
    }
    }
  } else {
    {
    {
#line 227
    sock_write(*sock, "%s", buf);
    }
    }
  }
#line 228
  return;
}
}
#line 232 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_source_verbose(void *data , void *param ) 
{ 
  connection_t *con ;
  source_t *source ;
  sock_t *sock ;
  char buf[8192] ;
  char buf2[16384] ;
  char timebuf[8192] ;
  relay_id_t *rip ;
  avl_traverser trav ;
  int tmp ;
  char const   *tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 235
  con = (connection_t *)data;
#line 237
  sock = (sock_t *)((void *)0);
#line 240
  trav.init = 0;
#line 240
  trav.nstack = 0;
#line 240
  trav.p = (avl_node const   *)0;
#line 240
  trav.stack[0] = (avl_node const   *)0;
#line 240
  trav.stack[1] = (avl_node const   *)0;
#line 240
  trav.stack[2] = (avl_node const   *)0;
#line 240
  trav.stack[3] = (avl_node const   *)0;
#line 240
  trav.stack[4] = (avl_node const   *)0;
#line 240
  trav.stack[5] = (avl_node const   *)0;
#line 240
  trav.stack[6] = (avl_node const   *)0;
#line 240
  trav.stack[7] = (avl_node const   *)0;
#line 240
  trav.stack[8] = (avl_node const   *)0;
#line 240
  trav.stack[9] = (avl_node const   *)0;
#line 240
  trav.stack[10] = (avl_node const   *)0;
#line 240
  trav.stack[11] = (avl_node const   *)0;
#line 240
  trav.stack[12] = (avl_node const   *)0;
#line 240
  trav.stack[13] = (avl_node const   *)0;
#line 240
  trav.stack[14] = (avl_node const   *)0;
#line 240
  trav.stack[15] = (avl_node const   *)0;
#line 240
  trav.stack[16] = (avl_node const   *)0;
#line 240
  trav.stack[17] = (avl_node const   *)0;
#line 240
  trav.stack[18] = (avl_node const   *)0;
#line 240
  trav.stack[19] = (avl_node const   *)0;
#line 240
  trav.stack[20] = (avl_node const   *)0;
#line 240
  trav.stack[21] = (avl_node const   *)0;
#line 240
  trav.stack[22] = (avl_node const   *)0;
#line 240
  trav.stack[23] = (avl_node const   *)0;
#line 240
  trav.stack[24] = (avl_node const   *)0;
#line 240
  trav.stack[25] = (avl_node const   *)0;
#line 240
  trav.stack[26] = (avl_node const   *)0;
#line 240
  trav.stack[27] = (avl_node const   *)0;
#line 240
  trav.stack[28] = (avl_node const   *)0;
#line 240
  trav.stack[29] = (avl_node const   *)0;
#line 240
  trav.stack[30] = (avl_node const   *)0;
#line 240
  trav.stack[31] = (avl_node const   *)0;
#line 242
  source = con->food.source;
#line 243
  if (param) {
#line 244
    sock = (sock_t *)param;
  }
  {
  {
#line 246
  tmp = avl_count((avl_tree const   *)source->clients);
  }
  }
#line 246
  if ((int )source->type == 0) {
#line 246
    tmp___0 = "encoder";
  } else {
#line 246
    tmp___0 = "relay";
  }
  {
  {
#line 246
  tmp___1 = get_time();
  }
  {
#line 246
  tmp___2 = nice_time((unsigned long )(tmp___1 - con->connect_time), timebuf);
  }
  {
#line 246
  tmp___3 = con_host(con);
  }
  {
#line 246
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Source %lu\t[%s] connected for %s, %lu megs transfered, type: %s, streaming to %lu clients, priority: %d, ",
           con->id, tmp___3, tmp___2, source->stats.read_megs, tmp___0, (unsigned long )tmp,
           source->priority);
  }
  }
#line 250
  if (source->dumpfile) {
    {
    {
#line 252
    snprintf((char */* __restrict  */)(buf2), (size_t )8192, (char const   */* __restrict  */)"%sdumping to [%s]\r\n",
             buf, source->dumpfile);
    }
    {
#line 253
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)(buf2),
            (size_t )8192);
    }
    }
  } else {
    {
    {
#line 255
    strcat((char */* __restrict  */)(buf), (char const   */* __restrict  */)"not dumping to any file\r\n");
    }
    }
  }
#line 258
  if (! param) {
    {
    {
#line 259
    fd_write(info.statsfile, "%s", buf);
    }
    }
  } else {
    {
    {
#line 261
    sock_write(*sock, "%s", buf);
    }
    }
  }
#line 263
  if (source->info.streamurl) {
#line 263
    tmp___4 = (char const   *)source->info.streamurl;
  } else {
#line 263
    tmp___4 = "n/a";
  }
#line 263
  if (source->info.streamtitle) {
#line 263
    tmp___5 = (char const   *)source->info.streamtitle;
  } else {
#line 263
    tmp___5 = "n/a";
  }
  {
  {
#line 263
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"\tStream Title: %s\r\n\tStream URL: %s\tx-audiocast-name: %s\r\n\tx-audiocast-genre: %s\r\n\tx-audiocast-bitrate: %d\r\n\tx-audiocast-url: %s\r\n\tx-audiocast-mount: %s\r\n\tx-audiocast-description: %s\r\n\tx-audiocast-public: %d\r\n",
           tmp___5, tmp___4, source->audiocast.name, source->audiocast.genre, source->audiocast.bitrate,
           source->audiocast.url, source->audiocast.mount, source->audiocast.description,
           source->audiocast.public);
  }
  }
#line 268
  if (! param) {
    {
    {
#line 269
    fd_write(info.statsfile, "%s", buf);
    }
    }
  } else {
    {
    {
#line 271
    sock_write(*sock, "%s", buf);
    }
    }
  }
#line 273
  if (! param) {
    {
    {
#line 274
    fd_write(info.statsfile, "\tdirectory servers: ");
    }
    }
  } else {
    {
    {
#line 276
    sock_write(*sock, "\tdirectory servers: ");
    }
    }
  }
  {
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 278
    tmp___6 = avl_traverse(source->relay_tree, & trav);
    }
#line 278
    rip = (relay_id_t *)tmp___6;
    }
#line 278
    if (! rip) {
#line 278
      goto while_break;
    }
#line 280
    if (! param) {
      {
      {
#line 281
      fd_write(info.statsfile, "%s:%d ", rip->host, rip->id);
      }
      }
    } else {
      {
      {
#line 283
      sock_write(*sock, "%s:%d ", rip->host, rip->id);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if (! param) {
    {
    {
#line 287
    fd_write(info.statsfile, "\n");
    }
    }
  } else {
    {
    {
#line 289
    sock_write(*sock, "\r\n");
    }
    }
  }
#line 291
  return;
}
}
#line 293 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_clients(void *data , void *param ) 
{ 
  connection_t *con ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 296
  con = (connection_t *)data;
#line 298
  if (param) {
    {
    {
#line 300
    sock_write_line(*((sock_t *)param), "--- Source ---");
    }
    {
#line 301
    print_source((void *)con, param);
    }
    {
#line 302
    sock_write_line(*((sock_t *)param), "--- Listeners ---");
    }
    }
  } else {
    {
    {
#line 304
    fd_write(info.statsfile, "--- Source ---\n");
    }
    {
#line 305
    print_source((void *)con, param);
    }
    {
#line 306
    fd_write(info.statsfile, "--- Listeners ---\n");
    }
    }
  }
  {
  {
#line 309
  thread_mutex_lock_c(& (con->food.source)->mutex, 309, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 310
  avl_walk((con->food.source)->clients, & print_client, param);
  }
  {
#line 311
  thread_mutex_unlock_c(& (con->food.source)->mutex, 311, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 312
  return;
}
}
#line 314 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_client(void *data , void *param ) 
{ 
  connection_t *con ;
  client_t *client ;
  sock_t *sock ;
  char buf[8192] ;
  char timebuf[8192] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 317
  con = (connection_t *)data;
#line 319
  sock = (sock_t *)((void *)0);
#line 322
  if (param) {
#line 323
    sock = (sock_t *)param;
  }
#line 325
  client = con->food.client;
#line 327
  if ((int )client->type == 0) {
#line 327
    tmp = "listener";
  } else {
#line 327
    tmp = "relay";
  }
  {
  {
#line 327
  tmp___0 = get_user_agent(con);
  }
  {
#line 327
  tmp___1 = client_errors((client_t const   *)client);
  }
  {
#line 327
  tmp___2 = get_time();
  }
  {
#line 327
  tmp___3 = nice_time((unsigned long )(tmp___2 - con->connect_time), timebuf);
  }
  {
#line 327
  tmp___4 = con_host(con);
  }
  {
#line 327
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Client %ld\t[%s] connected for %s, %lu bytes transfered. %d errors. User agent: [%s]. Type: %s\r\n",
           con->id, tmp___4, tmp___3, client->write_bytes, tmp___1, tmp___0, tmp);
  }
  }
#line 331
  if (! param) {
    {
    {
#line 332
    fd_write(info.statsfile, "%s", buf);
    }
    }
  } else {
    {
    {
#line 334
    sock_write(*sock, "%s", buf);
    }
    }
  }
#line 335
  return;
}
}
#line 337 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_directory(void *data , void *param ) 
{ 
  directory_server_t *dir ;
  sock_t *sock ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 340
  dir = (directory_server_t *)data;
#line 343
  if (param) {
#line 344
    sock = (sock_t *)param;
#line 345
    if ((unsigned int )dir->type == 0U) {
      {
      {
#line 346
      sock_write_line(*sock, "Server: [%s] id: [%d] touches: [%d]", dir->host, dir->id,
                      dir->counter);
      }
      }
    } else {
      {
      {
#line 348
      sock_write_line(*sock, "Server: [%s:%d%s] id: [%d] touches: [%d]", dir->host,
                      dir->port, dir->path, dir->id, dir->counter);
      }
      }
    }
  }
#line 350
  return;
}
}
#line 353 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int field_ok(char *xac , char *field ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 356
  if (! field) {
    {
    {
#line 358
    write_log(0, (char *)"Header is missing %s field", xac);
    }
    }
#line 359
    return (0);
  } else
#line 356
  if (! *(field + 0)) {
    {
    {
#line 358
    write_log(0, (char *)"Header is missing %s field", xac);
    }
    }
#line 359
    return (0);
  }
#line 362
  return (1);
}
}
#line 365 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int find_frame_ofs(source_t *source ) 
{ 
  char *buff ;
  int pos ;
  int cid ;
  char *__cil_tmp5 ;

  {
#line 368
  pos = 0;
#line 370
  if (! source) {
    {
    {
#line 372
    write_log(0, (char *)"ERROR: find_frame_ofs() called with NULL argument");
    }
    }
#line 373
    return (0);
  }
#line 376
  if (info.use_meta_data) {
#line 377
    return (0);
  }
#line 379
  if (source->cid <= 0) {
#line 379
    cid = 63;
  } else {
#line 379
    cid = source->cid - 1;
  }
#line 381
  buff = source->chunk[cid].data;
  {
  {
#line 383
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 383
    if (! (pos < source->chunk[cid].len - 1)) {
#line 383
      goto while_break;
    }
#line 384
    if (((int )*(buff + pos) & 255) == 255) {
#line 384
      if (((int )*(buff + (pos + 1)) & 240) == 240) {
#line 385
        goto while_break;
      }
    }
#line 386
    pos ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (pos);
}
}
#line 393 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_connection_not_me(void *conarg , void *reasonarg ) 
{ 
  connection_t *kickcon ;
  icethread_t tmp ;
  int tmp___0 ;
  icethread_t tmp___1 ;
  int tmp___2 ;

  {
#line 396
  kickcon = (connection_t *)conarg;
#line 398
  if ((unsigned int )kickcon->type == 2U) {
    {
    {
#line 400
    tmp = thread_self();
    }
    {
#line 400
    tmp___0 = thread_equal((kickcon->food.admin)->thread, tmp);
    }
    }
#line 400
    if (tmp___0) {
#line 401
      return;
    }
  } else
#line 402
  if ((unsigned int )kickcon->type == 1U) {
    {
    {
#line 404
    tmp___1 = thread_self();
    }
    {
#line 404
    tmp___2 = thread_equal((kickcon->food.source)->thread, tmp___1);
    }
    }
#line 404
    if (tmp___2) {
#line 405
      return;
    }
  }
  {
  {
#line 407
  kick_connection(conarg, reasonarg);
  }
  }
#line 408
  return;
}
}
#line 410 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_connection(void *conarg , void *reasonarg ) 
{ 
  connection_t *con ;
  char *reason ;
  char timebuf[8192] ;
  unsigned int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  relay_t *rel ;
  relay_t *tmp___4 ;
  long tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  long tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  long tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 413
  con = (connection_t *)conarg;
#line 414
  reason = (char *)reasonarg;
#line 416
  timebuf[0] = (char )'\000';
#line 416
  tmp = 1U;
  {
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 416
    if (tmp >= 8192U) {
#line 416
      goto while_break;
    }
#line 416
    timebuf[tmp] = (char)0;
#line 416
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  if (! conarg) {
    {
    {
#line 420
    write_log(0, (char *)"WARNING: kick_connection called with NULL pointers");
    }
    }
#line 421
    return;
  } else
#line 418
  if (! reasonarg) {
    {
    {
#line 420
    write_log(0, (char *)"WARNING: kick_connection called with NULL pointers");
    }
    }
#line 421
    return;
  }
  {
#line 426
  if ((unsigned int )con->type == 0U) {
#line 426
    goto case_0;
  }
#line 446
  if ((unsigned int )con->type == 2U) {
#line 446
    goto case_2;
  }
#line 454
  if ((unsigned int )con->type == 1U) {
#line 454
    goto case_1;
  }
#line 469
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 427
  tmp___0 = get_time();
  }
  {
#line 427
  tmp___1 = nice_time((unsigned long )(tmp___0 - con->connect_time), timebuf);
  }
  }
#line 427
  if ((int )(con->food.client)->type == 0) {
#line 427
    tmp___2 = "listener";
  } else {
#line 427
    tmp___2 = "relay";
  }
  {
  {
#line 427
  tmp___3 = con_host(con);
  }
  {
#line 427
  write_log(0, (char *)"Kicking client %d [%s] [%s] [%s], connected for %s, %lu bytes transfered. %d clients connected",
            con->id, tmp___3, reason, tmp___2, tmp___1, (con->food.client)->write_bytes,
            info.num_clients - 1UL);
  }
#line 431
  (con->food.client)->alive = 0;
  }
#line 433
  if ((int )(con->food.client)->type == 1) {
    {
    {
#line 434
    tmp___4 = relay_find_with_con(con);
    }
#line 434
    rel = tmp___4;
    }
#line 435
    if (rel) {
#line 436
      rel->con = (connection_t *)((void *)0);
#line 437
      rel->reconnect_now = 1;
    } else {
      {
      {
#line 440
      write_log(0, (char *)"WARNING: Pushing relay was not found in the list of relays");
      }
      }
    }
  }
  {
  {
#line 443
  write_clf(con, (con->food.client)->source);
  }
  }
#line 444
  return;
#line 445
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 447
  tmp___5 = get_time();
  }
  {
#line 447
  tmp___6 = nice_time((unsigned long )(tmp___5 - con->connect_time), timebuf);
  }
  {
#line 447
  tmp___7 = con_host(con);
  }
  {
#line 447
  write_log(0, (char *)"Kicking admin %d [%s] [%s], %d commands issued, connected for %s. %d admins connected",
            con->id, tmp___7, reason, (con->food.admin)->commands, tmp___6, info.num_admins - 1UL);
  }
  {
#line 450
  sock_close(con->sock);
  }
#line 451
  (con->food.admin)->alive = 0U;
  }
#line 452
  return;
#line 453
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 455
  tmp___8 = get_time();
  }
  {
#line 455
  tmp___9 = nice_time((unsigned long )(tmp___8 - con->connect_time), timebuf);
  }
  }
#line 455
  if ((int )(con->food.source)->type == 0) {
#line 455
    tmp___10 = "encoder";
  } else {
#line 455
    tmp___10 = "relay";
  }
  {
  {
#line 455
  tmp___11 = con_host(con);
  }
  {
#line 455
  write_log(0, (char *)"Kicking source %d [%s] [%s] [%s], connected for %s, %lu bytes transfered. %d sources connected",
            con->id, tmp___11, reason, tmp___10, tmp___9, (con->food.source)->stats.read_bytes,
            info.num_sources - 1UL);
  }
  }
#line 459
  if ((con->food.source)->connected == 2) {
    {
    {
#line 460
    close_connection((void *)con, (void *)0);
    }
    }
  } else {
    {
    {
#line 464
    sock_close(con->sock);
    }
#line 465
    (con->food.source)->connected = 0;
    }
  }
#line 467
  return;
#line 468
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 470
  tmp___12 = get_time();
  }
  {
#line 470
  tmp___13 = nice_time((unsigned long )(tmp___12 - con->connect_time), timebuf);
  }
  {
#line 470
  tmp___14 = con_host(con);
  }
  {
#line 470
  write_log(0, (char *)"Kicking unknown %d [%s] [%s], connected for %s", con->id,
            tmp___14, reason, tmp___13);
  }
  }
#line 472
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 474
  close_connection((void *)con, (void *)(& info));
  }
  }
#line 475
  return;
}
}
#line 478 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
directory_server_t *create_directory(void) 
{ 
  directory_server_t *dir ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 480
  tmp = n_malloc((unsigned int const   )sizeof(directory_server_t ), (int const   )480,
                 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 480
  dir = (directory_server_t *)tmp;
#line 481
  dir->counter = 0;
#line 482
  dir->touches = 0;
#line 483
  dir->id = -1;
#line 484
  dir->host = (char *)((void *)0);
#line 485
  dir->port = -1;
#line 486
  dir->path = (char *)((void *)0);
  }
#line 487
  return (dir);
}
}
#line 490 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void close_directory(void *data , void *param ) 
{ 
  directory_server_t *dir ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 492
  dir = (directory_server_t *)data;
#line 494
  if (dir->id >= 0) {
#line 494
    if ((unsigned int )dir->type == 0U) {
      {
      {
#line 495
      directory_remove(dir);
      }
      }
    }
  }
  {
  {
#line 496
  avl_delete(info.d_servers, (void const   *)dir);
  }
  {
#line 497
  n_free((void *)dir->host, (int const   )497, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 497
  dir->host = (char *)((void *)0);
  {
#line 498
  n_free((void *)dir->path, (int const   )498, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 498
  dir->path = (char *)((void *)0);
  {
#line 499
  n_free((void *)dir, (int const   )499, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 499
  dir = (directory_server_t *)((void *)0);
  }
#line 500
  return;
}
}
#line 502 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *get_admin_with_id(int id ) 
{ 
  connection_t con ;
  connection_t *res ;
  void *tmp ;

  {
  {
#line 508
  con.type = (contype_t )2;
#line 509
  con.id = (unsigned long )id;
  {
#line 510
  tmp = avl_find(info.admins, (void const   *)(& con));
  }
#line 510
  res = (connection_t *)tmp;
  }
#line 511
  return (res);
}
}
#line 514 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void free_con(connection_t *con ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 517
  if (con->sock >= 0) {
#line 519
    if (con->host) {
      {
      {
#line 519
      tmp = ice_strcmp((char const   *)con->host, "icecast console");
      }
      }
#line 519
      if (! (tmp == 0)) {
        {
        {
#line 520
        sock_close(con->sock);
        }
#line 521
        con->sock = -1;
        }
      }
    } else {
      {
      {
#line 520
      sock_close(con->sock);
      }
#line 521
      con->sock = -1;
      }
    }
  }
#line 525
  if ((unsigned long )con->host != (unsigned long )((void *)0)) {
    {
    {
#line 527
    n_free((void *)con->host, (int const   )527, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 527
    con->host = (char *)((void *)0);
#line 528
    con->host = (char *)((void *)0);
    }
  }
#line 531
  if (con->headervars) {
    {
    {
#line 532
    free_con_variables(con);
    }
    }
  }
#line 534
  if (con->sin) {
    {
    {
#line 535
    n_free((void *)con->sin, (int const   )535, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
#line 535
  con->sin = (struct sockaddr_in *)((void *)0);
#line 537
  if ((unsigned long )con->hostname != (unsigned long )((void *)0)) {
    {
    {
#line 539
    n_free((void *)con->hostname, (int const   )539, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 539
    con->hostname = (char *)((void *)0);
#line 540
    con->hostname = (char *)((void *)0);
    }
  }
#line 542
  return;
}
}
#line 548 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void close_connection(void *data , void *param ) 
{ 
  connection_t *con ;
  source_t *con2 ;
  source_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  source_t *source ;
  connection_t *clicon ;
  avl_traverser trav ;
  relay_id_t *rip ;
  connection_t *smaller ;
  connection_t *tmp___3 ;
  void *tmp___4 ;
  relay_t *rel ;
  void *tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;

  {
#line 551
  con = (connection_t *)data;
#line 553
  if (! con) {
    {
    {
#line 554
    write_log(0, (char *)"ERROR: close_connection called with null pointer!");
    }
    }
#line 555
    return;
  }
  {
  {
#line 558
  xa_debug(2, (char *)"DEBUG: Removing connection %d of type %d", con->id, (unsigned int )con->type);
  }
  {
#line 560
  free_con(con);
  }
  }
#line 562
  if ((unsigned int )con->type == 2U) {
    {
    {
#line 563
    xa_debug(2, (char *)"Removing admin %d (%p) from admintree of (%p)", con->id,
             con, info.admins);
    }
    {
#line 564
    del_admin();
    }
    {
#line 565
    avl_delete(info.admins, (void const   *)con);
    }
    {
#line 566
    n_free((void *)con->food.admin, (int const   )566, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 566
    con->food.admin = (admin_t *)((void *)0);
    {
#line 567
    n_free((void *)con, (int const   )567, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 567
    con = (connection_t *)((void *)0);
    }
#line 568
    return;
  } else
#line 571
  if ((unsigned int )con->type == 0U) {
    {
    {
#line 572
    tmp = source_with_client(con);
    }
#line 572
    con2 = tmp;
    }
#line 574
    if (! con2) {
      {
      {
#line 575
      xa_debug(2, (char *)"DEBUG: Client with NULL source?");
      }
      }
    }
#line 577
    if ((con->food.client)->virgin == 0) {
      {
      {
#line 578
      del_client(con, con2);
      }
      }
    } else {
      {
      {
#line 580
      util_decrease_total_clients();
      }
      }
    }
#line 582
    if (con2) {
      {
      {
#line 584
      tmp___0 = get_time();
      }
#line 584
      con2->stats.client_connect_time += (unsigned long )((double )(tmp___0 - con->connect_time) / 60.0);
      {
#line 585
      tmp___1 = get_time();
      }
#line 585
      info.hourly_stats.client_connect_time += (unsigned long )((double )(tmp___1 - con->connect_time) / 60.0);
      {
#line 587
      xa_debug(2, (char *)"DEBUG: Removing client %d (%p) from sourcetree of (%p)",
               con->id, con, con2);
      }
      {
#line 589
      tmp___2 = avl_delete(con2->clients, (void const   *)con);
      }
      }
#line 589
      if (! tmp___2) {
        {
        {
#line 590
        xa_debug(2, (char *)"DEBUG: Didn\'t find client in sourcetree, shit!");
        }
        }
      }
    } else {
      {
      {
#line 592
      xa_debug(2, (char *)"DEBUG: client %d without source?", con->id);
      }
      }
    }
    {
    {
#line 594
    n_free((void *)con->food.client, (int const   )594, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 594
    con->food.client = (client_t *)((void *)0);
    {
#line 595
    n_free((void *)con, (int const   )595, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 595
    con = (connection_t *)((void *)0);
    }
#line 596
    return;
  } else
#line 599
  if ((unsigned int )con->type == 1U) {
#line 600
    source = con->food.source;
#line 603
    if (! source) {
      {
      {
#line 605
      write_log(0, (char *)"WARNING!!! - Erroneous source without food");
      }
      }
#line 606
      return;
    }
    {
    {
#line 609
    xa_debug(2, (char *)"Removing source %d (%p) from sourcetree of (%p)", con->id,
             con, info.sources);
    }
    }
#line 611
    if (source) {
#line 611
      if (source->clients) {
        {
#line 613
        trav.init = 0;
#line 613
        trav.nstack = 0;
#line 613
        trav.p = (avl_node const   *)0;
#line 613
        trav.stack[0] = (avl_node const   *)0;
#line 613
        trav.stack[1] = (avl_node const   *)0;
#line 613
        trav.stack[2] = (avl_node const   *)0;
#line 613
        trav.stack[3] = (avl_node const   *)0;
#line 613
        trav.stack[4] = (avl_node const   *)0;
#line 613
        trav.stack[5] = (avl_node const   *)0;
#line 613
        trav.stack[6] = (avl_node const   *)0;
#line 613
        trav.stack[7] = (avl_node const   *)0;
#line 613
        trav.stack[8] = (avl_node const   *)0;
#line 613
        trav.stack[9] = (avl_node const   *)0;
#line 613
        trav.stack[10] = (avl_node const   *)0;
#line 613
        trav.stack[11] = (avl_node const   *)0;
#line 613
        trav.stack[12] = (avl_node const   *)0;
#line 613
        trav.stack[13] = (avl_node const   *)0;
#line 613
        trav.stack[14] = (avl_node const   *)0;
#line 613
        trav.stack[15] = (avl_node const   *)0;
#line 613
        trav.stack[16] = (avl_node const   *)0;
#line 613
        trav.stack[17] = (avl_node const   *)0;
#line 613
        trav.stack[18] = (avl_node const   *)0;
#line 613
        trav.stack[19] = (avl_node const   *)0;
#line 613
        trav.stack[20] = (avl_node const   *)0;
#line 613
        trav.stack[21] = (avl_node const   *)0;
#line 613
        trav.stack[22] = (avl_node const   *)0;
#line 613
        trav.stack[23] = (avl_node const   *)0;
#line 613
        trav.stack[24] = (avl_node const   *)0;
#line 613
        trav.stack[25] = (avl_node const   *)0;
#line 613
        trav.stack[26] = (avl_node const   *)0;
#line 613
        trav.stack[27] = (avl_node const   *)0;
#line 613
        trav.stack[28] = (avl_node const   *)0;
#line 613
        trav.stack[29] = (avl_node const   *)0;
#line 613
        trav.stack[30] = (avl_node const   *)0;
#line 613
        trav.stack[31] = (avl_node const   *)0;
        {
#line 615
        tmp___3 = get_twin_mount(source);
        }
#line 615
        smaller = tmp___3;
        {
#line 617
        write_log(0, (char *)"Kicking all %d clients for source %d", source->num_clients,
                  con->id);
        }
        }
        {
        {
#line 619
        while (1) {
          while_continue___1: /* CIL Label */ ;
          while_continue: /* CIL Label */ ;
          {
          {
#line 619
          tmp___4 = avl_traverse(source->clients, & trav);
          }
#line 619
          clicon = (connection_t *)tmp___4;
          }
#line 619
          if (! clicon) {
#line 619
            goto while_break;
          }
#line 621
          if (smaller) {
            {
            {
#line 622
            move_to_smaller_twin(source, clicon);
            }
            }
          } else {
            {
            {
#line 624
            kick_connection((void *)clicon, (void *)"Stream ended");
            }
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
        {
        {
#line 626
        kick_dead_clients(source);
        }
        }
#line 628
        if ((int )(con->food.source)->type == 1) {
#line 631
          if (source->connected != 0) {
#line 631
            if (source->connected != 2) {
#line 631
              if (source->connected != 4) {
                {
                {
#line 633
                thread_mutex_lock_c(& info.thread_mutex, 633, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
                }
                {
#line 634
                rel = relay_find_with_con(con);
                }
                {
#line 635
                thread_mutex_unlock_c(& info.thread_mutex, 635, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
                }
                }
              } else {
                {
                {
#line 637
                rel = relay_find_with_con(con);
                }
                }
              }
            } else {
              {
              {
#line 637
              rel = relay_find_with_con(con);
              }
              }
            }
          } else {
            {
            {
#line 637
            rel = relay_find_with_con(con);
            }
            }
          }
#line 638
          if (rel) {
#line 639
            rel->con = (connection_t *)((void *)0);
          }
        }
#line 642
        if (source->relay_tree) {
          {
          {
#line 644
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue___0: /* CIL Label */ ;
            {
            {
#line 644
            tmp___6 = avl_get_any_node(source->relay_tree);
            }
#line 644
            rip = (relay_id_t *)tmp___6;
            }
#line 644
            if (! rip) {
#line 644
              goto while_break___0;
            }
            {
            {
#line 646
            tmp___5 = avl_delete(source->relay_tree, (void const   *)rip);
            }
            }
#line 646
            if (! tmp___5) {
              {
              {
#line 647
              write_log(0, (char *)"ERROR: relay id not in relay tree");
              }
              }
            }
            {
            {
#line 648
            n_free((void *)rip->host, (int const   )648, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
            }
#line 648
            rip->host = (char *)((void *)0);
            {
#line 649
            n_free((void *)rip, (int const   )649, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
            }
#line 649
            rip = (relay_id_t *)((void *)0);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
          {
#line 651
          avl_destroy(source->relay_tree, (void (*)(void *data , void *param ))((void *)0));
          }
          }
        }
        {
        {
#line 654
        avl_destroy(source->clients, (void (*)(void *data , void *param ))((void *)0));
        }
        }
      }
    }
    {
    {
#line 657
    dispose_audiocast(& source->audiocast);
    }
    {
#line 661
    n_free((void *)source->info.streamtitle, (int const   )661, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 661
    source->info.streamtitle = (char *)((void *)0);
    {
#line 662
    n_free((void *)source->info.streamurl, (int const   )662, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 662
    source->info.streamurl = (char *)((void *)0);
    {
#line 663
    n_free((void *)source->info.streammsg, (int const   )663, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 663
    source->info.streammsg = (char *)((void *)0);
    }
#line 665
    if (source->dumpfile) {
      {
      {
#line 667
      n_free((void *)source->dumpfile, (int const   )667, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
#line 667
      source->dumpfile = (char *)((void *)0);
#line 668
      source->dumpfile = (char *)((void *)0);
      {
#line 669
      fd_close(source->dumpfd);
      }
#line 670
      source->dumpfd = -1;
      }
    }
    {
    {
#line 673
    tmp___7 = get_time();
    }
#line 673
    info.hourly_stats.source_connect_time += (unsigned long )((tmp___7 - con->connect_time) / 60L);
    }
#line 676
    if ((con->food.source)->connected != 2) {
      {
      {
#line 678
      del_source();
      }
      {
#line 679
      avl_delete(info.sources, (void const   *)con);
      }
      }
    }
#line 682
    if (source->mutex.thread_id >= 0L) {
      {
      {
#line 683
      thread_mutex_unlock_c(& source->mutex, 683, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      }
    }
    {
    {
#line 684
    thread_mutex_destroy(& source->mutex);
    }
    {
#line 686
    n_free((void *)source, (int const   )686, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 686
    source = (source_t *)((void *)0);
    {
#line 687
    n_free((void *)con, (int const   )687, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 687
    con = (connection_t *)((void *)0);
    }
#line 688
    return;
  }
  {
  {
#line 691
  n_free((void *)con, (int const   )691, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 691
  con = (connection_t *)((void *)0);
  }
#line 692
  return;
}
}
#line 695 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_not_connected(connection_t *con , char *reason ) 
{ 
  char timebuf[8192] ;
  char typebuf[10] ;
  long tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 701
  if (reason) {
    {
    {
#line 702
    tmp = get_time();
    }
    {
#line 702
    tmp___0 = nice_time((unsigned long )(tmp - con->connect_time), timebuf);
    }
    {
#line 702
    tmp___1 = con_host(con);
    }
    {
#line 702
    tmp___2 = type_of_str(con->type, typebuf);
    }
    {
#line 702
    write_log(0, (char *)"Kicking %s %d [%s] [%s], connected for %s", tmp___2, con->id,
              tmp___1, reason, tmp___0);
    }
    }
  }
  {
  {
#line 705
  free_con(con);
  }
  }
#line 707
  if ((unsigned int )con->type == 1U) {
    {
    {
#line 709
    avl_destroy((con->food.source)->relay_tree, (void (*)(void *data , void *param ))((void *)0));
    }
    {
#line 710
    avl_destroy((con->food.source)->clients, (void (*)(void *data , void *param ))((void *)0));
    }
    {
#line 711
    n_free((void *)con->food.source, (int const   )711, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 711
    con->food.source = (source_t *)((void *)0);
    }
  } else
#line 713
  if ((unsigned int )con->type == 0U) {
    {
    {
#line 715
    n_free((void *)con->food.client, (int const   )715, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 715
    con->food.client = (client_t *)((void *)0);
    }
  } else
#line 717
  if ((unsigned int )con->type == 2U) {
    {
    {
#line 719
    n_free((void *)con->food.admin, (int const   )719, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
#line 719
    con->food.admin = (admin_t *)((void *)0);
    }
  }
  {
  {
#line 722
  n_free((void *)con, (int const   )722, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 722
  con = (connection_t *)((void *)0);
  }
#line 723
  return;
}
}
#line 725 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_silently(connection_t *con ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 728
  free_con(con);
  }
  {
#line 730
  n_free((void *)con, (int const   )730, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 730
  con = (connection_t *)((void *)0);
  }
#line 731
  return;
}
}
#line 734 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
source_t *source_with_client(connection_t *con ) 
{ 


  {
#line 737
  if (con) {
#line 738
    return ((con->food.client)->source);
  }
#line 739
  return ((source_t *)((void *)0));
}
}
#line 743 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int server_detach(void) 
{ 
  pid_t icepid ;
  FILE *tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 747
  write_log(0, (char *)"Trying to fork");
  }
  {
#line 749
  icepid = fork();
  }
  }
#line 750
  if (icepid == -1) {
    {
    {
#line 751
    write_log(0, (char *)"ERROR: Can\'t fork dammit!");
    }
    }
#line 752
    return (1);
  }
#line 755
  if (icepid != 0) {
    {
    {
#line 757
    write_log(0, (char *)"Detached (pid: %d)", icepid);
    }
    {
#line 758
    setpgid(icepid, icepid);
    }
    {
#line 760
    exit(0);
    }
    }
  } else {
    {
    {
#line 763
    setpgid(0, 0);
    }
    {
#line 765
    tmp = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
                  (FILE */* __restrict  */)stdin);
    }
    }
#line 765
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
      {
      {
#line 766
      perror("freopen (stdin)");
      }
      {
#line 767
      exit(1);
      }
      }
    }
    {
    {
#line 769
    tmp___0 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                      (FILE */* __restrict  */)stdout);
    }
    }
#line 769
    if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
      {
      {
#line 770
      perror("freopen (stdout)");
      }
      {
#line 771
      exit(1);
      }
      }
    }
    {
    {
#line 773
    tmp___1 = freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                      (FILE */* __restrict  */)stderr);
    }
    }
#line 773
    if ((unsigned long )((void *)0) == (unsigned long )tmp___1) {
      {
      {
#line 774
      perror("freopen (stderr)");
      }
      {
#line 775
      exit(1);
      }
      }
    }
    {
    {
#line 777
    fd_close(0);
    }
    {
#line 778
    fd_close(1);
    }
    {
#line 779
    fd_close(2);
    }
    }
  }
#line 781
  return (1);
}
}
#line 785 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_con_with_host(struct sockaddr_in  const  *sin ) 
{ 
  connection_t *clicon ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  avl_traverser clitrav ;
  char hbuf[8192] ;
  char *hostptr ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 789
  trav.init = 0;
#line 789
  trav.nstack = 0;
#line 789
  trav.p = (avl_node const   *)0;
#line 789
  trav.stack[0] = (avl_node const   *)0;
#line 789
  trav.stack[1] = (avl_node const   *)0;
#line 789
  trav.stack[2] = (avl_node const   *)0;
#line 789
  trav.stack[3] = (avl_node const   *)0;
#line 789
  trav.stack[4] = (avl_node const   *)0;
#line 789
  trav.stack[5] = (avl_node const   *)0;
#line 789
  trav.stack[6] = (avl_node const   *)0;
#line 789
  trav.stack[7] = (avl_node const   *)0;
#line 789
  trav.stack[8] = (avl_node const   *)0;
#line 789
  trav.stack[9] = (avl_node const   *)0;
#line 789
  trav.stack[10] = (avl_node const   *)0;
#line 789
  trav.stack[11] = (avl_node const   *)0;
#line 789
  trav.stack[12] = (avl_node const   *)0;
#line 789
  trav.stack[13] = (avl_node const   *)0;
#line 789
  trav.stack[14] = (avl_node const   *)0;
#line 789
  trav.stack[15] = (avl_node const   *)0;
#line 789
  trav.stack[16] = (avl_node const   *)0;
#line 789
  trav.stack[17] = (avl_node const   *)0;
#line 789
  trav.stack[18] = (avl_node const   *)0;
#line 789
  trav.stack[19] = (avl_node const   *)0;
#line 789
  trav.stack[20] = (avl_node const   *)0;
#line 789
  trav.stack[21] = (avl_node const   *)0;
#line 789
  trav.stack[22] = (avl_node const   *)0;
#line 789
  trav.stack[23] = (avl_node const   *)0;
#line 789
  trav.stack[24] = (avl_node const   *)0;
#line 789
  trav.stack[25] = (avl_node const   *)0;
#line 789
  trav.stack[26] = (avl_node const   *)0;
#line 789
  trav.stack[27] = (avl_node const   *)0;
#line 789
  trav.stack[28] = (avl_node const   *)0;
#line 789
  trav.stack[29] = (avl_node const   *)0;
#line 789
  trav.stack[30] = (avl_node const   *)0;
#line 789
  trav.stack[31] = (avl_node const   *)0;
#line 789
  clitrav.init = 0;
#line 789
  clitrav.nstack = 0;
#line 789
  clitrav.p = (avl_node const   *)0;
#line 789
  clitrav.stack[0] = (avl_node const   *)0;
#line 789
  clitrav.stack[1] = (avl_node const   *)0;
#line 789
  clitrav.stack[2] = (avl_node const   *)0;
#line 789
  clitrav.stack[3] = (avl_node const   *)0;
#line 789
  clitrav.stack[4] = (avl_node const   *)0;
#line 789
  clitrav.stack[5] = (avl_node const   *)0;
#line 789
  clitrav.stack[6] = (avl_node const   *)0;
#line 789
  clitrav.stack[7] = (avl_node const   *)0;
#line 789
  clitrav.stack[8] = (avl_node const   *)0;
#line 789
  clitrav.stack[9] = (avl_node const   *)0;
#line 789
  clitrav.stack[10] = (avl_node const   *)0;
#line 789
  clitrav.stack[11] = (avl_node const   *)0;
#line 789
  clitrav.stack[12] = (avl_node const   *)0;
#line 789
  clitrav.stack[13] = (avl_node const   *)0;
#line 789
  clitrav.stack[14] = (avl_node const   *)0;
#line 789
  clitrav.stack[15] = (avl_node const   *)0;
#line 789
  clitrav.stack[16] = (avl_node const   *)0;
#line 789
  clitrav.stack[17] = (avl_node const   *)0;
#line 789
  clitrav.stack[18] = (avl_node const   *)0;
#line 789
  clitrav.stack[19] = (avl_node const   *)0;
#line 789
  clitrav.stack[20] = (avl_node const   *)0;
#line 789
  clitrav.stack[21] = (avl_node const   *)0;
#line 789
  clitrav.stack[22] = (avl_node const   *)0;
#line 789
  clitrav.stack[23] = (avl_node const   *)0;
#line 789
  clitrav.stack[24] = (avl_node const   *)0;
#line 789
  clitrav.stack[25] = (avl_node const   *)0;
#line 789
  clitrav.stack[26] = (avl_node const   *)0;
#line 789
  clitrav.stack[27] = (avl_node const   *)0;
#line 789
  clitrav.stack[28] = (avl_node const   *)0;
#line 789
  clitrav.stack[29] = (avl_node const   *)0;
#line 789
  clitrav.stack[30] = (avl_node const   *)0;
#line 789
  clitrav.stack[31] = (avl_node const   *)0;
#line 793
  if (! sin) {
#line 794
    return ((connection_t *)((void *)0));
  }
  {
  {
#line 796
  hostptr = makeasciihost(& sin->sin_addr, hbuf);
  }
  {
#line 799
  thread_mutex_lock_c(& info.double_mutex, 799, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 800
  thread_mutex_lock_c(& info.source_mutex, 800, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 802
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 802
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 802
    sourcecon = (connection_t *)tmp___1;
    }
#line 802
    if (! sourcecon) {
#line 802
      goto while_break;
    }
    {
    {
#line 804
    zero_trav(& clitrav);
    }
    {
#line 806
    thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 806, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
    {
    {
#line 808
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 808
      tmp___0 = avl_traverse((sourcecon->food.source)->clients, & clitrav);
      }
#line 808
      clicon = (connection_t *)tmp___0;
      }
#line 808
      if (! clicon) {
#line 808
        goto while_break___0;
      }
#line 810
      if (clicon->host) {
#line 810
        if (clicon->sin) {
          {
          {
#line 810
          tmp = ice_strcasecmp((char const   *)clicon->host, (char const   *)hostptr);
          }
          }
#line 810
          if (tmp == 0) {
#line 810
            if ((int )(clicon->sin)->sin_port == (int )sin->sin_port) {
              {
              {
#line 813
              thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 813, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
              }
              {
#line 814
              thread_mutex_unlock_c(& info.double_mutex, 814, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
              }
              {
#line 815
              thread_mutex_unlock_c(& info.source_mutex, 815, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
              }
              }
#line 816
              return (clicon);
            }
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 820
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 820, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 823
  thread_mutex_unlock_c(& info.double_mutex, 823, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 824
  thread_mutex_unlock_c(& info.source_mutex, 824, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 826
  return ((connection_t *)((void *)0));
}
}
#line 829 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_con_with_host_and_udpport(char const   *hostptr , int const   portnr ) 
{ 
  connection_t *clicon ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  avl_traverser clitrav ;
  int tmp ;
  int tmp___0 ;
  uint16_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 833
  trav.init = 0;
#line 833
  trav.nstack = 0;
#line 833
  trav.p = (avl_node const   *)0;
#line 833
  trav.stack[0] = (avl_node const   *)0;
#line 833
  trav.stack[1] = (avl_node const   *)0;
#line 833
  trav.stack[2] = (avl_node const   *)0;
#line 833
  trav.stack[3] = (avl_node const   *)0;
#line 833
  trav.stack[4] = (avl_node const   *)0;
#line 833
  trav.stack[5] = (avl_node const   *)0;
#line 833
  trav.stack[6] = (avl_node const   *)0;
#line 833
  trav.stack[7] = (avl_node const   *)0;
#line 833
  trav.stack[8] = (avl_node const   *)0;
#line 833
  trav.stack[9] = (avl_node const   *)0;
#line 833
  trav.stack[10] = (avl_node const   *)0;
#line 833
  trav.stack[11] = (avl_node const   *)0;
#line 833
  trav.stack[12] = (avl_node const   *)0;
#line 833
  trav.stack[13] = (avl_node const   *)0;
#line 833
  trav.stack[14] = (avl_node const   *)0;
#line 833
  trav.stack[15] = (avl_node const   *)0;
#line 833
  trav.stack[16] = (avl_node const   *)0;
#line 833
  trav.stack[17] = (avl_node const   *)0;
#line 833
  trav.stack[18] = (avl_node const   *)0;
#line 833
  trav.stack[19] = (avl_node const   *)0;
#line 833
  trav.stack[20] = (avl_node const   *)0;
#line 833
  trav.stack[21] = (avl_node const   *)0;
#line 833
  trav.stack[22] = (avl_node const   *)0;
#line 833
  trav.stack[23] = (avl_node const   *)0;
#line 833
  trav.stack[24] = (avl_node const   *)0;
#line 833
  trav.stack[25] = (avl_node const   *)0;
#line 833
  trav.stack[26] = (avl_node const   *)0;
#line 833
  trav.stack[27] = (avl_node const   *)0;
#line 833
  trav.stack[28] = (avl_node const   *)0;
#line 833
  trav.stack[29] = (avl_node const   *)0;
#line 833
  trav.stack[30] = (avl_node const   *)0;
#line 833
  trav.stack[31] = (avl_node const   *)0;
#line 833
  clitrav.init = 0;
#line 833
  clitrav.nstack = 0;
#line 833
  clitrav.p = (avl_node const   *)0;
#line 833
  clitrav.stack[0] = (avl_node const   *)0;
#line 833
  clitrav.stack[1] = (avl_node const   *)0;
#line 833
  clitrav.stack[2] = (avl_node const   *)0;
#line 833
  clitrav.stack[3] = (avl_node const   *)0;
#line 833
  clitrav.stack[4] = (avl_node const   *)0;
#line 833
  clitrav.stack[5] = (avl_node const   *)0;
#line 833
  clitrav.stack[6] = (avl_node const   *)0;
#line 833
  clitrav.stack[7] = (avl_node const   *)0;
#line 833
  clitrav.stack[8] = (avl_node const   *)0;
#line 833
  clitrav.stack[9] = (avl_node const   *)0;
#line 833
  clitrav.stack[10] = (avl_node const   *)0;
#line 833
  clitrav.stack[11] = (avl_node const   *)0;
#line 833
  clitrav.stack[12] = (avl_node const   *)0;
#line 833
  clitrav.stack[13] = (avl_node const   *)0;
#line 833
  clitrav.stack[14] = (avl_node const   *)0;
#line 833
  clitrav.stack[15] = (avl_node const   *)0;
#line 833
  clitrav.stack[16] = (avl_node const   *)0;
#line 833
  clitrav.stack[17] = (avl_node const   *)0;
#line 833
  clitrav.stack[18] = (avl_node const   *)0;
#line 833
  clitrav.stack[19] = (avl_node const   *)0;
#line 833
  clitrav.stack[20] = (avl_node const   *)0;
#line 833
  clitrav.stack[21] = (avl_node const   *)0;
#line 833
  clitrav.stack[22] = (avl_node const   *)0;
#line 833
  clitrav.stack[23] = (avl_node const   *)0;
#line 833
  clitrav.stack[24] = (avl_node const   *)0;
#line 833
  clitrav.stack[25] = (avl_node const   *)0;
#line 833
  clitrav.stack[26] = (avl_node const   *)0;
#line 833
  clitrav.stack[27] = (avl_node const   *)0;
#line 833
  clitrav.stack[28] = (avl_node const   *)0;
#line 833
  clitrav.stack[29] = (avl_node const   *)0;
#line 833
  clitrav.stack[30] = (avl_node const   *)0;
#line 833
  clitrav.stack[31] = (avl_node const   *)0;
  {
#line 836
  thread_mutex_lock_c(& info.double_mutex, 836, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 837
  thread_mutex_lock_c(& info.source_mutex, 837, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 839
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 839
    tmp___3 = avl_traverse(info.sources, & trav);
    }
#line 839
    sourcecon = (connection_t *)tmp___3;
    }
#line 839
    if (! sourcecon) {
#line 839
      goto while_break;
    }
    {
    {
#line 841
    zero_trav(& clitrav);
    }
    {
#line 843
    thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 843, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
    {
    {
#line 845
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 845
      tmp___2 = avl_traverse((sourcecon->food.source)->clients, & clitrav);
      }
#line 845
      clicon = (connection_t *)tmp___2;
      }
#line 845
      if (! clicon) {
#line 845
        goto while_break___0;
      }
#line 847
      if (clicon->host) {
        {
        {
#line 847
        tmp = ice_strcasecmp((char const   *)clicon->host, hostptr);
        }
        }
#line 847
        if (tmp == 0) {
#line 847
          goto _L;
        } else {
#line 847
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 847
      if (clicon->hostname) {
        {
        {
#line 847
        tmp___0 = ice_strcasecmp((char const   *)clicon->hostname, hostptr);
        }
        }
#line 847
        if (tmp___0 == 0) {
          _L: /* CIL Label */ 
          {
          {
#line 847
          tmp___1 = htons((uint16_t )portnr);
          }
          }
#line 847
          if ((int )(clicon->sin)->sin_port == (int )tmp___1) {
            {
            {
#line 851
            thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 851, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
            }
            {
#line 852
            thread_mutex_unlock_c(& info.double_mutex, 852, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
            }
            {
#line 853
            thread_mutex_unlock_c(& info.source_mutex, 853, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
            }
            }
#line 854
            return (clicon);
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 858
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 858, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 861
  thread_mutex_unlock_c(& info.double_mutex, 861, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 862
  thread_mutex_unlock_c(& info.source_mutex, 862, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 864
  return ((connection_t *)((void *)0));
}
}
#line 868 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_client_with_id(int id ) 
{ 
  connection_t con ;
  connection_t *res ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 871
  res = (connection_t *)((void *)0);
#line 872
  trav.init = 0;
#line 872
  trav.nstack = 0;
#line 872
  trav.p = (avl_node const   *)0;
#line 872
  trav.stack[0] = (avl_node const   *)0;
#line 872
  trav.stack[1] = (avl_node const   *)0;
#line 872
  trav.stack[2] = (avl_node const   *)0;
#line 872
  trav.stack[3] = (avl_node const   *)0;
#line 872
  trav.stack[4] = (avl_node const   *)0;
#line 872
  trav.stack[5] = (avl_node const   *)0;
#line 872
  trav.stack[6] = (avl_node const   *)0;
#line 872
  trav.stack[7] = (avl_node const   *)0;
#line 872
  trav.stack[8] = (avl_node const   *)0;
#line 872
  trav.stack[9] = (avl_node const   *)0;
#line 872
  trav.stack[10] = (avl_node const   *)0;
#line 872
  trav.stack[11] = (avl_node const   *)0;
#line 872
  trav.stack[12] = (avl_node const   *)0;
#line 872
  trav.stack[13] = (avl_node const   *)0;
#line 872
  trav.stack[14] = (avl_node const   *)0;
#line 872
  trav.stack[15] = (avl_node const   *)0;
#line 872
  trav.stack[16] = (avl_node const   *)0;
#line 872
  trav.stack[17] = (avl_node const   *)0;
#line 872
  trav.stack[18] = (avl_node const   *)0;
#line 872
  trav.stack[19] = (avl_node const   *)0;
#line 872
  trav.stack[20] = (avl_node const   *)0;
#line 872
  trav.stack[21] = (avl_node const   *)0;
#line 872
  trav.stack[22] = (avl_node const   *)0;
#line 872
  trav.stack[23] = (avl_node const   *)0;
#line 872
  trav.stack[24] = (avl_node const   *)0;
#line 872
  trav.stack[25] = (avl_node const   *)0;
#line 872
  trav.stack[26] = (avl_node const   *)0;
#line 872
  trav.stack[27] = (avl_node const   *)0;
#line 872
  trav.stack[28] = (avl_node const   *)0;
#line 872
  trav.stack[29] = (avl_node const   *)0;
#line 872
  trav.stack[30] = (avl_node const   *)0;
#line 872
  trav.stack[31] = (avl_node const   *)0;
#line 873
  con.id = (unsigned long )id;
#line 874
  con.type = (contype_t )0;
  {
#line 877
  thread_mutex_lock_c(& info.double_mutex, 877, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 879
  thread_mutex_lock_c(& info.source_mutex, 879, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 880
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 880
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 880
    sourcecon = (connection_t *)tmp___0;
    }
#line 880
    if (! sourcecon) {
#line 880
      goto while_break;
    }
    {
    {
#line 882
    thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 882, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    {
#line 883
    tmp = avl_find((sourcecon->food.source)->clients, (void const   *)(& con));
    }
#line 883
    res = (connection_t *)tmp;
    {
#line 884
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 884, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
#line 885
    if (res) {
#line 886
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 889
  thread_mutex_unlock_c(& info.double_mutex, 889, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 890
  thread_mutex_unlock_c(& info.source_mutex, 890, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 891
  return (res);
}
}
#line 894 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_source_with_id(int id ) 
{ 
  connection_t con ;
  connection_t *res ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 898
  con.id = (unsigned long )id;
#line 899
  con.type = (contype_t )1;
  {
#line 901
  thread_mutex_lock_c(& info.source_mutex, 901, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 902
  tmp = avl_find(info.sources, (void const   *)(& con));
  }
#line 902
  res = (connection_t *)tmp;
  {
#line 903
  thread_mutex_unlock_c(& info.source_mutex, 903, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 904
  return (res);
}
}
#line 907 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_source_with_mount(char *mount ) 
{ 
  avl_traverser trav ;
  connection_t *scon ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 910
  trav.init = 0;
#line 910
  trav.nstack = 0;
#line 910
  trav.p = (avl_node const   *)0;
#line 910
  trav.stack[0] = (avl_node const   *)0;
#line 910
  trav.stack[1] = (avl_node const   *)0;
#line 910
  trav.stack[2] = (avl_node const   *)0;
#line 910
  trav.stack[3] = (avl_node const   *)0;
#line 910
  trav.stack[4] = (avl_node const   *)0;
#line 910
  trav.stack[5] = (avl_node const   *)0;
#line 910
  trav.stack[6] = (avl_node const   *)0;
#line 910
  trav.stack[7] = (avl_node const   *)0;
#line 910
  trav.stack[8] = (avl_node const   *)0;
#line 910
  trav.stack[9] = (avl_node const   *)0;
#line 910
  trav.stack[10] = (avl_node const   *)0;
#line 910
  trav.stack[11] = (avl_node const   *)0;
#line 910
  trav.stack[12] = (avl_node const   *)0;
#line 910
  trav.stack[13] = (avl_node const   *)0;
#line 910
  trav.stack[14] = (avl_node const   *)0;
#line 910
  trav.stack[15] = (avl_node const   *)0;
#line 910
  trav.stack[16] = (avl_node const   *)0;
#line 910
  trav.stack[17] = (avl_node const   *)0;
#line 910
  trav.stack[18] = (avl_node const   *)0;
#line 910
  trav.stack[19] = (avl_node const   *)0;
#line 910
  trav.stack[20] = (avl_node const   *)0;
#line 910
  trav.stack[21] = (avl_node const   *)0;
#line 910
  trav.stack[22] = (avl_node const   *)0;
#line 910
  trav.stack[23] = (avl_node const   *)0;
#line 910
  trav.stack[24] = (avl_node const   *)0;
#line 910
  trav.stack[25] = (avl_node const   *)0;
#line 910
  trav.stack[26] = (avl_node const   *)0;
#line 910
  trav.stack[27] = (avl_node const   *)0;
#line 910
  trav.stack[28] = (avl_node const   *)0;
#line 910
  trav.stack[29] = (avl_node const   *)0;
#line 910
  trav.stack[30] = (avl_node const   *)0;
#line 910
  trav.stack[31] = (avl_node const   *)0;
#line 911
  scon = (connection_t *)((void *)0);
  {
#line 913
  thread_mutex_lock_c(& info.source_mutex, 913, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 915
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 915
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 915
    scon = (connection_t *)tmp___0;
    }
#line 915
    if (! scon) {
#line 915
      goto while_break;
    }
    {
    {
#line 916
    tmp = ice_strcmp((char const   *)mount, (char const   *)(scon->food.source)->audiocast.mount);
    }
    }
#line 916
    if (tmp == 0) {
#line 917
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 920
  thread_mutex_unlock_c(& info.source_mutex, 920, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 922
  return (scon);
}
}
#line 927 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *find_id(int id ) 
{ 
  avl_traverser trav ;
  avl_traverser trav2 ;
  connection_t *con ;
  connection_t *con2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 930
  trav.init = 0;
#line 930
  trav.nstack = 0;
#line 930
  trav.p = (avl_node const   *)0;
#line 930
  trav.stack[0] = (avl_node const   *)0;
#line 930
  trav.stack[1] = (avl_node const   *)0;
#line 930
  trav.stack[2] = (avl_node const   *)0;
#line 930
  trav.stack[3] = (avl_node const   *)0;
#line 930
  trav.stack[4] = (avl_node const   *)0;
#line 930
  trav.stack[5] = (avl_node const   *)0;
#line 930
  trav.stack[6] = (avl_node const   *)0;
#line 930
  trav.stack[7] = (avl_node const   *)0;
#line 930
  trav.stack[8] = (avl_node const   *)0;
#line 930
  trav.stack[9] = (avl_node const   *)0;
#line 930
  trav.stack[10] = (avl_node const   *)0;
#line 930
  trav.stack[11] = (avl_node const   *)0;
#line 930
  trav.stack[12] = (avl_node const   *)0;
#line 930
  trav.stack[13] = (avl_node const   *)0;
#line 930
  trav.stack[14] = (avl_node const   *)0;
#line 930
  trav.stack[15] = (avl_node const   *)0;
#line 930
  trav.stack[16] = (avl_node const   *)0;
#line 930
  trav.stack[17] = (avl_node const   *)0;
#line 930
  trav.stack[18] = (avl_node const   *)0;
#line 930
  trav.stack[19] = (avl_node const   *)0;
#line 930
  trav.stack[20] = (avl_node const   *)0;
#line 930
  trav.stack[21] = (avl_node const   *)0;
#line 930
  trav.stack[22] = (avl_node const   *)0;
#line 930
  trav.stack[23] = (avl_node const   *)0;
#line 930
  trav.stack[24] = (avl_node const   *)0;
#line 930
  trav.stack[25] = (avl_node const   *)0;
#line 930
  trav.stack[26] = (avl_node const   *)0;
#line 930
  trav.stack[27] = (avl_node const   *)0;
#line 930
  trav.stack[28] = (avl_node const   *)0;
#line 930
  trav.stack[29] = (avl_node const   *)0;
#line 930
  trav.stack[30] = (avl_node const   *)0;
#line 930
  trav.stack[31] = (avl_node const   *)0;
#line 931
  trav2.init = 0;
#line 931
  trav2.nstack = 0;
#line 931
  trav2.p = (avl_node const   *)0;
#line 931
  trav2.stack[0] = (avl_node const   *)0;
#line 931
  trav2.stack[1] = (avl_node const   *)0;
#line 931
  trav2.stack[2] = (avl_node const   *)0;
#line 931
  trav2.stack[3] = (avl_node const   *)0;
#line 931
  trav2.stack[4] = (avl_node const   *)0;
#line 931
  trav2.stack[5] = (avl_node const   *)0;
#line 931
  trav2.stack[6] = (avl_node const   *)0;
#line 931
  trav2.stack[7] = (avl_node const   *)0;
#line 931
  trav2.stack[8] = (avl_node const   *)0;
#line 931
  trav2.stack[9] = (avl_node const   *)0;
#line 931
  trav2.stack[10] = (avl_node const   *)0;
#line 931
  trav2.stack[11] = (avl_node const   *)0;
#line 931
  trav2.stack[12] = (avl_node const   *)0;
#line 931
  trav2.stack[13] = (avl_node const   *)0;
#line 931
  trav2.stack[14] = (avl_node const   *)0;
#line 931
  trav2.stack[15] = (avl_node const   *)0;
#line 931
  trav2.stack[16] = (avl_node const   *)0;
#line 931
  trav2.stack[17] = (avl_node const   *)0;
#line 931
  trav2.stack[18] = (avl_node const   *)0;
#line 931
  trav2.stack[19] = (avl_node const   *)0;
#line 931
  trav2.stack[20] = (avl_node const   *)0;
#line 931
  trav2.stack[21] = (avl_node const   *)0;
#line 931
  trav2.stack[22] = (avl_node const   *)0;
#line 931
  trav2.stack[23] = (avl_node const   *)0;
#line 931
  trav2.stack[24] = (avl_node const   *)0;
#line 931
  trav2.stack[25] = (avl_node const   *)0;
#line 931
  trav2.stack[26] = (avl_node const   *)0;
#line 931
  trav2.stack[27] = (avl_node const   *)0;
#line 931
  trav2.stack[28] = (avl_node const   *)0;
#line 931
  trav2.stack[29] = (avl_node const   *)0;
#line 931
  trav2.stack[30] = (avl_node const   *)0;
#line 931
  trav2.stack[31] = (avl_node const   *)0;
  {
#line 934
  thread_mutex_lock_c(& info.admin_mutex, 934, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 935
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 935
    tmp = avl_traverse(info.admins, & trav);
    }
#line 935
    con = (connection_t *)tmp;
    }
#line 935
    if (! con) {
#line 935
      goto while_break;
    }
#line 937
    if (con->id == (unsigned long )((unsigned int )id)) {
      {
      {
#line 939
      thread_mutex_unlock_c(& info.admin_mutex, 939, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      }
#line 940
      return (con);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 943
  thread_mutex_unlock_c(& info.admin_mutex, 943, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 945
  zero_trav(& trav);
  }
  {
#line 948
  thread_mutex_lock_c(& info.double_mutex, 948, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 950
  thread_mutex_lock_c(& info.source_mutex, 950, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 952
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 952
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 952
    con = (connection_t *)tmp___1;
    }
#line 952
    if (! con) {
#line 952
      goto while_break___0;
    }
#line 954
    if (con->id == (unsigned long )((unsigned int )id)) {
      {
      {
#line 956
      thread_mutex_unlock_c(& info.double_mutex, 956, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      {
#line 957
      thread_mutex_unlock_c(& info.source_mutex, 957, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      }
#line 958
      return (con);
    }
    {
    {
#line 961
    zero_trav(& trav2);
    }
    {
#line 962
    thread_mutex_lock_c(& (con->food.source)->mutex, 962, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
    {
    {
#line 964
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 964
      tmp___0 = avl_traverse((con->food.source)->clients, & trav2);
      }
#line 964
      con2 = (connection_t *)tmp___0;
      }
#line 964
      if (! con2) {
#line 964
        goto while_break___1;
      }
#line 966
      if (con2->id == (unsigned long )((unsigned int )id)) {
        {
        {
#line 968
        thread_mutex_unlock_c(& (con->food.source)->mutex, 968, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
        }
        {
#line 969
        thread_mutex_unlock_c(& info.source_mutex, 969, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
        }
        {
#line 970
        thread_mutex_unlock_c(& info.double_mutex, 970, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
        }
        }
#line 971
        return (con2);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 974
    thread_mutex_unlock_c(& (con->food.source)->mutex, 974, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 976
  thread_mutex_unlock_c(& info.source_mutex, 976, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 978
  thread_mutex_unlock_c(& info.double_mutex, 978, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 979
  return ((connection_t *)((void *)0));
}
}
#line 982 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_everything(void) 
{ 
  connection_t *con ;
  connection_t *con2 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 987
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 987
    tmp___0 = avl_get_any_node(info.sources);
    }
#line 987
    con = (connection_t *)tmp___0;
    }
#line 987
    if (! con) {
#line 987
      goto while_break;
    }
    {
    {
#line 989
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 989
      tmp = avl_get_any_node((con->food.source)->clients);
      }
#line 989
      con2 = (connection_t *)tmp;
      }
#line 989
      if (! con2) {
#line 989
        goto while_break___0;
      }
      {
      {
#line 990
      kick_connection((void *)con2, (void *)"Masskick by admin");
      }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 991
    kick_connection((void *)con, (void *)"Masskick by admin");
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 994
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 994
    tmp___1 = avl_get_any_node(info.admins);
    }
#line 994
    con = (connection_t *)tmp___1;
    }
#line 994
    if (! con) {
#line 994
      goto while_break___1;
    }
    {
    {
#line 995
    kick_connection((void *)con, (void *)"Masskick by admin");
    }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 997
  return;
}
}
#line 1000 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kick_if_match(char *pattern ) 
{ 
  char buf[8192] ;
  void *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 1004
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Matching %s",
           pattern);
  }
  {
#line 1005
  do_if_match_all(pattern, & kick_connection, (void *)(buf), 1);
  }
  }
#line 1006
  return;
}
}
#line 1008 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void do_if_match_all(char *pattern , void (*func)(void *data , void *param ) , void *buf ,
                     int destructive ) 
{ 
  avl_traverser trav ;
  connection_t *con ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1011
  trav.init = 0;
#line 1011
  trav.nstack = 0;
#line 1011
  trav.p = (avl_node const   *)0;
#line 1011
  trav.stack[0] = (avl_node const   *)0;
#line 1011
  trav.stack[1] = (avl_node const   *)0;
#line 1011
  trav.stack[2] = (avl_node const   *)0;
#line 1011
  trav.stack[3] = (avl_node const   *)0;
#line 1011
  trav.stack[4] = (avl_node const   *)0;
#line 1011
  trav.stack[5] = (avl_node const   *)0;
#line 1011
  trav.stack[6] = (avl_node const   *)0;
#line 1011
  trav.stack[7] = (avl_node const   *)0;
#line 1011
  trav.stack[8] = (avl_node const   *)0;
#line 1011
  trav.stack[9] = (avl_node const   *)0;
#line 1011
  trav.stack[10] = (avl_node const   *)0;
#line 1011
  trav.stack[11] = (avl_node const   *)0;
#line 1011
  trav.stack[12] = (avl_node const   *)0;
#line 1011
  trav.stack[13] = (avl_node const   *)0;
#line 1011
  trav.stack[14] = (avl_node const   *)0;
#line 1011
  trav.stack[15] = (avl_node const   *)0;
#line 1011
  trav.stack[16] = (avl_node const   *)0;
#line 1011
  trav.stack[17] = (avl_node const   *)0;
#line 1011
  trav.stack[18] = (avl_node const   *)0;
#line 1011
  trav.stack[19] = (avl_node const   *)0;
#line 1011
  trav.stack[20] = (avl_node const   *)0;
#line 1011
  trav.stack[21] = (avl_node const   *)0;
#line 1011
  trav.stack[22] = (avl_node const   *)0;
#line 1011
  trav.stack[23] = (avl_node const   *)0;
#line 1011
  trav.stack[24] = (avl_node const   *)0;
#line 1011
  trav.stack[25] = (avl_node const   *)0;
#line 1011
  trav.stack[26] = (avl_node const   *)0;
#line 1011
  trav.stack[27] = (avl_node const   *)0;
#line 1011
  trav.stack[28] = (avl_node const   *)0;
#line 1011
  trav.stack[29] = (avl_node const   *)0;
#line 1011
  trav.stack[30] = (avl_node const   *)0;
#line 1011
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1014
  thread_mutex_lock_c(& info.admin_mutex, 1014, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1015
  do_if_match_tree(info.admins, pattern, func, buf, destructive);
  }
  {
#line 1016
  thread_mutex_unlock_c(& info.admin_mutex, 1016, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1019
  thread_mutex_lock_c(& info.double_mutex, 1019, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1021
  thread_mutex_lock_c(& info.source_mutex, 1021, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 1022
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1022
    tmp = avl_traverse(info.sources, & trav);
    }
#line 1022
    con = (connection_t *)tmp;
    }
#line 1022
    if (! con) {
#line 1022
      goto while_break;
    }
    {
    {
#line 1024
    thread_mutex_lock_c(& (con->food.source)->mutex, 1024, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    {
#line 1025
    do_if_match_tree((con->food.source)->clients, pattern, func, buf, 0);
    }
    {
#line 1026
    thread_mutex_unlock_c(& (con->food.source)->mutex, 1026, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1030
  do_if_match_tree(info.sources, pattern, func, buf, 0);
  }
  {
#line 1032
  thread_mutex_unlock_c(& info.source_mutex, 1032, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1034
  thread_mutex_unlock_c(& info.double_mutex, 1034, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1035
  return;
}
}
#line 1037 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void do_if_match_tree_destructive(avl_tree *tree , char *pattern , void (*func)(void *data ,
                                                                                void *param ) ,
                                  void *buf ) 
{ 
  avl_traverser trav ;
  connection_t *con ;
  void *tmp ;
  icethread_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1040
  trav.init = 0;
#line 1040
  trav.nstack = 0;
#line 1040
  trav.p = (avl_node const   *)0;
#line 1040
  trav.stack[0] = (avl_node const   *)0;
#line 1040
  trav.stack[1] = (avl_node const   *)0;
#line 1040
  trav.stack[2] = (avl_node const   *)0;
#line 1040
  trav.stack[3] = (avl_node const   *)0;
#line 1040
  trav.stack[4] = (avl_node const   *)0;
#line 1040
  trav.stack[5] = (avl_node const   *)0;
#line 1040
  trav.stack[6] = (avl_node const   *)0;
#line 1040
  trav.stack[7] = (avl_node const   *)0;
#line 1040
  trav.stack[8] = (avl_node const   *)0;
#line 1040
  trav.stack[9] = (avl_node const   *)0;
#line 1040
  trav.stack[10] = (avl_node const   *)0;
#line 1040
  trav.stack[11] = (avl_node const   *)0;
#line 1040
  trav.stack[12] = (avl_node const   *)0;
#line 1040
  trav.stack[13] = (avl_node const   *)0;
#line 1040
  trav.stack[14] = (avl_node const   *)0;
#line 1040
  trav.stack[15] = (avl_node const   *)0;
#line 1040
  trav.stack[16] = (avl_node const   *)0;
#line 1040
  trav.stack[17] = (avl_node const   *)0;
#line 1040
  trav.stack[18] = (avl_node const   *)0;
#line 1040
  trav.stack[19] = (avl_node const   *)0;
#line 1040
  trav.stack[20] = (avl_node const   *)0;
#line 1040
  trav.stack[21] = (avl_node const   *)0;
#line 1040
  trav.stack[22] = (avl_node const   *)0;
#line 1040
  trav.stack[23] = (avl_node const   *)0;
#line 1040
  trav.stack[24] = (avl_node const   *)0;
#line 1040
  trav.stack[25] = (avl_node const   *)0;
#line 1040
  trav.stack[26] = (avl_node const   *)0;
#line 1040
  trav.stack[27] = (avl_node const   *)0;
#line 1040
  trav.stack[28] = (avl_node const   *)0;
#line 1040
  trav.stack[29] = (avl_node const   *)0;
#line 1040
  trav.stack[30] = (avl_node const   *)0;
#line 1040
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1043
  xa_debug(2, (char *)"Destructively traversing tree (%p) with %s", tree, pattern);
  }
  {
#line 1045
  zero_trav(& trav);
  }
  }
  {
  {
#line 1047
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1049
    tmp = avl_traverse(tree, & trav);
    }
#line 1049
    con = (connection_t *)tmp;
    }
#line 1050
    if (! con) {
#line 1051
      goto while_break;
    }
    {
    {
#line 1052
    tmp___2 = wild_match((unsigned char const   *)((unsigned char *)pattern), (unsigned char const   *)((unsigned char *)con->host));
    }
    }
#line 1052
    if (tmp___2) {
#line 1052
      goto _L;
    } else
#line 1052
    if (con->hostname) {
      {
      {
#line 1052
      tmp___3 = wild_match((unsigned char const   *)((unsigned char *)pattern), (unsigned char const   *)((unsigned char *)con->hostname));
      }
      }
#line 1052
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 1055
        if ((unsigned int )con->type == 2U) {
          {
          {
#line 1055
          tmp___0 = thread_self();
          }
          {
#line 1055
          tmp___1 = thread_equal((con->food.admin)->thread, tmp___0);
          }
          }
#line 1055
          if (tmp___1) {
            {
            {
#line 1056
            xa_debug(2, (char *)"DEBUG: Skipping myself in destructive tree traversal");
            }
            }
          } else {
            {
            {
#line 1059
            xa_debug(3, (char *)"%s matched, starting over", con->host);
            }
            {
#line 1060
            (*func)((void *)con, buf);
            }
            {
#line 1061
            zero_trav(& trav);
            }
            }
          }
        } else {
          {
          {
#line 1059
          xa_debug(3, (char *)"%s matched, starting over", con->host);
          }
          {
#line 1060
          (*func)((void *)con, buf);
          }
          {
#line 1061
          zero_trav(& trav);
          }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return;
}
}
#line 1067 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void do_if_match_tree(avl_tree *tree , char *pattern , void (*func)(void *data , void *param ) ,
                      void *buf , int destructive ) 
{ 
  avl_traverser trav ;
  connection_t *con ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1070
  trav.init = 0;
#line 1070
  trav.nstack = 0;
#line 1070
  trav.p = (avl_node const   *)0;
#line 1070
  trav.stack[0] = (avl_node const   *)0;
#line 1070
  trav.stack[1] = (avl_node const   *)0;
#line 1070
  trav.stack[2] = (avl_node const   *)0;
#line 1070
  trav.stack[3] = (avl_node const   *)0;
#line 1070
  trav.stack[4] = (avl_node const   *)0;
#line 1070
  trav.stack[5] = (avl_node const   *)0;
#line 1070
  trav.stack[6] = (avl_node const   *)0;
#line 1070
  trav.stack[7] = (avl_node const   *)0;
#line 1070
  trav.stack[8] = (avl_node const   *)0;
#line 1070
  trav.stack[9] = (avl_node const   *)0;
#line 1070
  trav.stack[10] = (avl_node const   *)0;
#line 1070
  trav.stack[11] = (avl_node const   *)0;
#line 1070
  trav.stack[12] = (avl_node const   *)0;
#line 1070
  trav.stack[13] = (avl_node const   *)0;
#line 1070
  trav.stack[14] = (avl_node const   *)0;
#line 1070
  trav.stack[15] = (avl_node const   *)0;
#line 1070
  trav.stack[16] = (avl_node const   *)0;
#line 1070
  trav.stack[17] = (avl_node const   *)0;
#line 1070
  trav.stack[18] = (avl_node const   *)0;
#line 1070
  trav.stack[19] = (avl_node const   *)0;
#line 1070
  trav.stack[20] = (avl_node const   *)0;
#line 1070
  trav.stack[21] = (avl_node const   *)0;
#line 1070
  trav.stack[22] = (avl_node const   *)0;
#line 1070
  trav.stack[23] = (avl_node const   *)0;
#line 1070
  trav.stack[24] = (avl_node const   *)0;
#line 1070
  trav.stack[25] = (avl_node const   *)0;
#line 1070
  trav.stack[26] = (avl_node const   *)0;
#line 1070
  trav.stack[27] = (avl_node const   *)0;
#line 1070
  trav.stack[28] = (avl_node const   *)0;
#line 1070
  trav.stack[29] = (avl_node const   *)0;
#line 1070
  trav.stack[30] = (avl_node const   *)0;
#line 1070
  trav.stack[31] = (avl_node const   *)0;
#line 1073
  if (destructive) {
    {
    {
#line 1074
    do_if_match_tree_destructive(tree, pattern, func, buf);
    }
    }
  } else {
    {
    {
#line 1077
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1077
      tmp___1 = avl_traverse(tree, & trav);
      }
#line 1077
      con = (connection_t *)tmp___1;
      }
#line 1077
      if (! con) {
#line 1077
        goto while_break;
      }
      {
      {
#line 1079
      tmp = wild_match((unsigned char const   *)((unsigned char *)pattern), (unsigned char const   *)((unsigned char *)con->host));
      }
      }
#line 1079
      if (tmp) {
        {
        {
#line 1081
        (*func)((void *)con, buf);
        }
        }
      } else
#line 1079
      if (con->hostname) {
        {
        {
#line 1079
        tmp___0 = wild_match((unsigned char const   *)((unsigned char *)pattern),
                             (unsigned char const   *)((unsigned char *)con->hostname));
        }
        }
#line 1079
        if (tmp___0) {
          {
          {
#line 1081
          (*func)((void *)con, buf);
          }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1084
  return;
}
}
#line 1087 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
unsigned long new_id(void) 
{ 
  unsigned long ret ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 1091
  thread_mutex_lock_c(& info.misc_mutex, 1091, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 1092
  ret = info.id;
#line 1093
  (info.id) ++;
  {
#line 1094
  thread_mutex_unlock_c(& info.misc_mutex, 1094, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1095
  return (ret);
}
}
#line 1098 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void kill_threads(void) 
{ 
  avl_traverser trav ;
  connection_t *con ;
  mythread_t *mt ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1101
  trav.init = 0;
#line 1101
  trav.nstack = 0;
#line 1101
  trav.p = (avl_node const   *)0;
#line 1101
  trav.stack[0] = (avl_node const   *)0;
#line 1101
  trav.stack[1] = (avl_node const   *)0;
#line 1101
  trav.stack[2] = (avl_node const   *)0;
#line 1101
  trav.stack[3] = (avl_node const   *)0;
#line 1101
  trav.stack[4] = (avl_node const   *)0;
#line 1101
  trav.stack[5] = (avl_node const   *)0;
#line 1101
  trav.stack[6] = (avl_node const   *)0;
#line 1101
  trav.stack[7] = (avl_node const   *)0;
#line 1101
  trav.stack[8] = (avl_node const   *)0;
#line 1101
  trav.stack[9] = (avl_node const   *)0;
#line 1101
  trav.stack[10] = (avl_node const   *)0;
#line 1101
  trav.stack[11] = (avl_node const   *)0;
#line 1101
  trav.stack[12] = (avl_node const   *)0;
#line 1101
  trav.stack[13] = (avl_node const   *)0;
#line 1101
  trav.stack[14] = (avl_node const   *)0;
#line 1101
  trav.stack[15] = (avl_node const   *)0;
#line 1101
  trav.stack[16] = (avl_node const   *)0;
#line 1101
  trav.stack[17] = (avl_node const   *)0;
#line 1101
  trav.stack[18] = (avl_node const   *)0;
#line 1101
  trav.stack[19] = (avl_node const   *)0;
#line 1101
  trav.stack[20] = (avl_node const   *)0;
#line 1101
  trav.stack[21] = (avl_node const   *)0;
#line 1101
  trav.stack[22] = (avl_node const   *)0;
#line 1101
  trav.stack[23] = (avl_node const   *)0;
#line 1101
  trav.stack[24] = (avl_node const   *)0;
#line 1101
  trav.stack[25] = (avl_node const   *)0;
#line 1101
  trav.stack[26] = (avl_node const   *)0;
#line 1101
  trav.stack[27] = (avl_node const   *)0;
#line 1101
  trav.stack[28] = (avl_node const   *)0;
#line 1101
  trav.stack[29] = (avl_node const   *)0;
#line 1101
  trav.stack[30] = (avl_node const   *)0;
#line 1101
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1105
  write_log(0, (char *)"Telling threads to die...");
  }
  }
  {
  {
#line 1108
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1108
    tmp = avl_traverse(info.threads, & trav);
    }
#line 1108
    mt = (mythread_t *)tmp;
    }
#line 1108
    if (! mt) {
#line 1108
      goto while_break;
    }
#line 1109
    mt->running = -2;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1112
  write_log(0, (char *)"Closing sockets for admins that keep hanging around...");
  }
  {
#line 1114
  thread_mutex_lock_c(& info.double_mutex, 1114, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1115
  thread_mutex_lock_c(& info.admin_mutex, 1115, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 1117
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1117
    tmp___1 = avl_traverse(info.admins, & trav);
    }
#line 1117
    con = (connection_t *)tmp___1;
    }
#line 1117
    if (! con) {
#line 1117
      goto while_break___0;
    }
#line 1118
    if (con->host) {
      {
      {
#line 1118
      tmp___0 = ice_strcmp((char const   *)con->host, "icecast console");
      }
      }
#line 1118
      if (! (tmp___0 == 0)) {
        {
        {
#line 1119
        sock_close(con->sock);
        }
        }
      }
    } else {
      {
      {
#line 1119
      sock_close(con->sock);
      }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1122
  thread_mutex_unlock_c(& info.admin_mutex, 1122, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1123
  thread_mutex_unlock_c(& info.double_mutex, 1123, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1125
  write_log(0, (char *)"Closing sockets for sources that keep hanging around...");
  }
  {
#line 1127
  zero_trav(& trav);
  }
  {
#line 1130
  thread_mutex_lock_c(& info.source_mutex, 1130, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 1131
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
    {
    {
#line 1131
    tmp___2 = avl_traverse(info.sources, & trav);
    }
#line 1131
    con = (connection_t *)tmp___2;
    }
#line 1131
    if (! con) {
#line 1131
      goto while_break___1;
    }
    {
    {
#line 1132
    sock_close(con->sock);
    }
#line 1133
    (con->food.source)->connected = 0;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1136
  thread_mutex_unlock_c(& info.source_mutex, 1136, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1137
  return;
}
}
#line 1139 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
time_t tree_time(avl_tree *tree ) 
{ 
  connection_t *con ;
  avl_traverser trav ;
  time_t t ;
  time_t tc ;
  void *tmp ;

  {
  {
#line 1143
  trav.init = 0;
#line 1143
  trav.nstack = 0;
#line 1143
  trav.p = (avl_node const   *)0;
#line 1143
  trav.stack[0] = (avl_node const   *)0;
#line 1143
  trav.stack[1] = (avl_node const   *)0;
#line 1143
  trav.stack[2] = (avl_node const   *)0;
#line 1143
  trav.stack[3] = (avl_node const   *)0;
#line 1143
  trav.stack[4] = (avl_node const   *)0;
#line 1143
  trav.stack[5] = (avl_node const   *)0;
#line 1143
  trav.stack[6] = (avl_node const   *)0;
#line 1143
  trav.stack[7] = (avl_node const   *)0;
#line 1143
  trav.stack[8] = (avl_node const   *)0;
#line 1143
  trav.stack[9] = (avl_node const   *)0;
#line 1143
  trav.stack[10] = (avl_node const   *)0;
#line 1143
  trav.stack[11] = (avl_node const   *)0;
#line 1143
  trav.stack[12] = (avl_node const   *)0;
#line 1143
  trav.stack[13] = (avl_node const   *)0;
#line 1143
  trav.stack[14] = (avl_node const   *)0;
#line 1143
  trav.stack[15] = (avl_node const   *)0;
#line 1143
  trav.stack[16] = (avl_node const   *)0;
#line 1143
  trav.stack[17] = (avl_node const   *)0;
#line 1143
  trav.stack[18] = (avl_node const   *)0;
#line 1143
  trav.stack[19] = (avl_node const   *)0;
#line 1143
  trav.stack[20] = (avl_node const   *)0;
#line 1143
  trav.stack[21] = (avl_node const   *)0;
#line 1143
  trav.stack[22] = (avl_node const   *)0;
#line 1143
  trav.stack[23] = (avl_node const   *)0;
#line 1143
  trav.stack[24] = (avl_node const   *)0;
#line 1143
  trav.stack[25] = (avl_node const   *)0;
#line 1143
  trav.stack[26] = (avl_node const   *)0;
#line 1143
  trav.stack[27] = (avl_node const   *)0;
#line 1143
  trav.stack[28] = (avl_node const   *)0;
#line 1143
  trav.stack[29] = (avl_node const   *)0;
#line 1143
  trav.stack[30] = (avl_node const   *)0;
#line 1143
  trav.stack[31] = (avl_node const   *)0;
#line 1144
  tc = (time_t )0;
  {
#line 1146
  t = get_time();
  }
  }
  {
  {
#line 1147
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1147
    tmp = avl_traverse(tree, & trav);
    }
#line 1147
    con = (connection_t *)tmp;
    }
#line 1147
    if (! con) {
#line 1147
      goto while_break;
    }
#line 1148
    tc += t - con->connect_time;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1149
  return (tc / 60L);
}
}
#line 1152 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void write_icecast_header(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 1155
  printf((char const   */* __restrict  */)"Icecast Version %s Initializing...\n",
         "1.3.12");
  }
  {
#line 1156
  printf((char const   */* __restrict  */)"Icecast comes with NO WARRANTY, to the extent permitted by law.\nYou may redistribute copies of Icecast under the terms of the\nGNU General Public License.\nFor more information about these matters, see the file named COPYING.\n");
  }
  {
#line 1157
  printf((char const   */* __restrict  */)"Starting thread engine...\n");
  }
  {
#line 1158
  write_log(0, (char *)"Icecast Version %s Starting..", "1.3.12");
  }
  }
#line 1159
  return;
}
}
#line 1161 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void print_startup_server_info(void) 
{ 
  int i ;
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1166
  if (info.myhostname) {
    {
    {
#line 1166
    tmp = ice_strcmp((char const   *)info.myhostname, "0.0.0.0");
    }
    }
#line 1166
    if (tmp) {
      {
      {
#line 1167
      write_log(0, (char *)"Listening on host %s...", info.myhostname);
      }
      }
    }
  }
#line 1169
  i = 0;
  {
  {
#line 1169
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1169
    if (! (i < 5)) {
#line 1169
      goto while_break;
    }
#line 1170
    if (info.port[i] > 0) {
      {
      {
#line 1171
      write_log(0, (char *)"Listening on port %i...", info.port[i]);
      }
      }
    }
#line 1169
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1174
  if (info.server_name) {
    {
    {
#line 1175
    write_log(0, (char *)"Using \'%s\' as servername...", info.server_name);
    }
    }
  }
  {
  {
#line 1177
  write_log(0, (char *)"Server limits: %d clients, %d clients per source, %d sources, %d admins",
            info.max_clients, info.max_clients_per_source, info.max_sources, info.max_admins);
  }
  }
#line 1180
  if (info.allow_http_admin) {
    {
    {
#line 1181
    write_log(0, (char *)"WWW Admin interface accessible at http://%s:%d/admin", info.server_name,
              info.port[0]);
    }
    }
  } else {
    {
    {
#line 1183
    write_log(0, (char *)"Access to WWW Admin interface disabled");
    }
    }
  }
#line 1184
  return;
}
}
#line 1186 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void sanity_check(void) 
{ 
  int fd ;
  char *file ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 1189
  fd = -1;
  {
#line 1190
  tmp = get_log_file("stats.log");
  }
#line 1190
  file = tmp;
  }
#line 1192
  if (! file) {
    {
    {
#line 1194
    write_log(0, (char *)"ERROR: Could not find a suitable directory for server logfiles");
    }
    {
#line 1195
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: Could not find a suitable directory for server logfiles\n");
    }
    {
#line 1196
    clean_shutdown(& info);
    }
    }
  }
  {
  {
#line 1199
  xa_debug(1, (char *)"DEBUG: Checking write access for file %s", file);
  }
  {
#line 1200
  fd = open_for_writing((char const   *)file);
  }
  }
#line 1200
  if (fd == -1) {
    {
    {
#line 1202
    write_log(0, (char *)"Damn, could not write log file [%s]. Exiting.", file);
    }
    {
#line 1203
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Damn, could not write log file [%s]. Exiting.\n",
            file);
    }
    {
#line 1204
    clean_shutdown(& info);
    }
    }
  } else {
    {
    {
#line 1206
    fd_close(fd);
    }
    {
#line 1207
    remove("stats.log");
    }
    }
  }
  {
  {
#line 1210
  n_free((void *)file, (int const   )1210, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 1210
  file = (char *)((void *)0);
  {
#line 1212
  file = get_template("mountlist.html");
  }
  }
#line 1214
  if (! file) {
    {
    {
#line 1216
    write_log(0, (char *)"ERROR: Could not find a suitable directory for template files, something might be wrong!");
    }
    }
#line 1217
    return;
  }
  {
  {
#line 1220
  xa_debug(1, (char *)"DEBUG: Looking for templates");
  }
  {
#line 1222
  fd = open_for_reading((char const   *)file);
  }
  }
#line 1222
  if (fd == -1) {
    {
    {
#line 1224
    write_log(0, (char *)"WARNING: Could not find template file for mountlist.html, something might be wrong!");
    }
    {
#line 1225
    fd_close(fd);
    }
    }
  }
  {
  {
#line 1228
  n_free((void *)file, (int const   )1228, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 1228
  file = (char *)((void *)0);
  }
#line 1229
  return;
}
}
#line 1231 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
unsigned long transfer_average(unsigned long megabytes , unsigned long connections ) 
{ 


  {
#line 1234
  if (! connections) {
#line 1235
    return (megabytes);
  }
#line 1236
  return ((unsigned long )((double )megabytes / (double )connections));
}
}
#line 1239 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *connect_average(unsigned long minutes , unsigned long connections , char *buf ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1242
  if (! connections) {
    {
    {
#line 1243
    tmp = nice_time_minutes(minutes, buf);
    }
    }
#line 1243
    return (tmp);
  }
  {
  {
#line 1244
  tmp___0 = nice_time_minutes((unsigned long )((double )minutes / (double )connections),
                              buf);
  }
  }
#line 1244
  return (tmp___0);
}
}
#line 1248 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int hostname_local(char *name ) 
{ 
  char *new ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char buf[8192] ;
  char *out ;
  char *res ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 1253
  if (! name) {
    {
    {
#line 1255
    write_log(0, (char *)"ERROR: hostname_local called with NULL name");
    }
    }
#line 1256
    return (0);
  }
#line 1259
  if (! *(name + 0)) {
#line 1260
    return (1);
  }
  {
  {
#line 1262
  tmp = ice_strcasecmp((char const   *)name, "localhost");
  }
  }
#line 1262
  if (tmp == 0) {
#line 1263
    return (1);
  } else {
    {
    {
#line 1262
    tmp___0 = ice_strcasecmp((char const   *)name, "127.0.0.1");
    }
    }
#line 1262
    if (tmp___0 == 0) {
#line 1263
      return (1);
    }
  }
#line 1264
  if (info.server_name) {
    {
    {
#line 1264
    tmp___1 = ice_strcasecmp((char const   *)name, (char const   *)info.server_name);
    }
    }
#line 1264
    if (tmp___1 == 0) {
#line 1265
      return (1);
    }
  }
#line 1266
  if (info.myhostname) {
    {
    {
#line 1266
    tmp___2 = ice_strcasecmp((char const   *)name, (char const   *)info.myhostname);
    }
    }
#line 1266
    if (tmp___2 == 0) {
#line 1267
      return (1);
    }
  }
  {
  {
#line 1270
  thread_mutex_lock_c(& info.hostname_mutex, 1270, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1272
  tmp___3 = avl_find(info.my_hostnames, (void const   *)name);
  }
#line 1272
  new = (char *)tmp___3;
  {
#line 1274
  thread_mutex_unlock_c(& info.hostname_mutex, 1274, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1276
  if (new) {
#line 1277
    return (1);
  }
  {
  {
#line 1282
  tmp___4 = forward((char const   *)name, buf);
  }
#line 1282
  res = tmp___4;
  }
#line 1284
  if (! res) {
#line 1285
    return (0);
  }
  {
  {
#line 1287
  thread_mutex_lock_c(& info.hostname_mutex, 1287, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1289
  tmp___5 = avl_find(info.my_hostnames, (void const   *)res);
  }
#line 1289
  out = (char *)tmp___5;
  {
#line 1291
  thread_mutex_unlock_c(& info.hostname_mutex, 1291, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1293
  if (out) {
    {
    {
#line 1295
    thread_mutex_lock_c(& info.hostname_mutex, 1295, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    {
#line 1296
    tmp___6 = n_strdup((char const   *)name, (int const   )1296, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    {
#line 1296
    avl_insert(info.my_hostnames, (void *)tmp___6);
    }
    {
#line 1297
    thread_mutex_unlock_c(& info.hostname_mutex, 1297, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
#line 1298
    return (1);
  } else
#line 1293
  if (info.myhostname) {
    {
    {
#line 1293
    tmp___7 = ice_strcasecmp((char const   *)res, (char const   *)info.myhostname);
    }
    }
#line 1293
    if (tmp___7 == 0) {
      {
      {
#line 1295
      thread_mutex_lock_c(& info.hostname_mutex, 1295, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      {
#line 1296
      tmp___6 = n_strdup((char const   *)name, (int const   )1296, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      {
#line 1296
      avl_insert(info.my_hostnames, (void *)tmp___6);
      }
      {
#line 1297
      thread_mutex_unlock_c(& info.hostname_mutex, 1297, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      }
#line 1298
      return (1);
    } else {
#line 1293
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 1293
    tmp___8 = ice_strcmp((char const   *)res, "127.0.0.1");
    }
    }
#line 1293
    if (tmp___8 == 0) {
      {
      {
#line 1295
      thread_mutex_lock_c(& info.hostname_mutex, 1295, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      {
#line 1296
      tmp___6 = n_strdup((char const   *)name, (int const   )1296, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      {
#line 1296
      avl_insert(info.my_hostnames, (void *)tmp___6);
      }
      {
#line 1297
      thread_mutex_unlock_c(& info.hostname_mutex, 1297, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
      }
      }
#line 1298
      return (1);
    }
  }
#line 1301
  return (0);
}
}
#line 1304 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void build_request(char *line , request_t *req ) 
{ 
  char path[8192] ;
  unsigned int tmp ;
  char *ptr ;
  char *lineptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char pathbuf[8192] ;
  char *tmp___5 ;
  int tmp___6 ;
  char hostbuf[8192] ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 1307
  path[0] = (char )'\000';
#line 1307
  tmp = 1U;
  {
  {
#line 1307
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1307
    if (tmp >= 8192U) {
#line 1307
      goto while_break;
    }
#line 1307
    path[tmp] = (char)0;
#line 1307
    tmp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  if (! line) {
    {
    {
#line 1312
    write_log(0, (char *)"ERROR: build_request called with NULL pointer");
    }
    }
#line 1313
    return;
  } else
#line 1310
  if (! req) {
    {
    {
#line 1312
    write_log(0, (char *)"ERROR: build_request called with NULL pointer");
    }
    }
#line 1313
    return;
  }
  {
  {
#line 1316
  xa_debug(2, (char *)"DEBUG: Building request out of [%s]", line);
  }
  {
#line 1318
  tmp___11 = ice_strncmp((char const   *)line, "GET", (size_t )3);
  }
  }
#line 1318
  if (tmp___11 == 0) {
    {
    {
#line 1321
    splitc((char *)((void *)0), line, (char const   )' ');
    }
    {
#line 1330
    tmp___0 = splitc(path, line, (char const   )' ');
    }
    }
#line 1330
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 1332
      xa_debug(1, (char *)"Empty GET request [%s]", line);
      }
      {
#line 1333
      strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
              (size_t )8192);
      }
      {
#line 1334
      strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)info.server_name,
              (size_t )8192);
      }
#line 1335
      req->port = info.port[0];
      }
#line 1336
      return;
    } else
#line 1330
    if (! path[0]) {
      {
      {
#line 1332
      xa_debug(1, (char *)"Empty GET request [%s]", line);
      }
      {
#line 1333
      strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
              (size_t )8192);
      }
      {
#line 1334
      strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)info.server_name,
              (size_t )8192);
      }
#line 1335
      req->port = info.port[0];
      }
#line 1336
      return;
    } else
#line 1330
    if ((int )path[0] == 32) {
      {
      {
#line 1332
      xa_debug(1, (char *)"Empty GET request [%s]", line);
      }
      {
#line 1333
      strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
              (size_t )8192);
      }
      {
#line 1334
      strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)info.server_name,
              (size_t )8192);
      }
#line 1335
      req->port = info.port[0];
      }
#line 1336
      return;
    }
    {
    {
#line 1339
    tmp___6 = ice_strncmp((char const   *)(path), "http://", (size_t )7);
    }
    }
#line 1339
    if (tmp___6 == 0) {
      {
#line 1341
      lineptr = & path[7];
      {
#line 1343
      xa_debug(2, (char *)"DEBUG: Building http request from [%s]", lineptr);
      }
      {
#line 1345
      ptr = strchr((char const   *)lineptr, ':');
      }
      }
#line 1347
      if (ptr) {
        {
        {
#line 1349
        splitc(req->host, lineptr, (char const   )':');
        }
        {
#line 1350
        req->port = atoi((char const   *)lineptr);
        }
        {
#line 1352
        lineptr = strchr((char const   *)lineptr, '/');
        }
        }
#line 1354
        if (! lineptr) {
          {
          {
#line 1355
          strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
                  (size_t )8192);
          }
          }
        } else {
          {
          {
#line 1358
          tmp___1 = splitc(req->path, lineptr, (char const   )' ');
          }
          }
#line 1358
          if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
            {
            {
#line 1359
            strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)lineptr,
                    (size_t )8192);
            }
            }
          }
        }
#line 1361
        return;
      } else {
        {
#line 1363
        req->port = info.port[0];
        {
#line 1365
        ptr = strchr((char const   *)lineptr, '/');
        }
        }
#line 1367
        if (! ptr) {
          {
          {
#line 1369
          tmp___2 = splitc(req->host, lineptr, (char const   )' ');
          }
          }
#line 1369
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
            {
            {
#line 1370
            strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)lineptr,
                    (size_t )8192);
            }
            }
          }
          {
          {
#line 1371
          strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
                  (size_t )8192);
          }
          }
#line 1372
          return;
        } else {
          {
          {
#line 1374
          tmp___4 = splitc(req->host, lineptr, (char const   )'/');
          }
          }
#line 1374
          if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
            {
            {
#line 1375
            strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)lineptr,
                    (size_t )8192);
            }
            }
          } else {
            {
            {
#line 1376
            tmp___3 = splitc(req->path, lineptr, (char const   )' ');
            }
            }
#line 1376
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
              {
              {
#line 1377
              strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)lineptr,
                      (size_t )8192);
              }
              }
            }
          }
#line 1379
          if ((int )req->path[0] != 47) {
            {
            {
#line 1380
            strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)"/",
                    (size_t )8192);
            }
            }
          }
#line 1381
          return;
        }
      }
    } else {
      {
      {
#line 1388
      xa_debug(2, (char *)"DEBUG: Building clean request from [%s]", path);
      }
#line 1390
      req->port = info.port[0];
      {
#line 1391
      tmp___5 = splitc(pathbuf, path, (char const   )' ');
      }
      }
#line 1391
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        {
        {
#line 1392
        strncpy((char */* __restrict  */)(pathbuf), (char const   */* __restrict  */)(path),
                (size_t )8192);
        }
        }
      }
#line 1394
      if ((int )pathbuf[0] == 47) {
        {
        {
#line 1395
        strncpy((char */* __restrict  */)(req->path), (char const   */* __restrict  */)(pathbuf),
                (size_t )8192);
        }
        }
      } else {
        {
        {
#line 1397
        snprintf((char */* __restrict  */)(req->path), (size_t )8192, (char const   */* __restrict  */)"/%s",
                 pathbuf);
        }
        }
      }
#line 1399
      if (info.server_name) {
        {
        {
#line 1400
        strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)info.server_name,
                (size_t )8192);
        }
        }
      } else {
        {
        {
#line 1402
        strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)"localhost",
                (size_t )8192);
        }
        }
      }
#line 1403
      return;
    }
  } else {
    {
    {
#line 1406
    tmp___9 = ice_strncmp((char const   *)line, "HOST:", (size_t )5);
    }
    }
#line 1406
    if (tmp___9 == 0) {
#line 1406
      goto _L;
    } else {
      {
      {
#line 1406
      tmp___10 = ice_strncmp((char const   *)line, "Host:", (size_t )5);
      }
      }
#line 1406
      if (tmp___10 == 0) {
        _L: /* CIL Label */ 
#line 1408
        hostbuf[0] = (char )'\000';
#line 1408
        tmp___7 = 1U;
        {
        {
#line 1408
        while (1) {
          while_continue___3: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 1408
          if (tmp___7 >= 8192U) {
#line 1408
            goto while_break___0;
          }
#line 1408
          hostbuf[tmp___7] = (char)0;
#line 1408
          tmp___7 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 1410
        splitc((char *)((void *)0), line, (char const   )':');
        }
        }
        {
        {
#line 1412
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1412
          if (! ((int )*line == 32)) {
#line 1412
            goto while_break___1;
          }
#line 1413
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        {
#line 1415
        ptr = strchr((char const   *)line, ':');
        }
        }
#line 1417
        if (ptr) {
          {
          {
#line 1419
          splitc(hostbuf, line, (char const   )':');
          }
          {
#line 1420
          req->port = atoi((char const   *)line);
          }
          }
        } else {
          {
          {
#line 1422
          tmp___8 = splitc(hostbuf, line, (char const   )' ');
          }
          }
#line 1422
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
            {
            {
#line 1423
            strncpy((char */* __restrict  */)(hostbuf), (char const   */* __restrict  */)line,
                    (size_t )8192);
            }
            }
          }
        }
        {
        {
#line 1426
        strncpy((char */* __restrict  */)(req->host), (char const   */* __restrict  */)(hostbuf),
                (size_t )8192);
        }
        }
#line 1428
        return;
      } else {
        {
        {
#line 1430
        xa_debug(1, (char *)"DEBUG: Build request called with invalid line [%s]",
                 line);
        }
        }
      }
    }
  }
#line 1432
  return;
}
}
#line 1434 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int mount_exists(char *mount ) 
{ 
  avl_traverser trav ;
  connection_t *scon ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1437
  trav.init = 0;
#line 1437
  trav.nstack = 0;
#line 1437
  trav.p = (avl_node const   *)0;
#line 1437
  trav.stack[0] = (avl_node const   *)0;
#line 1437
  trav.stack[1] = (avl_node const   *)0;
#line 1437
  trav.stack[2] = (avl_node const   *)0;
#line 1437
  trav.stack[3] = (avl_node const   *)0;
#line 1437
  trav.stack[4] = (avl_node const   *)0;
#line 1437
  trav.stack[5] = (avl_node const   *)0;
#line 1437
  trav.stack[6] = (avl_node const   *)0;
#line 1437
  trav.stack[7] = (avl_node const   *)0;
#line 1437
  trav.stack[8] = (avl_node const   *)0;
#line 1437
  trav.stack[9] = (avl_node const   *)0;
#line 1437
  trav.stack[10] = (avl_node const   *)0;
#line 1437
  trav.stack[11] = (avl_node const   *)0;
#line 1437
  trav.stack[12] = (avl_node const   *)0;
#line 1437
  trav.stack[13] = (avl_node const   *)0;
#line 1437
  trav.stack[14] = (avl_node const   *)0;
#line 1437
  trav.stack[15] = (avl_node const   *)0;
#line 1437
  trav.stack[16] = (avl_node const   *)0;
#line 1437
  trav.stack[17] = (avl_node const   *)0;
#line 1437
  trav.stack[18] = (avl_node const   *)0;
#line 1437
  trav.stack[19] = (avl_node const   *)0;
#line 1437
  trav.stack[20] = (avl_node const   *)0;
#line 1437
  trav.stack[21] = (avl_node const   *)0;
#line 1437
  trav.stack[22] = (avl_node const   *)0;
#line 1437
  trav.stack[23] = (avl_node const   *)0;
#line 1437
  trav.stack[24] = (avl_node const   *)0;
#line 1437
  trav.stack[25] = (avl_node const   *)0;
#line 1437
  trav.stack[26] = (avl_node const   *)0;
#line 1437
  trav.stack[27] = (avl_node const   *)0;
#line 1437
  trav.stack[28] = (avl_node const   *)0;
#line 1437
  trav.stack[29] = (avl_node const   *)0;
#line 1437
  trav.stack[30] = (avl_node const   *)0;
#line 1437
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1440
  thread_mutex_lock_c(& info.source_mutex, 1440, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 1442
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1442
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 1442
    scon = (connection_t *)tmp___0;
    }
#line 1442
    if (! scon) {
#line 1442
      goto while_break;
    }
    {
    {
#line 1444
    tmp = ice_strcmp((char const   *)mount, (char const   *)(scon->food.source)->audiocast.mount);
    }
    }
#line 1444
    if (tmp == 0) {
#line 1444
      if ((scon->food.source)->connected != 4) {
        {
        {
#line 1446
        thread_mutex_unlock_c(& info.source_mutex, 1446, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
        }
        }
#line 1447
        return (1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1451
  thread_mutex_unlock_c(& info.source_mutex, 1451, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1453
  return (0);
}
}
#line 1456 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void generate_request(char *line , request_t *req ) 
{ 
  char full[8192] ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1461
  if (! line) {
    {
    {
#line 1463
    write_log(0, (char *)"ERROR: generate_request called with NULL pointer");
    }
    }
#line 1464
    return;
  } else
#line 1461
  if (! req) {
    {
    {
#line 1463
    write_log(0, (char *)"ERROR: generate_request called with NULL pointer");
    }
    }
#line 1464
    return;
  }
  {
  {
#line 1467
  snprintf((char */* __restrict  */)(full), (size_t )8192, (char const   */* __restrict  */)"GET %s HTTP/1.0",
           line);
  }
  {
#line 1469
  build_request(full, req);
  }
  }
#line 1471
  if (req->path[0]) {
    {
    {
#line 1472
    xa_debug(2, (char *)"DEBUG: Generated request [%s:%d%s]", req->host, req->port,
             req->path);
    }
    }
  }
#line 1474
  return;
}
}
#line 1476 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void generate_http_request(char *line , request_t *req ) 
{ 
  char full[8242] ;
  unsigned int tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1479
  full[0] = (char )'\000';
#line 1479
  tmp = 1U;
  {
  {
#line 1479
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1479
    if (tmp >= 8242U) {
#line 1479
      goto while_break;
    }
#line 1479
    full[tmp] = (char)0;
#line 1479
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1481
  if (! line) {
    {
    {
#line 1483
    write_log(0, (char *)"ERROR: generate_request called with NULL pointer");
    }
    }
#line 1484
    return;
  } else
#line 1481
  if (! req) {
    {
    {
#line 1483
    write_log(0, (char *)"ERROR: generate_request called with NULL pointer");
    }
    }
#line 1484
    return;
  }
  {
  {
#line 1487
  tmp___0 = ice_strncmp((char const   *)line, "http://", (size_t )7);
  }
  }
#line 1487
  if (tmp___0 == 0) {
    {
    {
#line 1489
    snprintf((char */* __restrict  */)(full), (size_t )8192, (char const   */* __restrict  */)"GET %s HTTP/1.0",
             line);
    }
    }
  } else {
    {
    {
#line 1491
    snprintf((char */* __restrict  */)(full), (size_t )8192, (char const   */* __restrict  */)"GET http://%s HTTP/1.0",
             line);
    }
    }
  }
  {
  {
#line 1494
  build_request(full, req);
  }
  {
#line 1496
  xa_debug(2, (char *)"DEBUG: Generated http request [%s:%d%s]", req->host, req->port,
           req->path);
  }
  }
#line 1497
  return;
}
}
#line 1499 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void zero_request(request_t *req ) 
{ 


  {
#line 1502
  req->host[0] = (char )'\000';
#line 1503
  req->path[0] = (char )'\000';
#line 1504
  req->port = -1;
#line 1505
  return;
}
}
#line 1512 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
static char apan[30]  ;
#line 1507 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *next_mount_point(void) 
{ 
  avl_traverser trav ;
  connection_t *sourcecon ;
  int count ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1510
  trav.init = 0;
#line 1510
  trav.nstack = 0;
#line 1510
  trav.p = (avl_node const   *)0;
#line 1510
  trav.stack[0] = (avl_node const   *)0;
#line 1510
  trav.stack[1] = (avl_node const   *)0;
#line 1510
  trav.stack[2] = (avl_node const   *)0;
#line 1510
  trav.stack[3] = (avl_node const   *)0;
#line 1510
  trav.stack[4] = (avl_node const   *)0;
#line 1510
  trav.stack[5] = (avl_node const   *)0;
#line 1510
  trav.stack[6] = (avl_node const   *)0;
#line 1510
  trav.stack[7] = (avl_node const   *)0;
#line 1510
  trav.stack[8] = (avl_node const   *)0;
#line 1510
  trav.stack[9] = (avl_node const   *)0;
#line 1510
  trav.stack[10] = (avl_node const   *)0;
#line 1510
  trav.stack[11] = (avl_node const   *)0;
#line 1510
  trav.stack[12] = (avl_node const   *)0;
#line 1510
  trav.stack[13] = (avl_node const   *)0;
#line 1510
  trav.stack[14] = (avl_node const   *)0;
#line 1510
  trav.stack[15] = (avl_node const   *)0;
#line 1510
  trav.stack[16] = (avl_node const   *)0;
#line 1510
  trav.stack[17] = (avl_node const   *)0;
#line 1510
  trav.stack[18] = (avl_node const   *)0;
#line 1510
  trav.stack[19] = (avl_node const   *)0;
#line 1510
  trav.stack[20] = (avl_node const   *)0;
#line 1510
  trav.stack[21] = (avl_node const   *)0;
#line 1510
  trav.stack[22] = (avl_node const   *)0;
#line 1510
  trav.stack[23] = (avl_node const   *)0;
#line 1510
  trav.stack[24] = (avl_node const   *)0;
#line 1510
  trav.stack[25] = (avl_node const   *)0;
#line 1510
  trav.stack[26] = (avl_node const   *)0;
#line 1510
  trav.stack[27] = (avl_node const   *)0;
#line 1510
  trav.stack[28] = (avl_node const   *)0;
#line 1510
  trav.stack[29] = (avl_node const   *)0;
#line 1510
  trav.stack[30] = (avl_node const   *)0;
#line 1510
  trav.stack[31] = (avl_node const   *)0;
#line 1513
  count = 0;
  {
  {
#line 1515
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1515
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 1515
    sourcecon = (connection_t *)tmp___0;
    }
#line 1515
    if (! sourcecon) {
#line 1515
      goto while_break;
    }
    {
    {
#line 1517
    tmp = ice_strncmp((char const   *)(sourcecon->food.source)->audiocast.mount, "/icy_",
                      (size_t )5);
    }
    }
#line 1517
    if (tmp == 0) {
#line 1517
      if ((sourcecon->food.source)->connected != 4) {
#line 1518
        count ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1521
  snprintf((char */* __restrict  */)(apan), (size_t )sizeof(apan), (char const   */* __restrict  */)"icy_%d",
           count);
  }
  }
#line 1523
  return (& apan[0]);
}
}
#line 1526 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void init_thread_tree(int line , char *file ) 
{ 
  mythread_t *mt ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1530
  if (! file) {
    {
    {
#line 1531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: init_thread_tree() called with file == NULL\n");
    }
    {
#line 1532
    exit(1);
    }
    }
  }
  {
#line 1535
  info.threads = (avl_tree *)((void *)0);
#line 1536
  info.threadid = 0L;
  {
#line 1543
  tmp = n_malloc((unsigned int const   )sizeof(mythread_t ), (int const   )1543, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 1543
  mt = (mythread_t *)tmp;
  {
#line 1546
  info.threads = avl_create(& compare_threads, (void *)(& info));
  }
#line 1549
  mt->id = 0L;
#line 1550
  mt->line = line;
  {
#line 1551
  mt->file = strdup((char const   *)file);
  }
  {
#line 1552
  mt->thread = thread_self();
  }
  {
#line 1553
  mt->created = get_time();
  }
  {
#line 1554
  mt->name = strdup("Main Thread");
  }
  {
#line 1556
  tmp___0 = avl_insert(info.threads, (void *)mt);
  }
  }
#line 1556
  if (tmp___0) {
    {
    {
#line 1557
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Could not insert main thread into the thread tree, DAMN!\n");
    }
    {
#line 1558
    exit(1);
    }
    }
  }
  {
  {
#line 1561
  thread_create_mutex_c(& info.thread_mutex, 1561, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1565
  thread_init();
  }
  {
#line 1567
  thread_catch_signals();
  }
  {
#line 1569
  thread_setup_default_attributes();
  }
  }
#line 1570
  return;
}
}
#line 1572 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void pending_connection(connection_t *con ) 
{ 
  relay_t *rel ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 1575
  write_log(0, (char *)"Lost connection to source on mount %s, waiting %d seconds for timeout",
            (con->food.source)->audiocast.mount, info.client_timeout);
  }
#line 1576
  (con->food.source)->connected = 4;
  }
#line 1579
  if ((int )(con->food.source)->type == 1) {
    {
    {
#line 1581
    thread_mutex_lock_c(& info.relay_mutex, 1581, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    {
#line 1582
    rel = relay_find_with_con(con);
    }
    }
#line 1583
    if (rel) {
#line 1584
      rel->con = (connection_t *)((void *)0);
#line 1585
      rel->reconnect_now = 1;
    }
    {
    {
#line 1587
    thread_mutex_unlock_c(& info.relay_mutex, 1587, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
  }
#line 1589
  return;
}
}
#line 1591 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int pending_source_signoff(connection_t *con ) 
{ 
  time_t start ;
  long tmp ;
  long tmp___0 ;

  {
  {
  {
#line 1594
  tmp = get_time();
  }
#line 1594
  start = tmp;
  }
  {
  {
#line 1595
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1595
    if (running == 1) {
#line 1595
      if ((con->food.source)->connected == 4) {
        {
        {
#line 1595
        tmp___0 = get_time();
        }
        }
#line 1595
        if (! (tmp___0 - start < (long )info.client_timeout)) {
#line 1595
          goto while_break;
        }
      } else {
#line 1595
        goto while_break;
      }
    } else {
#line 1595
      goto while_break;
    }
    {
    {
#line 1596
    my_sleep(90000);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1597
  if ((con->food.source)->connected == 4) {
#line 1598
    return (1);
  }
#line 1599
  return (0);
}
}
#line 1602 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
connection_t *get_pending_mount(char *mount ) 
{ 
  avl_traverser trav ;
  connection_t *sourcecon ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1605
  trav.init = 0;
#line 1605
  trav.nstack = 0;
#line 1605
  trav.p = (avl_node const   *)0;
#line 1605
  trav.stack[0] = (avl_node const   *)0;
#line 1605
  trav.stack[1] = (avl_node const   *)0;
#line 1605
  trav.stack[2] = (avl_node const   *)0;
#line 1605
  trav.stack[3] = (avl_node const   *)0;
#line 1605
  trav.stack[4] = (avl_node const   *)0;
#line 1605
  trav.stack[5] = (avl_node const   *)0;
#line 1605
  trav.stack[6] = (avl_node const   *)0;
#line 1605
  trav.stack[7] = (avl_node const   *)0;
#line 1605
  trav.stack[8] = (avl_node const   *)0;
#line 1605
  trav.stack[9] = (avl_node const   *)0;
#line 1605
  trav.stack[10] = (avl_node const   *)0;
#line 1605
  trav.stack[11] = (avl_node const   *)0;
#line 1605
  trav.stack[12] = (avl_node const   *)0;
#line 1605
  trav.stack[13] = (avl_node const   *)0;
#line 1605
  trav.stack[14] = (avl_node const   *)0;
#line 1605
  trav.stack[15] = (avl_node const   *)0;
#line 1605
  trav.stack[16] = (avl_node const   *)0;
#line 1605
  trav.stack[17] = (avl_node const   *)0;
#line 1605
  trav.stack[18] = (avl_node const   *)0;
#line 1605
  trav.stack[19] = (avl_node const   *)0;
#line 1605
  trav.stack[20] = (avl_node const   *)0;
#line 1605
  trav.stack[21] = (avl_node const   *)0;
#line 1605
  trav.stack[22] = (avl_node const   *)0;
#line 1605
  trav.stack[23] = (avl_node const   *)0;
#line 1605
  trav.stack[24] = (avl_node const   *)0;
#line 1605
  trav.stack[25] = (avl_node const   *)0;
#line 1605
  trav.stack[26] = (avl_node const   *)0;
#line 1605
  trav.stack[27] = (avl_node const   *)0;
#line 1605
  trav.stack[28] = (avl_node const   *)0;
#line 1605
  trav.stack[29] = (avl_node const   *)0;
#line 1605
  trav.stack[30] = (avl_node const   *)0;
#line 1605
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1608
  thread_mutex_lock_c(& info.source_mutex, 1608, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
  {
  {
#line 1610
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1610
    tmp___0 = avl_traverse(info.sources, & trav);
    }
#line 1610
    sourcecon = (connection_t *)tmp___0;
    }
#line 1610
    if (! sourcecon) {
#line 1610
      goto while_break;
    }
    {
    {
#line 1612
    tmp = ice_strcmp((char const   *)(sourcecon->food.source)->audiocast.mount, (char const   *)mount);
    }
    }
#line 1612
    if (tmp == 0) {
#line 1612
      if ((sourcecon->food.source)->connected == 4) {
        {
        {
#line 1614
        thread_mutex_unlock_c(& info.source_mutex, 1614, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
        }
        }
#line 1615
        return (sourcecon);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1619
  thread_mutex_unlock_c(& info.source_mutex, 1619, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1620
  return ((connection_t *)((void *)0));
}
}
#line 1623 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void clear_source_stats(void *data , void *param ) 
{ 
  connection_t *con ;
  source_t *source ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1625
  con = (connection_t *)data;
#line 1627
  source = con->food.source;
  {
#line 1628
  thread_mutex_lock_c(& source->mutex, 1628, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  {
#line 1629
  zero_stats(& source->stats);
  }
  {
#line 1630
  avl_walk(source->clients, & clear_client_stats, param);
  }
  {
#line 1631
  thread_mutex_unlock_c(& source->mutex, 1631, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
  }
#line 1632
  return;
}
}
#line 1634 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void clear_client_stats(void *data , void *param ) 
{ 
  connection_t *con ;
  client_t *client ;

  {
#line 1636
  con = (connection_t *)data;
#line 1638
  client = con->food.client;
#line 1639
  client->write_bytes = 0UL;
#line 1640
  return;
}
}
#line 1642 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void clear_admin_stats(void *data , void *param ) 
{ 
  connection_t *con ;
  admin_t *admin ;

  {
#line 1644
  con = (connection_t *)data;
#line 1646
  admin = con->food.admin;
#line 1647
  admin->commands = 0;
#line 1648
  return;
}
}
#line 1650 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int hosteq(connection_t *con , connection_t *con2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1653
  if (con->host) {
#line 1653
    if (con2->host) {
      {
      {
#line 1655
      tmp = ice_strcasecmp((char const   *)con->host, (char const   *)con2->host);
      }
      }
#line 1655
      if (tmp == 0) {
#line 1656
        return (1);
      }
    }
  }
#line 1659
  if (con->hostname) {
#line 1659
    if (con2->hostname) {
      {
      {
#line 1661
      tmp___0 = ice_strcasecmp((char const   *)con->hostname, (char const   *)con2->hostname);
      }
      }
#line 1661
      if (tmp___0 == 0) {
#line 1662
        return (1);
      }
    }
  }
#line 1665
  return (0);
}
}
#line 1668 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int hostmatch(connection_t const   *con , char const   *pattern ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1671
  if (! pattern) {
#line 1672
    return (0);
  } else
#line 1671
  if (! con) {
#line 1672
    return (0);
  }
#line 1673
  if (con->host) {
    {
    {
#line 1673
    tmp = wild_match((unsigned char const   *)((unsigned char *)pattern), (unsigned char const   *)((unsigned char *)con->host));
    }
    }
#line 1673
    if (tmp) {
#line 1674
      return (1);
    }
  }
#line 1675
  if (con->hostname) {
    {
    {
#line 1675
    tmp___0 = wild_match((unsigned char const   *)((unsigned char *)pattern), (unsigned char const   *)((unsigned char *)con->hostname));
    }
    }
#line 1675
    if (tmp___0) {
#line 1676
      return (1);
    }
  }
#line 1677
  return (0);
}
}
#line 1680 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int open_for_writing(char const   *filename ) 
{ 
  int fd ;
  char *__cil_tmp3 ;

  {
#line 1685
  if (! filename) {
#line 1686
    return (-1);
  }
  {
  {
#line 1688
  fd = open(filename, 577, 420);
  }
  }
#line 1689
  if (fd == -1) {
    {
    {
#line 1690
    xa_debug(1, (char *)"ERROR: Cannot open file for writing[%s]", filename);
    }
    }
  }
#line 1691
  return (fd);
}
}
#line 1694 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int open_for_reading(char const   *filename ) 
{ 
  int fd ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 1698
  if (! filename) {
    {
    {
#line 1699
    xa_debug(1, (char *)"ERROR: Cannot open file for reading no file specified");
    }
    }
#line 1700
    return (-1);
  }
  {
  {
#line 1703
  fd = open(filename, 0);
  }
  }
#line 1704
  if (fd == -1) {
    {
    {
#line 1705
    xa_debug(1, (char *)"ERROR: Cannot open file for reading [%s]", filename);
    }
    }
  }
#line 1707
  return (fd);
}
}
#line 1710 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int open_for_append(char const   *filename ) 
{ 
  int fd ;
  char *__cil_tmp3 ;

  {
#line 1715
  if (! filename) {
#line 1716
    return (-1);
  }
  {
  {
#line 1718
  fd = open(filename, 1089, 420);
  }
  }
#line 1719
  if (fd == -1) {
    {
    {
#line 1720
    xa_debug(1, (char *)"ERROR: Cannot open file for append [%s]", filename);
    }
    }
  }
#line 1721
  return (fd);
}
}
#line 1724 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *get_template(char const   *filename ) 
{ 
  char *tmp ;

  {
  {
  {
#line 1727
  tmp = get_icecast_file(filename, (filetype_t )3, 4);
  }
  }
#line 1727
  return (tmp);
}
}
#line 1730 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *get_log_file(char const   *filename ) 
{ 
  char logdir[8192] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1735
  if (! filename) {
    {
    {
#line 1736
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: get_log_file() called with NULLs\n");
    }
    }
#line 1737
    return ((char *)((void *)0));
  } else
#line 1735
  if (! info.logdir) {
    {
    {
#line 1736
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: get_log_file() called with NULLs\n");
    }
    }
#line 1737
    return ((char *)((void *)0));
  }
  {
  {
#line 1740
  snprintf((char */* __restrict  */)(logdir), (size_t )8192, (char const   */* __restrict  */)"%s%c",
           info.logdir, '/');
  }
  {
#line 1741
  xa_debug(1, (char *)"DEBUG: Checking directory %s", logdir);
  }
  {
#line 1743
  tmp___0 = access((char const   *)info.logdir, 4);
  }
  }
#line 1743
  if (tmp___0 == 0) {
    {
    {
#line 1744
    tmp = ice_cat((char const   *)(logdir), filename);
    }
    }
#line 1744
    return (tmp);
  }
  {
  {
#line 1747
  snprintf((char */* __restrict  */)(logdir), (size_t )8192, (char const   */* __restrict  */)"log%c",
           '/');
  }
  {
#line 1748
  xa_debug(1, (char *)"DEBUG: Checking directory %s", logdir);
  }
  {
#line 1749
  tmp___2 = access((char const   *)(logdir), 4);
  }
  }
#line 1749
  if (tmp___2 == 0) {
    {
    {
#line 1750
    tmp___1 = ice_cat((char const   *)(logdir), filename);
    }
    }
#line 1750
    return (tmp___1);
  }
  {
  {
#line 1753
  snprintf((char */* __restrict  */)(logdir), (size_t )8192, (char const   */* __restrict  */)"%s%c",
           ".", '/');
  }
  {
#line 1754
  tmp___4 = access((char const   *)(logdir), 4);
  }
  }
#line 1754
  if (tmp___4 == 0) {
    {
    {
#line 1755
    tmp___3 = ice_cat((char const   *)(logdir), filename);
    }
    }
#line 1755
    return (tmp___3);
  }
#line 1758
  return ((char *)((void *)0));
}
}
#line 1761 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *get_icecast_file(char const   *filename , filetype_t type , int flags ) 
{ 
  char path_and_file[8192] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 1766
  if (! filename) {
    {
    {
#line 1767
    xa_debug(1, (char *)"ERROR: get_icecast_file(): called with NULL pointer");
    }
    }
#line 1768
    return ((char *)((void *)0));
  } else
#line 1766
  if (! info.etcdir) {
    {
    {
#line 1767
    xa_debug(1, (char *)"ERROR: get_icecast_file(): called with NULL pointer");
    }
    }
#line 1768
    return ((char *)((void *)0));
  } else
#line 1766
  if (! info.logdir) {
    {
    {
#line 1767
    xa_debug(1, (char *)"ERROR: get_icecast_file(): called with NULL pointer");
    }
    }
#line 1768
    return ((char *)((void *)0));
  } else
#line 1766
  if (! info.templatedir) {
    {
    {
#line 1767
    xa_debug(1, (char *)"ERROR: get_icecast_file(): called with NULL pointer");
    }
    }
#line 1768
    return ((char *)((void *)0));
  } else
#line 1766
  if (! info.staticdir) {
    {
    {
#line 1767
    xa_debug(1, (char *)"ERROR: get_icecast_file(): called with NULL pointer");
    }
    }
#line 1768
    return ((char *)((void *)0));
  }
#line 1771
  path_and_file[0] = (char )'\000';
  {
#line 1774
  if ((unsigned int )type == 1U) {
#line 1774
    goto case_1;
  }
#line 1777
  if ((unsigned int )type == 2U) {
#line 1777
    goto case_2;
  }
#line 1780
  if ((unsigned int )type == 3U) {
#line 1780
    goto case_3;
  }
#line 1783
  if ((unsigned int )type == 4U) {
#line 1783
    goto case_4;
  }
#line 1786
  goto switch_default;
  case_1: /* CIL Label */ 
  {
  {
#line 1775
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s%c%s",
           info.etcdir, '/', filename);
  }
  }
#line 1776
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 1778
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s%c%s",
           info.logdir, '/', filename);
  }
  }
#line 1779
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 1781
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s%c%s",
           info.templatedir, '/', filename);
  }
  }
#line 1782
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 1784
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s%c%s",
           info.staticdir, '/', filename);
  }
  }
#line 1785
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 1787
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s",
           filename);
  }
  }
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 1790
  xa_debug(3, (char *)"DEBUG: get_icecast_file(): Looking for %s", path_and_file);
  }
  {
#line 1792
  tmp___0 = access((char const   *)(path_and_file), flags);
  }
  }
#line 1792
  if (tmp___0 == 0) {
    {
    {
#line 1793
    tmp = n_strdup((char const   *)(path_and_file), (int const   )1793, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
#line 1793
    return (tmp);
  }
  {
#line 1796
  if ((unsigned int )type == 1U) {
#line 1796
    goto case_1___0;
  }
#line 1799
  if ((unsigned int )type == 2U) {
#line 1799
    goto case_2___0;
  }
#line 1802
  if ((unsigned int )type == 3U) {
#line 1802
    goto case_3___0;
  }
#line 1805
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
  {
#line 1797
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)".%c%s%c%s",
           '/', "conf", '/', filename);
  }
  }
#line 1798
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
  {
#line 1800
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)".%c%s%c%s",
           '/', "logs", '/', filename);
  }
  }
#line 1801
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
  {
#line 1803
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)".%c%s%c%s",
           '/', "templates", '/', filename);
  }
  }
#line 1804
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
  {
#line 1806
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s",
           filename);
  }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1809
  xa_debug(3, (char *)"DEBUG: get_icecast_file(): Looking for %s", path_and_file);
  }
  {
#line 1811
  tmp___2 = access((char const   *)(path_and_file), flags);
  }
  }
#line 1811
  if (tmp___2 == 0) {
    {
    {
#line 1812
    tmp___1 = n_strdup((char const   *)(path_and_file), (int const   )1812, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
#line 1812
    return (tmp___1);
  }
  {
#line 1815
  if ((unsigned int )type == 1U) {
#line 1815
    goto case_1___1;
  }
#line 1818
  if ((unsigned int )type == 2U) {
#line 1818
    goto case_2___1;
  }
#line 1821
  if ((unsigned int )type == 3U) {
#line 1821
    goto case_3___1;
  }
#line 1824
  goto switch_default___1;
  case_1___1: /* CIL Label */ 
  {
  {
#line 1816
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"..%c%s%c%s",
           '/', "conf", '/', filename);
  }
  }
#line 1817
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
  {
  {
#line 1819
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"..%c%s%c%s",
           '/', "logs", '/', filename);
  }
  }
#line 1820
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
  {
  {
#line 1822
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"..%c%s%c%s",
           '/', "templates", '/', filename);
  }
  }
#line 1823
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
  {
  {
#line 1825
  snprintf((char */* __restrict  */)(path_and_file), (size_t )8192, (char const   */* __restrict  */)"%s",
           filename);
  }
  }
  switch_break___1: /* CIL Label */ ;
  }
  {
  {
#line 1828
  xa_debug(3, (char *)"DEBUG: get_icecast_file(): Looking for %s", path_and_file);
  }
  {
#line 1830
  tmp___4 = access((char const   *)(path_and_file), flags);
  }
  }
#line 1830
  if (tmp___4 == 0) {
    {
    {
#line 1831
    tmp___3 = n_strdup((char const   *)(path_and_file), (int const   )1831, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
    }
    }
#line 1831
    return (tmp___3);
  }
  {
  {
#line 1833
  xa_debug(2, (char *)"DEBUG: get_icecast_file(): Didn\'t find %s", filename);
  }
  }
#line 1835
  return ((char *)((void *)0));
}
}
#line 1839 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void stat_add_read(statistics_t *stat___0 , int len ) 
{ 


  {
  {
  {
#line 1842
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1842
    if (! (stat___0->read_bytes + (unsigned long )len >= 1048576UL)) {
#line 1842
      goto while_break;
    }
#line 1844
    (stat___0->read_megs) ++;
#line 1845
    len -= 1048576;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1848
  stat___0->read_bytes += (unsigned long )len;
#line 1849
  return;
}
}
#line 1851 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void stat_add_write(statistics_t *stat___0 , int len ) 
{ 


  {
  {
  {
#line 1854
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1854
    if (! (stat___0->write_bytes + (unsigned long )len >= 1048576UL)) {
#line 1854
      goto while_break;
    }
#line 1856
    (stat___0->write_megs) ++;
#line 1857
    len -= 1048576;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1860
  stat___0->write_bytes += (unsigned long )len;
#line 1861
  return;
}
}
#line 1863 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
char *type_of_str(contype_t type , char *buf ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1866
  if ((unsigned int )type == 2U) {
    {
    {
#line 1867
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"admin");
    }
    }
  } else
#line 1868
  if ((unsigned int )type == 0U) {
    {
    {
#line 1869
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"client");
    }
    }
  } else
#line 1870
  if ((unsigned int )type == 1U) {
    {
    {
#line 1871
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"source");
    }
    }
  } else {
    {
    {
#line 1873
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"unknown");
    }
    }
  }
#line 1875
  return (buf);
}
}
#line 1878 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void zero_song_info(songinfo_t *si ) 
{ 


  {
#line 1881
  si->streamurl = (char *)((void *)0);
#line 1882
  si->streammsg = (char *)((void *)0);
#line 1883
  si->streamtitle = (char *)((void *)0);
#line 1884
  si->streamlength = -1L;
#line 1885
  si->udpseqnr = 0UL;
#line 1886
  return;
}
}
#line 1888 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void my_sleep(int microseconds ) 
{ 
  struct timespec req ;
  struct timespec rem ;
  long nanoseconds ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1898
  req.tv_sec = (__time_t )0;
#line 1899
  req.tv_nsec = 0L;
  {
  {
#line 1901
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1901
    if (! (microseconds > 999999)) {
#line 1901
      goto while_break;
    }
#line 1902
    (req.tv_sec) ++;
#line 1903
    microseconds -= 1000000;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  nanoseconds = (long )(microseconds * 1000);
  {
  {
#line 1908
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1908
    if (! (nanoseconds > 999999999L)) {
#line 1908
      goto while_break___0;
    }
#line 1910
    (req.tv_sec) ++;
#line 1911
    nanoseconds -= 1000000000L;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1914
  req.tv_nsec = nanoseconds;
  {
#line 1918
  tmp = nanosleep((struct timespec  const  *)(& req), & rem);
  }
  }
  {
#line 1919
  if (tmp == 4) {
#line 1919
    goto case_4;
  }
#line 1922
  if (tmp == 22) {
#line 1922
    goto case_22;
  }
#line 1918
  goto switch_break;
  case_4: /* CIL Label */ 
  {
  {
#line 1920
  xa_debug(4, (char *)"WARNING: nanosleep() was interupted by nonblocked signal");
  }
  }
#line 1921
  goto switch_break;
  case_22: /* CIL Label */ 
  {
  {
#line 1923
  xa_debug(1, (char *)"WARNING: nanosleep() was passed invalid or negative sleep value %ld+%ld",
           req.tv_sec, req.tv_nsec);
  }
  }
#line 1925
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1937
  return;
}
}
#line 1939 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void show_runtime_configuration(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 1942
  xa_debug(1, (char *)"Runtime Configuration:");
  }
  {
#line 1944
  xa_debug(1, (char *)"Using nanosleep() as sleep method");
  }
  {
#line 1956
  xa_debug(1, (char *)"Using posix signal interface to block all signals in threads that don\'t want them");
  }
  {
#line 1959
  xa_debug(1, (char *)"Using %d chunks of %d bytes for client backlog", 64, 8192);
  }
  }
  {
#line 1963
  if ((unsigned int )info.resolv_type == 2U) {
#line 1963
    goto case_2;
  }
#line 1966
  if ((unsigned int )info.resolv_type == 1U) {
#line 1966
    goto case_1;
  }
#line 1969
  if ((unsigned int )info.resolv_type == 3U) {
#line 1969
    goto case_3;
  }
#line 1961
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 1964
  xa_debug(1, (char *)"Using solaris own gethostbyname_r() and getaddrbyname_r(), which is good.");
  }
  }
#line 1965
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 1967
  xa_debug(1, (char *)"Using linux own gethostbyname_r() and getaddrbyname_r(), which is good.");
  }
  }
#line 1968
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 1970
  xa_debug(1, (char *)"Using standard gethostbyname() and getaddrbyname(), which might be dangerous cause it\'s not threadsafe!");
  }
  }
#line 1971
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1977
  return;
}
}
#line 1979 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int is_recoverable(int error ) 
{ 


  {
#line 1986
  if (error == 11) {
#line 1987
    return (1);
  } else
#line 1986
  if (error == 4) {
#line 1987
    return (1);
  } else
#line 1986
  if (error == 115) {
#line 1987
    return (1);
  }
#line 1996
  if (error == 5) {
#line 1997
    return (1);
  }
#line 2000
  return (0);
}
}
#line 2003 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void set_run_path(char **argv ) 
{ 
  char *pos ;
  int i ;
  size_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2009
  if (! argv) {
    {
    {
#line 2010
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Weird NULL pointer in argv\n");
    }
    }
#line 2011
    return;
  } else
#line 2009
  if (! *(argv + 0)) {
    {
    {
#line 2010
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Weird NULL pointer in argv\n");
    }
    }
#line 2011
    return;
  }
  {
  {
#line 2015
  info.runpath = strdup((char const   *)*(argv + 0));
  }
#line 2016
  running = 2;
  {
#line 2017
  pos = strrchr((char const   *)info.runpath, '/');
  }
  }
#line 2018
  if (pos) {
    {
#line 2019
    *(pos + 1) = (char )'\000';
    {
#line 2020
    tmp = strlen((char const   *)info.runpath);
    }
#line 2020
    i = (int )(tmp - 1U);
    }
#line 2021
    if (i >= 3) {
#line 2021
      if ((int )*(info.runpath + (i - 1)) == 110) {
#line 2021
        goto _L___0;
      } else
#line 2021
      if ((int )*(info.runpath + (i - 1)) == 78) {
        _L___0: /* CIL Label */ 
#line 2021
        if ((int )*(info.runpath + (i - 2)) == 105) {
#line 2021
          goto _L;
        } else
#line 2021
        if ((int )*(info.runpath + (i - 3)) == 73) {
          _L: /* CIL Label */ 
#line 2021
          if ((int )*(info.runpath + (i - 3)) == 98) {
#line 2025
            *(info.runpath + (i - 3)) = (char )'\000';
          } else
#line 2021
          if ((int )*(info.runpath + (i - 4)) == 66) {
#line 2025
            *(info.runpath + (i - 3)) = (char )'\000';
          }
        }
      }
    }
  }
#line 2028
  return;
}
}
#line 2030 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void zero_audiocast(audiocast_t *au ) 
{ 


  {
#line 2033
  au->name = (char *)((void *)0);
#line 2034
  au->genre = (char *)((void *)0);
#line 2035
  au->bitrate = -1;
#line 2036
  au->url = (char *)((void *)0);
#line 2037
  au->mount = (char *)((void *)0);
#line 2038
  au->description = (char *)((void *)0);
#line 2039
  au->streammimetype = (char *)((void *)0);
#line 2040
  au->contentid = (char *)((void *)0);
#line 2041
  au->public = -1;
#line 2042
  return;
}
}
#line 2044 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
void dispose_audiocast(audiocast_t *au ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2047
  if (! au) {
#line 2048
    return;
  }
  {
  {
#line 2049
  n_free((void *)au->name, (int const   )2049, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2049
  au->name = (char *)((void *)0);
  {
#line 2050
  n_free((void *)au->genre, (int const   )2050, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2050
  au->genre = (char *)((void *)0);
  {
#line 2051
  n_free((void *)au->url, (int const   )2051, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2051
  au->url = (char *)((void *)0);
  {
#line 2052
  n_free((void *)au->mount, (int const   )2052, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2052
  au->mount = (char *)((void *)0);
  {
#line 2053
  n_free((void *)au->description, (int const   )2053, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2053
  au->description = (char *)((void *)0);
  {
#line 2054
  n_free((void *)au->streammimetype, (int const   )2054, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2054
  au->streammimetype = (char *)((void *)0);
  {
#line 2055
  n_free((void *)au->contentid, (int const   )2055, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c");
  }
#line 2055
  au->contentid = (char *)((void *)0);
  }
#line 2056
  return;
}
}
#line 2058 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
int is_valid_http_request(request_t *req ) 
{ 


  {
#line 2061
  if (! req->path[0]) {
#line 2062
    return (0);
  }
#line 2063
  return (1);
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 145
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 30 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.h"
char *util_base64_encode(char *message ) ;
#line 33
char *mutex_to_string(mutex_t *mutex , char *out ) ;
#line 69 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
mutex_t library_mutex ;
#line 71 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char const   const_null[7]  = {      (char const   )'(',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )')',      (char const   )'\000'};
#line 73 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *splitc(char *first , char *rest , char const   divider ) 
{ 
  char *p ;
  char *__cil_tmp5 ;

  {
#line 78
  if (! rest) {
    {
    {
#line 80
    write_log(0, (char *)"WARNING: splitc called with NULL pointers");
    }
    }
#line 81
    return ((char *)((void *)0));
  }
  {
  {
#line 84
  p = strchr((char const   *)rest, (int )divider);
  }
  }
#line 85
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 86
    if ((unsigned long )first != (unsigned long )rest) {
#line 86
      if ((unsigned long )first != (unsigned long )((void *)0)) {
#line 87
        *(first + 0) = (char)0;
      }
    }
#line 89
    return ((char *)((void *)0));
  }
#line 92
  *p = (char)0;
#line 95
  if ((unsigned long )first != (unsigned long )((void *)0)) {
    {
    {
#line 95
    strcpy((char */* __restrict  */)first, (char const   */* __restrict  */)rest);
    }
    }
  }
#line 96
  if ((unsigned long )first != (unsigned long )rest) {
    {
    {
#line 96
    strcpy((char */* __restrict  */)rest, (char const   */* __restrict  */)(p + 1));
    }
    }
  }
#line 98
  return (rest);
}
}
#line 101 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *clean_string(char *string ) 
{ 
  register unsigned int i ;

  {
#line 106
  i = 0U;
  {
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 107
    if ((int )*(string + i) == 32) {
#line 107
      if (! ((int )*(string + i) != 0)) {
#line 107
        goto while_break;
      }
    } else {
#line 107
      goto while_break;
    }
#line 108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (string + i);
}
}
#line 113 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
void flags2string(admin_t *adm , void *param ) 
{ 
  char fls[5] ;
  unsigned int tmp ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 116
  fls[0] = (char )'\000';
#line 116
  tmp = 1U;
  {
  {
#line 116
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 116
    if (tmp >= 5U) {
#line 116
      goto while_break;
    }
#line 116
    fls[tmp] = (char)0;
#line 116
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (adm->oper) {
    {
    {
#line 118
    strcat((char */* __restrict  */)(fls), (char const   */* __restrict  */)"O");
    }
    }
  }
#line 119
  if (adm->tailing) {
    {
    {
#line 120
    strcat((char */* __restrict  */)(fls), (char const   */* __restrict  */)"T");
    }
    }
  }
#line 121
  if (adm->status) {
    {
    {
#line 122
    strcat((char */* __restrict  */)(fls), (char const   */* __restrict  */)"S");
    }
    }
  }
#line 123
  if (param) {
    {
    {
#line 124
    sock_write(*((sock_t *)param), "%s", fls);
    }
    }
  } else {
    {
    {
#line 126
    fd_write(info.statsfile, "%s", fls);
    }
    }
  }
#line 127
  return;
}
}
#line 129 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
int is_pattern(char const   *string ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
  {
#line 132
  tmp___1 = strchr(string, '*');
  }
  }
#line 132
  if (tmp___1) {
#line 133
    return (1);
  } else {
    {
    {
#line 134
    tmp___0 = strchr(string, '?');
    }
    }
#line 134
    if (tmp___0) {
#line 135
      return (1);
    } else {
      {
      {
#line 136
      tmp = strchr(string, '.');
      }
      }
#line 136
      if (tmp) {
#line 137
        return (1);
      }
    }
  }
#line 138
  return (0);
}
}
#line 141 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
int is_number(char const   *string ) 
{ 
  int i ;
  int length ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  {
#line 145
  tmp = ice_strlen(string);
  }
#line 145
  length = (int )tmp;
  }
#line 145
  if (length == 0) {
#line 146
    return (0);
  }
#line 149
  i = 0;
  {
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < length)) {
#line 149
      goto while_break;
    }
    {
    {
#line 150
    tmp___0 = __ctype_b_loc();
    }
    }
#line 150
    if (((int const   )*(*tmp___0 + (int )*(string + i)) & 1024) != 0) {
#line 151
      return (0);
    }
#line 149
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return (1);
}
}
#line 159 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
static char null[5]  = {      (char )'n',      (char )'u',      (char )'l',      (char )'l', 
        (char )'\000'};
#line 156 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char const   *con_host(connection_t *con ) 
{ 
  char *__cil_tmp2 ;

  {
#line 161
  if (! con) {
    {
    {
#line 163
    write_log(0, (char *)"WARNING: con_host called with NULL connection");
    }
    }
#line 164
    return ((char const   *)(null));
  }
#line 167
  if (con->hostname) {
#line 168
    return ((char const   *)con->hostname);
  } else
#line 169
  if (con->host) {
#line 170
    return ((char const   *)con->host);
  } else {
#line 172
    return ((char const   *)(null));
  }
}
}
#line 175 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *my_strdup(char const   *string ) 
{ 
  char const   *ptr ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 178
  ptr = string;
#line 179
  if (! string) {
    {
    {
#line 181
    xa_debug(1, (char *)"DEBUG: my_strdup called with NULL pointer!");
    }
    }
#line 182
    return ((char *)((void *)0));
  }
  {
  {
#line 184
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 184
    if (ptr) {
#line 184
      if (*ptr) {
#line 184
        if (! ((int const   )*ptr == 32)) {
#line 184
          goto while_break;
        }
      } else {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
#line 185
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 186
  tmp = n_strdup(ptr, (int const   )186, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
  }
  }
#line 186
  return (tmp);
}
}
#line 189 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char alphabet[65]  = 
#line 189
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
#line 191 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *util_base64_encode(char *message ) 
{ 
  char *encoded ;
  unsigned long length ;
  unsigned long encoded_length ;
  unsigned long left ;
  unsigned long bitqueue ;
  unsigned long i ;
  unsigned long j ;
  size_t tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  char *__cil_tmp29 ;

  {
  {
#line 195
  i = 0UL;
#line 195
  j = 0UL;
  {
#line 197
  tmp = ice_strlen((char const   *)message);
  }
#line 197
  length = (unsigned long )tmp;
  }
#line 199
  if (length == 0UL) {
#line 199
    return ((char *)((void *)0));
  }
  {
#line 201
  encoded_length = (4UL * (length + (3UL - length % 3UL) % 3UL)) / 3UL;
  {
#line 202
  tmp___0 = n_malloc((unsigned int const   )(encoded_length + 1UL), (int const   )202,
                     "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
  }
#line 202
  encoded = (char *)tmp___0;
  }
  {
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < length)) {
#line 204
      goto while_break;
    }
#line 205
    left = length - i;
#line 207
    if (left > 2UL) {
#line 208
      tmp___1 = i;
#line 208
      i ++;
#line 208
      bitqueue = (unsigned long )*(message + tmp___1);
#line 209
      tmp___2 = i;
#line 209
      i ++;
#line 209
      bitqueue = (bitqueue << 8) + (unsigned long )*(message + tmp___2);
#line 210
      tmp___3 = i;
#line 210
      i ++;
#line 210
      bitqueue = (bitqueue << 8) + (unsigned long )*(message + tmp___3);
#line 212
      tmp___4 = j;
#line 212
      j ++;
#line 212
      *(encoded + tmp___4) = alphabet[(bitqueue & 16515072UL) >> 18];
#line 213
      tmp___5 = j;
#line 213
      j ++;
#line 213
      *(encoded + tmp___5) = alphabet[(bitqueue & 258048UL) >> 12];
#line 214
      tmp___6 = j;
#line 214
      j ++;
#line 214
      *(encoded + tmp___6) = alphabet[(bitqueue & 4032UL) >> 6];
#line 215
      tmp___7 = j;
#line 215
      j ++;
#line 215
      *(encoded + tmp___7) = alphabet[bitqueue & 63UL];
    } else
#line 216
    if (left == 2UL) {
#line 217
      tmp___8 = i;
#line 217
      i ++;
#line 217
      bitqueue = (unsigned long )*(message + tmp___8);
#line 218
      tmp___9 = i;
#line 218
      i ++;
#line 218
      bitqueue = (bitqueue << 8) + (unsigned long )*(message + tmp___9);
#line 219
      bitqueue <<= 8;
#line 221
      tmp___10 = j;
#line 221
      j ++;
#line 221
      *(encoded + tmp___10) = alphabet[(bitqueue & 16515072UL) >> 18];
#line 222
      tmp___11 = j;
#line 222
      j ++;
#line 222
      *(encoded + tmp___11) = alphabet[(bitqueue & 258048UL) >> 12];
#line 223
      tmp___12 = j;
#line 223
      j ++;
#line 223
      *(encoded + tmp___12) = alphabet[(bitqueue & 4032UL) >> 6];
#line 224
      tmp___13 = j;
#line 224
      j ++;
#line 224
      *(encoded + tmp___13) = (char )'=';
    } else {
#line 226
      tmp___14 = i;
#line 226
      i ++;
#line 226
      bitqueue = (unsigned long )*(message + tmp___14);
#line 227
      bitqueue <<= 16;
#line 229
      tmp___15 = j;
#line 229
      j ++;
#line 229
      *(encoded + tmp___15) = alphabet[(bitqueue & 16515072UL) >> 18];
#line 230
      tmp___16 = j;
#line 230
      j ++;
#line 230
      *(encoded + tmp___16) = alphabet[(bitqueue & 258048UL) >> 12];
#line 231
      tmp___17 = j;
#line 231
      j ++;
#line 231
      *(encoded + tmp___17) = (char )'=';
#line 232
      tmp___18 = j;
#line 232
      j ++;
#line 232
      *(encoded + tmp___18) = (char )'=';
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (encoded);
}
}
#line 239 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char unalphabet(char alpha ) 
{ 


  {
#line 241
  if ((int )alpha >= 65) {
#line 241
    if ((int )alpha <= 90) {
#line 242
      return ((char )((int )alpha - 65));
    } else {
#line 241
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 243
  if ((int )alpha >= 97) {
#line 243
    if ((int )alpha <= 122) {
#line 244
      return ((char )(((int )alpha - 97) + 26));
    } else {
#line 243
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 245
  if ((int )alpha >= 48) {
#line 245
    if ((int )alpha <= 57) {
#line 246
      return ((char )(((int )alpha - 48) + 52));
    } else {
#line 245
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 247
  if ((int )alpha == 43) {
#line 248
    return ((char)62);
  } else
#line 249
  if ((int )alpha == 47) {
#line 250
    return ((char)63);
  } else
#line 251
  if ((int )alpha == 61) {
#line 252
    return ((char)64);
  } else {
#line 254
    return ((char)65);
  }
}
}
#line 257 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *util_base64_decode(char *message ) 
{ 
  char *decoded ;
  char temp ;
  long length ;
  long decoded_length ;
  long bitqueue ;
  long pad ;
  long i ;
  long j ;
  size_t tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  char *__cil_tmp19 ;

  {
  {
#line 262
  i = 0L;
#line 262
  j = 0L;
  {
#line 264
  tmp = ice_strlen((char const   *)message);
  }
#line 264
  length = (long )tmp;
  }
#line 266
  if (length % 4L != 0L) {
#line 266
    return ((char *)((void *)0));
  } else
#line 266
  if (length == 0L) {
#line 266
    return ((char *)((void *)0));
  }
#line 268
  decoded_length = (length / 4L) * 3L;
#line 270
  if ((int )*(message + (length - 1L)) == 61) {
#line 271
    decoded_length --;
#line 272
    if ((int )*(message + (length - 2L)) == 61) {
#line 273
      decoded_length --;
    }
  }
  {
  {
#line 276
  tmp___0 = n_malloc((unsigned int const   )(decoded_length + 1L), (int const   )276,
                     "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
  }
#line 276
  decoded = (char *)tmp___0;
  {
#line 277
  memset((void *)decoded, 0, (size_t )(decoded_length + 1L));
  }
  }
  {
  {
#line 279
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < length)) {
#line 279
      goto while_break;
    }
    {
#line 280
    pad = 0L;
#line 282
    tmp___1 = i;
#line 282
    i ++;
    {
#line 282
    temp = unalphabet(*(message + tmp___1));
    }
    }
#line 283
    if ((int )temp == 64) {
      {
      {
#line 284
      free((void *)decoded);
      }
      }
#line 285
      return ((char *)((void *)0));
    }
    {
#line 287
    bitqueue = (long )temp;
#line 289
    tmp___2 = i;
#line 289
    i ++;
    {
#line 289
    temp = unalphabet(*(message + tmp___2));
    }
    }
#line 290
    if ((int )temp == 64) {
      {
      {
#line 291
      free((void *)decoded);
      }
      }
#line 292
      return ((char *)((void *)0));
    }
    {
#line 294
    bitqueue <<= 6;
#line 295
    bitqueue += (long )temp;
#line 297
    tmp___3 = i;
#line 297
    i ++;
    {
#line 297
    temp = unalphabet(*(message + tmp___3));
    }
    }
#line 298
    if ((int )temp == 64) {
#line 299
      if (i != length - 1L) {
        {
        {
#line 300
        free((void *)decoded);
        }
        }
#line 301
        return ((char *)((void *)0));
      }
#line 303
      temp = (char)0;
#line 303
      pad ++;
    }
    {
#line 305
    bitqueue <<= 6;
#line 306
    bitqueue += (long )temp;
#line 308
    tmp___4 = i;
#line 308
    i ++;
    {
#line 308
    temp = unalphabet(*(message + tmp___4));
    }
    }
#line 309
    if (pad == 1L) {
#line 309
      if ((int )temp != 64) {
        {
        {
#line 310
        free((void *)decoded);
        }
        }
#line 311
        return ((char *)((void *)0));
      }
    }
#line 314
    if ((int )temp == 64) {
#line 315
      if (i != length) {
        {
        {
#line 316
        free((void *)decoded);
        }
        }
#line 317
        return ((char *)((void *)0));
      }
#line 319
      temp = (char)0;
#line 319
      pad ++;
    }
#line 321
    bitqueue <<= 6;
#line 322
    bitqueue += (long )temp;
#line 324
    tmp___5 = j;
#line 324
    j ++;
#line 324
    *(decoded + tmp___5) = (char )((bitqueue & 16711680L) >> 16);
#line 325
    if (pad < 2L) {
#line 326
      tmp___6 = j;
#line 326
      j ++;
#line 326
      *(decoded + tmp___6) = (char )((bitqueue & 65280L) >> 8);
#line 327
      if (pad < 1L) {
#line 328
        tmp___7 = j;
#line 328
        j ++;
#line 328
        *(decoded + tmp___7) = (char )(bitqueue & 255L);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return (decoded);
}
}
#line 335 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *safe_strcat(char *dest , char const   *src , unsigned int maxsize ) 
{ 
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 337
  if (! dest) {
#line 337
    return (dest);
  } else
#line 337
  if (! src) {
#line 337
    return (dest);
  }
  {
  {
#line 339
  tmp___3 = ice_strlen((char const   *)dest);
  }
  {
#line 339
  tmp___4 = ice_strlen(src);
  }
  }
#line 339
  if ((tmp___3 + tmp___4) + 1U >= maxsize) {
    {
    {
#line 340
    tmp___1 = ice_strlen((char const   *)dest);
    }
    }
#line 340
    if (tmp___1 + 1U >= maxsize) {
#line 342
      return (dest);
    } else {
      {
      {
#line 344
      tmp = ice_strlen((char const   *)dest);
      }
      {
#line 344
      tmp___0 = strncat((char */* __restrict  */)dest, (char const   */* __restrict  */)src,
                        maxsize - (tmp + 1U));
      }
      }
#line 344
      return (tmp___0);
    }
  } else {
    {
    {
#line 347
    tmp___2 = strcat((char */* __restrict  */)dest, (char const   */* __restrict  */)src);
    }
    }
#line 347
    return (tmp___2);
  }
}
}
#line 351 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *mutex_to_string(mutex_t *mutex , char *out ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 354
  if ((unsigned long )mutex == (unsigned long )(& info.source_mutex)) {
    {
    {
#line 355
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Source Tree Mutex");
    }
    }
  } else
#line 356
  if ((unsigned long )mutex == (unsigned long )(& info.relay_mutex)) {
    {
    {
#line 357
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Relay Tree Mutex");
    }
    }
  } else
#line 358
  if ((unsigned long )mutex == (unsigned long )(& info.admin_mutex)) {
    {
    {
#line 359
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Admin Tree Mutex");
    }
    }
  } else
#line 360
  if ((unsigned long )mutex == (unsigned long )(& info.directory_mutex)) {
    {
    {
#line 361
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Directory Tree Mutex");
    }
    }
  } else
#line 362
  if ((unsigned long )mutex == (unsigned long )(& info.alias_mutex)) {
    {
    {
#line 363
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Alias Tree Mutex");
    }
    }
  } else
#line 364
  if ((unsigned long )mutex == (unsigned long )(& info.misc_mutex)) {
    {
    {
#line 365
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Misc. Mutex");
    }
    }
  } else
#line 366
  if ((unsigned long )mutex == (unsigned long )(& info.mount_mutex)) {
    {
    {
#line 367
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Mount Point Mutex");
    }
    }
  } else
#line 368
  if ((unsigned long )mutex == (unsigned long )(& info.hostname_mutex)) {
    {
    {
#line 369
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Hostname Tree Mutex");
    }
    }
  } else
#line 370
  if ((unsigned long )mutex == (unsigned long )(& info.acl_mutex)) {
    {
    {
#line 371
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"ACL Tree Mutex");
    }
    }
  } else
#line 372
  if ((unsigned long )mutex == (unsigned long )(& info.double_mutex)) {
    {
    {
#line 373
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Double Mutex Mutex");
    }
    }
  } else
#line 374
  if ((unsigned long )mutex == (unsigned long )(& info.thread_mutex)) {
    {
    {
#line 375
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Thread Tree Mutex");
    }
    }
  } else
#line 385
  if ((unsigned long )mutex == (unsigned long )(& info.resolvmutex)) {
    {
    {
#line 386
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"DNS Lookup Mutex");
    }
    }
  } else
#line 387
  if ((unsigned long )mutex == (unsigned long )(& library_mutex)) {
    {
    {
#line 388
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Library Mutex");
    }
    }
  } else
#line 389
  if ((unsigned long )mutex == (unsigned long )(& authentication_mutex)) {
    {
    {
#line 390
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Authentication Mutex");
    }
    }
  } else {
    {
    {
#line 392
    strcpy((char */* __restrict  */)out, (char const   */* __restrict  */)"Unknown Mutex (probably source)");
    }
    }
  }
#line 395
  return (out);
}
}
#line 398 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char const   *skip_before(char const   *ptr , char const   *search ) 
{ 
  char *tmp ;

  {
  {
  {
#line 401
  tmp = strstr(ptr, search);
  }
  }
#line 401
  return ((char const   *)tmp);
}
}
#line 404 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char const   *skip_after(char const   *ptr , char const   *search ) 
{ 
  char *hit ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
  {
#line 407
  tmp = strstr(ptr, search);
  }
#line 407
  hit = tmp;
  }
#line 408
  if (hit) {
    {
    {
#line 409
    tmp___0 = ice_strlen(search);
    }
    }
#line 409
    return ((char const   *)hit + tmp___0);
  } else {
#line 411
    return ((char const   *)((void *)0));
  }
}
}
#line 414 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *create_malloced_ascii_host(struct in_addr *in ) 
{ 
  char *buf ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 416
  tmp = n_malloc((unsigned int const   )20, (int const   )416, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
  }
#line 416
  buf = (char *)tmp;
  }
#line 418
  if (! in) {
    {
    {
#line 419
    xa_debug(1, (char *)"ERROR: Dammit, don\'t send NULL\'s to create_malloced_ascii_host()");
    }
    }
#line 420
    return ((char *)((void *)0));
  }
  {
  {
#line 423
  tmp___0 = makeasciihost((struct in_addr  const  *)in, buf);
  }
  }
#line 423
  return (tmp___0);
}
}
#line 426 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *makeasciihost(struct in_addr  const  *in , char *buf ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 428
  if (! buf) {
    {
    {
#line 429
    write_log(0, (char *)"ERROR: makeasciihost called with NULL arguments");
    }
    }
#line 430
    return ((char *)((void *)0));
  }
  {
  {
#line 437
  tmp = inet_ntoa((struct in_addr )*in);
  }
  {
#line 437
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)tmp, (size_t )20);
  }
  }
#line 453
  return (buf);
}
}
#line 456 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *nice_time_minutes(unsigned long minutes , char *buf ) 
{ 
  unsigned long days ;
  unsigned long hours ;
  unsigned long remains ;
  char buf2[8192] ;
  size_t tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 462
  if (! buf) {
    {
    {
#line 464
    write_log(0, (char *)"ERROR: nice_time_minutes called with NULL argument");
    }
    }
#line 465
    return ((char *)((void *)0));
  }
#line 468
  *(buf + 0) = (char )'\000';
#line 470
  days = minutes / 1440UL;
#line 471
  remains = minutes % 1440UL;
#line 472
  hours = remains / 60UL;
#line 473
  remains %= 60UL;
#line 475
  if (days > 0UL) {
    {
    {
#line 476
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu days, %lu hours, %lu minutes",
             days, hours, remains);
    }
    }
  } else
#line 477
  if (hours > 0UL) {
    {
    {
#line 478
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu hours, %lu minutes",
             hours, remains);
    }
    }
  } else {
    {
    {
#line 481
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu minutes",
             remains);
    }
    }
#line 482
    return (buf);
  }
#line 485
  if (remains > 0UL) {
    {
    {
#line 487
    snprintf((char */* __restrict  */)(buf2), (size_t )8192, (char const   */* __restrict  */)" and %lu minutes",
             remains);
    }
    {
#line 488
    tmp = strlen((char const   *)(buf2));
    }
    {
#line 488
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(buf2),
            8192U - tmp);
    }
    }
  }
#line 491
  return (buf);
}
}
#line 494 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *nice_time(unsigned long seconds , char *buf ) 
{ 
  unsigned long days ;
  unsigned long hours ;
  unsigned long minutes ;
  unsigned long nseconds ;
  unsigned long remains ;
  char buf2[8192] ;
  size_t tmp ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 500
  if (! buf) {
    {
    {
#line 502
    write_log(0, (char *)"ERROR: nice_time called with NULL argument");
    }
    }
#line 503
    return ((char *)((void *)0));
  }
#line 506
  *(buf + 0) = (char )'\000';
#line 508
  days = seconds / 86400UL;
#line 509
  remains = seconds % 86400UL;
#line 510
  hours = remains / 3600UL;
#line 511
  remains %= 3600UL;
#line 512
  minutes = remains / 60UL;
#line 513
  nseconds = remains % 60UL;
#line 514
  if (days > 0UL) {
    {
    {
#line 515
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu days, %lu hours, %lu minutes",
             days, hours, minutes);
    }
    }
  } else
#line 516
  if (hours > 0UL) {
    {
    {
#line 517
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu hours, %lu minutes",
             hours, minutes);
    }
    }
  } else
#line 518
  if (minutes > 0UL) {
    {
    {
#line 519
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu minutes",
             minutes);
    }
    }
  } else {
    {
    {
#line 523
    snprintf((char */* __restrict  */)buf, (size_t )8192, (char const   */* __restrict  */)"%lu seconds",
             nseconds);
    }
    }
#line 524
    return (buf);
  }
#line 527
  if (nseconds > 0UL) {
    {
    {
#line 529
    snprintf((char */* __restrict  */)(buf2), (size_t )8192, (char const   */* __restrict  */)" and %lu seconds",
             nseconds);
    }
    {
#line 530
    tmp = strlen((char const   *)(buf2));
    }
    {
#line 530
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)(buf2),
            8192U - tmp);
    }
    }
  }
#line 533
  return (buf);
}
}
#line 536 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *ice_sprintf(char const   *template , char const   *arg ) 
{ 
  char *ptr ;
  size_t sz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 542
  if (! template) {
#line 544
    if (! arg) {
      {
      {
#line 545
      tmp = n_strdup("(null)", (int const   )545, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
      }
      }
#line 545
      return (tmp);
    }
    {
    {
#line 546
    tmp___0 = n_strdup(arg, (int const   )546, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
    }
    }
#line 546
    return (tmp___0);
  }
#line 549
  if (! arg) {
    {
    {
#line 550
    tmp___1 = n_strdup("(null)", (int const   )550, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
    }
    }
#line 550
    return (tmp___1);
  }
  {
  {
#line 552
  tmp___3 = strchr(template, '%');
  }
  }
#line 552
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    {
    {
#line 553
    tmp___2 = n_strdup(template, (int const   )553, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
    }
    }
#line 553
    return (tmp___2);
  }
  {
  {
#line 555
  tmp___4 = ice_strlen(arg);
  }
  {
#line 555
  tmp___5 = ice_strlen(template);
  }
#line 555
  sz = (tmp___4 + tmp___5) + 2U;
  {
#line 556
  tmp___6 = n_malloc((unsigned int const   )sz, (int const   )556, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c");
  }
#line 556
  ptr = (char *)tmp___6;
  {
#line 558
  snprintf((char */* __restrict  */)ptr, sz, (char const   */* __restrict  */)template,
           arg);
  }
  }
#line 559
  return (ptr);
}
}
#line 562 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
size_t ice_strlen(char const   *string ) 
{ 
  size_t tmp ;
  char *__cil_tmp3 ;

  {
#line 565
  if (! string) {
    {
    {
#line 567
    xa_debug(1, (char *)"ERROR: ice_strlen() called with NULL pointer!");
    }
    }
#line 568
    return ((size_t )0);
  }
  {
  {
#line 570
  tmp = strlen(string);
  }
  }
#line 570
  return (tmp);
}
}
#line 573 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
int ice_strcmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 576
  if (! s1) {
    {
    {
#line 578
    xa_debug(1, (char *)"ERROR: ice_strcmp() called with NULL pointers!");
    }
    }
#line 579
    return (0);
  } else
#line 576
  if (! s2) {
    {
    {
#line 578
    xa_debug(1, (char *)"ERROR: ice_strcmp() called with NULL pointers!");
    }
    }
#line 579
    return (0);
  }
  {
  {
#line 581
  tmp = strcmp(s1, s2);
  }
  }
#line 581
  return (tmp);
}
}
#line 584 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
int ice_strncmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 587
  if (! s1) {
    {
    {
#line 589
    xa_debug(1, (char *)"ERROR: ice_strncmp() called with NULL pointers!");
    }
    }
#line 590
    return (0);
  } else
#line 587
  if (! s2) {
    {
    {
#line 589
    xa_debug(1, (char *)"ERROR: ice_strncmp() called with NULL pointers!");
    }
    }
#line 590
    return (0);
  }
  {
  {
#line 592
  tmp = strncmp(s1, s2, n);
  }
  }
#line 592
  return (tmp);
}
}
#line 595 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
int ice_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 598
  if (! s1) {
    {
    {
#line 600
    xa_debug(1, (char *)"ERROR: ice_strcasecmp() called with NULL pointers");
    }
    }
#line 601
    return (0);
  } else
#line 598
  if (! s2) {
    {
    {
#line 600
    xa_debug(1, (char *)"ERROR: ice_strcasecmp() called with NULL pointers");
    }
    }
#line 601
    return (0);
  }
  {
  {
#line 606
  tmp = strcasecmp(s1, s2);
  }
  }
#line 606
  return (tmp);
}
}
#line 610 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char *ice_strstr(char const   *haystack , char const   *needle ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 613
  if (! needle) {
    {
    {
#line 614
    xa_debug(1, (char *)"ERROR: ice_strstr() called with NULL pointers");
    }
    }
#line 615
    return ((char *)((void *)0));
  } else
#line 613
  if (! haystack) {
    {
    {
#line 614
    xa_debug(1, (char *)"ERROR: ice_strstr() called with NULL pointers");
    }
    }
#line 615
    return ((char *)((void *)0));
  }
  {
  {
#line 617
  tmp = strstr(haystack, needle);
  }
  }
#line 617
  return (tmp);
}
}
#line 620 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
char const   *nullcheck_string(char const   *string ) 
{ 


  {
#line 623
  if (! string) {
#line 624
    return (const_null);
  }
#line 625
  return (string);
}
}
#line 628 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
void catsnprintf(char *line , size_t sz , char const   *fmt  , ...) 
{ 
  char buff[8192] ;
  va_list ap ;
  void *__cil_tmp6 ;

  {
  {
  {
#line 634
  __builtin_va_start(ap, fmt);
  }
  {
#line 636
  vsnprintf((char */* __restrict  */)(buff), (size_t )8192, (char const   */* __restrict  */)fmt,
            ap);
  }
  {
#line 638
  __builtin_va_end(ap);
  }
  {
#line 640
  strncat((char */* __restrict  */)line, (char const   */* __restrict  */)(buff),
          sz);
  }
  }
#line 641
  return;
}
}
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.h"
void parse_authentication_scheme(void) ;
#line 25
void destroy_authentication_scheme(void) ;
#line 28
void rehash_authentication_scheme(void) ;
#line 29
int need_authentication_on_mount(char *mount ) ;
#line 24 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.h"
void parse_mount_authentication_file(void) ;
#line 27
mounttree_t *create_mount_tree(void) ;
#line 29
void free_mount_tree(mounttree_t *mt ) ;
#line 30
grouptree_t *get_grouptree_for_mount(char const   *mountname ) ;
#line 77 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
mutex_t authentication_mutex  =    {-3L, {{0, 0U, 0, 0, 0U, {.__list = {(struct __pthread_internal_slist *)0}}}},
    0L, 0, 0L};
#line 78 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
mounttree_t *mounttree  =    (mounttree_t *)((void *)0);
#line 79 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
usertree_t *usertree  =    (usertree_t *)((void *)0);
#line 80 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
grouptree_t *grouptree  =    (grouptree_t *)((void *)0);
#line 81 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
time_t lastrehash  =    (time_t )0;
#line 83 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
void rehash_authentication_scheme(void) 
{ 
  int rehash_it ;
  struct stat st ;
  char *userfile ;
  char *mountfile ;
  char *groupfile ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 85
  rehash_it = 0;
  {
#line 89
  userfile = get_icecast_file((char const   *)info.userfile, (filetype_t )1, 4);
  }
  {
#line 90
  mountfile = get_icecast_file((char const   *)info.mountfile, (filetype_t )1, 4);
  }
  {
#line 91
  groupfile = get_icecast_file((char const   *)info.groupfile, (filetype_t )1, 4);
  }
  }
#line 93
  if (userfile) {
    {
    {
#line 94
    tmp = stat((char const   */* __restrict  */)userfile, (struct stat */* __restrict  */)(& st));
    }
    }
#line 94
    if (tmp == 0) {
#line 95
      if (st.st_mtim.tv_sec > lastrehash) {
#line 96
        rehash_it = 1;
      }
    }
  }
#line 98
  if (! rehash_it) {
#line 98
    if (groupfile) {
      {
      {
#line 99
      tmp___0 = stat((char const   */* __restrict  */)groupfile, (struct stat */* __restrict  */)(& st));
      }
      }
#line 99
      if (tmp___0 == 0) {
#line 100
        if (st.st_mtim.tv_sec > lastrehash) {
#line 101
          rehash_it = 1;
        }
      }
    }
  }
#line 103
  if (! rehash_it) {
#line 103
    if (mountfile) {
      {
      {
#line 104
      tmp___1 = stat((char const   */* __restrict  */)mountfile, (struct stat */* __restrict  */)(& st));
      }
      }
#line 104
      if (tmp___1 == 0) {
#line 105
        if (st.st_mtim.tv_sec > lastrehash) {
#line 106
          rehash_it = 1;
        }
      }
    }
  }
#line 108
  if (rehash_it) {
    {
    {
#line 109
    parse_authentication_scheme();
    }
    }
  }
  {
  {
#line 111
  n_free((void *)userfile, (int const   )111, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 111
  userfile = (char *)((void *)0);
  {
#line 112
  n_free((void *)groupfile, (int const   )112, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 112
  groupfile = (char *)((void *)0);
  {
#line 113
  n_free((void *)mountfile, (int const   )113, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 113
  mountfile = (char *)((void *)0);
  }
#line 114
  return;
}
}
#line 116 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
void init_authentication_scheme(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
  {
#line 118
  thread_create_mutex_c(& authentication_mutex, 118, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  {
#line 120
  parse_authentication_scheme();
  }
  }
#line 121
  return;
}
}
#line 128 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
void parse_authentication_scheme(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
  {
  {
#line 130
  thread_mutex_lock_c(& authentication_mutex, 130, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  {
#line 135
  destroy_authentication_scheme();
  }
  {
#line 140
  parse_user_authentication_file();
  }
  {
#line 145
  parse_group_authentication_file();
  }
  {
#line 150
  parse_mount_authentication_file();
  }
  {
#line 152
  thread_mutex_unlock_c(& authentication_mutex, 152, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  {
#line 154
  lastrehash = get_time();
  }
  }
#line 155
  return;
}
}
#line 157 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
void destroy_authentication_scheme(void) 
{ 


  {
  {
  {
#line 159
  free_mount_tree(mounttree);
  }
  {
#line 161
  free_group_tree(grouptree);
  }
  {
#line 163
  free_user_tree(usertree);
  }
  {
#line 165
  mounttree = create_mount_tree();
  }
  {
#line 166
  grouptree = create_group_tree();
  }
  {
#line 167
  usertree = create_user_tree();
  }
  }
#line 168
  return;
}
}
#line 170 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
int authenticate_user_request(connection_t *con , request_t *req ) 
{ 
  ice_user_t checkuser ;
  grouptree_t *gt ;
  group_t *group ;
  avl_traverser trav ;
  ice_user_t *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 178
  trav.init = 0;
#line 178
  trav.nstack = 0;
#line 178
  trav.p = (avl_node const   *)0;
#line 178
  trav.stack[0] = (avl_node const   *)0;
#line 178
  trav.stack[1] = (avl_node const   *)0;
#line 178
  trav.stack[2] = (avl_node const   *)0;
#line 178
  trav.stack[3] = (avl_node const   *)0;
#line 178
  trav.stack[4] = (avl_node const   *)0;
#line 178
  trav.stack[5] = (avl_node const   *)0;
#line 178
  trav.stack[6] = (avl_node const   *)0;
#line 178
  trav.stack[7] = (avl_node const   *)0;
#line 178
  trav.stack[8] = (avl_node const   *)0;
#line 178
  trav.stack[9] = (avl_node const   *)0;
#line 178
  trav.stack[10] = (avl_node const   *)0;
#line 178
  trav.stack[11] = (avl_node const   *)0;
#line 178
  trav.stack[12] = (avl_node const   *)0;
#line 178
  trav.stack[13] = (avl_node const   *)0;
#line 178
  trav.stack[14] = (avl_node const   *)0;
#line 178
  trav.stack[15] = (avl_node const   *)0;
#line 178
  trav.stack[16] = (avl_node const   *)0;
#line 178
  trav.stack[17] = (avl_node const   *)0;
#line 178
  trav.stack[18] = (avl_node const   *)0;
#line 178
  trav.stack[19] = (avl_node const   *)0;
#line 178
  trav.stack[20] = (avl_node const   *)0;
#line 178
  trav.stack[21] = (avl_node const   *)0;
#line 178
  trav.stack[22] = (avl_node const   *)0;
#line 178
  trav.stack[23] = (avl_node const   *)0;
#line 178
  trav.stack[24] = (avl_node const   *)0;
#line 178
  trav.stack[25] = (avl_node const   *)0;
#line 178
  trav.stack[26] = (avl_node const   *)0;
#line 178
  trav.stack[27] = (avl_node const   *)0;
#line 178
  trav.stack[28] = (avl_node const   *)0;
#line 178
  trav.stack[29] = (avl_node const   *)0;
#line 178
  trav.stack[30] = (avl_node const   *)0;
#line 178
  trav.stack[31] = (avl_node const   *)0;
  {
#line 180
  tmp = con_get_user(con, & checkuser);
  }
  }
#line 180
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 181
    return (0);
  }
  {
  {
#line 183
  tmp___0 = nullcheck_string((char const   *)checkuser.pass);
  }
  {
#line 183
  tmp___1 = nullcheck_string((char const   *)checkuser.name);
  }
  {
#line 183
  tmp___2 = nullcheck_string((char const   *)(req->path));
  }
  {
#line 183
  xa_debug(3, (char *)"DEBUG: Checking authentication for mount %s for user %s with pass %s",
           tmp___2, tmp___1, tmp___0);
  }
  {
#line 186
  rehash_authentication_scheme();
  }
  {
#line 188
  thread_mutex_lock_c(& authentication_mutex, 188, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  {
#line 190
  gt = get_grouptree_for_mount("all");
  }
  }
#line 192
  if (! gt) {
    {
    {
#line 193
    gt = get_grouptree_for_mount((char const   *)(req->path));
    }
    }
  }
#line 195
  if (! gt) {
    {
    {
#line 196
    gt = get_grouptree_for_mount("rest");
    }
    }
  }
#line 198
  if (! checkuser.name) {
    {
    {
#line 199
    thread_mutex_unlock_c(& authentication_mutex, 199, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
    }
    }
#line 200
    return (0);
  } else
#line 198
  if (! checkuser.pass) {
    {
    {
#line 199
    thread_mutex_unlock_c(& authentication_mutex, 199, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
    }
    }
#line 200
    return (0);
  } else
#line 198
  if (! gt) {
    {
    {
#line 199
    thread_mutex_unlock_c(& authentication_mutex, 199, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
    }
    }
#line 200
    return (0);
  }
  {
  {
#line 202
  tmp___5 = user_authenticate(checkuser.name, (char const   *)checkuser.pass);
  }
  }
#line 202
  if (tmp___5) {
    {
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 203
      tmp___4 = avl_traverse(gt, & trav);
      }
#line 203
      group = (group_t *)tmp___4;
      }
#line 203
      if (! group) {
#line 203
        goto while_break;
      }
      {
      {
#line 204
      tmp___3 = is_member_of(checkuser.name, group);
      }
      }
#line 204
      if (tmp___3) {
        {
        {
#line 205
        n_free((void *)checkuser.name, (int const   )205, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
        }
#line 205
        checkuser.name = (char *)((void *)0);
        {
#line 206
        n_free((void *)checkuser.pass, (int const   )206, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
        }
#line 206
        checkuser.pass = (char *)((void *)0);
        {
#line 207
        thread_mutex_unlock_c(& authentication_mutex, 207, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
        }
        }
#line 208
        return (1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 212
    xa_debug(1, (char *)"DEBUG: User authentication failed. Invalid user/password");
    }
    }
  }
  {
  {
#line 216
  n_free((void *)checkuser.name, (int const   )216, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 216
  checkuser.name = (char *)((void *)0);
  {
#line 217
  n_free((void *)checkuser.pass, (int const   )217, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 217
  checkuser.pass = (char *)((void *)0);
  {
#line 218
  thread_mutex_unlock_c(& authentication_mutex, 218, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  }
#line 219
  return (0);
}
}
#line 222 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
int need_authentication_on_mount(char *mount ) 
{ 
  request_t req ;
  int tmp ;

  {
  {
  {
#line 226
  zero_request(& req);
  }
  {
#line 227
  strcpy((char */* __restrict  */)(req.path), (char const   */* __restrict  */)mount);
  }
  {
#line 228
  tmp = need_authentication(& req);
  }
  }
#line 228
  return (tmp);
}
}
#line 231 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c"
int need_authentication(request_t *req ) 
{ 
  mount_t *mount ;
  mount_t search ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 236
  xa_debug(3, (char *)"DEBUG: Checking need for authentication on mount %s", req->path);
  }
  {
#line 238
  rehash_authentication_scheme();
  }
  {
#line 240
  thread_mutex_lock_c(& authentication_mutex, 240, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
#line 242
  search.name = req->path;
  {
#line 244
  tmp = avl_find(mounttree, (void const   *)(& search));
  }
#line 244
  mount = (mount_t *)tmp;
  }
#line 246
  if (mount) {
    {
    {
#line 247
    thread_mutex_unlock_c(& authentication_mutex, 247, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
    }
    }
#line 248
    return (1);
  }
  {
  {
#line 250
  thread_mutex_unlock_c(& authentication_mutex, 250, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/basic.c");
  }
  }
#line 252
  return (0);
}
}
#line 25 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.h"
mount_t *create_mount_from_line(char *line ) ;
#line 26
mount_t *create_mount(void) ;
#line 28
void add_authentication_mount(mount_t *mount ) ;
#line 31
void con_display_mounts(com_request_t *req ) ;
#line 32
int runtime_add_mount(char const   *name ) ;
#line 33
int runtime_add_mount_with_group(char const   *name , char *groups ) ;
#line 79 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
void parse_mount_authentication_file(void) 
{ 
  int fd ;
  char *mountfile ;
  char *tmp ;
  mount_t *mount ;
  char line[8192] ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 82
  tmp = get_icecast_file((char const   *)info.mountfile, (filetype_t )1, 4);
  }
#line 82
  mountfile = tmp;
  }
#line 86
  if (! mountfile) {
#line 86
    goto _L;
  } else {
    {
    {
#line 86
    fd = open_for_reading((char const   *)mountfile);
    }
    }
#line 86
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 87
      if (mountfile) {
        {
        {
#line 88
        n_free((void *)mountfile, (int const   )88, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
        }
        }
      }
      {
#line 88
      mountfile = (char *)((void *)0);
      {
#line 89
      xa_debug(1, (char *)"WARNING: Could not open mount authentication file");
      }
      }
#line 90
      return;
    }
  }
  {
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 92
    tmp___0 = fd_read_line(fd, line, (int const   )8192);
    }
    }
#line 92
    if (! tmp___0) {
#line 92
      goto while_break;
    }
#line 93
    if ((int )line[0] == 35) {
#line 94
      goto while_continue;
    } else
#line 93
    if ((int )line[0] == 32) {
#line 94
      goto while_continue;
    }
    {
    {
#line 96
    mount = create_mount_from_line(line);
    }
    }
#line 98
    if (mount) {
      {
      {
#line 99
      add_authentication_mount(mount);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (mountfile) {
    {
    {
#line 103
    n_free((void *)mountfile, (int const   )103, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
    }
  }
  {
#line 103
  mountfile = (char *)((void *)0);
  {
#line 104
  fd_close(fd);
  }
  }
#line 105
  return;
}
}
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
mount_t *create_mount_from_line(char *line ) 
{ 
  mount_t *mount ;
  group_t *group ;
  char name[8192] ;
  char cgroup[8192] ;
  int go_on ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 113
  go_on = 1;
#line 115
  if (! line) {
    {
    {
#line 116
    xa_debug(1, (char *)"WARNING: create_mount_from_line() called with NULL pointer");
    }
    }
#line 117
    return ((mount_t *)((void *)0));
  }
  {
  {
#line 119
  tmp = splitc(name, line, (char const   )':');
  }
  }
#line 119
  if (! tmp) {
    {
    {
#line 120
    xa_debug(1, (char *)"ERROR: Syntax error in mount file, with line [%s]", line);
    }
    }
#line 121
    return ((mount_t *)((void *)0));
  }
  {
  {
#line 123
  mount = create_mount();
  }
  {
#line 125
  tmp___0 = clean_string(name);
  }
  {
#line 125
  mount->name = n_strdup((char const   *)tmp___0, (int const   )125, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  }
  {
  {
#line 127
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 128
    tmp___1 = splitc(cgroup, line, (char const   )',');
    }
    }
#line 128
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
      {
#line 129
      strcpy((char */* __restrict  */)(cgroup), (char const   */* __restrict  */)line);
      }
#line 130
      go_on = 0;
      }
    }
    {
    {
#line 132
    tmp___2 = clean_string(cgroup);
    }
    {
#line 132
    group = find_group_from_tree(grouptree, (char const   *)tmp___2);
    }
    }
#line 134
    if (! group) {
      {
      {
#line 135
      write_log(0, (char *)"WARNING: Unrecognized group [%s] specified for mount [%s]",
                cgroup, name);
      }
      }
    } else {
      {
      {
#line 138
      avl_insert(mount->grouptree, (void *)group);
      }
      }
    }
#line 127
    if (! go_on) {
#line 127
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return (mount);
}
}
#line 145 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
mount_t *create_mount(void) 
{ 
  mount_t *mount ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 148
  tmp = n_malloc((unsigned int const   )sizeof(mount_t ), (int const   )148, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
#line 148
  mount = (mount_t *)tmp;
  {
#line 150
  mount->grouptree = create_group_tree();
  }
#line 151
  mount->name = (char *)((void *)0);
  }
#line 152
  return (mount);
}
}
#line 155 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
mounttree_t *create_mount_tree(void) 
{ 
  mounttree_t *gt ;
  avl_tree *tmp ;

  {
  {
  {
#line 158
  tmp = avl_create(& compare_mounts, (void *)(& info));
  }
#line 158
  gt = tmp;
  }
#line 160
  return (gt);
}
}
#line 163 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
void add_authentication_mount(mount_t *mount ) 
{ 
  mount_t *out ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 167
  if (! mount) {
    {
    {
#line 168
    xa_debug(1, (char *)"ERROR: add_authentication_mount() called with NULL pointers");
    }
    }
#line 169
    return;
  } else
#line 167
  if (! mounttree) {
    {
    {
#line 168
    xa_debug(1, (char *)"ERROR: add_authentication_mount() called with NULL pointers");
    }
    }
#line 169
    return;
  } else
#line 167
  if (! mount->name) {
    {
    {
#line 168
    xa_debug(1, (char *)"ERROR: add_authentication_mount() called with NULL pointers");
    }
    }
#line 169
    return;
  } else
#line 167
  if (! mount->grouptree) {
    {
    {
#line 168
    xa_debug(1, (char *)"ERROR: add_authentication_mount() called with NULL pointers");
    }
    }
#line 169
    return;
  }
  {
  {
#line 171
  tmp = avl_replace(mounttree, (void *)mount);
  }
#line 171
  out = (mount_t *)tmp;
  }
#line 173
  if (out) {
    {
    {
#line 174
    write_log(0, (char *)"WARNING: Duplicate mount record %s, using latter", mount->name);
    }
    {
#line 175
    n_free((void *)out->name, (int const   )175, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
#line 175
    out->name = (char *)((void *)0);
    {
#line 176
    free_group_tree(out->grouptree);
    }
    {
#line 177
    n_free((void *)out, (int const   )177, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
#line 177
    out = (mount_t *)((void *)0);
    }
  }
  {
  {
#line 179
  xa_debug(1, (char *)"DEBUG: add_authentication_mount(): Inserted mount [%s]", mount->name);
  }
  }
#line 180
  return;
}
}
#line 182 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
void free_mount_tree(mounttree_t *mt ) 
{ 
  avl_traverser trav ;
  mount_t *mount ;
  mount_t *out ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 184
  trav.init = 0;
#line 184
  trav.nstack = 0;
#line 184
  trav.p = (avl_node const   *)0;
#line 184
  trav.stack[0] = (avl_node const   *)0;
#line 184
  trav.stack[1] = (avl_node const   *)0;
#line 184
  trav.stack[2] = (avl_node const   *)0;
#line 184
  trav.stack[3] = (avl_node const   *)0;
#line 184
  trav.stack[4] = (avl_node const   *)0;
#line 184
  trav.stack[5] = (avl_node const   *)0;
#line 184
  trav.stack[6] = (avl_node const   *)0;
#line 184
  trav.stack[7] = (avl_node const   *)0;
#line 184
  trav.stack[8] = (avl_node const   *)0;
#line 184
  trav.stack[9] = (avl_node const   *)0;
#line 184
  trav.stack[10] = (avl_node const   *)0;
#line 184
  trav.stack[11] = (avl_node const   *)0;
#line 184
  trav.stack[12] = (avl_node const   *)0;
#line 184
  trav.stack[13] = (avl_node const   *)0;
#line 184
  trav.stack[14] = (avl_node const   *)0;
#line 184
  trav.stack[15] = (avl_node const   *)0;
#line 184
  trav.stack[16] = (avl_node const   *)0;
#line 184
  trav.stack[17] = (avl_node const   *)0;
#line 184
  trav.stack[18] = (avl_node const   *)0;
#line 184
  trav.stack[19] = (avl_node const   *)0;
#line 184
  trav.stack[20] = (avl_node const   *)0;
#line 184
  trav.stack[21] = (avl_node const   *)0;
#line 184
  trav.stack[22] = (avl_node const   *)0;
#line 184
  trav.stack[23] = (avl_node const   *)0;
#line 184
  trav.stack[24] = (avl_node const   *)0;
#line 184
  trav.stack[25] = (avl_node const   *)0;
#line 184
  trav.stack[26] = (avl_node const   *)0;
#line 184
  trav.stack[27] = (avl_node const   *)0;
#line 184
  trav.stack[28] = (avl_node const   *)0;
#line 184
  trav.stack[29] = (avl_node const   *)0;
#line 184
  trav.stack[30] = (avl_node const   *)0;
#line 184
  trav.stack[31] = (avl_node const   *)0;
#line 188
  if (! mt) {
#line 189
    return;
  }
  {
  {
#line 191
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 191
    tmp___0 = avl_traverse(mt, & trav);
    }
#line 191
    mount = (mount_t *)tmp___0;
    }
#line 191
    if (! mount) {
#line 191
      goto while_break;
    }
    {
    {
#line 192
    tmp = avl_delete(mt, (void const   *)mount);
    }
#line 192
    out = (mount_t *)tmp;
    }
#line 194
    if (! out) {
      {
      {
#line 195
      xa_debug(1, (char *)"WARNING: Weird ass things going on in mounttree!");
      }
      }
#line 196
      goto while_continue;
    }
    {
    {
#line 198
    n_free((void *)mount->name, (int const   )198, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
#line 198
    mount->name = (char *)((void *)0);
    {
#line 199
    avl_destroy(mount->grouptree, (void (*)(void *data , void *param ))((void *)0));
    }
    {
#line 200
    n_free((void *)mount, (int const   )200, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
#line 200
    mount = (mount_t *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
grouptree_t *get_grouptree_for_mount(char const   *mountname ) 
{ 
  mount_t *mount ;
  avl_traverser trav ;
  int tmp ;
  void *tmp___0 ;

  {
#line 208
  trav.init = 0;
#line 208
  trav.nstack = 0;
#line 208
  trav.p = (avl_node const   *)0;
#line 208
  trav.stack[0] = (avl_node const   *)0;
#line 208
  trav.stack[1] = (avl_node const   *)0;
#line 208
  trav.stack[2] = (avl_node const   *)0;
#line 208
  trav.stack[3] = (avl_node const   *)0;
#line 208
  trav.stack[4] = (avl_node const   *)0;
#line 208
  trav.stack[5] = (avl_node const   *)0;
#line 208
  trav.stack[6] = (avl_node const   *)0;
#line 208
  trav.stack[7] = (avl_node const   *)0;
#line 208
  trav.stack[8] = (avl_node const   *)0;
#line 208
  trav.stack[9] = (avl_node const   *)0;
#line 208
  trav.stack[10] = (avl_node const   *)0;
#line 208
  trav.stack[11] = (avl_node const   *)0;
#line 208
  trav.stack[12] = (avl_node const   *)0;
#line 208
  trav.stack[13] = (avl_node const   *)0;
#line 208
  trav.stack[14] = (avl_node const   *)0;
#line 208
  trav.stack[15] = (avl_node const   *)0;
#line 208
  trav.stack[16] = (avl_node const   *)0;
#line 208
  trav.stack[17] = (avl_node const   *)0;
#line 208
  trav.stack[18] = (avl_node const   *)0;
#line 208
  trav.stack[19] = (avl_node const   *)0;
#line 208
  trav.stack[20] = (avl_node const   *)0;
#line 208
  trav.stack[21] = (avl_node const   *)0;
#line 208
  trav.stack[22] = (avl_node const   *)0;
#line 208
  trav.stack[23] = (avl_node const   *)0;
#line 208
  trav.stack[24] = (avl_node const   *)0;
#line 208
  trav.stack[25] = (avl_node const   *)0;
#line 208
  trav.stack[26] = (avl_node const   *)0;
#line 208
  trav.stack[27] = (avl_node const   *)0;
#line 208
  trav.stack[28] = (avl_node const   *)0;
#line 208
  trav.stack[29] = (avl_node const   *)0;
#line 208
  trav.stack[30] = (avl_node const   *)0;
#line 208
  trav.stack[31] = (avl_node const   *)0;
#line 211
  if (! mountname) {
#line 212
    return ((grouptree_t *)((void *)0));
  }
  {
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 214
    tmp___0 = avl_traverse(mounttree, & trav);
    }
#line 214
    mount = (mount_t *)tmp___0;
    }
#line 214
    if (! mount) {
#line 214
      goto while_break;
    }
#line 215
    if (mount->name) {
      {
      {
#line 215
      tmp = ice_strcmp(mountname, (char const   *)mount->name);
      }
      }
#line 215
      if (tmp == 0) {
#line 216
        return (mount->grouptree);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  return ((grouptree_t *)((void *)0));
}
}
#line 222 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
void con_display_mounts(com_request_t *req ) 
{ 
  avl_traverser trav ;
  avl_traverser grouptrav ;
  mount_t *mount ;
  group_t *group ;
  int listed ;
  char const   *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 224
  trav.init = 0;
#line 224
  trav.nstack = 0;
#line 224
  trav.p = (avl_node const   *)0;
#line 224
  trav.stack[0] = (avl_node const   *)0;
#line 224
  trav.stack[1] = (avl_node const   *)0;
#line 224
  trav.stack[2] = (avl_node const   *)0;
#line 224
  trav.stack[3] = (avl_node const   *)0;
#line 224
  trav.stack[4] = (avl_node const   *)0;
#line 224
  trav.stack[5] = (avl_node const   *)0;
#line 224
  trav.stack[6] = (avl_node const   *)0;
#line 224
  trav.stack[7] = (avl_node const   *)0;
#line 224
  trav.stack[8] = (avl_node const   *)0;
#line 224
  trav.stack[9] = (avl_node const   *)0;
#line 224
  trav.stack[10] = (avl_node const   *)0;
#line 224
  trav.stack[11] = (avl_node const   *)0;
#line 224
  trav.stack[12] = (avl_node const   *)0;
#line 224
  trav.stack[13] = (avl_node const   *)0;
#line 224
  trav.stack[14] = (avl_node const   *)0;
#line 224
  trav.stack[15] = (avl_node const   *)0;
#line 224
  trav.stack[16] = (avl_node const   *)0;
#line 224
  trav.stack[17] = (avl_node const   *)0;
#line 224
  trav.stack[18] = (avl_node const   *)0;
#line 224
  trav.stack[19] = (avl_node const   *)0;
#line 224
  trav.stack[20] = (avl_node const   *)0;
#line 224
  trav.stack[21] = (avl_node const   *)0;
#line 224
  trav.stack[22] = (avl_node const   *)0;
#line 224
  trav.stack[23] = (avl_node const   *)0;
#line 224
  trav.stack[24] = (avl_node const   *)0;
#line 224
  trav.stack[25] = (avl_node const   *)0;
#line 224
  trav.stack[26] = (avl_node const   *)0;
#line 224
  trav.stack[27] = (avl_node const   *)0;
#line 224
  trav.stack[28] = (avl_node const   *)0;
#line 224
  trav.stack[29] = (avl_node const   *)0;
#line 224
  trav.stack[30] = (avl_node const   *)0;
#line 224
  trav.stack[31] = (avl_node const   *)0;
#line 226
  grouptrav.init = 0;
#line 226
  grouptrav.nstack = 0;
#line 226
  grouptrav.p = (avl_node const   *)0;
#line 226
  grouptrav.stack[0] = (avl_node const   *)0;
#line 226
  grouptrav.stack[1] = (avl_node const   *)0;
#line 226
  grouptrav.stack[2] = (avl_node const   *)0;
#line 226
  grouptrav.stack[3] = (avl_node const   *)0;
#line 226
  grouptrav.stack[4] = (avl_node const   *)0;
#line 226
  grouptrav.stack[5] = (avl_node const   *)0;
#line 226
  grouptrav.stack[6] = (avl_node const   *)0;
#line 226
  grouptrav.stack[7] = (avl_node const   *)0;
#line 226
  grouptrav.stack[8] = (avl_node const   *)0;
#line 226
  grouptrav.stack[9] = (avl_node const   *)0;
#line 226
  grouptrav.stack[10] = (avl_node const   *)0;
#line 226
  grouptrav.stack[11] = (avl_node const   *)0;
#line 226
  grouptrav.stack[12] = (avl_node const   *)0;
#line 226
  grouptrav.stack[13] = (avl_node const   *)0;
#line 226
  grouptrav.stack[14] = (avl_node const   *)0;
#line 226
  grouptrav.stack[15] = (avl_node const   *)0;
#line 226
  grouptrav.stack[16] = (avl_node const   *)0;
#line 226
  grouptrav.stack[17] = (avl_node const   *)0;
#line 226
  grouptrav.stack[18] = (avl_node const   *)0;
#line 226
  grouptrav.stack[19] = (avl_node const   *)0;
#line 226
  grouptrav.stack[20] = (avl_node const   *)0;
#line 226
  grouptrav.stack[21] = (avl_node const   *)0;
#line 226
  grouptrav.stack[22] = (avl_node const   *)0;
#line 226
  grouptrav.stack[23] = (avl_node const   *)0;
#line 226
  grouptrav.stack[24] = (avl_node const   *)0;
#line 226
  grouptrav.stack[25] = (avl_node const   *)0;
#line 226
  grouptrav.stack[26] = (avl_node const   *)0;
#line 226
  grouptrav.stack[27] = (avl_node const   *)0;
#line 226
  grouptrav.stack[28] = (avl_node const   *)0;
#line 226
  grouptrav.stack[29] = (avl_node const   *)0;
#line 226
  grouptrav.stack[30] = (avl_node const   *)0;
#line 226
  grouptrav.stack[31] = (avl_node const   *)0;
#line 230
  listed = 0;
  {
#line 232
  admin_write_line((com_request_t const   *)req, (int const   )437, "Listing mount points in the authentication module:");
  }
  {
#line 234
  thread_mutex_lock_c(& authentication_mutex, 234, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  }
  {
  {
#line 236
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 236
    tmp___1 = avl_traverse(mounttree, & trav);
    }
#line 236
    mount = (mount_t *)tmp___1;
    }
#line 236
    if (! mount) {
#line 236
      goto while_break;
    }
    {
    {
#line 237
    zero_trav(& grouptrav);
    }
    }
#line 239
    if (mount->name) {
#line 239
      tmp = (char const   *)mount->name;
    } else {
#line 239
      tmp = "(null)";
    }
    {
    {
#line 239
    admin_write((com_request_t const   *)req, (int const   )438, "%s: ", tmp);
    }
    }
    {
    {
#line 241
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 241
      tmp___0 = avl_traverse(mount->grouptree, & grouptrav);
      }
#line 241
      group = (group_t *)tmp___0;
      }
#line 241
      if (! group) {
#line 241
        goto while_break___0;
      }
      {
      {
#line 242
      admin_write((com_request_t const   *)req, (int const   )-1, "%s ", group->name);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 243
    admin_write_line((com_request_t const   *)req, (int const   )-1, "");
    }
#line 244
    listed ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 247
  thread_mutex_unlock_c(& authentication_mutex, 247, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  {
#line 249
  admin_write_line((com_request_t const   *)req, (int const   )439, "End of mount point listing (%d listed)",
                   listed);
  }
  }
#line 250
  return;
}
}
#line 252 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
int runtime_add_mount_with_group(char const   *name , char *groups ) 
{ 
  char line[8192] ;
  char *mountfile ;
  char *s ;
  int fd ;
  grouptree_t *tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 258
  if (! name) {
#line 259
    return (-2);
  } else
#line 258
  if (! groups) {
#line 259
    return (-2);
  } else
#line 258
  if (! *(name + 0)) {
#line 259
    return (-2);
  } else
#line 258
  if (! *(groups + 0)) {
#line 259
    return (-2);
  }
  {
  {
#line 261
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 261
    s = strchr((char const   *)groups, ' ');
    }
    }
#line 261
    if (! s) {
#line 261
      goto while_break;
    }
#line 262
    *s = (char )',';
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 267
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s:%s\n",
          name, groups);
  }
  {
#line 270
  thread_mutex_lock_c(& authentication_mutex, 270, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  {
#line 272
  tmp = get_grouptree_for_mount(name);
  }
  }
#line 272
  if (tmp) {
    {
    {
#line 273
    thread_mutex_unlock_c(& authentication_mutex, 273, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
    }
#line 274
    return (-6);
  }
  {
  {
#line 276
  mountfile = get_icecast_file((char const   *)info.mountfile, (filetype_t )1, 2);
  }
  }
#line 278
  if (! mountfile) {
#line 278
    goto _L;
  } else {
    {
    {
#line 278
    fd = open_for_append((char const   *)mountfile);
    }
    }
#line 278
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 279
      if (mountfile) {
        {
        {
#line 280
        n_free((void *)mountfile, (int const   )280, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
        }
        }
      }
      {
#line 280
      mountfile = (char *)((void *)0);
      {
#line 281
      xa_debug(1, (char *)"WARNING: Could not open mount authentication file for writing");
      }
      {
#line 282
      thread_mutex_unlock_c(& authentication_mutex, 282, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
      }
      }
#line 283
      return (-7);
    }
  }
  {
  {
#line 285
  fd_write_line(fd, "%s", line);
  }
  {
#line 286
  fd_close(fd);
  }
  }
#line 287
  if (mountfile) {
    {
    {
#line 288
    n_free((void *)mountfile, (int const   )288, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
    }
  }
  {
#line 288
  mountfile = (char *)((void *)0);
  {
#line 289
  thread_mutex_unlock_c(& authentication_mutex, 289, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  }
#line 290
  return (1);
}
}
#line 293 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c"
int runtime_add_mount(char const   *name ) 
{ 
  char line[8192] ;
  char *mountfile ;
  int fd ;
  grouptree_t *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 299
  if (! name) {
#line 300
    return (-2);
  } else
#line 299
  if (! *(name + 0)) {
#line 300
    return (-2);
  }
  {
  {
#line 304
  sprintf((char */* __restrict  */)(line), (char const   */* __restrict  */)"%s:\n",
          name);
  }
  {
#line 307
  thread_mutex_lock_c(& authentication_mutex, 307, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  {
#line 309
  tmp = get_grouptree_for_mount(name);
  }
  }
#line 309
  if (tmp) {
    {
    {
#line 310
    thread_mutex_unlock_c(& authentication_mutex, 310, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
    }
#line 311
    return (-6);
  }
  {
  {
#line 313
  mountfile = get_icecast_file((char const   *)info.mountfile, (filetype_t )1, 2);
  }
  }
#line 315
  if (! mountfile) {
#line 315
    goto _L;
  } else {
    {
    {
#line 315
    fd = open_for_append((char const   *)mountfile);
    }
    }
#line 315
    if (fd == -1) {
      _L: /* CIL Label */ 
#line 316
      if (mountfile) {
        {
        {
#line 317
        n_free((void *)mountfile, (int const   )317, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
        }
        }
      }
      {
#line 317
      mountfile = (char *)((void *)0);
      {
#line 318
      xa_debug(1, (char *)"WARNING: Could not open mount authentication file for writing");
      }
      {
#line 319
      thread_mutex_unlock_c(& authentication_mutex, 319, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
      }
      }
#line 320
      return (-7);
    }
  }
  {
  {
#line 322
  fd_write_line(fd, "%s", line);
  }
  {
#line 323
  fd_close(fd);
  }
  }
#line 324
  if (mountfile) {
    {
    {
#line 325
    n_free((void *)mountfile, (int const   )325, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
    }
    }
  }
  {
#line 325
  mountfile = (char *)((void *)0);
  {
#line 326
  thread_mutex_unlock_c(& authentication_mutex, 326, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/authenticate/mount.c");
  }
  }
#line 327
  return (1);
}
}
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 225
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigfillset)(sigset_t *__set ) ;
#line 228
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 231
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigdelset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 227 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 236
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 265
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 269
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 272
extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 283
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 292
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                        int __detachstate ) ;
#line 369
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                                      size_t __stacksize ) ;
#line 723
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
#line 728
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 736
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 747
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 99 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.h"
void thread_block_signals(void) ;
#line 104
long thread_new(void) ;
#line 105
long thread_mutex_new(void) ;
#line 77 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
mutex_t library_mutex  =    {-3L, {{0, 0U, 0, 0, 0U, {.__list = {(struct __pthread_internal_slist *)0}}}},
    0L, 0, 0L};
#line 96 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
icethread_t thread_create_c(char *name , void *(*start_routine)(void * ) , void *arg ,
                            int line , char *file ) 
{ 
  icethread_t thread ;
  pthread_attr_t attr ;
  int i ;
  mythread_t *mt ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 105
  tmp = n_malloc((unsigned int const   )sizeof(mythread_t ), (int const   )105, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
  }
#line 105
  mt = (mythread_t *)tmp;
#line 107
  mt->line = line;
  {
#line 108
  mt->file = n_strdup((char const   *)file, (int const   )108, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
  }
  {
#line 110
  internal_lock_mutex(& info.thread_mutex);
  }
  {
#line 111
  mt->id = thread_new();
  }
  {
#line 112
  internal_unlock_mutex(& info.thread_mutex);
  }
  {
#line 114
  mt->name = n_strdup((char const   *)name, (int const   )114, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
  }
  {
#line 115
  mt->created = get_time();
  }
#line 116
  mt->ping = 0;
#line 117
  mt->running = -1;
  {
#line 122
  pthread_attr_init(& attr);
  }
  {
#line 128
  pthread_attr_setstacksize(& attr, (size_t )256000);
  }
#line 134
  i = 0;
  }
  {
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < 10)) {
#line 134
      goto while_break;
    }
    {
    {
#line 140
    tmp___0 = pthread_create((pthread_t */* __restrict  */)(& thread), (pthread_attr_t const   */* __restrict  */)(& attr),
                             start_routine, (void */* __restrict  */)arg);
    }
    }
#line 140
    if (tmp___0 == 0) {
#line 142
      goto while_break;
    } else {
      {
      {
#line 144
      write_log(0, (char *)"ERROR: Could not create new thread, retrying");
      }
      }
    }
#line 134
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 147
  pthread_attr_destroy(& attr);
  }
  }
#line 153
  if (i >= 10) {
    {
    {
#line 155
    write_log(0, (char *)"System won\'t let me create more threads, giving up");
    }
    {
#line 156
    clean_shutdown(& info);
    }
    }
  }
  {
#line 160
  mt->thread = thread;
  {
#line 163
  internal_lock_mutex(& info.thread_mutex);
  }
  {
#line 164
  tmp___1 = avl_insert(info.threads, (void *)mt);
  }
  }
#line 164
  if (tmp___1) {
    {
    {
#line 166
    write_log(0, (char *)"WARNING: Inserting thread resulted in duplicate.. sheit!");
    }
    }
  }
  {
  {
#line 168
  internal_unlock_mutex(& info.thread_mutex);
  }
  {
#line 170
  xa_debug(3, (char *)"DEBUG: Adding thread %d started at [%s:%d]", mt->id, file,
           line);
  }
  {
#line 176
  pthread_detach(thread);
  }
  }
#line 180
  return (mt->thread);
}
}
#line 184 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_create_mutex_nl(mutex_t *mutex ) 
{ 
  char *__cil_tmp2 ;

  {
#line 187
  if (! mutex) {
    {
    {
#line 188
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: thread_create_mutex_nl() called with NULL mutex\n");
    }
    }
#line 189
    return;
  }
  {
#line 192
  mutex->thread_id = -2L;
#line 193
  mutex->lineno = -1;
  {
#line 203
  pthread_mutex_init(& mutex->mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
  }
#line 207
  return;
}
}
#line 209 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_create_mutex_c(mutex_t *mutex , int line , char *file ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 212
  if (! mutex) {
    {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: thread_create_mutex_c() called with NULL mutex\n");
    }
    }
#line 214
    return;
  } else
#line 212
  if (! file) {
    {
    {
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: thread_create_mutex_c() called with NULL mutex\n");
    }
    }
#line 214
    return;
  }
  {
#line 217
  mutex->thread_id = -2L;
#line 218
  mutex->lineno = -1;
  {
#line 228
  pthread_mutex_init(& mutex->mutex, (pthread_mutexattr_t const   *)((void *)0));
  }
  }
#line 239
  return;
}
}
#line 241 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_mutex_destroy(mutex_t *mutex ) 
{ 


  {
  {
  {
#line 248
  pthread_mutex_destroy(& mutex->mutex);
  }
  }
#line 256
  return;
}
}
#line 258 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_mutex_lock_c(mutex_t *mutex , int line , char *file ) 
{ 
  mythread_t *mt ;
  mythread_t *tmp ;
  char name[40] ;
  icethread_t tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 267
  tmp = thread_get_mythread();
  }
#line 267
  mt = tmp;
  }
#line 269
  if (! mt) {
    {
    {
#line 270
    tmp___0 = thread_self();
    }
    {
#line 270
    write_log(0, (char *)"WARNING: No mt record for %u in lock [%s:%d]", tmp___0,
              file, line);
    }
    }
  }
#line 271
  if (mt) {
#line 271
    tmp___1 = mt->id;
  } else {
#line 271
    tmp___1 = -1L;
  }
  {
  {
#line 271
  tmp___2 = mutex_to_string(mutex, name);
  }
  {
#line 271
  xa_debug(5, (char *)"Locking %p (%s) on line %d in file %s by thread %d", mutex,
           tmp___2, line, file, tmp___1);
  }
  {
#line 309
  internal_lock_mutex(mutex);
  }
  }
#line 315
  if (mt) {
#line 315
    tmp___3 = mt->id;
  } else {
#line 315
    tmp___3 = -1L;
  }
  {
  {
#line 315
  xa_debug(5, (char *)"Locked %p by thread %d", mutex, tmp___3);
  }
#line 316
  mutex->lineno = line;
  }
#line 317
  if (mt) {
#line 318
    mutex->thread_id = mt->id;
  }
#line 325
  return;
}
}
#line 327 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_mutex_unlock_c(mutex_t *mutex , int line , char *file ) 
{ 
  mythread_t *mt ;
  mythread_t *tmp ;
  char name[40] ;
  icethread_t tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 336
  tmp = thread_get_mythread();
  }
#line 336
  mt = tmp;
  }
#line 338
  if (! mt) {
    {
    {
#line 339
    tmp___0 = thread_self();
    }
    {
#line 339
    write_log(0, (char *)"WARNING: No mt record for %u in unlock [%s:%d]", tmp___0,
              file, line);
    }
    }
  }
#line 340
  if (mt) {
#line 340
    tmp___1 = mt->id;
  } else {
#line 340
    tmp___1 = -1L;
  }
  {
  {
#line 340
  tmp___2 = mutex_to_string(mutex, name);
  }
  {
#line 340
  xa_debug(5, (char *)"Unlocking %p (%s) on line %d in file %s by thread %d", mutex,
           tmp___2, line, file, tmp___1);
  }
#line 341
  mutex->lineno = line;
  {
#line 375
  internal_unlock_mutex(mutex);
  }
  }
#line 381
  if (mt) {
#line 381
    tmp___3 = mt->id;
  } else {
#line 381
    tmp___3 = -1L;
  }
  {
  {
#line 381
  xa_debug(5, (char *)"Unlocked %p by thread %d", mutex, tmp___3);
  }
#line 382
  mutex->lineno = -1;
  }
#line 383
  if (mt) {
#line 383
    if (mutex->thread_id == mt->id) {
#line 384
      mutex->thread_id = -1L;
    }
  }
#line 390
  return;
}
}
#line 392 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_exit_c(long val , int line , char *file ) 
{ 
  mythread_t *out ;
  mythread_t *mt ;
  mythread_t *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 395
  tmp = thread_get_mythread();
  }
#line 395
  mt = tmp;
  }
#line 415
  if (mt) {
    {
    {
#line 416
    xa_debug(2, (char *)"DEBUG: Removing thread %d started at [%s:%d], reason: \'Thread Exited\'",
             mt->id, mt->file, mt->line);
    }
    {
#line 418
    internal_lock_mutex(& info.thread_mutex);
    }
    {
#line 419
    tmp___0 = avl_delete(info.threads, (void const   *)mt);
    }
#line 419
    out = (mythread_t *)tmp___0;
    {
#line 420
    internal_unlock_mutex(& info.thread_mutex);
    }
    }
#line 422
    if (out) {
#line 423
      if (out->id == 0L) {
#line 425
        if (out->file) {
          {
          {
#line 426
          free((void *)out->file);
          }
          }
        }
#line 427
        if (out->name) {
          {
          {
#line 428
          free((void *)out->name);
          }
          }
        }
#line 429
        if (out) {
          {
          {
#line 430
          free((void *)out);
          }
          }
        }
      } else {
        {
        {
#line 435
        n_free((void *)out->file, (int const   )435, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
        }
#line 435
        out->file = (char *)((void *)0);
        {
#line 436
        n_free((void *)out->name, (int const   )436, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
        }
#line 436
        out->name = (char *)((void *)0);
        {
#line 437
        n_free((void *)out, (int const   )437, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
        }
#line 437
        out = (mythread_t *)((void *)0);
        }
      }
    }
  }
  {
  {
#line 445
  pthread_exit((void *)val);
  }
  }
}
}
#line 454 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_block_signals(void) 
{ 
  sigset_t ss ;
  int tmp ;

  {
  {
  {
#line 460
  sigfillset(& ss);
  }
  {
#line 463
  sigdelset(& ss, 9);
  }
  {
#line 464
  sigdelset(& ss, 19);
  }
  {
#line 465
  sigdelset(& ss, 15);
  }
  {
#line 466
  sigdelset(& ss, 11);
  }
  {
#line 467
  sigdelset(& ss, 7);
  }
  {
#line 468
  tmp = pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& ss), (__sigset_t */* __restrict  */)((void *)0));
  }
  }
#line 474
  return;
}
}
#line 479 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_catch_signals(void) 
{ 
  sigset_t ss ;
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 485
  sigemptyset(& ss);
  }
  {
#line 488
  sigaddset(& ss, 1);
  }
  {
#line 489
  sigaddset(& ss, 17);
  }
  {
#line 490
  sigaddset(& ss, 2);
  }
  {
#line 492
  sigaddset(& ss, 13);
  }
  {
#line 495
  tmp = pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& ss), (__sigset_t */* __restrict  */)((void *)0));
  }
  }
#line 495
  if (tmp != 0) {
    {
    {
#line 496
    write_log(0, (char *)"WARNING: pthread_sigmask() failed!");
    }
    }
  }
#line 498
  return;
}
}
#line 500 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_init(void) 
{ 
  mythread_t *mt ;
  mythread_t *tmp ;
  int max ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
  {
#line 503
  tmp = thread_check_created();
  }
#line 503
  mt = tmp;
#line 504
  max = 600;
  {
#line 506
  thread_block_signals();
  }
  }
  {
  {
#line 508
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 508
    if (! mt) {
#line 508
      if (! (max > 0)) {
#line 508
        goto while_break;
      }
    } else {
#line 508
      goto while_break;
    }
    {
    {
#line 510
    my_sleep(40000);
    }
    {
#line 511
    mt = thread_check_created();
    }
#line 512
    max --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if (max == 0) {
    {
    {
#line 517
    log_no_thread(1, (char *)"DEBUG: Thread never made it to life.. weird");
    }
    {
#line 518
    thread_exit_c(13L, 518, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
    }
    }
  } else
#line 515
  if (! mt) {
    {
    {
#line 517
    log_no_thread(1, (char *)"DEBUG: Thread never made it to life.. weird");
    }
    {
#line 518
    thread_exit_c(13L, 518, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
    }
    }
  }
#line 521
  if (mt) {
#line 522
    mt->running = 1;
  }
#line 523
  return;
}
}
#line 525 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
icethread_t thread_self(void) 
{ 
  pthread_t tmp ;

  {
  {
  {
#line 530
  tmp = pthread_self();
  }
  }
#line 530
  return (tmp);
}
}
#line 534 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
int thread_equal(icethread_t t1 , icethread_t t2 ) 
{ 
  int tmp ;

  {
  {
  {
#line 540
  tmp = pthread_equal(t1, t2);
  }
  }
#line 540
  return (tmp);
}
}
#line 544 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
long thread_new(void) 
{ 


  {
#line 547
  (info.threadid) ++;
#line 548
  return (info.threadid);
}
}
#line 551 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
long thread_mutex_new(void) 
{ 


  {
#line 554
  (info.mutexid) ++;
#line 555
  return (info.mutexid);
}
}
#line 558 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
mythread_t *thread_get_mythread(void) 
{ 
  avl_traverser trav ;
  mythread_t *mt ;
  icethread_t t ;
  icethread_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 561
  trav.init = 0;
#line 561
  trav.nstack = 0;
#line 561
  trav.p = (avl_node const   *)0;
#line 561
  trav.stack[0] = (avl_node const   *)0;
#line 561
  trav.stack[1] = (avl_node const   *)0;
#line 561
  trav.stack[2] = (avl_node const   *)0;
#line 561
  trav.stack[3] = (avl_node const   *)0;
#line 561
  trav.stack[4] = (avl_node const   *)0;
#line 561
  trav.stack[5] = (avl_node const   *)0;
#line 561
  trav.stack[6] = (avl_node const   *)0;
#line 561
  trav.stack[7] = (avl_node const   *)0;
#line 561
  trav.stack[8] = (avl_node const   *)0;
#line 561
  trav.stack[9] = (avl_node const   *)0;
#line 561
  trav.stack[10] = (avl_node const   *)0;
#line 561
  trav.stack[11] = (avl_node const   *)0;
#line 561
  trav.stack[12] = (avl_node const   *)0;
#line 561
  trav.stack[13] = (avl_node const   *)0;
#line 561
  trav.stack[14] = (avl_node const   *)0;
#line 561
  trav.stack[15] = (avl_node const   *)0;
#line 561
  trav.stack[16] = (avl_node const   *)0;
#line 561
  trav.stack[17] = (avl_node const   *)0;
#line 561
  trav.stack[18] = (avl_node const   *)0;
#line 561
  trav.stack[19] = (avl_node const   *)0;
#line 561
  trav.stack[20] = (avl_node const   *)0;
#line 561
  trav.stack[21] = (avl_node const   *)0;
#line 561
  trav.stack[22] = (avl_node const   *)0;
#line 561
  trav.stack[23] = (avl_node const   *)0;
#line 561
  trav.stack[24] = (avl_node const   *)0;
#line 561
  trav.stack[25] = (avl_node const   *)0;
#line 561
  trav.stack[26] = (avl_node const   *)0;
#line 561
  trav.stack[27] = (avl_node const   *)0;
#line 561
  trav.stack[28] = (avl_node const   *)0;
#line 561
  trav.stack[29] = (avl_node const   *)0;
#line 561
  trav.stack[30] = (avl_node const   *)0;
#line 561
  trav.stack[31] = (avl_node const   *)0;
  {
#line 563
  tmp = thread_self();
  }
#line 563
  t = tmp;
  {
#line 565
  internal_lock_mutex(& info.thread_mutex);
  }
  }
#line 567
  if ((unsigned long )info.threads == (unsigned long )((void *)0)) {
    {
    {
#line 569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Thread tree is empty, this must be wrong!");
    }
    {
#line 570
    internal_unlock_mutex(& info.thread_mutex);
    }
    }
#line 571
    return ((mythread_t *)((void *)0));
  }
  {
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 574
    tmp___1 = avl_traverse(info.threads, & trav);
    }
#line 574
    mt = (mythread_t *)tmp___1;
    }
#line 574
    if (! mt) {
#line 574
      goto while_break;
    }
    {
    {
#line 575
    tmp___0 = thread_equal(t, mt->thread);
    }
    }
#line 575
    if (tmp___0) {
      {
      {
#line 576
      internal_unlock_mutex(& info.thread_mutex);
      }
      }
#line 577
      return (mt);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 580
  internal_unlock_mutex(& info.thread_mutex);
  }
  {
#line 581
  write_log(0, (char *)"WARNING: Nonexistant thread alive...");
  }
  }
#line 582
  return ((mythread_t *)((void *)0));
}
}
#line 585 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
mythread_t *thread_check_created(void) 
{ 
  avl_traverser trav ;
  mythread_t *mt ;
  icethread_t t ;
  icethread_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 588
  trav.init = 0;
#line 588
  trav.nstack = 0;
#line 588
  trav.p = (avl_node const   *)0;
#line 588
  trav.stack[0] = (avl_node const   *)0;
#line 588
  trav.stack[1] = (avl_node const   *)0;
#line 588
  trav.stack[2] = (avl_node const   *)0;
#line 588
  trav.stack[3] = (avl_node const   *)0;
#line 588
  trav.stack[4] = (avl_node const   *)0;
#line 588
  trav.stack[5] = (avl_node const   *)0;
#line 588
  trav.stack[6] = (avl_node const   *)0;
#line 588
  trav.stack[7] = (avl_node const   *)0;
#line 588
  trav.stack[8] = (avl_node const   *)0;
#line 588
  trav.stack[9] = (avl_node const   *)0;
#line 588
  trav.stack[10] = (avl_node const   *)0;
#line 588
  trav.stack[11] = (avl_node const   *)0;
#line 588
  trav.stack[12] = (avl_node const   *)0;
#line 588
  trav.stack[13] = (avl_node const   *)0;
#line 588
  trav.stack[14] = (avl_node const   *)0;
#line 588
  trav.stack[15] = (avl_node const   *)0;
#line 588
  trav.stack[16] = (avl_node const   *)0;
#line 588
  trav.stack[17] = (avl_node const   *)0;
#line 588
  trav.stack[18] = (avl_node const   *)0;
#line 588
  trav.stack[19] = (avl_node const   *)0;
#line 588
  trav.stack[20] = (avl_node const   *)0;
#line 588
  trav.stack[21] = (avl_node const   *)0;
#line 588
  trav.stack[22] = (avl_node const   *)0;
#line 588
  trav.stack[23] = (avl_node const   *)0;
#line 588
  trav.stack[24] = (avl_node const   *)0;
#line 588
  trav.stack[25] = (avl_node const   *)0;
#line 588
  trav.stack[26] = (avl_node const   *)0;
#line 588
  trav.stack[27] = (avl_node const   *)0;
#line 588
  trav.stack[28] = (avl_node const   *)0;
#line 588
  trav.stack[29] = (avl_node const   *)0;
#line 588
  trav.stack[30] = (avl_node const   *)0;
#line 588
  trav.stack[31] = (avl_node const   *)0;
  {
#line 590
  tmp = thread_self();
  }
#line 590
  t = tmp;
  {
#line 592
  internal_lock_mutex(& info.thread_mutex);
  }
  }
#line 594
  if ((unsigned long )info.threads == (unsigned long )((void *)0)) {
    {
    {
#line 596
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Thread tree is empty, this must be wrong!");
    }
    }
#line 597
    return ((mythread_t *)((void *)0));
  }
  {
  {
#line 600
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 600
    tmp___1 = avl_traverse(info.threads, & trav);
    }
#line 600
    mt = (mythread_t *)tmp___1;
    }
#line 600
    if (! mt) {
#line 600
      goto while_break;
    }
    {
    {
#line 601
    tmp___0 = thread_equal(t, mt->thread);
    }
    }
#line 601
    if (tmp___0) {
      {
      {
#line 602
      internal_unlock_mutex(& info.thread_mutex);
      }
      }
#line 603
      return (mt);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 606
  internal_unlock_mutex(& info.thread_mutex);
  }
  }
#line 607
  return ((mythread_t *)((void *)0));
}
}
#line 610 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_rename(char const   *name ) 
{ 
  mythread_t *mt ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 615
  if ((unsigned long )info.threads == (unsigned long )((void *)0)) {
#line 615
    return;
  }
  {
  {
#line 617
  mt = thread_get_mythread();
  }
  }
#line 618
  if (mt->name) {
    {
    {
#line 620
    n_free((void *)mt->name, (int const   )620, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
    }
#line 620
    mt->name = (char *)((void *)0);
    }
  }
  {
  {
#line 622
  mt->name = n_strdup(name, (int const   )622, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
  }
  }
#line 623
  return;
}
}
#line 625 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void internal_lock_mutex(mutex_t *mutex ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 627
  if (! mutex) {
    {
    {
#line 628
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: internal_lock_mutex() called with NULL pointer!");
    }
    }
  }
  {
  {
#line 634
  tmp = pthread_mutex_lock(& mutex->mutex);
  }
  }
  {
#line 635
  if (tmp == 22) {
#line 635
    goto case_22;
  }
#line 634
  goto switch_break;
  case_22: /* CIL Label */ 
  {
  {
#line 636
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Locking unitialized mutex\n");
  }
  }
#line 637
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 645
  return;
}
}
#line 647 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void internal_unlock_mutex(mutex_t *mutex ) 
{ 
  int tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 652
  tmp = pthread_mutex_unlock(& mutex->mutex);
  }
  }
  {
#line 653
  if (tmp == 22) {
#line 653
    goto case_22;
  }
#line 652
  goto switch_break;
  case_22: /* CIL Label */ 
  {
  {
#line 654
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Unlocking unitialized mutex\n");
  }
  }
#line 655
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 663
  return;
}
}
#line 665 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_lib_init(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 667
  info.mutexes = (avl_tree *)((void *)0);
#line 668
  info.mutexid = 0L;
  {
#line 670
  info.mutexes = avl_create_nl(& compare_mutexes, (void *)(& info));
  }
  {
#line 671
  thread_create_mutex_nl(& info.mutex_mutex);
  }
  {
#line 672
  thread_create_mutex_c(& library_mutex, 672, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c");
  }
  }
#line 673
  return;
}
}
#line 675 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_library_lock(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 678
  if (! (library_mutex.thread_id != -3L)) {
    {
    {
#line 678
    __assert_fail("library_mutex.thread_id != -3", "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c",
                  678U, "thread_library_lock");
    }
    }
  }
  {
  {
#line 679
  internal_lock_mutex(& library_mutex);
  }
  }
#line 680
  return;
}
}
#line 682 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_library_unlock(void) 
{ 


  {
  {
  {
#line 684
  internal_unlock_mutex(& library_mutex);
  }
  }
#line 685
  return;
}
}
#line 687 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_setup_default_attributes(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 691
  tmp = pthread_attr_init(& info.defaultattr);
  }
  }
#line 691
  if (tmp != 0) {
    {
    {
#line 692
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: pthread_attr_init() failed!\n");
    }
    }
  }
  {
  {
#line 693
  tmp___0 = pthread_attr_setdetachstate(& info.defaultattr, 1);
  }
  }
#line 693
  if (tmp___0 != 0) {
    {
    {
#line 694
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: pthread_attr_setdetachstate() failed!\n");
    }
    }
  }
#line 696
  return;
}
}
#line 698 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
int thread_alive(mythread_t *mt ) 
{ 


  {
#line 701
  if (mt->running != 1) {
#line 702
    return (0);
  }
#line 703
  return (1);
}
}
#line 706 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/threads.c"
void thread_wait_for_solitude(void) 
{ 
  int max ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 709
  max = 300;
  {
#line 711
  tmp = avl_count((avl_tree const   *)info.threads);
  }
  }
#line 711
  if (tmp <= 1) {
#line 712
    return;
  }
  {
  {
#line 714
  write_log(0, (char *)"Waiting a wee while to let the other threads die..");
  }
  }
  {
  {
#line 716
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 718
    internal_lock_mutex(& info.thread_mutex);
    }
    {
#line 719
    tmp___0 = avl_count((avl_tree const   *)info.threads);
    }
    }
#line 719
    if (tmp___0 <= 1) {
      {
      {
#line 720
      write_log(0, (char *)"Ahhh, finally alone");
      }
      {
#line 721
      internal_unlock_mutex(& info.thread_mutex);
      }
      }
#line 722
      return;
    }
    {
    {
#line 724
    internal_unlock_mutex(& info.thread_mutex);
    }
#line 726
    max --;
    {
#line 728
    my_sleep(3000);
    }
    }
#line 716
    if (! (max >= 0)) {
#line 716
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 731
  tmp___3 = avl_count((avl_tree const   *)info.threads);
  }
  }
#line 731
  if (tmp___3 > 2) {
#line 731
    tmp___2 = "buggers";
  } else {
#line 731
    tmp___2 = "bugger";
  }
  {
  {
#line 731
  tmp___4 = avl_count((avl_tree const   *)info.threads);
  }
  {
#line 731
  write_log(0, (char *)"Ok, that\'s enough, let\'s kill the remaining %d %s", tmp___4 - 1,
            tmp___2);
  }
  }
#line 732
  return;
}
}
#line 145 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 43 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.h"
int com_help(com_request_t *req ) ;
#line 43
int com_oper(com_request_t *req ) ;
#line 43
int com_quit(com_request_t *req ) ;
#line 43
int com_status(com_request_t *req ) ;
#line 43
int com_ping(com_request_t *req ) ;
#line 43
int com_debug(com_request_t *req ) ;
#line 43
int com_scheme(com_request_t *req ) ;
#line 43
int com_resolv(com_request_t *req ) ;
#line 43
int com_sock(com_request_t *req ) ;
#line 43
int com_run(com_request_t *req ) ;
#line 55
void show_settings(com_request_t *req ) ;
#line 62
void move_id_to(com_request_t *req , int id , int newsourceid ) ;
#line 63
void move_all_from(com_request_t *req , int sourceid , int targetid ) ;
#line 64
void move_all_matching(com_request_t *req , int sourceid , char *arg ) ;
#line 66
avl_tree *get_acl_tree(char *type ) ;
#line 69
void change_special_variable(com_request_t *req , set_element *s , char *variable_name ,
                             char *argument ) ;
#line 70
int is_special_variable(char *variable_name ) ;
#line 71
void change_variable(com_request_t *req , set_element *s , char *argument , char *arg ) ;
#line 73
int com_auth_del(com_request_t *req , char *arg ) ;
#line 74
int com_auth_list(com_request_t *req , char *arg ) ;
#line 75
int com_auth_add(com_request_t *req , char *arg ) ;
#line 40 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
void describe_client(com_request_t const   *req , connection_t const   *clicon ) ;
#line 41
char const   *client_type(connection_t const   *clicon ) ;
#line 108 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) struct mallinfo mallinfo(void) ;
#line 103 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void zero_opts(int *opt , int maxelements ) ;
#line 104
static void set_opts(int *opt , char const   *arg , conopt_t *opts , int maxelements ) ;
#line 107 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
comp_element commands[44]  = 
#line 107
  {      {(char *)"alias", & com_alias, (char *)"Add an alias for a mount point", 1, (char *)"alias <add|del|list> [newmountpoint] [mountpoint] or [newmountpoint] [http://server:port/mountpoint]\r\n\tMakes mountpoint available on 2 places\r\n"}, 
        {(char *)"allow",
      & com_allow, (char *)"Add hostmask for allowed host", 1, (char *)"allow <client|source|admin|all> <add|del|list> [hostmask]\r\n\tAdd, delete or list allowed hostmasks\r\n"}, 
        {(char *)"deny",
      & com_deny, (char *)"Add hostmask for denied host", 1, (char *)"deny <client|source|admin|all> <add|del|list> [hostmask]\r\n\tAdd, delete or list denied hostmasks\r\n"}, 
        {(char *)"acl",
      & com_acl, (char *)"List all access controls", 1, (char *)"acl\r\n\tList all access controls\r\n"}, 
        {(char *)"admins",
      & com_admins, (char *)"Show all connected admins", 0, (char *)"admins [pattern]\r\n\tDisplays all admins matching pattern, or all just all admins if no pattern is specified\r\n"}, 
        {(char *)"dir",
      & com_dir, (char *)"Add, delete or remove directory servers", 1, (char *)"dir [add|delete|list]\r\n\tadd host[:port[/path] [icy]], del <host>, or list all directory servers\r\n"}, 
        {(char *)"dump",
      & com_dump, (char *)"Dump a source to a specified file", 1, (char *)"dump <sourceid> <filename|close>\r\n\tDump source with id <sourceid> to a file specified with filename, or stop dumping if the filename is \"close\".\r\n"}, 
        {(char *)"help",
      & com_help, (char *)"Display this text", 0, (char *)"help <command>\r\n\tDisplay general help, or help for a specific command.\r\n"}, 
        {(char *)"kick",
      & com_kick, (char *)"Kick client, admin, or source", 1, (char *)"kick <options> <pattern|id>\r\n\t-c for clients, -a for admins, -s for sources, kicks specified pattern or id.\r\n"}, 
        {(char *)"listeners",
      & com_listeners, (char *)"Show connected listeners", 0, (char *)"listeners <pattern>\r\n\tDisplay all listeners matching pattern, or all listeners if no pattern is specified\r\n"}, 
        {(char *)"modify",
      & com_modify, (char *)"Change the audiocast data for a source", 1, (char *)"modify <source_id> <-mungdPpb> <argument>\r\n\tModify a audiocast field for the specified source\r\n"}, 
        {(char *)"oper",
      & com_oper, (char *)"Obtain operator privileges", 0, (char *)"oper <password>\r\n\tIf correct password is specified, makes you a icecast operator and grants access to the operator commands\r\n"}, 
        {(char *)"pause",
      & com_pause, (char *)"Put a client or source on hold", 1, (char *)"pause <client_id|source_id>\r\n\tEither pause a client (cutting the data), or a source (no data to its clients)\r\n"}, 
        {(char *)"quit",
      & com_quit, (char *)"Leave remote admin console", 0, (char *)"quit <message>\r\n\tLeaves the remote admin console with message displayed for all other admins.\r\n"}, 
        {(char *)"rehash",
      & com_rehash, (char *)"Parse the config file", 1, (char *)"rehash <configfile>\r\n\tOpen and parse the configfile, or the default configfile if not specified.\r\n"}, 
        {(char *)"select",
      & com_sel, (char *)"Select encoder for clients", 1, (char *)"select <options> <sid> [pattern] <tid>\r\n\tEither select -a <sourceid> <targetid>, which moves all clients from sourceid to targetid. Or select -p <sourceid> <pattern> <targetid>, which moves all clients matching pattern from sourceid to targetid. Or select <clientid> <targetsourceid>, which moves client with id clientid to source with id targetsourceid.\r\n"}, 
        {(char *)"sources",
      & com_sources, (char *)"Show connected encoders", 0, (char *)"sources [pattern] [options]\r\n\tShow connected sources matching pattern, or all sources if no pattern is specified.\r\n"}, 
        {(char *)"shutdown",
      & com_shutdown, (char *)"Shutdown the server", 1, (char *)"shutdown <message>\r\n\tShutdown server, display message to all connected admins.\r\n"}, 
        {(char *)"set",
      & com_set, (char *)"Set <var> to <arg>", 1, (char *)"set [variable] [argument]\r\n\tIf both variable and argument, set variable to argument. If just variable, show current setting. If just set, then show all current settings.\r\n"}, 
        {(char *)"stats",
      & com_stats, (char *)"Show server statistics", 0, (char *)"stats <daily|hourly|clear>\r\n\tShow current server statistics, averages, uptime, etc.  Argument is optional - either gives daily stats, hourly stats, or clears all stats\r\n"}, 
        {(char *)"tail",
      & com_tail, (char *)"Start tailing the logfile", 0, (char *)"tail\r\n\tIntercept icecast server log messages.\r\n"}, 
        {(char *)"tell",
      & com_tell, (char *)"Tell other admins", 0, (char *)"tell <message>\r\n\tDisplay message for all connected admins.\r\n"}, 
        {(char *)"touch",
      & com_touch, (char *)"Touch the directory server", 1, (char *)"touch\r\n\tForce all directory servers to be touched now.\r\n"}, 
        {(char *)"unpause",
      & com_unpause, (char *)"Unpause a client or source", 1, (char *)"unpause <client_id|source_id>\r\n\tRemove a lock on a client or source, making it run like normal again\r\n."}, 
        {(char *)"untail",
      & com_untail, (char *)"Stop tailing the logfile", 0, (char *)"untail\r\n\tDon\'t display logfile messages.\r\n"}, 
        {(char *)"uptime",
      & com_uptime, (char *)"Show server uptime", 0, (char *)"uptime\r\n\tShow icecast server version and uptime.\r\n"}, 
        {(char *)"list",
      & com_list, (char *)"List all current connections", 0, (char *)"list <pattern>\r\n\tList all connections matching pattern, or all connections if no pattern is specified.\r\n"}, 
        {(char *)"relay",
      & com_relay, (char *)"Pull or push a server relay", 1, (char *)"relay <push <id> <host[:port]> <options> | pull <url>>\r\n\tEither (push) relay a connected source to a remote server, or (pull) relay a source from a remove server.\r\n"}, 
        {(char *)"threads",
      & com_threads, (char *)"Show all program threads", 0, (char *)"threads\r\n\tDisplay all the currently running threads in the program, and where and when they were created.\r\n"}, 
        {(char *)"locks",
      & com_locks, (char *)"Show status of all locks", 0, (char *)"locks\r\n\tDisplay all mutexes, and their status.\r\n"}, 
        {(char *)"status",
      & com_status, (char *)"Turn status info on/off (for you)", 0, (char *)"status [on|off|show]\r\n\tTurn on or off the periodic status information line.\r\n"}, 
        {(char *)"debug",
      & com_debug, (char *)"Set debugging output level for this connection.", 0, (char *)"debug <integer>\r\n\tSets debugging level. Higher value is more debugging output.\r\n"}, 
        {(char *)"mem",
      & com_mem, (char *)"Another debug function, shows mem usage.", 0, (char *)"mem\r\n\tShows all alloced addresses.\r\n"}, 
        {(char *)"streamtitle",
      & com_streamtitle, (char *)"Set and/or lock streamtitle for a source.", 0, (char *)"streamtitle <-a|sourceid> <message>\r\n\tSets and/or locks the stream title for source or [-a] all sources.\r\n"}, 
        {(char *)"streamurl",
      & com_streamurl, (char *)"Set and/or lock streamurl for a source.", 0, (char *)"streamurl [-a] [sourceid] <message>\r\n\tSets the stream url for source or [-a] all sources.\r\n"}, 
        {(char *)"describe",
      & com_describe, (char *)"Show detailed view on a connection.", 0, (char *)"describe <id>\r\n\tDisplay all information available for the specified connection id.\r\n"}, 
        {(char *)"auth",
      & com_auth, (char *)"Show authorization groups, users, or mountpoints.", 0,
      (char *)"auth <groups|users|mounts>\r\n\tList all authentication entries for users, groups or mounts.\r\n"}, 
        {(char *)"scheme",
      & com_scheme, (char *)"Change output format.", 0, (char *)"scheme <default|html|tagged>\r\n\tChange the output format for all admin commands.\r\n"}, 
        {(char *)"server_info",
      & com_runtime, (char *)"Display runtime information.", 0, (char *)"server_info\r\n\tDisplay information about server only available at runtime.\r\n"}, 
        {(char *)"resolv",
      & com_resolv, (char *)"Resolv given ip or hostname.", 0, (char *)"resolv <hostname|ip>\r\n\tResolv hostname/ip.\r\n"}, 
        {(char *)"ping",
      & com_ping, (char *)"Connect to given icecast server and check if it\'s alive.",
      0, (char *)"ping <server[:port]>\r\n\tConnect to icecast server and check if it is up.\r\n"}, 
        {(char *)"sock",
      & com_sock, (char *)"List or close sockets.", 1, (char *)"sock <list|close> [sock]\r\n\tList all sockets or close a given socket descriptor.\r\n"}, 
        {(char *)"run",
      & com_run, (char *)"Let interpreter run a file.", 1, (char *)"run <filename>\r\n\tEvaluate the file with the interpreter.\r\n"}, 
        {(char *)((void *)0),
      (icecast_function *)((void *)0), (char *)((void *)0), 0, (char *)0}};
#line 193 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
set_element admin_settings[44]  = 
#line 193
  {      {(char *)"encoder_password", (type_t )2, (char *)"The encoder password", (void *)0}, 
        {(char *)"client_password",
      (type_t )2, (char *)"<unimplemented> Client password", (void *)0}, 
        {(char *)"admin_password", (type_t )2, (char *)"The remote admin password", (void *)0}, 
        {(char *)"oper_password",
      (type_t )2, (char *)"Operator Password", (void *)0}, 
        {(char *)"touch_freq", (type_t )0, (char *)"Touch frequency", (void *)0}, 
        {(char *)"client_timeout", (type_t )0, (char *)"When to kick out clients", (void *)0}, 
        {(char *)"max_clients",
      (type_t )0, (char *)"How many listeners to let in", (void *)0}, 
        {(char *)"max_clients_per_source", (type_t )0, (char *)"Max number of clients per source",
      (void *)0}, 
        {(char *)"max_sources", (type_t )0, (char *)"How many sources to let in", (void *)0}, 
        {(char *)"max_admins",
      (type_t )0, (char *)"How many admins to let in", (void *)0}, 
        {(char *)"reverse", (type_t )0, (char *)"Whether to reverse ip:s to hostnames",
      (void *)0}, 
        {(char *)"location", (type_t )2, (char *)"Icecast server geographical location",
      (void *)0}, 
        {(char *)"rp_email", (type_t )2, (char *)"Resposible person email", (void *)0}, 
        {(char *)"transparent_proxy",
      (type_t )0, (char *)"Whether to act as transparent proxy", (void *)0}, 
        {(char *)"stats_log", (type_t )2, (char *)"File for dumping periodic stats",
      (void *)0}, 
        {(char *)"statshtml_log", (type_t )2, (char *)"File for dumping periodic stats in html format",
      (void *)0}, 
        {(char *)"stats_time", (type_t )0, (char *)"How often to write to the stats logfile, in seconds",
      (void *)0}, 
        {(char *)"acl_policy", (type_t )0, (char *)"Whether to allow (1), or deny (0) by default",
      (void *)0}, 
        {(char *)"throttle", (type_t )1, (char *)"At what bandwidth usage (MB/s) do we deny access?",
      (void *)0}, 
        {(char *)"kick_relays", (type_t )0, (char *)"Kick relays after how many seconds without listeners? (0 means keep forever)",
      (void *)0}, 
        {(char *)"kick_clients", (type_t )0, (char *)"0 means move clients to default source when their source dies, 1 means kick them out",
      (void *)0}, 
        {(char *)"status_time", (type_t )0, (char *)"Seconds between status line updates",
      (void *)0}, 
        {(char *)"logfiledebuglevel", (type_t )0, (char *)"Debug level for logfile output",
      (void *)0}, 
        {(char *)"consoledebuglevel", (type_t )0, (char *)"Debug level for console output",
      (void *)0}, 
        {(char *)"server_url", (type_t )2, (char *)"URL for this icecast server", (void *)0}, 
        {(char *)"use_meta_data",
      (type_t )0, (char *)"Whether to include metadata in the stream", (void *)0}, 
        {(char *)"streamurllock",
      (type_t )0, (char *)"Whether or not to allow sources to change the stream url",
      (void *)0}, 
        {(char *)"streamurl", (type_t )2, (char *)"Server global stream url", (void *)0}, 
        {(char *)"streamtitletemplate",
      (type_t )2, (char *)"Template string for stream title string", (void *)0}, 
        {(char *)"nametemplate", (type_t )2, (char *)"Template string for stream name",
      (void *)0}, 
        {(char *)"desctemplate", (type_t )2, (char *)"Template string for description template",
      (void *)0}, 
        {(char *)"logfile", (type_t )2, (char *)"Main logfile", (void *)0}, 
        {(char *)"accessfile", (type_t )2, (char *)"Access logfile", (void *)0}, 
        {(char *)"usagefile", (type_t )2, (char *)"Usage logfile", (void *)0}, 
        {(char *)"staticdir", (type_t )2, (char *)"Directory for static files", (void *)0}, 
        {(char *)"default_source_options",
      (type_t )2, (char *)"Default options to \'sources\'", (void *)0}, 
        {(char *)"mount_fallback", (type_t )0, (char *)"Fallback to default mount (1 yes, 0 no)",
      (void *)0}, 
        {(char *)"force_servername", (type_t )0, (char *)"Force use of server_name on directory server",
      (void *)0}, 
        {(char *)"resolv_type", (type_t )0, (char *)"Type of resolv function to use. 1 is linux reentrant, 2 is solaris reentrant, 3 is standard nonreentrant",
      (void *)0}, 
        {(char *)"http_admin", (type_t )0, (char *)"Whether to allow admins on the WWW interface. 1 is yes, 0 means no",
      (void *)0}, 
        {(char *)"relay_reconnect_max", (type_t )0, (char *)"How many times to try reconnecting a relay, -1 means forever",
      (void *)0}, 
        {(char *)"relay_reconnect_time", (type_t )0, (char *)"Seconds to wait between reconnects",
      (void *)0}, 
        {(char *)"sleep_ratio", (type_t )1, (char *)"Ratio that affects source sleep time. Larger value means sleep more (normal values (0.0 - 1.0)",
      (void *)0}, 
        {(char *)((void *)0), (type_t )0, (char *)((void *)0), (void *)0}};
#line 242 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void setup_admin_settings(void) 
{ 
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 245
  x = 0;
#line 247
  tmp = x;
#line 247
  x ++;
#line 247
  admin_settings[tmp].setting = (void *)(& info.encoder_pass);
#line 248
  tmp___0 = x;
#line 248
  x ++;
#line 248
  admin_settings[tmp___0].setting = (void *)(& info.client_pass);
#line 249
  tmp___1 = x;
#line 249
  x ++;
#line 249
  admin_settings[tmp___1].setting = (void *)(& info.remote_admin_pass);
#line 250
  tmp___2 = x;
#line 250
  x ++;
#line 250
  admin_settings[tmp___2].setting = (void *)(& info.oper_pass);
#line 251
  tmp___3 = x;
#line 251
  x ++;
#line 251
  admin_settings[tmp___3].setting = (void *)(& info.touch_freq);
#line 252
  tmp___4 = x;
#line 252
  x ++;
#line 252
  admin_settings[tmp___4].setting = (void *)(& info.client_timeout);
#line 253
  tmp___5 = x;
#line 253
  x ++;
#line 253
  admin_settings[tmp___5].setting = (void *)(& info.max_clients);
#line 254
  tmp___6 = x;
#line 254
  x ++;
#line 254
  admin_settings[tmp___6].setting = (void *)(& info.max_clients_per_source);
#line 255
  tmp___7 = x;
#line 255
  x ++;
#line 255
  admin_settings[tmp___7].setting = (void *)(& info.max_sources);
#line 256
  tmp___8 = x;
#line 256
  x ++;
#line 256
  admin_settings[tmp___8].setting = (void *)(& info.max_admins);
#line 257
  tmp___9 = x;
#line 257
  x ++;
#line 257
  admin_settings[tmp___9].setting = (void *)(& info.reverse_lookups);
#line 258
  tmp___10 = x;
#line 258
  x ++;
#line 258
  admin_settings[tmp___10].setting = (void *)(& info.location);
#line 259
  tmp___11 = x;
#line 259
  x ++;
#line 259
  admin_settings[tmp___11].setting = (void *)(& info.rp_email);
#line 260
  tmp___12 = x;
#line 260
  x ++;
#line 260
  admin_settings[tmp___12].setting = (void *)(& info.transparent_proxy);
#line 261
  tmp___13 = x;
#line 261
  x ++;
#line 261
  admin_settings[tmp___13].setting = (void *)(& info.statsfilename);
#line 262
  tmp___14 = x;
#line 262
  x ++;
#line 262
  admin_settings[tmp___14].setting = (void *)(& info.statshtmlfilename);
#line 263
  tmp___15 = x;
#line 263
  x ++;
#line 263
  admin_settings[tmp___15].setting = (void *)(& info.statstime);
#line 264
  tmp___16 = x;
#line 264
  x ++;
#line 264
  admin_settings[tmp___16].setting = (void *)(& info.policy);
#line 265
  tmp___17 = x;
#line 265
  x ++;
#line 265
  admin_settings[tmp___17].setting = (void *)(& info.throttle);
#line 266
  tmp___18 = x;
#line 266
  x ++;
#line 266
  admin_settings[tmp___18].setting = (void *)(& info.kick_relays);
#line 267
  tmp___19 = x;
#line 267
  x ++;
#line 267
  admin_settings[tmp___19].setting = (void *)(& info.kick_clients);
#line 268
  tmp___20 = x;
#line 268
  x ++;
#line 268
  admin_settings[tmp___20].setting = (void *)(& info.statustime);
#line 269
  tmp___21 = x;
#line 269
  x ++;
#line 269
  admin_settings[tmp___21].setting = (void *)(& info.logfiledebuglevel);
#line 270
  tmp___22 = x;
#line 270
  x ++;
#line 270
  admin_settings[tmp___22].setting = (void *)(& info.consoledebuglevel);
#line 271
  tmp___23 = x;
#line 271
  x ++;
#line 271
  admin_settings[tmp___23].setting = (void *)(& info.server_url);
#line 272
  tmp___24 = x;
#line 272
  x ++;
#line 272
  admin_settings[tmp___24].setting = (void *)(& info.use_meta_data);
#line 273
  tmp___25 = x;
#line 273
  x ++;
#line 273
  admin_settings[tmp___25].setting = (void *)(& info.streamurllock);
#line 274
  tmp___26 = x;
#line 274
  x ++;
#line 274
  admin_settings[tmp___26].setting = (void *)(& info.streamurl);
#line 275
  tmp___27 = x;
#line 275
  x ++;
#line 275
  admin_settings[tmp___27].setting = (void *)(& info.streamtitletemplate);
#line 276
  tmp___28 = x;
#line 276
  x ++;
#line 276
  admin_settings[tmp___28].setting = (void *)(& info.nametemplate);
#line 277
  tmp___29 = x;
#line 277
  x ++;
#line 277
  admin_settings[tmp___29].setting = (void *)(& info.descriptiontemplate);
#line 278
  tmp___30 = x;
#line 278
  x ++;
#line 278
  admin_settings[tmp___30].setting = (void *)(& info.logfilename);
#line 279
  tmp___31 = x;
#line 279
  x ++;
#line 279
  admin_settings[tmp___31].setting = (void *)(& info.accessfilename);
#line 280
  tmp___32 = x;
#line 280
  x ++;
#line 280
  admin_settings[tmp___32].setting = (void *)(& info.usagefilename);
#line 281
  tmp___33 = x;
#line 281
  x ++;
#line 281
  admin_settings[tmp___33].setting = (void *)(& info.staticdir);
#line 282
  tmp___34 = x;
#line 282
  x ++;
#line 282
  admin_settings[tmp___34].setting = (void *)(& info.default_sourceopts);
#line 283
  tmp___35 = x;
#line 283
  x ++;
#line 283
  admin_settings[tmp___35].setting = (void *)(& info.mount_fallback);
#line 284
  tmp___36 = x;
#line 284
  x ++;
#line 284
  admin_settings[tmp___36].setting = (void *)(& info.force_servername);
#line 285
  tmp___37 = x;
#line 285
  x ++;
#line 285
  admin_settings[tmp___37].setting = (void *)(& info.resolv_type);
#line 286
  tmp___38 = x;
#line 286
  x ++;
#line 286
  admin_settings[tmp___38].setting = (void *)(& info.allow_http_admin);
#line 287
  tmp___39 = x;
#line 287
  x ++;
#line 287
  admin_settings[tmp___39].setting = (void *)(& info.relay_reconnect_tries);
#line 288
  tmp___40 = x;
#line 288
  x ++;
#line 288
  admin_settings[tmp___40].setting = (void *)(& info.relay_reconnect_time);
#line 289
  tmp___41 = x;
#line 289
  x ++;
#line 289
  admin_settings[tmp___41].setting = (void *)(& info.sleep_ratio);
#line 290
  return;
}
}
#line 294 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
set_element configfile_settings[49]  = 
#line 294
  {      {(char *)"encoder_password", (type_t )2, (char *)"The encoder password", (void *)0}, 
        {(char *)"client_password",
      (type_t )2, (char *)"<unimplemented> Client password", (void *)0}, 
        {(char *)"admin_password", (type_t )2, (char *)"The remote admin password", (void *)0}, 
        {(char *)"oper_password",
      (type_t )2, (char *)"Operator Password", (void *)0}, 
        {(char *)"touch_freq", (type_t )0, (char *)"Touch frequency", (void *)0}, 
        {(char *)"max_clients", (type_t )0, (char *)"Highest number of client connectons",
      (void *)0}, 
        {(char *)"max_sources", (type_t )0, (char *)"Highest number of source connections",
      (void *)0}, 
        {(char *)"max_admins", (type_t )0, (char *)"Highest number of admin connections",
      (void *)0}, 
        {(char *)"logfile", (type_t )2, (char *)"Logfile to write to", (void *)0}, 
        {(char *)"hostname", (type_t )2, (char *)"What host/ip to bind to", (void *)0}, 
        {(char *)"server_name",
      (type_t )2, (char *)"Server\'s hostname", (void *)0}, 
        {(char *)"console_mode", (type_t )0, (char *)"How to use the icecast console",
      (void *)0}, 
        {(char *)"client_timeout", (type_t )0, (char *)"When to kick out clients", (void *)0}, 
        {(char *)"stats_log",
      (type_t )2, (char *)"Stats Logfile to write to", (void *)0}, 
        {(char *)"statshtml_log", (type_t )2, (char *)"File for dumping periodic stats in html format",
      (void *)0}, 
        {(char *)"stats_time", (type_t )0, (char *)"How often to write to the stats logfile, in seconds",
      (void *)0}, 
        {(char *)"max_clients_per_source", (type_t )0, (char *)"Max number of clients listening on one source",
      (void *)0}, 
        {(char *)"reverse_lookups", (type_t )0, (char *)"Whether to reverse lookup hostnames",
      (void *)0}, 
        {(char *)"location", (type_t )2, (char *)"Icecast server geographical location",
      (void *)0}, 
        {(char *)"rp_email", (type_t )2, (char *)"Resposible person email", (void *)0}, 
        {(char *)"transparent_proxy",
      (type_t )0, (char *)"Whether to act as transparent proxy", (void *)0}, 
        {(char *)"acl_policy", (type_t )0, (char *)"Whether to allow (1) or deny (0) by default",
      (void *)0}, 
        {(char *)"throttle", (type_t )1, (char *)"At what bandwidth usage (MB/s) do we deny access?",
      (void *)0}, 
        {(char *)"kick_relays", (type_t )0, (char *)"Kick relays after how many seconds without listeners? (0 means keep forever)",
      (void *)0}, 
        {(char *)"kick_clients", (type_t )0, (char *)"0 means move clients to default source when their source dies, 1 means kick them out",
      (void *)0}, 
        {(char *)"status_time", (type_t )0, (char *)"Seconds between status line updates",
      (void *)0}, 
        {(char *)"staticdir", (type_t )2, (char *)"Directory for static files", (void *)0}, 
        {(char *)"logfiledebuglevel",
      (type_t )0, (char *)"Debug level for logfile output", (void *)0}, 
        {(char *)"consoledebuglevel", (type_t )0, (char *)"Debug level for console output",
      (void *)0}, 
        {(char *)"server_url", (type_t )2, (char *)"URL for this icecast server", (void *)0}, 
        {(char *)"use_meta_data",
      (type_t )0, (char *)"Whether to include metadata in the stream", (void *)0}, 
        {(char *)"streamurllock",
      (type_t )0, (char *)"Whether or not to allow sources to change the stream url",
      (void *)0}, 
        {(char *)"streamurl", (type_t )2, (char *)"Server global stream url", (void *)0}, 
        {(char *)"streamtitletemplate",
      (type_t )2, (char *)"Template string for stream title string", (void *)0}, 
        {(char *)"nametemplate", (type_t )2, (char *)"Template string for stream name",
      (void *)0}, 
        {(char *)"desctemplate", (type_t )2, (char *)"Template string for description template",
      (void *)0}, 
        {(char *)"accessfile", (type_t )2, (char *)"Access logfile", (void *)0}, 
        {(char *)"usagefile", (type_t )2, (char *)"Usage logfile", (void *)0}, 
        {(char *)"default_source_options", (type_t )2, (char *)"Default options to \'sources\'",
      (void *)0}, 
        {(char *)"mount_fallback", (type_t )0, (char *)"Fallback to default mount (1 yes, 0 no)",
      (void *)0}, 
        {(char *)"force_servername", (type_t )0, (char *)"Force use of server_name on directory server",
      (void *)0}, 
        {(char *)"logdir", (type_t )2, (char *)"Directory for log files", (void *)0}, 
        {(char *)"templatedir",
      (type_t )2, (char *)"Directory for template files", (void *)0}, 
        {(char *)"resolv_type", (type_t )0, (char *)"Type of resolv function to use. 1 is linux reentrant, 2 is solaris reentrant, 3 is standard nonreentrant",
      (void *)0}, 
        {(char *)"http_admin", (type_t )0, (char *)"Whether to allow admins on the WWW interface. 1 is yes, 0 means no",
      (void *)0}, 
        {(char *)"relay_reconnect_max", (type_t )0, (char *)"How many times to try reconnecting a relay, -1 means forever",
      (void *)0}, 
        {(char *)"relay_reconnect_time", (type_t )0, (char *)"Seconds to wait between reconnects",
      (void *)0}, 
        {(char *)"sleep_ratio", (type_t )1, (char *)"Ratio that affects source sleep time. Larger value means sleep more (normal values (0.0 - 1.0)",
      (void *)0}, 
        {(char *)((void *)0), (type_t )0, (char *)((void *)0), (void *)0}};
#line 390 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void setup_config_file_settings(void) 
{ 
  int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;

  {
#line 393
  x = 0;
#line 395
  tmp = x;
#line 395
  x ++;
#line 395
  configfile_settings[tmp].setting = (void *)(& info.encoder_pass);
#line 396
  tmp___0 = x;
#line 396
  x ++;
#line 396
  configfile_settings[tmp___0].setting = (void *)(& info.client_pass);
#line 397
  tmp___1 = x;
#line 397
  x ++;
#line 397
  configfile_settings[tmp___1].setting = (void *)(& info.remote_admin_pass);
#line 398
  tmp___2 = x;
#line 398
  x ++;
#line 398
  configfile_settings[tmp___2].setting = (void *)(& info.oper_pass);
#line 399
  tmp___3 = x;
#line 399
  x ++;
#line 399
  configfile_settings[tmp___3].setting = (void *)(& info.touch_freq);
#line 400
  tmp___4 = x;
#line 400
  x ++;
#line 400
  configfile_settings[tmp___4].setting = (void *)(& info.max_clients);
#line 401
  tmp___5 = x;
#line 401
  x ++;
#line 401
  configfile_settings[tmp___5].setting = (void *)(& info.max_sources);
#line 402
  tmp___6 = x;
#line 402
  x ++;
#line 402
  configfile_settings[tmp___6].setting = (void *)(& info.max_admins);
#line 403
  tmp___7 = x;
#line 403
  x ++;
#line 403
  configfile_settings[tmp___7].setting = (void *)(& info.logfilename);
#line 404
  tmp___8 = x;
#line 404
  x ++;
#line 404
  configfile_settings[tmp___8].setting = (void *)(& info.myhostname);
#line 405
  tmp___9 = x;
#line 405
  x ++;
#line 405
  configfile_settings[tmp___9].setting = (void *)(& info.server_name);
#line 406
  tmp___10 = x;
#line 406
  x ++;
#line 406
  configfile_settings[tmp___10].setting = (void *)(& info.console_mode);
#line 407
  tmp___11 = x;
#line 407
  x ++;
#line 407
  configfile_settings[tmp___11].setting = (void *)(& info.client_timeout);
#line 408
  tmp___12 = x;
#line 408
  x ++;
#line 408
  configfile_settings[tmp___12].setting = (void *)(& info.statsfilename);
#line 409
  tmp___13 = x;
#line 409
  x ++;
#line 409
  configfile_settings[tmp___13].setting = (void *)(& info.statshtmlfilename);
#line 410
  tmp___14 = x;
#line 410
  x ++;
#line 410
  configfile_settings[tmp___14].setting = (void *)(& info.statstime);
#line 411
  tmp___15 = x;
#line 411
  x ++;
#line 411
  configfile_settings[tmp___15].setting = (void *)(& info.max_clients_per_source);
#line 412
  tmp___16 = x;
#line 412
  x ++;
#line 412
  configfile_settings[tmp___16].setting = (void *)(& info.reverse_lookups);
#line 413
  tmp___17 = x;
#line 413
  x ++;
#line 413
  configfile_settings[tmp___17].setting = (void *)(& info.location);
#line 414
  tmp___18 = x;
#line 414
  x ++;
#line 414
  configfile_settings[tmp___18].setting = (void *)(& info.rp_email);
#line 415
  tmp___19 = x;
#line 415
  x ++;
#line 415
  configfile_settings[tmp___19].setting = (void *)(& info.transparent_proxy);
#line 416
  tmp___20 = x;
#line 416
  x ++;
#line 416
  configfile_settings[tmp___20].setting = (void *)(& info.policy);
#line 417
  tmp___21 = x;
#line 417
  x ++;
#line 417
  configfile_settings[tmp___21].setting = (void *)(& info.throttle);
#line 418
  tmp___22 = x;
#line 418
  x ++;
#line 418
  configfile_settings[tmp___22].setting = (void *)(& info.kick_relays);
#line 419
  tmp___23 = x;
#line 419
  x ++;
#line 419
  configfile_settings[tmp___23].setting = (void *)(& info.kick_clients);
#line 420
  tmp___24 = x;
#line 420
  x ++;
#line 420
  configfile_settings[tmp___24].setting = (void *)(& info.statustime);
#line 421
  tmp___25 = x;
#line 421
  x ++;
#line 421
  configfile_settings[tmp___25].setting = (void *)(& info.staticdir);
#line 422
  tmp___26 = x;
#line 422
  x ++;
#line 422
  configfile_settings[tmp___26].setting = (void *)(& info.logfiledebuglevel);
#line 423
  tmp___27 = x;
#line 423
  x ++;
#line 423
  configfile_settings[tmp___27].setting = (void *)(& info.consoledebuglevel);
#line 424
  tmp___28 = x;
#line 424
  x ++;
#line 424
  configfile_settings[tmp___28].setting = (void *)(& info.server_url);
#line 425
  tmp___29 = x;
#line 425
  x ++;
#line 425
  configfile_settings[tmp___29].setting = (void *)(& info.use_meta_data);
#line 426
  tmp___30 = x;
#line 426
  x ++;
#line 426
  configfile_settings[tmp___30].setting = (void *)(& info.streamurllock);
#line 427
  tmp___31 = x;
#line 427
  x ++;
#line 427
  configfile_settings[tmp___31].setting = (void *)(& info.streamurl);
#line 428
  tmp___32 = x;
#line 428
  x ++;
#line 428
  configfile_settings[tmp___32].setting = (void *)(& info.streamtitletemplate);
#line 429
  tmp___33 = x;
#line 429
  x ++;
#line 429
  configfile_settings[tmp___33].setting = (void *)(& info.nametemplate);
#line 430
  tmp___34 = x;
#line 430
  x ++;
#line 430
  configfile_settings[tmp___34].setting = (void *)(& info.descriptiontemplate);
#line 431
  tmp___35 = x;
#line 431
  x ++;
#line 431
  configfile_settings[tmp___35].setting = (void *)(& info.accessfilename);
#line 432
  tmp___36 = x;
#line 432
  x ++;
#line 432
  configfile_settings[tmp___36].setting = (void *)(& info.usagefilename);
#line 433
  tmp___37 = x;
#line 433
  x ++;
#line 433
  configfile_settings[tmp___37].setting = (void *)(& info.default_sourceopts);
#line 434
  tmp___38 = x;
#line 434
  x ++;
#line 434
  configfile_settings[tmp___38].setting = (void *)(& info.mount_fallback);
#line 435
  tmp___39 = x;
#line 435
  x ++;
#line 435
  configfile_settings[tmp___39].setting = (void *)(& info.force_servername);
#line 436
  tmp___40 = x;
#line 436
  x ++;
#line 436
  configfile_settings[tmp___40].setting = (void *)(& info.logdir);
#line 437
  tmp___41 = x;
#line 437
  x ++;
#line 437
  configfile_settings[tmp___41].setting = (void *)(& info.templatedir);
#line 438
  tmp___42 = x;
#line 438
  x ++;
#line 438
  configfile_settings[tmp___42].setting = (void *)(& info.resolv_type);
#line 439
  tmp___43 = x;
#line 439
  x ++;
#line 439
  configfile_settings[tmp___43].setting = (void *)(& info.allow_http_admin);
#line 440
  tmp___44 = x;
#line 440
  x ++;
#line 440
  configfile_settings[tmp___44].setting = (void *)(& info.relay_reconnect_tries);
#line 441
  tmp___45 = x;
#line 441
  x ++;
#line 441
  configfile_settings[tmp___45].setting = (void *)(& info.relay_reconnect_time);
#line 442
  tmp___46 = x;
#line 442
  x ++;
#line 442
  configfile_settings[tmp___46].setting = (void *)(& info.sleep_ratio);
#line 443
  return;
}
}
#line 445 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
set_element *find_set_element(char *name , set_element *el ) 
{ 
  register int i ;
  int tmp ;

  {
#line 449
  i = 0;
  {
  {
#line 449
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 449
    if (! (el + i)->name) {
#line 449
      goto while_break;
    }
    {
    {
#line 450
    tmp = ice_strcmp((char const   *)name, (char const   *)(el + i)->name);
    }
    }
#line 450
    if (tmp == 0) {
#line 451
      return (el + i);
    }
#line 449
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return ((set_element *)((void *)0));
}
}
#line 455 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
comp_element const   *find_comp_element(char const   *name , comp_element const   *el ) 
{ 
  register int i ;
  int tmp ;

  {
#line 459
  i = 0;
  {
  {
#line 459
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 459
    if (! (el + i)->name) {
#line 459
      goto while_break;
    }
    {
    {
#line 460
    tmp = ice_strcmp(name, (char const   *)(el + i)->name);
    }
    }
#line 460
    if (tmp == 0) {
#line 461
      return (el + i);
    }
#line 459
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return ((comp_element const   *)((comp_element *)((void *)0)));
}
}
#line 465 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int parse_default_config_file(void) 
{ 
  char *file ;
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 468
  tmp = get_icecast_file((char const   *)info.configfile, (filetype_t )1, 4);
  }
#line 468
  file = tmp;
  }
#line 470
  if (file) {
    {
    {
#line 471
    parse_config_file(file);
    }
    {
#line 472
    n_free((void *)file, (int const   )472, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
#line 472
    file = (char *)((void *)0);
    }
#line 473
    return (1);
  }
  {
  {
#line 476
  parse_config_file(info.configfile);
  }
  }
#line 477
  return (1);
}
}
#line 482 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int parse_config_file(char *file ) 
{ 
  set_element *se ;
  char word[8192] ;
  char line[8192] ;
  int cf ;
  int i ;
  int lineno ;
  char const   *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char host[8192] ;
  char port[8192] ;
  directory_server_t *dir ;
  directory_server_t *tmp___4 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char name[8192] ;
  request_t nameline ;
  request_t realline ;
  char *tmp___12 ;
  int p ;
  int tmp___13 ;
  char type[8192] ;
  restrict_t *res ;
  char *tmp___14 ;
  avl_tree *tmp___15 ;
  char type___0[8192] ;
  restrict_t *res___0 ;
  char *tmp___16 ;
  avl_tree *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;

  {
#line 489
  lineno = 0;
#line 491
  if (file) {
#line 491
    tmp = (char const   *)file;
  } else {
#line 491
    tmp = "(null)";
  }
  {
  {
#line 491
  xa_debug(1, (char *)"DEBUG: Parsing configuration file %s", tmp);
  }
  }
#line 493
  if (! file) {
#line 494
    return (0);
  }
  {
  {
#line 496
  cf = open_for_reading((char const   *)file);
  }
  }
#line 496
  if (cf == -1) {
    {
    {
#line 498
    write_log(0, (char *)"No configfile found, using defaults.");
    }
    }
#line 499
    return (1);
  }
#line 504
  if (! info.client_acl) {
    {
    {
#line 505
    write_log(0, (char *)"WARNING: parse_config_file(): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 504
  if (! info.source_acl) {
    {
    {
#line 505
    write_log(0, (char *)"WARNING: parse_config_file(): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 504
  if (! info.admin_acl) {
    {
    {
#line 505
    write_log(0, (char *)"WARNING: parse_config_file(): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 504
  if (! info.all_acl) {
    {
    {
#line 505
    write_log(0, (char *)"WARNING: parse_config_file(): NULL acl tree pointers, this is weird!");
    }
    }
  } else {
    {
    {
#line 507
    free_acl_lists();
    }
    }
  }
#line 509
  if (! info.client_acl) {
    {
    {
#line 510
    write_log(0, (char *)"WARNING: parse_config_file(after): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 509
  if (! info.source_acl) {
    {
    {
#line 510
    write_log(0, (char *)"WARNING: parse_config_file(after): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 509
  if (! info.admin_acl) {
    {
    {
#line 510
    write_log(0, (char *)"WARNING: parse_config_file(after): NULL acl tree pointers, this is weird!");
    }
    }
  } else
#line 509
  if (! info.all_acl) {
    {
    {
#line 510
    write_log(0, (char *)"WARNING: parse_config_file(after): NULL acl tree pointers, this is weird!");
    }
    }
  }
  {
  {
#line 512
  free_directory_servers(& info.d_servers);
  }
  {
#line 513
  free_aliases();
  }
#line 515
  i = 0;
  }
  {
  {
#line 515
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 515
    if (! (i < 5)) {
#line 515
      goto while_break;
    }
#line 516
    info.port[i] = 0;
#line 515
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 519
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 519
    tmp___27 = fd_read_line(cf, line, (int const   )8192);
    }
    }
#line 519
    if (! (tmp___27 > 0)) {
#line 519
      goto while_break___0;
    }
    {
#line 521
    lineno ++;
    {
#line 522
    tmp___0 = ice_strlen((char const   *)(line));
    }
    }
#line 522
    if (tmp___0 < 2U) {
#line 523
      goto while_continue___0;
    } else
#line 522
    if ((int )line[0] == 35) {
#line 523
      goto while_continue___0;
    } else
#line 522
    if ((int )line[0] == 32) {
#line 523
      goto while_continue___0;
    }
    {
    {
#line 525
    tmp___2 = ice_strlen((char const   *)(line));
    }
    }
#line 525
    if ((int )line[tmp___2 - 1U] == 10) {
      {
      {
#line 526
      tmp___1 = ice_strlen((char const   *)(line));
      }
#line 526
      line[tmp___1 - 1U] = (char )'\000';
      }
    }
    {
    {
#line 527
    tmp___3 = splitc(word, line, (char const   )' ');
    }
    }
#line 527
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      {
      {
#line 528
      write_log(0, (char *)"ERROR: No argument given to setting %s on line %d", line,
                lineno);
      }
      }
#line 530
      goto while_continue___0;
    }
    {
    {
#line 533
    se = find_set_element(word, configfile_settings);
    }
    {
#line 537
    tmp___24 = ice_strncmp((char const   *)(word), "icydir", (size_t )6);
    }
    }
#line 537
    if (tmp___24 == 0) {
#line 537
      goto _L;
    } else {
      {
      {
#line 537
      tmp___25 = ice_strncmp((char const   *)(word), "dir", (size_t )3);
      }
      }
#line 537
      if (tmp___25 == 0) {
        _L: /* CIL Label */ 
        {
        {
#line 540
        tmp___4 = create_directory();
        }
#line 540
        dir = tmp___4;
        {
#line 542
        tmp___6 = ice_strncmp((char const   *)(word), "icydir", (size_t )6);
        }
        }
#line 542
        if (tmp___6 == 0) {
#line 542
          dir->type = (protocol_t )0;
        } else {
#line 542
          dir->type = (protocol_t )1;
        }
        {
#line 543
        dir->counter = 0;
#line 544
        dir->id = -1;
        {
#line 546
        tmp___7 = strchr((char const   *)(line), '/');
        }
        }
#line 546
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
          {
          {
#line 546
          tmp___8 = strchr((char const   *)(line), ':');
          }
          }
#line 546
          if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
            {
            {
#line 548
            write_log(0, (char *)"ERROR: Path but no port specified in icy directory on line %d",
                      lineno);
            }
            }
#line 549
            goto while_continue___0;
          }
        }
        {
        {
#line 552
        tmp___10 = splitc(host, line, (char const   )':');
        }
        }
#line 552
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
          {
#line 554
          dir->port = 80;
          {
#line 555
          dir->path = n_strdup("cgi-bin/touch", (int const   )555, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
          }
          {
#line 556
          strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)(line),
                  (size_t )8192);
          }
          }
        } else {
          {
          {
#line 557
          tmp___9 = splitc(port, line, (char const   )'/');
          }
          }
#line 557
          if ((unsigned long )tmp___9 == (unsigned long )((void *)0)) {
            {
            {
#line 559
            dir->port = atoi((char const   *)(line));
            }
            {
#line 560
            dir->path = n_strdup("DEFAULT_YP_TOUCH", (int const   )560, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            }
          } else {
            {
            {
#line 562
            dir->port = atoi((char const   *)(port));
            }
            {
#line 563
            dir->path = n_strdup((char const   *)(line), (int const   )563, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            }
          }
        }
        {
        {
#line 566
        dir->host = n_strdup((char const   *)(host), (int const   )566, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        {
#line 568
        thread_mutex_lock_c(& info.directory_mutex, 568, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        {
#line 569
        tmp___11 = avl_find(info.d_servers, (void const   *)dir);
        }
        }
#line 569
        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
          {
          {
#line 570
          avl_insert(info.d_servers, (void *)dir);
          }
          }
        }
        {
        {
#line 571
        thread_mutex_unlock_c(& info.directory_mutex, 571, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        }
#line 573
        if ((unsigned int )dir->type == 0U) {
          {
          {
#line 574
          write_log(0, (char *)"Using icy directory server [%s:%d]", dir->host, dir->port);
          }
          }
        } else {
          {
          {
#line 576
          write_log(0, (char *)"Using xaudiocast directory server [%s:%d/%s]", dir->host,
                    dir->port, dir->path);
          }
          }
        }
#line 577
        goto while_continue___0;
      } else {
        {
        {
#line 579
        tmp___23 = ice_strncmp((char const   *)(word), "alias", (size_t )5);
        }
        }
#line 579
        if (tmp___23 == 0) {
          {
          {
#line 582
          tmp___12 = splitc(name, line, (char const   )' ');
          }
          }
#line 582
          if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
            {
            {
#line 583
            write_log(0, (char *)"ERROR: Missing argument for alias on line %d", lineno);
            }
            }
          } else {
            {
            {
#line 587
            zero_request(& nameline);
            }
            {
#line 588
            zero_request(& realline);
            }
            {
#line 590
            generate_request(name, & nameline);
            }
            {
#line 591
            generate_request(line, & realline);
            }
            }
#line 594
            if (! nameline.path[0]) {
              {
              {
#line 595
              write_log(0, (char *)"ERROR: Invalid syntax for alias on line %d", lineno);
              }
              }
#line 596
              goto while_continue___0;
            } else
#line 594
            if (! realline.path[0]) {
              {
              {
#line 595
              write_log(0, (char *)"ERROR: Invalid syntax for alias on line %d", lineno);
              }
              }
#line 596
              goto while_continue___0;
            }
            {
            {
#line 598
            add_alias(& nameline, & realline);
            }
            }
          }
#line 600
          goto while_continue___0;
        } else {
          {
          {
#line 601
          tmp___22 = ice_strncmp((char const   *)(word), "relay", (size_t )5);
          }
          }
#line 601
          if (tmp___22 == 0) {
            {
            {
#line 602
            relay_add_pull_to_list(line);
            }
            }
#line 603
            goto while_continue___0;
          } else {
            {
            {
#line 604
            tmp___21 = ice_strncmp((char const   *)(word), "port", (size_t )4);
            }
            }
#line 604
            if (tmp___21 == 0) {
              {
              {
#line 605
              tmp___13 = atoi((char const   *)(line));
              }
#line 605
              p = tmp___13;
#line 606
              i = 0;
              }
              {
              {
#line 606
              while (1) {
                while_continue___4: /* CIL Label */ ;
                while_continue___1: /* CIL Label */ ;
#line 606
                if (! (i < 5)) {
#line 606
                  goto while_break___1;
                }
#line 607
                if (info.port[i] == 0) {
#line 607
                  goto while_break___1;
                }
#line 606
                i ++;
              }
              while_break___4: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 608
              if (i < 5) {
#line 609
                info.port[i] = p;
              }
#line 610
              goto while_continue___0;
            } else {
              {
              {
#line 611
              tmp___20 = ice_strncmp((char const   *)(word), "include", (size_t )7);
              }
              }
#line 611
              if (tmp___20 == 0) {
                {
                {
#line 612
                parse_config_file(line);
                }
                }
#line 613
                goto while_continue___0;
              } else {
                {
                {
#line 614
                tmp___19 = ice_strncmp((char const   *)(word), "allow", (size_t )5);
                }
                }
#line 614
                if (tmp___19 == 0) {
                  {
                  {
#line 617
                  tmp___14 = splitc(type, line, (char const   )' ');
                  }
                  }
#line 617
                  if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
                    {
                    {
#line 618
                    write_log(0, (char *)"ERROR: Invalid syntax for acl allow on line %d",
                              lineno);
                    }
                    }
#line 619
                    goto while_continue___0;
                  }
                  {
                  {
#line 621
                  tmp___15 = get_acl_tree(type);
                  }
                  {
#line 621
                  res = add_restrict(tmp___15, line, (acltype_t )1);
                  }
                  }
#line 622
                  if (! res) {
                    {
                    {
#line 623
                    write_log(0, (char *)"ERROR: Acl addition for [%s] failed", line);
                    }
                    }
                  }
#line 624
                  goto while_continue___0;
                } else {
                  {
                  {
#line 625
                  tmp___18 = ice_strncmp((char const   *)(word), "deny", (size_t )4);
                  }
                  }
#line 625
                  if (tmp___18 == 0) {
                    {
                    {
#line 628
                    tmp___16 = splitc(type___0, line, (char const   )' ');
                    }
                    }
#line 628
                    if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
                      {
                      {
#line 629
                      write_log(0, (char *)"ERROR: Invalid syntax for acl deny on line %d",
                                lineno);
                      }
                      }
#line 630
                      goto while_continue___0;
                    }
                    {
                    {
#line 632
                    tmp___17 = get_acl_tree(type___0);
                    }
                    {
#line 632
                    res___0 = add_restrict(tmp___17, line, (acltype_t )0);
                    }
                    }
#line 633
                    if (! res___0) {
                      {
                      {
#line 634
                      write_log(0, (char *)"ERROR: Acl addition for [%s] failed",
                                line);
                      }
                      }
                    }
#line 635
                    goto while_continue___0;
                  }
                }
              }
            }
          }
        }
      }
    }
#line 639
    if (! se) {
      {
      {
#line 640
      write_log(0, (char *)"Unknown setting %s on line %d", word, lineno);
      }
      }
#line 641
      goto while_continue___0;
    }
#line 644
    if ((unsigned int )se->type == 0U) {
      {
      {
#line 645
      *((int *)se->setting) = atoi((char const   *)(line));
      }
      }
    } else
#line 646
    if ((unsigned int )se->type == 1U) {
      {
      {
#line 647
      *((double *)se->setting) = atof((char const   *)(line));
      }
      }
    } else {
#line 650
      if ((unsigned long )*((char **)se->setting) != (unsigned long )((void *)0)) {
        {
        {
#line 651
        n_free((void *)*((char **)se->setting), (int const   )651, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        }
      }
      {
#line 651
      *((char **)se->setting) = (char *)((void *)0);
      {
#line 652
      tmp___26 = n_strdup((char const   *)(line), (int const   )652, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
      {
#line 652
      *((char **)se->setting) = clean_string(tmp___26);
      }
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 655
  fd_close(cf);
  }
  }
#line 656
  return (0);
}
}
#line 660 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void handle_admin_command(connection_t *con , char *command , int command_len ) 
{ 
  int flag ;
  register int i ;
  comp_element const   *com ;
  com_request_t req ;
  char comstr[8192] ;
  char widstr[8192] ;
  admin_t *adm ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 663
  flag = 0;
#line 668
  adm = con->food.admin;
#line 670
  widstr[0] = (char )'\000';
#line 673
  req.con = con;
#line 674
  req.wid = -1;
#line 675
  req.arg = (char *)((void *)0);
#line 677
  if (command_len < 2) {
    {
    {
#line 679
    write_admin_prompt((connection_t const   *)con);
    }
    }
#line 680
    return;
  }
#line 684
  i = 0;
  {
  {
#line 684
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i <= command_len)) {
#line 684
      goto while_break;
    }
#line 686
    if ((int )*(command + i) == 10) {
#line 688
      flag = 1;
#line 689
      *(command + i) = (char )'\000';
#line 690
      goto while_break;
    } else
#line 686
    if ((int )*(command + i) == 0) {
#line 688
      flag = 1;
#line 689
      *(command + i) = (char )'\000';
#line 690
      goto while_break;
    }
#line 684
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 694
  tmp___0 = strlen((char const   *)command);
  }
  }
#line 694
  if ((int )*(command + (tmp___0 - 1U)) == 32) {
    {
    {
#line 695
    tmp = strlen((char const   *)command);
    }
#line 695
    *(command + (tmp - 1U)) = (char )'\000';
    }
  }
#line 697
  if (! flag) {
    {
    {
#line 699
    write_admin_prompt((connection_t const   *)con);
    }
    }
#line 700
    return;
  }
  {
  {
#line 703
  splitc(comstr, command, (char const   )' ');
  }
  }
#line 705
  if (! comstr[0]) {
#line 705
    goto _L;
  } else
#line 705
  if (! *(command + 0)) {
#line 705
    goto _L;
  } else
#line 705
  if ((int )*(command + 0) == 32) {
    _L: /* CIL Label */ 
#line 707
    if (*(command + 0)) {
#line 707
      if ((int )*(command + 0) != 32) {
        {
        {
#line 708
        strncpy((char */* __restrict  */)(comstr), (char const   */* __restrict  */)command,
                (size_t )8192);
        }
        }
      }
    }
#line 709
    req.arg = (char *)((void *)0);
  } else {
#line 711
    req.arg = command;
  }
  {
  {
#line 713
  splitc(widstr, comstr, (char const   )'.');
  }
  {
#line 715
  tmp___1 = is_number((char const   *)(widstr));
  }
  }
#line 715
  if (tmp___1) {
    {
    {
#line 717
    req.wid = atoi((char const   *)(widstr));
    }
    }
  }
  {
  {
#line 721
  com = find_comp_element((char const   *)(comstr), (comp_element const   *)(commands));
  }
  }
#line 723
  if (! com) {
    {
    {
#line 725
    com_help(& req);
    }
    {
#line 726
    write_admin_prompt((connection_t const   *)con);
    }
    }
#line 727
    return;
  }
#line 729
  if (com->oper) {
#line 729
    if (! adm->oper) {
      {
      {
#line 730
      admin_write_line((com_request_t const   *)(& req), (int const   )-1, "Only operators can use the %s command",
                       com->name);
      }
      }
    } else {
      {
      {
#line 733
      log_command((char const   *)(comstr), (com_request_t const   *)(& req));
      }
      {
#line 734
      (*(com->func))(& req);
      }
      }
    }
  } else {
    {
    {
#line 733
    log_command((char const   *)(comstr), (com_request_t const   *)(& req));
    }
    {
#line 734
    (*(com->func))(& req);
    }
    }
  }
  {
  {
#line 737
  write_admin_prompt((connection_t const   *)con);
  }
  }
#line 738
  return;
}
}
#line 740 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void log_command(char const   *command , com_request_t const   *req ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 743
  if (req->arg) {
    {
    {
#line 743
    tmp___1 = strcmp(command, "oper");
    }
    }
#line 743
    if (tmp___1 != 0) {
      {
      {
#line 744
      tmp = con_host((connection_t *)req->con);
      }
      {
#line 744
      write_log_not_me(0, (connection_t *)req->con, (char *)"Admin [%s] said: %s %s",
                       tmp, command, req->arg);
      }
      }
    } else {
      {
      {
#line 746
      tmp___0 = con_host((connection_t *)req->con);
      }
      {
#line 746
      write_log_not_me(0, (connection_t *)req->con, (char *)"Admin [%s] said: %s",
                       tmp___0, command);
      }
      }
    }
  } else {
    {
    {
#line 746
    tmp___0 = con_host((connection_t *)req->con);
    }
    {
#line 746
    write_log_not_me(0, (connection_t *)req->con, (char *)"Admin [%s] said: %s", tmp___0,
                     command);
    }
    }
  }
#line 747
  return;
}
}
#line 749 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
char *com_arg(com_request_t const   *req ) 
{ 


  {
#line 752
  if (req) {
#line 753
    return ((char *)req->arg);
  }
#line 754
  return ((char *)((void *)0));
}
}
#line 757 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_admins(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  connection_t *admcon ;
  avl_traverser trav ;
  char pattern[8192] ;
  char buf[8192] ;
  int listed ;
  time_t t ;
  long tmp___0 ;
  item_t *tmp___1 ;
  item_t *tmp___2 ;
  item_t *tmp___3 ;
  item_t *tmp___4 ;
  item_t *tmp___5 ;
  item_t *tmp___6 ;
  int tmp___7 ;
  item_t *tmp___8 ;
  char *tmp___9 ;
  item_t *tmp___10 ;
  char const   *tmp___11 ;
  item_t *tmp___12 ;
  item_t *tmp___13 ;
  void *tmp___14 ;
  item_t *tmp___15 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
  {
#line 760
  tmp = com_arg((com_request_t const   *)req);
  }
#line 760
  arg = tmp;
#line 762
  trav.init = 0;
#line 762
  trav.nstack = 0;
#line 762
  trav.p = (avl_node const   *)0;
#line 762
  trav.stack[0] = (avl_node const   *)0;
#line 762
  trav.stack[1] = (avl_node const   *)0;
#line 762
  trav.stack[2] = (avl_node const   *)0;
#line 762
  trav.stack[3] = (avl_node const   *)0;
#line 762
  trav.stack[4] = (avl_node const   *)0;
#line 762
  trav.stack[5] = (avl_node const   *)0;
#line 762
  trav.stack[6] = (avl_node const   *)0;
#line 762
  trav.stack[7] = (avl_node const   *)0;
#line 762
  trav.stack[8] = (avl_node const   *)0;
#line 762
  trav.stack[9] = (avl_node const   *)0;
#line 762
  trav.stack[10] = (avl_node const   *)0;
#line 762
  trav.stack[11] = (avl_node const   *)0;
#line 762
  trav.stack[12] = (avl_node const   *)0;
#line 762
  trav.stack[13] = (avl_node const   *)0;
#line 762
  trav.stack[14] = (avl_node const   *)0;
#line 762
  trav.stack[15] = (avl_node const   *)0;
#line 762
  trav.stack[16] = (avl_node const   *)0;
#line 762
  trav.stack[17] = (avl_node const   *)0;
#line 762
  trav.stack[18] = (avl_node const   *)0;
#line 762
  trav.stack[19] = (avl_node const   *)0;
#line 762
  trav.stack[20] = (avl_node const   *)0;
#line 762
  trav.stack[21] = (avl_node const   *)0;
#line 762
  trav.stack[22] = (avl_node const   *)0;
#line 762
  trav.stack[23] = (avl_node const   *)0;
#line 762
  trav.stack[24] = (avl_node const   *)0;
#line 762
  trav.stack[25] = (avl_node const   *)0;
#line 762
  trav.stack[26] = (avl_node const   *)0;
#line 762
  trav.stack[27] = (avl_node const   *)0;
#line 762
  trav.stack[28] = (avl_node const   *)0;
#line 762
  trav.stack[29] = (avl_node const   *)0;
#line 762
  trav.stack[30] = (avl_node const   *)0;
#line 762
  trav.stack[31] = (avl_node const   *)0;
#line 764
  listed = 0;
  {
#line 765
  tmp___0 = get_time();
  }
#line 765
  t = tmp___0;
#line 767
  pattern[0] = (char )'\000';
  }
#line 769
  if (arg) {
#line 769
    if (*(arg + 0)) {
      {
      {
#line 771
      strncpy((char */* __restrict  */)(pattern), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      {
#line 772
      tmp___1 = item_create("Listing admins matching [%s]", "%s", (void const   *)arg);
      }
      {
#line 772
      item_write_formatted_line(req, 100, (item_type_t )0, 1, tmp___1);
      }
      }
    } else {
      {
      {
#line 775
      tmp___2 = item_create("Listing admins", "%s", (void const   *)((void *)0));
      }
      {
#line 775
      item_write_formatted_line(req, 100, (item_type_t )0, 1, tmp___2);
      }
      }
    }
  } else {
    {
    {
#line 775
    tmp___2 = item_create("Listing admins", "%s", (void const   *)((void *)0));
    }
    {
#line 775
    item_write_formatted_line(req, 100, (item_type_t )0, 1, tmp___2);
    }
    }
  }
  {
  {
#line 779
  tmp___3 = item_create("Commands issued", "%s", (void const   *)((void *)0));
  }
  {
#line 779
  tmp___4 = item_create("Connected for", "%s", (void const   *)((void *)0));
  }
  {
#line 779
  tmp___5 = item_create("Host", "%s", (void const   *)((void *)0));
  }
  {
#line 779
  tmp___6 = item_create("Connection id", "%s", (void const   *)((void *)0));
  }
  {
#line 779
  item_write_formatted_line(req, 103, (item_type_t )4, 4, tmp___6, tmp___5, tmp___4,
                            tmp___3);
  }
  {
#line 785
  thread_mutex_lock_c(& info.admin_mutex, 785, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 786
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 786
    tmp___14 = avl_traverse(info.admins, & trav);
    }
#line 786
    admcon = (connection_t *)tmp___14;
    }
#line 786
    if (! admcon) {
#line 786
      goto while_break;
    }
#line 788
    if (pattern[0]) {
      {
      {
#line 789
      tmp___7 = hostmatch((connection_t const   *)admcon, (char const   *)(pattern));
      }
      }
#line 789
      if (! tmp___7) {
#line 790
        goto while_continue;
      }
    }
    {
#line 791
    listed ++;
    {
#line 792
    tmp___8 = item_create("Commands issued", "%d", (void const   *)(& (admcon->food.admin)->commands));
    }
    {
#line 792
    tmp___9 = nice_time((unsigned long )(t - admcon->connect_time), buf);
    }
    {
#line 792
    tmp___10 = item_create("Connected for", "%s", (void const   *)tmp___9);
    }
    {
#line 792
    tmp___11 = con_host(admcon);
    }
    {
#line 792
    tmp___12 = item_create("Host", "%s", (void const   *)tmp___11);
    }
    {
#line 792
    tmp___13 = item_create("Id", "%d", (void const   *)(& admcon->id));
    }
    {
#line 792
    item_write_formatted_line(req, 101, (item_type_t )2, 4, tmp___13, tmp___12, tmp___10,
                              tmp___8);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 804
  thread_mutex_unlock_c(& info.admin_mutex, 804, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 806
  tmp___15 = item_create("End of admin listing (%d listed)", "%d", (void const   *)(& listed));
  }
  {
#line 806
  item_write_formatted_line(req, 102, (item_type_t )1, 1, tmp___15);
  }
  }
#line 808
  return (1);
}
}
#line 811 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void show_settings(com_request_t *req ) 
{ 
  register int i ;
  set_element *se ;
  item_t *tmp ;
  item_t *tmp___0 ;
  item_t *tmp___1 ;
  item_t *tmp___2 ;
  item_t *tmp___3 ;
  item_t *tmp___4 ;
  item_t *tmp___5 ;
  item_t *tmp___6 ;
  item_t *tmp___7 ;
  item_t *tmp___8 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 815
  se = admin_settings;
  {
#line 817
  tmp = item_create("Current settings", "%s", (void const   *)((void *)0));
  }
  {
#line 817
  item_write_formatted_line(req, 110, (item_type_t )0, 1, tmp);
  }
  {
#line 820
  tmp___0 = item_create("Value", "%s", (void const   *)((void *)0));
  }
  {
#line 820
  tmp___1 = item_create("Setting", "%s", (void const   *)((void *)0));
  }
  {
#line 820
  item_write_formatted_line(req, 116, (item_type_t )4, 2, tmp___1, tmp___0);
  }
#line 825
  i = 0;
  }
  {
  {
#line 825
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 825
    if (! (se + i)->name) {
#line 825
      goto while_break;
    }
#line 827
    if ((unsigned int )(se + i)->type == 0U) {
      {
      {
#line 828
      tmp___2 = item_create("", "%d", (void const   *)(se + i)->setting);
      }
      {
#line 828
      tmp___3 = item_create("", "%25s:\t", (void const   *)(se + i)->name);
      }
      {
#line 828
      item_write_formatted_line(req, 111, (item_type_t )6, 2, tmp___3, tmp___2);
      }
      }
    } else
#line 831
    if ((unsigned int )(se + i)->type == 1U) {
      {
      {
#line 832
      tmp___4 = item_create("", "%f", (void const   *)(se + i)->setting);
      }
      {
#line 832
      tmp___5 = item_create("", "%25s:\t", (void const   *)(se + i)->name);
      }
      {
#line 832
      item_write_formatted_line(req, 112, (item_type_t )6, 2, tmp___5, tmp___4);
      }
      }
    } else {
      {
      {
#line 836
      tmp___6 = item_create("", "%s", (void const   *)*((char **)(se + i)->setting));
      }
      {
#line 836
      tmp___7 = item_create("", "%25s:\t", (void const   *)(se + i)->name);
      }
      {
#line 836
      item_write_formatted_line(req, 113, (item_type_t )6, 2, tmp___7, tmp___6);
      }
      }
    }
#line 825
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 841
  tmp___8 = item_create("End of settings", "%s", (void const   *)((void *)0));
  }
  {
#line 841
  item_write_formatted_line(req, 115, (item_type_t )1, 1, tmp___8);
  }
  }
#line 843
  return;
}
}
#line 845 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_help(com_request_t *req ) 
{ 
  register int i ;
  comp_element const   *ce ;
  set_element *se ;
  char *arg ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
  {
#line 851
  tmp = com_arg((com_request_t const   *)req);
  }
#line 851
  arg = tmp;
  }
#line 853
  if (! arg) {
    {
#line 855
    ce = (comp_element const   *)(commands);
    {
#line 856
    admin_write_line((com_request_t const   *)req, (int const   )120, "Available commands:");
    }
#line 857
    i = 0;
    }
    {
    {
#line 857
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 857
      if (! (ce + i)->name) {
#line 857
        goto while_break;
      }
      {
      {
#line 858
      admin_write_line((com_request_t const   *)req, (int const   )121, "%20s\t: %s",
                       (ce + i)->name, (ce + i)->doc);
      }
#line 857
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 859
    admin_write_line((com_request_t const   *)req, (int const   )122, "For slighly more detailed help on each command, try \'help <command>\'");
    }
    }
#line 860
    return (1);
  }
  {
  {
#line 863
  tmp___0 = ice_strncmp((char const   *)arg, "setti", (size_t )5);
  }
  }
#line 863
  if (tmp___0 == 0) {
    {
#line 865
    se = admin_settings;
    {
#line 866
    admin_write_line((com_request_t const   *)req, (int const   )110, "Available settings:");
    }
#line 867
    i = 0;
    }
    {
    {
#line 867
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 867
      if (! (se + i)->name) {
#line 867
        goto while_break___0;
      }
      {
      {
#line 868
      admin_write_line((com_request_t const   *)req, (int const   )114, "%25s\t: %s",
                       (se + i)->name, (se + i)->doc);
      }
#line 867
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 869
    admin_write_line((com_request_t const   *)req, (int const   )115, "End of settings list (%d listed)",
                     i);
    }
    }
#line 870
    return (1);
  }
  {
  {
#line 873
  ce = find_comp_element((char const   *)arg, (comp_element const   *)(commands));
  }
  }
#line 875
  if (! ce) {
    {
    {
#line 877
    admin_write_line((com_request_t const   *)req, (int const   )123, "No such command [%s]",
                     arg);
    }
    }
#line 878
    return (1);
  }
  {
  {
#line 881
  admin_write_line((com_request_t const   *)req, (int const   )124, "Command: [%s]\tDescription: [%s]%s",
                   ce->name, ce->doc, ce->doclong);
  }
  }
#line 883
  return (1);
}
}
#line 886 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_set(com_request_t *req ) 
{ 
  char argument[8192] ;
  set_element *s ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 891
  tmp = com_arg((com_request_t const   *)req);
  }
#line 891
  arg = tmp;
#line 893
  argument[0] = (char )'\000';
  }
#line 895
  if (! arg) {
    {
    {
#line 897
    show_settings(req);
    }
    }
#line 898
    return (1);
  } else
#line 895
  if (! *(arg + 0)) {
    {
    {
#line 897
    show_settings(req);
    }
    }
#line 898
    return (1);
  }
#line 901
  if (! *(arg + 0)) {
#line 901
    goto _L;
  } else
#line 901
  if ((int )*(arg + 0) == 32) {
#line 901
    goto _L;
  } else
#line 901
  if ((int )*(arg + 0) == 0) {
#line 901
    goto _L;
  } else {
    {
    {
#line 901
    tmp___0 = splitc(argument, arg, (char const   )' ');
    }
    }
#line 901
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 901
      goto _L;
    } else
#line 901
    if ((int )argument[0] == 32) {
#line 901
      goto _L;
    } else
#line 901
    if ((int )argument[0] == 0) {
#line 901
      goto _L;
    } else
#line 901
    if ((int )*(arg + 0) == 32) {
#line 901
      goto _L;
    } else
#line 901
    if ((int )*(arg + 0) == 0) {
      _L: /* CIL Label */ 
      {
      {
#line 905
      s = find_set_element(arg, admin_settings);
      }
      }
#line 906
      if (! s) {
        {
        {
#line 908
        admin_write_line((com_request_t const   *)req, (int const   )130, "No such setting [%s]",
                         arg);
        }
        }
#line 909
        return (1);
      }
#line 911
      if ((unsigned int )s->type == 0U) {
        {
        {
#line 912
        admin_write_line((com_request_t const   *)req, (int const   )111, "%s: %d",
                         s->name, *((int *)s->setting));
        }
        }
      } else
#line 913
      if ((unsigned int )s->type == 1U) {
        {
        {
#line 914
        admin_write_line((com_request_t const   *)req, (int const   )112, "%s: %f",
                         s->name, *((double *)s->setting));
        }
        }
      } else {
        {
        {
#line 916
        admin_write_line((com_request_t const   *)req, (int const   )113, "%s: %s",
                         s->name, *((char **)s->setting));
        }
        }
      }
#line 917
      return (1);
    }
  }
  {
  {
#line 920
  s = find_set_element(argument, admin_settings);
  }
  }
#line 921
  if (! s) {
    {
    {
#line 923
    admin_write_line((com_request_t const   *)req, (int const   )130, "No such setting [%s]",
                     argument);
    }
    }
#line 924
    return (1);
  }
  {
  {
#line 928
  tmp___1 = is_special_variable(argument);
  }
  }
#line 928
  if (tmp___1) {
    {
    {
#line 930
    change_special_variable(req, s, argument, arg);
    }
    }
#line 931
    return (1);
  }
  {
  {
#line 934
  change_variable(req, s, argument, arg);
  }
  }
#line 937
  return (1);
}
}
#line 940 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_tail(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 943
  admin_write_line((com_request_t const   *)req, (int const   )140, "Now tailing logfile");
  }
#line 944
  ((req->con)->food.admin)->tailing = 1U;
  }
#line 945
  return (1);
}
}
#line 948 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_untail(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 951
  admin_write_line((com_request_t const   *)req, (int const   )141, "No longer tailing logfile");
  }
#line 952
  ((req->con)->food.admin)->tailing = 0U;
  }
#line 953
  return (1);
}
}
#line 956 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
conopt_t sourceopts[27]  = 
#line 956
  {      {(char )'i', (char *)"Show id", 0}, 
        {(char )'s', (char *)"Show socket", 1}, 
        {(char )'t', (char *)"Show time of connect", 2}, 
        {(char )'p', (char *)"Show ip", 3}, 
        {(char )'h', (char *)"Show host", 4}, 
        {(char )'e', (char *)"Show all headers", 5}, 
        {(char )'c', (char *)"Show state (connected/pending)", 6}, 
        {(char )'y', (char *)"Show source type", 7}, 
        {(char )'o', (char *)"Show protocol (xaudiocast/icy)", 8}, 
        {(char )'c', (char *)"Show number of clients", 9}, 
        {(char )'d', (char *)"Show dumpfile", 10}, 
        {(char )'r', (char *)"Show mount priority", 11}, 
        {(char )'l', (char *)"Show song title", 12}, 
        {(char )'u', (char *)"Show song url", 13}, 
        {(char )'m', (char *)"Show stream msg", 14}, 
        {(char )'n', (char *)"Show song length", 15}, 
        {(char )'a', (char *)"Show source name", 16}, 
        {(char )'g', (char *)"Show source genre", 17}, 
        {(char )'b', (char *)"Show source bitrate", 18}, 
        {(char )'U', (char *)"Show source URL", 19}, 
        {(char )'M', (char *)"Show source mountpoint", 20}, 
        {(char )'D', (char *)"Show source description", 21}, 
        {(char )'R', (char *)"Show bytes read", 22}, 
        {(char )'W', (char *)"Show bytes written", 23}, 
        {(char )'C', (char *)"Show total connects", 24}, 
        {(char )'T', (char *)"Show connected time", 25}, 
        {(char )'\000', (char *)((void *)0), -1}};
#line 987 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_sources(com_request_t *req ) 
{ 
  int opt[26] ;
  int listed ;
  char pattern[8192] ;
  char line[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *source ;
  avl_traverser trav ;
  char *tmp___0 ;
  item_t *tmp___1 ;
  item_t *tmp___2 ;
  item_t *tmp___3 ;
  item_t *tmp___4 ;
  item_t *tmp___5 ;
  item_t *tmp___6 ;
  item_t *tmp___7 ;
  item_t *tmp___8 ;
  item_t *tmp___9 ;
  item_t *tmp___10 ;
  item_t *tmp___11 ;
  item_t *tmp___12 ;
  item_t *tmp___13 ;
  item_t *tmp___14 ;
  item_t *tmp___15 ;
  item_t *tmp___16 ;
  item_t *tmp___17 ;
  item_t *tmp___18 ;
  item_t *tmp___19 ;
  item_t *tmp___20 ;
  item_t *tmp___21 ;
  item_t *tmp___22 ;
  item_t *tmp___23 ;
  item_t *tmp___24 ;
  item_t *tmp___25 ;
  item_t *tmp___26 ;
  item_t *tmp___27 ;
  item_t *tmp___28 ;
  int tmp___29 ;
  char *ct ;
  char buf[8192] ;
  item_t *tmp___30 ;
  long tmp___31 ;
  char *tmp___32 ;
  item_t *tmp___33 ;
  item_t *tmp___34 ;
  item_t *tmp___35 ;
  item_t *tmp___36 ;
  char const   *tmp___37 ;
  item_t *tmp___38 ;
  char const   *tmp___39 ;
  item_t *tmp___40 ;
  item_t *tmp___41 ;
  char const   *tmp___42 ;
  item_t *tmp___43 ;
  item_t *tmp___44 ;
  char const   *tmp___45 ;
  item_t *tmp___46 ;
  char const   *tmp___47 ;
  item_t *tmp___48 ;
  item_t *tmp___49 ;
  item_t *tmp___50 ;
  char const   *tmp___51 ;
  item_t *tmp___52 ;
  item_t *tmp___53 ;
  char const   *tmp___54 ;
  item_t *tmp___55 ;
  char const   *tmp___56 ;
  item_t *tmp___57 ;
  item_t *tmp___58 ;
  char const   *tmp___59 ;
  item_t *tmp___60 ;
  item_t *tmp___61 ;
  char const   *tmp___62 ;
  item_t *tmp___63 ;
  char const   *tmp___64 ;
  item_t *tmp___65 ;
  item_t *tmp___66 ;
  char const   *tmp___67 ;
  item_t *tmp___68 ;
  char const   *tmp___69 ;
  item_t *tmp___70 ;
  scheme_t tmp___71 ;
  void *tmp___72 ;
  item_t *tmp___73 ;
  void *__cil_tmp86 ;
  void *__cil_tmp87 ;
  void *__cil_tmp88 ;
  void *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;

  {
  {
#line 990
  listed = 0;
  {
#line 991
  tmp = com_arg((com_request_t const   *)req);
  }
#line 991
  arg = tmp;
#line 993
  trav.init = 0;
#line 993
  trav.nstack = 0;
#line 993
  trav.p = (avl_node const   *)0;
#line 993
  trav.stack[0] = (avl_node const   *)0;
#line 993
  trav.stack[1] = (avl_node const   *)0;
#line 993
  trav.stack[2] = (avl_node const   *)0;
#line 993
  trav.stack[3] = (avl_node const   *)0;
#line 993
  trav.stack[4] = (avl_node const   *)0;
#line 993
  trav.stack[5] = (avl_node const   *)0;
#line 993
  trav.stack[6] = (avl_node const   *)0;
#line 993
  trav.stack[7] = (avl_node const   *)0;
#line 993
  trav.stack[8] = (avl_node const   *)0;
#line 993
  trav.stack[9] = (avl_node const   *)0;
#line 993
  trav.stack[10] = (avl_node const   *)0;
#line 993
  trav.stack[11] = (avl_node const   *)0;
#line 993
  trav.stack[12] = (avl_node const   *)0;
#line 993
  trav.stack[13] = (avl_node const   *)0;
#line 993
  trav.stack[14] = (avl_node const   *)0;
#line 993
  trav.stack[15] = (avl_node const   *)0;
#line 993
  trav.stack[16] = (avl_node const   *)0;
#line 993
  trav.stack[17] = (avl_node const   *)0;
#line 993
  trav.stack[18] = (avl_node const   *)0;
#line 993
  trav.stack[19] = (avl_node const   *)0;
#line 993
  trav.stack[20] = (avl_node const   *)0;
#line 993
  trav.stack[21] = (avl_node const   *)0;
#line 993
  trav.stack[22] = (avl_node const   *)0;
#line 993
  trav.stack[23] = (avl_node const   *)0;
#line 993
  trav.stack[24] = (avl_node const   *)0;
#line 993
  trav.stack[25] = (avl_node const   *)0;
#line 993
  trav.stack[26] = (avl_node const   *)0;
#line 993
  trav.stack[27] = (avl_node const   *)0;
#line 993
  trav.stack[28] = (avl_node const   *)0;
#line 993
  trav.stack[29] = (avl_node const   *)0;
#line 993
  trav.stack[30] = (avl_node const   *)0;
#line 993
  trav.stack[31] = (avl_node const   *)0;
  {
#line 995
  zero_opts(opt, 26);
  }
#line 997
  pattern[0] = (char )'\000';
  }
#line 999
  if (arg) {
#line 999
    if (*(arg + 0)) {
#line 1001
      if ((int )*(arg + 0) == 45) {
        {
        {
#line 1002
        set_opts(opt, (char const   *)arg, sourceopts, 26);
        }
        }
      } else {
        {
        {
#line 1004
        tmp___0 = splitc(pattern, arg, (char const   )' ');
        }
        }
#line 1004
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          {
          {
#line 1005
          strncpy((char */* __restrict  */)(pattern), (char const   */* __restrict  */)arg,
                  (size_t )8192);
          }
          }
        }
        {
        {
#line 1006
        set_opts(opt, (char const   *)arg, sourceopts, 26);
        }
        }
      }
    } else {
      {
      {
#line 1009
      set_opts(opt, (char const   *)info.default_sourceopts, sourceopts, 26);
      }
      }
    }
  } else {
    {
    {
#line 1009
    set_opts(opt, (char const   *)info.default_sourceopts, sourceopts, 26);
    }
    }
  }
#line 1012
  if (pattern[0]) {
    {
    {
#line 1013
    tmp___1 = item_create("Listing sources matching [%s]", "%s", (void const   *)(pattern));
    }
    {
#line 1013
    item_write_formatted_line(req, 150, (item_type_t )0, 1, tmp___1);
    }
    }
  } else {
    {
    {
#line 1016
    tmp___2 = item_create("Listing sources", "%s", (void const   *)((void *)0));
    }
    {
#line 1016
    item_write_formatted_line(req, 150, (item_type_t )0, 1, tmp___2);
    }
    }
  }
  {
  {
#line 1019
  tmp___3 = item_create("Sock", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___4 = item_create("Connected for", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___5 = item_create("Client connections", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___6 = item_create("MBytes written", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___7 = item_create("MBytes read", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___8 = item_create("Description", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___9 = item_create("Stream URL", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___10 = item_create("Stream Bitrate", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___11 = item_create("Stream Genre", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___12 = item_create("Song Length", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___13 = item_create("Stream Message", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___14 = item_create("Song URL", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___15 = item_create("Priority", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___16 = item_create("Dumpfd", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___17 = item_create("Dumpfile", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___18 = item_create("Clients", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___19 = item_create("Protocol", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___20 = item_create("Type", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___21 = item_create("State", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___22 = item_create("IP", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___23 = item_create("Time of connect", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___24 = item_create("Song Title", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___25 = item_create("Host", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___26 = item_create("Id", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___27 = item_create("Stream Name", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  tmp___28 = item_create("Mountpoint", "%s", (void const   *)((void *)0));
  }
  {
#line 1019
  item_write_formatted_line(req, 153, (item_type_t )4, 26, tmp___28, tmp___27, tmp___26,
                            tmp___25, tmp___24, tmp___23, tmp___22, tmp___21, tmp___20,
                            tmp___19, tmp___18, tmp___17, tmp___16, tmp___15, tmp___14,
                            tmp___13, tmp___12, tmp___11, tmp___10, tmp___9, tmp___8,
                            tmp___7, tmp___6, tmp___5, tmp___4, tmp___3);
  }
  {
#line 1047
  thread_mutex_lock_c(& info.source_mutex, 1047, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1049
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1049
    tmp___72 = avl_traverse(info.sources, & trav);
    }
#line 1049
    source = (connection_t *)tmp___72;
    }
#line 1049
    if (! source) {
#line 1049
      goto while_break;
    }
#line 1051
    if (pattern[0]) {
      {
      {
#line 1052
      tmp___29 = hostmatch((connection_t const   *)source, (char const   *)(pattern));
      }
      }
#line 1052
      if (! tmp___29) {
#line 1053
        goto while_continue;
      }
    }
    {
    {
#line 1055
    tmp___71 = admin_scheme(req);
    }
    }
#line 1055
    if ((unsigned int )tmp___71 == 1U) {
      {
      {
#line 1056
      build_source_con_line_with_opts(source, line, opt, 8192);
      }
      {
#line 1058
      admin_write_line((com_request_t const   *)req, (int const   )151, "%s", line);
      }
      }
    } else {
      {
#line 1060
      ct = (char *)((void *)0);
#line 1063
      buf[0] = (char )'\000';
      {
#line 1065
      tmp___30 = item_create("Sock", "%d", (void const   *)(& source->sock));
      }
      {
#line 1065
      tmp___31 = get_time();
      }
      {
#line 1065
      tmp___32 = nice_time((unsigned long )(tmp___31 - source->connect_time), buf);
      }
      {
#line 1065
      tmp___33 = item_create("Connected for", "%s", (void const   *)tmp___32);
      }
      {
#line 1065
      tmp___34 = item_create("Client connections", "%d", (void const   *)(& (source->food.source)->stats.client_connections));
      }
      {
#line 1065
      tmp___35 = item_create("MBytes written", "%d", (void const   *)(& (source->food.source)->stats.write_megs));
      }
      {
#line 1065
      tmp___36 = item_create("MBytes read", "%d", (void const   *)(& (source->food.source)->stats.read_megs));
      }
      {
#line 1065
      tmp___37 = nullcheck_string((char const   *)(source->food.source)->audiocast.description);
      }
      {
#line 1065
      tmp___38 = item_create("Description", "%s", (void const   *)tmp___37);
      }
      {
#line 1065
      tmp___39 = nullcheck_string((char const   *)(source->food.source)->audiocast.url);
      }
      {
#line 1065
      tmp___40 = item_create("Stream URL", "%s", (void const   *)tmp___39);
      }
      {
#line 1065
      tmp___41 = item_create("Stream Bitrate", "%d", (void const   *)(& (source->food.source)->audiocast.bitrate));
      }
      {
#line 1065
      tmp___42 = nullcheck_string((char const   *)(source->food.source)->audiocast.genre);
      }
      {
#line 1065
      tmp___43 = item_create("Stream Genre", "%s", (void const   *)tmp___42);
      }
      {
#line 1065
      tmp___44 = item_create("Song Length (bytes)", "%d", (void const   *)(& (source->food.source)->info.streamlength));
      }
      {
#line 1065
      tmp___45 = nullcheck_string((char const   *)(source->food.source)->info.streammsg);
      }
      {
#line 1065
      tmp___46 = item_create("Stream Message", "%s", (void const   *)tmp___45);
      }
      {
#line 1065
      tmp___47 = nullcheck_string((char const   *)(source->food.source)->info.streamurl);
      }
      {
#line 1065
      tmp___48 = item_create("Song URL", "%s", (void const   *)tmp___47);
      }
      {
#line 1065
      tmp___49 = item_create("Priority", "%d", (void const   *)(& (source->food.source)->priority));
      }
      {
#line 1065
      tmp___50 = item_create("Dumpfd", "%d", (void const   *)(& (source->food.source)->dumpfd));
      }
      {
#line 1065
      tmp___51 = nullcheck_string((char const   *)(source->food.source)->dumpfile);
      }
      {
#line 1065
      tmp___52 = item_create("Dumpfile", "%s", (void const   *)tmp___51);
      }
      {
#line 1065
      tmp___53 = item_create("Clients", "%d", (void const   *)(& (source->food.source)->num_clients));
      }
      {
#line 1065
      tmp___54 = sourceproto_to_string((source->food.source)->protocol);
      }
      {
#line 1065
      tmp___55 = item_create("Protocol", "%s", (void const   *)tmp___54);
      }
      {
#line 1065
      tmp___56 = sourcetype_to_string((source->food.source)->type);
      }
      {
#line 1065
      tmp___57 = item_create("Type", "%s", (void const   *)tmp___56);
      }
      {
#line 1065
      tmp___58 = item_create("State", "%d", (void const   *)(& (source->food.source)->connected));
      }
      {
#line 1065
      tmp___59 = nullcheck_string((char const   *)source->host);
      }
      {
#line 1065
      tmp___60 = item_create("IP", "%s", (void const   *)tmp___59);
      }
      {
#line 1065
      ct = get_string_time(source->connect_time, (char *)"%d/%b/%Y:%H:%M:%S");
      }
      {
#line 1065
      tmp___61 = item_create("Time of connect", "%s", (void const   *)ct);
      }
      {
#line 1065
      tmp___62 = nullcheck_string((char const   *)(source->food.source)->info.streamtitle);
      }
      {
#line 1065
      tmp___63 = item_create("Song Title", "%s", (void const   *)tmp___62);
      }
      {
#line 1065
      tmp___64 = nullcheck_string((char const   *)source->hostname);
      }
      {
#line 1065
      tmp___65 = item_create("Host", "%s", (void const   *)tmp___64);
      }
      {
#line 1065
      tmp___66 = item_create("Id", "%d", (void const   *)(& source->id));
      }
      {
#line 1065
      tmp___67 = nullcheck_string((char const   *)(source->food.source)->audiocast.name);
      }
      {
#line 1065
      tmp___68 = item_create("Stream Name", "%s", (void const   *)tmp___67);
      }
      {
#line 1065
      tmp___69 = nullcheck_string((char const   *)(source->food.source)->audiocast.mount);
      }
      {
#line 1065
      tmp___70 = item_create("Mountpoint", "%s", (void const   *)tmp___69);
      }
      {
#line 1065
      item_write_formatted_line(req, 151, (item_type_t )2, 26, tmp___70, tmp___68,
                                tmp___66, tmp___65, tmp___63, tmp___61, tmp___60,
                                tmp___58, tmp___57, tmp___55, tmp___53, tmp___52,
                                tmp___50, tmp___49, tmp___48, tmp___46, tmp___44,
                                tmp___43, tmp___41, tmp___40, tmp___38, tmp___36,
                                tmp___35, tmp___34, tmp___33, tmp___30);
      }
      {
#line 1093
      n_free((void *)ct, (int const   )1093, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 1093
      ct = (char *)((void *)0);
      }
    }
#line 1097
    listed ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1100
  thread_mutex_unlock_c(& info.source_mutex, 1100, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1102
  tmp___73 = item_create("End of source listing (%d listed)", "%d", (void const   *)(& listed));
  }
  {
#line 1102
  item_write_formatted_line(req, 152, (item_type_t )1, 1, tmp___73);
  }
  }
#line 1103
  return (1);
}
}
#line 1106 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_listeners(com_request_t *req ) 
{ 
  char pattern[8192] ;
  char buf[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *clicon ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  avl_traverser sourcetrav ;
  int listed ;
  time_t t ;
  long tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
  {
#line 1109
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1109
  arg = tmp;
#line 1111
  trav.init = 0;
#line 1111
  trav.nstack = 0;
#line 1111
  trav.p = (avl_node const   *)0;
#line 1111
  trav.stack[0] = (avl_node const   *)0;
#line 1111
  trav.stack[1] = (avl_node const   *)0;
#line 1111
  trav.stack[2] = (avl_node const   *)0;
#line 1111
  trav.stack[3] = (avl_node const   *)0;
#line 1111
  trav.stack[4] = (avl_node const   *)0;
#line 1111
  trav.stack[5] = (avl_node const   *)0;
#line 1111
  trav.stack[6] = (avl_node const   *)0;
#line 1111
  trav.stack[7] = (avl_node const   *)0;
#line 1111
  trav.stack[8] = (avl_node const   *)0;
#line 1111
  trav.stack[9] = (avl_node const   *)0;
#line 1111
  trav.stack[10] = (avl_node const   *)0;
#line 1111
  trav.stack[11] = (avl_node const   *)0;
#line 1111
  trav.stack[12] = (avl_node const   *)0;
#line 1111
  trav.stack[13] = (avl_node const   *)0;
#line 1111
  trav.stack[14] = (avl_node const   *)0;
#line 1111
  trav.stack[15] = (avl_node const   *)0;
#line 1111
  trav.stack[16] = (avl_node const   *)0;
#line 1111
  trav.stack[17] = (avl_node const   *)0;
#line 1111
  trav.stack[18] = (avl_node const   *)0;
#line 1111
  trav.stack[19] = (avl_node const   *)0;
#line 1111
  trav.stack[20] = (avl_node const   *)0;
#line 1111
  trav.stack[21] = (avl_node const   *)0;
#line 1111
  trav.stack[22] = (avl_node const   *)0;
#line 1111
  trav.stack[23] = (avl_node const   *)0;
#line 1111
  trav.stack[24] = (avl_node const   *)0;
#line 1111
  trav.stack[25] = (avl_node const   *)0;
#line 1111
  trav.stack[26] = (avl_node const   *)0;
#line 1111
  trav.stack[27] = (avl_node const   *)0;
#line 1111
  trav.stack[28] = (avl_node const   *)0;
#line 1111
  trav.stack[29] = (avl_node const   *)0;
#line 1111
  trav.stack[30] = (avl_node const   *)0;
#line 1111
  trav.stack[31] = (avl_node const   *)0;
#line 1111
  sourcetrav.init = 0;
#line 1111
  sourcetrav.nstack = 0;
#line 1111
  sourcetrav.p = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[0] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[1] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[2] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[3] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[4] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[5] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[6] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[7] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[8] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[9] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[10] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[11] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[12] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[13] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[14] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[15] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[16] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[17] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[18] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[19] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[20] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[21] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[22] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[23] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[24] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[25] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[26] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[27] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[28] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[29] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[30] = (avl_node const   *)0;
#line 1111
  sourcetrav.stack[31] = (avl_node const   *)0;
#line 1112
  listed = 0;
  {
#line 1113
  tmp___0 = get_time();
  }
#line 1113
  t = tmp___0;
#line 1115
  pattern[0] = (char )'\000';
  }
#line 1117
  if (arg) {
#line 1117
    if (*(arg + 0)) {
      {
      {
#line 1119
      strncpy((char */* __restrict  */)(pattern), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      {
#line 1120
      admin_write_line((com_request_t const   *)req, (int const   )160, "Listing listeners matching [%s]:",
                       pattern);
      }
      }
    } else {
      {
      {
#line 1122
      admin_write_line((com_request_t const   *)req, (int const   )160, "Listing listeners");
      }
      }
    }
  } else {
    {
    {
#line 1122
    admin_write_line((com_request_t const   *)req, (int const   )160, "Listing listeners");
    }
    }
  }
  {
  {
#line 1125
  thread_mutex_lock_c(& info.double_mutex, 1125, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1126
  thread_mutex_lock_c(& info.source_mutex, 1126, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1128
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1128
    tmp___8 = avl_traverse(info.sources, & sourcetrav);
    }
#line 1128
    sourcecon = (connection_t *)tmp___8;
    }
#line 1128
    if (! sourcecon) {
#line 1128
      goto while_break;
    }
    {
    {
#line 1130
    zero_trav(& trav);
    }
    {
#line 1132
    thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 1132, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 1134
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 1134
      tmp___7 = avl_traverse((sourcecon->food.source)->clients, & trav);
      }
#line 1134
      clicon = (connection_t *)tmp___7;
      }
#line 1134
      if (! clicon) {
#line 1134
        goto while_break___0;
      }
#line 1136
      if (pattern[0]) {
        {
        {
#line 1137
        tmp___1 = hostmatch((connection_t const   *)clicon, (char const   *)(pattern));
        }
        }
#line 1137
        if (! tmp___1) {
#line 1138
          goto while_continue___0;
        }
      }
      {
#line 1139
      listed ++;
      {
#line 1140
      tmp___2 = client_type((connection_t const   *)clicon);
      }
      {
#line 1140
      tmp___3 = get_user_agent(clicon);
      }
      {
#line 1140
      tmp___4 = client_errors((client_t const   *)clicon->food.client);
      }
      {
#line 1140
      tmp___5 = nice_time((unsigned long )(t - clicon->connect_time), buf);
      }
      {
#line 1140
      tmp___6 = con_host(clicon);
      }
      {
#line 1140
      admin_write_line((com_request_t const   *)req, (int const   )161, "[Host: %s] [Mountpoint %s] [Id: %ld] [Connected for: %s] [Source Id: %ld] [Bytes written: %ld] [Errors: %d] [User agent: %s] [Type: %s]",
                       tmp___6, (sourcecon->food.source)->audiocast.mount, clicon->id,
                       tmp___5, sourcecon->id, (clicon->food.client)->write_bytes,
                       tmp___4, tmp___3, tmp___2);
      }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1146
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 1146, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1150
  thread_mutex_unlock_c(& info.source_mutex, 1150, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1151
  thread_mutex_unlock_c(& info.double_mutex, 1151, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1153
  admin_write_line((com_request_t const   *)req, (int const   )162, "End of listener listing (%d listed)",
                   listed);
  }
  }
#line 1154
  return (1);
}
}
#line 1157 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_rehash(com_request_t *req ) 
{ 
  char *oldlogfile ;
  char *oldaccessfile ;
  char *oldusagefile ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1160
  oldlogfile = info.logfilename;
#line 1161
  oldaccessfile = info.accessfilename;
#line 1162
  oldusagefile = info.usagefilename;
  {
#line 1163
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1163
  arg = tmp;
  }
#line 1165
  if (arg) {
#line 1165
    tmp___0 = arg;
  } else {
#line 1165
    tmp___0 = info.configfile;
  }
  {
  {
#line 1165
  admin_write_line((com_request_t const   *)req, (int const   )170, "Reading configfile %s",
                   tmp___0);
  }
  }
#line 1166
  if (arg) {
#line 1166
    tmp___1 = arg;
  } else {
#line 1166
    tmp___1 = info.configfile;
  }
  {
  {
#line 1166
  write_log_not_me(0, req->con, (char *)"Reading configfile %s", tmp___1);
  }
  }
#line 1168
  if (arg) {
#line 1168
    if (*(arg + 0)) {
      {
      {
#line 1169
      parse_config_file(arg);
      }
      }
    } else {
      {
      {
#line 1171
      parse_default_config_file();
      }
      }
    }
  } else {
    {
    {
#line 1171
    parse_default_config_file();
    }
    }
  }
#line 1173
  if ((unsigned long )oldlogfile != (unsigned long )info.logfilename) {
    {
    {
#line 1175
    open_log_files();
    }
    }
  } else
#line 1173
  if ((unsigned long )oldusagefile != (unsigned long )info.usagefilename) {
    {
    {
#line 1175
    open_log_files();
    }
    }
  } else
#line 1173
  if ((unsigned long )oldaccessfile != (unsigned long )info.accessfilename) {
    {
    {
#line 1175
    open_log_files();
    }
    }
  }
#line 1178
  return (1);
}
}
#line 1181 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_uptime(com_request_t *req ) 
{ 
  char timebuf[8192] ;
  int i ;
  long tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 1185
  tmp = get_time();
  }
#line 1185
  i = (int )(tmp - info.server_start_time);
  {
#line 1187
  tmp___0 = nice_time((unsigned long )i, timebuf);
  }
  {
#line 1187
  tmp___1 = nullcheck_string((char const   *)info.server_name);
  }
  {
#line 1187
  admin_write_line((com_request_t const   *)req, (int const   )180, "Icecast %s server running on %s default port %d, uptime: %s",
                   "1.3.12", tmp___1, info.port[0], tmp___0);
  }
  }
#line 1188
  return (1);
}
}
#line 1191 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_tell(com_request_t *req ) 
{ 
  char buf[8192] ;
  avl_traverser trav ;
  connection_t *con2 ;
  char *arg ;
  char *tmp ;
  void *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1195
  trav.init = 0;
#line 1195
  trav.nstack = 0;
#line 1195
  trav.p = (avl_node const   *)0;
#line 1195
  trav.stack[0] = (avl_node const   *)0;
#line 1195
  trav.stack[1] = (avl_node const   *)0;
#line 1195
  trav.stack[2] = (avl_node const   *)0;
#line 1195
  trav.stack[3] = (avl_node const   *)0;
#line 1195
  trav.stack[4] = (avl_node const   *)0;
#line 1195
  trav.stack[5] = (avl_node const   *)0;
#line 1195
  trav.stack[6] = (avl_node const   *)0;
#line 1195
  trav.stack[7] = (avl_node const   *)0;
#line 1195
  trav.stack[8] = (avl_node const   *)0;
#line 1195
  trav.stack[9] = (avl_node const   *)0;
#line 1195
  trav.stack[10] = (avl_node const   *)0;
#line 1195
  trav.stack[11] = (avl_node const   *)0;
#line 1195
  trav.stack[12] = (avl_node const   *)0;
#line 1195
  trav.stack[13] = (avl_node const   *)0;
#line 1195
  trav.stack[14] = (avl_node const   *)0;
#line 1195
  trav.stack[15] = (avl_node const   *)0;
#line 1195
  trav.stack[16] = (avl_node const   *)0;
#line 1195
  trav.stack[17] = (avl_node const   *)0;
#line 1195
  trav.stack[18] = (avl_node const   *)0;
#line 1195
  trav.stack[19] = (avl_node const   *)0;
#line 1195
  trav.stack[20] = (avl_node const   *)0;
#line 1195
  trav.stack[21] = (avl_node const   *)0;
#line 1195
  trav.stack[22] = (avl_node const   *)0;
#line 1195
  trav.stack[23] = (avl_node const   *)0;
#line 1195
  trav.stack[24] = (avl_node const   *)0;
#line 1195
  trav.stack[25] = (avl_node const   *)0;
#line 1195
  trav.stack[26] = (avl_node const   *)0;
#line 1195
  trav.stack[27] = (avl_node const   *)0;
#line 1195
  trav.stack[28] = (avl_node const   *)0;
#line 1195
  trav.stack[29] = (avl_node const   *)0;
#line 1195
  trav.stack[30] = (avl_node const   *)0;
#line 1195
  trav.stack[31] = (avl_node const   *)0;
  {
#line 1197
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1197
  arg = tmp;
  }
#line 1199
  if (! arg) {
    {
    {
#line 1201
    admin_write_line((com_request_t const   *)req, (int const   )191, "Don\'t be so modest, spit it out :)");
    }
    }
#line 1202
    return (1);
  } else
#line 1199
  if (! *(arg + 0)) {
    {
    {
#line 1201
    admin_write_line((com_request_t const   *)req, (int const   )191, "Don\'t be so modest, spit it out :)");
    }
    }
#line 1202
    return (1);
  }
  {
  {
#line 1205
  snprintf((char */* __restrict  */)(buf), (size_t )8192, (char const   */* __restrict  */)"Admin %ld said: [%s]\r\n-> ",
           (req->con)->id, arg);
  }
  {
#line 1207
  thread_mutex_lock_c(& info.admin_mutex, 1207, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1209
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1209
    tmp___0 = avl_traverse(info.admins, & trav);
    }
#line 1209
    con2 = (connection_t *)tmp___0;
    }
#line 1209
    if (! con2) {
#line 1209
      goto while_break;
    }
#line 1211
    if (con2->id != (req->con)->id) {
      {
      {
#line 1212
      sock_write_line(con2->sock, "M%d %s", 190, buf);
      }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1215
  thread_mutex_unlock_c(& info.admin_mutex, 1215, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 1216
  return (1);
}
}
#line 1222 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_stats(com_request_t *req ) 
{ 
  unsigned long verb ;
  statistics_t stat___0 ;
  time_t t ;
  unsigned long extra_clientconnections ;
  unsigned long extra_sourceconnections ;
  char *arg ;
  char *tmp ;
  char timebuf[8192] ;
  int tmp___0 ;
  statistics_t cs ;
  statistics_t cs___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  unsigned long tmp___9 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 1225
  verb = 0UL;
#line 1228
  extra_clientconnections = 0UL;
#line 1229
  extra_sourceconnections = 0UL;
  {
#line 1230
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1230
  arg = tmp;
  }
#line 1233
  if (arg) {
    {
    {
#line 1233
    tmp___0 = ice_strncmp((char const   *)arg, "-v", (size_t )2);
    }
    }
#line 1233
    if (tmp___0 == 0) {
#line 1234
      verb = 1UL;
    }
  }
  {
  {
#line 1236
  zero_stats(& stat___0);
  }
  }
#line 1238
  if (arg) {
#line 1238
    if (*(arg + 0)) {
      {
      {
#line 1240
      tmp___3 = ice_strcmp((char const   *)arg, "daily");
      }
      }
#line 1240
      if (tmp___3 == 0) {
        {
        {
#line 1243
        get_current_stats(& cs);
        }
        {
#line 1244
        add_stats(& stat___0, & cs, 0UL);
        }
        {
#line 1246
        get_hourly_stats(& cs);
        }
        {
#line 1247
        add_stats(& stat___0, & cs, 0UL);
        }
        {
#line 1249
        get_daily_stats(& cs);
        }
        {
#line 1250
        add_stats(& stat___0, & cs, 1000UL);
        }
#line 1252
        extra_sourceconnections = info.num_sources;
#line 1253
        extra_clientconnections = info.num_clients;
        {
#line 1254
        admin_write_line((com_request_t const   *)req, (int const   )200, "Following info is for the last day:");
        }
        }
      } else {
        {
        {
#line 1255
        tmp___2 = ice_strcmp((char const   *)arg, "hourly");
        }
        }
#line 1255
        if (tmp___2 == 0) {
          {
          {
#line 1258
          get_current_stats(& cs___0);
          }
          {
#line 1259
          add_stats(& stat___0, & cs___0, 0UL);
          }
          {
#line 1261
          get_hourly_stats(& cs___0);
          }
          {
#line 1262
          add_stats(& stat___0, & cs___0, 0UL);
          }
#line 1263
          extra_sourceconnections = info.num_sources;
#line 1264
          extra_clientconnections = info.num_clients;
          {
#line 1265
          admin_write_line((com_request_t const   *)req, (int const   )201, "Following info is for the last hour:");
          }
          }
        } else {
          {
          {
#line 1266
          tmp___1 = ice_strcmp((char const   *)arg, "clear");
          }
          }
#line 1266
          if (tmp___1 == 0) {
            {
            {
#line 1268
            admin_write_line((com_request_t const   *)req, (int const   )202, "Clearing stats...");
            }
            {
#line 1269
            write_log(0, (char *)"Clearing stats...");
            }
            {
#line 1270
            thread_mutex_lock_c(& info.misc_mutex, 1270, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1271
            zero_stats(& info.daily_stats);
            }
            {
#line 1272
            zero_stats(& info.hourly_stats);
            }
            {
#line 1273
            zero_stats(& info.total_stats);
            }
            {
#line 1274
            thread_mutex_unlock_c(& info.misc_mutex, 1274, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1277
            thread_mutex_lock_c(& info.double_mutex, 1277, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1278
            thread_mutex_lock_c(& info.source_mutex, 1278, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1279
            avl_walk(info.sources, & clear_source_stats, (void *)(& info));
            }
            {
#line 1280
            thread_mutex_unlock_c(& info.source_mutex, 1280, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1281
            thread_mutex_unlock_c(& info.double_mutex, 1281, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1283
            thread_mutex_lock_c(& info.admin_mutex, 1283, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            {
#line 1284
            avl_walk(info.admins, & clear_admin_stats, (void *)(& info));
            }
            {
#line 1285
            thread_mutex_unlock_c(& info.admin_mutex, 1285, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
            }
            }
          } else {
            {
            {
#line 1287
            admin_write_line((com_request_t const   *)req, (int const   )203, "Unknown stats type %s",
                             arg);
            }
            }
#line 1288
            return (1);
          }
        }
      }
    } else {
      {
      {
#line 1291
      admin_write_line((com_request_t const   *)req, (int const   )204, "Following info is server total:");
      }
      {
#line 1292
      get_running_stats(& stat___0);
      }
      }
    }
  } else {
    {
    {
#line 1291
    admin_write_line((com_request_t const   *)req, (int const   )204, "Following info is server total:");
    }
    {
#line 1292
    get_running_stats(& stat___0);
    }
    }
  }
  {
  {
#line 1295
  t = get_time();
  }
  {
#line 1297
  tmp___4 = nice_time((unsigned long )(t - info.server_start_time), timebuf);
  }
  {
#line 1297
  tmp___5 = nullcheck_string((char const   *)info.server_name);
  }
  {
#line 1297
  admin_write_line((com_request_t const   *)req, (int const   )180, "Icecast %s server running on %s default port %d, uptime: %s",
                   "1.3.12", tmp___5, info.port[0], tmp___4);
  }
  {
#line 1300
  admin_write_line((com_request_t const   *)req, (int const   )205, "Admins (%d):",
                   info.num_admins);
  }
  {
#line 1301
  admin_write_line((com_request_t const   *)req, (int const   )206, "Sources (%d):",
                   info.num_sources);
  }
  {
#line 1302
  admin_write_line((com_request_t const   *)req, (int const   )207, "Listeners (%d):",
                   info.num_clients);
  }
  {
#line 1304
  admin_write_line((com_request_t const   *)req, (int const   )208, "Displaying server statistics:");
  }
  {
#line 1305
  admin_write_line((com_request_t const   *)req, (int const   )209, "Total Mbytes read: %lu",
                   stat___0.read_bytes);
  }
  {
#line 1306
  admin_write_line((com_request_t const   *)req, (int const   )210, "Total Mbytes written: %lu",
                   stat___0.write_bytes);
  }
  {
#line 1307
  admin_write_line((com_request_t const   *)req, (int const   )211, "Number of source connects: %lu",
                   stat___0.source_connections);
  }
  {
#line 1308
  admin_write_line((com_request_t const   *)req, (int const   )212, "Number of client connects: %lu",
                   stat___0.client_connections);
  }
  }
#line 1310
  if (stat___0.client_connections > 0UL) {
    {
    {
#line 1312
    tmp___6 = connect_average(stat___0.client_connect_time, stat___0.client_connections + extra_clientconnections,
                              timebuf);
    }
    {
#line 1312
    admin_write_line((com_request_t const   *)req, (int const   )213, "Average listener time: %s",
                     tmp___6);
    }
    {
#line 1314
    tmp___7 = transfer_average(stat___0.write_bytes, stat___0.client_connections + extra_clientconnections);
    }
    {
#line 1314
    admin_write_line((com_request_t const   *)req, (int const   )214, "Average listener transfer: %lu Mbytes",
                     tmp___7);
    }
    }
  }
#line 1318
  if (stat___0.source_connections > 0UL) {
    {
    {
#line 1320
    tmp___8 = connect_average(stat___0.source_connect_time, stat___0.source_connections + extra_sourceconnections,
                              timebuf);
    }
    {
#line 1320
    admin_write_line((com_request_t const   *)req, (int const   )215, "Average source connect time: %s",
                     tmp___8);
    }
    {
#line 1322
    tmp___9 = transfer_average(stat___0.read_bytes, stat___0.source_connections + extra_sourceconnections);
    }
    {
#line 1322
    admin_write_line((com_request_t const   *)req, (int const   )216, "Average source transfer: %lu Mbytes",
                     tmp___9);
    }
    }
  }
  {
  {
#line 1326
  admin_write_line((com_request_t const   *)req, (int const   )217, "End of statistics");
  }
  }
#line 1327
  return (1);
}
}
#line 1330 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_shutdown(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 1332
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1332
  arg = tmp;
  {
#line 1334
  admin_write_line((com_request_t const   *)req, (int const   )230, "Ok, killing server, bye!");
  }
  }
#line 1336
  if (arg) {
#line 1336
    if (*(arg + 0)) {
      {
      {
#line 1337
      com_tell(req);
      }
      }
    }
  }
#line 1339
  running = 0;
#line 1341
  return (1);
}
}
#line 1344 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_oper(com_request_t *req ) 
{ 
  admin_t *adm ;
  char *arg ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 1348
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1348
  arg = tmp;
  }
#line 1350
  if (! arg) {
    {
    {
#line 1352
    admin_write_line((com_request_t const   *)req, (int const   )240, "*hint* The password is longer than that :)");
    }
    }
#line 1353
    return (1);
  }
  {
#line 1356
  adm = (req->con)->food.admin;
  {
#line 1358
  tmp___1 = password_match((char const   *)info.oper_pass, (char const   *)arg);
  }
  }
#line 1358
  if (tmp___1) {
    {
#line 1360
    adm->oper = 1U;
    {
#line 1361
    admin_write_line((com_request_t const   *)req, (int const   )241, "You are now an icecast operator");
    }
    {
#line 1362
    tmp___0 = con_host(req->con);
    }
    {
#line 1362
    write_log(0, (char *)"Admin %s[%i] is now an icecast operator", tmp___0, (req->con)->id);
    }
    }
  } else {
    {
    {
#line 1364
    admin_write_line((com_request_t const   *)req, (int const   )240, "Invalid password");
    }
    }
  }
#line 1365
  return (1);
}
}
#line 1368 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_quit(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char message[8207] ;
  char const   *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 1371
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1371
  arg = tmp;
  }
#line 1373
  if ((req->con)->host) {
    {
    {
#line 1373
    tmp___1 = ice_strcmp((char const   *)(req->con)->host, "icecast console");
    }
    }
#line 1373
    if (tmp___1 == 0) {
      {
      {
#line 1375
      fd_write_line(1, "Sorry, you can\'t quit from the local admin console");
      }
      {
#line 1376
      fd_write_line(1, "Use \'shutdown\' to bring the server down");
      }
      }
    } else {
#line 1373
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1379
    if (arg) {
#line 1379
      tmp___0 = (char const   *)arg;
    } else {
#line 1379
      tmp___0 = "No message";
    }
    {
    {
#line 1379
    snprintf((char */* __restrict  */)(message), (size_t )8207, (char const   */* __restrict  */)"Admin quit: %s",
             tmp___0);
    }
    {
#line 1380
    admin_write_line((com_request_t const   *)req, (int const   )500, "Uh, ok, bye!");
    }
    {
#line 1381
    kick_connection((void *)req->con, (void *)(message));
    }
    }
  }
#line 1383
  return (1);
}
}
#line 1386 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_touch(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 1389
  admin_write_line((com_request_t const   *)req, (int const   )250, "Touching directory servers");
  }
  {
#line 1391
  info.directorylasttime = get_time();
  }
  {
#line 1393
  thread_mutex_lock_c(& info.directory_mutex, 1393, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1394
  avl_walk(info.d_servers, & avl_touch_directory, (void *)(& info));
  }
  {
#line 1395
  thread_mutex_unlock_c(& info.directory_mutex, 1395, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 1397
  return (1);
}
}
#line 1401 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_dir(com_request_t *req ) 
{ 
  char *out ;
  char *arg ;
  char *tmp ;
  char type[8192] ;
  char host[8192] ;
  char port[8192] ;
  directory_server_t *dir ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  directory_server_t *out___0 ;
  directory_server_t ds ;
  char *ptr ;
  void *tmp___6 ;
  int listed ;
  avl_traverser trav ;
  directory_server_t *dir___0 ;
  void *tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
  {
#line 1404
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1404
  arg = tmp;
  }
#line 1407
  if (! arg) {
    {
    {
#line 1409
    admin_write((com_request_t const   *)req, (int const   )260, "dir <add|del|list> [options|number]\r\n");
    }
    }
#line 1410
    return (1);
  } else
#line 1407
  if (! *(arg + 0)) {
    {
    {
#line 1409
    admin_write((com_request_t const   *)req, (int const   )260, "dir <add|del|list> [options|number]\r\n");
    }
    }
#line 1410
    return (1);
  }
  {
  {
#line 1413
  out = splitc(type, arg, (char const   )' ');
  }
  }
#line 1415
  if (! out) {
    {
    {
#line 1416
    strncpy((char */* __restrict  */)(type), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
#line 1418
  if ((int )type[0] == 97) {
#line 1423
    if (! out) {
      {
      {
#line 1425
      admin_write((com_request_t const   *)req, (int const   )260, "dir <add|del|list> [options|number]\r\n");
      }
      }
#line 1426
      return (1);
    }
    {
    {
#line 1429
    dir = create_directory();
    }
#line 1430
    dir->counter = 0;
#line 1431
    dir->id = -1;
#line 1432
    dir->type = (protocol_t )1;
#line 1433
    dir->host = (char *)((void *)0);
#line 1434
    dir->path = (char *)((void *)0);
    {
#line 1436
    tmp___0 = strchr((char const   *)arg, '/');
    }
    }
#line 1436
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      {
      {
#line 1436
      tmp___1 = strchr((char const   *)arg, ':');
      }
      }
#line 1436
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
        {
#line 1438
        admin_write_line((com_request_t const   *)req, (int const   )260, "ERROR in directory syntax. Path but no port specified");
        }
        }
#line 1439
        return (1);
      }
    }
    {
    {
#line 1442
    tmp___3 = strstr((char const   *)arg, " icy");
    }
    }
#line 1442
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
      {
#line 1444
      dir->type = (protocol_t )0;
      {
#line 1445
      tmp___2 = strchr((char const   *)arg, ' ');
      }
#line 1445
      *tmp___2 = (char )'\000';
      }
    }
    {
    {
#line 1448
    tmp___5 = splitc(host, arg, (char const   )':');
    }
    }
#line 1448
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
      {
#line 1450
      dir->port = 80;
      {
#line 1451
      dir->path = n_strdup("cgi-bin/touch", (int const   )1451, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
      {
#line 1452
      strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      }
    } else {
      {
      {
#line 1453
      tmp___4 = splitc(port, arg, (char const   )'/');
      }
      }
#line 1453
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
        {
        {
#line 1455
        dir->port = atoi((char const   *)arg);
        }
        {
#line 1456
        dir->path = n_strdup("cgi-bin/touch", (int const   )1456, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        }
      } else {
        {
        {
#line 1458
        dir->port = atoi((char const   *)(port));
        }
        {
#line 1459
        dir->path = n_strdup((char const   *)arg, (int const   )1459, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
        }
      }
    }
    {
    {
#line 1462
    dir->host = n_strdup((char const   *)(host), (int const   )1462, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1464
    if ((unsigned int )dir->type == 0U) {
      {
      {
#line 1465
      admin_write_line((com_request_t const   *)req, (int const   )261, "Adding icy directory server [%s:%d]",
                       dir->host, dir->port);
      }
      }
    } else {
      {
      {
#line 1467
      admin_write_line((com_request_t const   *)req, (int const   )262, "Adding xaudiocast directory server [%s:%d/%s]",
                       dir->host, dir->port, dir->path);
      }
      }
    }
    {
    {
#line 1469
    thread_mutex_lock_c(& info.directory_mutex, 1469, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1470
    avl_insert(info.d_servers, (void *)dir);
    }
    {
#line 1471
    thread_mutex_unlock_c(& info.directory_mutex, 1471, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1473
    return (1);
  }
#line 1476
  if ((int )type[0] == 100) {
    {
    {
#line 1481
    ptr = strchr((char const   *)arg, ':');
    }
    }
#line 1481
    if (ptr) {
      {
#line 1483
      *ptr = (char )'\000';
      {
#line 1484
      ds.port = atoi((char const   *)(ptr + 1));
      }
#line 1485
      ds.host = arg + 0;
      }
    } else {
#line 1487
      ds.port = 80;
#line 1488
      ds.host = arg + 0;
    }
    {
    {
#line 1491
    thread_mutex_lock_c(& info.directory_mutex, 1491, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1492
    tmp___6 = avl_delete(info.d_servers, (void const   *)(& ds));
    }
#line 1492
    out___0 = (directory_server_t *)tmp___6;
    {
#line 1493
    thread_mutex_unlock_c(& info.directory_mutex, 1493, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1495
    if (out___0) {
#line 1495
      if (out___0->id >= 0) {
#line 1495
        if ((unsigned int )out___0->type == 0U) {
          {
          {
#line 1496
          directory_remove(out___0);
          }
          }
        }
      }
    }
#line 1498
    if (out___0) {
      {
      {
#line 1500
      admin_write_line((com_request_t const   *)req, (int const   )263, "Directory server [%s:%d] removed",
                       out___0->host, out___0->port);
      }
      {
#line 1501
      n_free((void *)out___0->host, (int const   )1501, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 1501
      out___0->host = (char *)((void *)0);
      {
#line 1502
      n_free((void *)out___0->path, (int const   )1502, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 1502
      out___0->path = (char *)((void *)0);
      {
#line 1503
      n_free((void *)out___0, (int const   )1503, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 1503
      out___0 = (directory_server_t *)((void *)0);
      }
    } else {
      {
      {
#line 1505
      admin_write_line((com_request_t const   *)req, (int const   )264, "Directory removal failed.");
      }
      }
    }
  }
#line 1509
  if ((int )type[0] == 108) {
    {
#line 1511
    listed = 0;
#line 1512
    trav.init = 0;
#line 1512
    trav.nstack = 0;
#line 1512
    trav.p = (avl_node const   *)0;
#line 1512
    trav.stack[0] = (avl_node const   *)0;
#line 1512
    trav.stack[1] = (avl_node const   *)0;
#line 1512
    trav.stack[2] = (avl_node const   *)0;
#line 1512
    trav.stack[3] = (avl_node const   *)0;
#line 1512
    trav.stack[4] = (avl_node const   *)0;
#line 1512
    trav.stack[5] = (avl_node const   *)0;
#line 1512
    trav.stack[6] = (avl_node const   *)0;
#line 1512
    trav.stack[7] = (avl_node const   *)0;
#line 1512
    trav.stack[8] = (avl_node const   *)0;
#line 1512
    trav.stack[9] = (avl_node const   *)0;
#line 1512
    trav.stack[10] = (avl_node const   *)0;
#line 1512
    trav.stack[11] = (avl_node const   *)0;
#line 1512
    trav.stack[12] = (avl_node const   *)0;
#line 1512
    trav.stack[13] = (avl_node const   *)0;
#line 1512
    trav.stack[14] = (avl_node const   *)0;
#line 1512
    trav.stack[15] = (avl_node const   *)0;
#line 1512
    trav.stack[16] = (avl_node const   *)0;
#line 1512
    trav.stack[17] = (avl_node const   *)0;
#line 1512
    trav.stack[18] = (avl_node const   *)0;
#line 1512
    trav.stack[19] = (avl_node const   *)0;
#line 1512
    trav.stack[20] = (avl_node const   *)0;
#line 1512
    trav.stack[21] = (avl_node const   *)0;
#line 1512
    trav.stack[22] = (avl_node const   *)0;
#line 1512
    trav.stack[23] = (avl_node const   *)0;
#line 1512
    trav.stack[24] = (avl_node const   *)0;
#line 1512
    trav.stack[25] = (avl_node const   *)0;
#line 1512
    trav.stack[26] = (avl_node const   *)0;
#line 1512
    trav.stack[27] = (avl_node const   *)0;
#line 1512
    trav.stack[28] = (avl_node const   *)0;
#line 1512
    trav.stack[29] = (avl_node const   *)0;
#line 1512
    trav.stack[30] = (avl_node const   *)0;
#line 1512
    trav.stack[31] = (avl_node const   *)0;
    {
#line 1515
    admin_write_line((com_request_t const   *)req, (int const   )265, "Listing directories: ");
    }
    {
#line 1517
    thread_mutex_lock_c(& info.directory_mutex, 1517, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 1519
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1519
      tmp___7 = avl_traverse(info.d_servers, & trav);
      }
#line 1519
      dir___0 = (directory_server_t *)tmp___7;
      }
#line 1519
      if (! dir___0) {
#line 1519
        goto while_break;
      }
      {
      {
#line 1521
      admin_write_line((com_request_t const   *)req, (int const   )266, "[Host: %s] [Id: %d] [Touches: %d]",
                       dir___0->host, dir___0->id, dir___0->counter);
      }
#line 1522
      listed ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1525
    thread_mutex_unlock_c(& info.directory_mutex, 1525, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1527
    admin_write_line((com_request_t const   *)req, (int const   )267, "End of directory listing (%d listed)",
                     listed);
    }
    }
  }
#line 1529
  return (1);
}
}
#line 1532 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_kick(com_request_t *req ) 
{ 
  char buf[8192] ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  char reason[8192] ;
  void *tmp___1 ;
  connection_t *kick ;
  int tmp___2 ;
  connection_t *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
  {
  {
#line 1535
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1535
  arg = tmp;
  }
#line 1537
  if (! arg) {
    {
    {
#line 1539
    admin_write_line((com_request_t const   *)req, (int const   )280, "kick <id>");
    }
    }
#line 1540
    return (1);
  } else
#line 1537
  if (! *(arg + 0)) {
    {
    {
#line 1539
    admin_write_line((com_request_t const   *)req, (int const   )280, "kick <id>");
    }
    }
#line 1540
    return (1);
  }
  {
  {
#line 1543
  tmp___0 = splitc(buf, arg, (char const   )' ');
  }
  }
#line 1543
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 1544
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
#line 1546
  if ((int )buf[0] == 45) {
    {
#line 1549
    trav.init = 0;
#line 1549
    trav.nstack = 0;
#line 1549
    trav.p = (avl_node const   *)0;
#line 1549
    trav.stack[0] = (avl_node const   *)0;
#line 1549
    trav.stack[1] = (avl_node const   *)0;
#line 1549
    trav.stack[2] = (avl_node const   *)0;
#line 1549
    trav.stack[3] = (avl_node const   *)0;
#line 1549
    trav.stack[4] = (avl_node const   *)0;
#line 1549
    trav.stack[5] = (avl_node const   *)0;
#line 1549
    trav.stack[6] = (avl_node const   *)0;
#line 1549
    trav.stack[7] = (avl_node const   *)0;
#line 1549
    trav.stack[8] = (avl_node const   *)0;
#line 1549
    trav.stack[9] = (avl_node const   *)0;
#line 1549
    trav.stack[10] = (avl_node const   *)0;
#line 1549
    trav.stack[11] = (avl_node const   *)0;
#line 1549
    trav.stack[12] = (avl_node const   *)0;
#line 1549
    trav.stack[13] = (avl_node const   *)0;
#line 1549
    trav.stack[14] = (avl_node const   *)0;
#line 1549
    trav.stack[15] = (avl_node const   *)0;
#line 1549
    trav.stack[16] = (avl_node const   *)0;
#line 1549
    trav.stack[17] = (avl_node const   *)0;
#line 1549
    trav.stack[18] = (avl_node const   *)0;
#line 1549
    trav.stack[19] = (avl_node const   *)0;
#line 1549
    trav.stack[20] = (avl_node const   *)0;
#line 1549
    trav.stack[21] = (avl_node const   *)0;
#line 1549
    trav.stack[22] = (avl_node const   *)0;
#line 1549
    trav.stack[23] = (avl_node const   *)0;
#line 1549
    trav.stack[24] = (avl_node const   *)0;
#line 1549
    trav.stack[25] = (avl_node const   *)0;
#line 1549
    trav.stack[26] = (avl_node const   *)0;
#line 1549
    trav.stack[27] = (avl_node const   *)0;
#line 1549
    trav.stack[28] = (avl_node const   *)0;
#line 1549
    trav.stack[29] = (avl_node const   *)0;
#line 1549
    trav.stack[30] = (avl_node const   *)0;
#line 1549
    trav.stack[31] = (avl_node const   *)0;
    {
#line 1551
    snprintf((char */* __restrict  */)(reason), (size_t )8192, (char const   */* __restrict  */)"Matching (%s)",
             arg);
    }
    }
    {
#line 1555
    if ((int )buf[1] == 97) {
#line 1555
      goto case_97;
    }
#line 1562
    if ((int )buf[1] == 115) {
#line 1562
      goto case_115;
    }
#line 1569
    if ((int )buf[1] == 99) {
#line 1569
      goto case_99;
    }
#line 1585
    goto switch_default;
    case_97: /* CIL Label */ 
    {
    {
#line 1556
    admin_write_line((com_request_t const   *)req, (int const   )281, "Kicking all admins matching (%s)",
                     arg);
    }
    {
#line 1557
    thread_mutex_lock_c(& info.admin_mutex, 1557, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1558
    do_if_match_tree(info.admins, arg, & kick_connection_not_me, (void *)(reason),
                     1);
    }
    {
#line 1559
    thread_mutex_unlock_c(& info.admin_mutex, 1559, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1560
    return (1);
#line 1561
    goto switch_break;
    case_115: /* CIL Label */ 
    {
    {
#line 1563
    admin_write_line((com_request_t const   *)req, (int const   )282, "Kicking all sources matching (%s)",
                     arg);
    }
    {
#line 1564
    thread_mutex_lock_c(& info.source_mutex, 1564, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1565
    do_if_match_tree(info.sources, arg, & kick_connection, (void *)(reason), 0);
    }
    {
#line 1566
    thread_mutex_unlock_c(& info.source_mutex, 1566, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1567
    return (1);
#line 1568
    goto switch_break;
    case_99: /* CIL Label */ 
    {
    {
#line 1570
    admin_write_line((com_request_t const   *)req, (int const   )283, "Kicking all clients matching (%s)",
                     arg);
    }
    {
#line 1572
    thread_mutex_lock_c(& info.double_mutex, 1572, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1573
    thread_mutex_lock_c(& info.source_mutex, 1573, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 1574
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 1574
      tmp___1 = avl_traverse(info.sources, & trav);
      }
#line 1574
      sourcecon = (connection_t *)tmp___1;
      }
#line 1574
      if (! sourcecon) {
#line 1574
        goto while_break;
      }
      {
      {
#line 1576
      thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 1576, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
      {
#line 1577
      do_if_match_tree((sourcecon->food.source)->clients, arg, & kick_connection,
                       (void *)(reason), 0);
      }
      {
#line 1579
      thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 1579, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 1581
    thread_mutex_unlock_c(& info.source_mutex, 1581, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 1582
    thread_mutex_unlock_c(& info.double_mutex, 1582, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1583
    return (1);
#line 1584
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 1586
    admin_write_line((com_request_t const   *)req, (int const   )280, "Try \'help kick\'");
    }
    }
#line 1587
    return (1);
#line 1588
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
  {
#line 1592
  tmp___5 = is_pattern((char const   *)(buf));
  }
  }
#line 1592
  if (tmp___5) {
    {
    {
#line 1594
    admin_write_line((com_request_t const   *)req, (int const   )284, "Kicking all connections matching (%s)",
                     buf);
    }
    {
#line 1595
    kick_if_match(buf);
    }
    }
#line 1596
    return (1);
  } else {
    {
    {
#line 1598
    tmp___2 = atoi((char const   *)arg);
    }
    {
#line 1598
    tmp___3 = find_id(tmp___2);
    }
#line 1598
    kick = tmp___3;
    }
#line 1600
    if (! kick) {
      {
      {
#line 1602
      tmp___4 = atoi((char const   *)arg);
      }
      {
#line 1602
      admin_write_line((com_request_t const   *)req, (int const   )285, "No such id %d",
                       tmp___4);
      }
      }
#line 1603
      return (1);
    }
#line 1606
    if (kick->id == (req->con)->id) {
      {
      {
#line 1608
      admin_write_line((com_request_t const   *)req, (int const   )286, "Some people kick theirselves, but please do it somewhere less public ;)");
      }
      }
#line 1609
      return (1);
    }
    {
    {
#line 1611
    kick_connection((void *)kick, (void *)"Kicked by admin");
    }
    }
  }
#line 1613
  return (1);
}
}
#line 1620 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_sel(com_request_t *req ) 
{ 
  char first[8192] ;
  char second[8192] ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
  {
#line 1623
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1623
  arg = tmp;
  }
#line 1625
  if (! arg) {
    {
    {
#line 1627
    admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
    }
    }
#line 1628
    return (1);
  } else
#line 1625
  if (! *(arg + 0)) {
    {
    {
#line 1627
    admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
    }
    }
#line 1628
    return (1);
  } else {
    {
    {
#line 1625
    tmp___0 = splitc(first, arg, (char const   )' ');
    }
    }
#line 1625
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 1627
      admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
      }
      }
#line 1628
      return (1);
    }
  }
#line 1631
  if ((int )first[0] == 45) {
    {
    {
#line 1633
    tmp___4 = splitc(second, arg, (char const   )' ');
    }
    }
#line 1633
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 1635
      if ((int )first[1] == 97) {
        {
        {
#line 1637
        tmp___1 = source_get_id(arg);
        }
        {
#line 1637
        tmp___2 = source_get_id(second);
        }
        {
#line 1637
        move_all_from(req, tmp___2, tmp___1);
        }
        }
#line 1638
        return (1);
      } else
#line 1639
      if ((int )first[1] == 112) {
        {
        {
#line 1641
        tmp___3 = source_get_id(second);
        }
        {
#line 1641
        move_all_matching(req, tmp___3, arg);
        }
        }
#line 1642
        return (1);
      }
    }
    {
    {
#line 1645
    admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
    }
    }
#line 1646
    return (1);
  }
  {
  {
#line 1649
  tmp___5 = __ctype_b_loc();
  }
  }
#line 1649
  if (! ((int const   )*(*tmp___5 + (int )first[0]) & 2048)) {
    {
    {
#line 1651
    admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
    }
    }
#line 1652
    return (1);
  }
  {
  {
#line 1655
  tmp___6 = source_get_id(arg);
  }
  {
#line 1655
  tmp___7 = atoi((char const   *)(first));
  }
  {
#line 1655
  move_id_to(req, tmp___7, tmp___6);
  }
  }
#line 1656
  return (1);
}
}
#line 1660 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void move_to(void *clientarg , void *sourcetargetarg ) 
{ 
  connection_t *client ;
  connection_t *sourcetarget ;

  {
  {
#line 1663
  client = (connection_t *)clientarg;
#line 1664
  sourcetarget = (connection_t *)sourcetargetarg;
  {
#line 1666
  avl_delete(((client->food.client)->source)->clients, (void const   *)client);
  }
  {
#line 1667
  del_client(client, (client->food.client)->source);
  }
#line 1668
  (client->food.client)->virgin = 1;
#line 1669
  (client->food.client)->alive = 1;
#line 1670
  (client->food.client)->source = sourcetarget->food.source;
  {
#line 1671
  pool_add(client);
  }
  {
#line 1672
  util_increase_total_clients();
  }
  }
#line 1673
  return;
}
}
#line 1676 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void move_all_matching(com_request_t *req , int sourceid , char *arg ) 
{ 
  char pattern[8192] ;
  connection_t *sourcecon ;
  connection_t *targetcon ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 1682
  sourcecon = find_source_with_id(sourceid);
  }
  }
#line 1683
  if (! sourcecon) {
    {
    {
#line 1685
    admin_write_line((com_request_t const   *)req, (int const   )291, "Error in source id [%d]",
                     sourceid);
    }
    }
#line 1686
    return;
  }
  {
  {
#line 1689
  tmp = splitc(pattern, arg, (char const   )' ');
  }
  }
#line 1689
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 1691
    admin_write_line((com_request_t const   *)req, (int const   )290, "Try \'help select\'");
    }
    }
#line 1692
    return;
  }
  {
  {
#line 1695
  tmp___0 = atoi((char const   *)arg);
  }
  {
#line 1695
  targetcon = find_source_with_id(tmp___0);
  }
  }
#line 1696
  if (! targetcon) {
    {
    {
#line 1698
    tmp___1 = atoi((char const   *)arg);
    }
    {
#line 1698
    admin_write_line((com_request_t const   *)req, (int const   )292, "Error in target id [%d]",
                     tmp___1);
    }
    }
#line 1699
    return;
  }
  {
  {
#line 1702
  admin_write_line((com_request_t const   *)req, (int const   )293, "Moving all clients matching pattern [%s] from source %s to source %s",
                   pattern, (sourcecon->food.source)->audiocast.mount, (targetcon->food.source)->audiocast.mount);
  }
  {
#line 1705
  thread_mutex_lock_c(& info.double_mutex, 1705, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1707
  thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 1707, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1708
  thread_mutex_lock_c(& (targetcon->food.source)->mutex, 1708, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1710
  do_if_match_tree((sourcecon->food.source)->clients, pattern, & move_to, (void *)targetcon,
                   1);
  }
  {
#line 1712
  thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 1712, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1713
  thread_mutex_unlock_c(& (targetcon->food.source)->mutex, 1713, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1715
  thread_mutex_unlock_c(& info.double_mutex, 1715, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1717
  admin_write_line((com_request_t const   *)req, (int const   )294, "Done, source now has %d clients, and target source has %d",
                   (sourcecon->food.source)->num_clients, (targetcon->food.source)->num_clients);
  }
  }
#line 1719
  return;
}
}
#line 1724 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void move_all_from(com_request_t *req , int sourceid , int targetid ) 
{ 
  connection_t *sourcecon ;
  connection_t *targetcon ;
  connection_t *clicon ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 1729
  sourcecon = find_source_with_id(sourceid);
  }
  }
#line 1730
  if (! sourcecon) {
    {
    {
#line 1732
    admin_write_line((com_request_t const   *)req, (int const   )291, "Error in source id [%d]",
                     sourceid);
    }
    }
#line 1733
    return;
  }
  {
  {
#line 1736
  targetcon = find_source_with_id(targetid);
  }
  }
#line 1737
  if (! targetcon) {
    {
    {
#line 1739
    admin_write_line((com_request_t const   *)req, (int const   )292, "Error in target id [%d]",
                     targetid);
    }
    }
#line 1740
    return;
  }
  {
  {
#line 1743
  admin_write_line((com_request_t const   *)req, (int const   )295, "Moving all clients from source %s to source %s",
                   (sourcecon->food.source)->audiocast.mount, (targetcon->food.source)->audiocast.mount);
  }
  {
#line 1746
  thread_mutex_lock_c(& info.double_mutex, 1746, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1748
  thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 1748, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1749
  thread_mutex_lock_c(& (targetcon->food.source)->mutex, 1749, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1751
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1751
    tmp = avl_get_any_node((sourcecon->food.source)->clients);
    }
#line 1751
    clicon = (connection_t *)tmp;
    }
#line 1751
    if (! clicon) {
#line 1751
      goto while_break;
    }
    {
    {
#line 1753
    avl_delete((sourcecon->food.source)->clients, (void const   *)clicon);
    }
    {
#line 1754
    del_client(clicon, sourcecon->food.source);
    }
#line 1755
    (clicon->food.client)->virgin = 1;
#line 1756
    (clicon->food.client)->source = targetcon->food.source;
    {
#line 1757
    pool_add(clicon);
    }
    {
#line 1758
    util_increase_total_clients();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1761
  thread_mutex_unlock_c(& (targetcon->food.source)->mutex, 1761, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1762
  thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 1762, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1764
  thread_mutex_unlock_c(& info.double_mutex, 1764, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1766
  admin_write_line((com_request_t const   *)req, (int const   )294, "Done, old source has %d clients, new source has %d clients",
                   (sourcecon->food.source)->num_clients, (targetcon->food.source)->num_clients);
  }
  }
#line 1768
  return;
}
}
#line 1771 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void move_id_to(com_request_t *req , int id , int newsourceid ) 
{ 
  connection_t *con ;
  connection_t *tmp ;
  connection_t *newsourcecon ;
  connection_t *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 1774
  tmp = find_client_with_id(id);
  }
#line 1774
  con = tmp;
  {
#line 1775
  tmp___0 = find_source_with_id(newsourceid);
  }
#line 1775
  newsourcecon = tmp___0;
  }
#line 1777
  if (! con) {
    {
    {
#line 1779
    admin_write_line((com_request_t const   *)req, (int const   )296, "Error in client id [%d]",
                     id);
    }
    }
#line 1780
    return;
  } else
#line 1777
  if ((unsigned int )con->type != 0U) {
    {
    {
#line 1779
    admin_write_line((com_request_t const   *)req, (int const   )296, "Error in client id [%d]",
                     id);
    }
    }
#line 1780
    return;
  }
#line 1783
  if (! newsourcecon) {
    {
    {
#line 1785
    admin_write_line((com_request_t const   *)req, (int const   )291, "Error in new source id [%d]",
                     newsourceid);
    }
    }
#line 1786
    return;
  } else
#line 1783
  if ((unsigned int )newsourcecon->type != 1U) {
    {
    {
#line 1785
    admin_write_line((com_request_t const   *)req, (int const   )291, "Error in new source id [%d]",
                     newsourceid);
    }
    }
#line 1786
    return;
  }
  {
  {
#line 1789
  admin_write_line((com_request_t const   *)req, (int const   )297, "Moving client %d from source %s to source %s",
                   con->id, ((con->food.client)->source)->audiocast.mount, (newsourcecon->food.source)->audiocast.mount);
  }
  {
#line 1793
  thread_mutex_lock_c(& ((con->food.client)->source)->mutex, 1793, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1794
  avl_delete(((con->food.client)->source)->clients, (void const   *)con);
  }
  {
#line 1795
  thread_mutex_unlock_c(& ((con->food.client)->source)->mutex, 1795, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1796
  del_client(con, (con->food.client)->source);
  }
#line 1798
  (con->food.client)->virgin = 1;
#line 1799
  (con->food.client)->source = newsourcecon->food.source;
  {
#line 1800
  pool_add(con);
  }
  {
#line 1802
  util_increase_total_clients();
  }
  {
#line 1803
  admin_write_line((com_request_t const   *)req, (int const   )294, "Moved client %d to client tree of source %d",
                   con->id, newsourcecon->id);
  }
  }
#line 1805
  return;
}
}
#line 1808 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_list(com_request_t *req ) 
{ 
  char pattern[8192] ;
  char *arg ;
  char *tmp ;
  char buf[8192] ;
  connection_t *con ;
  connection_t *sourcecon ;
  avl_traverser trav ;
  avl_traverser sourcetrav ;
  int listed ;
  time_t t ;
  long tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  void *tmp___12 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
  {
  {
#line 1811
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1811
  arg = tmp;
#line 1813
  trav.init = 0;
#line 1813
  trav.nstack = 0;
#line 1813
  trav.p = (avl_node const   *)0;
#line 1813
  trav.stack[0] = (avl_node const   *)0;
#line 1813
  trav.stack[1] = (avl_node const   *)0;
#line 1813
  trav.stack[2] = (avl_node const   *)0;
#line 1813
  trav.stack[3] = (avl_node const   *)0;
#line 1813
  trav.stack[4] = (avl_node const   *)0;
#line 1813
  trav.stack[5] = (avl_node const   *)0;
#line 1813
  trav.stack[6] = (avl_node const   *)0;
#line 1813
  trav.stack[7] = (avl_node const   *)0;
#line 1813
  trav.stack[8] = (avl_node const   *)0;
#line 1813
  trav.stack[9] = (avl_node const   *)0;
#line 1813
  trav.stack[10] = (avl_node const   *)0;
#line 1813
  trav.stack[11] = (avl_node const   *)0;
#line 1813
  trav.stack[12] = (avl_node const   *)0;
#line 1813
  trav.stack[13] = (avl_node const   *)0;
#line 1813
  trav.stack[14] = (avl_node const   *)0;
#line 1813
  trav.stack[15] = (avl_node const   *)0;
#line 1813
  trav.stack[16] = (avl_node const   *)0;
#line 1813
  trav.stack[17] = (avl_node const   *)0;
#line 1813
  trav.stack[18] = (avl_node const   *)0;
#line 1813
  trav.stack[19] = (avl_node const   *)0;
#line 1813
  trav.stack[20] = (avl_node const   *)0;
#line 1813
  trav.stack[21] = (avl_node const   *)0;
#line 1813
  trav.stack[22] = (avl_node const   *)0;
#line 1813
  trav.stack[23] = (avl_node const   *)0;
#line 1813
  trav.stack[24] = (avl_node const   *)0;
#line 1813
  trav.stack[25] = (avl_node const   *)0;
#line 1813
  trav.stack[26] = (avl_node const   *)0;
#line 1813
  trav.stack[27] = (avl_node const   *)0;
#line 1813
  trav.stack[28] = (avl_node const   *)0;
#line 1813
  trav.stack[29] = (avl_node const   *)0;
#line 1813
  trav.stack[30] = (avl_node const   *)0;
#line 1813
  trav.stack[31] = (avl_node const   *)0;
#line 1813
  sourcetrav.init = 0;
#line 1813
  sourcetrav.nstack = 0;
#line 1813
  sourcetrav.p = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[0] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[1] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[2] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[3] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[4] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[5] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[6] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[7] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[8] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[9] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[10] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[11] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[12] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[13] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[14] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[15] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[16] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[17] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[18] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[19] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[20] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[21] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[22] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[23] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[24] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[25] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[26] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[27] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[28] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[29] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[30] = (avl_node const   *)0;
#line 1813
  sourcetrav.stack[31] = (avl_node const   *)0;
#line 1814
  listed = 0;
  {
#line 1815
  tmp___0 = get_time();
  }
#line 1815
  t = tmp___0;
#line 1817
  pattern[0] = (char )'\000';
  }
#line 1819
  if (arg) {
#line 1819
    if (*(arg + 0)) {
      {
      {
#line 1821
      strncpy((char */* __restrict  */)(pattern), (char const   */* __restrict  */)arg,
              (size_t )8192);
      }
      {
#line 1822
      admin_write_line((com_request_t const   *)req, (int const   )300, "Listing connections matching [%s]:",
                       pattern);
      }
      }
    } else {
      {
      {
#line 1824
      admin_write_line((com_request_t const   *)req, (int const   )300, "Listing connections:",
                       pattern);
      }
      }
    }
  } else {
    {
    {
#line 1824
    admin_write_line((com_request_t const   *)req, (int const   )300, "Listing connections:",
                     pattern);
    }
    }
  }
  {
  {
#line 1827
  thread_mutex_lock_c(& info.admin_mutex, 1827, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1829
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1829
    tmp___4 = avl_traverse(info.admins, & trav);
    }
#line 1829
    con = (connection_t *)tmp___4;
    }
#line 1829
    if (! con) {
#line 1829
      goto while_break;
    }
#line 1831
    if (pattern[0]) {
      {
      {
#line 1832
      tmp___1 = hostmatch((connection_t const   *)con, (char const   *)(pattern));
      }
      }
#line 1832
      if (! tmp___1) {
#line 1833
        goto while_continue;
      }
    }
    {
#line 1834
    listed ++;
    {
#line 1835
    tmp___2 = nice_time((unsigned long )(t - con->connect_time), buf);
    }
    {
#line 1835
    tmp___3 = con_host(con);
    }
    {
#line 1835
    admin_write_line((com_request_t const   *)req, (int const   )301, "[Id: %lu] [Host: %s] [Type: admin] [Connected for: %s]",
                     con->id, tmp___3, tmp___2);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1839
  thread_mutex_unlock_c(& info.admin_mutex, 1839, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1841
  thread_mutex_lock_c(& info.double_mutex, 1841, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1842
  thread_mutex_lock_c(& info.source_mutex, 1842, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
  {
  {
#line 1844
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 1844
    tmp___12 = avl_traverse(info.sources, & sourcetrav);
    }
#line 1844
    sourcecon = (connection_t *)tmp___12;
    }
#line 1844
    if (! sourcecon) {
#line 1844
      goto while_break___0;
    }
    {
    {
#line 1846
    zero_trav(& trav);
    }
    {
#line 1847
    thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 1847, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 1849
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 1849
      tmp___8 = avl_traverse((sourcecon->food.source)->clients, & trav);
      }
#line 1849
      con = (connection_t *)tmp___8;
      }
#line 1849
      if (! con) {
#line 1849
        goto while_break___1;
      }
#line 1851
      if (pattern[0]) {
        {
        {
#line 1852
        tmp___5 = hostmatch((connection_t const   *)con, (char const   *)(pattern));
        }
        }
#line 1852
        if (! tmp___5) {
#line 1853
          goto while_continue___1;
        }
      }
      {
#line 1854
      listed ++;
      {
#line 1855
      tmp___6 = nice_time((unsigned long )(t - con->connect_time), buf);
      }
      {
#line 1855
      tmp___7 = con_host(con);
      }
      {
#line 1855
      admin_write_line((com_request_t const   *)req, (int const   )301, "[Id: %lu] [Host: %s] [Type: client] [Connected for: %s]",
                       con->id, tmp___7, tmp___6);
      }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 1859
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 1859, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 1861
    if (pattern[0]) {
      {
      {
#line 1862
      tmp___9 = hostmatch((connection_t const   *)sourcecon, (char const   *)(pattern));
      }
      }
#line 1862
      if (! tmp___9) {
#line 1863
        goto while_continue___0;
      }
    }
    {
    {
#line 1865
    tmp___10 = nice_time((unsigned long )(t - sourcecon->connect_time), buf);
    }
    {
#line 1865
    tmp___11 = con_host(sourcecon);
    }
    {
#line 1865
    admin_write_line((com_request_t const   *)req, (int const   )301, "[Id: %lu] [Host: %s] [Type: source] [Connected for: %s]",
                     sourcecon->id, tmp___11, tmp___10);
    }
#line 1867
    listed ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 1870
  thread_mutex_unlock_c(& info.source_mutex, 1870, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1872
  thread_mutex_unlock_c(& info.double_mutex, 1872, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 1874
  admin_write_line((com_request_t const   *)req, (int const   )302, "End of list listing (%d listed)",
                   listed);
  }
  }
#line 1875
  return (1);
}
}
#line 1883 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_relay(com_request_t *req ) 
{ 
  char command[8192] ;
  char *arg ;
  char *tmp ;
  int err ;
  char *tmp___0 ;
  request_t rreq ;
  int tmp___1 ;
  int tmp___2 ;
  avl_traverser trav ;
  relay_t *rel ;
  char const   *tmp___3 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;

  {
  {
  {
#line 1885
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1885
  arg = tmp;
#line 1886
  err = 1;
  }
#line 1888
  if (! arg) {
    {
    {
#line 1889
    admin_write_line((com_request_t const   *)req, (int const   )310, "Syntax: relay <pull|push|list> <arguments>");
    }
    }
#line 1890
    return (1);
  } else
#line 1888
  if (! *(arg + 0)) {
    {
    {
#line 1889
    admin_write_line((com_request_t const   *)req, (int const   )310, "Syntax: relay <pull|push|list> <arguments>");
    }
    }
#line 1890
    return (1);
  }
  {
  {
#line 1893
  tmp___0 = splitc(command, arg, (char const   )' ');
  }
  }
#line 1893
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 1894
    strncpy((char */* __restrict  */)(command), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
#line 1895
    *(arg + 0) = (char )'\000';
    }
  }
  {
  {
#line 1898
  tmp___11 = ice_strncmp((char const   *)(command), "push", (size_t )4);
  }
  }
#line 1898
  if (tmp___11 == 0) {
    {
    {
#line 1899
    err = relay_add_push_to_list(arg);
    }
    }
  } else {
    {
    {
#line 1900
    tmp___10 = ice_strncmp((char const   *)(command), "pull", (size_t )4);
    }
    }
#line 1900
    if (tmp___10 == 0) {
      {
      {
#line 1901
      err = relay_add_pull_to_list(arg);
      }
      }
    } else {
      {
      {
#line 1902
      tmp___9 = ice_strncmp((char const   *)(command), "del", (size_t )3);
      }
      }
#line 1902
      if (tmp___9 == 0) {
        {
        {
#line 1904
        generate_http_request(arg, & rreq);
        }
        {
#line 1906
        tmp___1 = is_valid_http_request(& rreq);
        }
        }
#line 1906
        if (! tmp___1) {
          {
          {
#line 1907
          admin_write_line((com_request_t const   *)req, (int const   )310, "Syntax: relay <pull|push|list> <arguments>");
          }
          }
#line 1908
          return (0);
        }
        {
        {
#line 1911
        tmp___2 = relay_remove_with_req(& rreq);
        }
        }
#line 1911
        if (tmp___2 > 0) {
          {
          {
#line 1912
          admin_write_line((com_request_t const   *)req, (int const   )325, "Relay [%s:%d%s] removed",
                           rreq.host, rreq.port, rreq.path);
          }
          }
        } else {
          {
          {
#line 1915
          admin_write_line((com_request_t const   *)req, (int const   )325, "Could not remove [%s:%d%s]",
                           rreq.host, rreq.port, rreq.path);
          }
          }
        }
#line 1917
        return (0);
      } else {
        {
        {
#line 1918
        tmp___8 = ice_strncmp((char const   *)(command), "list", (size_t )4);
        }
        }
#line 1918
        if (tmp___8 == 0) {
          {
#line 1919
          trav.init = 0;
#line 1919
          trav.nstack = 0;
#line 1919
          trav.p = (avl_node const   *)0;
#line 1919
          trav.stack[0] = (avl_node const   *)0;
#line 1919
          trav.stack[1] = (avl_node const   *)0;
#line 1919
          trav.stack[2] = (avl_node const   *)0;
#line 1919
          trav.stack[3] = (avl_node const   *)0;
#line 1919
          trav.stack[4] = (avl_node const   *)0;
#line 1919
          trav.stack[5] = (avl_node const   *)0;
#line 1919
          trav.stack[6] = (avl_node const   *)0;
#line 1919
          trav.stack[7] = (avl_node const   *)0;
#line 1919
          trav.stack[8] = (avl_node const   *)0;
#line 1919
          trav.stack[9] = (avl_node const   *)0;
#line 1919
          trav.stack[10] = (avl_node const   *)0;
#line 1919
          trav.stack[11] = (avl_node const   *)0;
#line 1919
          trav.stack[12] = (avl_node const   *)0;
#line 1919
          trav.stack[13] = (avl_node const   *)0;
#line 1919
          trav.stack[14] = (avl_node const   *)0;
#line 1919
          trav.stack[15] = (avl_node const   *)0;
#line 1919
          trav.stack[16] = (avl_node const   *)0;
#line 1919
          trav.stack[17] = (avl_node const   *)0;
#line 1919
          trav.stack[18] = (avl_node const   *)0;
#line 1919
          trav.stack[19] = (avl_node const   *)0;
#line 1919
          trav.stack[20] = (avl_node const   *)0;
#line 1919
          trav.stack[21] = (avl_node const   *)0;
#line 1919
          trav.stack[22] = (avl_node const   *)0;
#line 1919
          trav.stack[23] = (avl_node const   *)0;
#line 1919
          trav.stack[24] = (avl_node const   *)0;
#line 1919
          trav.stack[25] = (avl_node const   *)0;
#line 1919
          trav.stack[26] = (avl_node const   *)0;
#line 1919
          trav.stack[27] = (avl_node const   *)0;
#line 1919
          trav.stack[28] = (avl_node const   *)0;
#line 1919
          trav.stack[29] = (avl_node const   *)0;
#line 1919
          trav.stack[30] = (avl_node const   *)0;
#line 1919
          trav.stack[31] = (avl_node const   *)0;
          {
#line 1922
          admin_write_line((com_request_t const   *)req, (int const   )323, "Listing relays:");
          }
          {
#line 1923
          thread_mutex_lock_c(& info.relay_mutex, 1923, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
          }
          }
          {
          {
#line 1925
          while (1) {
            while_continue___0: /* CIL Label */ ;
            while_continue: /* CIL Label */ ;
            {
            {
#line 1925
            tmp___7 = avl_traverse(info.relays, & trav);
            }
#line 1925
            rel = (relay_t *)tmp___7;
            }
#line 1925
            if (! rel) {
#line 1925
              goto while_break;
            }
#line 1927
            if ((unsigned int )rel->type == 2U) {
#line 1927
              tmp___3 = "push";
            } else {
#line 1927
              tmp___3 = "pull";
            }
            {
            {
#line 1927
            tmp___6 = relay_connected(rel);
            }
            }
#line 1927
            if (tmp___6) {
#line 1927
              tmp___5 = "yes";
            } else {
#line 1927
              tmp___5 = "no";
            }
            {
            {
#line 1927
            admin_write_line((com_request_t const   *)req, (int const   )315, "Remote: [%s:%d%s] Local: [%s] Connected: [%s] Type: [%s] Reconnects: [%d]",
                             rel->req.host, rel->req.port, rel->req.path, rel->localmount,
                             tmp___5, tmp___3, rel->reconnects);
            }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
          {
#line 1934
          thread_mutex_unlock_c(& info.relay_mutex, 1934, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
          }
          {
#line 1935
          admin_write_line((com_request_t const   *)req, (int const   )324, "End of relay listing");
          }
          }
#line 1936
          return (1);
        } else {
          {
          {
#line 1938
          admin_write_line((com_request_t const   *)req, (int const   )310, "Syntax: relay <pull|push|list> <arguments>");
          }
          }
#line 1939
          return (0);
        }
      }
    }
  }
#line 1942
  if (err != 1) {
    {
#line 1946
    if (err == -2) {
#line 1946
      goto case_neg_2;
    }
#line 1949
    if (err == -9) {
#line 1949
      goto case_neg_9;
    }
#line 1952
    if (err == -3) {
#line 1952
      goto case_neg_3;
    }
#line 1955
    goto switch_default;
    case_neg_2: /* CIL Label */ 
    {
    {
#line 1947
    admin_write_line((com_request_t const   *)req, (int const   )310, "Syntax: relay <pull|push|list> <arguments>");
    }
    }
#line 1948
    goto switch_break;
    case_neg_9: /* CIL Label */ 
    {
    {
#line 1950
    admin_write_line((com_request_t const   *)req, (int const   )312, "No such source");
    }
    }
#line 1951
    goto switch_break;
    case_neg_3: /* CIL Label */ 
    {
    {
#line 1953
    admin_write_line((com_request_t const   *)req, (int const   )313, "Argument required for option");
    }
    }
#line 1954
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
#line 1956
    admin_write_line((com_request_t const   *)req, (int const   )310, "Unspecific error");
    }
    }
#line 1957
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1959
    return (0);
  } else {
    {
    {
#line 1961
    admin_write_line((com_request_t const   *)req, (int const   )320, "Relay added");
    }
    }
  }
#line 1964
  return (1);
}
}
#line 1968 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_alias(com_request_t *req ) 
{ 
  char type[8192] ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  char mountpoint[8192] ;
  request_t nameline ;
  request_t realline ;
  alias_t *res ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
  {
#line 1971
  tmp = com_arg((com_request_t const   *)req);
  }
#line 1971
  arg = tmp;
  }
#line 1973
  if (! arg) {
    {
    {
#line 1975
    admin_write((com_request_t const   *)req, (int const   )330, "alias <add|del|list> [mountpoint] [real source]\r\n");
    }
    }
#line 1976
    return (0);
  } else
#line 1973
  if (! *(arg + 0)) {
    {
    {
#line 1975
    admin_write((com_request_t const   *)req, (int const   )330, "alias <add|del|list> [mountpoint] [real source]\r\n");
    }
    }
#line 1976
    return (0);
  }
  {
  {
#line 1979
  tmp___0 = splitc(type, arg, (char const   )' ');
  }
  }
#line 1979
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 1980
    strncpy((char */* __restrict  */)(type), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
  {
#line 1982
  tmp___5 = ice_strcmp((char const   *)(type), "list");
  }
  }
#line 1982
  if (tmp___5 == 0) {
    {
    {
#line 1984
    list_aliases(req);
    }
    }
#line 1985
    return (1);
  } else {
    {
    {
#line 1986
    tmp___4 = ice_strcmp((char const   *)(type), "add");
    }
    }
#line 1986
    if (tmp___4 == 0) {
      {
#line 1990
      res = (alias_t *)((void *)0);
      {
#line 1992
      zero_request(& nameline);
      }
      {
#line 1993
      zero_request(& realline);
      }
      {
#line 1995
      tmp___1 = splitc(mountpoint, arg, (char const   )' ');
      }
      }
#line 1995
      if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
        {
        {
#line 1997
        admin_write((com_request_t const   *)req, (int const   )330, "alias <add|del|list> [mountpoint] [real source]\r\n");
        }
        }
#line 1998
        return (0);
      }
      {
      {
#line 2001
      generate_request(mountpoint, & nameline);
      }
      {
#line 2002
      generate_request(arg, & realline);
      }
      }
#line 2004
      if (! nameline.path[0]) {
        {
        {
#line 2006
        admin_write((com_request_t const   *)req, (int const   )330, "alias <add|del|list> [mountpoint] [real source]\r\n");
        }
        }
#line 2007
        return (0);
      } else
#line 2004
      if (! realline.path[0]) {
        {
        {
#line 2006
        admin_write((com_request_t const   *)req, (int const   )330, "alias <add|del|list> [mountpoint] [real source]\r\n");
        }
        }
#line 2007
        return (0);
      }
      {
      {
#line 2010
      res = add_alias(& nameline, & realline);
      }
      }
#line 2011
      if (res) {
        {
        {
#line 2013
        admin_write_line((com_request_t const   *)req, (int const   )331, "Added alias [%s] for [%s]",
                         res->name, res->real);
        }
        }
#line 2014
        return (1);
      } else {
        {
        {
#line 2016
        admin_write_line((com_request_t const   *)req, (int const   )332, "Alias add failed, alias not added");
        }
        }
#line 2017
        return (0);
      }
    } else {
      {
      {
#line 2019
      tmp___3 = ice_strcmp((char const   *)(type), "del");
      }
      }
#line 2019
      if (tmp___3 == 0) {
        {
        {
#line 2021
        tmp___2 = del_alias(arg);
        }
        }
#line 2021
        if (tmp___2) {
          {
          {
#line 2023
          admin_write_line((com_request_t const   *)req, (int const   )333, "Removed alias [%s]",
                           arg);
          }
          }
#line 2024
          return (1);
        } else {
          {
          {
#line 2026
          admin_write_line((com_request_t const   *)req, (int const   )334, "Alias remove failed",
                           arg);
          }
          }
#line 2027
          return (0);
        }
      } else {
        {
        {
#line 2030
        admin_write_line((com_request_t const   *)req, (int const   )335, "Unknown command alias [%s] [%s]",
                         type, arg);
        }
        }
#line 2031
        return (0);
      }
    }
  }
}
}
#line 2035 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_threads(com_request_t *req ) 
{ 
  avl_traverser trav ;
  mythread_t *mt ;
  char *freeme ;
  int listed ;
  void *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 2038
  trav.init = 0;
#line 2038
  trav.nstack = 0;
#line 2038
  trav.p = (avl_node const   *)0;
#line 2038
  trav.stack[0] = (avl_node const   *)0;
#line 2038
  trav.stack[1] = (avl_node const   *)0;
#line 2038
  trav.stack[2] = (avl_node const   *)0;
#line 2038
  trav.stack[3] = (avl_node const   *)0;
#line 2038
  trav.stack[4] = (avl_node const   *)0;
#line 2038
  trav.stack[5] = (avl_node const   *)0;
#line 2038
  trav.stack[6] = (avl_node const   *)0;
#line 2038
  trav.stack[7] = (avl_node const   *)0;
#line 2038
  trav.stack[8] = (avl_node const   *)0;
#line 2038
  trav.stack[9] = (avl_node const   *)0;
#line 2038
  trav.stack[10] = (avl_node const   *)0;
#line 2038
  trav.stack[11] = (avl_node const   *)0;
#line 2038
  trav.stack[12] = (avl_node const   *)0;
#line 2038
  trav.stack[13] = (avl_node const   *)0;
#line 2038
  trav.stack[14] = (avl_node const   *)0;
#line 2038
  trav.stack[15] = (avl_node const   *)0;
#line 2038
  trav.stack[16] = (avl_node const   *)0;
#line 2038
  trav.stack[17] = (avl_node const   *)0;
#line 2038
  trav.stack[18] = (avl_node const   *)0;
#line 2038
  trav.stack[19] = (avl_node const   *)0;
#line 2038
  trav.stack[20] = (avl_node const   *)0;
#line 2038
  trav.stack[21] = (avl_node const   *)0;
#line 2038
  trav.stack[22] = (avl_node const   *)0;
#line 2038
  trav.stack[23] = (avl_node const   *)0;
#line 2038
  trav.stack[24] = (avl_node const   *)0;
#line 2038
  trav.stack[25] = (avl_node const   *)0;
#line 2038
  trav.stack[26] = (avl_node const   *)0;
#line 2038
  trav.stack[27] = (avl_node const   *)0;
#line 2038
  trav.stack[28] = (avl_node const   *)0;
#line 2038
  trav.stack[29] = (avl_node const   *)0;
#line 2038
  trav.stack[30] = (avl_node const   *)0;
#line 2038
  trav.stack[31] = (avl_node const   *)0;
#line 2040
  freeme = (char *)((void *)0);
#line 2041
  listed = 0;
  {
#line 2043
  admin_write_line((com_request_t const   *)req, (int const   )340, "Listing threads (might take a short while)");
  }
  {
#line 2045
  internal_lock_mutex(& info.thread_mutex);
  }
  }
  {
  {
#line 2047
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 2047
    tmp = avl_traverse(info.threads, & trav);
    }
#line 2047
    mt = (mythread_t *)tmp;
    }
#line 2047
    if (! mt) {
#line 2047
      goto while_break;
    }
#line 2049
    mt->ping = 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 2052
  my_sleep(1000000);
  }
  {
#line 2054
  zero_trav(& trav);
  }
  }
  {
  {
#line 2056
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 2056
    tmp___1 = avl_traverse(info.threads, & trav);
    }
#line 2056
    mt = (mythread_t *)tmp___1;
    }
#line 2056
    if (! mt) {
#line 2056
      goto while_break___0;
    }
    {
#line 2058
    freeme = (char *)((void *)0);
    {
#line 2060
    freeme = get_string_time(mt->created, (char *)"%d/%b/%Y:%H:%M:%S");
    }
    }
#line 2060
    if (mt->ping == 0) {
#line 2060
      tmp___0 = "no";
    } else {
#line 2060
      tmp___0 = "yes";
    }
    {
    {
#line 2060
    admin_write_line((com_request_t const   *)req, (int const   )341, "%d\tType: [%23s]\tStarted [File: %10s Line: %d] Stuck: %s Started: %s",
                     mt->id, mt->name, mt->file, mt->line, tmp___0, freeme);
    }
    }
#line 2062
    if ((unsigned long )freeme != (unsigned long )((void *)0)) {
      {
      {
#line 2063
      free((void *)freeme);
      }
      }
    }
#line 2064
    listed ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 2067
  internal_unlock_mutex(& info.thread_mutex);
  }
  {
#line 2069
  admin_write_line((com_request_t const   *)req, (int const   )342, "End of threads listing (%d listed)",
                   listed);
  }
  }
#line 2071
  return (1);
}
}
#line 2074 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_status(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char *lt ;
  char *tmp___0 ;
  char timebuf[8192] ;
  long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
  {
#line 2077
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2077
  arg = tmp;
  }
#line 2079
  if (arg) {
#line 2079
    if (*(arg + 0)) {
      {
      {
#line 2081
      tmp___5 = ice_strncmp((char const   *)arg, "off", (size_t )3);
      }
      }
#line 2081
      if (tmp___5 == 0) {
#line 2082
        ((req->con)->food.admin)->status = 0U;
      } else {
        {
        {
#line 2083
        tmp___4 = ice_strncmp((char const   *)arg, "on", (size_t )2);
        }
        }
#line 2083
        if (tmp___4 == 0) {
#line 2084
          ((req->con)->food.admin)->status = 1U;
        } else {
          {
          {
#line 2085
          tmp___3 = ice_strncmp((char const   *)arg, "show", (size_t )4);
          }
          }
#line 2085
          if (tmp___3 == 0) {
            {
            {
#line 2087
            tmp___0 = get_log_time();
            }
#line 2087
            lt = tmp___0;
            {
#line 2089
            tmp___1 = get_time();
            }
            {
#line 2089
            tmp___2 = nice_time((unsigned long )(tmp___1 - info.server_start_time),
                                timebuf);
            }
            {
#line 2089
            admin_write_line((com_request_t const   *)req, (int const   )352, "[%s] [Bandwidth: %fMB/s] [Sources: %ld] [Clients: %ld] [Admins: %ld] [Uptime: %s] ",
                             lt, info.bandwidth_usage, info.num_sources, info.num_clients,
                             info.num_admins, tmp___2);
            }
            }
#line 2092
            if ((unsigned long )lt != (unsigned long )((void *)0)) {
              {
              {
#line 2093
              free((void *)lt);
              }
              }
            }
#line 2094
            return (1);
          } else {
            {
            {
#line 2096
            admin_write_line((com_request_t const   *)req, (int const   )350, "Usage: status [off|on]");
            }
            }
#line 2097
            return (1);
          }
        }
      }
    }
  }
#line 2100
  if (((req->con)->food.admin)->status) {
#line 2100
    tmp___6 = "on";
  } else {
#line 2100
    tmp___6 = "off";
  }
  {
  {
#line 2100
  admin_write_line((com_request_t const   *)req, (int const   )351, "Status information is [%s]",
                   tmp___6);
  }
  }
#line 2101
  return (1);
}
}
#line 2105 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_dump(com_request_t *req ) 
{ 
  char cid[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *sourcecon ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 2108
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2108
  arg = tmp;
  }
#line 2111
  if (! arg) {
    {
    {
#line 2113
    admin_write((com_request_t const   *)req, (int const   )351, "dump <sourceid> <filename|close>\r\n");
    }
    }
#line 2114
    return (0);
  } else
#line 2111
  if (! *(arg + 0)) {
    {
    {
#line 2113
    admin_write((com_request_t const   *)req, (int const   )351, "dump <sourceid> <filename|close>\r\n");
    }
    }
#line 2114
    return (0);
  }
  {
  {
#line 2117
  tmp___0 = splitc(cid, arg, (char const   )' ');
  }
  }
#line 2117
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 2119
    admin_write((com_request_t const   *)req, (int const   )351, "dump <sourceid> <filename|close>\r\n");
    }
    }
#line 2120
    return (0);
  }
  {
  {
#line 2123
  tmp___1 = atoi((char const   *)(cid));
  }
  {
#line 2123
  sourcecon = find_source_with_id(tmp___1);
  }
  }
#line 2124
  if (! sourcecon) {
    {
    {
#line 2126
    admin_write_line((com_request_t const   *)req, (int const   )352, "No source with id [%s] found.",
                     cid);
    }
    }
#line 2127
    return (0);
  }
  {
  {
#line 2130
  thread_mutex_lock_c(& (sourcecon->food.source)->mutex, 2130, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 2132
  tmp___2 = ice_strncmp((char const   *)arg, "close", (size_t )5);
  }
  }
#line 2132
  if (tmp___2 == 0) {
    {
    {
#line 2133
    fd_close((sourcecon->food.source)->dumpfd);
    }
    {
#line 2134
    n_free((void *)(sourcecon->food.source)->dumpfile, (int const   )2134, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
#line 2134
    (sourcecon->food.source)->dumpfile = (char *)((void *)0);
#line 2135
    (sourcecon->food.source)->dumpfile = (char *)((void *)0);
#line 2136
    (sourcecon->food.source)->dumpfd = -1;
    {
#line 2138
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 2138, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 2140
    admin_write_line((com_request_t const   *)req, (int const   )353, "Ok, stopped and closed dumping for source %d",
                     sourcecon->id);
    }
    }
#line 2141
    return (1);
  }
  {
  {
#line 2144
  (sourcecon->food.source)->dumpfile = my_strdup((char const   *)arg);
  }
  {
#line 2146
  (sourcecon->food.source)->dumpfd = open_for_writing((char const   *)(sourcecon->food.source)->dumpfile);
  }
  }
#line 2148
  if ((sourcecon->food.source)->dumpfd < 0) {
    {
    {
#line 2149
    tmp___3 = __errno_location();
    }
    {
#line 2149
    admin_write_line((com_request_t const   *)req, (int const   )354, "Failed opening dumpfile [%s] for source %d [%d]",
                     (sourcecon->food.source)->dumpfile, sourcecon->id, *tmp___3);
    }
    {
#line 2150
    n_free((void *)(sourcecon->food.source)->dumpfile, (int const   )2150, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
#line 2150
    (sourcecon->food.source)->dumpfile = (char *)((void *)0);
#line 2151
    (sourcecon->food.source)->dumpfile = (char *)((void *)0);
    {
#line 2152
    fd_close((sourcecon->food.source)->dumpfd);
    }
    {
#line 2154
    thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 2154, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 2155
    return (0);
  }
  {
  {
#line 2158
  thread_mutex_unlock_c(& (sourcecon->food.source)->mutex, 2158, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  {
#line 2160
  admin_write_line((com_request_t const   *)req, (int const   )355, "Ok, dumping source %d to %s",
                   sourcecon->id, (sourcecon->food.source)->dumpfile);
  }
  }
#line 2162
  return (1);
}
}
#line 2166 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_pause(com_request_t *req ) 
{ 
  char cid[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *pausecon ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 2169
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2169
  arg = tmp;
  }
#line 2172
  if (! arg) {
    {
    {
#line 2174
    admin_write((com_request_t const   *)req, (int const   )360, "pause <client_id|source_id>\r\n");
    }
    }
#line 2175
    return (0);
  } else
#line 2172
  if (! *(arg + 0)) {
    {
    {
#line 2174
    admin_write((com_request_t const   *)req, (int const   )360, "pause <client_id|source_id>\r\n");
    }
    }
#line 2175
    return (0);
  }
  {
  {
#line 2178
  tmp___0 = splitc(cid, arg, (char const   )' ');
  }
  }
#line 2178
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 2179
    strncpy((char */* __restrict  */)(cid), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
  {
#line 2181
  tmp___1 = atoi((char const   *)(cid));
  }
  {
#line 2181
  pausecon = find_source_with_id(tmp___1);
  }
  }
#line 2182
  if (! pausecon) {
    {
    {
#line 2183
    tmp___2 = atoi((char const   *)(cid));
    }
    {
#line 2183
    pausecon = find_client_with_id(tmp___2);
    }
    }
  }
#line 2185
  if (! pausecon) {
    {
    {
#line 2187
    admin_write_line((com_request_t const   *)req, (int const   )361, "No source or client with id [%s] found.",
                     cid);
    }
    }
#line 2188
    return (0);
  }
#line 2191
  if ((unsigned int )pausecon->type == 1U) {
#line 2192
    (pausecon->food.source)->connected = 3;
  } else
#line 2193
  if ((unsigned int )pausecon->type == 0U) {
#line 2194
    (pausecon->food.client)->virgin = 3;
  } else {
    {
    {
#line 2196
    admin_write_line((com_request_t const   *)req, (int const   )362, "Invalid type of paused id [%s].",
                     cid);
    }
    }
#line 2197
    return (0);
  }
#line 2200
  return (1);
}
}
#line 2203 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_unpause(com_request_t *req ) 
{ 
  char cid[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *pausecon ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  avl_traverser trav ;
  connection_t *client ;
  void *tmp___3 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
  {
#line 2206
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2206
  arg = tmp;
  }
#line 2210
  if (! arg) {
    {
    {
#line 2212
    admin_write_line((com_request_t const   *)req, (int const   )370, "pause <client_id|source_id>\r\n");
    }
    }
#line 2213
    return (0);
  } else
#line 2210
  if (! *(arg + 0)) {
    {
    {
#line 2212
    admin_write_line((com_request_t const   *)req, (int const   )370, "pause <client_id|source_id>\r\n");
    }
    }
#line 2213
    return (0);
  }
  {
  {
#line 2216
  tmp___0 = splitc(cid, arg, (char const   )' ');
  }
  }
#line 2216
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 2217
    strncpy((char */* __restrict  */)(cid), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
  {
#line 2219
  tmp___1 = atoi((char const   *)(cid));
  }
  {
#line 2219
  pausecon = find_source_with_id(tmp___1);
  }
  }
#line 2220
  if (! pausecon) {
    {
    {
#line 2221
    tmp___2 = atoi((char const   *)(cid));
    }
    {
#line 2221
    pausecon = find_client_with_id(tmp___2);
    }
    }
  }
#line 2223
  if (! pausecon) {
    {
    {
#line 2225
    admin_write_line((com_request_t const   *)req, (int const   )371, "No source or client with id [%s] found.",
                     cid);
    }
    }
#line 2226
    return (0);
  }
#line 2229
  if ((unsigned int )pausecon->type == 1U) {
    {
#line 2231
    trav.init = 0;
#line 2231
    trav.nstack = 0;
#line 2231
    trav.p = (avl_node const   *)0;
#line 2231
    trav.stack[0] = (avl_node const   *)0;
#line 2231
    trav.stack[1] = (avl_node const   *)0;
#line 2231
    trav.stack[2] = (avl_node const   *)0;
#line 2231
    trav.stack[3] = (avl_node const   *)0;
#line 2231
    trav.stack[4] = (avl_node const   *)0;
#line 2231
    trav.stack[5] = (avl_node const   *)0;
#line 2231
    trav.stack[6] = (avl_node const   *)0;
#line 2231
    trav.stack[7] = (avl_node const   *)0;
#line 2231
    trav.stack[8] = (avl_node const   *)0;
#line 2231
    trav.stack[9] = (avl_node const   *)0;
#line 2231
    trav.stack[10] = (avl_node const   *)0;
#line 2231
    trav.stack[11] = (avl_node const   *)0;
#line 2231
    trav.stack[12] = (avl_node const   *)0;
#line 2231
    trav.stack[13] = (avl_node const   *)0;
#line 2231
    trav.stack[14] = (avl_node const   *)0;
#line 2231
    trav.stack[15] = (avl_node const   *)0;
#line 2231
    trav.stack[16] = (avl_node const   *)0;
#line 2231
    trav.stack[17] = (avl_node const   *)0;
#line 2231
    trav.stack[18] = (avl_node const   *)0;
#line 2231
    trav.stack[19] = (avl_node const   *)0;
#line 2231
    trav.stack[20] = (avl_node const   *)0;
#line 2231
    trav.stack[21] = (avl_node const   *)0;
#line 2231
    trav.stack[22] = (avl_node const   *)0;
#line 2231
    trav.stack[23] = (avl_node const   *)0;
#line 2231
    trav.stack[24] = (avl_node const   *)0;
#line 2231
    trav.stack[25] = (avl_node const   *)0;
#line 2231
    trav.stack[26] = (avl_node const   *)0;
#line 2231
    trav.stack[27] = (avl_node const   *)0;
#line 2231
    trav.stack[28] = (avl_node const   *)0;
#line 2231
    trav.stack[29] = (avl_node const   *)0;
#line 2231
    trav.stack[30] = (avl_node const   *)0;
#line 2231
    trav.stack[31] = (avl_node const   *)0;
    {
#line 2234
    thread_mutex_lock_c(& (pausecon->food.source)->mutex, 2234, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 2236
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 2236
      tmp___3 = avl_traverse((pausecon->food.source)->clients, & trav);
      }
#line 2236
      client = (connection_t *)tmp___3;
      }
#line 2236
      if (! client) {
#line 2236
        goto while_break;
      }
#line 2237
      (client->food.client)->virgin = 4;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 2239
    thread_mutex_unlock_c(& (pausecon->food.source)->mutex, 2239, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
#line 2241
    (pausecon->food.source)->connected = 1;
    }
  } else
#line 2242
  if ((unsigned int )pausecon->type == 0U) {
#line 2243
    (pausecon->food.client)->virgin = 4;
  } else {
    {
    {
#line 2245
    admin_write_line((com_request_t const   *)req, (int const   )372, "Invalid type of unpaused id [%s].",
                     cid);
    }
    }
#line 2246
    return (0);
  }
#line 2249
  return (1);
}
}
#line 2253 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_restrict(com_request_t *req , avl_tree *tree , acltype_t acl_type ) 
{ 
  char type[8192] ;
  char *arg ;
  char *tmp ;
  char *tmp___0 ;
  restrict_t *res ;
  restrict_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
  {
#line 2256
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2256
  arg = tmp;
  }
#line 2258
  if (! arg) {
    {
    {
#line 2260
    admin_write((com_request_t const   *)req, (int const   )380, "<deny|allow> <add|del|list> [mask]\r\n");
    }
    }
#line 2261
    return (0);
  } else
#line 2258
  if (! *(arg + 0)) {
    {
    {
#line 2260
    admin_write((com_request_t const   *)req, (int const   )380, "<deny|allow> <add|del|list> [mask]\r\n");
    }
    }
#line 2261
    return (0);
  }
  {
  {
#line 2264
  tmp___0 = splitc(type, arg, (char const   )' ');
  }
  }
#line 2264
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 2265
    strncpy((char */* __restrict  */)(type), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
  {
#line 2267
  tmp___5 = ice_strcmp((char const   *)(type), "list");
  }
  }
#line 2267
  if (tmp___5 == 0) {
    {
    {
#line 2269
    list_restrict(req, tree, acl_type);
    }
    }
#line 2270
    return (1);
  } else {
    {
    {
#line 2271
    tmp___4 = ice_strcmp((char const   *)(type), "add");
    }
    }
#line 2271
    if (tmp___4 == 0) {
      {
      {
#line 2273
      tmp___1 = add_restrict(tree, arg, acl_type);
      }
#line 2273
      res = tmp___1;
      }
#line 2275
      if (res) {
        {
        {
#line 2277
        admin_write_line((com_request_t const   *)req, (int const   )381, "Added acl rule [%s]",
                         res->mask);
        }
        }
#line 2278
        return (1);
      } else {
        {
        {
#line 2280
        admin_write_line((com_request_t const   *)req, (int const   )382, "Acl addition for [%s] failed",
                         arg);
        }
        }
#line 2281
        return (0);
      }
    } else {
      {
      {
#line 2283
      tmp___3 = ice_strcmp((char const   *)(type), "del");
      }
      }
#line 2283
      if (tmp___3 == 0) {
        {
        {
#line 2285
        tmp___2 = del_restrict(tree, arg, acl_type);
        }
        }
#line 2285
        if (tmp___2) {
          {
          {
#line 2287
          admin_write_line((com_request_t const   *)req, (int const   )383, "Acl rule [%s] removed",
                           arg);
          }
          }
#line 2288
          return (1);
        } else {
          {
          {
#line 2290
          admin_write_line((com_request_t const   *)req, (int const   )384, "Acl removal of [%s] failed",
                           arg);
          }
          }
        }
      } else {
        {
        {
#line 2293
        admin_write_line((com_request_t const   *)req, (int const   )385, "Unknown restrict command [%s] [%s]",
                         type, arg);
        }
        }
#line 2294
        return (0);
      }
    }
  }
#line 2296
  return (0);
}
}
#line 2299 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
avl_tree *get_acl_tree(char *type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 2302
  tmp = ice_strncmp((char const   *)type, "client", (size_t )5);
  }
  }
#line 2302
  if (tmp == 0) {
#line 2303
    return (info.client_acl);
  }
  {
  {
#line 2304
  tmp___0 = ice_strncmp((char const   *)type, "source", (size_t )5);
  }
  }
#line 2304
  if (tmp___0 == 0) {
#line 2305
    return (info.source_acl);
  }
  {
  {
#line 2306
  tmp___1 = ice_strncmp((char const   *)type, "admin", (size_t )5);
  }
  }
#line 2306
  if (tmp___1 == 0) {
#line 2307
    return (info.admin_acl);
  }
  {
  {
#line 2308
  tmp___2 = ice_strncmp((char const   *)type, "all", (size_t )3);
  }
  }
#line 2308
  if (tmp___2 == 0) {
#line 2309
    return (info.all_acl);
  }
#line 2311
  return ((avl_tree *)((void *)0));
}
}
#line 2315 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_deny(com_request_t *req ) 
{ 
  char type[8192] ;
  char *arg ;
  char *tmp ;
  avl_tree *treetype ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 2318
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2318
  arg = tmp;
  }
#line 2321
  if (! arg) {
    {
    {
#line 2323
    admin_write((com_request_t const   *)req, (int const   )380, "deny <client|source|admin|all> <add|del|list> [hostmask]\r\n");
    }
    }
#line 2324
    return (0);
  } else {
    {
    {
#line 2321
    tmp___0 = splitc(type, arg, (char const   )' ');
    }
    }
#line 2321
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 2323
      admin_write((com_request_t const   *)req, (int const   )380, "deny <client|source|admin|all> <add|del|list> [hostmask]\r\n");
      }
      }
#line 2324
      return (0);
    }
  }
  {
  {
#line 2327
  treetype = get_acl_tree(type);
  }
  }
#line 2327
  if ((unsigned long )treetype == (unsigned long )((void *)0)) {
    {
    {
#line 2329
    admin_write((com_request_t const   *)req, (int const   )380, "deny <client|source|admin|all> <add|del|list> [hostmask]\r\n");
    }
    }
#line 2330
    return (0);
  }
  {
  {
#line 2332
  tmp___1 = com_restrict(req, treetype, (acltype_t )0);
  }
  }
#line 2332
  return (tmp___1);
}
}
#line 2336 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_allow(com_request_t *req ) 
{ 
  char type[8192] ;
  char *arg ;
  char *tmp ;
  avl_tree *treetype ;
  char *tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 2339
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2339
  arg = tmp;
  }
#line 2342
  if (! arg) {
    {
    {
#line 2344
    admin_write((com_request_t const   *)req, (int const   )380, "allow <client|source|admin|all> <add|del|list> [hostmask]\r\n");
    }
    }
#line 2345
    return (0);
  } else {
    {
    {
#line 2342
    tmp___0 = splitc(type, arg, (char const   )' ');
    }
    }
#line 2342
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 2344
      admin_write((com_request_t const   *)req, (int const   )380, "allow <client|source|admin|all> <add|del|list> [hostmask]\r\n");
      }
      }
#line 2345
      return (0);
    }
  }
  {
  {
#line 2348
  treetype = get_acl_tree(type);
  }
  }
#line 2348
  if ((unsigned long )treetype == (unsigned long )((void *)0)) {
    {
    {
#line 2350
    admin_write((com_request_t const   *)req, (int const   )380, "allow <client|source|admin|all> <add|del|list> [hostmask]\r\n");
    }
    }
#line 2351
    return (0);
  }
  {
  {
#line 2354
  tmp___1 = com_restrict(req, treetype, (acltype_t )1);
  }
  }
#line 2354
  return (tmp___1);
}
}
#line 2358 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_acl(com_request_t *req ) 
{ 
  avl_tree *treetype ;
  char *arg ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 2362
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2362
  arg = tmp;
  }
#line 2364
  if (! arg) {
    {
    {
#line 2366
    admin_write((com_request_t const   *)req, (int const   )600, "acl []\r\n");
    }
    }
#line 2367
    return (0);
  }
  {
  {
#line 2370
  treetype = get_acl_tree((char *)"all");
  }
  }
#line 2370
  if ((unsigned long )treetype == (unsigned long )((void *)0)) {
    {
    {
#line 2372
    admin_write((com_request_t const   *)req, (int const   )600, "acl []\r\n");
    }
    }
#line 2373
    return (0);
  }
  {
#line 2376
  req->arg = (char *)"list";
  {
#line 2378
  tmp___0 = com_restrict(req, treetype, (acltype_t )2);
  }
  }
#line 2378
  return (tmp___0);
}
}
#line 2382 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_modify(com_request_t *req ) 
{ 
  char cid[8192] ;
  char carg[8192] ;
  char *arg ;
  char *tmp ;
  connection_t *sourcecon ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
  {
#line 2385
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2385
  arg = tmp;
  }
#line 2389
  if (! arg) {
    {
    {
#line 2391
    admin_write((com_request_t const   *)req, (int const   )400, "modify <source_id> <-mungPdpb> <argument>\r\n");
    }
    }
#line 2392
    return (0);
  } else
#line 2389
  if (! *(arg + 0)) {
    {
    {
#line 2391
    admin_write((com_request_t const   *)req, (int const   )400, "modify <source_id> <-mungPdpb> <argument>\r\n");
    }
    }
#line 2392
    return (0);
  } else {
    {
    {
#line 2389
    tmp___0 = splitc(cid, arg, (char const   )' ');
    }
    }
#line 2389
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 2391
      admin_write((com_request_t const   *)req, (int const   )400, "modify <source_id> <-mungPdpb> <argument>\r\n");
      }
      }
#line 2392
      return (0);
    }
  }
  {
  {
#line 2395
  tmp___1 = atoi((char const   *)(cid));
  }
  {
#line 2395
  sourcecon = find_source_with_id(tmp___1);
  }
  }
#line 2396
  if (! sourcecon) {
    {
    {
#line 2398
    admin_write_line((com_request_t const   *)req, (int const   )401, "No source found with id [%s]",
                     cid);
    }
    }
#line 2399
    return (0);
  }
#line 2402
  if ((int )*(arg + 0) != 45) {
    {
    {
#line 2404
    admin_write((com_request_t const   *)req, (int const   )400, "modify <source_id> <-mungPdpb> <argument>\r\n");
    }
    }
#line 2405
    return (0);
  }
  {
  {
#line 2408
  tmp___2 = splitc(carg, arg, (char const   )' ');
  }
  }
#line 2408
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
    {
#line 2409
    strncpy((char */* __restrict  */)(carg), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
#line 2413
  if ((int )carg[1] == 98) {
#line 2413
    goto case_98;
  }
#line 2416
  if ((int )carg[1] == 112) {
#line 2416
    goto case_112;
  }
#line 2419
  if ((int )carg[1] == 80) {
#line 2419
    goto case_80;
  }
#line 2422
  if ((int )carg[1] == 100) {
#line 2422
    goto case_100;
  }
#line 2426
  if ((int )carg[1] == 103) {
#line 2426
    goto case_103;
  }
#line 2430
  if ((int )carg[1] == 110) {
#line 2430
    goto case_110;
  }
#line 2434
  if ((int )carg[1] == 117) {
#line 2434
    goto case_117;
  }
#line 2438
  if ((int )carg[1] == 109) {
#line 2438
    goto case_109;
  }
#line 2442
  goto switch_default;
  case_98: /* CIL Label */ 
  {
  {
#line 2414
  (sourcecon->food.source)->audiocast.bitrate = atoi((char const   *)arg);
  }
  }
#line 2415
  goto switch_break;
  case_112: /* CIL Label */ 
  {
  {
#line 2417
  (sourcecon->food.source)->audiocast.public = atoi((char const   *)arg);
  }
  }
#line 2418
  goto switch_break;
  case_80: /* CIL Label */ 
  {
  {
#line 2420
  (sourcecon->food.source)->priority = atoi((char const   *)arg);
  }
  }
#line 2421
  goto switch_break;
  case_100: /* CIL Label */ 
  {
  {
#line 2423
  n_free((void *)(sourcecon->food.source)->audiocast.description, (int const   )2423,
         "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
#line 2423
  (sourcecon->food.source)->audiocast.description = (char *)((void *)0);
  {
#line 2424
  (sourcecon->food.source)->audiocast.description = n_strdup((char const   *)arg,
                                                             (int const   )2424, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 2425
  goto switch_break;
  case_103: /* CIL Label */ 
  {
  {
#line 2427
  n_free((void *)(sourcecon->food.source)->audiocast.genre, (int const   )2427, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
#line 2427
  (sourcecon->food.source)->audiocast.genre = (char *)((void *)0);
  {
#line 2428
  (sourcecon->food.source)->audiocast.genre = n_strdup((char const   *)arg, (int const   )2428,
                                                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 2429
  goto switch_break;
  case_110: /* CIL Label */ 
  {
  {
#line 2431
  n_free((void *)(sourcecon->food.source)->audiocast.name, (int const   )2431, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
#line 2431
  (sourcecon->food.source)->audiocast.name = (char *)((void *)0);
  {
#line 2432
  (sourcecon->food.source)->audiocast.name = n_strdup((char const   *)arg, (int const   )2432,
                                                      "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 2433
  goto switch_break;
  case_117: /* CIL Label */ 
  {
  {
#line 2435
  n_free((void *)(sourcecon->food.source)->audiocast.url, (int const   )2435, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
#line 2435
  (sourcecon->food.source)->audiocast.url = (char *)((void *)0);
  {
#line 2436
  (sourcecon->food.source)->audiocast.url = n_strdup((char const   *)arg, (int const   )2436,
                                                     "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 2437
  goto switch_break;
  case_109: /* CIL Label */ 
  {
  {
#line 2439
  n_free((void *)(sourcecon->food.source)->audiocast.mount, (int const   )2439, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
#line 2439
  (sourcecon->food.source)->audiocast.mount = (char *)((void *)0);
  {
#line 2440
  (sourcecon->food.source)->audiocast.mount = n_strdup((char const   *)arg, (int const   )2440,
                                                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
  }
  }
#line 2441
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 2443
  admin_write((com_request_t const   *)req, (int const   )400, "modify <source_id> <-mungPdpb> <argument>\r\n");
  }
  }
#line 2444
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 2446
  admin_write_line((com_request_t const   *)req, (int const   )402, "Value changed to [%s]",
                   arg);
  }
  }
#line 2447
  return (1);
}
}
#line 2450 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void show_lock_status(com_request_t *req , char *name , mutex_t *mutex ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2453
  if (mutex->lineno >= 0) {
#line 2454
    if (mutex->thread_id >= 0L) {
#line 2454
      tmp = "locked";
    } else {
#line 2454
      tmp = "unlocked";
    }
    {
    {
#line 2454
    admin_write_line((com_request_t const   *)req, (int const   )410, "Mutex: [%21s] Status: [%8s] Thread: [%d] Locked on line: [%d]",
                     name, tmp, mutex->thread_id, mutex->lineno);
    }
    }
  } else
#line 2455
  if (mutex->thread_id >= 0L) {
#line 2456
    if (mutex->thread_id >= 0L) {
#line 2456
      tmp___0 = "locked";
    } else {
#line 2456
      tmp___0 = "unlocked";
    }
    {
    {
#line 2456
    admin_write_line((com_request_t const   *)req, (int const   )410, "Mutex: [%21s] Status: [%8s] Thread: [%d]",
                     name, tmp___0, mutex->thread_id);
    }
    }
  } else {
#line 2458
    if (mutex->thread_id >= 0L) {
#line 2458
      tmp___1 = "locked";
    } else {
#line 2458
      tmp___1 = "unlocked";
    }
    {
    {
#line 2458
    admin_write_line((com_request_t const   *)req, (int const   )410, "Mutex: [%21s] Status: [%8s]",
                     name, tmp___1);
    }
    }
  }
#line 2459
  return;
}
}
#line 2461 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_locks(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 2469
  show_lock_status(req, (char *)"source mutex", & info.source_mutex);
  }
  {
#line 2470
  show_lock_status(req, (char *)"admin mutex", & info.admin_mutex);
  }
  {
#line 2471
  show_lock_status(req, (char *)"directory mutex", & info.directory_mutex);
  }
  {
#line 2472
  show_lock_status(req, (char *)"alias mutex", & info.alias_mutex);
  }
  {
#line 2473
  show_lock_status(req, (char *)"misc mutex", & info.misc_mutex);
  }
  {
#line 2474
  show_lock_status(req, (char *)"mount mutex", & info.mount_mutex);
  }
  {
#line 2475
  show_lock_status(req, (char *)"hostname mutex", & info.hostname_mutex);
  }
  {
#line 2476
  show_lock_status(req, (char *)"acl mutex", & info.acl_mutex);
  }
  {
#line 2477
  show_lock_status(req, (char *)"double mutex", & info.double_mutex);
  }
  {
#line 2478
  show_lock_status(req, (char *)"thread mutex", & info.thread_mutex);
  }
  {
#line 2479
  show_lock_status(req, (char *)"dns mutex", & info.resolvmutex);
  }
  {
#line 2480
  show_lock_status(req, (char *)"relay mutex", & info.relay_mutex);
  }
  {
#line 2487
  show_lock_status(req, (char *)"library mutex", & library_mutex);
  }
  {
#line 2488
  show_lock_status(req, (char *)"authentication mutex", & authentication_mutex);
  }
  }
#line 2489
  return (1);
}
}
#line 2494 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_debug(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 2497
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2497
  arg = tmp;
  }
#line 2499
  if (! arg) {
    {
    {
#line 2501
    admin_write_line((com_request_t const   *)req, (int const   )420, "Your debugging level is [%d]",
                     ((req->con)->food.admin)->debuglevel);
    }
    }
#line 2502
    return (1);
  }
  {
  {
#line 2505
  ((req->con)->food.admin)->debuglevel = atoi((char const   *)arg);
  }
  {
#line 2507
  admin_write_line((com_request_t const   *)req, (int const   )421, "Your debugging level is now [%d]",
                   ((req->con)->food.admin)->debuglevel);
  }
  }
#line 2508
  return (0);
}
}
#line 2513 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_auth(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char command[8192] ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 2516
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2516
  arg = tmp;
  }
#line 2519
  if (! arg) {
    {
    {
#line 2521
    admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
    }
    }
#line 2522
    return (0);
  } else
#line 2519
  if (! *(arg + 0)) {
    {
    {
#line 2521
    admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
    }
    }
#line 2522
    return (0);
  }
  {
  {
#line 2525
  rehash_authentication_scheme();
  }
  {
#line 2527
  tmp___0 = splitc(command, arg, (char const   )' ');
  }
  }
#line 2527
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
    {
#line 2529
    admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
    }
    }
#line 2530
    return (0);
  }
  {
  {
#line 2533
  tmp___6 = ice_strcmp((char const   *)(command), "add");
  }
  }
#line 2533
  if (tmp___6 == 0) {
    {
    {
#line 2534
    tmp___1 = com_auth_add(req, arg);
    }
    }
#line 2534
    return (tmp___1);
  } else {
    {
    {
#line 2535
    tmp___5 = ice_strcmp((char const   *)(command), "del");
    }
    }
#line 2535
    if (tmp___5 == 0) {
      {
      {
#line 2536
      tmp___2 = com_auth_del(req, arg);
      }
      }
#line 2536
      return (tmp___2);
    } else {
      {
      {
#line 2537
      tmp___4 = ice_strcmp((char const   *)(command), "list");
      }
      }
#line 2537
      if (tmp___4 == 0) {
        {
        {
#line 2538
        tmp___3 = com_auth_list(req, arg);
        }
        }
#line 2538
        return (tmp___3);
      } else {
        {
        {
#line 2540
        admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
        }
        }
      }
    }
  }
#line 2541
  return (0);
}
}
#line 2544 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_auth_add(com_request_t *req , char *arg ) 
{ 
  char type[8192] ;
  char firstarg[8192] ;
  int count ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 2548
  count = 0;
#line 2550
  type[0] = (char )'\000';
#line 2550
  firstarg[0] = type[0];
  {
#line 2552
  tmp = splitc(type, arg, (char const   )' ');
  }
  }
#line 2552
  if (! tmp) {
    {
    {
#line 2554
    admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
    }
    }
#line 2555
    return (0);
  }
  {
  {
#line 2558
  tmp___0 = splitc(firstarg, arg, (char const   )' ');
  }
  }
#line 2558
  if (tmp___0) {
#line 2563
    count = 2;
  } else {
    {
    {
#line 2560
    strncpy((char */* __restrict  */)(firstarg), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
#line 2561
    count = 1;
    }
  }
  {
  {
#line 2565
  tmp___8 = ice_strncmp((char const   *)(type), "user", (size_t )4);
  }
  }
#line 2565
  if (tmp___8 == 0) {
#line 2567
    if (count == 2) {
      {
      {
#line 2568
      tmp___1 = runtime_add_user((char const   *)(firstarg), (char const   *)arg);
      }
      }
#line 2568
      return (tmp___1);
    }
    {
    {
#line 2569
    admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
    }
    }
#line 2570
    return (0);
  } else {
    {
    {
#line 2571
    tmp___7 = ice_strncmp((char const   *)(type), "group", (size_t )5);
    }
    }
#line 2571
    if (tmp___7 == 0) {
#line 2573
      if (count == 2) {
        {
        {
#line 2574
        tmp___2 = runtime_add_group_with_user((char const   *)(firstarg), arg);
        }
        }
#line 2574
        return (tmp___2);
      }
      {
      {
#line 2575
      tmp___3 = runtime_add_group((char const   *)(firstarg));
      }
      }
#line 2575
      return (tmp___3);
    } else {
      {
      {
#line 2576
      tmp___6 = ice_strncmp((char const   *)(type), "mount", (size_t )5);
      }
      }
#line 2576
      if (tmp___6 == 0) {
#line 2578
        if (count == 2) {
          {
          {
#line 2579
          tmp___4 = runtime_add_mount_with_group((char const   *)(firstarg), arg);
          }
          }
#line 2579
          return (tmp___4);
        }
        {
        {
#line 2580
        tmp___5 = runtime_add_mount((char const   *)(firstarg));
        }
        }
#line 2580
        return (tmp___5);
      }
    }
  }
  {
  {
#line 2583
  admin_write((com_request_t const   *)req, (int const   )430, "auth <add|del|list> <group|user|mount> [user password|group [user user2...]|mount [group group2...]\r\n");
  }
  }
#line 2584
  return (0);
}
}
#line 2588 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_auth_del(com_request_t *req , char *arg ) 
{ 


  {
#line 2591
  return (1);
}
}
#line 2594 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_auth_list(com_request_t *req , char *arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 2597
  tmp___1 = ice_strncmp((char const   *)arg, "user", (size_t )4);
  }
  }
#line 2597
  if (tmp___1 == 0) {
    {
    {
#line 2598
    con_display_users(req);
    }
    }
  } else {
    {
    {
#line 2599
    tmp___0 = ice_strncmp((char const   *)arg, "group", (size_t )5);
    }
    }
#line 2599
    if (tmp___0 == 0) {
      {
      {
#line 2600
      con_display_groups(req);
      }
      }
    } else {
      {
      {
#line 2601
      tmp = ice_strncmp((char const   *)arg, "mount", (size_t )5);
      }
      }
#line 2601
      if (tmp == 0) {
        {
        {
#line 2602
        con_display_mounts(req);
        }
        }
      }
    }
  }
#line 2603
  return (1);
}
}
#line 2606 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_mem(com_request_t *req ) 
{ 
  struct mallinfo malli ;
  struct mallinfo tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 2623
  admin_write_line((com_request_t const   *)req, (int const   )550, "No internal memory debug information available in this binary");
  }
  {
#line 2653
  tmp = mallinfo();
  }
#line 2653
  malli = tmp;
  {
#line 2654
  admin_write_line((com_request_t const   *)req, (int const   )556, "Information as reported by libc malloc():");
  }
  {
#line 2655
  admin_write_line((com_request_t const   *)req, (int const   )553, "Total bytes allocated by malloc: %d",
                   malli.arena);
  }
  {
#line 2656
  admin_write_line((com_request_t const   *)req, (int const   )554, "Chunks not in use %d",
                   malli.ordblks);
  }
  {
#line 2657
  admin_write_line((com_request_t const   *)req, (int const   )557, "Chunks allocated by mmap: %d",
                   malli.hblks);
  }
  {
#line 2658
  admin_write_line((com_request_t const   *)req, (int const   )555, "Total bytes allocated by mmap: %d",
                   malli.hblkhd);
  }
  {
#line 2659
  admin_write_line((com_request_t const   *)req, (int const   )558, "Total memory occupied by malloc chunks: %d",
                   malli.uordblks);
  }
  {
#line 2660
  admin_write_line((com_request_t const   *)req, (int const   )559, "Total memory occupied by free (not in use): %d",
                   malli.fordblks);
  }
  {
#line 2661
  admin_write_line((com_request_t const   *)req, (int const   )560, "Top-most releaseable chunksize: %d",
                   malli.keepcost);
  }
  }
#line 2664
  return (1);
}
}
#line 2669 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_streamtitle(com_request_t *req ) 
{ 
  int all___0 ;
  char id[8192] ;
  char *ptr ;
  char *arg ;
  char *tmp ;
  avl_traverser trav ;
  connection_t *sourcecon ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 2672
  all___0 = 0;
  {
#line 2674
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2674
  arg = tmp;
#line 2675
  trav.init = 0;
#line 2675
  trav.nstack = 0;
#line 2675
  trav.p = (avl_node const   *)0;
#line 2675
  trav.stack[0] = (avl_node const   *)0;
#line 2675
  trav.stack[1] = (avl_node const   *)0;
#line 2675
  trav.stack[2] = (avl_node const   *)0;
#line 2675
  trav.stack[3] = (avl_node const   *)0;
#line 2675
  trav.stack[4] = (avl_node const   *)0;
#line 2675
  trav.stack[5] = (avl_node const   *)0;
#line 2675
  trav.stack[6] = (avl_node const   *)0;
#line 2675
  trav.stack[7] = (avl_node const   *)0;
#line 2675
  trav.stack[8] = (avl_node const   *)0;
#line 2675
  trav.stack[9] = (avl_node const   *)0;
#line 2675
  trav.stack[10] = (avl_node const   *)0;
#line 2675
  trav.stack[11] = (avl_node const   *)0;
#line 2675
  trav.stack[12] = (avl_node const   *)0;
#line 2675
  trav.stack[13] = (avl_node const   *)0;
#line 2675
  trav.stack[14] = (avl_node const   *)0;
#line 2675
  trav.stack[15] = (avl_node const   *)0;
#line 2675
  trav.stack[16] = (avl_node const   *)0;
#line 2675
  trav.stack[17] = (avl_node const   *)0;
#line 2675
  trav.stack[18] = (avl_node const   *)0;
#line 2675
  trav.stack[19] = (avl_node const   *)0;
#line 2675
  trav.stack[20] = (avl_node const   *)0;
#line 2675
  trav.stack[21] = (avl_node const   *)0;
#line 2675
  trav.stack[22] = (avl_node const   *)0;
#line 2675
  trav.stack[23] = (avl_node const   *)0;
#line 2675
  trav.stack[24] = (avl_node const   *)0;
#line 2675
  trav.stack[25] = (avl_node const   *)0;
#line 2675
  trav.stack[26] = (avl_node const   *)0;
#line 2675
  trav.stack[27] = (avl_node const   *)0;
#line 2675
  trav.stack[28] = (avl_node const   *)0;
#line 2675
  trav.stack[29] = (avl_node const   *)0;
#line 2675
  trav.stack[30] = (avl_node const   *)0;
#line 2675
  trav.stack[31] = (avl_node const   *)0;
#line 2676
  sourcecon = (connection_t *)((void *)0);
  }
#line 2678
  if (! arg) {
    {
    {
#line 2680
    admin_write((com_request_t const   *)req, (int const   )460, "streamtitle <-a|source_id> <message>\r\n");
    }
    }
#line 2681
    return (0);
  } else
#line 2678
  if (! *(arg + 0)) {
    {
    {
#line 2680
    admin_write((com_request_t const   *)req, (int const   )460, "streamtitle <-a|source_id> <message>\r\n");
    }
    }
#line 2681
    return (0);
  }
#line 2684
  if ((int )*(arg + 0) == 45) {
#line 2686
    if ((int )*(arg + 1) == 97) {
#line 2687
      all___0 = 1;
    }
    {
    {
#line 2688
    splitc((char *)((void *)0), arg, (char const   )' ');
    }
    }
  }
#line 2691
  if (all___0 == 0) {
    {
    {
#line 2691
    tmp___0 = splitc(id, arg, (char const   )' ');
    }
    }
#line 2691
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 2693
      admin_write((com_request_t const   *)req, (int const   )460, "streamtitle <-a|source_id> <message>\r\n");
      }
      }
#line 2694
      return (0);
    }
  }
#line 2697
  if (all___0) {
    {
    {
#line 2699
    thread_mutex_lock_c(& info.source_mutex, 2699, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 2701
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 2701
      tmp___1 = avl_traverse(info.sources, & trav);
      }
#line 2701
      sourcecon = (connection_t *)tmp___1;
      }
#line 2701
      if (! sourcecon) {
#line 2701
        goto while_break;
      }
      {
#line 2703
      ptr = (sourcecon->food.source)->info.streamtitle;
      {
#line 2704
      (sourcecon->food.source)->info.streamtitle = n_strdup((char const   *)arg, (int const   )2704,
                                                            "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2705
      ((sourcecon->food.source)->info.udpseqnr) ++;
      {
#line 2706
      n_free((void *)ptr, (int const   )2706, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2706
      ptr = (char *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 2709
    thread_mutex_unlock_c(& info.source_mutex, 2709, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 2710
    admin_write_line((com_request_t const   *)req, (int const   )461, "Set all source titles to %s",
                     arg);
    }
    }
  } else {
    {
    {
#line 2713
    tmp___2 = atoi((char const   *)(id));
    }
    {
#line 2713
    sourcecon = find_source_with_id(tmp___2);
    }
    }
#line 2715
    if (sourcecon) {
      {
#line 2717
      ptr = (sourcecon->food.source)->info.streamtitle;
      {
#line 2718
      (sourcecon->food.source)->info.streamtitle = n_strdup((char const   *)arg, (int const   )2718,
                                                            "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2719
      ((sourcecon->food.source)->info.udpseqnr) ++;
      {
#line 2720
      n_free((void *)ptr, (int const   )2720, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2720
      ptr = (char *)((void *)0);
      }
    } else {
      {
      {
#line 2722
      tmp___3 = atoi((char const   *)(id));
      }
      {
#line 2722
      admin_write_line((com_request_t const   *)req, (int const   )462, "No source with id %d",
                       tmp___3);
      }
      }
#line 2723
      return (0);
    }
    {
    {
#line 2725
    tmp___4 = atoi((char const   *)(id));
    }
    {
#line 2725
    admin_write_line((com_request_t const   *)req, (int const   )463, "Set source title for source %d to %s",
                     tmp___4, arg);
    }
    }
  }
#line 2727
  return (1);
}
}
#line 2731 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_streamurl(com_request_t *req ) 
{ 
  int all___0 ;
  char id[8192] ;
  char *ptr ;
  char *arg ;
  char *tmp ;
  avl_traverser trav ;
  connection_t *sourcecon ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 2734
  all___0 = 0;
  {
#line 2735
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2735
  arg = tmp;
#line 2736
  trav.init = 0;
#line 2736
  trav.nstack = 0;
#line 2736
  trav.p = (avl_node const   *)0;
#line 2736
  trav.stack[0] = (avl_node const   *)0;
#line 2736
  trav.stack[1] = (avl_node const   *)0;
#line 2736
  trav.stack[2] = (avl_node const   *)0;
#line 2736
  trav.stack[3] = (avl_node const   *)0;
#line 2736
  trav.stack[4] = (avl_node const   *)0;
#line 2736
  trav.stack[5] = (avl_node const   *)0;
#line 2736
  trav.stack[6] = (avl_node const   *)0;
#line 2736
  trav.stack[7] = (avl_node const   *)0;
#line 2736
  trav.stack[8] = (avl_node const   *)0;
#line 2736
  trav.stack[9] = (avl_node const   *)0;
#line 2736
  trav.stack[10] = (avl_node const   *)0;
#line 2736
  trav.stack[11] = (avl_node const   *)0;
#line 2736
  trav.stack[12] = (avl_node const   *)0;
#line 2736
  trav.stack[13] = (avl_node const   *)0;
#line 2736
  trav.stack[14] = (avl_node const   *)0;
#line 2736
  trav.stack[15] = (avl_node const   *)0;
#line 2736
  trav.stack[16] = (avl_node const   *)0;
#line 2736
  trav.stack[17] = (avl_node const   *)0;
#line 2736
  trav.stack[18] = (avl_node const   *)0;
#line 2736
  trav.stack[19] = (avl_node const   *)0;
#line 2736
  trav.stack[20] = (avl_node const   *)0;
#line 2736
  trav.stack[21] = (avl_node const   *)0;
#line 2736
  trav.stack[22] = (avl_node const   *)0;
#line 2736
  trav.stack[23] = (avl_node const   *)0;
#line 2736
  trav.stack[24] = (avl_node const   *)0;
#line 2736
  trav.stack[25] = (avl_node const   *)0;
#line 2736
  trav.stack[26] = (avl_node const   *)0;
#line 2736
  trav.stack[27] = (avl_node const   *)0;
#line 2736
  trav.stack[28] = (avl_node const   *)0;
#line 2736
  trav.stack[29] = (avl_node const   *)0;
#line 2736
  trav.stack[30] = (avl_node const   *)0;
#line 2736
  trav.stack[31] = (avl_node const   *)0;
  }
#line 2739
  if (! arg) {
    {
    {
#line 2741
    admin_write((com_request_t const   *)req, (int const   )470, "streamurl [-a] <url>\r\n");
    }
    }
#line 2742
    return (0);
  } else
#line 2739
  if (! *(arg + 0)) {
    {
    {
#line 2741
    admin_write((com_request_t const   *)req, (int const   )470, "streamurl [-a] <url>\r\n");
    }
    }
#line 2742
    return (0);
  }
#line 2745
  if ((int )*(arg + 0) == 45) {
#line 2747
    if ((int )*(arg + 1) == 97) {
#line 2748
      all___0 = 1;
    }
    {
    {
#line 2749
    splitc((char *)((void *)0), arg, (char const   )' ');
    }
    }
  }
#line 2752
  if (all___0 == 0) {
    {
    {
#line 2752
    tmp___0 = splitc(id, arg, (char const   )' ');
    }
    }
#line 2752
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 2754
      admin_write((com_request_t const   *)req, (int const   )470, "streamurl [-a] <url>\r\n");
      }
      }
#line 2755
      return (0);
    }
  }
#line 2758
  if (all___0) {
    {
    {
#line 2760
    thread_mutex_lock_c(& info.source_mutex, 2760, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
    {
    {
#line 2762
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
      {
      {
#line 2762
      tmp___1 = avl_traverse(info.sources, & trav);
      }
#line 2762
      sourcecon = (connection_t *)tmp___1;
      }
#line 2762
      if (! sourcecon) {
#line 2762
        goto while_break;
      }
      {
#line 2764
      ptr = (sourcecon->food.source)->info.streamurl;
      {
#line 2765
      (sourcecon->food.source)->info.streamurl = n_strdup((char const   *)arg, (int const   )2765,
                                                          "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2766
      ((sourcecon->food.source)->info.udpseqnr) ++;
      {
#line 2767
      n_free((void *)ptr, (int const   )2767, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2767
      ptr = (char *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 2770
    thread_mutex_unlock_c(& info.source_mutex, 2770, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 2771
    admin_write_line((com_request_t const   *)req, (int const   )471, "Set all source urls to %s",
                     arg);
    }
    }
  } else {
    {
    {
#line 2774
    tmp___2 = atoi((char const   *)(id));
    }
    {
#line 2774
    sourcecon = find_source_with_id(tmp___2);
    }
    }
#line 2776
    if (sourcecon) {
      {
#line 2778
      ptr = (sourcecon->food.source)->info.streamurl;
      {
#line 2779
      (sourcecon->food.source)->info.streamurl = n_strdup((char const   *)arg, (int const   )2779,
                                                          "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2780
      ((sourcecon->food.source)->info.udpseqnr) ++;
      {
#line 2781
      n_free((void *)ptr, (int const   )2781, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
      }
#line 2781
      ptr = (char *)((void *)0);
      }
    } else {
      {
      {
#line 2783
      tmp___3 = atoi((char const   *)(id));
      }
      {
#line 2783
      admin_write_line((com_request_t const   *)req, (int const   )472, "No source with id %d",
                       tmp___3);
      }
      }
#line 2784
      return (0);
    }
    {
    {
#line 2786
    tmp___4 = atoi((char const   *)(id));
    }
    {
#line 2786
    admin_write_line((com_request_t const   *)req, (int const   )473, "Set source url for source %d to %s",
                     tmp___4, arg);
    }
    }
  }
#line 2788
  return (1);
}
}
#line 2792 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_describe(com_request_t *req ) 
{ 
  int id ;
  connection_t *idcon ;
  char *arg ;
  char *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 2797
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2797
  arg = tmp;
  }
#line 2799
  if (! req) {
#line 2800
    return (0);
  } else
#line 2801
  if (! arg) {
    {
    {
#line 2803
    admin_write_line((com_request_t const   *)req, (int const   )480, "describe <id>\r\n");
    }
    }
#line 2804
    return (0);
  } else
#line 2801
  if (! *(arg + 0)) {
    {
    {
#line 2803
    admin_write_line((com_request_t const   *)req, (int const   )480, "describe <id>\r\n");
    }
    }
#line 2804
    return (0);
  }
  {
  {
#line 2807
  id = atoi((char const   *)arg);
  }
  {
#line 2809
  idcon = find_id(id);
  }
  }
#line 2811
  if (! idcon) {
    {
    {
#line 2813
    admin_write_line((com_request_t const   *)req, (int const   )481, "No connection found with id [%d]",
                     id);
    }
    }
#line 2814
    return (0);
  }
  {
#line 2819
  if ((unsigned int )idcon->type == 0U) {
#line 2819
    goto case_0;
  }
#line 2822
  if ((unsigned int )idcon->type == 1U) {
#line 2822
    goto case_1;
  }
#line 2825
  if ((unsigned int )idcon->type == 2U) {
#line 2825
    goto case_2;
  }
#line 2828
  goto switch_default;
  case_0: /* CIL Label */ 
  {
  {
#line 2820
  describe_client((com_request_t const   *)req, (connection_t const   *)idcon);
  }
  }
#line 2821
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 2823
  describe_source((com_request_t const   *)req, (connection_t const   *)idcon);
  }
  }
#line 2824
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 2826
  describe_admin((com_request_t const   *)req, (connection_t const   *)idcon);
  }
  }
#line 2827
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
#line 2829
  admin_write_line((com_request_t const   *)req, (int const   )482, "Unknown connection type on connection id [%d]",
                   id);
  }
  }
#line 2830
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2832
  return (1);
}
}
#line 2835 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_scheme(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 2838
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2838
  arg = tmp;
  }
#line 2840
  if (! req) {
#line 2841
    return (0);
  }
#line 2843
  if (! arg) {
    {
#line 2847
    if ((unsigned int )((req->con)->food.admin)->scheme == 1U) {
#line 2847
      goto case_1;
    }
#line 2850
    if ((unsigned int )((req->con)->food.admin)->scheme == 0U) {
#line 2850
      goto case_0;
    }
#line 2853
    if ((unsigned int )((req->con)->food.admin)->scheme == 2U) {
#line 2853
      goto case_2;
    }
#line 2845
    goto switch_break;
    case_1: /* CIL Label */ 
    {
    {
#line 2848
    admin_write_line((com_request_t const   *)req, (int const   )510, "Using default output scheme");
    }
    }
#line 2849
    goto switch_break;
    case_0: /* CIL Label */ 
    {
    {
#line 2851
    admin_write_line((com_request_t const   *)req, (int const   )510, "Using html output scheme");
    }
    }
#line 2852
    goto switch_break;
    case_2: /* CIL Label */ 
    {
    {
#line 2854
    admin_write_line((com_request_t const   *)req, (int const   )510, "Using tagged output scheme");
    }
    }
#line 2855
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2857
    return (1);
  } else {
    {
    {
#line 2860
    tmp___2 = ice_strcasecmp((char const   *)arg, "html");
    }
    }
#line 2860
    if (tmp___2 == 0) {
#line 2861
      ((req->con)->food.admin)->scheme = (scheme_t )0;
    } else {
      {
      {
#line 2862
      tmp___1 = ice_strcasecmp((char const   *)arg, "default");
      }
      }
#line 2862
      if (tmp___1 == 0) {
#line 2863
        ((req->con)->food.admin)->scheme = (scheme_t )1;
      } else {
        {
        {
#line 2864
        tmp___0 = ice_strcasecmp((char const   *)arg, "tagged");
        }
        }
#line 2864
        if (tmp___0 == 0) {
#line 2865
          ((req->con)->food.admin)->scheme = (scheme_t )2;
        } else {
          {
          {
#line 2868
          admin_write_line((com_request_t const   *)req, (int const   )511, "No such scheme [%s]",
                           arg);
          }
          }
#line 2869
          return (0);
        }
      }
    }
  }
  {
  {
#line 2873
  admin_write_line((com_request_t const   *)req, (int const   )512, "Changed scheme to %s",
                   arg);
  }
  }
#line 2874
  return (1);
}
}
#line 2878 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_ping(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char host[8192] ;
  char timebuf[8192] ;
  int s ;
  int port ;
  time_t before ;
  char *tmp___0 ;
  long tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 2881
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2881
  arg = tmp;
#line 2883
  port = info.port[0];
#line 2884
  before = (time_t )0;
  }
#line 2886
  if (! arg) {
    {
    {
#line 2888
    admin_write_line((com_request_t const   *)req, (int const   )540, "ping <host[:port]>");
    }
    }
#line 2889
    return (0);
  } else
#line 2886
  if (! *(arg + 0)) {
    {
    {
#line 2888
    admin_write_line((com_request_t const   *)req, (int const   )540, "ping <host[:port]>");
    }
    }
#line 2889
    return (0);
  }
  {
#line 2892
  host[0] = (char )'\000';
  {
#line 2894
  tmp___0 = splitc(host, arg, (char const   )':');
  }
  }
#line 2894
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    {
    {
#line 2895
    port = atoi((char const   *)arg);
    }
    }
  } else {
    {
    {
#line 2897
    strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)arg,
            (size_t )8192);
    }
    }
  }
  {
  {
#line 2899
  admin_write_line((com_request_t const   *)req, (int const   )541, "Connecting to [%s] on port [%d] (will timeout after 30 seconds)",
                   host, port);
  }
  {
#line 2901
  before = get_time();
  }
  {
#line 2903
  s = sock_connect_wto((char const   *)(host), (int const   )port, (int const   )30);
  }
  {
#line 2903
  tmp___3 = sock_valid((SOCKET const   )s);
  }
  }
#line 2903
  if (! tmp___3) {
    {
    {
#line 2905
    tmp___1 = get_time();
    }
    {
#line 2905
    tmp___2 = nice_time((unsigned long )(tmp___1 - before), timebuf);
    }
    {
#line 2905
    admin_write_line((com_request_t const   *)req, (int const   )542, "Connect to [%s:%d] failed. Connect took %s",
                     host, port, tmp___2);
    }
    }
#line 2906
    return (0);
  }
  {
  {
#line 2909
  tmp___4 = get_time();
  }
  {
#line 2909
  tmp___5 = nice_time((unsigned long )(tmp___4 - before), timebuf);
  }
  {
#line 2909
  admin_write_line((com_request_t const   *)req, (int const   )543, "Connected to [%s:%d] after %s...",
                   host, port, tmp___5);
  }
  {
#line 2910
  sock_write_line(s, "PING\r\n");
  }
  {
#line 2912
  tmp___6 = get_time();
  }
  {
#line 2912
  tmp___7 = nice_time((unsigned long )(tmp___6 - before), timebuf);
  }
  {
#line 2912
  admin_write_line((com_request_t const   *)req, (int const   )544, "Pong response from [%s:%d] after %s, terminating connection.",
                   host, port, tmp___7);
  }
  }
#line 2914
  return (1);
}
}
#line 2917 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_resolv(com_request_t *req ) 
{ 
  char *arg ;
  char *tmp ;
  char *out ;
  char outtarget[20] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
  {
#line 2920
  tmp = com_arg((com_request_t const   *)req);
  }
#line 2920
  arg = tmp;
  }
#line 2923
  if (! arg) {
    {
    {
#line 2925
    admin_write_line((com_request_t const   *)req, (int const   )520, "Resolv what?");
    }
    }
#line 2926
    return (0);
  } else
#line 2923
  if (! *(arg + 0)) {
    {
    {
#line 2925
    admin_write_line((com_request_t const   *)req, (int const   )520, "Resolv what?");
    }
    }
#line 2926
    return (0);
  }
  {
  {
#line 2929
  tmp___1 = __ctype_b_loc();
  }
  }
#line 2929
  if ((int const   )*(*tmp___1 + (int )*(arg + 0)) & 2048) {
    {
    {
#line 2929
    tmp___2 = __ctype_b_loc();
    }
    {
#line 2929
    tmp___3 = strlen((char const   *)arg);
    }
    }
#line 2929
    if ((int const   )*(*tmp___2 + (int )*(arg + (tmp___3 - 1U))) & 2048) {
      {
      {
#line 2931
      out = reverse((char const   *)arg);
      }
      }
#line 2932
      if (! out) {
        {
        {
#line 2933
        admin_write_line((com_request_t const   *)req, (int const   )521, "No such host [%s]",
                         arg);
        }
        }
      } else {
        {
        {
#line 2936
        admin_write_line((com_request_t const   *)req, (int const   )522, "[%s] is [%s]",
                         arg, out);
        }
        {
#line 2937
        n_free((void *)out, (int const   )2937, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
        }
#line 2937
        out = (char *)((void *)0);
        }
      }
    } else {
#line 2929
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 2940
    tmp___0 = forward((char const   *)arg, outtarget);
    }
    }
#line 2940
    if (tmp___0) {
      {
      {
#line 2943
      admin_write_line((com_request_t const   *)req, (int const   )522, "[%s] is [%s]",
                       arg, outtarget);
      }
      }
    } else {
      {
      {
#line 2941
      admin_write_line((com_request_t const   *)req, (int const   )521, "No such host [%s]",
                       arg);
      }
      }
    }
  }
#line 2945
  return (1);
}
}
#line 2948 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_runtime(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 2951
  admin_write_line((com_request_t const   *)req, (int const   )530, "Runtime Configuration:");
  }
  {
#line 2953
  admin_write_line((com_request_t const   *)req, (int const   )531, "Using nanosleep() as sleep method");
  }
  {
#line 2963
  admin_write_line((com_request_t const   *)req, (int const   )532, "Using %d chunks of %d bytes for client backlog",
                   64, 8192);
  }
  }
  {
#line 2967
  if ((unsigned int )info.resolv_type == 2U) {
#line 2967
    goto case_2;
  }
#line 2970
  if ((unsigned int )info.resolv_type == 1U) {
#line 2970
    goto case_1;
  }
#line 2973
  if ((unsigned int )info.resolv_type == 3U) {
#line 2973
    goto case_3;
  }
#line 2965
  goto switch_break;
  case_2: /* CIL Label */ 
  {
  {
#line 2968
  admin_write_line((com_request_t const   *)req, (int const   )533, "Using solaris own gethostbyname_r() and getaddrbyname_r(), which is good.");
  }
  }
#line 2969
  goto switch_break;
  case_1: /* CIL Label */ 
  {
  {
#line 2971
  admin_write_line((com_request_t const   *)req, (int const   )533, "Using linux own gethostbyname_r() and getaddrbyname_r(), which is good.");
  }
  }
#line 2972
  goto switch_break;
  case_3: /* CIL Label */ 
  {
  {
#line 2974
  admin_write_line((com_request_t const   *)req, (int const   )533, "Using standard gethostbyname() and getaddrbyname(), which might be dangerous cause it\'s not threadsafe!");
  }
  }
#line 2975
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
#line 2979
  admin_write_line((com_request_t const   *)req, (int const   )536, "Using posix signal interface to block all signals in threads that don\'t want them");
  }
  }
#line 2999
  return (1);
}
}
#line 3003 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_run(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 3024
  write_log(0, (char *)"This binary has not been compiled with python interpreter support. You can\'t do that!");
  }
  }
#line 3026
  return (1);
}
}
#line 3030 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int com_sock(com_request_t *req ) 
{ 
  char *__cil_tmp2 ;

  {
  {
  {
#line 3034
  write_log(0, (char *)"This binary has not been compiled with DEBUG_SOCKETS, no socket information available");
  }
  }
#line 3035
  return (1);
}
}
#line 3100 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void zero_opts(int *opt , int maxelements ) 
{ 
  int i ;

  {
#line 3105
  if (! opt) {
#line 3106
    return;
  }
#line 3108
  i = 0;
  {
  {
#line 3108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3108
    if (! (i < maxelements)) {
#line 3108
      goto while_break;
    }
#line 3109
    *(opt + i) = 0;
#line 3108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3110
  return;
}
}
#line 3112 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void set_opts(int *opt , char const   *arg , conopt_t *opts , int maxelements ) 
{ 
  int i ;
  int k ;

  {
#line 3117
  if (! opt) {
#line 3118
    return;
  } else
#line 3117
  if (! arg) {
#line 3118
    return;
  } else
#line 3117
  if (! opts) {
#line 3118
    return;
  } else
#line 3117
  if (maxelements < 0) {
#line 3118
    return;
  }
#line 3120
  i = 0;
  {
  {
#line 3120
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3120
    if (! *(arg + i)) {
#line 3120
      goto while_break;
    }
#line 3122
    if ((int const   )*(arg + i) == 45) {
#line 3123
      goto __Cont;
    }
#line 3125
    k = 0;
    {
    {
#line 3125
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3125
      if (! (k < maxelements)) {
#line 3125
        goto while_break___0;
      }
#line 3127
      if ((int )(opts + k)->opt == (int )*(arg + i)) {
#line 3128
        *(opt + (opts + k)->arindex) = 1;
      }
#line 3125
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3120
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3131
  return;
}
}
#line 3133 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
int is_special_variable(char *variable_name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3136
  if (! variable_name) {
#line 3137
    return (0);
  }
  {
  {
#line 3139
  tmp = strcmp((char const   *)variable_name, "accessfile");
  }
  }
#line 3139
  if (tmp == 0) {
#line 3141
    return (1);
  } else {
    {
    {
#line 3139
    tmp___0 = strcmp((char const   *)variable_name, "usagefile");
    }
    }
#line 3139
    if (tmp___0 == 0) {
#line 3141
      return (1);
    } else {
      {
      {
#line 3139
      tmp___1 = strcmp((char const   *)variable_name, "logfile");
      }
      }
#line 3139
      if (tmp___1 == 0) {
#line 3141
        return (1);
      } else {
        {
        {
#line 3139
        tmp___2 = strcmp((char const   *)variable_name, "resolv_type");
        }
        }
#line 3139
        if (tmp___2 == 0) {
#line 3141
          return (1);
        }
      }
    }
  }
#line 3142
  return (0);
}
}
#line 3145 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void change_special_variable(com_request_t *req , set_element *s , char *variable_name ,
                             char *argument ) 
{ 
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 3148
  if (! variable_name) {
#line 3149
    return;
  } else
#line 3148
  if (! argument) {
#line 3149
    return;
  }
  {
  {
#line 3151
  tmp___1 = strcmp((char const   *)variable_name, "accessfile");
  }
  }
#line 3151
  if (tmp___1 == 0) {
    {
    {
#line 3154
    change_variable(req, s, variable_name, argument);
    }
    {
#line 3155
    open_log_files();
    }
    }
  } else {
    {
    {
#line 3151
    tmp___2 = strcmp((char const   *)variable_name, "usagefile");
    }
    }
#line 3151
    if (tmp___2 == 0) {
      {
      {
#line 3154
      change_variable(req, s, variable_name, argument);
      }
      {
#line 3155
      open_log_files();
      }
      }
    } else {
      {
      {
#line 3151
      tmp___3 = strcmp((char const   *)variable_name, "logfile");
      }
      }
#line 3151
      if (tmp___3 == 0) {
        {
        {
#line 3154
        change_variable(req, s, variable_name, argument);
        }
        {
#line 3155
        open_log_files();
        }
        }
      } else {
        {
        {
#line 3156
        tmp___0 = strcmp((char const   *)variable_name, "resolv_type");
        }
        }
#line 3156
        if (tmp___0 == 0) {
          {
          {
#line 3158
          tmp = atoi((char const   *)argument);
          }
#line 3158
          val = tmp;
          }
          {
#line 3161
          if (val == 1) {
#line 3161
            goto case_1;
          }
#line 3169
          if (val == 2) {
#line 3169
            goto case_2;
          }
#line 3178
          if (val == 3) {
#line 3178
            goto case_3;
          }
#line 3183
          goto switch_default;
          case_1: /* CIL Label */ 
          {
          {
#line 3166
          admin_write_line((com_request_t const   *)req, (int const   )130, "Solaris style reentrant resolv functions not available");
          }
          }
#line 3168
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 3171
          info.resolv_type = (resolv_type_t )2;
          {
#line 3172
          admin_write_line((com_request_t const   *)req, (int const   )133, "Resolv style changed to linux reentrant");
          }
          {
#line 3173
          change_variable(req, s, variable_name, argument);
          }
          }
#line 3177
          goto switch_break;
          case_3: /* CIL Label */ 
          {
#line 3179
          info.resolv_type = (resolv_type_t )3;
          {
#line 3180
          admin_write_line((com_request_t const   *)req, (int const   )133, "Resolv style changed to standard (nonreentrant)");
          }
          {
#line 3181
          change_variable(req, s, variable_name, argument);
          }
          }
#line 3182
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
          {
#line 3184
          admin_write_line((com_request_t const   *)req, (int const   )130, "Only values 1,2 and 3 are valid for resolv_type");
          }
          }
#line 3185
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 3188
  return;
}
}
#line 3190 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
void change_variable(com_request_t *req , set_element *s , char *argument , char *arg ) 
{ 
  int oldval ;
  double oldval___0 ;
  char *oldval___1 ;
  char const   *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 3193
  if ((unsigned int )s->type == 0U) {
    {
#line 3195
    oldval = *((int *)s->setting);
    {
#line 3196
    *((int *)s->setting) = atoi((char const   *)arg);
    }
    {
#line 3197
    admin_write_line((com_request_t const   *)req, (int const   )131, "%s changed from %d to %d",
                     argument, oldval, *((int *)s->setting));
    }
    }
  } else
#line 3198
  if ((unsigned int )s->type == 1U) {
    {
#line 3200
    oldval___0 = *((double *)s->setting);
    {
#line 3201
    *((double *)s->setting) = atof((char const   *)arg);
    }
    {
#line 3202
    admin_write_line((com_request_t const   *)req, (int const   )132, "%s changed from %f to %f",
                     argument, oldval___0, *((double *)s->setting));
    }
    }
  } else {
    {
#line 3204
    oldval___1 = *((char **)s->setting);
    {
#line 3205
    *((char **)s->setting) = n_strdup((char const   *)arg, (int const   )3205, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    {
#line 3206
    tmp = nullcheck_string((char const   *)oldval___1);
    }
    {
#line 3206
    admin_write_line((com_request_t const   *)req, (int const   )133, "%s changed from %s to [%s]",
                     argument, tmp, *((char **)s->setting));
    }
    {
#line 3207
    n_free((void *)oldval___1, (int const   )3207, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
#line 3207
    oldval___1 = (char *)((void *)0);
    }
  }
#line 3209
  return;
}
}
#line 3211 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
char *variable_to_string(char *varname ) 
{ 
  set_element *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 3216
  if (! varname) {
    {
    {
#line 3217
    tmp = n_strdup("(null)", (int const   )3217, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 3217
    return (tmp);
  }
  {
  {
#line 3219
  s = find_set_element(varname, admin_settings);
  }
  }
#line 3221
  if (! s) {
    {
    {
#line 3222
    tmp___0 = n_strdup("(not found)", (int const   )3222, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 3222
    return (tmp___0);
  }
#line 3224
  if ((unsigned int )s->type == 0U) {
    {
    {
#line 3225
    tmp___1 = ice_itoa(*((int *)s->setting));
    }
    }
#line 3225
    return (tmp___1);
  } else
#line 3226
  if ((unsigned int )s->type == 1U) {
    {
    {
#line 3227
    tmp___2 = ice_itoa((int )*((double *)s->setting));
    }
    }
#line 3227
    return (tmp___2);
  } else {
    {
    {
#line 3229
    tmp___3 = n_strdup((char const   *)*((char **)s->setting), (int const   )3229,
                       "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c");
    }
    }
#line 3229
    return (tmp___3);
  }
}
}
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 28 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.h"
client_t *create_client(void) ;
#line 29
void gen_playlist(connection_t *con , request_t *req ) ;
#line 30
void show_mountlist(connection_t *con , request_t *req ) ;
#line 34
int client_wants_content_length(connection_t *con ) ;
#line 35
int client_wants_icy_headers(connection_t *con ) ;
#line 36
int client_wants_metadata(connection_t *con ) ;
#line 39
void greet_client(connection_t *con , source_t *source ) ;
#line 95 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void client_login(connection_t *con , char *expr ) 
{ 
  char line[8192] ;
  int go_on ;
  connection_t *source ;
  request_t req ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int err ;
  char *secfile ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *umd ;
  char const   *tmp___17 ;
  char const   *ref ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *sport ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  void *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;

  {
  {
#line 98
  go_on = 1;
  {
#line 102
  xa_debug(3, (char *)"Client login...\n");
  }
  }
#line 104
  if (! con) {
    {
    {
#line 105
    write_log(0, (char *)"WARNING: client_login called with NULL pointer");
    }
    }
#line 106
    return;
  } else
#line 104
  if (! expr) {
    {
    {
#line 105
    write_log(0, (char *)"WARNING: client_login called with NULL pointer");
    }
    }
#line 106
    return;
  }
#line 109
  if (info.throttle_on) {
    {
    {
#line 110
    sock_write(con->sock, "HTTP/1.0 406 Not Acceptable (using too much bandwidth)");
    }
    {
#line 111
    kick_not_connected(con, (char *)"Bandwidth usage too high (throttling)");
    }
    }
#line 112
    return;
  }
  {
  {
#line 122
  tmp = allowed(con, (contype_t )0);
  }
  }
#line 122
  if (! tmp) {
    {
    {
#line 123
    write_http_code_page(con, 403, "Forbidden");
    }
    {
#line 124
    kick_not_connected(con, (char *)"Access Denied (internal acl list (client connection))");
    }
    }
#line 125
    return;
  }
  {
  {
#line 128
  zero_request(& req);
  }
  {
#line 130
  con->headervars = create_header_vars();
  }
  }
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 133
    tmp___0 = splitc(line, expr, (char const   )'\n');
    }
    }
#line 133
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
      {
#line 134
      strncpy((char */* __restrict  */)(line), (char const   */* __restrict  */)expr,
              (size_t )8192);
      }
#line 135
      go_on = 0;
      }
    }
    {
    {
#line 138
    tmp___3 = ice_strncmp((char const   *)(line), "GET", (size_t )3);
    }
    }
#line 138
    if (tmp___3 == 0) {
      {
      {
#line 139
      build_request(line, & req);
      }
      }
    } else {
      {
      {
#line 141
      tmp___1 = ice_strncmp((char const   *)(line), "Host:", (size_t )5);
      }
      }
#line 141
      if (tmp___1 == 0) {
        {
        {
#line 142
        build_request(line, & req);
        }
        }
      } else {
        {
        {
#line 141
        tmp___2 = ice_strncmp((char const   *)(line), "HOST:", (size_t )5);
        }
        }
#line 141
        if (tmp___2 == 0) {
          {
          {
#line 142
          build_request(line, & req);
          }
          }
        } else {
          {
          {
#line 144
          extract_header_vars(line, con->headervars);
          }
          }
        }
      }
    }
#line 132
    if (! go_on) {
#line 132
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 148
  tmp___5 = need_authentication(& req);
  }
  }
#line 148
  if (tmp___5) {
    {
    {
#line 150
    tmp___4 = authenticate_user_request(con, & req);
    }
    }
#line 150
    if (! tmp___4) {
      {
      {
#line 152
      write_401(con, req.path);
      }
      {
#line 153
      kick_not_connected(con, (char *)"Not authorized");
      }
      }
#line 154
      return;
    }
  }
  {
  {
#line 158
  tmp___6 = ice_strcmp((char const   *)(req.path), "/list.cgi");
  }
  }
#line 158
  if (tmp___6 == 0) {
    {
    {
#line 159
    show_mountlist(con, & req);
    }
    {
#line 160
    kick_not_connected(con, (char *)"Displayed mountlist");
    }
    }
#line 161
    return;
  }
  {
  {
#line 164
  tmp___7 = ice_strncmp((char const   *)(req.path), "/playlist.pls", (size_t )13);
  }
  }
#line 164
  if (tmp___7 == 0) {
    {
    {
#line 165
    gen_playlist(con, & req);
    }
    {
#line 166
    kick_not_connected(con, (char *)"Generated playlist");
    }
    }
#line 167
    return;
  }
  {
  {
#line 170
  tmp___12 = ice_strncmp((char const   *)(req.path), "/admin", (size_t )6);
  }
  }
#line 170
  if (tmp___12 == 0) {
    {
    {
#line 174
    tmp___8 = get_icecast_file((char const   *)info.mountfile, (filetype_t )1, 4);
    }
#line 174
    secfile = tmp___8;
    }
#line 176
    if (! secfile) {
      {
      {
#line 176
      tmp___10 = strstr((char const   *)(req.path), "updinfo");
      }
      }
#line 176
      if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
        {
        {
#line 177
        write_http_code_page(con, 403, "Forbidden");
        }
        {
#line 178
        tmp___9 = con_host(con);
        }
        {
#line 178
        write_log(0, (char *)"No mountfile found, refusing access to WWW admin for %s",
                  tmp___9);
        }
        {
#line 179
        kick_not_connected(con, (char *)"No mountfile found");
        }
        }
#line 180
        return;
      }
    }
    {
    {
#line 183
    err = http_admin_command(con, & req);
    }
    }
#line 185
    if (err) {
      {
      {
#line 187
      tmp___11 = con_host(con);
      }
      {
#line 187
      xa_debug(2, (char *)"DEBUG: kicking %s, executed admin command", tmp___11);
      }
      {
#line 188
      kick_not_connected(con, (char *)((void *)0));
      }
      }
    } else {
      {
      {
#line 190
      kick_not_connected(con, (char *)"Failed to execute admin command");
      }
      }
    }
#line 191
    return;
  }
  {
  {
#line 194
  tmp___14 = ice_strncmp((char const   *)(req.path), "/file/", (size_t )6);
  }
  }
#line 194
  if (tmp___14 == 0) {
    {
    {
#line 195
    thread_rename("Static File Thread");
    }
    {
#line 196
    tmp___13 = ice_strlen((char const   *)(req.path));
    }
    }
#line 196
    if ((int )req.path[tmp___13 - 1U] == 47) {
      {
      {
#line 198
      list_directory(con, req.path);
      }
      {
#line 199
      kick_not_connected(con, (char *)"Displayed directory list");
      }
      }
    } else {
      {
      {
#line 201
      send_file(con, & req);
      }
      {
#line 202
      kick_not_connected(con, (char *)"Sent static file");
      }
      }
    }
#line 204
    return;
  }
  {
  {
#line 207
  xa_debug(1, (char *)"Looking for mount [%s:%d%s]", req.host, req.port, req.path);
  }
  {
#line 210
  thread_mutex_lock_c(& info.double_mutex, 210, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 211
  thread_mutex_lock_c(& info.mount_mutex, 211, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 212
  thread_mutex_lock_c(& info.source_mutex, 212, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 214
  source = find_mount_with_req(& req);
  }
  {
#line 216
  thread_mutex_unlock_c(& info.source_mutex, 216, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 217
  thread_mutex_unlock_c(& info.mount_mutex, 217, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 218
  thread_mutex_unlock_c(& info.double_mutex, 218, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  }
#line 221
  if ((unsigned long )source == (unsigned long )((void *)0)) {
#line 221
    if (info.mount_fallback) {
      {
      {
#line 222
      source = get_default_mount();
      }
      }
    }
  }
#line 225
  if ((unsigned long )source == (unsigned long )((void *)0)) {
    {
    {
#line 226
    write_http_code_page(con, 404, "Stream not found");
    }
    {
#line 227
    kick_not_connected(con, (char *)"No encoder");
    }
    }
#line 228
    return;
  }
  {
  {
#line 231
  tmp___16 = need_authentication_on_mount((source->food.source)->audiocast.mount);
  }
  }
#line 231
  if (tmp___16) {
    {
    {
#line 233
    tmp___15 = authenticate_user_request(con, & req);
    }
    }
#line 233
    if (! tmp___15) {
      {
      {
#line 235
      write_401(con, req.path);
      }
      {
#line 236
      kick_not_connected(con, (char *)"Not authorized");
      }
      }
#line 237
      return;
    }
  }
#line 241
  if (info.num_clients >= info.max_clients) {
#line 241
    goto _L;
  } else
#line 241
  if ((source->food.source)->num_clients >= info.max_clients_per_source) {
    _L: /* CIL Label */ 
    {
    {
#line 244
    write_http_code_page(con, 504, "Server Full");
    }
    }
#line 245
    if (info.num_clients >= info.max_clients) {
      {
      {
#line 246
      xa_debug(2, (char *)"DEBUG: inc > imc: %lu %lu", info.num_clients, info.max_clients);
      }
      }
    } else
#line 247
    if ((source->food.source)->num_clients >= info.max_clients_per_source) {
      {
      {
#line 248
      xa_debug(2, (char *)"DEBUG: snc > smc: %lu %lu", (source->food.source)->num_clients,
               info.max_clients_per_source);
      }
      }
    } else {
      {
      {
#line 250
      xa_debug(1, (char *)"ERROR: Erroneous number of clients, what the hell is going on?");
      }
      }
    }
    {
    {
#line 252
    kick_not_connected(con, (char *)"Server Full (too many listeners)");
    }
    }
#line 253
    return;
  }
  {
  {
#line 256
  put_client(con);
  }
#line 257
  (con->food.client)->type = (client_type_t )0;
  {
#line 260
  tmp___17 = get_con_variable(con, "Icy-MetaData");
  }
#line 260
  umd = tmp___17;
  }
#line 261
  if (umd) {
    {
    {
#line 262
    (con->food.client)->use_icy_metadata = atoi(umd);
    }
    }
  }
  {
  {
#line 266
  tmp___18 = get_con_variable(con, "Referer");
  }
#line 266
  ref = tmp___18;
  }
#line 267
  if (ref) {
    {
    {
#line 267
    tmp___19 = ice_strcmp(ref, "RELAY");
    }
    }
#line 267
    if (tmp___19 == 0) {
#line 268
      (con->food.client)->type = (client_type_t )2;
    }
  }
#line 272
  if (con->sin) {
    {
    {
#line 274
    tmp___20 = get_con_variable(con, "x-audiocast-udpport");
    }
#line 274
    sport = tmp___20;
    }
#line 275
    if (sport) {
      {
      {
#line 277
      tmp___21 = atoi(sport);
      }
      {
#line 277
      (con->sin)->sin_port = htons((uint16_t )tmp___21);
      }
#line 278
      (con->food.client)->use_udp = 1U;
      {
#line 279
      tmp___22 = atoi(sport);
      }
      {
#line 279
      xa_debug(1, (char *)"DEBUG: client_login(): Client listening on udp port %d",
               tmp___22);
      }
      }
    }
  }
#line 283
  if ((con->food.client)->use_icy_metadata) {
#line 283
    if ((con->food.client)->use_udp) {
#line 284
      (con->food.client)->use_icy_metadata = 0;
    }
  }
  {
  {
#line 286
  util_increase_total_clients();
  }
#line 288
  (con->food.client)->source = source->food.source;
#line 291
  ((source->food.source)->stats.client_connections) ++;
  {
#line 293
  pool_add(con);
  }
  {
#line 295
  tmp___23 = con_host(con);
  }
  {
#line 295
  write_log(0, (char *)"Accepted client %d from [%s] on mountpoint [%s]. %d clients connected",
            con->id, tmp___23, (source->food.source)->audiocast.mount, info.num_clients);
  }
  {
#line 297
  greet_client(con, source->food.source);
  }
  }
#line 298
  return;
}
}
#line 300 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
client_t *create_client(void) 
{ 
  client_t *client ;
  void *tmp ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 303
  tmp = n_malloc((unsigned int const   )sizeof(client_t ), (int const   )303, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
#line 303
  client = (client_t *)tmp;
#line 304
  client->type = (client_type_t )-1;
  }
#line 305
  return (client);
}
}
#line 308 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void put_client(connection_t *con ) 
{ 
  client_t *cli ;
  client_t *tmp ;

  {
  {
  {
#line 310
  tmp = create_client();
  }
#line 310
  cli = tmp;
#line 311
  con->food.client = cli;
#line 312
  cli->errors = 0;
#line 313
  cli->type = (client_type_t )-1;
#line 314
  cli->write_bytes = 0UL;
#line 315
  cli->virgin = -1;
#line 316
  cli->source = (source_t *)((void *)0);
#line 317
  cli->cid = -1;
#line 318
  cli->offset = 0;
#line 319
  cli->alive = 1;
#line 320
  cli->use_icy_metadata = 0;
#line 321
  cli->metadataoffset = 0UL;
#line 322
  cli->metadatalen = 0UL;
#line 323
  cli->metadatawritten = 0UL;
#line 324
  cli->use_icy = 0U;
#line 325
  cli->use_udp = 0U;
#line 326
  con->type = (contype_t )0;
#line 327
  cli->udpseqnr = 0UL;
  }
#line 328
  return;
}
}
#line 330 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void gen_playlist(connection_t *con , request_t *req ) 
{ 
  char const   *mount_point ;
  vartree_t *req_vars ;
  avl_tree *tmp ;
  char const   *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
  {
#line 334
  tmp = avl_create(& compare_vars, (void *)(& info));
  }
#line 334
  req_vars = tmp;
  {
#line 336
  extract_vars(req_vars, req->path);
  }
  {
#line 337
  mount_point = get_variable(req_vars, "mount");
  }
  {
#line 339
  xa_debug(1, (char *)"DEBUG: Generating playlist");
  }
  {
#line 341
  write_http_header(con->sock, 200, "OK");
  }
  {
#line 343
  sock_write_line(con->sock, "Connection: close");
  }
  {
#line 344
  sock_write_line(con->sock, "Content-Type: audio/x-scpls\r\n");
  }
  {
#line 347
  sock_write_line(con->sock, "[playlist]\r\n");
  }
  {
#line 348
  sock_write_line(con->sock, "NumberOfEntries=1");
  }
  }
#line 349
  if (mount_point) {
#line 349
    tmp___0 = mount_point;
  } else {
#line 349
    tmp___0 = "/";
  }
  {
  {
#line 349
  sock_write_line(con->sock, "File1=http://%s:%i%s", info.server_name, info.port[0],
                  tmp___0);
  }
  {
#line 351
  free_variables(req_vars);
  }
  }
#line 352
  return;
}
}
#line 354 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void show_mountlist(connection_t *con , request_t *req ) 
{ 
  char *filename ;
  char *tmp ;
  avl_traverser trav ;
  connection_t *sourcecon ;
  int i ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
  {
#line 357
  tmp = get_template("mountlist.html");
  }
#line 357
  filename = tmp;
#line 358
  trav.init = 0;
#line 358
  trav.nstack = 0;
#line 358
  trav.p = (avl_node const   *)0;
#line 358
  trav.stack[0] = (avl_node const   *)0;
#line 358
  trav.stack[1] = (avl_node const   *)0;
#line 358
  trav.stack[2] = (avl_node const   *)0;
#line 358
  trav.stack[3] = (avl_node const   *)0;
#line 358
  trav.stack[4] = (avl_node const   *)0;
#line 358
  trav.stack[5] = (avl_node const   *)0;
#line 358
  trav.stack[6] = (avl_node const   *)0;
#line 358
  trav.stack[7] = (avl_node const   *)0;
#line 358
  trav.stack[8] = (avl_node const   *)0;
#line 358
  trav.stack[9] = (avl_node const   *)0;
#line 358
  trav.stack[10] = (avl_node const   *)0;
#line 358
  trav.stack[11] = (avl_node const   *)0;
#line 358
  trav.stack[12] = (avl_node const   *)0;
#line 358
  trav.stack[13] = (avl_node const   *)0;
#line 358
  trav.stack[14] = (avl_node const   *)0;
#line 358
  trav.stack[15] = (avl_node const   *)0;
#line 358
  trav.stack[16] = (avl_node const   *)0;
#line 358
  trav.stack[17] = (avl_node const   *)0;
#line 358
  trav.stack[18] = (avl_node const   *)0;
#line 358
  trav.stack[19] = (avl_node const   *)0;
#line 358
  trav.stack[20] = (avl_node const   *)0;
#line 358
  trav.stack[21] = (avl_node const   *)0;
#line 358
  trav.stack[22] = (avl_node const   *)0;
#line 358
  trav.stack[23] = (avl_node const   *)0;
#line 358
  trav.stack[24] = (avl_node const   *)0;
#line 358
  trav.stack[25] = (avl_node const   *)0;
#line 358
  trav.stack[26] = (avl_node const   *)0;
#line 358
  trav.stack[27] = (avl_node const   *)0;
#line 358
  trav.stack[28] = (avl_node const   *)0;
#line 358
  trav.stack[29] = (avl_node const   *)0;
#line 358
  trav.stack[30] = (avl_node const   *)0;
#line 358
  trav.stack[31] = (avl_node const   *)0;
#line 360
  i = 0;
  }
#line 362
  if (filename) {
#line 362
    tmp___0 = (char const   *)filename;
  } else {
#line 362
    tmp___0 = "internal";
  }
  {
  {
#line 362
  xa_debug(1, (char *)"DEBUG: Displaying mountlist [%s]", tmp___0);
  }
  }
#line 364
  if (filename) {
    {
    {
#line 366
    write_template_parsed_html_page(con, (connection_t *)((void *)0), (char const   *)filename,
                                    -1, (vartree_t *)((void *)0));
    }
    {
#line 367
    n_free((void *)filename, (int const   )367, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
    }
#line 367
    filename = (char *)((void *)0);
    }
#line 368
    return;
  }
  {
  {
#line 371
  thread_mutex_lock_c(& info.source_mutex, 371, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  {
#line 373
  write_http_header(con->sock, 200, "OK");
  }
  {
#line 375
  sock_write_line(con->sock, "Connection: close");
  }
  {
#line 376
  sock_write_line(con->sock, "Content-Type: text/html\r\n");
  }
  {
#line 378
  sock_write_line(con->sock, "<html><head><title>icecast server, version %s, running on %s</title></head>",
                  "1.3.12", info.server_name);
  }
  {
#line 379
  sock_write_line(con->sock, "<body bgcolor=black text=white link=lightblue alink=lightblue vlink=lightblue><h3><tt>icecast server, version %s, running on %s</tt></h3><br>",
                  "1.3.12", info.server_name);
  }
#line 381
  i = 0;
  }
  {
  {
#line 381
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < 5)) {
#line 381
      goto while_break;
    }
#line 382
    if (info.port[i] > 0) {
      {
      {
#line 383
      sock_write_line(con->sock, "<p>Listening on port %d<br>", info.port[i]);
      }
      }
    }
#line 381
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  if (info.location) {
    {
    {
#line 386
    sock_write_line(con->sock, "Server location: %s<br>", info.location);
    }
    }
  }
#line 387
  if (info.rp_email) {
    {
    {
#line 388
    sock_write_line(con->sock, "Server admin: <a href=\"mailto:%s\">%s</a><br>", info.rp_email,
                    info.rp_email);
    }
    }
  }
#line 389
  if (info.server_url) {
    {
    {
#line 390
    sock_write_line(con->sock, "Server URL: <a href=\"%s\">%s</a><br></p>", info.server_url,
                    info.server_url);
    }
    }
  }
  {
  {
#line 392
  sock_write_line(con->sock, "<table border=0 cellspacing=0 cellpadding=3><tr><td><font face=\"sans-serif\" size=+2>Stream Link</font></td><td><font face=\"sans-serif\" size=+2>Name</font></td><td><font face=\"sans-serif\" size=+2>URL</font></td><td><font face=\"sans-serif\" size=+2>Genre</font></td><td><font face=\"sans-serif\" size=+2>Description</font></td></tr>");
  }
  }
  {
  {
#line 394
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
    {
    {
#line 394
    tmp___1 = avl_traverse(info.sources, & trav);
    }
#line 394
    sourcecon = (connection_t *)tmp___1;
    }
#line 394
    if (! sourcecon) {
#line 394
      goto while_break___0;
    }
#line 396
    i ++;
#line 397
    if (i % 2) {
      {
      {
#line 397
      sock_write_line(con->sock, "<tr bgcolor=#000000>");
      }
      }
    } else {
      {
      {
#line 397
      sock_write_line(con->sock, "<tr bgcolor=#333333>");
      }
      }
    }
    {
    {
#line 399
    sock_write_line(con->sock, "<td><tt><a href=\"/playlist.pls?mount=%s&file=dummy.pls\">%s</a></tt></td><td><tt>%s</tt></td><td><tt><a href=\"%s\">%s</a></tt></td><td><tt>%s</tt></td><td><tt>%s</tt></td></tr>",
                    (sourcecon->food.source)->audiocast.mount, (sourcecon->food.source)->audiocast.mount,
                    (sourcecon->food.source)->audiocast.name, (sourcecon->food.source)->audiocast.url,
                    (sourcecon->food.source)->audiocast.url, (sourcecon->food.source)->audiocast.genre,
                    (sourcecon->food.source)->audiocast.description);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 409
  sock_write_line(con->sock, "</table></body></html>");
  }
  {
#line 410
  thread_mutex_unlock_c(& info.source_mutex, 410, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  }
#line 411
  return;
}
}
#line 413 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void util_increase_total_clients(void) 
{ 


  {
  {
  {
#line 415
  internal_lock_mutex(& info.misc_mutex);
  }
#line 416
  (info.num_clients) ++;
#line 417
  (info.hourly_stats.client_connections) ++;
  {
#line 418
  internal_unlock_mutex(& info.misc_mutex);
  }
  }
#line 419
  return;
}
}
#line 421 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void util_decrease_total_clients(void) 
{ 


  {
  {
  {
#line 424
  internal_lock_mutex(& info.misc_mutex);
  }
#line 425
  (info.num_clients) --;
  {
#line 426
  internal_unlock_mutex(& info.misc_mutex);
  }
  }
#line 427
  return;
}
}
#line 429 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void del_client(connection_t *client , source_t *source ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 432
  if (! client) {
    {
    {
#line 433
    write_log(0, (char *)"WARNING: del_client() called with NULL pointer");
    }
    }
#line 434
    return;
  } else
#line 432
  if (! source) {
    {
    {
#line 433
    write_log(0, (char *)"WARNING: del_client() called with NULL pointer");
    }
    }
#line 434
    return;
  }
#line 437
  if (source) {
#line 437
    if (client->food.client) {
#line 437
      if ((client->food.client)->virgin != 1) {
#line 437
        if ((client->food.client)->virgin != -1) {
#line 438
          if (source->num_clients == 0UL) {
            {
            {
#line 439
            write_log(0, (char *)"WARNING: Bloody going below limits on client count!");
            }
            }
          } else {
#line 441
            (source->num_clients) --;
          }
        }
      }
    }
  }
  {
  {
#line 443
  util_decrease_total_clients();
  }
  }
#line 444
  return;
}
}
#line 446 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_wants_udp_info(connection_t *con ) 
{ 
  char const   *val ;
  char *__cil_tmp3 ;

  {
#line 451
  if (! con) {
#line 452
    return (0);
  }
  {
  {
#line 454
  val = get_con_variable(con, "x-audiocast-udpport");
  }
  }
#line 455
  if (! val) {
#line 456
    return (0);
  }
#line 458
  return (1);
}
}
#line 461 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_wants_content_length(connection_t *con ) 
{ 
  char const   *val ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 466
  if (! con) {
#line 467
    return (0);
  }
  {
  {
#line 469
  val = get_user_agent(con);
  }
  }
#line 470
  if (! val) {
#line 471
    return (0);
  }
  {
  {
#line 473
  tmp = strstr(val, "MSIE");
  }
  }
#line 473
  if (tmp) {
#line 474
    return (1);
  }
  {
  {
#line 475
  tmp___0 = strstr(val, "RMA/1.0");
  }
  }
#line 475
  if (tmp___0) {
#line 476
    return (1);
  }
  {
  {
#line 477
  tmp___1 = strstr(val, "NSPlayer");
  }
  }
#line 477
  if (tmp___1) {
#line 478
    return (1);
  }
#line 479
  return (0);
}
}
#line 482 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_wants_icy_headers(connection_t *con ) 
{ 
  char const   *val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 487
  if (! con) {
#line 488
    return (1);
  }
  {
  {
#line 490
  val = get_user_agent(con);
  }
  }
#line 491
  if (! val) {
#line 492
    return (1);
  } else
#line 491
  if (! *(val + 0)) {
#line 492
    return (1);
  } else {
    {
    {
#line 491
    tmp = strcmp(val, "(null)");
    }
    }
#line 491
    if (tmp == 0) {
#line 492
      return (1);
    }
  }
#line 494
  if ((con->food.client)->use_icy) {
#line 495
    return (1);
  }
  {
  {
#line 496
  tmp___0 = strncasecmp(val, "winamp", (size_t )6);
  }
  }
#line 496
  if (tmp___0 == 0) {
#line 497
    return (1);
  }
  {
  {
#line 498
  tmp___1 = strncasecmp(val, "Shoutcast", (size_t )9);
  }
  }
#line 498
  if (tmp___1 == 0) {
#line 499
    return (1);
  }
#line 501
  return (0);
}
}
#line 504 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_wants_metadata(connection_t *con ) 
{ 


  {
#line 507
  if (! con) {
#line 508
    return (0);
  }
#line 509
  if ((con->food.client)->use_icy_metadata) {
#line 509
    if (info.use_meta_data) {
#line 510
      return (1);
    }
  }
#line 511
  return (0);
}
}
#line 514 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void print_relay_ids(connection_t *con , source_t *source ) 
{ 
  avl_traverser trav ;
  relay_id_t *rid ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 517
  trav.init = 0;
#line 517
  trav.nstack = 0;
#line 517
  trav.p = (avl_node const   *)0;
#line 517
  trav.stack[0] = (avl_node const   *)0;
#line 517
  trav.stack[1] = (avl_node const   *)0;
#line 517
  trav.stack[2] = (avl_node const   *)0;
#line 517
  trav.stack[3] = (avl_node const   *)0;
#line 517
  trav.stack[4] = (avl_node const   *)0;
#line 517
  trav.stack[5] = (avl_node const   *)0;
#line 517
  trav.stack[6] = (avl_node const   *)0;
#line 517
  trav.stack[7] = (avl_node const   *)0;
#line 517
  trav.stack[8] = (avl_node const   *)0;
#line 517
  trav.stack[9] = (avl_node const   *)0;
#line 517
  trav.stack[10] = (avl_node const   *)0;
#line 517
  trav.stack[11] = (avl_node const   *)0;
#line 517
  trav.stack[12] = (avl_node const   *)0;
#line 517
  trav.stack[13] = (avl_node const   *)0;
#line 517
  trav.stack[14] = (avl_node const   *)0;
#line 517
  trav.stack[15] = (avl_node const   *)0;
#line 517
  trav.stack[16] = (avl_node const   *)0;
#line 517
  trav.stack[17] = (avl_node const   *)0;
#line 517
  trav.stack[18] = (avl_node const   *)0;
#line 517
  trav.stack[19] = (avl_node const   *)0;
#line 517
  trav.stack[20] = (avl_node const   *)0;
#line 517
  trav.stack[21] = (avl_node const   *)0;
#line 517
  trav.stack[22] = (avl_node const   *)0;
#line 517
  trav.stack[23] = (avl_node const   *)0;
#line 517
  trav.stack[24] = (avl_node const   *)0;
#line 517
  trav.stack[25] = (avl_node const   *)0;
#line 517
  trav.stack[26] = (avl_node const   *)0;
#line 517
  trav.stack[27] = (avl_node const   *)0;
#line 517
  trav.stack[28] = (avl_node const   *)0;
#line 517
  trav.stack[29] = (avl_node const   *)0;
#line 517
  trav.stack[30] = (avl_node const   *)0;
#line 517
  trav.stack[31] = (avl_node const   *)0;
  {
#line 520
  thread_mutex_lock_c(& source->mutex, 520, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  }
  {
  {
#line 522
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 522
    tmp = avl_traverse(source->relay_tree, & trav);
    }
#line 522
    rid = (relay_id_t *)tmp;
    }
#line 522
    if (! rid) {
#line 522
      goto while_break;
    }
#line 524
    if (! rid) {
      {
      {
#line 526
      write_log(0, (char *)"ERROR: Erroneous relay id:s...");
      }
      }
#line 527
      goto while_continue;
    } else
#line 524
    if (! rid->host) {
      {
      {
#line 526
      write_log(0, (char *)"ERROR: Erroneous relay id:s...");
      }
      }
#line 527
      goto while_continue;
    }
    {
    {
#line 529
    xa_debug(1, (char *)"DEBUG: Displaying dir-id: %s:%d to %d", rid->host, rid->id,
             con->id);
    }
    {
#line 530
    sock_write_line(con->sock, "x-audiocast-directory: %s:%d", rid->host, rid->id);
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 533
  thread_mutex_unlock_c(& source->mutex, 533, (char *)"/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
  }
  }
#line 534
  return;
}
}
#line 537 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_wants_relay_ids(connection_t *con ) 
{ 


  {
#line 540
  return (0);
}
}
#line 543 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void greet_client(connection_t *con , source_t *source ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char *title ;
  char *msg ;
  char length[11] ;
  char *url ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 550
  if (! con) {
    {
    {
#line 551
    write_log(0, (char *)"WARNING: greet_client called with NULL pointer");
    }
    }
#line 552
    return;
  }
#line 555
  if (source->info.udpseqnr > 0UL) {
#line 555
    (con->food.client)->udpseqnr = source->info.udpseqnr - 1UL;
  } else {
#line 555
    (con->food.client)->udpseqnr = source->info.udpseqnr;
  }
  {
  {
#line 557
  tmp___12 = client_wants_icy_headers(con);
  }
  }
#line 557
  if (tmp___12) {
    {
    {
#line 558
    tmp = con_host(con);
    }
    {
#line 558
    xa_debug(2, (char *)"DEBUG: client [%s] wants icy headers", tmp);
    }
    {
#line 559
    sock_write_line(con->sock, "ICY 200 OK");
    }
    {
#line 560
    sock_write_line(con->sock, "icy-notice1:<BR>This stream requires <a href=\"http://www.winamp.com/\">Winamp</a><BR>");
    }
    {
#line 562
    sock_write_line(con->sock, "icy-notice2:SHOUTcast Distributed Network Audio Server/posix v1.6.0rc2<BR>");
    }
    {
#line 564
    tmp___0 = client_wants_metadata(con);
    }
    }
#line 564
    if (tmp___0) {
      {
      {
#line 565
      sock_write_line(con->sock, "icy-metaint:%u", info.metainterval);
      }
      }
    }
    {
    {
#line 567
    tmp___1 = client_wants_udp_info(con);
    }
    }
#line 567
    if (tmp___1) {
      {
      {
#line 568
      sock_write_line(con->sock, "x-audiocast-udpport: %d", info.port[0]);
      }
      }
    }
    {
    {
#line 570
    sock_write(con->sock, "icy-name:%s\r\nicy-genre:%s\r\nicy-url:%s\r\nicy-pub:%d\nicy-br:%d\r\n\r\n",
               source->audiocast.name, source->audiocast.genre, source->audiocast.url,
               source->audiocast.public, source->audiocast.bitrate);
    }
    }
  } else {
    {
    {
#line 574
    tmp___2 = con_host(con);
    }
    {
#line 574
    xa_debug(2, (char *)"DEBUG: client [%s] wants xaudiocast headers", tmp___2);
    }
    {
#line 576
    write_http_header(con->sock, 200, "OK");
    }
    }
#line 577
    if (source->audiocast.streammimetype) {
      {
      {
#line 578
      sock_write_line(con->sock, "Content-Type: %s", source->audiocast.streammimetype);
      }
      }
    } else {
      {
      {
#line 580
      sock_write_line(con->sock, "Content-Type: audio/mpeg");
      }
      }
    }
    {
    {
#line 582
    tmp___3 = client_wants_content_length(con);
    }
    }
#line 582
    if (tmp___3) {
      {
      {
#line 583
      sock_write(con->sock, "Cache-Control: no-cache\r\nPragma: no-cache\r\nConnection: close\r\nContent-Length: 54000000\r\n");
      }
      }
    }
#line 585
    if (info.location) {
      {
      {
#line 586
      sock_write_line(con->sock, "x-audiocast-location: %s", info.location);
      }
      }
    }
#line 588
    if (info.rp_email) {
      {
      {
#line 589
      sock_write_line(con->sock, "x-audiocast-admin: %s", info.rp_email);
      }
      }
    }
#line 591
    if (info.server_url) {
      {
      {
#line 592
      sock_write_line(con->sock, "x-audiocast-server-url: %s", info.server_url);
      }
      }
    }
    {
    {
#line 594
    tmp___4 = client_wants_relay_ids(con);
    }
    }
#line 594
    if (tmp___4) {
      {
      {
#line 595
      print_relay_ids(con, source);
      }
      }
    }
    {
    {
#line 597
    tmp___5 = client_wants_metadata(con);
    }
    }
#line 597
    if (tmp___5) {
      {
      {
#line 598
      sock_write_line(con->sock, "icy-metaint:%u", info.metainterval);
      }
      }
    }
    {
    {
#line 600
    tmp___6 = client_wants_udp_info(con);
    }
    }
#line 600
    if (tmp___6) {
      {
      {
#line 601
      sock_write_line(con->sock, "x-audiocast-udpport: %d", info.port[0]);
      }
      }
    }
    {
    {
#line 603
    tmp___7 = nullcheck_string((char const   *)source->audiocast.genre);
    }
    {
#line 603
    tmp___8 = nullcheck_string((char const   *)source->audiocast.url);
    }
    {
#line 603
    tmp___9 = nullcheck_string((char const   *)source->audiocast.description);
    }
    {
#line 603
    tmp___10 = nullcheck_string((char const   *)source->audiocast.name);
    }
    {
#line 603
    tmp___11 = nullcheck_string((char const   *)source->audiocast.mount);
    }
    {
#line 603
    sock_write(con->sock, "x-audiocast-mount:%s\r\nx-audiocast-name:%s\r\nx-audiocast-description:%s\r\nx-audiocast-url:%s\r\nx-audiocast-genre:%s\r\nx-audiocast-bitrate:%d\r\nx-audiocast-public:%d\r\n\r\n",
               tmp___11, tmp___10, tmp___9, tmp___8, tmp___7, source->audiocast.bitrate,
               source->audiocast.public);
    }
    }
  }
  {
  {
#line 606
  sock_set_blocking(con->sock, (int const   )1);
  }
#line 612
  (con->food.client)->virgin = 1;
  }
#line 614
  if ((int )(con->food.client)->type == 2) {
    {
#line 615
    title = (char *)((void *)0);
#line 616
    msg = (char *)((void *)0);
#line 618
    url = (char *)((void *)0);
    {
#line 620
    url_encode((char const   *)source->info.streamtitle, & title);
    }
    {
#line 621
    url_encode((char const   *)source->info.streammsg, & msg);
    }
    {
#line 622
    snprintf((char */* __restrict  */)(length), (size_t )sizeof(length), (char const   */* __restrict  */)"%ld",
             source->info.streamlength);
    }
    {
#line 623
    url_encode((char const   *)source->info.streamurl, & url);
    }
    {
#line 624
    update_metadata_on_relay(con, (char const   *)source->audiocast.mount, (char const   *)title,
                             (char const   *)msg, (char const   *)(length), (char const   *)url);
    }
    {
#line 625
    n_free((void *)title, (int const   )625, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
    }
#line 625
    title = (char *)((void *)0);
    {
#line 626
    n_free((void *)msg, (int const   )626, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
    }
#line 626
    msg = (char *)((void *)0);
    {
#line 627
    n_free((void *)url, (int const   )627, "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c");
    }
#line 627
    url = (char *)((void *)0);
    }
  }
#line 629
  return;
}
}
#line 631 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
void describe_client(com_request_t const   *req , connection_t const   *clicon ) 
{ 
  client_t const   *client ;
  char const   *tmp ;
  uint16_t tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 636
  if (! req) {
    {
    {
#line 638
    xa_debug(1, (char *)"WARNING: describe_client(): called with NULL pointers");
    }
    }
#line 639
    return;
  } else
#line 636
  if (! clicon) {
    {
    {
#line 638
    xa_debug(1, (char *)"WARNING: describe_client(): called with NULL pointers");
    }
    }
#line 639
    return;
  }
#line 642
  if ((unsigned int const   )clicon->type != 0U) {
    {
    {
#line 644
    xa_debug(1, (char *)"WARNING: describe_client(): called with invalid type");
    }
    }
#line 645
    return;
  }
  {
  {
#line 648
  describe_connection(req, clicon);
  }
#line 650
  client = (client_t const   *)clicon->food.client;
  {
#line 652
  admin_write_line(req, (int const   )483, "Misc client info:");
  }
  }
#line 653
  if (client->use_udp) {
#line 653
    tmp = "yes";
  } else {
#line 653
    tmp = "no";
  }
  {
  {
#line 653
  admin_write_line(req, (int const   )484, "UDPinfo: %s", tmp);
  }
  }
#line 654
  if (client->use_udp) {
    {
    {
#line 655
    tmp___0 = htons((clicon->sin)->sin_port);
    }
    {
#line 655
    admin_write_line(req, (int const   )484, "UDP client port: %d", (int )tmp___0);
    }
    }
  }
  {
  {
#line 656
  admin_write_line(req, (int const   )484, "UDP sequence number: %d", client->udpseqnr);
  }
  }
#line 657
  if (client->use_icy_metadata) {
#line 657
    tmp___1 = "yes";
  } else {
#line 657
    tmp___1 = "no";
  }
  {
  {
#line 657
  admin_write_line(req, (int const   )484, "ICY metadata: %s", tmp___1);
  }
  {
#line 658
  tmp___2 = client_errors(client);
  }
  {
#line 658
  admin_write_line(req, (int const   )484, "Transfer error balance: %d", tmp___2);
  }
  {
#line 659
  admin_write_line(req, (int const   )484, "Transfer chunk id and offset: %d : %d",
                   client->cid, client->offset);
  }
  {
#line 660
  admin_write_line(req, (int const   )484, "Bytes transfered: %lu", client->write_bytes);
  }
  }
#line 661
  if (client->virgin) {
#line 661
    tmp___3 = "yes";
  } else {
#line 661
    tmp___3 = "no";
  }
  {
  {
#line 661
  admin_write_line(req, (int const   )484, "Virgin: %s", tmp___3);
  }
  {
#line 662
  tmp___4 = client_type(clicon);
  }
  {
#line 662
  admin_write_line(req, (int const   )484, "Client type: %s", tmp___4);
  }
  }
#line 663
  if (client->source) {
#line 663
    if ((client->source)->audiocast.mount) {
      {
      {
#line 664
      admin_write_line(req, (int const   )484, "Mountpoint: %s", (client->source)->audiocast.mount);
      }
      }
    }
  }
  {
  {
#line 665
  admin_write_line(req, (int const   )497, "End of client info");
  }
  }
#line 666
  return;
}
}
#line 668 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
char const   client_types[4][16]  = { {        (char const   )'l',        (char const   )'i',        (char const   )'s',        (char const   )'t', 
            (char const   )'e',        (char const   )'n',        (char const   )'e',        (char const   )'r', 
            (char const   )'\000'}, 
   {        (char const   )'p',        (char const   )'u',        (char const   )'s',        (char const   )'h', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'p',        (char const   )'u',        (char const   )'l',        (char const   )'l', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'u',        (char const   )'n',        (char const   )'k',        (char const   )'n', 
            (char const   )'o',        (char const   )'w',        (char const   )'n',        (char const   )' ', 
            (char const   )'l',        (char const   )'i',        (char const   )'s',        (char const   )'t', 
            (char const   )'e',        (char const   )'n',        (char const   )'e',        (char const   )'r'}};
#line 670 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
char const   *client_type(connection_t const   *clicon ) 
{ 


  {
  {
#line 675
  if ((int )(clicon->food.client)->type == 0) {
#line 675
    goto case_0;
  }
#line 678
  if ((int )(clicon->food.client)->type == 1) {
#line 678
    goto case_1;
  }
#line 681
  if ((int )(clicon->food.client)->type == 2) {
#line 681
    goto case_2;
  }
#line 684
  goto switch_default;
  case_0: /* CIL Label */ 
#line 676
  return (client_types[0]);
#line 677
  goto switch_break;
  case_1: /* CIL Label */ 
#line 679
  return (client_types[1]);
#line 680
  goto switch_break;
  case_2: /* CIL Label */ 
#line 682
  return (client_types[2]);
#line 683
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 685
  return (client_types[3]);
#line 686
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 688
  return ((char const   *)0);
}
}
#line 690 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/client.c"
int client_errors(client_t const   *client ) 
{ 


  {
#line 693
  if (! client) {
#line 694
    return (0);
  } else
#line 693
  if (! client->source) {
#line 694
    return (0);
  }
#line 696
  return ((64 - (int )(client->cid - (int const   )(client->source)->cid)) % 64);
}
}
#line 103 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void zero_opts___0(int *opt , int maxelements ) ;
#line 104
static void set_opts___0(int *opt , char const   *arg , conopt_t *opts , int maxelements ) ;
#line 3100 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void zero_opts___0(int *opt , int maxelements ) 
{ 
  int i ;

  {
#line 3105
  if (! opt) {
#line 3106
    return;
  }
#line 3108
  i = 0;
  {
  {
#line 3108
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3108
    if (! (i < maxelements)) {
#line 3108
      goto while_break;
    }
#line 3109
    *(opt + i) = 0;
#line 3108
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3110
  return;
}
}
#line 3112 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/commands.c"
static void set_opts___0(int *opt , char const   *arg , conopt_t *opts , int maxelements ) 
{ 
  int i ;
  int k ;

  {
#line 3117
  if (! opt) {
#line 3118
    return;
  } else
#line 3117
  if (! arg) {
#line 3118
    return;
  } else
#line 3117
  if (! opts) {
#line 3118
    return;
  } else
#line 3117
  if (maxelements < 0) {
#line 3118
    return;
  }
#line 3120
  i = 0;
  {
  {
#line 3120
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 3120
    if (! *(arg + i)) {
#line 3120
      goto while_break;
    }
#line 3122
    if ((int const   )*(arg + i) == 45) {
#line 3123
      goto __Cont;
    }
#line 3125
    k = 0;
    {
    {
#line 3125
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 3125
      if (! (k < maxelements)) {
#line 3125
        goto while_break___0;
      }
#line 3127
      if ((int )(opts + k)->opt == (int )*(arg + i)) {
#line 3128
        *(opt + (opts + k)->arindex) = 1;
      }
#line 3125
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3120
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3131
  return;
}
}
#line 159 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/ice_string.c"
static char null___0[5]  = {      (char )'n',      (char )'u',      (char )'l',      (char )'l', 
        (char )'\000'};
#line 73 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
static mutex_t pool_mutex___0  =    {-3L, {{0, 0U, 0, 0, 0U, {.__list = {(struct __pthread_internal_slist *)0}}}},
    0L, 0, 0L};
#line 74 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/pool.c"
static avl_tree *pool___0  =    (avl_tree *)((void *)0);
#line 547 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/main.c"
static int main_shutting_down___0  =    0;
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.c"
static unsigned char tolowertab___0[256]  = 
#line 49 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/match.c"
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'k', 
        (unsigned char )'l',      (unsigned char )'m',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'r',      (unsigned char )'s', 
        (unsigned char )'t',      (unsigned char )'u',      (unsigned char )'v',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'y',      (unsigned char )'z',      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
#line 1512 "/home/wslee/benchmarks/sound/icecast-server-1.3.12/src/utility.c"
static char apan___0[30]  ;
