/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 288 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/stdpre.h"
typedef int bool;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 170 "/usr/include/libio.h"
struct _IO_FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 240 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
struct string_item_s {
   char const   *str ;
   int file_index ;
   int index ;
};
#line 240 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
typedef struct string_item_s string_item_t;
#line 247
enum __anonenum_uniq_mode_t_24 {
    uniq_all = 1,
    uniq_first = 2,
    uniq_last = 4
} ;
#line 247 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
typedef enum __anonenum_uniq_mode_t_24 uniq_mode_t;
#line 252 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
struct string_list_s {
   char const   *list_name ;
   int max_count ;
   uniq_mode_t mode ;
   int count ;
   string_item_t *items ;
};
#line 252 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
typedef struct string_list_s string_list_t;
#line 263 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
struct string_pattern_s {
   bool upper_case ;
   bool drop_extn ;
   char pattern[61] ;
};
#line 263 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
typedef struct string_pattern_s string_pattern_t;
#line 268 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
struct nu_ {
   string_list_t sorted_resources ;
   string_list_t resources ;
   string_list_t devs ;
   string_list_t compositors ;
   string_list_t fonts ;
   string_list_t libs ;
   string_list_t libpaths ;
   string_list_t links ;
   string_list_t objs ;
};
#line 268 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
union ru_ {
   struct nu_ named ;
   string_list_t indexed[9] ;
};
#line 268 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
struct config_s {
   int debug ;
   char const   *name_prefix ;
   char const   *file_prefix ;
   string_list_t file_names ;
   string_list_t file_contents ;
   string_list_t replaces ;
   union ru_ lists ;
   string_pattern_t lib_p ;
   string_pattern_t libpath_p ;
   string_pattern_t obj_p ;
};
#line 268 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
typedef struct config_s config_t;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 147 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 662
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 722
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 727
extern long ftell(FILE *__stream ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 471 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 756
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 142
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 302 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static struct config_s  const  init_config  = 
#line 302 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
     {0, "gs_", "", {"file name", 200, 0U, 0, (string_item_t *)0}, {"file contents",
                                                                  200, 0U, 0, (string_item_t *)0},
    {"-replace", 50, 0U, 0, (string_item_t *)0}, {{{(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0},
                                                   {(char const   *)0, 0, 0U, 0, (string_item_t *)0}}},
    {0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
            (char)0, (char)0, (char)0, (char)0, (char)0}}, {0, 0, {(char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0}}, {0,
                                                                               0,
                                                                               {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0}}};
#line 310 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static string_list_t const   init_config_lists[9]  = 
#line 310
  {      {"resource", 100, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"sorted_resource", 20, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-comp", 10, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-dev", 100, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-font", 50, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-lib", 20, (uniq_mode_t )4, 0, (string_item_t *)0}, 
        {"-libpath", 10, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-link", 10, (uniq_mode_t )2, 0, (string_item_t *)0}, 
        {"-obj", 500, (uniq_mode_t )2, 0, (string_item_t *)0}};
#line 323
static void *mrealloc(void *old_ptr , size_t old_size , size_t new_size ) ;
#line 324
int alloc_list(string_list_t *list ) ;
#line 325
void dev_file_name(char *str ) ;
#line 326
int process_replaces(config_t *pconf ) ;
#line 327
int read_dev(config_t *pconf , char const   *arg ) ;
#line 328
int read_token(char *token , int max_len , char const   **pin ) ;
#line 329
int add_entry(config_t *pconf , char *category , char const   *item , int file_index ) ;
#line 330
string_item_t *add_item(string_list_t *list , char const   *str , int file_index ) ;
#line 331
void sort_uniq(string_list_t *list , bool by_index ) ;
#line 332
void write_list(FILE *out , string_list_t const   *list , char const   *pstr ) ;
#line 333
void write_list_pattern(FILE *out , string_list_t const   *list , string_pattern_t const   *pat ) ;
#line 338 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int main(int argc , char **argv ) 
{ 
  config_t conf ;
  char escape ;
  int i ;
  char const   *arg ;
  FILE *out ;
  int lib ;
  int obj ;
  string_pattern_t *pat ;
  char *p ;
  char *q ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;
  char template[80] ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 342
  escape = (char )'&';
#line 346
  conf = (config_t )init_config;
#line 347
  memcpy((void */* __restrict  */)(conf.lists.indexed), (void const   */* __restrict  */)(init_config_lists),
         (size_t )sizeof(conf.lists.indexed));
#line 349
  alloc_list(& conf.file_names);
#line 350
  alloc_list(& conf.file_contents);
#line 351
  alloc_list(& conf.replaces);
#line 352
  i = 0;
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < 9)) {
#line 352
      goto while_break;
    }
    {
#line 353
    alloc_list(& conf.lists.indexed[i]);
#line 352
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  conf.lib_p.upper_case = 0;
#line 357
  conf.lib_p.drop_extn = 0;
#line 358
  strcpy((char */* __restrict  */)(conf.lib_p.pattern), (char const   */* __restrict  */)"%s\n");
#line 359
  conf.libpath_p = conf.lib_p;
#line 360
  conf.obj_p = conf.lib_p;
#line 363
  i = 1;
  }
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    if (! (i < argc)) {
#line 363
      goto while_break___0;
    }
#line 364
    arg = (char const   *)*(argv + i);
#line 366
    lib = 0;
#line 366
    obj = 0;
#line 368
    if ((int const   )*arg != 45) {
      {
#line 369
      read_dev(& conf, arg);
      }
#line 370
      goto __Cont;
    }
#line 372
    if (i == argc - 1) {
      {
#line 373
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing argument after %s.\n",
              arg);
#line 375
      exit(1);
      }
    }
    {
#line 378
    if ((int const   )*(arg + 1) == 67) {
#line 378
      goto case_67;
    }
#line 383
    if ((int const   )*(arg + 1) == 101) {
#line 383
      goto case_101;
    }
#line 387
    if ((int const   )*(arg + 1) == 110) {
#line 387
      goto case_110;
    }
#line 392
    if ((int const   )*(arg + 1) == 112) {
#line 392
      goto case_112;
    }
#line 458
    if ((int const   )*(arg + 1) == 90) {
#line 458
      goto case_90;
    }
#line 377
    goto switch_break;
    case_67: /* CIL Label */ 
#line 379
    if ((int )*(*(argv + (i + 1)) + 0) == 45) {
#line 379
      conf.file_prefix = "";
    } else {
#line 379
      conf.file_prefix = (char const   *)*(argv + (i + 1));
    }
#line 381
    i ++;
#line 382
    goto __Cont;
    case_101: /* CIL Label */ 
#line 384
    escape = *(*(argv + (i + 1)) + 0);
#line 385
    i ++;
#line 386
    goto __Cont;
    case_110: /* CIL Label */ 
#line 388
    if ((int )*(*(argv + (i + 1)) + 0) == 45) {
#line 388
      conf.name_prefix = "";
    } else {
#line 388
      conf.name_prefix = (char const   *)*(argv + (i + 1));
    }
#line 390
    i ++;
#line 391
    goto __Cont;
    case_112: /* CIL Label */ 
#line 396
    arg += 2;
    {
#line 397
    if ((int const   )*arg == 108) {
#line 397
      goto case_108;
    }
#line 400
    if ((int const   )*arg == 76) {
#line 400
      goto case_76;
    }
#line 403
    goto switch_default;
    case_108: /* CIL Label */ 
#line 398
    pat = & conf.lib_p;
#line 399
    goto switch_break___0;
    case_76: /* CIL Label */ 
#line 401
    pat = & conf.libpath_p;
#line 402
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 404
    pat = & conf.obj_p;
#line 405
    arg --;
    switch_break___0: /* CIL Label */ ;
    }
#line 407
    pat->upper_case = 0;
#line 408
    pat->drop_extn = 0;
#line 409
    if ((int )*(*(argv + (i + 1)) + 0) == 45) {
      {
#line 410
      strcpy((char */* __restrict  */)(pat->pattern), (char const   */* __restrict  */)"%s\n");
      }
    } else {
#line 414
      p = pat->pattern;
#line 414
      i ++;
#line 414
      q = *(argv + i);
      {
#line 414
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 414
        tmp = p;
#line 414
        p ++;
#line 414
        tmp___1 = q;
#line 414
        q ++;
#line 414
        tmp___0 = *tmp___1;
#line 414
        *tmp = tmp___0;
#line 414
        if (! ((int )tmp___0 != 0)) {
#line 414
          goto while_break___1;
        }
#line 417
        if ((int )*(p + -1) == (int )escape) {
          {
#line 419
          if ((int )*q == 112) {
#line 419
            goto case_112___0;
          }
#line 421
          if ((int )*q == 115) {
#line 421
            goto case_115;
          }
#line 423
          if ((int )*q == 45) {
#line 423
            goto case_45;
          }
#line 425
          goto switch_default___0;
          case_112___0: /* CIL Label */ 
#line 420
          *(p + -1) = (char )'%';
#line 420
          q ++;
#line 420
          goto switch_break___1;
          case_115: /* CIL Label */ 
#line 422
          *(p + -1) = (char )' ';
#line 422
          q ++;
#line 422
          goto switch_break___1;
          case_45: /* CIL Label */ 
#line 424
          *(p + -1) = (char )'-';
#line 424
          q ++;
#line 424
          goto switch_break___1;
          switch_default___0: /* CIL Label */ 
#line 426
          if ((int )*q == (int )escape) {
#line 427
            *(p + -1) = (char )'\\';
#line 427
            q ++;
#line 427
            goto switch_break___1;
          }
          {
#line 429
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%c not followed by p|s|%c|-: &%c\n",
                  (int )escape, (int )escape, (int )*q);
#line 432
          exit(1);
          }
          switch_break___1: /* CIL Label */ ;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 434
      *(p + -1) = (char )'\n';
#line 435
      *p = (char)0;
    }
    {
#line 437
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 438
      arg ++;
      {
#line 439
      if ((int const   )*arg == 117) {
#line 439
        goto case_117;
      }
#line 442
      if ((int const   )*arg == 101) {
#line 442
        goto case_101___0;
      }
#line 445
      if ((int const   )*arg == 0) {
#line 445
        goto case_0;
      }
#line 447
      goto switch_default___1;
      case_117: /* CIL Label */ 
#line 440
      pat->upper_case = 1;
#line 441
      goto switch_break___2;
      case_101___0: /* CIL Label */ 
#line 443
      pat->drop_extn = 1;
#line 444
      goto switch_break___2;
      case_0: /* CIL Label */ 
#line 446
      goto pbreak;
      switch_default___1: /* CIL Label */ 
      {
#line 448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown switch %s.\n",
              arg);
#line 449
      exit(1);
      }
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    pbreak: 
#line 452
    if ((unsigned long )pat == (unsigned long )(& conf.obj_p)) {
#line 453
      conf.lib_p = *pat;
#line 454
      conf.libpath_p = *pat;
    }
#line 456
    goto __Cont;
    case_90: /* CIL Label */ 
#line 459
    conf.debug = 1;
#line 460
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 463
    i ++;
#line 463
    out = fopen((char const   */* __restrict  */)*(argv + i), (char const   */* __restrict  */)"w");
    }
#line 464
    if ((unsigned long )out == (unsigned long )((FILE *)0)) {
      {
#line 465
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for output.\n",
              *(argv + i));
#line 467
      exit(1);
      }
    }
    {
#line 470
    if ((int const   )*(arg + 1) == 102) {
#line 470
      goto case_102;
    }
#line 483
    if ((int const   )*(arg + 1) == 104) {
#line 483
      goto case_104;
    }
#line 493
    if ((int const   )*(arg + 1) == 108) {
#line 493
      goto case_108___0;
    }
#line 497
    if ((int const   )*(arg + 1) == 111) {
#line 497
      goto case_111;
    }
#line 513
    goto switch_default___2;
    case_102: /* CIL Label */ 
    {
#line 471
    process_replaces(& conf);
#line 472
    fputs((char const   */* __restrict  */)"/* This file was generated automatically by genconf.c. */\n",
          (FILE */* __restrict  */)out);
#line 473
    fputs((char const   */* __restrict  */)"/* For documentation, see gsconfig.c. */\n",
          (FILE */* __restrict  */)out);
#line 477
    sprintf((char */* __restrict  */)(template), (char const   */* __restrict  */)"font_(\"0.font_%%s\",%sf_%%s,zf_%%s)\n",
            conf.name_prefix);
#line 480
    write_list(out, (string_list_t const   *)(& conf.lists.named.fonts), (char const   *)(template));
    }
#line 482
    goto switch_break___3;
    case_104: /* CIL Label */ 
    {
#line 484
    process_replaces(& conf);
#line 485
    fputs((char const   */* __restrict  */)"/* This file was generated automatically by genconf.c. */\n",
          (FILE */* __restrict  */)out);
#line 486
    write_list(out, (string_list_t const   *)(& conf.lists.named.compositors), "%s\n");
#line 487
    write_list(out, (string_list_t const   *)(& conf.lists.named.devs), "%s\n");
#line 488
    sort_uniq(& conf.lists.named.resources, 1);
#line 489
    write_list(out, (string_list_t const   *)(& conf.lists.named.resources), "%s\n");
#line 490
    sort_uniq(& conf.lists.named.sorted_resources, 0);
#line 491
    write_list(out, (string_list_t const   *)(& conf.lists.named.sorted_resources),
               "%s\n");
    }
#line 492
    goto switch_break___3;
    case_108___0: /* CIL Label */ 
#line 494
    lib = 1;
#line 495
    obj = (int const   )*(arg + 2) == 111;
#line 496
    goto lo;
    case_111: /* CIL Label */ 
#line 498
    obj = 1;
#line 499
    lib = (int const   )*(arg + 2) == 108;
    lo: 
    {
#line 500
    process_replaces(& conf);
    }
#line 501
    if (obj) {
      {
#line 502
      sort_uniq(& conf.lists.named.objs, 1);
#line 503
      write_list_pattern(out, (string_list_t const   *)(& conf.lists.named.objs),
                         (string_pattern_t const   *)(& conf.obj_p));
      }
    }
#line 505
    if (lib) {
      {
#line 506
      sort_uniq(& conf.lists.named.libs, 1);
#line 507
      sort_uniq(& conf.lists.named.links, 1);
#line 508
      write_list_pattern(out, (string_list_t const   *)(& conf.lists.named.libpaths),
                         (string_pattern_t const   *)(& conf.libpath_p));
#line 509
      write_list_pattern(out, (string_list_t const   *)(& conf.lists.named.links),
                         (string_pattern_t const   *)(& conf.obj_p));
#line 510
      write_list_pattern(out, (string_list_t const   *)(& conf.lists.named.libs),
                         (string_pattern_t const   *)(& conf.lib_p));
      }
    }
#line 512
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
    {
#line 514
    fclose(out);
#line 515
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown switch %s.\n",
            *(argv + i));
#line 516
    exit(1);
    }
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 518
    fclose(out);
    }
    __Cont: /* CIL Label */ 
#line 363
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 521
  return (0);
}
}
#line 529 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static void *mrealloc(void *old_ptr , size_t old_size , size_t new_size ) 
{ 
  void *new_ptr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 532
  tmp = malloc(new_size);
#line 532
  new_ptr = tmp;
  }
#line 534
  if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
#line 535
    return ((void *)0);
  }
#line 538
  if (old_ptr) {
#line 539
    if (old_size < new_size) {
#line 539
      tmp___0 = old_size;
    } else {
#line 539
      tmp___0 = new_size;
    }
    {
#line 539
    memcpy((void */* __restrict  */)new_ptr, (void const   */* __restrict  */)old_ptr,
           tmp___0);
    }
  }
#line 540
  return (new_ptr);
}
}
#line 544 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int alloc_list(string_list_t *list ) 
{ 
  void *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 547
  list->count = 0;
#line 548
  tmp = calloc((size_t )list->max_count, (size_t )sizeof(string_item_t ));
#line 548
  list->items = (string_item_t *)tmp;
  }
#line 550
  if (! ((unsigned long )list->items != (unsigned long )((void *)0))) {
    {
#line 550
    __assert_fail("list->items != ((void *)0)", "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c",
                  550U, "alloc_list");
    }
  }
#line 551
  return (0);
}
}
#line 555 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
void dev_file_name(char *str ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 558
  tmp = strlen((char const   *)str);
#line 558
  len = (int )tmp;
  }
#line 560
  if (len <= 4) {
    {
#line 561
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)".dev");
    }
  } else {
    {
#line 560
    tmp___0 = strcmp(".dev", (char const   *)((str + len) - 4));
    }
#line 560
    if (tmp___0) {
      {
#line 561
      strcat((char */* __restrict  */)str, (char const   */* __restrict  */)".dev");
      }
    }
  }
#line 562
  return;
}
}
#line 565 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int process_replaces(config_t *pconf ) 
{ 
  char bufname[120] ;
  int i ;
  int j ;
  char const   *fname ;
  int rn ;
  string_item_t *items ;
  int count ;
  int tn ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 571
  i = 0;
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < pconf->replaces.count)) {
#line 571
      goto while_break;
    }
    {
#line 574
    strcpy((char */* __restrict  */)(bufname), (char const   */* __restrict  */)(pconf->replaces.items + i)->str);
#line 576
    dev_file_name(bufname);
#line 577
    j = 0;
    }
    {
#line 577
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 577
      if (! (j < pconf->file_names.count)) {
#line 577
        goto while_break___0;
      }
      {
#line 578
      fname = (pconf->file_names.items + j)->str;
#line 580
      tmp___0 = strcmp(fname, (char const   *)(bufname));
      }
#line 580
      if (! tmp___0) {
#line 581
        if (pconf->debug) {
          {
#line 582
          printf((char const   */* __restrict  */)"Replacing file %s.\n", fname);
          }
        }
#line 587
        rn = 0;
        {
#line 587
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 587
          if (! (rn < 9)) {
#line 587
            goto while_break___1;
          }
#line 588
          items = pconf->lists.indexed[rn].items;
#line 589
          count = pconf->lists.indexed[rn].count;
#line 592
          tn = 0;
          {
#line 592
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 592
            if (! (tn < count)) {
#line 592
              goto while_break___2;
            }
#line 593
            if ((items + tn)->file_index == j) {
#line 600
              if (pconf->debug) {
                {
#line 601
                printf((char const   */* __restrict  */)"Replacing %s %s.\n", pconf->lists.indexed[rn].list_name,
                       (items + tn)->str);
                }
              }
#line 604
              tmp = tn;
#line 604
              tn --;
#line 604
              count --;
#line 604
              *(items + tmp) = *(items + count);
            }
#line 592
            tn ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 607
          pconf->lists.indexed[rn].count = count;
#line 587
          rn ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 610
        (pconf->file_names.items + j)->str = "";
#line 611
        goto while_break___0;
      }
#line 577
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  pconf->replaces.count = 0;
#line 617
  return (0);
}
}
#line 626 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static string_item_t *read_file(config_t *pconf , char const   *fname ) 
{ 
  char *cname ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int i ;
  FILE *in ;
  int end ;
  int nread ;
  char *cont ;
  string_item_t *item ;
  int tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 629
  tmp = strlen(fname);
#line 629
  tmp___0 = strlen(pconf->file_prefix);
#line 629
  tmp___1 = malloc((tmp + tmp___0) + 1U);
#line 629
  cname = (char *)tmp___1;
  }
#line 636
  if ((unsigned long )cname == (unsigned long )((char *)0)) {
    {
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t allocate space for file name %s%s.\n",
            pconf->file_prefix, fname);
#line 639
    exit(1);
    }
  }
  {
#line 641
  strcpy((char */* __restrict  */)cname, (char const   */* __restrict  */)pconf->file_prefix);
#line 642
  strcat((char */* __restrict  */)cname, (char const   */* __restrict  */)fname);
#line 643
  i = 0;
  }
  {
#line 643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 643
    if (! (i < pconf->file_names.count)) {
#line 643
      goto while_break;
    }
    {
#line 644
    tmp___2 = strcmp((pconf->file_names.items + i)->str, (char const   *)cname);
    }
#line 644
    if (! tmp___2) {
      {
#line 645
      free((void *)cname);
      }
#line 646
      return (pconf->file_contents.items + i);
    }
#line 643
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 650
  in = fopen((char const   */* __restrict  */)cname, (char const   */* __restrict  */)"rb");
  }
#line 651
  if ((unsigned long )in == (unsigned long )((FILE *)0)) {
    {
#line 652
    in = fopen((char const   */* __restrict  */)cname, (char const   */* __restrict  */)"r");
    }
#line 653
    if ((unsigned long )in == (unsigned long )((FILE *)0)) {
      {
#line 654
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t read %s.\n",
              cname);
#line 655
      exit(1);
      }
    }
  }
  {
#line 658
  fseek(in, 0L, 2);
#line 659
  tmp___3 = ftell(in);
#line 659
  end = (int )tmp___3;
#line 660
  tmp___4 = malloc((size_t )(end + 1));
#line 660
  cont = (char *)tmp___4;
  }
#line 661
  if ((unsigned long )cont == (unsigned long )((char *)0)) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t allocate %d bytes to read %s.\n",
            end + 1, cname);
#line 664
    exit(1);
    }
  }
  {
#line 666
  rewind(in);
#line 667
  tmp___5 = fread((void */* __restrict  */)cont, (size_t )1, (size_t )end, (FILE */* __restrict  */)in);
#line 667
  nread = (int )tmp___5;
#line 668
  fclose(in);
#line 669
  *(cont + nread) = (char)0;
  }
#line 670
  if (pconf->debug) {
    {
#line 671
    printf((char const   */* __restrict  */)"File %s = %d bytes.\n", cname, nread);
    }
  }
  {
#line 672
  add_item(& pconf->file_names, (char const   *)cname, -1);
#line 673
  item = add_item(& pconf->file_contents, (char const   *)cont, -1);
#line 674
  item->index = 0;
  }
#line 675
  return (item);
}
}
#line 679 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int read_dev(config_t *pconf , char const   *arg ) 
{ 
  string_item_t *item ;
  char const   *in ;
  char *token ;
  void *tmp ;
  char *category ;
  void *tmp___0 ;
  int file_index ;
  int len ;
  int tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 686
  tmp = malloc((size_t )257);
#line 686
  token = (char *)tmp;
#line 687
  tmp___0 = malloc((size_t )257);
#line 687
  category = (char *)tmp___0;
  }
#line 691
  if (pconf->debug) {
    {
#line 692
    printf((char const   */* __restrict  */)"Reading %s;\n", arg);
    }
  }
  {
#line 693
  item = read_file(pconf, arg);
  }
#line 694
  if (item->index == 2) {
#line 695
    if (pconf->debug) {
      {
#line 696
      printf((char const   */* __restrict  */)"Skipping duplicate file.\n");
      }
    }
#line 697
    return (2);
  }
  {
#line 699
  in = item->str;
#line 700
  file_index = (int )(item - pconf->file_contents.items);
#line 701
  strcpy((char */* __restrict  */)category, (char const   */* __restrict  */)"obj");
  }
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 702
    len = read_token(token, 256, & in);
    }
#line 702
    if (! (len > 0)) {
#line 702
      goto while_break;
    }
    {
#line 703
    tmp___1 = add_entry(pconf, category, (char const   *)token, file_index);
#line 703
    item->index |= tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 704
  free((void *)category);
  }
#line 706
  if (len < 0) {
    {
#line 707
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Token too long: %s.\n",
            token);
#line 708
    exit(1);
    }
  }
#line 710
  if (pconf->debug) {
    {
#line 711
    printf((char const   */* __restrict  */)"Finished %s.\n", arg);
    }
  }
  {
#line 712
  free((void *)token);
  }
#line 713
  return (item->index);
}
}
#line 717 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int read_token(char *token , int max_len , char const   **pin ) 
{ 
  char const   *in ;
  int len ;
  char ch ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 720
  in = *pin;
#line 721
  len = 0;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (len < max_len)) {
#line 723
      goto while_break;
    }
#line 724
    ch = (char )*in;
#line 726
    if ((int )ch == 0) {
#line 727
      goto while_break;
    }
    {
#line 728
    in ++;
#line 729
    tmp = __ctype_b_loc();
    }
#line 729
    if ((int const   )*(*tmp + (int )ch) & 8192) {
#line 730
      if (len > 0) {
#line 731
        goto while_break;
      }
#line 732
      goto while_continue;
    }
#line 734
    tmp___0 = len;
#line 734
    len ++;
#line 734
    *(token + tmp___0) = ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  *(token + len) = (char)0;
#line 737
  *pin = in;
#line 738
  if (len >= max_len) {
#line 738
    tmp___1 = -1;
  } else {
#line 738
    tmp___1 = len;
  }
#line 738
  return (tmp___1);
}
}
#line 742 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
int add_entry(config_t *pconf , char *category , char const   *item , int file_index ) 
{ 
  char str[120] ;
  char template[80] ;
  char const   *pat ;
  string_list_t *list ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t tmp___22 ;
  unsigned short const   **tmp___23 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;

  {
#line 745
  if ((int const   )*(item + 0) == 45) {
    {
#line 745
    tmp___23 = __ctype_b_loc();
    }
#line 745
    if ((int const   )*(*tmp___23 + (int )*(item + 1)) & 512) {
      {
#line 746
      strcpy((char */* __restrict  */)category, (char const   */* __restrict  */)(item + 1));
      }
#line 747
      return (0);
    } else {
#line 745
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 751
    pat = (char const   *)0;
#line 752
    list = & pconf->lists.named.resources;
#line 754
    if (pconf->debug) {
      {
#line 755
      printf((char const   */* __restrict  */)"Adding %s %s;\n", category, item);
      }
    }
    {
#line 759
    if ((int )*(category + 0) == 99) {
#line 759
      goto case_99;
    }
#line 765
    if ((int )*(category + 0) == 100) {
#line 765
      goto case_100;
    }
#line 776
    if ((int )*(category + 0) == 101) {
#line 776
      goto case_101;
    }
#line 784
    if ((int )*(category + 0) == 102) {
#line 784
      goto case_102;
    }
#line 793
    if ((int )*(category + 0) == 104) {
#line 793
      goto case_104;
    }
#line 799
    if ((int )*(category + 0) == 105) {
#line 799
      goto case_105;
    }
#line 816
    if ((int )*(category + 0) == 108) {
#line 816
      goto case_108;
    }
#line 828
    if ((int )*(category + 0) == 111) {
#line 828
      goto case_111;
    }
#line 841
    if ((int )*(category + 0) == 112) {
#line 841
      goto case_112;
    }
#line 852
    if ((int )*(category + 0) == 114) {
#line 852
      goto case_114;
    }
#line 859
    goto err;
    case_99: /* CIL Label */ 
    {
#line 760
    tmp = strcmp((char const   *)category, "comp");
    }
#line 760
    if (tmp) {
#line 761
      goto err;
    }
#line 762
    pat = "compositor_(%scomposite_%%s_type)";
#line 763
    list = & pconf->lists.named.compositors;
#line 764
    goto pre;
    case_100: /* CIL Label */ 
    {
#line 766
    tmp___1 = strcmp((char const   *)category, "dev");
    }
#line 766
    if (tmp___1) {
      {
#line 768
      tmp___0 = strcmp((char const   *)category, "dev2");
      }
#line 768
      if (tmp___0) {
#line 771
        goto err;
      } else {
#line 769
        pat = "device2_(%s%%s_device)";
      }
    } else {
#line 767
      pat = "device_(%s%%s_device)";
    }
#line 772
    list = & pconf->lists.named.devs;
    pre: 
    {
#line 773
    sprintf((char */* __restrict  */)(template), (char const   */* __restrict  */)pat,
            pconf->name_prefix);
#line 774
    pat = (char const   *)(template);
    }
#line 775
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 777
    tmp___3 = strcmp((char const   *)category, "emulator");
    }
#line 777
    if (! tmp___3) {
      {
#line 778
      tmp___2 = strlen(item);
#line 778
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"emulator_(\"%s\",%u)",
              item, tmp___2);
#line 780
      item = (char const   *)(str);
      }
#line 781
      goto switch_break;
    }
#line 783
    goto err;
    case_102: /* CIL Label */ 
    {
#line 785
    tmp___5 = strcmp((char const   *)category, "font");
    }
#line 785
    if (tmp___5) {
      {
#line 788
      tmp___4 = strcmp((char const   *)category, "functiontype");
      }
#line 788
      if (tmp___4) {
#line 791
        goto err;
      } else {
#line 789
        pat = "function_type_(%%s,%sbuild_function_%%s)";
      }
    } else {
#line 786
      list = & pconf->lists.named.fonts;
#line 787
      goto switch_break;
    }
#line 792
    goto pre;
    case_104: /* CIL Label */ 
    {
#line 794
    tmp___6 = strcmp((char const   *)category, "halftone");
    }
#line 794
    if (tmp___6) {
#line 797
      goto err;
    } else {
#line 795
      pat = "halftone_(%sdht_%%s)";
    }
#line 798
    goto pre;
    case_105: /* CIL Label */ 
    {
#line 800
    tmp___12 = strcmp((char const   *)category, "imageclass");
    }
#line 800
    if (tmp___12) {
      {
#line 803
      tmp___11 = strcmp((char const   *)category, "imagetype");
      }
#line 803
      if (tmp___11) {
        {
#line 805
        tmp___10 = strcmp((char const   *)category, "include");
        }
#line 805
        if (tmp___10) {
          {
#line 809
          tmp___9 = strcmp((char const   *)category, "init");
          }
#line 809
          if (tmp___9) {
            {
#line 811
            tmp___8 = strcmp((char const   *)category, "iodev");
            }
#line 811
            if (tmp___8) {
#line 814
              goto err;
            } else {
#line 812
              pat = "io_device_(%siodev_%%s)";
            }
          } else {
#line 810
            pat = "init_(%s%%s_init)";
          }
        } else {
          {
#line 806
          strcpy((char */* __restrict  */)(str), (char const   */* __restrict  */)item);
#line 807
          dev_file_name(str);
#line 808
          tmp___7 = read_dev(pconf, (char const   *)(str));
          }
#line 808
          return (tmp___7);
        }
      } else {
#line 804
        pat = "image_type_(%%s,%simage_type_%%s)";
      }
    } else {
#line 801
      list = & pconf->lists.named.sorted_resources;
#line 802
      pat = "image_class_(%simage_class_%%s)";
    }
#line 815
    goto pre;
    case_108: /* CIL Label */ 
    {
#line 817
    tmp___15 = strcmp((char const   *)category, "lib");
    }
#line 817
    if (tmp___15) {
      {
#line 820
      tmp___14 = strcmp((char const   *)category, "libpath");
      }
#line 820
      if (tmp___14) {
        {
#line 823
        tmp___13 = strcmp((char const   *)category, "link");
        }
#line 823
        if (! tmp___13) {
#line 824
          list = & pconf->lists.named.links;
#line 825
          goto switch_break;
        }
      } else {
#line 821
        list = & pconf->lists.named.libpaths;
#line 822
        goto switch_break;
      }
    } else {
#line 818
      list = & pconf->lists.named.libs;
#line 819
      goto switch_break;
    }
#line 827
    goto err;
    case_111: /* CIL Label */ 
    {
#line 829
    tmp___16 = strcmp((char const   *)category, "obj");
    }
#line 829
    if (! tmp___16) {
      {
#line 830
      list = & pconf->lists.named.objs;
#line 831
      strcpy((char */* __restrict  */)(template), (char const   */* __restrict  */)pconf->file_prefix);
#line 832
      strcat((char */* __restrict  */)(template), (char const   */* __restrict  */)"%s");
#line 833
      pat = (char const   *)(template);
      }
#line 834
      goto switch_break;
    }
    {
#line 836
    tmp___17 = strcmp((char const   *)category, "oper");
    }
#line 836
    if (! tmp___17) {
#line 837
      pat = "oper_(%s_op_defs)";
#line 838
      goto switch_break;
    }
#line 840
    goto err;
    case_112: /* CIL Label */ 
    {
#line 842
    tmp___20 = strcmp((char const   *)category, "ps");
    }
#line 842
    if (tmp___20) {
      {
#line 847
      tmp___19 = strcmp((char const   *)category, "plugin");
      }
#line 847
      if (! tmp___19) {
#line 848
        pat = "plugin_(%s%%s_instantiate)";
#line 849
        goto pre;
      }
    } else {
      {
#line 843
      tmp___18 = strlen(item);
#line 843
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"psfile_(\"%s.ps\",%u)",
              item, tmp___18 + 3U);
#line 845
      item = (char const   *)(str);
      }
#line 846
      goto switch_break;
    }
#line 851
    goto err;
    case_114: /* CIL Label */ 
    {
#line 853
    tmp___21 = strcmp((char const   *)category, "replace");
    }
#line 853
    if (! tmp___21) {
#line 854
      list = & pconf->replaces;
#line 855
      goto switch_break;
    }
#line 857
    goto err;
    err: 
    switch_default: /* CIL Label */ 
    {
#line 860
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Definition not recognized: %s %s.\n",
            category, item);
#line 862
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 864
    if (pat) {
      {
#line 865
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)pat,
              item, item);
#line 866
      tmp___22 = strlen((char const   *)(str));
      }
#line 866
      if (! (tmp___22 < 120U)) {
        {
#line 866
        __assert_fail("strlen(str) < 120", "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c",
                      866U, "add_entry");
        }
      }
      {
#line 867
      add_item(list, (char const   *)(str), file_index);
      }
    } else {
      {
#line 869
      add_item(list, item, file_index);
      }
    }
#line 870
    return ((int )list->mode);
  }
}
}
#line 875 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
string_item_t *add_item(string_list_t *list , char const   *str , int file_index ) 
{ 
  char *rstr ;
  size_t tmp ;
  void *tmp___0 ;
  int count ;
  string_item_t *item ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 878
  tmp = strlen(str);
#line 878
  tmp___0 = malloc(tmp + 1U);
#line 878
  rstr = (char *)tmp___0;
#line 879
  count = list->count;
  }
#line 882
  if (count >= list->max_count) {
#line 883
    list->max_count <<= 1;
#line 884
    if (list->max_count < 20) {
#line 885
      list->max_count = 20;
    }
    {
#line 886
    tmp___1 = mrealloc((void *)list->items, (size_t )((unsigned long )(list->max_count >> 1) * sizeof(string_item_t )),
                       (size_t )((unsigned long )list->max_count * sizeof(string_item_t )));
#line 886
    list->items = (string_item_t *)tmp___1;
    }
#line 892
    if (! ((unsigned long )list->items != (unsigned long )((void *)0))) {
      {
#line 892
      __assert_fail("list->items != ((void *)0)", "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c",
                    892U, "add_item");
      }
    }
  }
  {
#line 894
  item = list->items + count;
#line 895
  item->str = (char const   *)rstr;
#line 896
  item->index = count;
#line 897
  item->file_index = file_index;
#line 898
  strcpy((char */* __restrict  */)rstr, (char const   */* __restrict  */)str);
#line 899
  (list->count) ++;
  }
#line 900
  return (item);
}
}
#line 908 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static int cmp_index(void const   *p1 , void const   *p2 ) 
{ 
  string_item_t const   *psi1 ;
  string_item_t const   *psi2 ;
  int cmp ;
  int tmp ;
  int tmp___0 ;

  {
#line 911
  psi1 = (string_item_t const   *)p1;
#line 912
  psi2 = (string_item_t const   *)p2;
#line 913
  cmp = (int )(psi1->index - psi2->index);
#line 915
  if (cmp < 0) {
#line 915
    tmp___0 = -1;
  } else {
#line 915
    if (cmp > 0) {
#line 915
      tmp = 1;
    } else {
#line 915
      tmp = 0;
    }
#line 915
    tmp___0 = tmp;
  }
#line 915
  return (tmp___0);
}
}
#line 917 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
static int cmp_str(void const   *p1 , void const   *p2 ) 
{ 
  string_item_t const   *psi1 ;
  string_item_t const   *psi2 ;
  int tmp ;

  {
  {
#line 920
  psi1 = (string_item_t const   *)p1;
#line 921
  psi2 = (string_item_t const   *)p2;
#line 923
  tmp = strcmp((char const   *)psi1->str, (char const   *)psi2->str);
  }
#line 923
  return (tmp);
}
}
#line 925 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
void sort_uniq(string_list_t *list , bool by_index ) 
{ 
  string_item_t *strlist ;
  int count ;
  string_item_t const   *from ;
  string_item_t *to ;
  int i ;
  bool last ;
  string_item_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 928
  strlist = list->items;
#line 929
  count = list->count;
#line 933
  last = (unsigned int )list->mode == 4U;
#line 935
  if (count == 0) {
#line 936
    return;
  }
  {
#line 937
  qsort((void *)((char *)strlist), (size_t )count, (size_t )sizeof(string_item_t ),
        & cmp_str);
#line 938
  to = strlist + 1;
#line 938
  from = (string_item_t const   *)to;
#line 938
  i = 1;
  }
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if (! (i < count)) {
#line 938
      goto while_break;
    }
    {
#line 939
    tmp___1 = strcmp((char const   *)from->str, (to + -1)->str);
    }
#line 939
    if (tmp___1) {
#line 940
      tmp = to;
#line 940
      to ++;
#line 940
      *tmp = (string_item_t )*from;
    } else {
#line 941
      if (last) {
#line 941
        tmp___0 = from->index > (int const   )(to + -1)->index;
      } else {
#line 941
        tmp___0 = from->index < (int const   )(to + -1)->index;
      }
#line 941
      if (tmp___0) {
#line 944
        *(to + -1) = (string_item_t )*from;
      }
    }
#line 938
    from ++;
#line 938
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 945
  count = (int )(to - strlist);
#line 946
  list->count = count;
#line 947
  if (by_index) {
    {
#line 948
    qsort((void *)((char *)strlist), (size_t )count, (size_t )sizeof(string_item_t ),
          & cmp_index);
    }
  }
#line 949
  return;
}
}
#line 952 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
void write_list(FILE *out , string_list_t const   *list , char const   *pstr ) 
{ 
  string_pattern_t pat ;

  {
  {
#line 957
  pat.upper_case = 0;
#line 958
  pat.drop_extn = 0;
#line 959
  strcpy((char */* __restrict  */)(pat.pattern), (char const   */* __restrict  */)pstr);
#line 960
  write_list_pattern(out, list, (string_pattern_t const   *)(& pat));
  }
#line 961
  return;
}
}
#line 962 "/home/wslee/benchmarks/textformat/ghostscript-8.71.dfsg.1/./base/genconf.c"
void write_list_pattern(FILE *out , string_list_t const   *list , string_pattern_t const   *pat ) 
{ 
  int i ;
  char macname[40] ;
  int plen ;
  size_t tmp ;
  char const   *lstr ;
  int len ;
  size_t tmp___0 ;
  char *str ;
  void *tmp___1 ;
  int xlen ;
  char *xstr ;
  void *tmp___2 ;
  char *alist ;
  char *dot ;
  char *ptr ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 968
  tmp = strlen((char const   *)(pat->pattern));
#line 968
  plen = (int )tmp;
#line 970
  macname[0] = (char)0;
#line 971
  i = 0;
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! (i < (int )list->count)) {
#line 971
      goto while_break;
    }
    {
#line 972
    lstr = (list->items + i)->str;
#line 973
    tmp___0 = strlen(lstr);
#line 973
    len = (int )tmp___0;
#line 974
    tmp___1 = malloc((size_t )(len + 1));
#line 974
    str = (char *)tmp___1;
#line 975
    xlen = plen + len * 3;
#line 976
    tmp___2 = malloc((size_t )(xlen + 1));
#line 976
    xstr = (char *)tmp___2;
#line 979
    strcpy((char */* __restrict  */)str, (char const   */* __restrict  */)lstr);
    }
#line 980
    if (pat->drop_extn) {
#line 981
      dot = str + len;
      {
#line 983
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 983
        if ((unsigned long )dot > (unsigned long )str) {
#line 983
          if (! ((int )*dot != 46)) {
#line 983
            goto while_break___0;
          }
        } else {
#line 983
          goto while_break___0;
        }
#line 984
        dot --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 985
      if ((unsigned long )dot > (unsigned long )str) {
#line 986
        *dot = (char)0;
#line 986
        len = (int )(dot - str);
      }
    }
#line 988
    if (pat->upper_case) {
#line 989
      ptr = str;
      {
#line 991
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 991
        if (! *ptr) {
#line 991
          goto while_break___1;
        }
        {
#line 992
        tmp___4 = __ctype_b_loc();
        }
#line 992
        if ((int const   )*(*tmp___4 + (int )*ptr) & 512) {
          {
#line 993
          tmp___3 = toupper((int )*ptr);
#line 993
          *ptr = (char )tmp___3;
          }
        }
#line 991
        ptr ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 997
    sprintf((char */* __restrict  */)xstr, (char const   */* __restrict  */)(pat->pattern),
            str, str, str);
#line 1000
    alist = strchr((char const   *)xstr, '(');
    }
#line 1001
    if ((unsigned long )alist != (unsigned long )((char *)0)) {
#line 1001
      if ((unsigned long )alist != (unsigned long )xstr) {
#line 1001
        if ((int )*(alist + -1) == 95) {
          {
#line 1002
          *alist = (char)0;
#line 1003
          tmp___5 = strcmp((char const   *)xstr, (char const   *)(macname));
          }
#line 1003
          if (tmp___5) {
#line 1004
            if (macname[0]) {
              {
#line 1005
              fputs((char const   */* __restrict  */)"#endif\n", (FILE */* __restrict  */)out);
              }
            }
            {
#line 1006
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"#ifdef %s\n",
                    xstr);
#line 1007
            strcpy((char */* __restrict  */)(macname), (char const   */* __restrict  */)xstr);
            }
          }
#line 1009
          *alist = (char )'(';
        } else {
#line 1001
          goto _L___0;
        }
      } else {
#line 1001
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1011
    if (macname[0]) {
      {
#line 1012
      fputs((char const   */* __restrict  */)"#endif\n", (FILE */* __restrict  */)out);
#line 1013
      macname[0] = (char)0;
      }
    }
    {
#line 1016
    fputs((char const   */* __restrict  */)xstr, (FILE */* __restrict  */)out);
#line 1017
    free((void *)xstr);
#line 1018
    free((void *)str);
#line 971
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1020
  if (macname[0]) {
    {
#line 1021
    fputs((char const   */* __restrict  */)"#endif\n", (FILE */* __restrict  */)out);
    }
  }
#line 1022
  return;
}
}
