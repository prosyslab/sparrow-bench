/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 141 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
typedef short bool;
#line 150
enum OP {
    OP_CHECK = 0,
    OP_DUMP = 1,
    OP_DUMP_FULL = 2,
    OP_DUMP_VALUE = 3,
    OP_FILTER = 4,
    OP_EOT = 5
} ;
#line 178
enum LOG_LEVEL {
    LOG_LEVEL_QUIET = 0,
    LOG_LEVEL_ERRORS = 1,
    LOG_LEVEL_WARNINGS = 2,
    LOG_LEVEL_INFO = 3,
    LOG_LEVEL_DEBUG = 4,
    LOG_LEVEL_EOT = 5
} ;
#line 258 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
struct prefs_struct {
   enum LOG_LEVEL log_level ;
   bool technical ;
   enum OP op ;
   char *context_text ;
   unsigned long context_warnings ;
   unsigned long context_errors ;
   unsigned long context_fixes ;
   unsigned long warnings ;
   unsigned long errors ;
   unsigned long fixes ;
   unsigned short wrap_dump ;
   bool rewrite ;
   bool rewrite_create_backup ;
   bool fix ;
   int filter_mode ;
   bool rewrite_cached ;
   bool extract_iptc ;
   bool extract_extension_append ;
   bool test_rewrite ;
};
#line 288 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
struct parser_result {
   unsigned long parsed_bytes ;
   unsigned long written_bytes ;
   bool ret ;
};
#line 15 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
enum TIFF_TYPE {
    TIFF_IFD_TYPE_BYTE = 1,
    TIFF_IFD_TYPE_STRING = 2,
    TIFF_IFD_TYPE_USHORT = 3,
    TIFF_IFD_TYPE_ULONG = 4,
    TIFF_IFD_TYPE_URATIONAL = 5,
    TIFF_IFD_TYPE_SBYTE = 6,
    TIFF_IFD_TYPE_UNDEFINED = 7,
    TIFF_IFD_TYPE_SSHORT = 8,
    TIFF_IFD_TYPE_SLONG = 9,
    TIFF_IFD_TYPE_SRATIONAL = 10,
    TIFF_IFD_TYPE_FLOAT = 11,
    TIFF_IFD_TYPE_DOUBLE = 12,
    TIFF_IFD_TYPE_UNKNOWN = -1
} ;
#line 33 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct tiff_ifd_entry {
   unsigned short tag ;
   unsigned short type ;
   unsigned long count ;
   unsigned long value_offset ;
};
#line 41 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct tiff_ifd_type_size {
   enum TIFF_TYPE type ;
   unsigned int size ;
};
#line 50
enum EXIF_IFD_CODE {
    EXIF_IFD_IMAGE_WIDTH = 256,
    EXIF_IFD_IMAGE_HEIGHT = 257,
    EXIF_IFD_BITS_PER_SAMPLE = 258,
    EXIF_IFD_COMPRESSION = 259,
    EXIF_IFD_PHOTOMETRIC_INTERPRETATION = 262,
    EXIF_IFD_IMAGE_DESCR = 270,
    EXIF_IFD_MAKE = 271,
    EXIF_IFD_MODEL = 272,
    EXIF_IFD_STRIP_OFFSETS = 273,
    EXIF_IFD_ORIENTATION = 274,
    EXIF_IFD_SAMPLES_PER_PIXEL = 277,
    EXIF_IFD_ROWS_PER_STRIP = 278,
    EXIF_IFD_STRIP_BYTE_COUNT = 279,
    EXIF_IFD_XRES = 282,
    EXIF_IFD_YRES = 283,
    EXIF_IFD_RES_UNIT = 296,
    EXIF_IFD_SOFTWARE = 305,
    EXIF_IFD_DATE_TIME = 306,
    EXIF_IFD_JPEG_IF_OFFSET = 513,
    EXIF_IFD_JPEG_IF_BYTE_COUNT = 514,
    EXIF_IFD_YCBCR_POS = 531,
    EXIF_IFD_EXPOSURE_TIME = 33434,
    EXIF_IFD_F_NUMBER = 33437,
    EXIF_IFD_OFFSET = 34665,
    EXIF_IFD_LOCATION_OFFSET = 34695,
    EXIF_IFD_EXPOSURE_PROGRAM = 34850,
    EXIF_IFD_GPS_IFD_OFFSET = 34853,
    EXIF_IFD_ISO_SPEED_RATINGS = 34855,
    EXIF_IFD_EXIF_VERSION = 36864,
    EXIF_IFD_ORIG_DATE_TIME = 36867,
    EXIF_IFD_DIGIT_DATE_TIME = 36868,
    EXIF_IFD_COMPONENT_CONFIG = 37121,
    EXIF_IFD_COMPRESSION_RATE = 37122,
    EXIF_IFD_SHUTTER_SPEED = 37377,
    EXIF_IFD_APERTURE = 37378,
    EXIF_IFD_BRIGHTNESS = 37379,
    EXIF_IFD_EXPOSURE_BIAS = 37380,
    EXIF_IFD_MAX_APERTURE = 37381,
    EXIF_IFD_SUBJECT_DISTANCE = 37382,
    EXIF_IFD_METERING_MODE = 37383,
    EXIF_IFD_LIGHT_SOURCE = 37384,
    EXIF_IFD_FLASH = 37385,
    EXIF_IFD_FOCAL_LENGTH = 37386,
    EXIF_IFD_MAKER_NOTE = 37500,
    EXIF_IFD_USER_COMMENT = 37510,
    EXIF_IFD_FLASH_PIX_VERSION = 40960,
    EXIF_IFD_COLOR_SPACE = 40961,
    EXIF_IFD_EXIF_IMAGE_WIDTH = 40962,
    EXIF_IFD_EXIF_IMAGE_HEIGHT = 40963,
    EXIF_IFD_SOUND_FILE = 40964,
    EXIF_IFD_INTEROPE_OFFSET = 40965,
    EXIF_IFD_FOCAL_PLANE_XRES = 41486,
    EXIF_IFD_FOCAL_PLANE_YRES = 41487,
    EXIF_IFD_FOCAL_PLANE_RES_UNIT = 41488,
    EXIF_IFD_SENSING_METHOD = 41495,
    EXIF_IFD_FILE_SOURCE = 41728,
    EXIF_IFD_SCENE_TYPE = 41729,
    EXIF_IFD_EOT = 65535
} ;
#line 117
enum EXIF_INTEROPE_CODE {
    EXIF_INTEROPE_INDEX = 1,
    EXIF_INTEROPE_VERSION = 2,
    EXIF_INTEROPE_IMAGE_WIDTH = 4097,
    EXIF_INTEROPE_IMAGE_HEIGHT = 4098,
    EXIF_INTEROPE_EOT = 65535
} ;
#line 127
enum EXIF_LOCATION_CODE {
    EXIF_LOCATION_CONTINENT = 4096,
    EXIF_LOCATION_COUNTRY = 4097,
    EXIF_LOCATION_COUNTRY_OTHER = 4098,
    EXIF_LOCATION_REGION = 4099,
    EXIF_LOCATION_AREA = 4100,
    EXIF_LOCATION_SUB_AREA = 4101,
    EXIF_LOCATION_PLACE = 4102,
    EXIF_LOCATION_PLACE_AREA = 4103,
    EXIF_LOCATION_LOCATION = 4104,
    EXIF_LOCATION_ADDRESS = 4105,
    EXIF_LOCATION_POSTAL_CODE = 4106,
    EXIF_LOCATION_DESCRIPTION = 4107,
    EXIF_LOCATION_EOT = 65535
} ;
#line 145
enum EXIF_CANON_CODE {
    EXIF_CANON_MAKER_NOTE_UNKNOWN1 = 0,
    EXIF_CANON_MAKER_NOTE_UNKNOWN2 = 1,
    EXIF_CANON_MAKER_NOTE_UNKNOWN3 = 2,
    EXIF_CANON_MAKER_NOTE_UNKNOWN4 = 3,
    EXIF_CANON_MAKER_NOTE_UNKNOWN5 = 4,
    EXIF_CANON_MAKER_NOTE_IMAGE_TYPE = 6,
    EXIF_CANON_MAKER_NOTE_FIRMWARE_VERSION = 7,
    EXIF_CANON_MAKER_NOTE_IMAGE_NUMBER = 8,
    EXIF_CANON_MAKER_NOTE_OWNER_NAME = 9,
    EXIF_CANON_MAKER_NOTE_UNKNOWN6 = 16,
    EXIF_CANON_EOT = 65535
} ;
#line 161
enum EXIF_FUJI_CODE {
    EXIF_FUJI_MAKER_NOTE_VERSION = 0,
    EXIF_FUJI_MAKER_NOTE_QUALITY = 4096,
    EXIF_FUJI_MAKER_NOTE_SHARPNESS = 4097,
    EXIF_FUJI_MAKER_NOTE_WHITE_BALANCE = 4098,
    EXIF_FUJI_MAKER_NOTE_FLASH_MODE = 4112,
    EXIF_FUJI_MAKER_NOTE_FLASH_STRENGTH = 4113,
    EXIF_FUJI_MAKER_NOTE_MACRO = 4128,
    EXIF_FUJI_MAKER_NOTE_FOCUS_MODE = 4129,
    EXIF_FUJI_MAKER_NOTE_SLOW_SYNC = 4144,
    EXIF_FUJI_MAKER_NOTE_PICTURE_MODE = 4145,
    EXIF_FUJI_MAKER_NOTE_CONT_TAKE_BRACKET = 4352,
    EXIF_FUJI_MAKER_NOTE_UNKNOWN = 4608,
    EXIF_FUJI_MAKER_NOTE_BLUR_WARNING = 4864,
    EXIF_FUJI_MAKER_NOTE_FOCUS_WARNING = 4865,
    EXIF_FUJI_MAKER_NOTE_AE_WARNING = 4866,
    EXIF_FUJI_EOT = 65535
} ;
#line 182
enum EXIF_NIKON_CODE {
    EXIF_NIKON_MAKER_NOTE_UNKNOWN1 = 2,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN2 = 3,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN3 = 4,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN4 = 5,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN5 = 6,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN6 = 7,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN7 = 8,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN8 = 9,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN9 = 10,
    EXIF_NIKON_MAKER_NOTE_UNKNOWN10 = 11,
    EXIF_NIKON_MAKER_NOTE_DATA_DUMP = 3840,
    EXIF_NIKON_EOT = 65535
} ;
#line 199
enum EXIF_SANYO_CODE {
    EXIF_SANYO_MAKER_NOTE_START_OFFSET = 255,
    EXIF_SANYO_MAKER_NOTE_JPEG_THUMBNAIL = 256,
    EXIF_SANYO_MAKER_NOTE_SPECIAL_MODE = 512,
    EXIF_SANYO_MAKER_NOTE_JPEQ_QUALITY = 513,
    EXIF_SANYO_MAKER_NOTE_MACRO = 514,
    EXIF_SANYO_MAKER_NOTE_UNKNOWN1 = 515,
    EXIF_SANYO_MAKER_NOTE_DIGITAL_ZOOM1 = 516,
    EXIF_SANYO_MAKER_NOTE_UNKNOWN2 = 517,
    EXIF_SANYO_MAKER_NOTE_UNKNOWN3 = 518,
    EXIF_SANYO_MAKER_NOTE_SOFTWARE_RELEASE = 519,
    EXIF_SANYO_MAKER_NOTE_PICT_INFO = 520,
    EXIF_SANYO_MAKER_NOTE_CAMERA_ID = 521,
    EXIF_SANYO_MAKER_NOTE_SEQUENTIAL_SHOT_METHOD = 526,
    EXIF_SANYO_MAKER_NOTE_WIDE_RANGE = 527,
    EXIF_SANYO_MAKER_NOTE_COLOUR_ADJUSTMENT_MODE = 528,
    EXIF_SANYO_MAKER_NOTE_QUICK_SHOT = 531,
    EXIF_SANYO_MAKER_NOTE_SELF_TIMER = 532,
    EXIF_SANYO_MAKER_NOTE_VOICE_MEMO = 534,
    EXIF_SANYO_MAKER_NOTE_RECORD_SHUTTER_RELEASE = 535,
    EXIF_SANYO_MAKER_NOTE_FLICKER_REDUCE = 536,
    EXIF_SANYO_MAKER_NOTE_OPTICAL_ZOOM = 537,
    EXIF_SANYO_MAKER_NOTE_DIGITAL_ZOOM2 = 539,
    EXIF_SANYO_MAKER_NOTE_LIGHT_SOURCE_SPECIAL = 541,
    EXIF_SANYO_MAKER_NOTE_RESAVED = 542,
    EXIF_SANYO_MAKER_NOTE_SCENE_SELECT = 543,
    EXIF_SANYO_MAKER_NOTE_MANUAL_FOCAL_DISTANCE = 547,
    EXIF_SANYO_MAKER_NOTE_SEQUENTIAL_SHOT_INTERVAL = 548,
    EXIF_SANYO_MAKER_NOTE_FLASH_MODE = 549,
    EXIF_SANYO_MAKER_NOTE_PRINTIM_FLAGS = 3584,
    EXIF_SANYO_MAKER_NOTE_DATA_DUMP = 3840,
    EXIF_SANYO_EOT = 65535
} ;
#line 235 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_ifd_field {
   enum TIFF_TYPE tag ;
   enum EXIF_IFD_CODE format ;
   int components ;
   char *entry ;
};
#line 243 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_interope_field {
   enum TIFF_TYPE tag ;
   enum EXIF_INTEROPE_CODE format ;
   int components ;
   char *entry ;
};
#line 251 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_location_field {
   enum TIFF_TYPE tag ;
   enum EXIF_LOCATION_CODE format ;
   int components ;
   char *entry ;
};
#line 259 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_canon_field {
   enum TIFF_TYPE tag ;
   enum EXIF_CANON_CODE format ;
   int components ;
   char *entry ;
};
#line 267 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_fuji_field {
   enum TIFF_TYPE tag ;
   enum EXIF_FUJI_CODE format ;
   int components ;
   char *entry ;
};
#line 275 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_nikon_field {
   enum TIFF_TYPE tag ;
   enum EXIF_NIKON_CODE format ;
   int components ;
   char *entry ;
};
#line 283 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
struct exif_sanyo_field {
   enum TIFF_TYPE tag ;
   enum EXIF_SANYO_CODE format ;
   int components ;
   char *entry ;
};
#line 194 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
enum SEVERITY {
    SEV_FATAL_ERROR = 0,
    SEV_ERROR = 1,
    SEV_WARNING = 2,
    SEV_INFO = 3,
    SEV_DEBUG = 4
} ;
#line 9 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
enum IPTC_CODE {
    IPTC_MODEL_VERSION = 256,
    IPTC_DESTINATION = 261,
    IPTC_FILE_FORMAT = 276,
    IPTC_FILE_FORMAT_VERSION = 278,
    IPTC_SERVICE_ID = 286,
    IPTC_ENVELOPE_NUMBER = 296,
    IPTC_PRODUCT_ID = 306,
    IPTC_ENVELOPE_PRIORITY = 316,
    IPTC_DATE_SENT = 326,
    IPTC_TIME_SENT = 336,
    IPTC_CODED_CHARACTER_SET = 346,
    IPTC_UNO = 356,
    IPTC_ARM_ID = 376,
    IPTC_ARM_VERSION = 378,
    IPTC_APP_RECORD_VERSION = 512,
    IPTC_APP_OBJECT_TYPE_REFERENCE = 515,
    IPTC_APP_OBJECT_ATTRIBUTE_REFERENCE = 516,
    IPTC_APP_OBJECT_NAME = 517,
    IPTC_APP_EDIT_STATUS = 519,
    IPTC_APP_EDITORIAL_UPDATE = 520,
    IPTC_APP_URGENCY = 522,
    IPTC_APP_SUBJECT_REFERENCE = 524,
    IPTC_APP_CATEGORY = 527,
    IPTC_APP_CATEGORY_DESCRIPTION = 528,
    IPTC_APP_SUPPLEMENTAL_CATEGORY = 532,
    IPTC_APP_CATEGORY_CODE = 533,
    IPTC_APP_FIXTURE_IDENTIFIER = 534,
    IPTC_APP_NUM = 535,
    IPTC_APP_KEYWORDS = 537,
    IPTC_APP_CONTENT_LOCATION_CODE = 538,
    IPTC_APP_CONTENT_LOCATION_NAME = 539,
    IPTC_APP_RELEASE_DATE = 542,
    IPTC_APP_RELEASE_TIME = 547,
    IPTC_APP_EXPIRATION_DATE = 549,
    IPTC_APP_EXPIRATION_TIME = 550,
    IPTC_APP_SPECIAL_INSTRUCTIONS = 552,
    IPTC_APP_ACTION_ADVISED = 554,
    IPTC_APP_REFERENCE_SERVICE = 557,
    IPTC_APP_REFERENCE_DATE = 559,
    IPTC_APP_REFERENCE_NUMBER = 562,
    IPTC_APP_DATE_CREATED = 567,
    IPTC_APP_ARCHIVE_DATE = 568,
    IPTC_APP_TIME_CREATED = 572,
    IPTC_APP_DIGITAL_CREATION_DATE = 574,
    IPTC_APP_DIGITAL_CREATION_TIME = 575,
    IPTC_APP_ORIGINATING_PROGRAM = 577,
    IPTC_APP_PROGRAM_VERSION = 582,
    IPTC_APP_OBJECT_CYCLE = 587,
    IPTC_APP_BYLINE = 592,
    IPTC_APP_BYLINE_TITLE = 597,
    IPTC_APP_TITLE_ORIGINAL = 598,
    IPTC_APP_PRODUCTOR = 599,
    IPTC_APP_ACTOR = 600,
    IPTC_APP_CITY = 602,
    IPTC_APP_SUBLOCATION = 604,
    IPTC_APP_PROVINCE_STATE = 607,
    IPTC_APP_COUNTRY_CODE = 612,
    IPTC_APP_COUNTRY = 613,
    IPTC_APP_ORIGINAL_TRANSMISSION_REFERENCE = 615,
    IPTC_APP_HEADLINE = 617,
    IPTC_APP_CREDIT = 622,
    IPTC_APP_PHOTOGRAPHER_NUMBER = 624,
    IPTC_APP_SOURCE = 627,
    IPTC_APP_COPYRIGHT_NOTICE = 628,
    IPTC_APP_CONTACT = 630,
    IPTC_APP_CAPTION_ABSTRACT = 632,
    IPTC_APP_PHOTOGRAPH_NUMBER = 633,
    IPTC_APP_WRITER_EDITOR = 634,
    IPTC_APP_SERIAL_NUMBER = 635,
    IPTC_APP_RASTERIZED_CAPTION = 637,
    IPTC_APP_IMAGE_TYPE = 642,
    IPTC_APP_IMAGE_ORIENTATION = 643,
    IPTC_APP_REFERENCE = 645,
    IPTC_APP_LANGUAGE_IDENTIFIER = 647,
    IPTC_APP_AUDIO_TYPE = 662,
    IPTC_APP_AUDIO_SAMPLING_RATE = 663,
    IPTC_APP_AUDIO_SAMPLING_RESOLUTION = 664,
    IPTC_APP_AUDIO_DURATION = 665,
    IPTC_APP_AUDIO_OUTCUE = 666,
    IPTC_APP_OBJECTDATA_PREVIEW_FILE_FORMAT = 712,
    IPTC_APP_OBJECTDATA_PREVIEW_FILE_FORMAT_VERSION = 713,
    IPTC_APP_OBJECTDATA_PREVIEW_PREVIEW_DATA = 714,
    IPTC_NP_RECORD_VERSION = 768,
    IPTC_NP_PICTURE_NUMBER = 778,
    IPTC_NP_PIXELS_PER_LINE = 788,
    IPTC_NP_NUMBER_OF_LINES = 798,
    IPTC_NP_PIXEL_SIZE_IN_SCANNING_DIRECTION = 808,
    IPTC_NP_PIXEL_SIZE_PERPENDICULAR_TO_SCANNING_DIRECTION = 818,
    IPTC_NP_SUPPLEMENTARY_TYPE = 823,
    IPTC_NP_COLOUR_REPRESENTATION = 828,
    IPTC_NP_INTERCHANGE_COLOUR_SPACE = 832,
    IPTC_NP_COLOUR_SEQUENCE = 833,
    IPTC_NP_ICC_INPUT_COLOUR_PROFILE = 834,
    IPTC_NP_COLOUR_CALIBRATION_MATRIX_TABLE = 838,
    IPTC_NP_LOOKUP_TABLE = 848,
    IPTC_NP_NUMBER_OF_INDEX_ENTRIES = 852,
    IPTC_NP_COLOUR_PALETTE = 853,
    IPTC_NP_NUMBER_OF_BITS_PER_SAMPLE = 854,
    IPTC_NP_SAMPLING_STRUCTURE = 858,
    IPTC_NP_SCANNING_DIRECTION = 868,
    IPTC_NP_IMAGE_ROTATION = 870,
    IPTC_NP_DATA_COMPRESSION_METHOD = 878,
    IPTC_NP_QUANTISATION_METHOD = 888,
    IPTC_NP_END_POINTS = 893,
    IPTC_NP_EXCURSION_TOLERANCE = 898,
    IPTC_NP_BITS_PER_COMPONENT = 903,
    IPTC_NP_MAXIMUM_DENSITY_RANGE = 908,
    IPTC_NP_GAMMA_COMPENSATED_VALUE = 913,
    IPTC_PRODD_SIZE_MODE = 1802,
    IPTC_PRODD_MAX_SUBFILE_SIZE = 1812,
    IPTC_PRODD_OBJECTDATA_SIZE_ANNOUNCED = 1882,
    IPTC_PRODD_MAXIMAL_OBJECTDATA_SIZE = 1887,
    IPTC_ODD_SUBFILE = 2058,
    IPTC_POODD_CONFIRMED_OBJECT_SIZE = 2314,
    IPTC_EOT = 65535
} ;
#line 137
enum IPTC_DATASET_FORMAT {
    IPTC_DATASET_UNKNOWN = 0,
    IPTC_DATASET_NUMERICAL = 1,
    IPTC_DATASET_BINARY = 2,
    IPTC_DATASET_TEXT = 3,
    IPTC_DATASET_SPECIFIC = 4,
    IPTC_DATASET_DATE = 5,
    IPTC_DATASET_TIME = 6,
    IPTC_DATASET_EOT = 7
} ;
#line 151
enum IPTC_DATASET_UNICITY {
    IPTC_DATASET_REPEATABLE = 0,
    IPTC_DATASET_UNIQUE = 1
} ;
#line 157
enum IPTC_DATASET_SIZE {
    IPTC_DATASET_MAX = 0,
    IPTC_DATASET_FIXED = 1
} ;
#line 163 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
struct iptc_code_descr {
   enum IPTC_CODE code ;
   enum IPTC_DATASET_FORMAT format ;
   enum IPTC_DATASET_UNICITY repeatable ;
   enum IPTC_DATASET_SIZE fixed_length ;
   long length ;
   char *label ;
};
#line 173
enum iptc_filter_element_type {
    IPTC_FET_VALUE = 0,
    IPTC_FET_RANGE = 1
} ;
#line 179 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
struct iptc_filter_match_data {
   enum iptc_filter_element_type type ;
   unsigned short code ;
   unsigned short code2 ;
};
#line 186 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
struct iptc_edit_data {
   bool enabled ;
   unsigned short code ;
   size_t length ;
   unsigned char *data ;
};
#line 194 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
struct iptc_edit_list_cell {
   struct iptc_edit_data *edit_data ;
   struct iptc_edit_list_cell *next ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 234 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
struct op_label {
   enum OP op ;
   char *label ;
   char *description ;
};
#line 247 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
struct log_level_descr {
   enum LOG_LEVEL level ;
   char *description ;
};
#line 302
enum EXIT_CODE {
    EXIT_CODE_NORMAL = 0,
    EXIT_CODE_USAGE_ERROR = 1,
    EXIT_CODE_ASYNCHRONOUS_SIGNAL = 2,
    EXIT_CODE_NORMAL_WITH_WARNINGS = 3,
    EXIT_CODE_NORMAL_WITH_ERRORS = 4,
    EXIT_CODE_FATAL_ERROR = 5,
    EXIT_EOT = 6
} ;
#line 320 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
struct exit_code_label {
   enum EXIT_CODE code ;
   char *label ;
};
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.h"
enum JFIF_MARKER {
    JFIF_SOF0 = 192,
    JFIF_SOF1 = 193,
    JFIF_SOF2 = 194,
    JFIF_SOF3 = 195,
    JFIF_SOF5 = 197,
    JFIF_SOF6 = 198,
    JFIF_SOF7 = 199,
    JFIF_JPG = 200,
    JFIF_SOF9 = 201,
    JFIF_SOF10 = 202,
    JFIF_SOF11 = 203,
    JFIF_SOF13 = 205,
    JFIF_SOF14 = 206,
    JFIF_SOF15 = 207,
    JFIF_DHT = 196,
    JFIF_DAC = 204,
    JFIF_RST0 = 208,
    JFIF_RST1 = 209,
    JFIF_RST2 = 210,
    JFIF_RST3 = 211,
    JFIF_RST4 = 212,
    JFIF_RST5 = 213,
    JFIF_RST6 = 214,
    JFIF_RST7 = 215,
    JFIF_SOI = 216,
    JFIF_EOI = 217,
    JFIF_SOS = 218,
    JFIF_DQT = 219,
    JFIF_DNL = 220,
    JFIF_DRI = 221,
    JFIF_DHP = 222,
    JFIF_EXP = 223,
    JFIF_APP0 = 224,
    JFIF_APP1 = 225,
    JFIF_APP2 = 226,
    JFIF_APP3 = 227,
    JFIF_APP4 = 228,
    JFIF_APP5 = 229,
    JFIF_APP6 = 230,
    JFIF_APP7 = 231,
    JFIF_APP8 = 232,
    JFIF_APP9 = 233,
    JFIF_APP10 = 234,
    JFIF_APP11 = 235,
    JFIF_APP12 = 236,
    JFIF_APP13 = 237,
    JFIF_APP14 = 238,
    JFIF_APP15 = 239,
    JFIF_JPG0 = 240,
    JFIF_JPG1 = 241,
    JFIF_JPG2 = 242,
    JFIF_JPG3 = 243,
    JFIF_JPG4 = 244,
    JFIF_JPG5 = 245,
    JFIF_JPG6 = 246,
    JFIF_JPG7 = 247,
    JFIF_JPG8 = 248,
    JFIF_JPG9 = 249,
    JFIF_JPG10 = 250,
    JFIF_JPG11 = 251,
    JFIF_JPG12 = 252,
    JFIF_JPG13 = 253,
    JFIF_COM = 254,
    JFIF_TEM = 1,
    JFIF_MARKER_EOT = 0
} ;
#line 92 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.h"
struct jfif_marker_descr {
   unsigned char tag ;
   char *name ;
   char *label ;
};
#line 99 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.h"
struct jfif_marker_range_descr {
   unsigned char lower_boundary ;
   unsigned char upper_boundary ;
   char *name ;
   char *label ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 221 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
enum FILTER_EDIT_VALUE_TYPE {
    FEV_NONE = 0,
    FEV_HEX = 1,
    FEV_TEXT = 2
} ;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.h"
enum ADOBE_RESOURCE {
    ADOBE_RSC_RASTER_INFO = 1000,
    ADOBE_RSC_MACINTOSH_PRINT_INFO = 1001,
    ADOBE_RSC_INDEXED_COLOR_TABLE = 1003,
    ADOBE_RSC_RESOLUTION = 1005,
    ADOBE_RSC_ALPHA_CHANNEL_NAMES = 1006,
    ADOBE_RSC_DISPLAY = 1007,
    ADOBE_RSC_CAPTION = 1008,
    ADOBE_RSC_BORDER_STYLE = 1009,
    ADOBE_RSC_BACRKGROUND_COLOR = 1010,
    ADOBE_RSC_PRINT_FLAGS = 1011,
    ADOBE_RSC_GRAYSCALE_MULTICHANNEL_HALFTONING = 1012,
    ADOBE_RSC_COLOR_HALFTONING = 1013,
    ADOBE_RSC_DUOTONE_HALFTONING = 1014,
    ADOBE_RSC_GRAYSCALE_MULTICHANNEL_TRANSFER = 1015,
    ADOBE_RSC_COLOR_TRANSFER = 1016,
    ADOBE_RSC_DUOTONE_TRANSFER = 1017,
    ADOBE_RSC_DUOTONE_IMAGE = 1018,
    ADOBE_RSC_BW_VALUES = 1019,
    ADOBE_RSC_OBSOLETE1 = 1020,
    ADOBE_RSC_EPS_OPTIONS = 1021,
    ADOBE_RSC_QUICK_MASK = 1022,
    ADOBE_RSC_OBSOLETE2 = 1023,
    ADOBE_RSC_LAYER_STATE = 1024,
    ADOBE_RSC_WORKING_PATH = 1025,
    ADOBE_RSC_LAYER_GROUP = 1026,
    ADOBE_RSC_OBSOLETE3 = 1027,
    ADOBE_RSC_IPTC_FILE_INFO = 1028,
    ADOBE_RSC_IMAGE_MODE = 1029,
    ADOBE_RSC_JPEG_QUALITY = 1030,
    ADOBE_RSC_GRID_GUIDES_INFO = 1032,
    ADOBE_RSC_THUMBNAIL_RESOURCE1 = 1033,
    ADOBE_RSC_COPYRIGHT_FLAG = 1034,
    ADOBE_RSC_UNIFORM_RESOURCE_LOCATOR = 1035,
    ADOBE_RSC_THUMBNAIL_RESOURCE2 = 1036,
    ADOBE_RSC_GLOBAL_ANGLE = 1037,
    ADOBE_RSC_COLOR_SAMPLERS_RESOURCE1 = 1038,
    ADOBE_RSC_ICC_PROFILE = 1039,
    ADOBE_RSC_WATERMARK = 1040,
    ADOBE_RSC_ICC_UNTAGGER = 1041,
    ADOBE_RSC_EFFECTS_VISIBLE = 1042,
    ADOBE_RSC_SPOT_HALFTONE = 1043,
    ADOBE_RSC_DOCUMENT_SPECIFIC_IDS = 1044,
    ADOBE_RSC_UNICODE_ALPHA_NAMES = 1045,
    ADOBE_RSC_INDEXED_COLOR_TABLE_COUNT = 1046,
    ADOBE_RSC_TRANSPARENT_INDEX = 1047,
    ADOBE_RSC_GLOBAL_ALTITUDE = 1049,
    ADOBE_RSC_SLICES = 1050,
    ADOBE_RSC_WORKFLOW_URL = 1051,
    ADOBE_RSC_XPEP_JUMP = 1052,
    ADOBE_RSC_ALPHA_IDENTIFIERS = 1053,
    ADOBE_RSC_URL_LIST = 1054,
    ADOBE_RSC_VERSION_INFO = 1057,
    ADOBE_RSC_CLIPPING_PATH = 2999,
    ADOBE_RSC_PRINT_FLAGS_INFO = 10000,
    ADOBE_RSC_EOT = 65535
} ;
#line 73 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.h"
struct adobe_resource_descr {
   unsigned short resource ;
   char *label ;
};
#line 79 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.h"
struct adobe_resource_range_descr {
   unsigned short lower_boundary ;
   unsigned short upper_boundary ;
   char *label ;
};
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
unsigned short getrawword(unsigned char *ptr , unsigned long offset ) ;
#line 349
unsigned long getlong(unsigned char *ptr , unsigned long offset ) ;
#line 350
unsigned long getrawlong(unsigned char *ptr , unsigned long offset ) ;
#line 352
unsigned char *getraw(unsigned char *ptr , unsigned long offset , unsigned char *buf ,
                      unsigned long const   len ) ;
#line 363
void fatal_error(char *format  , ...) ;
#line 364
void error(char *format  , ...) ;
#line 365
void warning(char *format  , ...) ;
#line 366
void info(char *format  , ...) ;
#line 367
void debug(char *format  , ...) ;
#line 381
size_t dump_rewrite(unsigned char *buffer , unsigned long length ) ;
#line 292 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.h"
void exif_parse(unsigned char *buffer , unsigned int const   bytes_left , struct parser_result *result ) ;
#line 293
struct exif_ifd_field *exif_match_tag(int const   tag ) ;
#line 294
void exif_dump_list(void) ;
#line 295
unsigned int get_ifd_type_size(enum TIFF_TYPE  const  type ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 6 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct prefs_struct prefs ;
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct tiff_ifd_type_size tiff_ifd_type_sizes[13]  = 
#line 13
  {      {(enum TIFF_TYPE )1, 1U}, 
        {(enum TIFF_TYPE )2, 1U}, 
        {(enum TIFF_TYPE )3, 2U}, 
        {(enum TIFF_TYPE )4, 4U}, 
        {(enum TIFF_TYPE )5, 8U}, 
        {(enum TIFF_TYPE )6, 1U}, 
        {(enum TIFF_TYPE )7, 8U}, 
        {(enum TIFF_TYPE )8, 2U}, 
        {(enum TIFF_TYPE )9, 4U}, 
        {(enum TIFF_TYPE )10, 8U}, 
        {(enum TIFF_TYPE )11, 4U}, 
        {(enum TIFF_TYPE )12, 8U}, 
        {(enum TIFF_TYPE )-1, 0U}};
#line 32 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_ifd_field exif_ifd_fields[57]  = 
#line 32
  {      {(enum TIFF_TYPE )256, (enum EXIF_IFD_CODE )4, 1, (char *)"image width"}, 
        {(enum TIFF_TYPE )257, (enum EXIF_IFD_CODE )4, 1, (char *)"image height"}, 
        {(enum TIFF_TYPE )258, (enum EXIF_IFD_CODE )3, 3, (char *)"bits per sample"}, 
        {(enum TIFF_TYPE )259,
      (enum EXIF_IFD_CODE )3, 1, (char *)"compression"}, 
        {(enum TIFF_TYPE )262, (enum EXIF_IFD_CODE )3, 1, (char *)"photometric interpretation"}, 
        {(enum TIFF_TYPE )270,
      (enum EXIF_IFD_CODE )2, 20, (char *)"image description"}, 
        {(enum TIFF_TYPE )271, (enum EXIF_IFD_CODE )2, 6, (char *)"make"}, 
        {(enum TIFF_TYPE )272, (enum EXIF_IFD_CODE )2, 20, (char *)"model"}, 
        {(enum TIFF_TYPE )273, (enum EXIF_IFD_CODE )4, 1, (char *)"strip offsets"}, 
        {(enum TIFF_TYPE )274, (enum EXIF_IFD_CODE )3, 1, (char *)"orientation"}, 
        {(enum TIFF_TYPE )277, (enum EXIF_IFD_CODE )3, 1, (char *)"samples per pixel"}, 
        {(enum TIFF_TYPE )278,
      (enum EXIF_IFD_CODE )4, 1, (char *)"rows per strip"}, 
        {(enum TIFF_TYPE )279, (enum EXIF_IFD_CODE )4, 1, (char *)"strip byte count"}, 
        {(enum TIFF_TYPE )282,
      (enum EXIF_IFD_CODE )5, 1, (char *)"x resolution"}, 
        {(enum TIFF_TYPE )283, (enum EXIF_IFD_CODE )5, 1, (char *)"y resolution"}, 
        {(enum TIFF_TYPE )296, (enum EXIF_IFD_CODE )3, 1, (char *)"resolution unit"}, 
        {(enum TIFF_TYPE )305,
      (enum EXIF_IFD_CODE )2, 23, (char *)"software"}, 
        {(enum TIFF_TYPE )306, (enum EXIF_IFD_CODE )2, 20, (char *)"date/time"}, 
        {(enum TIFF_TYPE )513, (enum EXIF_IFD_CODE )4, 1, (char *)"JPEG IF offset"}, 
        {(enum TIFF_TYPE )514, (enum EXIF_IFD_CODE )4, 1, (char *)"JPEG IF byte count"}, 
        {(enum TIFF_TYPE )531,
      (enum EXIF_IFD_CODE )3, 1, (char *)"YCbCr positioning"}, 
        {(enum TIFF_TYPE )33434, (enum EXIF_IFD_CODE )5, 1, (char *)"exposure time"}, 
        {(enum TIFF_TYPE )33437,
      (enum EXIF_IFD_CODE )5, 1, (char *)"F number"}, 
        {(enum TIFF_TYPE )34665, (enum EXIF_IFD_CODE )4, 1, (char *)"EXIF offset"}, 
        {(enum TIFF_TYPE )34695, (enum EXIF_IFD_CODE )5, 0, (char *)"location offset"}, 
        {(enum TIFF_TYPE )34850,
      (enum EXIF_IFD_CODE )3, 1, (char *)"exposure program"}, 
        {(enum TIFF_TYPE )34855, (enum EXIF_IFD_CODE )3, 1, (char *)"ISO speed ratings"}, 
        {(enum TIFF_TYPE )36864,
      (enum EXIF_IFD_CODE )7, 4, (char *)"EXIF version"}, 
        {(enum TIFF_TYPE )36867, (enum EXIF_IFD_CODE )2, 20, (char *)"original date/time"}, 
        {(enum TIFF_TYPE )36868,
      (enum EXIF_IFD_CODE )2, 20, (char *)"digitized date/time"}, 
        {(enum TIFF_TYPE )37121, (enum EXIF_IFD_CODE )7, 4, (char *)"component configuration"}, 
        {(enum TIFF_TYPE )37122,
      (enum EXIF_IFD_CODE )5, 1, (char *)"compression bits/pixel"}, 
        {(enum TIFF_TYPE )37377, (enum EXIF_IFD_CODE )10, 1, (char *)"shutter speed"}, 
        {(enum TIFF_TYPE )37378,
      (enum EXIF_IFD_CODE )5, 1, (char *)"aperture"}, 
        {(enum TIFF_TYPE )37379, (enum EXIF_IFD_CODE )10, 1, (char *)"brightness"}, 
        {(enum TIFF_TYPE )37380, (enum EXIF_IFD_CODE )10, 1, (char *)"exposure bias"}, 
        {(enum TIFF_TYPE )37381,
      (enum EXIF_IFD_CODE )5, 1, (char *)"max aperture"}, 
        {(enum TIFF_TYPE )37382, (enum EXIF_IFD_CODE )5, 1, (char *)"subject distance"}, 
        {(enum TIFF_TYPE )37383,
      (enum EXIF_IFD_CODE )3, 1, (char *)"metering mode"}, 
        {(enum TIFF_TYPE )37384, (enum EXIF_IFD_CODE )3, 1, (char *)"light source"}, 
        {(enum TIFF_TYPE )37385, (enum EXIF_IFD_CODE )3, 1, (char *)"flash"}, 
        {(enum TIFF_TYPE )37386, (enum EXIF_IFD_CODE )5, 1, (char *)"focal length"}, 
        {(enum TIFF_TYPE )37500, (enum EXIF_IFD_CODE )7, -1, (char *)"maker note"}, 
        {(enum TIFF_TYPE )37510, (enum EXIF_IFD_CODE )7, -1, (char *)"user comment"}, 
        {(enum TIFF_TYPE )40960,
      (enum EXIF_IFD_CODE )7, 4, (char *)"flash pix version"}, 
        {(enum TIFF_TYPE )40961, (enum EXIF_IFD_CODE )3, 1, (char *)"color space"}, 
        {(enum TIFF_TYPE )256, (enum EXIF_IFD_CODE )4, 1, (char *)"EXIF image width"}, 
        {(enum TIFF_TYPE )257,
      (enum EXIF_IFD_CODE )4, 1, (char *)"EXIF image height"}, 
        {(enum TIFF_TYPE )40964, (enum EXIF_IFD_CODE )5, 0, (char *)"sound file"}, 
        {(enum TIFF_TYPE )40965, (enum EXIF_IFD_CODE )4, 1, (char *)"EXIF interoperability offset"}, 
        {(enum TIFF_TYPE )41486,
      (enum EXIF_IFD_CODE )5, 1, (char *)"focal plane x resolution"}, 
        {(enum TIFF_TYPE )41487, (enum EXIF_IFD_CODE )5, 1, (char *)"focal plane y resolution"}, 
        {(enum TIFF_TYPE )41488,
      (enum EXIF_IFD_CODE )3, 1, (char *)"focal plane res unit"}, 
        {(enum TIFF_TYPE )41495, (enum EXIF_IFD_CODE )3, 2, (char *)"sensing method"}, 
        {(enum TIFF_TYPE )41728,
      (enum EXIF_IFD_CODE )7, 1, (char *)"file source"}, 
        {(enum TIFF_TYPE )41729, (enum EXIF_IFD_CODE )7, 1, (char *)"scene type"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_IFD_CODE )7, 0, (char *)((void *)0)}};
#line 98 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_interope_field exif_interope_fields[5]  = {      {(enum TIFF_TYPE )1, (enum EXIF_INTEROPE_CODE )2, 4, (char *)"index"}, 
        {(enum TIFF_TYPE )2, (enum EXIF_INTEROPE_CODE )7, 4, (char *)"version"}, 
        {(enum TIFF_TYPE )4097, (enum EXIF_INTEROPE_CODE )3, 1, (char *)"image width"}, 
        {(enum TIFF_TYPE )4098,
      (enum EXIF_INTEROPE_CODE )3, 1, (char *)"image height"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_INTEROPE_CODE )7, 0, (char *)((void *)0)}};
#line 108 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_location_field exif_location_fields[13]  = 
#line 108
  {      {(enum TIFF_TYPE )4096, (enum EXIF_LOCATION_CODE )2, -1, (char *)"continent"}, 
        {(enum TIFF_TYPE )4097,
      (enum EXIF_LOCATION_CODE )2, 2, (char *)"country (ISO 3166)"}, 
        {(enum TIFF_TYPE )4098, (enum EXIF_LOCATION_CODE )2, -1, (char *)"country/other"}, 
        {(enum TIFF_TYPE )4099,
      (enum EXIF_LOCATION_CODE )2, -1, (char *)"region"}, 
        {(enum TIFF_TYPE )4100, (enum EXIF_LOCATION_CODE )2, -1, (char *)"area"}, 
        {(enum TIFF_TYPE )4101, (enum EXIF_LOCATION_CODE )2, -1, (char *)"sub-area"}, 
        {(enum TIFF_TYPE )4102,
      (enum EXIF_LOCATION_CODE )2, -1, (char *)"place"}, 
        {(enum TIFF_TYPE )4103, (enum EXIF_LOCATION_CODE )2, -1, (char *)"place area"}, 
        {(enum TIFF_TYPE )4104,
      (enum EXIF_LOCATION_CODE )2, -1, (char *)"location"}, 
        {(enum TIFF_TYPE )4105, (enum EXIF_LOCATION_CODE )2, -1, (char *)"address"}, 
        {(enum TIFF_TYPE )4106, (enum EXIF_LOCATION_CODE )2, -1, (char *)"postal code"}, 
        {(enum TIFF_TYPE )4107,
      (enum EXIF_LOCATION_CODE )2, -1, (char *)"description"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_LOCATION_CODE )7, 0, (char *)((void *)0)}};
#line 126 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_canon_field exif_canon_fields[11]  = 
#line 126
  {      {(enum TIFF_TYPE )0, (enum EXIF_CANON_CODE )3, 6, (char *)"unknown1"}, 
        {(enum TIFF_TYPE )1, (enum EXIF_CANON_CODE )3, 19, (char *)"unknown2"}, 
        {(enum TIFF_TYPE )2, (enum EXIF_CANON_CODE )3, 4, (char *)"unknown3"}, 
        {(enum TIFF_TYPE )3, (enum EXIF_CANON_CODE )3, 4, (char *)"unknown4"}, 
        {(enum TIFF_TYPE )4, (enum EXIF_CANON_CODE )3, 15, (char *)"unknown5"}, 
        {(enum TIFF_TYPE )6, (enum EXIF_CANON_CODE )2, 32, (char *)"image type"}, 
        {(enum TIFF_TYPE )7, (enum EXIF_CANON_CODE )2, 24, (char *)"firmware version"}, 
        {(enum TIFF_TYPE )8,
      (enum EXIF_CANON_CODE )4, 1, (char *)"image number"}, 
        {(enum TIFF_TYPE )9, (enum EXIF_CANON_CODE )2, 32, (char *)"owner name"}, 
        {(enum TIFF_TYPE )16, (enum EXIF_CANON_CODE )4, 1, (char *)"unknown6"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_CANON_CODE )7, 0, (char *)((void *)0)}};
#line 142 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_fuji_field exif_fuji_fields[16]  = 
#line 142
  {      {(enum TIFF_TYPE )0, (enum EXIF_FUJI_CODE )7, 4, (char *)"version"}, 
        {(enum TIFF_TYPE )4096, (enum EXIF_FUJI_CODE )2, 8, (char *)"quality"}, 
        {(enum TIFF_TYPE )4097, (enum EXIF_FUJI_CODE )3, 1, (char *)"sharpness"}, 
        {(enum TIFF_TYPE )4098, (enum EXIF_FUJI_CODE )3, 1, (char *)"white balance"}, 
        {(enum TIFF_TYPE )4112,
      (enum EXIF_FUJI_CODE )3, 1, (char *)"flash mode"}, 
        {(enum TIFF_TYPE )4113, (enum EXIF_FUJI_CODE )10, 1, (char *)"flash strength"}, 
        {(enum TIFF_TYPE )4128,
      (enum EXIF_FUJI_CODE )3, 1, (char *)"macro"}, 
        {(enum TIFF_TYPE )4129, (enum EXIF_FUJI_CODE )3, 1, (char *)"focus mode"}, 
        {(enum TIFF_TYPE )4144, (enum EXIF_FUJI_CODE )3, 1, (char *)"slow sync"}, 
        {(enum TIFF_TYPE )4145, (enum EXIF_FUJI_CODE )3, 1, (char *)"picture mode"}, 
        {(enum TIFF_TYPE )4352, (enum EXIF_FUJI_CODE )3, 1, (char *)"contTake/bracket"}, 
        {(enum TIFF_TYPE )4608,
      (enum EXIF_FUJI_CODE )3, 1, (char *)"unknown"}, 
        {(enum TIFF_TYPE )4864, (enum EXIF_FUJI_CODE )3, 1, (char *)"blur warning"}, 
        {(enum TIFF_TYPE )4865, (enum EXIF_FUJI_CODE )3, 1, (char *)"focus warning"}, 
        {(enum TIFF_TYPE )4866,
      (enum EXIF_FUJI_CODE )3, 1, (char *)"ae warning"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_FUJI_CODE )7, 0, (char *)((void *)0)}};
#line 163 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_nikon_field exif_nikon_fields[12]  = 
#line 163
  {      {(enum TIFF_TYPE )2, (enum EXIF_NIKON_CODE )2, 6, (char *)"unknown1"}, 
        {(enum TIFF_TYPE )3, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown2"}, 
        {(enum TIFF_TYPE )4, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown3"}, 
        {(enum TIFF_TYPE )5, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown4"}, 
        {(enum TIFF_TYPE )6, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown5"}, 
        {(enum TIFF_TYPE )7, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown6"}, 
        {(enum TIFF_TYPE )8, (enum EXIF_NIKON_CODE )5, 1, (char *)"unknown7"}, 
        {(enum TIFF_TYPE )9, (enum EXIF_NIKON_CODE )2, 20, (char *)"unknown8"}, 
        {(enum TIFF_TYPE )10, (enum EXIF_NIKON_CODE )5, 1, (char *)"unknown9"}, 
        {(enum TIFF_TYPE )11, (enum EXIF_NIKON_CODE )3, 1, (char *)"unknown10"}, 
        {(enum TIFF_TYPE )3840, (enum EXIF_NIKON_CODE )4, 30, (char *)"data dump"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_NIKON_CODE )7, 0, (char *)((void *)0)}};
#line 180 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_sanyo_field exif_sanyo_fields[31]  = 
#line 180
  {      {(enum TIFF_TYPE )255, (enum EXIF_SANYO_CODE )3, 1, (char *)"makernote start offset"}, 
        {(enum TIFF_TYPE )256,
      (enum EXIF_SANYO_CODE )7, -1, (char *)"JPEG thumbnail data"}, 
        {(enum TIFF_TYPE )512, (enum EXIF_SANYO_CODE )4, 3, (char *)"special mode"}, 
        {(enum TIFF_TYPE )513, (enum EXIF_SANYO_CODE )3, 1, (char *)"JPEG quality"}, 
        {(enum TIFF_TYPE )514, (enum EXIF_SANYO_CODE )3, 1, (char *)"macro"}, 
        {(enum TIFF_TYPE )515, (enum EXIF_SANYO_CODE )3, 1, (char *)"unknown1"}, 
        {(enum TIFF_TYPE )516, (enum EXIF_SANYO_CODE )5, 1, (char *)"digital zoom (1)"}, 
        {(enum TIFF_TYPE )517,
      (enum EXIF_SANYO_CODE )5, 1, (char *)"unknown2"}, 
        {(enum TIFF_TYPE )518, (enum EXIF_SANYO_CODE )3, 6, (char *)"unknown3"}, 
        {(enum TIFF_TYPE )519, (enum EXIF_SANYO_CODE )2, -1, (char *)"software release"}, 
        {(enum TIFF_TYPE )520,
      (enum EXIF_SANYO_CODE )2, -1, (char *)"pict info"}, 
        {(enum TIFF_TYPE )521, (enum EXIF_SANYO_CODE )7, 32, (char *)"camera ID"}, 
        {(enum TIFF_TYPE )526, (enum EXIF_SANYO_CODE )3, 1, (char *)"sequential shot method"}, 
        {(enum TIFF_TYPE )527,
      (enum EXIF_SANYO_CODE )3, 1, (char *)"wide range"}, 
        {(enum TIFF_TYPE )528, (enum EXIF_SANYO_CODE )3, 1, (char *)"colour adjustment mode"}, 
        {(enum TIFF_TYPE )531,
      (enum EXIF_SANYO_CODE )3, 1, (char *)"quick shot"}, 
        {(enum TIFF_TYPE )532, (enum EXIF_SANYO_CODE )3, 1, (char *)"self timer"}, 
        {(enum TIFF_TYPE )534, (enum EXIF_SANYO_CODE )3, 1, (char *)"voice memo"}, 
        {(enum TIFF_TYPE )535, (enum EXIF_SANYO_CODE )3, 1, (char *)"record shutter release"}, 
        {(enum TIFF_TYPE )536,
      (enum EXIF_SANYO_CODE )3, 1, (char *)"flicker reduce"}, 
        {(enum TIFF_TYPE )537, (enum EXIF_SANYO_CODE )3, 1, (char *)"optical zoom"}, 
        {(enum TIFF_TYPE )539, (enum EXIF_SANYO_CODE )3, 1, (char *)"digital zoom (2)"}, 
        {(enum TIFF_TYPE )541,
      (enum EXIF_SANYO_CODE )3, 1, (char *)"light source special"}, 
        {(enum TIFF_TYPE )542, (enum EXIF_SANYO_CODE )3, 1, (char *)"resaved"}, 
        {(enum TIFF_TYPE )543, (enum EXIF_SANYO_CODE )3, 1, (char *)"scene select"}, 
        {(enum TIFF_TYPE )547, (enum EXIF_SANYO_CODE )5, 1, (char *)"manual focal distance"}, 
        {(enum TIFF_TYPE )548,
      (enum EXIF_SANYO_CODE )3, 1, (char *)"sequential shot interval"}, 
        {(enum TIFF_TYPE )549, (enum EXIF_SANYO_CODE )3, 1, (char *)"flash mode"}, 
        {(enum TIFF_TYPE )3584, (enum EXIF_SANYO_CODE )7, -1, (char *)"printIM flags"}, 
        {(enum TIFF_TYPE )3840,
      (enum EXIF_SANYO_CODE )4, -1, (char *)"data dump"}, 
        {(enum TIFF_TYPE )65535, (enum EXIF_SANYO_CODE )7, 0, (char *)((void *)0)}};
#line 217 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
void exif_parse(unsigned char *buffer , unsigned int const   bytes_left , struct parser_result *result ) 
{ 
  unsigned char *ptr ;
  unsigned long written_bytes ;
  unsigned long ifd_max ;
  unsigned short ifd_number ;
  long bytes ;
  bool ret ;
  char exif_marker[5] ;
  bool little_endian ;
  size_t tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned char *base_offset ;
  unsigned long offset ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct tiff_ifd_entry *ifd_entries ;
  unsigned long first_value_offset ;
  unsigned long next_ifd_offset ;
  size_t tmp___4 ;
  unsigned short tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  struct exif_ifd_field *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  unsigned long size ;
  unsigned int tmp___12 ;
  unsigned long gap_size ;
  size_t tmp___13 ;
  int tmp___14 ;
  unsigned char *tmp___15 ;
  int tmp___16 ;

  {
#line 228
  return;
  {
#line 230
  ptr = buffer;
#line 231
  bytes = (long )bytes_left;
#line 232
  written_bytes = 0UL;
#line 233
  ifd_number = (unsigned short)0;
#line 234
  ifd_max = 0UL;
#line 235
  ret = (bool )1;
#line 236
  debug((char *)"Exif parser: %ld byte(s) to parse", bytes);
  }
#line 239
  if (bytes < 15L) {
    {
#line 241
    ret = (bool )0;
#line 242
    error((char *)"Exif parser: chunk underrun (%ld byte(s) remaining, 15 or more expected)",
          bytes);
    }
  } else {
    {
#line 250
    tmp___15 = getraw(ptr, 0UL, (unsigned char *)(exif_marker), (unsigned long const   )6);
#line 250
    tmp___16 = strcmp((char const   *)((char *)tmp___15), "Exif\000\000");
    }
#line 250
    if (tmp___16 != 0) {
      {
#line 253
      ret = (bool )0;
#line 254
      error((char *)"Exif parser: expected marker not matched");
      }
    } else {
#line 260
      if (prefs.rewrite) {
        {
#line 261
        tmp = dump_rewrite(ptr, 6UL);
#line 261
        written_bytes += tmp;
        }
      }
      {
#line 262
      bytes -= 6L;
#line 263
      ptr += 6;
#line 266
      tmp___1 = getlong(ptr, 0UL);
      }
#line 266
      if (tmp___1 == 1296891946UL) {
        {
#line 268
        little_endian = (bool )0;
#line 269
        debug((char *)"Exif parser: TIFF (big endian) marker found");
        }
      } else {
        {
#line 272
        tmp___0 = getlong(ptr, 0UL);
        }
#line 272
        if (tmp___0 == 1229531648UL) {
          {
#line 274
          little_endian = (bool )1;
#line 275
          debug((char *)"Exif parser: TIFF (little endian) marker found");
          }
        } else {
          {
#line 279
          ret = (bool )0;
#line 280
          error((char *)"Exif parser: expected TIFF marker not matched");
          }
        }
      }
#line 283
      if (ret) {
#line 288
        base_offset = ptr;
#line 289
        if (prefs.rewrite) {
          {
#line 290
          tmp___2 = dump_rewrite(ptr, 4UL);
#line 290
          written_bytes += tmp___2;
          }
        }
        {
#line 291
        bytes -= 4L;
#line 292
        ptr += 4;
#line 295
        offset = getrawlong(ptr, 0UL);
        }
#line 296
        if (prefs.rewrite) {
          {
#line 297
          tmp___3 = dump_rewrite(ptr, 4UL);
#line 297
          written_bytes += tmp___3;
          }
        }
        {
#line 298
        bytes -= 4L;
#line 299
        ptr += 4;
#line 300
        debug((char *)"Exif parser: start offset=%lu (0x%08x)", offset, offset);
        }
#line 302
        if (offset < 8UL) {
          {
#line 304
          ret = (bool )0;
#line 305
          error((char *)"Exif parser: unexpected initial IFD%lu offset (got %lu, expected >=8)",
                (int )ifd_number, offset);
          }
        } else {
#line 314
          offset -= 8UL;
#line 315
          if (offset > 0UL) {
            {
#line 317
            warning((char *)"Exif parser: unexpected initial IFD%lu offset (got %lu, expected 8)",
                    (int )ifd_number, offset);
            }
#line 320
            if (prefs.rewrite) {
              {
#line 321
              tmp___4 = dump_rewrite(ptr, 4UL);
#line 321
              written_bytes += tmp___4;
              }
            }
#line 322
            bytes = (long )((unsigned long )bytes - offset);
#line 323
            ptr += offset;
          }
          {
#line 327
          tmp___5 = getrawword(ptr, 0UL);
#line 327
          ifd_max = (unsigned long )tmp___5;
          }
#line 328
          if (prefs.rewrite) {
            {
#line 329
            tmp___6 = dump_rewrite(ptr, 2UL);
#line 329
            written_bytes += tmp___6;
            }
          }
          {
#line 330
          bytes -= 2L;
#line 331
          ptr += 2;
#line 332
          debug((char *)"Exif parser: IFDs=%u (0x%04x)", ifd_max, ifd_max);
          }
#line 334
          if ((long )(ifd_max * 12UL) > bytes) {
            {
#line 335
            error((char *)"Exif parser: IFD entries list size inconsistency (expected %lu*%lu=%lu, size is only %lu)",
                  ifd_max, 12, ifd_max * 12UL, bytes);
            }
          }
#line 341
          if (ifd_max > 0UL) {
            {
#line 343
            tmp___7 = malloc(ifd_max * sizeof(struct tiff_ifd_entry ));
#line 343
            ifd_entries = (struct tiff_ifd_entry *)tmp___7;
            }
#line 344
            if (! ifd_entries) {
              {
#line 345
              fatal_error((char *)"Exif parser: could not allocate space for Exif IFD entries list");
              }
            }
          } else {
#line 348
            ifd_entries = (struct tiff_ifd_entry *)((void *)0);
          }
#line 351
          ifd_number = (unsigned short)0;
          {
#line 352
          while (1) {
            while_continue: /* CIL Label */ ;
#line 352
            if (bytes > 0L) {
#line 352
              if (! ((unsigned long )ifd_number < ifd_max)) {
#line 352
                goto while_break;
              }
            } else {
#line 352
              goto while_break;
            }
#line 354
            if (bytes < 12L) {
              {
#line 356
              ret = (bool )0;
#line 357
              error((char *)"Exif parser: IFD%u entry underrun (%lu byte(s) left, 12 expected)",
                    (int )ifd_number, bytes, 12);
              }
#line 359
              if (prefs.rewrite) {
                {
#line 360
                tmp___8 = dump_rewrite(ptr, (unsigned long )bytes);
#line 360
                written_bytes += tmp___8;
                }
              }
#line 361
              bytes = 0L;
#line 362
              ptr += bytes;
#line 363
              goto while_break;
            }
            {
#line 366
            (ifd_entries + ifd_number)->tag = getrawword(ptr, 0UL);
#line 367
            (ifd_entries + ifd_number)->type = getrawword(ptr, 2UL);
#line 368
            (ifd_entries + ifd_number)->count = getrawlong(ptr, 4UL);
#line 369
            (ifd_entries + ifd_number)->value_offset = getrawlong(ptr, 8UL);
#line 371
            tmp___9 = exif_match_tag((int const   )(ifd_entries + ifd_number)->tag);
            }
#line 371
            if (tmp___9) {
              {
#line 375
              debug((char *)"Exif parser: IFD%u found (tag=0x%02x, type=%u, count=%lu)",
                    (int )ifd_number, (int )(ifd_entries + ifd_number)->tag, (int )(ifd_entries + ifd_number)->type,
                    (ifd_entries + ifd_number)->count);
              }
            } else {
              {
#line 372
              warning((char *)"Exif parser: unknown Exif tag 0x%04x", (int )(ifd_entries + ifd_number)->tag);
              }
            }
#line 381
            if (prefs.rewrite) {
              {
#line 382
              tmp___10 = dump_rewrite(ptr, 12UL);
#line 382
              written_bytes += tmp___10;
              }
            }
#line 383
            bytes -= 12L;
#line 384
            ptr += 12;
#line 385
            ifd_number = (unsigned short )((int )ifd_number + 1);
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 389
          next_ifd_offset = getrawlong(ptr, 0UL);
          }
#line 390
          if (prefs.rewrite) {
            {
#line 391
            tmp___11 = dump_rewrite(ptr, 4UL);
#line 391
            written_bytes += tmp___11;
            }
          }
          {
#line 392
          bytes -= 4L;
#line 393
          ptr += 4;
#line 394
          debug((char *)"Exif parser: next IFD offset is %lu (0 means none)", next_ifd_offset);
#line 399
          first_value_offset = 0UL;
#line 400
          ifd_number = (unsigned short)0;
          }
          {
#line 401
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 401
            if (bytes > 0L) {
#line 401
              if (! ((unsigned long )ifd_number < ifd_max)) {
#line 401
                goto while_break___0;
              }
            } else {
#line 401
              goto while_break___0;
            }
            {
#line 405
            tmp___12 = get_ifd_type_size((enum TIFF_TYPE  const  )(ifd_entries + ifd_number)->type);
#line 405
            size = (unsigned long )tmp___12 * (ifd_entries + ifd_number)->count;
            }
#line 407
            if (size > 4UL) {
              {
#line 409
              info((char *)"Exif parser: outline value for IFD%u (size=%lu byte(s))",
                   (int )ifd_number, size);
              }
#line 413
              if (first_value_offset == 0UL) {
#line 419
                gap_size = (unsigned long )((base_offset + (ifd_entries + ifd_number)->value_offset) - ptr);
#line 420
                if (gap_size) {
                  {
#line 422
                  warning((char *)"Exif parser: there\'s a gap of %lu byte(s) before the first outline value from IFD%u",
                          gap_size, (int )ifd_number);
                  }
#line 424
                  if (prefs.rewrite) {
                    {
#line 425
                    tmp___13 = dump_rewrite(ptr, gap_size);
#line 425
                    written_bytes += tmp___13;
                    }
                  }
#line 426
                  bytes = (long )((unsigned long )bytes - gap_size);
#line 427
                  ptr += gap_size;
                }
              }
#line 435
              first_value_offset = (ifd_entries + ifd_number)->value_offset;
#line 439
              bytes = (long )((unsigned long )bytes + size);
#line 440
              ptr += size;
            } else {
              {
#line 444
              info((char *)"Exif parser: inline value for IFD%u (size=%lu byte(s))",
                   (int )ifd_number, size);
              }
            }
#line 451
            ifd_number = (unsigned short )((int )ifd_number + 1);
          }
          while_break___0: /* CIL Label */ ;
          }
#line 453
          if (bytes < 0L) {
            {
#line 455
            ret = (bool )0;
#line 456
            tmp___14 = abs((int )bytes);
#line 456
            error((char *)"Exif parser: dataset underrun (overflow of %lu byte(s))",
                  tmp___14);
            }
          }
          {
#line 459
          free((void *)ifd_entries);
          }
        }
      }
    }
  }
  {
#line 464
  debug((char *)"Exif parser: %u dataset(s) inspected, total length: %lu byte(s)",
        ifd_max, (long )bytes_left - bytes);
  }
#line 466
  if (prefs.rewrite) {
    {
#line 467
    debug((char *)"Exif parser: %lu byte(s) rewritten", written_bytes);
    }
  }
#line 468
  result->parsed_bytes = (unsigned long )((long )bytes_left - bytes);
#line 469
  result->written_bytes = written_bytes;
#line 470
  result->ret = ret;
}
}
#line 473 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
struct exif_ifd_field *exif_match_tag(int const   tag ) 
{ 
  register unsigned int i ;

  {
#line 477
  i = 0U;
  {
#line 478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 478
    if (! ((int )exif_ifd_fields[i].tag != 65535)) {
#line 478
      goto while_break;
    }
#line 480
    if ((int )exif_ifd_fields[i].tag == (int )tag) {
#line 481
      return (& exif_ifd_fields[i]);
    }
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  return ((struct exif_ifd_field *)((void *)0));
}
}
#line 487 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
void exif_dump_list(void) 
{ 


  {
#line 489
  return;
}
}
#line 491 "/home/wheatley/newnew/temp/pecomato-0.0.15/exif.c"
unsigned int get_ifd_type_size(enum TIFF_TYPE  const  type ) 
{ 
  register unsigned int i ;

  {
#line 495
  i = 0U;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! ((int )tiff_ifd_type_sizes[i].type != -1)) {
#line 496
      goto while_break;
    }
#line 498
    if ((int )tiff_ifd_type_sizes[i].type == (int )type) {
#line 499
      return (tiff_ifd_type_sizes[i].size);
    }
#line 500
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  return (0U);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 346 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
unsigned char getbyte(unsigned char *ptr , unsigned long offset ) ;
#line 347
unsigned short getword(unsigned char *ptr , unsigned long offset ) ;
#line 368
void message(enum SEVERITY severity , char *format  , ...) ;
#line 403
void dump_hexa(unsigned char *value , unsigned long length ) ;
#line 200 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.h"
void iptc_parse(unsigned char *buffer , long const   bytes_left , bool const   iptc_expected ,
                struct parser_result *result ) ;
#line 201
void iptc_stats_table_inc(unsigned int code , unsigned short *iptc_datasets_history ) ;
#line 202
void iptc_stats_table_dec(unsigned int code , unsigned short *iptc_datasets_history ) ;
#line 203
struct iptc_code_descr *iptc_match_code(enum IPTC_CODE  const  code ) ;
#line 204
void iptc_dump_value(unsigned short code , struct iptc_code_descr *code_descr , unsigned char *value ,
                     unsigned short length , bool dump_length , bool manage_newline ) ;
#line 206
void iptc_dump_list(void) ;
#line 208
void iptc_filter_table_init(void) ;
#line 209
void iptc_filter_add_value(unsigned int code ) ;
#line 210
void iptc_filter_add_range(unsigned int code , unsigned int code2 ) ;
#line 211
void iptc_filter_table_reset(void) ;
#line 212
void iptc_filter_table_dump(void) ;
#line 213
bool iptc_filter_match(unsigned int code ) ;
#line 214
unsigned short iptc_filters(void) ;
#line 216
void iptc_edit_list_init(void) ;
#line 217
void iptc_edit_add_edit(unsigned int code , size_t len , unsigned char *data , bool *data_in_use ) ;
#line 218
void iptc_edit_list_reset(void) ;
#line 219
void iptc_edit_list_dump(void) ;
#line 220
unsigned short iptc_edits(void) ;
#line 221
size_t iptc_edit_insert_chunks(bool flush , unsigned int code , unsigned short *iptc_datasets_history ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 8 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned char *rewrite_cache ;
#line 9
unsigned long rewrite_cache_offset ;
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
struct iptc_code_descr iptc_codes_descr[115]  = 
#line 13
  {      {(enum IPTC_CODE )256, (enum IPTC_DATASET_FORMAT )4, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"model version"}, 
        {(enum IPTC_CODE )261, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 1024L, (char *)"destination"}, 
        {(enum IPTC_CODE )276, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"file format"}, 
        {(enum IPTC_CODE )278, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"file format version"}, 
        {(enum IPTC_CODE )286, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 10L, (char *)"service ID"}, 
        {(enum IPTC_CODE )296, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"envelope number"}, 
        {(enum IPTC_CODE )306, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"product ID"}, 
        {(enum IPTC_CODE )316, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"envelope priority"}, 
        {(enum IPTC_CODE )326, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"date sent"}, 
        {(enum IPTC_CODE )336, (enum IPTC_DATASET_FORMAT )6, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 11L, (char *)"time sent"}, 
        {(enum IPTC_CODE )346, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"character set"}, 
        {(enum IPTC_CODE )356, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 80L, (char *)"unique name of object"}, 
        {(enum IPTC_CODE )376, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"abstract relationship method ID"}, 
        {(enum IPTC_CODE )378, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"abstract relationship method version"}, 
        {(enum IPTC_CODE )512,
      (enum IPTC_DATASET_FORMAT )4, (enum IPTC_DATASET_UNICITY )1, (enum IPTC_DATASET_SIZE )1,
      2L, (char *)"record version"}, 
        {(enum IPTC_CODE )515, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 67L, (char *)"object type reference"}, 
        {(enum IPTC_CODE )516, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 68L, (char *)"object attribute reference"}, 
        {(enum IPTC_CODE )517, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"object name (title)"}, 
        {(enum IPTC_CODE )519, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"edit status"}, 
        {(enum IPTC_CODE )520, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"editorial update"}, 
        {(enum IPTC_CODE )522, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"urgency"}, 
        {(enum IPTC_CODE )524, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 236L, (char *)"subject reference"}, 
        {(enum IPTC_CODE )527, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 3L, (char *)"category"}, 
        {(enum IPTC_CODE )528, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"category description"}, 
        {(enum IPTC_CODE )532, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"supplemental category"}, 
        {(enum IPTC_CODE )533, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"category code"}, 
        {(enum IPTC_CODE )534, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"fixture identifier"}, 
        {(enum IPTC_CODE )535, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"num"}, 
        {(enum IPTC_CODE )537, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"keywords"}, 
        {(enum IPTC_CODE )538, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )1, 3L, (char *)"content location code"}, 
        {(enum IPTC_CODE )539, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"content location name"}, 
        {(enum IPTC_CODE )542, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"release date"}, 
        {(enum IPTC_CODE )547, (enum IPTC_DATASET_FORMAT )6, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 11L, (char *)"release time"}, 
        {(enum IPTC_CODE )549, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"expiration date"}, 
        {(enum IPTC_CODE )550, (enum IPTC_DATASET_FORMAT )6, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"expiration time"}, 
        {(enum IPTC_CODE )552, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 256L, (char *)"special instructions"}, 
        {(enum IPTC_CODE )554, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"action advised"}, 
        {(enum IPTC_CODE )557, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 10L, (char *)"reference service"}, 
        {(enum IPTC_CODE )559, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"reference date"}, 
        {(enum IPTC_CODE )562, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 8L, (char *)"reference number"}, 
        {(enum IPTC_CODE )567, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"date created"}, 
        {(enum IPTC_CODE )568, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"archive date"}, 
        {(enum IPTC_CODE )572, (enum IPTC_DATASET_FORMAT )6, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 11L, (char *)"time created"}, 
        {(enum IPTC_CODE )574, (enum IPTC_DATASET_FORMAT )5, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 8L, (char *)"digital creation date"}, 
        {(enum IPTC_CODE )575, (enum IPTC_DATASET_FORMAT )6, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 11L, (char *)"digital creation time"}, 
        {(enum IPTC_CODE )577, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"originating program"}, 
        {(enum IPTC_CODE )582, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 10L, (char *)"program version"}, 
        {(enum IPTC_CODE )587, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 1L, (char *)"object cycle"}, 
        {(enum IPTC_CODE )592, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"byline (author)"}, 
        {(enum IPTC_CODE )597, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"byline title (author position)"}, 
        {(enum IPTC_CODE )598, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"title original"}, 
        {(enum IPTC_CODE )599, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"productor"}, 
        {(enum IPTC_CODE )600, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"actor"}, 
        {(enum IPTC_CODE )602, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"city"}, 
        {(enum IPTC_CODE )604, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"sub-location"}, 
        {(enum IPTC_CODE )607, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"state/province"}, 
        {(enum IPTC_CODE )612, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 3L, (char *)"country/primary location code"}, 
        {(enum IPTC_CODE )613, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"country/primary location name"}, 
        {(enum IPTC_CODE )615, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"original transmission reference"}, 
        {(enum IPTC_CODE )617,
      (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1, (enum IPTC_DATASET_SIZE )0,
      256L, (char *)"headline"}, 
        {(enum IPTC_CODE )622, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"credit"}, 
        {(enum IPTC_CODE )624, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"photographer number"}, 
        {(enum IPTC_CODE )627, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"source"}, 
        {(enum IPTC_CODE )628, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 128L, (char *)"copyright notice"}, 
        {(enum IPTC_CODE )630, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 128L, (char *)"contact"}, 
        {(enum IPTC_CODE )632, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 2000L, (char *)"caption/abstract"}, 
        {(enum IPTC_CODE )633, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"photograph number"}, 
        {(enum IPTC_CODE )634, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )0,
      (enum IPTC_DATASET_SIZE )0, 32L, (char *)"writer/editor"}, 
        {(enum IPTC_CODE )635, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"serial number"}, 
        {(enum IPTC_CODE )637, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 7360L, (char *)"rasterized caption"}, 
        {(enum IPTC_CODE )642, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"image type"}, 
        {(enum IPTC_CODE )643, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"image orientation"}, 
        {(enum IPTC_CODE )645, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)"reference"}, 
        {(enum IPTC_CODE )647, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 3L, (char *)"language identifier"}, 
        {(enum IPTC_CODE )662, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"audio type"}, 
        {(enum IPTC_CODE )663, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 6L, (char *)"audio sampling rate"}, 
        {(enum IPTC_CODE )664, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"audio sampling resolution"}, 
        {(enum IPTC_CODE )665, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 6L, (char *)"audio duration"}, 
        {(enum IPTC_CODE )666, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 64L, (char *)"audio outcue"}, 
        {(enum IPTC_CODE )712, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"objectdata preview file format"}, 
        {(enum IPTC_CODE )713, (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"objectdata preview file format version"}, 
        {(enum IPTC_CODE )714,
      (enum IPTC_DATASET_FORMAT )3, (enum IPTC_DATASET_UNICITY )1, (enum IPTC_DATASET_SIZE )0,
      256000L, (char *)"objectdata preview data"}, 
        {(enum IPTC_CODE )768, (enum IPTC_DATASET_FORMAT )4, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"record version"}, 
        {(enum IPTC_CODE )778, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 16L, (char *)"picture numver"}, 
        {(enum IPTC_CODE )788, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"pixels per line"}, 
        {(enum IPTC_CODE )798, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"number of lines"}, 
        {(enum IPTC_CODE )808, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"pixel size in scanning direction"}, 
        {(enum IPTC_CODE )818,
      (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1, (enum IPTC_DATASET_SIZE )1,
      2L, (char *)"pixel size perpendicular to scanning direction"}, 
        {(enum IPTC_CODE )823, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"supplementary type"}, 
        {(enum IPTC_CODE )828, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"colour representation"}, 
        {(enum IPTC_CODE )832, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"inter-change colour space"}, 
        {(enum IPTC_CODE )833, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"colour sequence"}, 
        {(enum IPTC_CODE )834, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 524288L, (char *)"ICC input colour profile"}, 
        {(enum IPTC_CODE )838, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 65535L, (char *)"colour calibration matrix table"}, 
        {(enum IPTC_CODE )848,
      (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1, (enum IPTC_DATASET_SIZE )0,
      131072L, (char *)"lookup table"}, 
        {(enum IPTC_CODE )852, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 2L, (char *)"number of index entries"}, 
        {(enum IPTC_CODE )853, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 524288L, (char *)"colour palette"}, 
        {(enum IPTC_CODE )854, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"number of bits per sample"}, 
        {(enum IPTC_CODE )858, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"sampling structure"}, 
        {(enum IPTC_CODE )868, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"scanning direction"}, 
        {(enum IPTC_CODE )870, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"image rotation"}, 
        {(enum IPTC_CODE )878, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 4L, (char *)"data compression method"}, 
        {(enum IPTC_CODE )888, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"quantisation method"}, 
        {(enum IPTC_CODE )893, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 65535L, (char *)"end points"}, 
        {(enum IPTC_CODE )898, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"excursion tolerance"}, 
        {(enum IPTC_CODE )903, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"bits per component"}, 
        {(enum IPTC_CODE )908, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"maximum density range"}, 
        {(enum IPTC_CODE )913, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 2L, (char *)"gamma compensated value"}, 
        {(enum IPTC_CODE )1802, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )1, 1L, (char *)"size mode"}, 
        {(enum IPTC_CODE )1812, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"max subfile size"}, 
        {(enum IPTC_CODE )1882, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"objectdata size announced"}, 
        {(enum IPTC_CODE )1887, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"maximal objectdata size"}, 
        {(enum IPTC_CODE )2058, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 2147483647L, (char *)"subfile"}, 
        {(enum IPTC_CODE )2314, (enum IPTC_DATASET_FORMAT )2, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 4L, (char *)"confirmed object size"}, 
        {(enum IPTC_CODE )65535, (enum IPTC_DATASET_FORMAT )0, (enum IPTC_DATASET_UNICITY )1,
      (enum IPTC_DATASET_SIZE )0, 0L, (char *)((void *)0)}};
#line 141 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
struct iptc_filter_match_data **iptc_filter_table  =    (struct iptc_filter_match_data **)((void *)0);
#line 142 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_filter_table_size  =    (unsigned short)0;
#line 143 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_filter_table_inc_size  =    (unsigned short)0;
#line 144 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_filter_table_filters  =    (unsigned short)0;
#line 146 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned char *iptc_extract_buffer  ;
#line 147 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned long iptc_extract_buffer_size  ;
#line 149 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
struct iptc_edit_list_cell *iptc_edit_list  =    (struct iptc_edit_list_cell *)((void *)0);
#line 150 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_edit_list_edits  =    (unsigned short)0;
#line 154 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_parse(unsigned char *buffer , long const   bytes_left , bool const   iptc_expected ,
                struct parser_result *result ) 
{ 
  struct iptc_code_descr *code_descr ;
  unsigned short *iptc_datasets_history ;
  unsigned char *ptr ;
  unsigned char *value ;
  unsigned long size ;
  unsigned long written_bytes ;
  unsigned long iptc_datasets ;
  long missing ;
  long bytes ;
  unsigned short code ;
  long length ;
  unsigned short extended_length ;
  unsigned char record ;
  unsigned char last_record ;
  unsigned char tag ;
  bool ret ;
  bool saw_warning_missing_record_version[256] ;
  bool saw_warning_duplicate_record_version[256] ;
  void *tmp ;
  unsigned char tmp___0 ;
  unsigned short tmp___1 ;
  unsigned char tmp___2 ;
  unsigned short tmp___3 ;
  unsigned long tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  long tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  bool tmp___14 ;
  bool tmp___15 ;
  size_t tmp___16 ;
  register unsigned short record_type ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
  {
#line 176
  iptc_datasets = 0UL;
#line 177
  ptr = buffer;
#line 178
  bytes = (long )bytes_left;
#line 179
  written_bytes = 0UL;
#line 180
  missing = 0L;
#line 181
  ret = (bool )1;
#line 182
  debug((char *)"IPTC parser: %ld byte(s) to parse", bytes);
  }
#line 185
  if (prefs.technical) {
#line 185
    goto _L;
  } else
#line 185
  if (prefs.rewrite) {
#line 185
    if (prefs.filter_mode & 4) {
      _L: /* CIL Label */ 
      {
#line 188
      size = 65536UL * sizeof(unsigned short );
#line 189
      tmp = malloc(size);
#line 189
      iptc_datasets_history = (unsigned short *)tmp;
      }
#line 190
      if (! iptc_datasets_history) {
        {
#line 191
        fatal_error((char *)"IPTC parser: could not allocate dataset history buffer");
        }
      }
      {
#line 192
      memset((void *)iptc_datasets_history, 0, size);
      }
    } else {
#line 195
      iptc_datasets_history = (unsigned short *)((void *)0);
    }
  } else {
#line 195
    iptc_datasets_history = (unsigned short *)((void *)0);
  }
  {
#line 196
  memset((void *)(saw_warning_missing_record_version), 0, 256UL * sizeof(bool ));
#line 197
  memset((void *)(saw_warning_duplicate_record_version), 0, 256UL * sizeof(bool ));
#line 200
  last_record = (unsigned char)0;
  }
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (bytes > 0L)) {
#line 202
      goto while_break;
    }
#line 204
    if (bytes < 5L) {
      {
#line 206
      ret = (bool )0;
#line 207
      error((char *)"IPTC parser: record underrun (%ld byte(s) remaining, 5 or more expected)",
            bytes);
      }
#line 209
      goto while_break;
    }
    {
#line 213
    tag = getbyte(ptr, 0UL);
    }
#line 214
    if ((int )tag != 28) {
#line 214
      if (iptc_expected) {
        {
#line 216
        ret = (bool )0;
#line 217
        error((char *)"IPTC parser: expected tag marker not matched");
        }
#line 218
        goto while_break;
      }
    }
    {
#line 222
    record = getbyte(ptr, 1UL);
    }
#line 223
    if (prefs.technical) {
#line 223
      if ((int )record == 0) {
        {
#line 224
        warning((char *)"IPTC parser: invalid record number 0");
        }
      }
    }
#line 226
    if (prefs.technical) {
#line 226
      if ((int )record < (int )last_record) {
        {
#line 227
        warning((char *)"IPTC parser: invalid record order (got 0x%02xxx, last one was 0x%02xxx)",
                (int )record, (int )last_record);
        }
      }
    }
    {
#line 229
    last_record = record;
#line 230
    tmp___0 = getbyte(ptr, 2UL);
#line 230
    code = (unsigned short )(((int )record << 8) | (int )tmp___0);
#line 231
    code_descr = iptc_match_code((enum IPTC_CODE  const  )code);
    }
#line 232
    if (! code_descr) {
      {
#line 233
      warning((char *)"IPTC parser: unknown IPTC code 0x%04x", (int )code);
      }
    } else {
      {
#line 236
      debug((char *)"IPTC parser: code 0x%04x (%s)", (int )code, code_descr->label);
      }
#line 238
      if (prefs.technical) {
#line 238
        if ((unsigned int )code_descr->repeatable == 1U) {
#line 238
          if (*(iptc_datasets_history + code)) {
            {
#line 241
            error((char *)"IPTC parser: dataset not repeatable but already found %u time(s), this new one should be ignored",
                  (int )*(iptc_datasets_history + code));
            }
          }
        }
      }
    }
#line 244
    if (prefs.technical) {
#line 246
      if (((int )code & 255) == 0) {
#line 249
        if (! saw_warning_duplicate_record_version[record]) {
#line 249
          if ((int )*(iptc_datasets_history + code) > 0) {
            {
#line 252
            saw_warning_duplicate_record_version[record] = (bool )1;
#line 253
            warning((char *)"IPTC parser: more than one record version found (code: 0x%04x)",
                    (int )code);
            }
          }
        }
      } else
#line 260
      if (! saw_warning_missing_record_version[record]) {
#line 260
        if ((int )*(iptc_datasets_history + ((int )code & 65280)) == 0) {
          {
#line 263
          saw_warning_missing_record_version[record] = (bool )1;
#line 264
          warning((char *)"IPTC parser: no record version found yet for code 0x%04x (expected code: 0x%04x)",
                  (int )code, (int )code & 65280);
          }
        }
      }
    }
#line 269
    if (prefs.technical) {
      {
#line 270
      iptc_stats_table_inc((unsigned int )code, iptc_datasets_history);
      }
    } else
#line 269
    if (prefs.rewrite) {
#line 269
      if (prefs.filter_mode & 4) {
        {
#line 270
        iptc_stats_table_inc((unsigned int )code, iptc_datasets_history);
        }
      }
    }
    {
#line 271
    iptc_datasets ++;
#line 274
    tmp___1 = getword(ptr, 3UL);
#line 274
    length = (long )tmp___1;
    }
#line 276
    if (length > 32767L) {
#line 278
      extended_length = (unsigned short )(length & 32767L);
      {
#line 281
      if ((int )extended_length == 1) {
#line 281
        goto case_1;
      }
#line 284
      if ((int )extended_length == 2) {
#line 284
        goto case_2;
      }
#line 287
      if ((int )extended_length == 4) {
#line 287
        goto case_4;
      }
#line 290
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 282
      tmp___2 = getbyte(ptr, 5UL);
#line 282
      length = (long )tmp___2;
      }
#line 283
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 285
      tmp___3 = getword(ptr, 5UL);
#line 285
      length = (long )tmp___3;
      }
#line 286
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 288
      tmp___4 = getlong(ptr, 5UL);
#line 288
      length = (long )tmp___4;
      }
#line 289
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 292
      error((char *)"IPTC parser: extended dataset found with an unsupported length: %u",
            (int )extended_length);
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 297
      extended_length = (unsigned short)0;
    }
#line 299
    if (prefs.technical) {
#line 299
      if (code_descr) {
#line 301
        if (code_descr->fixed_length) {
#line 303
          if (length != code_descr->length) {
            {
#line 304
            warning((char *)"IPTC parser: dataset 0x%04x: length (%lu byte(s)) doesn\'t match the expected length (%lu byte(s))",
                    (int )code, length, code_descr->length);
            }
          }
        } else
#line 308
        if (code_descr->length > 0L) {
#line 308
          if (length > code_descr->length) {
            {
#line 309
            warning((char *)"IPTC parser: dataset 0x%04x: length (%lu byte(s)) exceeds the expected max length (%lu byte(s))",
                    (int )code, length, code_descr->length);
            }
          }
        }
      }
    }
#line 314
    if ((unsigned int )prefs.op == 1U) {
#line 314
      goto _L___0;
    } else
#line 314
    if ((unsigned int )prefs.op == 2U) {
      _L___0: /* CIL Label */ 
      {
#line 316
      printf((char const   */* __restrict  */)"IPTC ");
#line 320
      printf((char const   */* __restrict  */)"0x%04x", (int )code);
      }
#line 322
      if (code_descr) {
#line 322
        tmp___5 = (char const   *)code_descr->label;
      } else {
#line 322
        tmp___5 = "<unknown dataset>";
      }
      {
#line 322
      printf((char const   */* __restrict  */)" %s", tmp___5);
      }
    }
#line 326
    missing = bytes - ((long )(5 + (int )extended_length) + length);
#line 327
    if (missing < 0L) {
#line 329
      if (prefs.fix) {
#line 329
        tmp___6 = " - about to be fixed";
      } else {
#line 329
        tmp___6 = "";
      }
#line 329
      if (prefs.fix) {
#line 329
        tmp___7 = 2;
      } else {
#line 329
        tmp___7 = 1;
      }
      {
#line 329
      message((enum SEVERITY )tmp___7, (char *)"IPTC parser: dataset 0x%04x: underrun (%ld byte(s) left, %ld expected)%s",
              (int )code, bytes, (long )(5 + (int )extended_length) + length, tmp___6);
      }
#line 331
      if (prefs.fix) {
        {
#line 333
        tmp___8 = abs((int )missing);
#line 333
        missing = (long )tmp___8;
#line 334
        (prefs.context_fixes) ++;
#line 335
        (prefs.fixes) ++;
        }
      } else {
#line 340
        missing = 0L;
#line 341
        ret = (bool )0;
      }
#line 343
      if (bytes == 0L) {
#line 345
        if ((unsigned int )prefs.op == 1U) {
          {
#line 346
          printf((char const   */* __restrict  */)"\n");
          }
        } else
#line 345
        if ((unsigned int )prefs.op == 2U) {
          {
#line 346
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 347
        goto while_break;
      }
#line 350
      length = bytes;
#line 351
      length -= (long )(5 + (int )extended_length);
    } else {
#line 354
      missing = 0L;
    }
    {
#line 355
    tmp___9 = malloc((unsigned long )((length + missing) + 1L) * sizeof(unsigned char ));
#line 355
    value = (unsigned char *)tmp___9;
    }
#line 356
    if (! value) {
#line 358
      if ((unsigned int )prefs.op == 1U) {
        {
#line 359
        printf((char const   */* __restrict  */)"\n");
        }
      } else
#line 358
      if ((unsigned int )prefs.op == 2U) {
        {
#line 359
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 360
      fatal_error((char *)"IPTC parser: malloc(%lu) for dataset 0x%04x", (unsigned long )(length + 1L) * sizeof(unsigned char ),
                  (int )code);
      }
    }
    {
#line 363
    memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)((((ptr + 1) + 2) + 2) + (int )extended_length),
           (size_t )length);
    }
#line 365
    if (missing) {
      {
#line 367
      memset((void *)(value + (unsigned long )length * sizeof(unsigned char )), 186,
             (unsigned long )missing * sizeof(unsigned char ));
      }
    }
#line 371
    *(value + (length + missing)) = (unsigned char)0;
#line 374
    if (prefs.rewrite) {
#line 374
      if (prefs.filter_mode & 4) {
        {
#line 375
        tmp___10 = iptc_edit_insert_chunks((bool )0, (unsigned int )code, iptc_datasets_history);
#line 375
        written_bytes += tmp___10;
        }
      }
    }
#line 380
    if (prefs.rewrite) {
      {
#line 382
      tmp___14 = iptc_filter_match((unsigned int )code);
      }
#line 382
      if (tmp___14) {
#line 384
        if ((long )(5 + (int )extended_length) + length > bytes) {
#line 384
          tmp___11 = bytes;
        } else {
#line 384
          tmp___11 = (long )(5 + (int )extended_length) + length;
        }
        {
#line 384
        tmp___12 = dump_rewrite(ptr, (unsigned long )tmp___11);
#line 384
        written_bytes += tmp___12;
        }
#line 385
        if (missing > 0L) {
          {
#line 387
          debug((char *)"IPTC parser: writing %ld byte(s) to fix the underrun", missing);
#line 389
          tmp___13 = dump_rewrite((((ptr + 1) + 2) + 2) + length, (unsigned long )missing);
#line 389
          written_bytes += tmp___13;
          }
        }
      } else
#line 395
      if (prefs.filter_mode & 4) {
        {
#line 397
        iptc_stats_table_dec((unsigned int )code, iptc_datasets_history);
        }
      }
    }
#line 402
    ptr += 5L + length;
#line 403
    bytes -= 5L + length;
#line 406
    if ((unsigned int )prefs.op == 2U) {
      {
#line 408
      printf((char const   */* __restrict  */)" ");
#line 409
      iptc_dump_value(code, code_descr, value, (unsigned short )length, (bool )1,
                      (bool )1);
      }
    } else
#line 412
    if ((unsigned int )prefs.op == 3U) {
      {
#line 414
      tmp___15 = iptc_filter_match((unsigned int )code);
      }
#line 414
      if (tmp___15) {
        {
#line 416
        debug((char *)"IPTC parser: matching IPTC code 0x%04x", (int )code);
#line 417
        iptc_dump_value(code, code_descr, value, (unsigned short )length, (bool )0,
                        (bool )0);
        }
      }
    } else
#line 421
    if ((unsigned int )prefs.op == 1U) {
      {
#line 422
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 424
    free((void *)value);
#line 425
    value = (unsigned char *)((void *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  if (prefs.rewrite) {
#line 429
    if (prefs.filter_mode & 4) {
      {
#line 430
      tmp___16 = iptc_edit_insert_chunks((bool )1, 0U, iptc_datasets_history);
#line 430
      written_bytes += tmp___16;
      }
    }
  }
#line 432
  if (prefs.technical) {
#line 458
    record_type = (unsigned short)1;
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 458
      if (! ((int )record_type <= 255)) {
#line 458
        goto while_break___0;
      }
#line 459
      if (saw_warning_missing_record_version[record_type]) {
        {
#line 460
        warning((char *)"IPTC parser: no record version code found at all for record type 0x%02xxx",
                (int )record_type);
        }
      }
#line 458
      record_type = (unsigned short )((int )record_type + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 463
  if (prefs.technical) {
    {
#line 465
    free((void *)iptc_datasets_history);
#line 466
    iptc_datasets_history = (unsigned short *)((void *)0);
    }
  } else
#line 463
  if (prefs.rewrite) {
#line 463
    if (prefs.filter_mode & 4) {
      {
#line 465
      free((void *)iptc_datasets_history);
#line 466
      iptc_datasets_history = (unsigned short *)((void *)0);
      }
    }
  }
  {
#line 468
  debug((char *)"IPTC parser: %u dataset(s) found, total length: %lu byte(s)", iptc_datasets,
        bytes_left - (long const   )bytes);
  }
#line 470
  if (prefs.rewrite) {
    {
#line 471
    debug((char *)"IPTC parser: %lu byte(s) rewritten", written_bytes);
    }
  }
#line 472
  result->parsed_bytes = (unsigned long )(bytes_left - (long const   )bytes);
#line 473
  result->written_bytes = written_bytes;
#line 474
  result->ret = ret;
#line 476
  if (prefs.extract_iptc) {
#line 478
    if (missing > 0L) {
#line 480
      if (! prefs.fix) {
        {
#line 481
        error((char *)"IPTC parser: unexpected state: fixing not enabled but there are %ld byte(s) marked for fixing (extraction)",
              missing);
        }
      } else {
        {
#line 484
        debug((char *)"IPTC parser: there are %ld byte(s) marked for fixing (extraction)",
              missing);
        }
      }
    }
#line 488
    if (prefs.rewrite_cached) {
      {
#line 491
      iptc_extract_buffer_size = result->written_bytes;
#line 492
      tmp___17 = malloc(iptc_extract_buffer_size * sizeof(unsigned char ));
#line 492
      iptc_extract_buffer = (unsigned char *)tmp___17;
      }
#line 493
      if (! iptc_extract_buffer) {
        {
#line 494
        fatal_error((char *)"IPTC parser: couldn\'t allocate space for IPTC extract buffer");
        }
      }
      {
#line 495
      memcpy((void */* __restrict  */)iptc_extract_buffer, (void const   */* __restrict  */)(rewrite_cache + (rewrite_cache_offset - iptc_extract_buffer_size)),
             iptc_extract_buffer_size);
#line 498
      debug((char *)"IPTC parser: IPTC chunk extraction prepared from write cache: %lu bytes(s)",
            iptc_extract_buffer_size);
      }
    } else {
      {
#line 504
      iptc_extract_buffer_size = result->parsed_bytes + (unsigned long )missing;
#line 505
      tmp___18 = malloc(iptc_extract_buffer_size * sizeof(unsigned char ));
#line 505
      iptc_extract_buffer = (unsigned char *)tmp___18;
      }
#line 506
      if (! iptc_extract_buffer) {
        {
#line 507
        fatal_error((char *)"IPTC parser: couldn\'t allocate space for IPTC extract buffer");
        }
      }
      {
#line 508
      memcpy((void */* __restrict  */)iptc_extract_buffer, (void const   */* __restrict  */)buffer,
             iptc_extract_buffer_size);
#line 509
      debug((char *)"IPTC parser: IPTC chunk extraction prepared from input flow: %lu bytes(s)",
            iptc_extract_buffer_size);
      }
    }
  }
#line 513
  return;
}
}
#line 515 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_stats_table_inc(unsigned int code , unsigned short *iptc_datasets_history ) 
{ 


  {
#line 518
  if ((int )*(iptc_datasets_history + code) == 65535) {
    {
#line 519
    error((char *)"iptc_stats_table_inc: datasets history overflow (0x%04x)", code);
    }
  } else {
#line 521
    *(iptc_datasets_history + code) = (unsigned short )((int )*(iptc_datasets_history + code) + 1);
  }
#line 522
  return;
}
}
#line 524 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_stats_table_dec(unsigned int code , unsigned short *iptc_datasets_history ) 
{ 


  {
#line 527
  if ((int )*(iptc_datasets_history + code) == 0) {
    {
#line 528
    error((char *)"iptc_stats_table_inc: datasets history underflow (0x%04x)", code);
    }
  } else {
#line 530
    *(iptc_datasets_history + code) = (unsigned short )((int )*(iptc_datasets_history + code) - 1);
  }
#line 531
  return;
}
}
#line 533 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
struct iptc_code_descr *iptc_match_code(enum IPTC_CODE  const  code ) 
{ 
  register unsigned int i ;

  {
#line 537
  i = 0U;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! ((unsigned int )iptc_codes_descr[i].code != 65535U)) {
#line 538
      goto while_break;
    }
#line 540
    if ((unsigned int )iptc_codes_descr[i].code == (unsigned int )code) {
#line 541
      return (& iptc_codes_descr[i]);
    }
#line 542
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return ((struct iptc_code_descr *)((void *)0));
}
}
#line 547 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_dump_value(unsigned short code , struct iptc_code_descr *code_descr , unsigned char *value ,
                     unsigned short length , bool dump_length , bool manage_newline ) 
{ 
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;

  {
#line 550
  if (! code_descr) {
    {
#line 551
    dump_hexa(value, (unsigned long )length);
    }
  } else {
    {
#line 558
    if ((unsigned int )code_descr->format == 2U) {
#line 558
      goto case_2;
    }
#line 558
    if ((unsigned int )code_descr->format == 0U) {
#line 558
      goto case_2;
    }
#line 562
    if ((unsigned int )code_descr->format == 3U) {
#line 562
      goto case_3;
    }
#line 569
    if ((unsigned int )code_descr->format == 5U) {
#line 569
      goto case_5;
    }
#line 577
    if ((unsigned int )code_descr->format == 6U) {
#line 577
      goto case_6;
    }
#line 585
    if ((unsigned int )code_descr->format == 1U) {
#line 585
      goto case_1;
    }
#line 618
    if ((unsigned int )code_descr->format == 4U) {
#line 618
      goto case_4;
    }
#line 639
    goto switch_default___0;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 559
    dump_hexa(value, (unsigned long )length);
    }
#line 560
    goto switch_break;
    case_3: /* CIL Label */ 
#line 563
    if (dump_length) {
      {
#line 564
      printf((char const   */* __restrict  */)"[%u byte(s)]: \'%s\'\n", (int )length,
             value);
      }
    } else {
      {
#line 566
      printf((char const   */* __restrict  */)"%s\n", (char *)value);
      }
    }
#line 567
    goto switch_break;
    case_5: /* CIL Label */ 
#line 571
    if (dump_length) {
      {
#line 572
      printf((char const   */* __restrict  */)"[%u byte(s)]: \'%s\'\n", (int )length,
             value);
      }
    } else {
      {
#line 574
      printf((char const   */* __restrict  */)"%s\n", (char *)value);
      }
    }
#line 575
    goto switch_break;
    case_6: /* CIL Label */ 
#line 579
    if (dump_length) {
      {
#line 580
      printf((char const   */* __restrict  */)"[%u byte(s)]: \'%s\'\n", (int )length,
             value);
      }
    } else {
      {
#line 582
      printf((char const   */* __restrict  */)"%s\n", (char *)value);
      }
    }
#line 583
    goto switch_break;
    case_1: /* CIL Label */ 
#line 586
    if ((int )length == 1) {
#line 588
      if (dump_length) {
        {
#line 589
        tmp = getbyte(value, 0UL);
#line 589
        printf((char const   */* __restrict  */)"[%u byte(s)]: %d\n", (int )length,
               (int )((char )tmp));
        }
      } else {
        {
#line 591
        tmp___0 = getbyte(value, 0UL);
#line 591
        printf((char const   */* __restrict  */)"%d\n", (int )((char )tmp___0));
        }
      }
    } else
#line 594
    if ((int )length == 2) {
#line 596
      if (dump_length) {
        {
#line 597
        tmp___1 = getword(value, 0UL);
#line 597
        printf((char const   */* __restrict  */)"[%u byte(s)]: %d\n", (int )length,
               (int )((short )tmp___1));
        }
      } else {
        {
#line 599
        tmp___2 = getword(value, 0UL);
#line 599
        printf((char const   */* __restrict  */)"%d\n", (int )((short )tmp___2));
        }
      }
    } else
#line 602
    if ((int )length == 4) {
#line 604
      if (dump_length) {
        {
#line 605
        tmp___3 = getlong(value, 0UL);
#line 605
        printf((char const   */* __restrict  */)"[%u byte(s)]: %ld\n", (int )length,
               (long )tmp___3);
        }
      } else {
        {
#line 607
        tmp___4 = getlong(value, 0UL);
#line 607
        printf((char const   */* __restrict  */)"%ld\n", (long )tmp___4);
        }
      }
    } else {
#line 611
      if (manage_newline) {
        {
#line 612
        printf((char const   */* __restrict  */)"\n");
        }
      }
      {
#line 613
      warning((char *)"IPTC parser: dataset 0x%04x: don\'t know how to print numerical value (%u byte(s))\n",
              (int )code, (int )length);
      }
    }
#line 616
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 621
    if ((unsigned int )((enum IPTC_CODE )code) == 512U) {
#line 621
      goto case_512;
    }
#line 630
    goto switch_default;
    case_512: /* CIL Label */ 
#line 623
    if (dump_length) {
      {
#line 624
      tmp___5 = getbyte(value, 0UL);
#line 624
      tmp___6 = getbyte(value, 1UL);
#line 624
      printf((char const   */* __restrict  */)"[%d byte(s)]: %d.%d\n", (int )length,
             (int )tmp___6, (int )tmp___5);
      }
    } else {
      {
#line 627
      tmp___7 = getbyte(value, 0UL);
#line 627
      tmp___8 = getbyte(value, 1UL);
#line 627
      printf((char const   */* __restrict  */)"%d.%d\n", (int )tmp___8, (int )tmp___7);
      }
    }
#line 628
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 631
    if (manage_newline) {
      {
#line 632
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 633
    warning((char *)"IPTC parser: dataset 0x%04x: don\'t know how to print specific value (%u byte(s))\n",
            (int )code, (int )length);
    }
#line 635
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 637
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 640
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 643
  return;
}
}
#line 645 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_dump_list(void) 
{ 
  int i ;

  {
  {
#line 649
  printf((char const   */* __restrict  */)"== IPTC datasets ==\n");
#line 650
  printf((char const   */* __restrict  */)"code    description\n");
#line 651
  i = 0;
  }
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    if (! ((unsigned int )iptc_codes_descr[i].code != 65535U)) {
#line 651
      goto while_break;
    }
    {
#line 657
    printf((char const   */* __restrict  */)"0x%04x ", (unsigned int )iptc_codes_descr[i].code);
#line 659
    printf((char const   */* __restrict  */)" %s\n", iptc_codes_descr[i].label);
#line 651
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  return;
}
}
#line 663 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_filter_table_init(void) 
{ 
  unsigned int i ;
  void *tmp ;

  {
  {
#line 667
  iptc_filter_table_size = (unsigned short)50;
#line 668
  iptc_filter_table_inc_size = (unsigned short)50;
#line 669
  iptc_filter_table_filters = (unsigned short)0;
#line 671
  tmp = malloc((unsigned long )iptc_filter_table_size * sizeof(struct iptc_filter_match_data *));
#line 671
  iptc_filter_table = (struct iptc_filter_match_data **)tmp;
  }
#line 672
  if (! iptc_filter_table) {
    {
#line 673
    fatal_error((char *)"iptc_filter_table_init: couldn\'t allocate space for IPTC filter table");
    }
  }
#line 675
  i = 0U;
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (i < (unsigned int )iptc_filter_table_size)) {
#line 675
      goto while_break;
    }
#line 676
    *(iptc_filter_table + i) = (struct iptc_filter_match_data *)((void *)0);
#line 675
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return;
}
}
#line 679 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
static void iptc_filter_table_realloc(void) 
{ 
  struct iptc_filter_match_data **new_ptr ;
  unsigned int new_len ;
  unsigned int i ;
  void *tmp ;

  {
  {
#line 685
  new_len = (unsigned int )((int )iptc_filter_table_size + (int )iptc_filter_table_inc_size);
#line 686
  tmp = realloc((void *)iptc_filter_table, (unsigned long )new_len * sizeof(struct iptc_filter_match_data *));
#line 686
  new_ptr = (struct iptc_filter_match_data **)tmp;
  }
#line 687
  if (! new_ptr) {
    {
#line 688
    fatal_error((char *)"iptc_filter_table_realloc: couldn\'t reallocate IPTC filter table");
    }
  }
#line 690
  i = (unsigned int )iptc_filter_table_size;
  {
#line 690
  while (1) {
    while_continue: /* CIL Label */ ;
#line 690
    if (! (i < new_len)) {
#line 690
      goto while_break;
    }
#line 691
    *(new_ptr + i) = (struct iptc_filter_match_data *)((void *)0);
#line 690
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  iptc_filter_table = new_ptr;
#line 694
  iptc_filter_table_size = (unsigned short )new_len;
#line 695
  return;
}
}
#line 697 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_filter_add_value(unsigned int code ) 
{ 
  struct iptc_filter_match_data *iptc_filter ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
  {
#line 701
  debug((char *)"iptc_add_filter_value(%u/%u): 0x%04x", (int )iptc_filter_table_filters,
        (int )iptc_filter_table_size, code);
  }
#line 705
  if ((int )iptc_filter_table_filters + 1 >= (int )iptc_filter_table_size) {
    {
#line 706
    iptc_filter_table_realloc();
    }
  }
  {
#line 708
  tmp = malloc(sizeof(struct iptc_filter_match_data ));
#line 708
  iptc_filter = (struct iptc_filter_match_data *)tmp;
  }
#line 709
  if (! iptc_filter) {
    {
#line 710
    fatal_error((char *)"iptc_filter_add_value: couldn\'t allocate space for IPTC filter value");
    }
  }
#line 712
  iptc_filter->type = (enum iptc_filter_element_type )0;
#line 713
  iptc_filter->code = (unsigned short )code;
#line 714
  tmp___0 = iptc_filter_table_filters;
#line 714
  iptc_filter_table_filters = (unsigned short )((int )iptc_filter_table_filters + 1);
#line 714
  *(iptc_filter_table + tmp___0) = iptc_filter;
#line 715
  return;
}
}
#line 717 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_filter_add_range(unsigned int code , unsigned int code2 ) 
{ 
  struct iptc_filter_match_data *iptc_filter ;
  void *tmp ;
  unsigned short tmp___0 ;

  {
  {
#line 721
  debug((char *)"iptc_add_filter_range(%u/%u): 0x%04x-%04x", (int )iptc_filter_table_filters,
        (int )iptc_filter_table_size, code, code2);
  }
#line 725
  if ((int )iptc_filter_table_filters + 1 >= (int )iptc_filter_table_size) {
    {
#line 726
    iptc_filter_table_realloc();
    }
  }
  {
#line 728
  tmp = malloc(sizeof(struct iptc_filter_match_data ));
#line 728
  iptc_filter = (struct iptc_filter_match_data *)tmp;
  }
#line 729
  if (! iptc_filter) {
    {
#line 730
    fatal_error((char *)"iptc_filter_add_range: couldn\'t allocate space for IPTC filter range");
    }
  }
#line 732
  iptc_filter->type = (enum iptc_filter_element_type )1;
#line 733
  iptc_filter->code = (unsigned short )code;
#line 734
  iptc_filter->code2 = (unsigned short )code2;
#line 735
  tmp___0 = iptc_filter_table_filters;
#line 735
  iptc_filter_table_filters = (unsigned short )((int )iptc_filter_table_filters + 1);
#line 735
  *(iptc_filter_table + tmp___0) = iptc_filter;
#line 736
  return;
}
}
#line 738 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_filter_table_reset(void) 
{ 
  register unsigned int i ;

  {
#line 740
  if (iptc_filter_table) {
#line 744
    i = 0U;
    {
#line 744
    while (1) {
      while_continue: /* CIL Label */ ;
#line 744
      if (! (i < (unsigned int )iptc_filter_table_filters)) {
#line 744
        goto while_break;
      }
      {
#line 746
      free((void *)*(iptc_filter_table + i));
#line 747
      *(iptc_filter_table + i) = (struct iptc_filter_match_data *)((void *)0);
#line 744
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 749
    free((void *)iptc_filter_table);
#line 750
    iptc_filter_table = (struct iptc_filter_match_data **)((void *)0);
#line 751
    debug((char *)"iptc_filter_table_reset: %lu IPTC filter(s) unregistered", i);
    }
  }
#line 753
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_filter_table_dump(void) 
{ 
  register unsigned int i ;

  {
#line 757
  if (iptc_filter_table) {
    {
#line 761
    debug((char *)"iptc_filter_table_dump: %lu element(s) follow", (int )iptc_filter_table_filters);
#line 762
    i = 0U;
    }
    {
#line 762
    while (1) {
      while_continue: /* CIL Label */ ;
#line 762
      if (! (i < (unsigned int )iptc_filter_table_filters)) {
#line 762
        goto while_break;
      }
#line 764
      if (*(iptc_filter_table + i)) {
#line 766
        if ((unsigned int )(*(iptc_filter_table + i))->type == 0U) {
          {
#line 767
          debug((char *)"iptc_filter_table_dump: 0x%04x", (int )(*(iptc_filter_table + i))->code);
          }
        } else {
          {
#line 770
          debug((char *)"iptc_filter_table_dump: 0x%04x-0x%04x", (int )(*(iptc_filter_table + i))->code,
                (int )(*(iptc_filter_table + i))->code2);
          }
        }
      } else {
        {
#line 774
        error((char *)"iptc_filter_table_dump: invalid NULL table element at offset %lu",
              i);
        }
      }
#line 762
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 777
  return;
}
}
#line 779 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
bool iptc_filter_match(unsigned int code ) 
{ 
  bool keep ;
  register unsigned int i ;
  bool matched ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 787
  if (! (prefs.filter_mode & 2)) {
#line 787
    if (! (prefs.filter_mode & 1)) {
#line 794
      keep = (bool )1;
    } else {
#line 787
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 801
    i = 0U;
#line 802
    matched = (bool )0;
    {
#line 803
    while (1) {
      while_continue: /* CIL Label */ ;
#line 803
      if (! (i < (unsigned int )iptc_filter_table_filters)) {
#line 803
        goto while_break;
      }
#line 805
      if ((unsigned int )(*(iptc_filter_table + i))->type == 0U) {
#line 807
        if ((unsigned int )(*(iptc_filter_table + i))->code == code) {
#line 809
          matched = (bool )1;
#line 810
          goto while_break;
        }
      } else
#line 814
      if ((unsigned int )(*(iptc_filter_table + i))->code <= code) {
#line 814
        if (code <= (unsigned int )(*(iptc_filter_table + i))->code2) {
#line 816
          matched = (bool )1;
#line 817
          goto while_break;
        }
      }
#line 819
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 821
    if (prefs.filter_mode & 2) {
#line 821
      keep = (bool )(! matched);
    } else {
#line 821
      keep = matched;
    }
#line 822
    if (matched) {
#line 822
      tmp = "";
    } else {
#line 822
      tmp = "not ";
    }
#line 822
    if (keep) {
#line 822
      tmp___0 = "keep";
    } else {
#line 822
      tmp___0 = "filter out";
    }
    {
#line 822
    debug((char *)"IPTC filter: record code 0x%04x to %s (filter mask %smatched)",
          code, tmp___0, tmp);
    }
  }
#line 825
  return (keep);
}
}
#line 828 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_filters(void) 
{ 


  {
#line 830
  return (iptc_filter_table_filters);
}
}
#line 833 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_edit_list_init(void) 
{ 


  {
#line 835
  iptc_edit_list = (struct iptc_edit_list_cell *)((void *)0);
#line 836
  iptc_edit_list_edits = (unsigned short)0;
#line 837
  return;
}
}
#line 839 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_edit_add_edit(unsigned int code , size_t len , unsigned char *data , bool *data_in_use ) 
{ 
  struct iptc_edit_list_cell *new_cell ;
  struct iptc_edit_list_cell *cell ;
  struct iptc_edit_list_cell *prev ;
  struct iptc_edit_data *iptc_edit ;
  struct iptc_code_descr *code_descr ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 851
  debug((char *)"IPTC filter edit (%u edit(s)): 0x%04x, %lu byte(s)", (int )iptc_edit_list_edits,
        code, len);
#line 854
  code_descr = iptc_match_code((enum IPTC_CODE  const  )code);
  }
#line 855
  if (code_descr) {
#line 858
    if ((unsigned int )code_descr->fixed_length == 1U) {
#line 860
      if (code_descr->length != 0L) {
#line 860
        if ((size_t )code_descr->length != len) {
          {
#line 862
          error((char *)"IPTC filter edit: dataset value length to add (%lu byte(s)) doesn\'t match the size restriction for record 0x%04x (expected exactly %lu byte(s)), record skipped",
                len, code, code_descr->length);
#line 864
          *data_in_use = (bool )0;
          }
#line 865
          return;
        }
      }
    } else
#line 870
    if (code_descr->length != 0L) {
#line 870
      if ((size_t )code_descr->length < len) {
        {
#line 872
        error((char *)"IPTC filter edit: dataset value length to add (%lu byte(s)) doesn\'t match the size restriction for record 0x%04x (expected max %lu byte(s)), record skipped",
              len, code, code_descr->length);
#line 874
        *data_in_use = (bool )0;
        }
#line 875
        return;
      }
    }
  } else {
    {
#line 880
    warning((char *)"IPTC filter edit: attempting to add a non-standard IPTC dataset (record 0x%04x)",
            code);
    }
  }
#line 882
  if (len > 32767UL) {
    {
#line 884
    error((char *)"IPTC filter edit: adding extended IPTC datasets (record 0x%04x, size > 32767) is not yet supported, record skipped",
          code, len);
#line 886
    *data_in_use = (bool )0;
    }
#line 887
    return;
  }
  {
#line 891
  tmp = malloc(sizeof(struct iptc_edit_data ));
#line 891
  iptc_edit = (struct iptc_edit_data *)tmp;
  }
#line 892
  if (! iptc_edit) {
    {
#line 893
    fatal_error((char *)"IPTC filter edit: couldn\'t allocate space for IPTC edit value");
    }
  }
  {
#line 896
  iptc_edit->enabled = (bool )1;
#line 897
  iptc_edit->code = (unsigned short )code;
#line 898
  iptc_edit->length = len;
#line 899
  iptc_edit->data = data;
#line 901
  tmp___0 = malloc(sizeof(struct iptc_edit_list_cell ));
#line 901
  new_cell = (struct iptc_edit_list_cell *)tmp___0;
  }
#line 902
  if (! new_cell) {
    {
#line 903
    fatal_error((char *)"IPTC filter edit: couldn\'t allocate space for IPTC edit list cell");
    }
  }
#line 904
  new_cell->edit_data = iptc_edit;
#line 907
  prev = (struct iptc_edit_list_cell *)((void *)0);
#line 908
  cell = iptc_edit_list;
  {
#line 909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if (cell) {
#line 909
      if (cell->edit_data) {
#line 909
        if (! ((unsigned int )(cell->edit_data)->code <= code)) {
#line 909
          goto while_break;
        }
      } else {
#line 909
        goto while_break;
      }
    } else {
#line 909
      goto while_break;
    }
#line 911
    prev = cell;
#line 912
    cell = cell->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  if (prev) {
#line 918
    if (prev->edit_data) {
#line 918
      if ((unsigned int )(prev->edit_data)->code == code) {
#line 918
        if ((int )(prev->edit_data)->code == 1) {
          {
#line 922
          error((char *)"IPTC filter edit: record 0x%04x is not repeatable and there\'s already a filter edit registered for it, record skipped",
                code);
#line 924
          free((void *)new_cell);
#line 925
          new_cell = (struct iptc_edit_list_cell *)((void *)0);
#line 926
          free((void *)iptc_edit->data);
#line 927
          iptc_edit->data = (unsigned char *)((void *)0);
#line 928
          free((void *)iptc_edit);
#line 929
          iptc_edit = (struct iptc_edit_data *)((void *)0);
#line 930
          *data_in_use = (bool )0;
          }
#line 931
          return;
        }
      }
    }
#line 934
    new_cell->next = prev->next;
#line 935
    prev->next = new_cell;
  } else {
#line 939
    new_cell->next = cell;
#line 940
    iptc_edit_list = new_cell;
  }
#line 943
  iptc_edit_list_edits = (unsigned short )((int )iptc_edit_list_edits + 1);
#line 944
  *data_in_use = (bool )1;
#line 945
  return;
}
}
#line 947 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_edit_list_reset(void) 
{ 
  struct iptc_edit_list_cell *cell ;
  struct iptc_edit_list_cell *next ;

  {
#line 949
  if (iptc_edit_list) {
#line 954
    cell = iptc_edit_list;
    {
#line 954
    while (1) {
      while_continue: /* CIL Label */ ;
#line 954
      if (! cell) {
#line 954
        goto while_break;
      }
#line 956
      if (cell->edit_data) {
#line 958
        if ((cell->edit_data)->enabled) {
          {
#line 959
          warning((char *)"iptc_edit_list_reset: record 0x%04x has not been added. This might be because you\'re attempting to add IPTC records to a file that doesn\'t contain any IPTC chunk",
                  (int )(cell->edit_data)->code);
          }
        }
#line 961
        if ((cell->edit_data)->data) {
          {
#line 963
          free((void *)(cell->edit_data)->data);
#line 964
          (cell->edit_data)->data = (unsigned char *)((void *)0);
          }
        }
        {
#line 966
        free((void *)cell->edit_data);
#line 967
        cell->edit_data = (struct iptc_edit_data *)((void *)0);
        }
      } else {
        {
#line 970
        error((char *)"iptc_edit_list_reset: invalid NULL edit_data in cell %p", cell);
        }
      }
      {
#line 971
      next = cell->next;
#line 972
      free((void *)cell);
#line 973
      cell = (struct iptc_edit_list_cell *)((void *)0);
#line 954
      cell = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 975
    iptc_edit_list = (struct iptc_edit_list_cell *)((void *)0);
#line 976
    iptc_edit_list_edits = (unsigned short)0;
#line 977
    debug((char *)"iptc_edit_list_reset: all IPTC edit(s) have been unregistered");
    }
  }
#line 979
  return;
}
}
#line 981 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
void iptc_edit_list_dump(void) 
{ 
  struct iptc_edit_list_cell *cell ;
  unsigned int i ;

  {
  {
#line 983
  debug((char *)"iptc_edit_list_dump: %lu element(s) follow(s)", (int )iptc_edit_list_edits);
  }
#line 984
  if (iptc_edit_list) {
#line 989
    i = 0U;
#line 990
    cell = iptc_edit_list;
    {
#line 990
    while (1) {
      while_continue: /* CIL Label */ ;
#line 990
      if (! cell) {
#line 990
        goto while_break;
      }
#line 992
      if (cell->edit_data) {
        {
#line 993
        debug((char *)"iptc_edit_list_dump: 0x%04x, length: %lu", (int )(cell->edit_data)->code,
              (cell->edit_data)->length);
        }
      } else {
        {
#line 996
        error((char *)"iptc_edit_list_dump: invalid NULL edit_data in cell %p", cell);
        }
      }
#line 997
      i ++;
#line 990
      cell = cell->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 999
    if (i != (unsigned int )iptc_edit_list_edits) {
      {
#line 1000
      error((char *)"iptc_edit_list_dump: list inconsistency: counted %u cell(s), expected %u",
            i, (int )iptc_edit_list_edits);
      }
    }
  }
#line 1003
  return;
}
}
#line 1005 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
unsigned short iptc_edits(void) 
{ 


  {
#line 1007
  return (iptc_edit_list_edits);
}
}
#line 1010 "/home/wheatley/newnew/temp/pecomato-0.0.15/iptc.c"
size_t iptc_edit_insert_chunks(bool flush , unsigned int code , unsigned short *iptc_datasets_history ) 
{ 
  size_t written_bytes ;
  struct iptc_edit_list_cell *cell ;
  struct iptc_edit_data *edit_data ;
  unsigned char dataset_header[7] ;
  unsigned char *ptr ;
  struct iptc_code_descr *code_descr ;
  bool store_it ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  size_t tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
#line 1015
  written_bytes = (size_t )0;
#line 1017
  if (iptc_edit_list) {
#line 1024
    if (flush) {
      {
#line 1025
      debug((char *)"iptc_edit_insert_chunks: about to add all IPTC datasets remaining in filter edit list");
      }
    } else {
      {
#line 1027
      debug((char *)"iptc_edit_insert_chunks: about to add all IPTC datasets with record code < 0x%04x",
            code);
      }
    }
#line 1030
    cell = iptc_edit_list;
    {
#line 1030
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1030
      if (! cell) {
#line 1030
        goto while_break;
      }
#line 1032
      edit_data = cell->edit_data;
#line 1033
      if (edit_data) {
#line 1035
        if (edit_data->enabled) {
#line 1035
          if (flush) {
#line 1035
            goto _L;
          } else
#line 1035
          if ((unsigned int )edit_data->code < code) {
            _L: /* CIL Label */ 
            {
#line 1038
            store_it = (bool )1;
#line 1040
            code_descr = iptc_match_code((enum IPTC_CODE  const  )edit_data->code);
            }
#line 1041
            if (code_descr) {
#line 1044
              if ((int )*(iptc_datasets_history + edit_data->code) != 0) {
#line 1044
                if ((unsigned int )code_descr->repeatable == 1U) {
                  {
#line 1047
                  error((char *)"iptc_edit_insert_chunks: attempting to add an IPTC record that already exist (it\'s not repeatable): 0x%04x, record skipped",
                        (int )edit_data->code);
#line 1049
                  store_it = (bool )0;
                  }
                }
              }
#line 1052
              if ((unsigned int )code_descr->fixed_length == 1U) {
#line 1054
                if (code_descr->length != 0L) {
#line 1054
                  if ((size_t )code_descr->length != edit_data->length) {
                    {
#line 1056
                    error((char *)"iptc_edit_insert_chunks: dataset value length to add (%lu byte(s)) doesn\'t match the size restriction for record 0x%04x (expected exactly %lu byte(s)), record skipped",
                          edit_data->length, code, code_descr->length);
#line 1058
                    store_it = (bool )0;
                    }
                  }
                }
              } else
#line 1063
              if (code_descr->length != 0L) {
#line 1063
                if ((size_t )code_descr->length < edit_data->length) {
                  {
#line 1065
                  error((char *)"iptc_edit_insert_chunks: dataset value length to add (%lu byte(s)) doesn\'t match the size restriction for record 0x%04x (expected max %lu byte(s)), record skipped",
                        edit_data->length, code, code_descr->length);
#line 1067
                  store_it = (bool )0;
                  }
                }
              }
            } else {
              {
#line 1074
              warning((char *)"iptc_edit_insert_chunks: adding non standard IPTC record 0x%04x",
                      (int )edit_data->code);
              }
            }
#line 1079
            if (edit_data->length > 32767UL) {
              {
#line 1081
              error((char *)"iptc_edit_insert_chunks: adding extended IPTC datasets (length > 32767) is not supported yet, record skipped");
#line 1082
              store_it = (bool )0;
              }
            }
#line 1086
            if (store_it) {
#line 1089
              if (((int )edit_data->code & 255) != 0) {
#line 1089
                if (256 <= ((int )edit_data->code & 65280)) {
#line 1089
                  if (((int )edit_data->code & 65280) <= 768) {
#line 1089
                    if ((int )*(iptc_datasets_history + ((int )edit_data->code & 65280)) == 0) {
                      {
#line 1093
                      warning((char *)"iptc_edit_insert_chunks: no IPTC version record already exist for 0x%04x, adding record code 0x%04x",
                              (int )edit_data->code, (int )edit_data->code & 65280);
#line 1095
                      ptr = dataset_header;
#line 1096
                      tmp = ptr;
#line 1096
                      ptr ++;
#line 1096
                      *tmp = (unsigned char)28;
#line 1097
                      tmp___0 = ptr;
#line 1097
                      ptr ++;
#line 1097
                      *tmp___0 = (unsigned char )(((int )edit_data->code & 65280) >> 8);
#line 1098
                      tmp___1 = ptr;
#line 1098
                      ptr ++;
#line 1098
                      *tmp___1 = (unsigned char)0;
#line 1099
                      tmp___2 = ptr;
#line 1099
                      ptr ++;
#line 1099
                      *tmp___2 = (unsigned char)0;
#line 1100
                      tmp___3 = ptr;
#line 1100
                      ptr ++;
#line 1100
                      *tmp___3 = (unsigned char)2;
#line 1101
                      tmp___4 = ptr;
#line 1101
                      ptr ++;
#line 1101
                      *tmp___4 = (unsigned char)0;
#line 1102
                      tmp___5 = ptr;
#line 1102
                      ptr ++;
#line 1102
                      *tmp___5 = (unsigned char)2;
#line 1103
                      tmp___6 = dump_rewrite(dataset_header, 7UL);
#line 1103
                      written_bytes += tmp___6;
#line 1104
                      iptc_stats_table_inc((unsigned int )((int )edit_data->code & 65280),
                                           iptc_datasets_history);
                      }
                    }
                  }
                }
              }
              {
#line 1107
              ptr = dataset_header;
#line 1108
              tmp___7 = ptr;
#line 1108
              ptr ++;
#line 1108
              *tmp___7 = (unsigned char)28;
#line 1109
              tmp___8 = ptr;
#line 1109
              ptr ++;
#line 1109
              *tmp___8 = (unsigned char )(((int )edit_data->code & 65280) >> 8);
#line 1110
              tmp___9 = ptr;
#line 1110
              ptr ++;
#line 1110
              *tmp___9 = (unsigned char )((int )edit_data->code & 255);
#line 1111
              tmp___10 = ptr;
#line 1111
              ptr ++;
#line 1111
              *tmp___10 = (unsigned char )((edit_data->length & 65280UL) >> 8);
#line 1112
              tmp___11 = ptr;
#line 1112
              ptr ++;
#line 1112
              *tmp___11 = (unsigned char )(edit_data->length & 255UL);
#line 1113
              tmp___12 = dump_rewrite(dataset_header, 5UL);
#line 1113
              written_bytes += tmp___12;
#line 1114
              tmp___13 = dump_rewrite(edit_data->data, edit_data->length);
#line 1114
              written_bytes += tmp___13;
#line 1115
              iptc_stats_table_inc((unsigned int )edit_data->code, iptc_datasets_history);
#line 1116
              debug((char *)"iptc_edit_insert_chunks: IPTC dataset added (record 0x%04x, %lu byte(s))",
                    (int )edit_data->code, edit_data->length);
              }
            } else {
              {
#line 1120
              debug((char *)"iptc_edit_insert_chunks: IPTC dataset NOT added (record 0x%04x), see error above",
                    (int )edit_data->code);
              }
            }
#line 1124
            edit_data->enabled = (bool )0;
          }
        }
      } else {
        {
#line 1128
        error((char *)"iptc_edit_insert_chunks: invalid NULL edit_data in cell %p",
              cell);
        }
      }
#line 1030
      cell = cell->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1132
  return (written_bytes);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 329 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
size_t fsize(FILE *file ) ;
#line 330
bool fexist(char const   *filename ) ;
#line 331
int frename(char const   *source_filename , char const   *target_filename ) ;
#line 335
bool fisdir(char const   *filename ) ;
#line 337
char *fbasename(char const   *path ) ;
#line 338
char *ffilename(char const   *path ) ;
#line 339
char *fdirname(char const   *path ) ;
#line 340
char *fcleanpath(char const   *path ) ;
#line 343
void backup_file(char const   *filename ) ;
#line 351
unsigned char *getstring(unsigned char *ptr , unsigned long offset , unsigned char *buf ,
                         unsigned long const   len ) ;
#line 371
void context_set_text(char *text ) ;
#line 373
void context_print_info(void) ;
#line 374
void context_reset(void) ;
#line 377
struct op_label *op_match_label(char *label ) ;
#line 380
void init_rewrite(void) ;
#line 382
void post_rewrite(unsigned char *buffer , struct parser_result *result ) ;
#line 385
bool get_unsigned_value(char const   *param , unsigned long *var ) ;
#line 394
void filter_load_line(char *buffer ) ;
#line 395
void filter_load_file(FILE *list_file ) ;
#line 399
void edit_load_line(char const   *buffer ) ;
#line 400
void edit_load_file(FILE *list_file ) ;
#line 406
void filenames_list_load(char ***filenames_list_ptr , int *filenames_count_ptr , FILE *list_file ) ;
#line 108 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.h"
void jfif_parse(unsigned char *buffer , unsigned long const   bytes_left , struct parser_result *result ) ;
#line 87 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.h"
void adobe_8bps_parse(unsigned char *buffer , unsigned long bytes_left , struct parser_result *result ) ;
#line 88
void adobe_ffo_parse(unsigned char *buffer , unsigned long bytes_left , unsigned short const   photoshop_version ,
                     struct parser_result *result ) ;
#line 89
void adobe_8bim_parse(unsigned char *buffer , unsigned long bytes_left , unsigned short const   photoshop_version ,
                      struct parser_result *result ) ;
#line 25 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
struct op_label op_labels[6] ;
#line 26
struct log_level_descr log_levels[6] ;
#line 27
struct exit_code_label exit_code_labels[7] ;
#line 30
unsigned long rewrite_cache_size ;
#line 31
FILE *output_file ;
#line 32
char *output_filename ;
#line 33
size_t input_length ;
#line 39 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
struct prefs_struct prefs  ;
#line 40 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
char *program_name  ;
#line 42 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
char *default_iptc_extension  =    (char *)"iptc";
#line 46 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
void version(void) 
{ 


  {
  {
#line 48
  printf((char const   */* __restrict  */)"pecomato 0.0.15\n");
#line 49
  exit(0);
  }
}
}
#line 52 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
void usage(enum EXIT_CODE ret ) 
{ 
  char spaces[19] ;
  int i ;
  int j ;
  size_t tmp ;

  {
  {
#line 58
  printf((char const   */* __restrict  */)"usage:\n");
#line 59
  printf((char const   */* __restrict  */)"    %s [<option> ..] <op> [<expr>] <file> [<file> ..]\n",
         program_name);
#line 60
  printf((char const   */* __restrict  */)"    %s [<option> ..] <op> [<expr>] @<file>\n",
         program_name);
#line 61
  printf((char const   */* __restrict  */)"usage of form <op> <expr> .. only concerns op mode dump-value, see below.\n");
#line 63
  printf((char const   */* __restrict  */)"\n");
#line 64
  printf((char const   */* __restrict  */)"iuse @<file> to read a list of files from that file. the file must contain exactly\n");
#line 65
  printf((char const   */* __restrict  */)"one filename to process per line (don\'t escape anything, filenames are taken as-is).\n");
#line 68
  printf((char const   */* __restrict  */)"\n");
#line 69
  printf((char const   */* __restrict  */)"general options:\n");
#line 70
  printf((char const   */* __restrict  */)"    -v --version          show version number then exit\n");
#line 71
  printf((char const   */* __restrict  */)"    -h --help             show this help then exit\n");
#line 72
  printf((char const   */* __restrict  */)"       --list             list all supported embedded data structures\n");
#line 73
  printf((char const   */* __restrict  */)"    -l --log-level <num>  define verbosity (see possible values below)\n");
#line 74
  printf((char const   */* __restrict  */)"    -c --check-compliance perform full checks to test the strict validity and\n");
#line 75
  printf((char const   */* __restrict  */)"                          compliance of structures to official formats\n");
#line 77
  printf((char const   */* __restrict  */)"\n");
#line 78
  printf((char const   */* __restrict  */)"filtering and extracting options:\n");
#line 79
  printf((char const   */* __restrict  */)"    -b --backup           create backup files of (re)written files if necessary\n");
#line 80
  printf((char const   */* __restrict  */)"    -d --target-dir <dir> target directory for all written files\n");
#line 81
  printf((char const   */* __restrict  */)"    -f --fix              fix metadata inconsistencies when possible\n");
#line 83
  printf((char const   */* __restrict  */)"\n");
#line 84
  printf((char const   */* __restrict  */)"extracting options:\n");
#line 85
  printf((char const   */* __restrict  */)"    -x --extract <type>   extract and save metadata to a standalone file (see\n");
#line 86
  printf((char const   */* __restrict  */)"                          below for a list of metadata that can be extracted)\n");
#line 87
  printf((char const   */* __restrict  */)"    -t --ext <extension>  define what filename extension to use when writing\n");
#line 88
  printf((char const   */* __restrict  */)"                          metadata that is extracted (default: .%s)\n",
         default_iptc_extension);
#line 92
  printf((char const   */* __restrict  */)"    -a --append-ext       append extension to original filename when saving\n");
#line 93
  printf((char const   */* __restrict  */)"                          the extracted metadata (default: replace original file\n");
#line 94
  printf((char const   */* __restrict  */)"                          extension)\n");
#line 96
  printf((char const   */* __restrict  */)"\n");
#line 97
  printf((char const   */* __restrict  */)"filtering options:\n");
#line 98
  printf((char const   */* __restrict  */)"    -i --include <expr>   a filter expression describing the datasets to keep\n");
#line 99
  printf((char const   */* __restrict  */)"    -i --include @<file>  or a file containing a list of datasets to keep,\n");
#line 100
  printf((char const   */* __restrict  */)"                          all other datasets will be filtered out.\n");
#line 101
  printf((char const   */* __restrict  */)"                          if not used, all datasets will be kept\n");
#line 102
  printf((char const   */* __restrict  */)"    -e --exclude <expr>   a filter expression describing the datasets to filter out\n");
#line 103
  printf((char const   */* __restrict  */)"    -e --exclude @<file>  or a file containing a list of datasets to filter out,\n");
#line 104
  printf((char const   */* __restrict  */)"                          all other datasets will be kept. if not used all\n");
#line 105
  printf((char const   */* __restrict  */)"                          datasets will be kept\n");
#line 106
  printf((char const   */* __restrict  */)"       --edit <expr>      a filter edit expression describing the datasets to add\n");
#line 107
  printf((char const   */* __restrict  */)"       --edit @<file>     or a file containing a list of datasets to add.\n");
#line 108
  printf((char const   */* __restrict  */)"                          datasets won\'t be inserted if that breaks compliance\n");
#line 109
  printf((char const   */* __restrict  */)"                          to the standards\n");
#line 110
  printf((char const   */* __restrict  */)"       --test             don\'t override original file(s), create *.rewrite file(s)\n");
#line 111
  printf((char const   */* __restrict  */)"                          instead\n");
#line 116
  printf((char const   */* __restrict  */)"-i and -e can\'t be mixed together. --edit can be used in conjonction to -i or -e,\n");
#line 117
  printf((char const   */* __restrict  */)"in that case, the edits will be processed after the include or exclude filter.\n");
#line 119
  printf((char const   */* __restrict  */)"\n");
#line 120
  printf((char const   */* __restrict  */)"dump options:\n");
#line 121
  printf((char const   */* __restrict  */)"    -w --wrap <num>       max column for wrapping (num must be in range\n");
#line 122
  printf((char const   */* __restrict  */)"                          [%d-%d]). default is to dump unwrapped\n",
         8, 1024);
#line 126
  printf((char const   */* __restrict  */)"\n");
#line 127
  printf((char const   */* __restrict  */)"possible ops:\n");
#line 128
  i = 0;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! ((unsigned int )op_labels[i].op != 5U)) {
#line 129
      goto while_break;
    }
#line 133
    j = 0;
    {
#line 133
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 133
      tmp = strlen((char const   *)op_labels[i].label);
      }
#line 133
      if (! (j < (int )(18UL - tmp))) {
#line 133
        goto while_break___0;
      }
#line 134
      spaces[j] = (char )' ';
#line 133
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 135
    spaces[j] = (char )'\000';
#line 136
    printf((char const   */* __restrict  */)"    %s%s%s\n", op_labels[i].label, spaces,
           op_labels[i].description);
#line 137
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  printf((char const   */* __restrict  */)"\n");
#line 142
  printf((char const   */* __restrict  */)"dump-value expressions:\n");
#line 143
  printf((char const   */* __restrict  */)"    IPTC.<record>\n");
#line 144
  printf((char const   */* __restrict  */)"same as filter include/exclude expression, see below:\n");
#line 147
  printf((char const   */* __restrict  */)"\n");
#line 148
  printf((char const   */* __restrict  */)"filter include/exclude expressions:\n");
#line 149
  printf((char const   */* __restrict  */)"    IPTC.<record>\n");
#line 150
  printf((char const   */* __restrict  */)"where <record> can be either:\n");
#line 151
  printf((char const   */* __restrict  */)"    all:               *\n");
#line 152
  printf((char const   */* __restrict  */)"    hexadecimal unary: 0xhhhh\n");
#line 153
  printf((char const   */* __restrict  */)"    hexadecimal range: 0xhhhh-0xhhhh\n");
#line 154
  printf((char const   */* __restrict  */)"    decimal unary:     nnn:nnn\n");
#line 155
  printf((char const   */* __restrict  */)"    decimal ranges:    nnn:nnn-nnn\n");
#line 156
  printf((char const   */* __restrict  */)"                       nnn:*\n");
#line 157
  printf((char const   */* __restrict  */)"examples:\n");
#line 158
  printf((char const   */* __restrict  */)"    IPTC.0x0219\n");
#line 159
  printf((char const   */* __restrict  */)"    IPTC.0x0300-0x0364\n");
#line 160
  printf((char const   */* __restrict  */)"    IPTC.3:0-100\n");
#line 163
  printf((char const   */* __restrict  */)"\n");
#line 164
  printf((char const   */* __restrict  */)"filter edit expressions:\n");
#line 165
  printf((char const   */* __restrict  */)"    IPTC.<record>=<type>:<value>\n");
#line 166
  printf((char const   */* __restrict  */)"where <record> can be either:\n");
#line 167
  printf((char const   */* __restrict  */)"    hexadecimal unary: 0xhhhh\n");
#line 168
  printf((char const   */* __restrict  */)"    decimal unary:     nnn:nnn\n");
#line 169
  printf((char const   */* __restrict  */)"where <type> can be either:\n");
#line 170
  printf((char const   */* __restrict  */)"    hex\n");
#line 171
  printf((char const   */* __restrict  */)"    text\n");
#line 172
  printf((char const   */* __restrict  */)"and <value> is:\n");
#line 173
  printf((char const   */* __restrict  */)"    hex:  [a-zA-Z0-9] pairs\n");
#line 174
  printf((char const   */* __restrict  */)"    text: any char (even widechars) on the line is taken as text, until\n");
#line 175
  printf((char const   */* __restrict  */)"          a newline is found\n");
#line 176
  printf((char const   */* __restrict  */)"examples:\n");
#line 177
  printf((char const   */* __restrict  */)"    IPTC.0x0200=hex:0002\n");
#line 178
  printf((char const   */* __restrict  */)"    IPTC.0x0219=text:this is a keyword\n");
#line 181
  printf((char const   */* __restrict  */)"\n");
#line 182
  printf((char const   */* __restrict  */)"supported metadata for extraction:\n");
#line 183
  printf((char const   */* __restrict  */)"    iptc   IPTC datasets\n");
#line 187
  printf((char const   */* __restrict  */)"\n");
#line 188
  printf((char const   */* __restrict  */)"possible log levels:\n");
#line 189
  i = 0;
  }
  {
#line 190
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 190
    if (! ((unsigned int )log_levels[i].level != 5U)) {
#line 190
      goto while_break___1;
    }
    {
#line 192
    printf((char const   */* __restrict  */)"   %2d   %s\n", i, log_levels[i].description);
#line 193
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 197
  printf((char const   */* __restrict  */)"\n");
#line 198
  printf((char const   */* __restrict  */)"supported input files:\n");
#line 199
  printf((char const   */* __restrict  */)"    JPEG files (commonly .jpeg, .jpg, .jpe, .jfif, .jif)\n");
#line 200
  printf((char const   */* __restrict  */)"    Adobe Photoshop files (commonly .psd, .pdd, .ffo)\n");
#line 201
  printf((char const   */* __restrict  */)"    FotoStation files (commonly .fdp, .ipt)\n");
#line 202
  printf((char const   */* __restrict  */)"    standalone IPTC metadata (commonly .iptc)\n");
#line 206
  printf((char const   */* __restrict  */)"\n");
#line 207
  printf((char const   */* __restrict  */)"exit codes:\n");
#line 208
  i = 0;
  }
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! ((unsigned int )exit_code_labels[i].code != 6U)) {
#line 209
      goto while_break___2;
    }
    {
#line 211
    printf((char const   */* __restrict  */)"    %d %s\n", (unsigned int )exit_code_labels[i].code,
           exit_code_labels[i].label);
#line 212
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 215
  exit((int )ret);
  }
}
}
#line 218 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
void signal_handler(int sig ) 
{ 


  {
  {
#line 220
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"signal %d received\n",
          sig);
#line 221
  fflush(stderr);
#line 222
  _exit(2);
  }
}
}
#line 225 "/home/wheatley/newnew/temp/pecomato-0.0.15/main.c"
int main(int argc , char **argv ) 
{ 
  char **filenames_list ;
  unsigned char tmp[7] ;
  struct parser_result result ;
  FILE *input_file ;
  unsigned char *buffer ;
  char *ptr ;
  char *input_filename ;
  char *include_expression ;
  char *exclude_expression ;
  char *edit_expression ;
  char *extract_extension ;
  char *target_dirname ;
  char *iptc_filename ;
  char *op ;
  char *arg ;
  char *dump_value ;
  size_t ret ;
  enum EXIT_CODE exit_code ;
  int filenames_count ;
  int i ;
  size_t tmp___0 ;
  unsigned long value ;
  bool tmp___1 ;
  int tmp___2 ;
  unsigned long value___0 ;
  bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct op_label *label ;
  int tmp___34 ;
  int tmp___35 ;
  FILE *list_file ;
  char *filename ;
  int err ;
  int *tmp___36 ;
  bool tmp___37 ;
  bool tmp___38 ;
  FILE *include_file ;
  char *include_filename ;
  FILE *exclude_file ;
  char *exclude_filename ;
  unsigned short tmp___39 ;
  FILE *edit_file ;
  char *edit_filename ;
  unsigned short tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  bool proceed ;
  char *pathname ;
  char *filename___0 ;
  size_t sz ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  void *tmp___46 ;
  char *pathname___0 ;
  char *filename___1 ;
  size_t sz___0 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  void *tmp___50 ;
  int tmp___51 ;
  void *tmp___52 ;
  int *tmp___53 ;
  int tmp___54 ;
  char const   *tmp___56 ;
  bool tmp___57 ;
  char const   *tmp___59 ;
  bool tmp___60 ;
  unsigned char tmp___61 ;
  unsigned char tmp___62 ;
  unsigned char *tmp___63 ;
  int tmp___64 ;
  unsigned short tmp___65 ;
  unsigned char *tmp___66 ;
  int tmp___67 ;
  unsigned long tmp___68 ;
  unsigned long tmp___69 ;
  unsigned long tmp___70 ;
  unsigned long tmp___71 ;
  unsigned long tmp___72 ;
  unsigned char *tmp___73 ;
  int tmp___74 ;
  unsigned char *tmp___75 ;
  int tmp___76 ;
  unsigned char *tmp___77 ;
  int tmp___78 ;
  int err___0 ;
  size_t len ;
  char *rewrite_filename ;
  size_t len___0 ;
  size_t tmp___79 ;
  void *tmp___80 ;
  char *target_filename ;
  size_t tmp___81 ;
  FILE *iptc_file ;
  unsigned long len___1 ;
  int *tmp___82 ;

  {
  {
#line 266
  prefs.log_level = (enum LOG_LEVEL )2;
#line 267
  prefs.technical = (bool )0;
#line 268
  prefs.warnings = 0UL;
#line 269
  prefs.errors = 0UL;
#line 270
  prefs.fixes = 0UL;
#line 271
  prefs.wrap_dump = (unsigned short)0;
#line 272
  prefs.rewrite = (bool )0;
#line 273
  prefs.rewrite_create_backup = (bool )0;
#line 274
  prefs.filter_mode = 0;
#line 275
  prefs.test_rewrite = (bool )0;
#line 279
  prefs.rewrite_cached = (bool )0;
#line 281
  prefs.extract_iptc = (bool )0;
#line 282
  prefs.extract_extension_append = (bool )0;
#line 283
  prefs.fix = (bool )0;
#line 285
  context_reset();
#line 286
  input_filename = (char *)((void *)0);
#line 287
  output_filename = (char *)((void *)0);
#line 288
  iptc_filename = (char *)((void *)0);
#line 289
  include_expression = (char *)((void *)0);
#line 290
  exclude_expression = (char *)((void *)0);
#line 291
  edit_expression = (char *)((void *)0);
#line 292
  extract_extension = (char *)((void *)0);
#line 293
  target_dirname = (char *)((void *)0);
#line 294
  input_file = (FILE *)((void *)0);
#line 295
  output_file = (FILE *)((void *)0);
#line 296
  rewrite_cache = (unsigned char *)((void *)0);
#line 297
  rewrite_cache_offset = 0UL;
#line 298
  rewrite_cache_size = 0UL;
#line 299
  iptc_extract_buffer = (unsigned char *)((void *)0);
#line 300
  iptc_extract_buffer_size = 0UL;
#line 301
  buffer = (unsigned char *)((void *)0);
#line 302
  filenames_list = (char **)((void *)0);
#line 303
  filenames_count = 0;
#line 304
  dump_value = (char *)((void *)0);
#line 310
  ptr = *argv;
#line 311
  tmp___0 = strlen((char const   *)ptr);
#line 311
  ptr += tmp___0 - 1UL;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! ((unsigned long )ptr > (unsigned long )*argv)) {
#line 312
      goto while_break;
    }
#line 313
    if ((int )*ptr == 47) {
#line 316
      ptr ++;
#line 317
      goto while_break;
    } else {
#line 320
      ptr --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  program_name = ptr;
#line 325
  argc --;
#line 326
  i = 1;
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! (i <= argc)) {
#line 326
      goto while_break___0;
    }
    {
#line 328
    arg = *(argv + i);
#line 329
    tmp___32 = strcmp((char const   *)arg, "--help");
    }
#line 329
    if (tmp___32 == 0) {
      {
#line 330
      usage((enum EXIT_CODE )0);
      }
    } else {
      {
#line 329
      tmp___33 = strcmp((char const   *)arg, "-h");
      }
#line 329
      if (tmp___33 == 0) {
        {
#line 330
        usage((enum EXIT_CODE )0);
        }
      } else {
        {
#line 332
        tmp___30 = strcmp((char const   *)arg, "--version");
        }
#line 332
        if (tmp___30 == 0) {
          {
#line 333
          version();
          }
        } else {
          {
#line 332
          tmp___31 = strcmp((char const   *)arg, "-v");
          }
#line 332
          if (tmp___31 == 0) {
            {
#line 333
            version();
            }
          } else {
            {
#line 335
            tmp___29 = strcmp((char const   *)arg, "--list");
            }
#line 335
            if (tmp___29 == 0) {
              {
#line 337
              iptc_dump_list();
#line 338
              exit(0);
              }
            } else {
              {
#line 341
              tmp___27 = strcmp((char const   *)arg, "--log-level");
              }
#line 341
              if (tmp___27 == 0) {
#line 341
                goto _L___5;
              } else {
                {
#line 341
                tmp___28 = strcmp((char const   *)arg, "-l");
                }
#line 341
                if (tmp___28 == 0) {
                  _L___5: /* CIL Label */ 
#line 343
                  if (i < argc) {
                    {
#line 347
                    i ++;
#line 348
                    tmp___1 = get_unsigned_value((char const   *)*(argv + i), & value);
                    }
#line 348
                    if (tmp___1) {
#line 350
                      if ((int )value < 0) {
                        {
#line 352
                        error((char *)"invalid log level value %d, not in range [%d-%d]",
                              value, 0, 4);
#line 354
                        usage((enum EXIT_CODE )1);
                        }
                      } else
#line 350
                      if ((int )value > 4) {
                        {
#line 352
                        error((char *)"invalid log level value %d, not in range [%d-%d]",
                              value, 0, 4);
#line 354
                        usage((enum EXIT_CODE )1);
                        }
                      }
#line 356
                      prefs.log_level = (enum LOG_LEVEL )((int )value);
                    } else {
                      {
#line 360
                      error((char *)"invalid value for option \'%s\': %s", arg, *(argv + i));
#line 361
                      usage((enum EXIT_CODE )1);
                      }
                    }
                  } else {
                    {
#line 366
                    error((char *)"missing value to argument \'%s\'", arg);
#line 367
                    usage((enum EXIT_CODE )1);
                    }
                  }
                } else {
                  {
#line 371
                  tmp___25 = strcmp((char const   *)arg, "--check-compliance");
                  }
#line 371
                  if (tmp___25 == 0) {
#line 372
                    prefs.technical = (bool )1;
                  } else {
                    {
#line 371
                    tmp___26 = strcmp((char const   *)arg, "-c");
                    }
#line 371
                    if (tmp___26 == 0) {
#line 372
                      prefs.technical = (bool )1;
                    } else {
                      {
#line 374
                      tmp___23 = strcmp((char const   *)arg, "--extract");
                      }
#line 374
                      if (tmp___23 == 0) {
#line 374
                        goto _L___4;
                      } else {
                        {
#line 374
                        tmp___24 = strcmp((char const   *)arg, "-x");
                        }
#line 374
                        if (tmp___24 == 0) {
                          _L___4: /* CIL Label */ 
#line 376
                          if (i < argc) {
                            {
#line 378
                            i ++;
#line 379
                            tmp___2 = strcasecmp((char const   *)*(argv + i), "iptc");
                            }
#line 379
                            if (tmp___2 == 0) {
#line 380
                              prefs.extract_iptc = (bool )1;
                            } else {
                              {
#line 383
                              error((char *)"unsupported metadata type to argument \'%s\'",
                                    arg);
#line 384
                              usage((enum EXIT_CODE )1);
                              }
                            }
                          } else {
                            {
#line 389
                            error((char *)"missing metadata type to argument \'%s\'",
                                  arg);
#line 390
                            usage((enum EXIT_CODE )1);
                            }
                          }
                        } else {
                          {
#line 394
                          tmp___21 = strcmp((char const   *)arg, "--backup");
                          }
#line 394
                          if (tmp___21 == 0) {
#line 395
                            prefs.rewrite_create_backup = (bool )1;
                          } else {
                            {
#line 394
                            tmp___22 = strcmp((char const   *)arg, "-b");
                            }
#line 394
                            if (tmp___22 == 0) {
#line 395
                              prefs.rewrite_create_backup = (bool )1;
                            } else {
                              {
#line 397
                              tmp___19 = strcmp((char const   *)arg, "--target-dir");
                              }
#line 397
                              if (tmp___19 == 0) {
#line 397
                                goto _L___3;
                              } else {
                                {
#line 397
                                tmp___20 = strcmp((char const   *)arg, "-d");
                                }
#line 397
                                if (tmp___20 == 0) {
                                  _L___3: /* CIL Label */ 
#line 399
                                  if (i < argc) {
                                    {
#line 401
                                    i ++;
#line 402
                                    target_dirname = fcleanpath((char const   *)*(argv + i));
                                    }
                                  } else {
                                    {
#line 406
                                    error((char *)"missing dirname to argument \'%s\'",
                                          arg);
#line 407
                                    usage((enum EXIT_CODE )1);
                                    }
                                  }
                                } else {
                                  {
#line 411
                                  tmp___17 = strcmp((char const   *)arg, "--fix");
                                  }
#line 411
                                  if (tmp___17 == 0) {
#line 412
                                    prefs.fix = (bool )1;
                                  } else {
                                    {
#line 411
                                    tmp___18 = strcmp((char const   *)arg, "-f");
                                    }
#line 411
                                    if (tmp___18 == 0) {
#line 412
                                      prefs.fix = (bool )1;
                                    } else {
                                      {
#line 414
                                      tmp___15 = strcmp((char const   *)arg, "--ext");
                                      }
#line 414
                                      if (tmp___15 == 0) {
#line 414
                                        goto _L___2;
                                      } else {
                                        {
#line 414
                                        tmp___16 = strcmp((char const   *)arg, "-t");
                                        }
#line 414
                                        if (tmp___16 == 0) {
                                          _L___2: /* CIL Label */ 
#line 416
                                          if (i < argc) {
#line 418
                                            i ++;
#line 419
                                            extract_extension = *(argv + i);
                                          } else {
                                            {
#line 423
                                            error((char *)"missing extension to argument \'%s\'",
                                                  arg);
#line 424
                                            usage((enum EXIT_CODE )1);
                                            }
                                          }
                                        } else {
                                          {
#line 428
                                          tmp___13 = strcmp((char const   *)arg, "--append-ext");
                                          }
#line 428
                                          if (tmp___13 == 0) {
#line 429
                                            prefs.extract_extension_append = (bool )1;
                                          } else {
                                            {
#line 428
                                            tmp___14 = strcmp((char const   *)arg,
                                                              "-a");
                                            }
#line 428
                                            if (tmp___14 == 0) {
#line 429
                                              prefs.extract_extension_append = (bool )1;
                                            } else {
                                              {
#line 431
                                              tmp___11 = strcmp((char const   *)arg,
                                                                "--include");
                                              }
#line 431
                                              if (tmp___11 == 0) {
#line 431
                                                goto _L___1;
                                              } else {
                                                {
#line 431
                                                tmp___12 = strcmp((char const   *)arg,
                                                                  "-i");
                                                }
#line 431
                                                if (tmp___12 == 0) {
                                                  _L___1: /* CIL Label */ 
#line 433
                                                  if (i < argc) {
#line 435
                                                    i ++;
#line 436
                                                    include_expression = *(argv + i);
                                                  } else {
                                                    {
#line 440
                                                    error((char *)"missing filename or expression to argument \'%s\'",
                                                          arg);
#line 441
                                                    usage((enum EXIT_CODE )1);
                                                    }
                                                  }
                                                } else {
                                                  {
#line 445
                                                  tmp___9 = strcmp((char const   *)arg,
                                                                   "--exclude");
                                                  }
#line 445
                                                  if (tmp___9 == 0) {
#line 445
                                                    goto _L___0;
                                                  } else {
                                                    {
#line 445
                                                    tmp___10 = strcmp((char const   *)arg,
                                                                      "-e");
                                                    }
#line 445
                                                    if (tmp___10 == 0) {
                                                      _L___0: /* CIL Label */ 
#line 447
                                                      if (i < argc) {
#line 449
                                                        i ++;
#line 450
                                                        exclude_expression = *(argv + i);
                                                      } else {
                                                        {
#line 454
                                                        error((char *)"missing filename or expression to argument \'%s\'",
                                                              arg);
#line 455
                                                        usage((enum EXIT_CODE )1);
                                                        }
                                                      }
                                                    } else {
                                                      {
#line 459
                                                      tmp___8 = strcmp((char const   *)arg,
                                                                       "--edit");
                                                      }
#line 459
                                                      if (tmp___8 == 0) {
#line 461
                                                        if (i < argc) {
#line 463
                                                          i ++;
#line 464
                                                          edit_expression = *(argv + i);
                                                        } else {
                                                          {
#line 468
                                                          error((char *)"missing filename or expression to argument \'%s\'",
                                                                arg);
#line 469
                                                          usage((enum EXIT_CODE )1);
                                                          }
                                                        }
                                                      } else {
                                                        {
#line 473
                                                        tmp___7 = strcmp((char const   *)arg,
                                                                         "--test");
                                                        }
#line 473
                                                        if (tmp___7 == 0) {
#line 474
                                                          prefs.test_rewrite = (bool )1;
                                                        } else {
                                                          {
#line 476
                                                          tmp___5 = strcmp((char const   *)arg,
                                                                           "--wrap");
                                                          }
#line 476
                                                          if (tmp___5 == 0) {
#line 476
                                                            goto _L;
                                                          } else {
                                                            {
#line 476
                                                            tmp___6 = strcmp((char const   *)arg,
                                                                             "-w");
                                                            }
#line 476
                                                            if (tmp___6 == 0) {
                                                              _L: /* CIL Label */ 
#line 478
                                                              if (i < argc) {
                                                                {
#line 482
                                                                i ++;
#line 483
                                                                tmp___3 = get_unsigned_value((char const   *)*(argv + i),
                                                                                             & value___0);
                                                                }
#line 483
                                                                if (tmp___3) {
#line 485
                                                                  if ((int )value___0 < 8) {
                                                                    {
#line 487
                                                                    error((char *)"invalid wrap dump value %d, not in range [%d-%d]",
                                                                          value___0,
                                                                          8, 1024);
#line 489
                                                                    usage((enum EXIT_CODE )1);
                                                                    }
                                                                  } else
#line 485
                                                                  if ((int )value___0 > 1024) {
                                                                    {
#line 487
                                                                    error((char *)"invalid wrap dump value %d, not in range [%d-%d]",
                                                                          value___0,
                                                                          8, 1024);
#line 489
                                                                    usage((enum EXIT_CODE )1);
                                                                    }
                                                                  }
#line 491
                                                                  prefs.wrap_dump = (unsigned short )value___0;
                                                                } else {
                                                                  {
#line 495
                                                                  error((char *)"invalid value for option \'%s\': %s",
                                                                        arg, *(argv + i));
#line 496
                                                                  usage((enum EXIT_CODE )1);
                                                                  }
                                                                }
                                                              } else {
                                                                {
#line 501
                                                                error((char *)"missing filename to argument \'%s\'",
                                                                      arg);
#line 502
                                                                usage((enum EXIT_CODE )1);
                                                                }
                                                              }
                                                            } else {
                                                              {
#line 509
                                                              tmp___4 = strcmp((char const   *)arg,
                                                                               "--");
                                                              }
#line 509
                                                              if (tmp___4 == 0) {
#line 510
                                                                goto while_break___0;
                                                              } else
#line 512
                                                              if ((int )*arg == 45) {
                                                                {
#line 514
                                                                error((char *)"unrecognized option \'%s\'",
                                                                      arg);
#line 515
                                                                usage((enum EXIT_CODE )1);
                                                                }
                                                              } else {
#line 518
                                                                goto while_break___0;
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 326
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 522
  filenames_list = argv;
#line 523
  filenames_count = argc;
#line 524
  if ((argc - i) + 1 >= 2) {
    {
#line 528
    tmp___34 = i;
#line 528
    i ++;
#line 528
    op = *(argv + tmp___34);
#line 529
    label = op_match_label(op);
    }
#line 530
    if (! label) {
      {
#line 532
      error((char *)"unknown op mode \'%s\'", op);
#line 533
      usage((enum EXIT_CODE )1);
      }
    }
    {
#line 535
    prefs.op = label->op;
#line 536
    info((char *)"operating mode: %s", op);
    }
#line 538
    if ((unsigned int )prefs.op == 4U) {
#line 539
      prefs.rewrite = (bool )1;
    }
#line 542
    if ((unsigned int )prefs.op == 3U) {
#line 544
      if ((argc - i) + 1 >= 2) {
        {
#line 546
        tmp___35 = i;
#line 546
        i ++;
#line 546
        dump_value = *(argv + tmp___35);
#line 548
        filter_load_line(dump_value);
#line 549
        prefs.filter_mode |= 1;
        }
      } else {
        {
#line 553
        error((char *)"missing parameter(s) for dump-value mode");
#line 554
        usage((enum EXIT_CODE )1);
        }
      }
    }
#line 559
    if ((int )*(*(argv + i)) == 64) {
#line 565
      if ((argc - i) + 1 > 1) {
        {
#line 566
        warning((char *)"ignoring extra parameters in command-line after @<file>");
        }
      }
      {
#line 569
      filename = *(argv + i);
#line 570
      filename ++;
#line 571
      list_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
      }
#line 572
      if (! list_file) {
        {
#line 573
        fatal_error((char *)"could not open file \'%s\'", filename);
        }
      }
      {
#line 576
      filenames_list = (char **)((void *)0);
#line 577
      filenames_count = 0;
#line 578
      filenames_list_load(& filenames_list, & filenames_count, list_file);
#line 579
      filenames_count --;
#line 580
      i = 0;
#line 583
      fclose(list_file);
      }
    }
  } else {
    {
#line 588
    error((char *)"missing parameter(s)");
#line 589
    usage((enum EXIT_CODE )1);
    }
  }
#line 593
  if (prefs.fix) {
#line 593
    if (! prefs.extract_iptc) {
#line 593
      if (! prefs.rewrite) {
        {
#line 595
        error((char *)"nothing to fix if not extracting or filtering");
#line 596
        usage((enum EXIT_CODE )1);
        }
      }
    }
  }
#line 599
  if (prefs.rewrite_create_backup) {
#line 599
    if (! prefs.extract_iptc) {
#line 599
      if (! prefs.rewrite) {
        {
#line 601
        error((char *)"nothing to backup if not extracting or filtering");
#line 602
        usage((enum EXIT_CODE )1);
        }
      }
    }
  }
#line 604
  if (prefs.test_rewrite) {
#line 604
    if (! prefs.rewrite) {
      {
#line 606
      error((char *)"test rewrite not possible if not filtering");
#line 607
      usage((enum EXIT_CODE )1);
      }
    }
  }
#line 609
  if (extract_extension) {
#line 609
    if (! prefs.extract_iptc) {
      {
#line 611
      error((char *)"nothing to do with extension \'%s\' when not extracting", extract_extension);
#line 613
      usage((enum EXIT_CODE )1);
      }
    }
  }
#line 615
  if (prefs.extract_extension_append) {
#line 615
    if (! prefs.extract_iptc) {
      {
#line 617
      error((char *)"no extension to append when not extracting");
#line 618
      usage((enum EXIT_CODE )1);
      }
    }
  }
#line 620
  if (include_expression) {
#line 620
    if (exclude_expression) {
#line 622
      if ((unsigned int )prefs.op != 4U) {
        {
#line 623
        error((char *)"don\'t know what to do with extraneous filename or expression for operating mode %s",
              op_labels[prefs.op].label);
        }
      } else {
        {
#line 626
        error((char *)"cannot mix include and exclude filenames or expressions at the same time");
        }
      }
      {
#line 627
      usage((enum EXIT_CODE )1);
      }
    }
  }
#line 631
  if (prefs.extract_iptc) {
#line 631
    if (! extract_extension) {
#line 633
      extract_extension = default_iptc_extension;
    }
  }
#line 634
  if (prefs.extract_iptc) {
#line 634
    goto _L___6;
  } else
#line 634
  if (prefs.rewrite) {
    _L___6: /* CIL Label */ 
#line 634
    if (target_dirname) {
      {
#line 637
      tmp___38 = fexist((char const   *)target_dirname);
      }
#line 637
      if (tmp___38) {
        {
#line 648
        tmp___37 = fisdir((char const   *)target_dirname);
        }
#line 648
        if (! tmp___37) {
          {
#line 649
          fatal_error((char *)"\'%s\' doesn\'t seem to be a directory", target_dirname);
          }
        }
      } else {
        {
#line 642
        err = mkdir((char const   *)target_dirname, (__mode_t )511);
        }
#line 643
        if (err < 0) {
          {
#line 644
          tmp___36 = __errno_location();
#line 644
          fatal_error((char *)"couldn\'t create target directory \'%s\' (error #%d)",
                      target_dirname, *tmp___36);
          }
        }
      }
    }
  }
#line 653
  if (include_expression) {
#line 655
    prefs.filter_mode |= 1;
#line 656
    if ((int )*include_expression == 64) {
      {
#line 661
      include_filename = include_expression + 1;
#line 662
      include_file = fopen((char const   */* __restrict  */)include_filename, (char const   */* __restrict  */)"r");
      }
#line 663
      if (! include_file) {
        {
#line 664
        fatal_error((char *)"could not open file \'%s\'", include_filename);
        }
      }
      {
#line 665
      debug((char *)"loading include file");
#line 666
      filter_load_file(include_file);
#line 667
      fclose(include_file);
      }
    } else {
      {
#line 671
      debug((char *)"evaluating include filter expression");
#line 672
      filter_load_line(include_expression);
      }
    }
#line 678
    prefs.rewrite_cached = (bool )1;
  } else
#line 681
  if (exclude_expression) {
#line 683
    prefs.filter_mode |= 2;
#line 684
    if ((int )*exclude_expression == 64) {
      {
#line 689
      exclude_filename = exclude_expression + 1;
#line 690
      exclude_file = fopen((char const   */* __restrict  */)exclude_filename, (char const   */* __restrict  */)"r");
      }
#line 691
      if (! exclude_file) {
        {
#line 692
        fatal_error((char *)"could not open file \'%s\'", exclude_filename);
        }
      }
      {
#line 693
      debug((char *)"loading exclude file");
#line 694
      filter_load_file(exclude_file);
#line 695
      fclose(exclude_file);
      }
    } else {
      {
#line 699
      debug((char *)"evaluating exclude filter expression");
#line 700
      filter_load_line(exclude_expression);
      }
    }
    {
#line 706
    tmp___39 = iptc_filters();
    }
#line 706
    if ((int )tmp___39 > 0) {
#line 707
      prefs.rewrite_cached = (bool )1;
    }
  }
#line 709
  if (edit_expression) {
#line 711
    prefs.filter_mode |= 4;
#line 712
    if ((int )*edit_expression == 64) {
      {
#line 717
      edit_filename = edit_expression + 1;
#line 718
      edit_file = fopen((char const   */* __restrict  */)edit_filename, (char const   */* __restrict  */)"r");
      }
#line 719
      if (! edit_file) {
        {
#line 720
        fatal_error((char *)"could not open file \'%s\'", edit_filename);
        }
      }
      {
#line 721
      debug((char *)"loading edit file");
#line 722
      edit_load_file(edit_file);
#line 723
      fclose(edit_file);
      }
    } else {
      {
#line 727
      debug((char *)"evaluating edit filter expression");
#line 728
      edit_load_line((char const   *)edit_expression);
      }
    }
    {
#line 731
    iptc_edit_list_dump();
#line 734
    tmp___40 = iptc_edits();
    }
#line 734
    if ((int )tmp___40 > 0) {
#line 735
      prefs.rewrite_cached = (bool )1;
    }
  }
#line 737
  if ((unsigned int )prefs.op == 4U) {
#line 739
    if (prefs.filter_mode == 0) {
      {
#line 740
      error((char *)"unexpected filter mode: none (not set)");
      }
    } else {
#line 742
      if (prefs.filter_mode & 4) {
#line 742
        tmp___41 = " edit";
      } else {
#line 742
        tmp___41 = "";
      }
#line 742
      if (prefs.filter_mode & 1) {
#line 742
        tmp___42 = " include";
      } else {
#line 742
        tmp___42 = "";
      }
#line 742
      if (prefs.filter_mode & 2) {
#line 742
        tmp___43 = " exclude";
      } else {
#line 742
        tmp___43 = "";
      }
      {
#line 742
      info((char *)"filter mode:%s%s%s", tmp___43, tmp___42, tmp___41);
      }
    }
  }
  {
#line 748
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 748
    if (! (i <= filenames_count)) {
#line 748
      goto while_break___1;
    }
#line 752
    proceed = (bool )1;
#line 756
    if ((unsigned int )prefs.op == 4U) {
#line 757
      prefs.rewrite = (bool )1;
    }
#line 759
    if (prefs.extract_iptc) {
#line 761
      iptc_extract_buffer = (unsigned char *)((void *)0);
#line 762
      iptc_extract_buffer_size = 0UL;
    }
    {
#line 766
    input_filename = *(filenames_list + i);
#line 767
    context_reset();
#line 768
    context_set_text(input_filename);
#line 769
    input_file = fopen((char const   */* __restrict  */)input_filename, (char const   */* __restrict  */)"rb");
    }
#line 770
    if (! input_file) {
      {
#line 772
      error((char *)"could not open file \'%s\'", input_filename);
#line 773
      i ++;
#line 774
      context_print_info();
      }
#line 775
      goto while_continue___1;
    }
#line 779
    if (prefs.rewrite) {
#line 781
      if (target_dirname) {
#line 788
        sz = (size_t )0;
#line 789
        if (target_dirname) {
          {
#line 790
          pathname = strdup((char const   *)target_dirname);
          }
        } else {
          {
#line 792
          pathname = fdirname((char const   *)input_filename);
          }
        }
#line 793
        if (pathname) {
#line 793
          if (*pathname) {
            {
#line 794
            tmp___44 = strlen((char const   *)pathname);
#line 794
            sz += tmp___44 + 1UL;
            }
          }
        }
        {
#line 797
        filename___0 = ffilename((char const   *)input_filename);
#line 798
        tmp___45 = strlen((char const   *)filename___0);
#line 798
        sz += tmp___45;
#line 800
        sz ++;
#line 801
        tmp___46 = malloc(sz * sizeof(char ));
#line 801
        output_filename = (char *)tmp___46;
        }
#line 802
        if (! output_filename) {
          {
#line 803
          fatal_error((char *)"couldn\'t allocate space for output filename");
          }
        }
#line 804
        *output_filename = (char )'\000';
#line 805
        if (pathname) {
#line 805
          if (*pathname) {
            {
#line 807
            strcat((char */* __restrict  */)output_filename, (char const   */* __restrict  */)pathname);
#line 808
            strcat((char */* __restrict  */)output_filename, (char const   */* __restrict  */)"/");
            }
          }
        }
        {
#line 810
        strcat((char */* __restrict  */)output_filename, (char const   */* __restrict  */)filename___0);
#line 813
        free((void *)filename___0);
#line 814
        filename___0 = (char *)((void *)0);
#line 815
        free((void *)pathname);
#line 816
        pathname = (char *)((void *)0);
        }
      } else {
        {
#line 819
        output_filename = strdup((char const   *)input_filename);
        }
      }
    } else {
#line 822
      output_filename = (char *)((void *)0);
    }
#line 825
    if (prefs.extract_iptc) {
#line 832
      sz___0 = (size_t )0;
#line 833
      if (target_dirname) {
        {
#line 834
        pathname___0 = strdup((char const   *)target_dirname);
        }
      } else {
        {
#line 836
        pathname___0 = fdirname((char const   *)input_filename);
        }
      }
#line 837
      if (pathname___0) {
#line 837
        if (*pathname___0) {
          {
#line 838
          tmp___47 = strlen((char const   *)pathname___0);
#line 838
          sz___0 += tmp___47 + 1UL;
          }
        }
      }
#line 841
      if (prefs.extract_extension_append) {
        {
#line 842
        filename___1 = ffilename((char const   *)input_filename);
        }
      } else {
        {
#line 844
        filename___1 = fbasename((char const   *)input_filename);
        }
      }
      {
#line 845
      tmp___48 = strlen((char const   *)filename___1);
#line 845
      sz___0 += tmp___48;
#line 848
      tmp___49 = strlen((char const   *)extract_extension);
#line 848
      sz___0 += (1UL + tmp___49) + 1UL;
#line 849
      tmp___50 = malloc(sz___0 * sizeof(char ));
#line 849
      iptc_filename = (char *)tmp___50;
      }
#line 850
      if (! iptc_filename) {
        {
#line 851
        fatal_error((char *)"couldn\'t allocate space for IPTC chunk extraction filename");
        }
      }
#line 852
      *iptc_filename = (char )'\000';
#line 853
      if (pathname___0) {
#line 853
        if (*pathname___0) {
          {
#line 855
          strcat((char */* __restrict  */)iptc_filename, (char const   */* __restrict  */)pathname___0);
#line 856
          strcat((char */* __restrict  */)iptc_filename, (char const   */* __restrict  */)"/");
          }
        }
      }
      {
#line 858
      strcat((char */* __restrict  */)iptc_filename, (char const   */* __restrict  */)filename___1);
#line 859
      strcat((char */* __restrict  */)iptc_filename, (char const   */* __restrict  */)".");
#line 860
      strcat((char */* __restrict  */)iptc_filename, (char const   */* __restrict  */)extract_extension);
#line 862
      free((void *)filename___1);
#line 863
      filename___1 = (char *)((void *)0);
#line 864
      free((void *)pathname___0);
#line 865
      pathname___0 = (char *)((void *)0);
      }
    }
#line 869
    if (prefs.extract_iptc) {
#line 869
      if (prefs.rewrite) {
        {
#line 874
        tmp___51 = strcmp((char const   *)output_filename, (char const   *)iptc_filename);
        }
#line 874
        if (tmp___51 == 0) {
          {
#line 877
          error((char *)"output filenames clash: filtering and extraction target files are identical (%s)\nthis would lead to unpredictable results",
                output_filename);
#line 879
          proceed = (bool )0;
          }
        }
      }
    }
#line 883
    if (proceed) {
      {
#line 887
      input_length = fsize(input_file);
#line 888
      tmp___52 = malloc(input_length * sizeof(unsigned char ));
#line 888
      buffer = (unsigned char *)tmp___52;
      }
#line 889
      if (! buffer) {
        {
#line 890
        fatal_error((char *)"could not allocate %lu bytes", input_length * sizeof(unsigned char ));
        }
      }
      {
#line 891
      ret = fread((void */* __restrict  */)((void *)buffer), (size_t )1, input_length,
                  (FILE */* __restrict  */)input_file);
      }
#line 892
      if (ret != input_length) {
        {
#line 892
        tmp___54 = ferror(input_file);
        }
#line 892
        if (tmp___54 < 0) {
          {
#line 893
          tmp___53 = __errno_location();
#line 893
          error((char *)"read error #%d in file \'%s\', offset %lu: ret=%lu (expected=%lu)",
                *tmp___53, input_filename, ret, input_length);
          }
        }
      }
      {
#line 897
      info((char *)"input file: \'%s\'", input_filename);
      }
#line 898
      if (prefs.rewrite) {
        {
#line 899
        tmp___57 = fexist((char const   *)output_filename);
        }
#line 899
        if (tmp___57) {
#line 899
          tmp___56 = " (already exists)";
        } else {
#line 899
          tmp___56 = "";
        }
        {
#line 899
        info((char *)"output file: \'%s\'%s", output_filename, tmp___56);
        }
      }
#line 901
      if (prefs.extract_iptc) {
        {
#line 902
        tmp___60 = fexist((char const   *)iptc_filename);
        }
#line 902
        if (tmp___60) {
#line 902
          tmp___59 = " (already exists)";
        } else {
#line 902
          tmp___59 = "";
        }
        {
#line 902
        info((char *)"IPTC extract output file: \'%s\'%s", iptc_filename, tmp___59);
        }
      }
#line 905
      result.parsed_bytes = 0UL;
#line 906
      result.written_bytes = 0UL;
#line 907
      result.ret = (bool )1;
#line 909
      if (input_length == 0UL) {
        {
#line 910
        warning((char *)"empty file, skipped");
        }
      } else {
        {
#line 913
        tmp___77 = getstring(buffer, 0UL, tmp, (unsigned long const   )5);
#line 913
        tmp___78 = strcmp((char const   *)((char *)tmp___77), "GIF87");
        }
#line 913
        if (tmp___78 == 0) {
          {
#line 915
          debug((char *)"GIF87 marker found");
#line 916
          info((char *)"GIF87 contents expected (unsupported)");
#line 917
          prefs.rewrite = (bool )0;
          }
        } else {
          {
#line 920
          tmp___75 = getstring(buffer, 0UL, tmp, (unsigned long const   )5);
#line 920
          tmp___76 = strcmp((char const   *)((char *)tmp___75), "GIF89");
          }
#line 920
          if (tmp___76 == 0) {
            {
#line 922
            debug((char *)"GIF89 marker found");
#line 923
            info((char *)"GIF89 contents expected (unsupported)");
#line 924
            prefs.rewrite = (bool )0;
            }
          } else {
            {
#line 927
            tmp___73 = getstring(buffer, 0UL, tmp, (unsigned long const   )6);
#line 927
            tmp___74 = strcmp((char const   *)((char *)tmp___73), "Exif\000\000");
            }
#line 927
            if (tmp___74 == 0) {
              {
#line 929
              debug((char *)"Exif marker found");
#line 930
              info((char *)"Exif contents expected");
#line 931
              exif_parse(buffer, (unsigned int const   )input_length, & result);
              }
#line 932
              if (! result.ret) {
                {
#line 933
                debug((char *)"Exif parser has reported error(s)");
                }
              }
            } else {
              {
#line 936
              tmp___72 = getlong(buffer, 0UL);
              }
#line 936
              if (tmp___72 == 943870035UL) {
                {
#line 938
                debug((char *)"8BPS marker found");
#line 939
                info((char *)"Adobe Photoshop contents expected");
                }
#line 940
                if (prefs.rewrite) {
                  {
#line 941
                  init_rewrite();
                  }
                }
                {
#line 942
                adobe_8bps_parse(buffer, input_length, & result);
                }
#line 943
                if (! result.ret) {
                  {
#line 944
                  debug((char *)"8BPS parser has reported error(s)");
                  }
                }
              } else {
                {
#line 947
                tmp___71 = getlong(buffer, 0UL);
                }
#line 947
                if (tmp___71 == 943868237UL) {
                  {
#line 949
                  debug((char *)"8BIM marker found");
#line 950
                  info((char *)"Adobe Photoshop contents expected");
                  }
#line 955
                  if (prefs.rewrite) {
                    {
#line 956
                    init_rewrite();
                    }
                  }
                  {
#line 957
                  adobe_8bim_parse(buffer, input_length, (unsigned short const   )0,
                                   & result);
                  }
#line 958
                  if (! result.ret) {
                    {
#line 959
                    debug((char *)"8BIM parser has reported error(s)");
                    }
                  }
                } else {
                  {
#line 962
                  tmp___70 = getlong(buffer, 0UL);
                  }
#line 962
                  if (tmp___70 == 1229531648UL) {
                    {
#line 964
                    debug((char *)"TIFF (little endian) marker found");
#line 965
                    info((char *)"TIFF (little endian) contents expected (unsupported)");
#line 966
                    prefs.rewrite = (bool )0;
                    }
                  } else {
                    {
#line 969
                    tmp___69 = getlong(buffer, 0UL);
                    }
#line 969
                    if (tmp___69 == 1296891946UL) {
                      {
#line 971
                      debug((char *)"TIFF (big endian) marker found");
#line 972
                      info((char *)"TIFF (big endian) contents expected (unsupported)");
#line 973
                      prefs.rewrite = (bool )0;
                      }
                    } else {
                      {
#line 976
                      tmp___68 = getlong(buffer, 0UL);
                      }
#line 976
                      if (tmp___68 == 2303741511UL) {
                        {
#line 978
                        debug((char *)"PNG marker found");
#line 979
                        info((char *)"PNG contents expected (unsupported)");
#line 980
                        prefs.rewrite = (bool )0;
                        }
                      } else {
                        {
#line 983
                        tmp___66 = getstring(buffer, 0UL, tmp, (unsigned long const   )4);
#line 983
                        tmp___67 = strcmp((char const   *)((char *)tmp___66), "DJvu");
                        }
#line 983
                        if (tmp___67 == 0) {
                          {
#line 985
                          debug((char *)"DJVU marker found");
#line 986
                          info((char *)"DJVU contents expected (unsupported)");
#line 987
                          prefs.rewrite = (bool )0;
                          }
                        } else {
                          {
#line 990
                          tmp___65 = getword(buffer, 0UL);
                          }
#line 990
                          if ((int )tmp___65 == ((255 << 8) | 216)) {
                            {
#line 992
                            debug((char *)"SOI tag found");
#line 993
                            info((char *)"JPEG/JFIF contents expected");
                            }
#line 994
                            if (prefs.rewrite) {
                              {
#line 995
                              init_rewrite();
                              }
                            }
                            {
#line 996
                            jfif_parse(buffer, (unsigned long const   )input_length,
                                       & result);
                            }
#line 997
                            if (! result.ret) {
                              {
#line 998
                              debug((char *)"JFIF parser has reported error(s)");
                              }
                            }
                          } else {
                            {
#line 1001
                            tmp___63 = getstring(buffer, 0UL, tmp, (unsigned long const   )2);
#line 1001
                            tmp___64 = strcmp((char const   *)((char *)tmp___63),
                                              "BM");
                            }
#line 1001
                            if (tmp___64 == 0) {
                              {
#line 1003
                              debug((char *)"Windows Bitmap marker found");
#line 1004
                              info((char *)"Windows Bitmap contents expected (unsupported)");
#line 1005
                              prefs.rewrite = (bool )0;
                              }
                            } else {
                              {
#line 1008
                              tmp___62 = getbyte(buffer, 0UL);
                              }
#line 1008
                              if ((int )tmp___62 == 28) {
                                {
#line 1010
                                debug((char *)"IPTC marker found");
#line 1011
                                info((char *)"IPTC contents expected");
                                }
#line 1012
                                if (prefs.rewrite) {
                                  {
#line 1013
                                  init_rewrite();
                                  }
                                }
                                {
#line 1014
                                iptc_parse(buffer, (long const   )input_length, (bool const   )1,
                                           & result);
                                }
#line 1015
                                if (! result.ret) {
                                  {
#line 1016
                                  debug((char *)"IPTC parser has reported error(s)");
                                  }
                                }
                              } else {
                                {
#line 1019
                                tmp___61 = getbyte(buffer, 0UL);
                                }
#line 1019
                                if ((int )tmp___61 == 170) {
                                  {
#line 1021
                                  debug((char *)"FF0 marker found");
#line 1022
                                  info((char *)"Adobe FF0 contents expected");
                                  }
#line 1023
                                  if (prefs.rewrite) {
                                    {
#line 1024
                                    init_rewrite();
                                    }
                                  }
                                  {
#line 1025
                                  adobe_ffo_parse(buffer, input_length, (unsigned short const   )1,
                                                  & result);
                                  }
#line 1026
                                  if (! result.ret) {
                                    {
#line 1027
                                    debug((char *)"FF0 parser has reported error(s)");
                                    }
                                  }
                                } else {
                                  {
#line 1031
                                  error((char *)"not a supported file (contents not recognized)");
#line 1032
                                  prefs.rewrite = (bool )0;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 1035
      if (result.parsed_bytes > input_length) {
        {
#line 1036
        error((char *)"%lu byte(s) have been parsed whereas the file length is %lu",
              result.parsed_bytes, input_length);
        }
      }
#line 1038
      if (result.parsed_bytes < input_length) {
        {
#line 1039
        debug((char *)"%lu remaining byte(s)", input_length - result.parsed_bytes);
        }
      }
      {
#line 1042
      fclose(input_file);
#line 1043
      input_file = (FILE *)((void *)0);
      }
#line 1045
      if (prefs.rewrite) {
        {
#line 1050
        post_rewrite(buffer, & result);
        }
#line 1052
        if (! result.ret) {
          {
#line 1054
          warning((char *)"at least one parser error has been encountered,\nwritten file might be corrupted (unreliable data)");
          }
        }
        {
#line 1057
        len = fsize(output_file);
        }
#line 1058
        if (output_file) {
          {
#line 1060
          fclose(output_file);
#line 1061
          output_file = (FILE *)((void *)0);
          }
        }
#line 1065
        if (prefs.test_rewrite) {
          {
#line 1070
          tmp___79 = strlen((char const   *)output_filename);
#line 1070
          len___0 = tmp___79 - 7UL;
#line 1071
          tmp___80 = malloc((((len___0 + 1UL) + 7UL) + 1UL) * sizeof(char ));
#line 1071
          rewrite_filename = (char *)tmp___80;
          }
#line 1072
          if (! rewrite_filename) {
            {
#line 1073
            fatal_error((char *)"couldn\'t allocate space for rewrite filename");
            }
          }
          {
#line 1074
          strncpy((char */* __restrict  */)rewrite_filename, (char const   */* __restrict  */)output_filename,
                  len___0);
#line 1075
          strncpy((char */* __restrict  */)(rewrite_filename + len___0), (char const   */* __restrict  */)".rewrite",
                  (size_t )8);
#line 1076
          *(rewrite_filename + ((len___0 + 1UL) + 7UL)) = (char )'\000';
          }
#line 1079
          if (prefs.rewrite_create_backup) {
            {
#line 1080
            backup_file((char const   *)rewrite_filename);
            }
          }
          {
#line 1082
          err___0 = frename((char const   *)output_filename, (char const   *)rewrite_filename);
          }
#line 1083
          if (err___0 != 0) {
            {
#line 1084
            error((char *)"couldn\'t rename \'%s\' to \'%s\' (error #%d)", output_filename,
                  rewrite_filename, err___0);
            }
          }
          {
#line 1087
          free((void *)rewrite_filename);
#line 1088
          rewrite_filename = (char *)((void *)0);
          }
        } else {
          {
#line 1095
          tmp___81 = strlen((char const   *)output_filename);
#line 1095
          target_filename = strndup((char const   *)output_filename, tmp___81 - 7UL);
          }
#line 1099
          if (prefs.rewrite_create_backup) {
            {
#line 1100
            backup_file((char const   *)target_filename);
            }
          }
          {
#line 1102
          err___0 = frename((char const   *)output_filename, (char const   *)target_filename);
          }
#line 1103
          if (err___0 != 0) {
            {
#line 1104
            error((char *)"couldn\'t rename \'%s\' to \'%s\' (error #%d)", output_filename,
                  target_filename, err___0);
            }
          } else {
            {
#line 1107
            info((char *)"written %d byte(s) to file \'%s\'", len, target_filename);
            }
          }
          {
#line 1109
          free((void *)target_filename);
#line 1110
          target_filename = (char *)((void *)0);
          }
        }
      }
#line 1114
      if (prefs.extract_iptc) {
#line 1116
        if (iptc_extract_buffer) {
#line 1121
          if (prefs.rewrite_create_backup) {
            {
#line 1122
            backup_file((char const   *)iptc_filename);
            }
          }
          {
#line 1125
          iptc_file = fopen((char const   */* __restrict  */)iptc_filename, (char const   */* __restrict  */)"w+b");
          }
#line 1126
          if (! iptc_file) {
            {
#line 1127
            fatal_error((char *)"couldn\'t create file \'%s\' for IPTC chunk extraction",
                        iptc_filename);
            }
          }
          {
#line 1129
          len___1 = fwrite((void const   */* __restrict  */)iptc_extract_buffer, (size_t )1,
                           iptc_extract_buffer_size, (FILE */* __restrict  */)iptc_file);
          }
#line 1130
          if (len___1 != iptc_extract_buffer_size) {
            {
#line 1131
            tmp___82 = __errno_location();
#line 1131
            error((char *)"error %d while attempting to save %lu byte(s) from the IPTC chunk (%lu written)",
                  *tmp___82, iptc_extract_buffer_size, len___1);
            }
          }
          {
#line 1133
          debug((char *)"IPTC chunk extracted and saved: %lu byte(s) to file \'%s\'",
                len___1, iptc_filename);
#line 1135
          info((char *)"written %d byte(s) to file \'%s\'", len___1, iptc_filename);
#line 1138
          fclose(iptc_file);
#line 1139
          iptc_file = (FILE *)((void *)0);
#line 1140
          free((void *)iptc_extract_buffer);
#line 1141
          iptc_extract_buffer = (unsigned char *)((void *)0);
#line 1142
          iptc_extract_buffer_size = 0UL;
          }
        } else {
          {
#line 1145
          error((char *)"unexpected uninitialized IPTC extract buffer");
          }
        }
      }
#line 1150
      if (buffer) {
        {
#line 1152
        free((void *)buffer);
#line 1153
        buffer = (unsigned char *)((void *)0);
        }
      }
    }
#line 1158
    if (iptc_filename) {
      {
#line 1160
      free((void *)iptc_filename);
#line 1161
      iptc_filename = (char *)((void *)0);
      }
    }
#line 1163
    if (output_filename) {
      {
#line 1165
      free((void *)output_filename);
#line 1166
      output_filename = (char *)((void *)0);
      }
    }
    {
#line 1169
    i ++;
#line 1170
    context_print_info();
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1174
  if ((unsigned int )prefs.op == 3U) {
    {
#line 1175
    iptc_filter_table_reset();
    }
  } else
#line 1177
  if (prefs.rewrite) {
    {
#line 1179
    iptc_filter_table_reset();
#line 1180
    iptc_edit_list_reset();
    }
  }
#line 1182
  if (target_dirname) {
    {
#line 1184
    free((void *)target_dirname);
#line 1185
    target_dirname = (char *)((void *)0);
    }
  }
#line 1188
  if ((unsigned long )filenames_list != (unsigned long )argv) {
#line 1188
    if (filenames_list) {
#line 1190
      i = 0;
      {
#line 1190
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1190
        if (! (i <= filenames_count)) {
#line 1190
          goto while_break___2;
        }
        {
#line 1192
        free((void *)*(filenames_list + i));
#line 1193
        *(filenames_list + i) = (char *)((void *)0);
#line 1190
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1195
      free((void *)filenames_list);
#line 1196
      filenames_list = (char **)((void *)0);
      }
    }
  }
  {
#line 1199
  info((char *)"total: %lu warning(s), %lu error(s)", prefs.warnings, prefs.errors);
  }
#line 1200
  if (prefs.fix) {
    {
#line 1201
    info((char *)"total: %lu fix(es)", prefs.fixes);
    }
  }
#line 1202
  exit_code = (enum EXIT_CODE )0;
#line 1203
  if (prefs.errors) {
#line 1204
    exit_code = (enum EXIT_CODE )4;
  } else
#line 1206
  if (prefs.warnings) {
#line 1207
    exit_code = (enum EXIT_CODE )3;
  }
  {
#line 1208
  exit((int )exit_code);
  }
}
}
#line 354 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
void setword(unsigned char *ptr , unsigned long offset , unsigned short word ) ;
#line 109 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.h"
bool jfif_skip_chunk(char *label , unsigned char **ptr , long *bytes , unsigned long *written_bytes ) ;
#line 110
char *jfif_tag_name(enum JFIF_MARKER  const  tag ) ;
#line 111
struct jfif_marker_descr *jfif_marker_match(enum JFIF_MARKER  const  tag ) ;
#line 112
struct jfif_marker_range_descr *jfif_marker_range_match(enum JFIF_MARKER  const  tag ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
struct jfif_marker_descr jfif_markers_descr[65]  = 
#line 13 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
  {      {(unsigned char)192, (char *)"SOF0", (char *)"baseline DCT"}, 
        {(unsigned char)193, (char *)"SOF1", (char *)"extended sequential DCT"}, 
        {(unsigned char)194, (char *)"SOF2", (char *)"progressive DCT"}, 
        {(unsigned char)195, (char *)"SOF3", (char *)"lossless (sequential)"}, 
        {(unsigned char)197, (char *)"SOF5", (char *)"differential sequential DCT"}, 
        {(unsigned char)198, (char *)"SOF6", (char *)"differential progressive DCT"}, 
        {(unsigned char)199,
      (char *)"SOF7", (char *)"differential lossless (sequential)"}, 
        {(unsigned char)200, (char *)"JPG", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)201, (char *)"SOF9", (char *)"extended sequential DCT"}, 
        {(unsigned char)202, (char *)"SOF10", (char *)"progressive DCT"}, 
        {(unsigned char)203, (char *)"SOF11", (char *)"lessless (sequential)"}, 
        {(unsigned char)205, (char *)"SOF13", (char *)"differential sequential DCT"}, 
        {(unsigned char)206,
      (char *)"SOF14", (char *)"differential progressive DCT"}, 
        {(unsigned char)207, (char *)"SOF15", (char *)"differential lossless (sequential)"}, 
        {(unsigned char)196,
      (char *)"DHT", (char *)"huffman table(s)"}, 
        {(unsigned char)204, (char *)"DAC", (char *)"arithmetic coding conditiong(s)"}, 
        {(unsigned char)208,
      (char *)"RST0", (char *)"restart with modulo 8 count 0"}, 
        {(unsigned char)209, (char *)"RST1", (char *)"restart with modulo 8 count 1"}, 
        {(unsigned char)210,
      (char *)"RST2", (char *)"restart with modulo 8 count 2"}, 
        {(unsigned char)211, (char *)"RST3", (char *)"restart with modulo 8 count 3"}, 
        {(unsigned char)212,
      (char *)"RST4", (char *)"restart with modulo 8 count 4"}, 
        {(unsigned char)213, (char *)"RST5", (char *)"restart with modulo 8 count 5"}, 
        {(unsigned char)214,
      (char *)"RST6", (char *)"restart with modulo 8 count 6"}, 
        {(unsigned char)215, (char *)"RST7", (char *)"restart with modulo 8 count 7"}, 
        {(unsigned char)216,
      (char *)"SOI", (char *)"start of image"}, 
        {(unsigned char)217, (char *)"EOI", (char *)"end of image"}, 
        {(unsigned char)218, (char *)"SOS", (char *)"start of scan"}, 
        {(unsigned char)219, (char *)"DQT", (char *)"define quantization table(s)"}, 
        {(unsigned char)220, (char *)"DNL", (char *)"define number of lines"}, 
        {(unsigned char)221, (char *)"DRI", (char *)"define restart internal"}, 
        {(unsigned char)222, (char *)"DHP", (char *)"define hierarchical progression"}, 
        {(unsigned char)223,
      (char *)"EXP", (char *)"expand reference component(s)"}, 
        {(unsigned char)224, (char *)"APP0", (char *)"application segment 0"}, 
        {(unsigned char)225, (char *)"APP1", (char *)"application segment 1"}, 
        {(unsigned char)226, (char *)"APP2", (char *)"application segment 2"}, 
        {(unsigned char)227, (char *)"APP3", (char *)"application segment 3"}, 
        {(unsigned char)228, (char *)"APP4", (char *)"application segment 4"}, 
        {(unsigned char)229, (char *)"APP5", (char *)"application segment 5"}, 
        {(unsigned char)230, (char *)"APP6", (char *)"application segment 6"}, 
        {(unsigned char)231, (char *)"APP7", (char *)"application segment 7"}, 
        {(unsigned char)232, (char *)"APP8", (char *)"application segment 8"}, 
        {(unsigned char)233, (char *)"APP9", (char *)"application segment 9"}, 
        {(unsigned char)234, (char *)"APP10", (char *)"application segment 10"}, 
        {(unsigned char)235, (char *)"APP11", (char *)"application segment 11"}, 
        {(unsigned char)236, (char *)"APP12", (char *)"application segment 12"}, 
        {(unsigned char)237, (char *)"APP13", (char *)"application segment 13"}, 
        {(unsigned char)238, (char *)"APP14", (char *)"application segment 14"}, 
        {(unsigned char)239, (char *)"APP15", (char *)"application segment 15"}, 
        {(unsigned char)240, (char *)"JPG0", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)241,
      (char *)"JPG1", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)242, (char *)"JPG2", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)243,
      (char *)"JPG3", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)244, (char *)"JPG4", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)245,
      (char *)"JPG5", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)246, (char *)"JPG6", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)247,
      (char *)"JPG7", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)248, (char *)"JPG8", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)249,
      (char *)"JPG9", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)250, (char *)"JPG10", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)251,
      (char *)"JPG11", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)252, (char *)"JPG12", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)253,
      (char *)"JPG13", (char *)"reserved for JPEG extensions"}, 
        {(unsigned char)254, (char *)"COM", (char *)"comment"}, 
        {(unsigned char)1, (char *)"TEM", (char *)"for temporary private use in arithmetic coding"}, 
        {(unsigned char)0,
      (char *)((void *)0), (char *)((void *)0)}};
#line 92 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
struct jfif_marker_range_descr jfif_marker_ranges_descr[2]  = {      {(unsigned char)2, (unsigned char)191, (char *)"RES", (char *)"reserved"}, 
        {(unsigned char)0, (unsigned char)0, (char *)((void *)0), (char *)((void *)0)}};
#line 103 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
void jfif_parse(unsigned char *buffer , unsigned long const   bytes_left , struct parser_result *result ) 
{ 
  struct parser_result res ;
  unsigned char *ptr ;
  unsigned long jfif_chunks ;
  unsigned long written_bytes ;
  long bytes ;
  unsigned short length ;
  unsigned char tag ;
  bool ret ;
  bool saw_EOI ;
  bool saw_SOS ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *ptr_at_length ;
  size_t tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char exif_marker[5] ;
  size_t tmp___11 ;
  unsigned char *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  unsigned char *p ;
  unsigned long len ;
  char product[100] ;
  unsigned short product_len ;
  unsigned short product_version ;
  unsigned char *tmp___16 ;
  int tmp___17 ;
  unsigned char *tmp___18 ;
  int tmp___19 ;
  unsigned char *tmp___20 ;
  int tmp___21 ;
  unsigned char *tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  bool parsed ;
  unsigned long tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long l ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  struct jfif_marker_descr *marker_descr ;
  struct jfif_marker_range_descr *marker_range_descr ;
  char *tmp___29 ;
  bool tmp___30 ;

  {
  {
#line 117
  jfif_chunks = 0UL;
#line 118
  ptr = buffer;
#line 119
  bytes = (long )bytes_left;
#line 120
  written_bytes = 0UL;
#line 121
  ret = (bool )1;
#line 122
  saw_EOI = (bool )0;
#line 123
  saw_SOS = (bool )0;
#line 124
  debug((char *)"JFIF parser: %ld byte(s) to parse", bytes);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (bytes > 0L) {
#line 126
      if (! saw_SOS) {
#line 126
        if (! (! saw_EOI)) {
#line 126
          goto while_break;
        }
      } else {
#line 126
        goto while_break;
      }
    } else {
#line 126
      goto while_break;
    }
#line 128
    if (bytes < 2L) {
      {
#line 130
      ret = (bool )0;
#line 131
      error((char *)"JFIF parser: chunk underrun (%ld byte(s) remaining, 2 or more expected)",
            bytes);
      }
#line 133
      goto while_break;
    }
    {
#line 137
    tag = getbyte(ptr, 0UL);
    }
#line 138
    if ((int )tag != 255) {
      {
#line 140
      ret = (bool )0;
#line 141
      error((char *)"JFIF parser: expected tag marker not matched");
      }
#line 142
      goto while_break;
    }
#line 144
    if (prefs.rewrite) {
      {
#line 145
      tmp = dump_rewrite(ptr, 1UL);
#line 145
      written_bytes += tmp;
      }
    }
    {
#line 146
    bytes --;
#line 147
    ptr ++;
#line 149
    jfif_chunks ++;
#line 151
    tag = getbyte(ptr, 0UL);
    }
    {
#line 154
    if ((int )tag == 216) {
#line 154
      goto case_216;
    }
#line 162
    if ((int )tag == 217) {
#line 162
      goto case_217;
    }
#line 174
    if ((int )tag == 218) {
#line 174
      goto case_218;
    }
#line 212
    if ((int )tag == 239) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 238) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 237) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 236) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 235) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 234) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 233) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 232) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 231) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 230) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 229) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 228) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 227) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 226) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 225) {
#line 212
      goto case_239;
    }
#line 212
    if ((int )tag == 224) {
#line 212
      goto case_239;
    }
#line 484
    if ((int )tag == 223) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 222) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 220) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 254) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 204) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 221) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 196) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 219) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 207) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 206) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 205) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 203) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 202) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 201) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 199) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 198) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 197) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 195) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 194) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 193) {
#line 484
      goto case_223;
    }
#line 484
    if ((int )tag == 192) {
#line 484
      goto case_223;
    }
#line 152
    goto switch_break;
    case_216: /* CIL Label */ 
    {
#line 155
    debug((char *)"JFIF parser: SOI tag found");
    }
#line 156
    if (prefs.rewrite) {
      {
#line 157
      tmp___0 = dump_rewrite(ptr, 1UL);
#line 157
      written_bytes += tmp___0;
      }
    }
#line 158
    bytes --;
#line 159
    ptr ++;
#line 160
    goto switch_break;
    case_217: /* CIL Label */ 
    {
#line 163
    saw_EOI = (bool )1;
#line 164
    debug((char *)"JFIF parser: EOI tag found");
    }
#line 165
    if (prefs.rewrite) {
      {
#line 166
      tmp___1 = dump_rewrite(ptr, 1UL);
#line 166
      written_bytes += tmp___1;
      }
    }
#line 167
    bytes --;
#line 168
    ptr ++;
#line 169
    if (bytes) {
      {
#line 170
      warning((char *)"JFIF parser: unexpected trailing data: %ld byte(s), ignored",
              bytes);
      }
    }
#line 172
    goto switch_break;
    case_218: /* CIL Label */ 
    {
#line 176
    tmp___2 = jfif_tag_name((enum JFIF_MARKER  const  )tag);
#line 176
    ret = jfif_skip_chunk(tmp___2, & ptr, & bytes, & written_bytes);
#line 179
    saw_SOS = (bool )1;
    }
#line 180
    if (bytes < 2L) {
      {
#line 182
      ret = (bool )0;
#line 183
      error((char *)"JFIF parser: SOS/image-data chunk underrun (%ld byte(s) remaining, 2 bytes expected)",
            (int )tag, bytes);
      }
#line 185
      goto switch_break;
    }
#line 189
    if (prefs.rewrite) {
#line 189
      if (bytes > 2L) {
        {
#line 190
        tmp___3 = dump_rewrite(ptr, (unsigned long )(bytes - 2L));
#line 190
        written_bytes += tmp___3;
        }
      }
    }
#line 191
    ptr += bytes - 2L;
#line 192
    bytes = 2L;
#line 193
    goto switch_break;
    case_239: /* CIL Label */ 
    case_238: /* CIL Label */ 
    case_237: /* CIL Label */ 
    case_236: /* CIL Label */ 
    case_235: /* CIL Label */ 
    case_234: /* CIL Label */ 
    case_233: /* CIL Label */ 
    case_232: /* CIL Label */ 
    case_231: /* CIL Label */ 
    case_230: /* CIL Label */ 
    case_229: /* CIL Label */ 
    case_228: /* CIL Label */ 
    case_227: /* CIL Label */ 
    case_226: /* CIL Label */ 
    case_225: /* CIL Label */ 
    case_224: /* CIL Label */ 
    {
#line 216
    tag = (unsigned char )((int )tag - 224);
#line 217
    debug((char *)"JFIF parser: APP%d chunk found", (int )tag);
    }
#line 218
    if (prefs.rewrite) {
      {
#line 219
      tmp___4 = dump_rewrite(ptr, 1UL);
#line 219
      written_bytes += tmp___4;
      }
    }
#line 220
    bytes --;
#line 221
    ptr ++;
#line 223
    if (bytes < 2L) {
      {
#line 225
      ret = (bool )0;
#line 226
      error((char *)"JFIF parser: APP%d chunk underrun (%ld byte(s) remaining, 2 or more expected)",
            (int )tag, bytes);
      }
#line 228
      goto switch_break;
    }
    {
#line 231
    ptr_at_length = ptr;
#line 232
    tmp___5 = getbyte(ptr, 0UL);
#line 232
    tmp___6 = getbyte(ptr, 1UL);
#line 232
    length = (unsigned short )(((int )tmp___5 << 8) | (int )tmp___6);
    }
#line 233
    if (bytes < (long )length) {
      {
#line 235
      ret = (bool )0;
#line 236
      error((char *)"JFIF parser: APP%d chunk underrun (%ld byte(s) remaining, %ld byte(s) expected)",
            (int )tag, bytes, (int )length);
      }
#line 238
      goto switch_break;
    }
#line 240
    length = (unsigned short )((int )length - 2);
#line 241
    if (prefs.rewrite) {
      {
#line 242
      tmp___7 = dump_rewrite(ptr, 2UL);
#line 242
      written_bytes += tmp___7;
      }
    }
#line 243
    bytes -= 2L;
#line 244
    ptr += 2;
#line 246
    tag = (unsigned char )((int )tag + 224);
    {
#line 249
    if ((int )tag == 224) {
#line 249
      goto case_224___0;
    }
#line 255
    if ((int )tag == 225) {
#line 255
      goto case_225___0;
    }
#line 304
    if ((int )tag == 230) {
#line 304
      goto case_230___0;
    }
#line 310
    if ((int )tag == 237) {
#line 310
      goto case_237___0;
    }
#line 454
    goto switch_default;
    case_224___0: /* CIL Label */ 
#line 251
    if (prefs.rewrite) {
#line 251
      if ((int )length > 0) {
        {
#line 252
        tmp___8 = dump_rewrite(ptr, (unsigned long )length);
#line 252
        written_bytes += tmp___8;
        }
      }
    }
#line 253
    goto switch_break___0;
    case_225___0: /* CIL Label */ 
#line 258
    if (prefs.rewrite) {
#line 258
      if ((int )length > 0) {
        {
#line 259
        tmp___9 = dump_rewrite(ptr, (unsigned long )length);
#line 259
        written_bytes += tmp___9;
        }
      }
    }
#line 260
    goto switch_break___0;
#line 261
    if (bytes < 4L) {
#line 263
      if (prefs.rewrite) {
#line 263
        if ((int )length > 0) {
          {
#line 264
          tmp___10 = dump_rewrite(ptr, (unsigned long )length);
#line 264
          written_bytes += tmp___10;
          }
        }
      }
    } else {
      {
#line 270
      tmp___12 = getraw(ptr, 0UL, (unsigned char *)(exif_marker), (unsigned long const   )6);
#line 270
      tmp___13 = strcmp((char const   *)((char *)tmp___12), "Exif\000\000");
      }
#line 270
      if (tmp___13 != 0) {
        {
#line 273
        ret = (bool )0;
#line 274
        error((char *)"JFIF parser: expected Exif tag marker not matched");
        }
#line 275
        if (prefs.rewrite) {
#line 275
          if ((int )length > 0) {
            {
#line 276
            tmp___11 = dump_rewrite(ptr, (unsigned long )length);
#line 276
            written_bytes += tmp___11;
            }
          }
        }
#line 277
        goto switch_break___0;
      }
      {
#line 279
      res.parsed_bytes = 0UL;
#line 280
      res.written_bytes = 0UL;
#line 281
      exif_parse(ptr, (unsigned int const   )length, & res);
#line 282
      ret = res.ret;
      }
#line 283
      if (res.parsed_bytes != (unsigned long )length) {
        {
#line 285
        error((char *)"JFIF parser: Exif size inconsistency (%lu byte(s) read, %lu expected)",
              res.parsed_bytes, (int )length);
        }
#line 288
        if (res.parsed_bytes > (unsigned long )length) {
#line 290
          ret = (bool )0;
#line 291
          length = (unsigned short )res.parsed_bytes;
        } else
#line 296
        if (res.parsed_bytes < (unsigned long )length) {
#line 296
          if (prefs.rewrite) {
            {
#line 297
            tmp___14 = dump_rewrite(ptr + (int )length, (unsigned long )length - res.parsed_bytes);
#line 297
            written_bytes += tmp___14;
            }
          }
        }
      }
#line 299
      written_bytes += res.written_bytes;
    }
#line 301
    goto switch_break___0;
    case_230___0: /* CIL Label */ 
#line 306
    if (prefs.rewrite) {
#line 306
      if ((int )length > 0) {
        {
#line 307
        tmp___15 = dump_rewrite(ptr, (unsigned long )length);
#line 307
        written_bytes += tmp___15;
        }
      }
    }
#line 308
    goto switch_break___0;
    case_237___0: /* CIL Label */ 
    {
#line 318
    len = (unsigned long )length;
#line 319
    p = ptr;
#line 323
    tmp___22 = getraw(p, 0UL, (unsigned char *)(product), (unsigned long const   )14);
#line 323
    tmp___23 = strcmp((char const   *)((char *)tmp___22), "Photoshop 3.0");
    }
#line 323
    if (tmp___23 == 0) {
#line 326
      product_len = (unsigned short)14;
#line 327
      product_version = (unsigned short)300;
    } else {
      {
#line 331
      tmp___20 = getraw(p, 0UL, (unsigned char *)(product), (unsigned long const   )14);
#line 331
      tmp___21 = strcmp((char const   *)((char *)tmp___20), "Photoshop 4.0");
      }
#line 331
      if (tmp___21 == 0) {
#line 334
        product_len = (unsigned short)14;
#line 335
        product_version = (unsigned short)400;
      } else {
        {
#line 339
        tmp___18 = getraw(p, 0UL, (unsigned char *)(product), (unsigned long const   )19);
#line 339
        tmp___19 = strncmp((char const   *)((char *)tmp___18), "Adobe_Photoshop2.5:",
                           (size_t )19);
        }
#line 339
        if (tmp___19 == 0) {
#line 342
          product[19] = (char )'\000';
#line 343
          product_len = (unsigned short)27;
#line 344
          product_version = (unsigned short)250;
        } else {
          {
#line 348
          tmp___16 = getraw(p, 0UL, (unsigned char *)(product), (unsigned long const   )9);
#line 348
          tmp___17 = strcmp((char const   *)((char *)tmp___16), "Adobe_CM");
          }
#line 348
          if (tmp___17 == 0) {
#line 351
            product_len = (unsigned short)10;
#line 352
            product_version = (unsigned short)0;
          } else {
            {
#line 356
            warning((char *)"JFIF parser: unknown Adobe product name");
#line 357
            product[0] = (char )'\000';
#line 358
            product_len = (unsigned short)0;
#line 359
            product_version = (unsigned short)0;
            }
          }
        }
      }
    }
#line 361
    if (prefs.rewrite) {
#line 361
      if ((int )product_len > 0) {
        {
#line 362
        tmp___24 = dump_rewrite(ptr, (unsigned long )product_len);
#line 362
        written_bytes += tmp___24;
        }
      }
    }
    {
#line 363
    len -= (unsigned long )product_len;
#line 364
    p += (int )product_len;
#line 365
    debug((char *)"JFIF parser: Photoshop product: \'%s\' (version %u)", product,
          (int )product_version);
    }
#line 367
    if (len >= 4UL) {
      {
#line 371
      parsed = (bool )0;
#line 372
      res.parsed_bytes = 0UL;
#line 373
      res.written_bytes = 0UL;
#line 375
      tmp___26 = getlong(p, 0UL);
      }
#line 375
      if (tmp___26 == 943868237UL) {
        {
#line 377
        debug((char *)"JFIF parser: 8BIM marker found, invoking sublevel 8BIM parser");
#line 378
        adobe_8bim_parse(p, len, (unsigned short const   )product_version, & res);
#line 379
        parsed = (bool )1;
#line 380
        ret = res.ret;
#line 381
        p += res.parsed_bytes;
        }
      } else {
        {
#line 385
        tmp___25 = getlong(p, 0UL);
        }
#line 385
        if (tmp___25 == 943870035UL) {
          {
#line 387
          debug((char *)"JFIF parser: 8BPS marker found, invoking sublevel 8BPS parser");
#line 388
          adobe_8bps_parse(p, len, & res);
#line 389
          parsed = (bool )1;
#line 390
          ret = res.ret;
#line 391
          p += res.parsed_bytes;
          }
        } else {
          {
#line 395
          debug((char *)"JFIF parser: neither 8BIM nor 8BPS marker found in APP13 chunk");
#line 396
          ret = (bool )0;
#line 397
          error((char *)"JFIF parser: unsupported or missing Adobe contents");
          }
        }
      }
#line 401
      if (prefs.rewrite) {
#line 402
        written_bytes += res.written_bytes;
      }
#line 406
      if (parsed) {
#line 406
        if (prefs.rewrite) {
#line 406
          if (res.written_bytes != res.parsed_bytes) {
            {
#line 408
            debug((char *)"JFIF parser: backward change of chunk length is necessary (%lu -> %lu)",
                  res.parsed_bytes, res.written_bytes);
            }
#line 410
            if (prefs.rewrite_cached) {
#line 415
              l = (res.written_bytes + (unsigned long )product_len) + 2UL;
#line 417
              if (l > 65535UL) {
                {
#line 419
                l = 65535UL;
#line 420
                error((char *)"JFIF parser: rewritten chunk size overflow (%lu)",
                      l);
                }
              }
              {
#line 422
              debug((char *)"JFIF parser: chunk length to change backwardly at offset %lu: %lu (instead of %lu)",
                    rewrite_cache_offset - l, l, (int )length + 2);
#line 425
              setword(rewrite_cache, rewrite_cache_offset - l, (unsigned short )l);
              }
            } else {
              {
#line 428
              error((char *)"JFIF parser: attempting to do backward changes to uncached write buffer");
              }
            }
          }
        }
      }
#line 431
      if (parsed) {
#line 431
        if (res.parsed_bytes + (unsigned long )product_len != (unsigned long )length) {
          {
#line 433
          error((char *)"JFIF parser: Adobe chunk size inconsistency (%lu byte(s) read, %lu expected)",
                res.parsed_bytes + (unsigned long )product_len, (int )length);
#line 436
          res.parsed_bytes = len;
          }
        }
      }
#line 439
      len -= res.parsed_bytes;
    } else
#line 442
    if (len > 0UL) {
      {
#line 445
      warning((char *)"JFIF parser: JFIF chunk size inconsistency (%lu remaining byte(s))",
              len);
      }
    }
#line 449
    if (prefs.rewrite) {
#line 449
      if (len > 0UL) {
        {
#line 450
        tmp___27 = dump_rewrite(p, len);
#line 450
        written_bytes += tmp___27;
        }
      }
    }
#line 451
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 455
    if (prefs.rewrite) {
#line 455
      if ((int )length > 0) {
        {
#line 456
        tmp___28 = dump_rewrite(ptr, (unsigned long )length);
#line 456
        written_bytes += tmp___28;
        }
      }
    }
#line 457
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 459
    bytes -= (long )length;
#line 460
    ptr += (int )length;
#line 461
    goto switch_break;
    case_223: /* CIL Label */ 
    case_222: /* CIL Label */ 
    case_220: /* CIL Label */ 
    case_254: /* CIL Label */ 
    case_204: /* CIL Label */ 
    case_221: /* CIL Label */ 
    case_196: /* CIL Label */ 
    case_219: /* CIL Label */ 
    case_207: /* CIL Label */ 
    case_206: /* CIL Label */ 
    case_205: /* CIL Label */ 
    case_203: /* CIL Label */ 
    case_202: /* CIL Label */ 
    case_201: /* CIL Label */ 
    case_199: /* CIL Label */ 
    case_198: /* CIL Label */ 
    case_197: /* CIL Label */ 
    case_195: /* CIL Label */ 
    case_194: /* CIL Label */ 
    case_193: /* CIL Label */ 
    case_192: /* CIL Label */ 
    {
#line 489
    marker_descr = jfif_marker_match((enum JFIF_MARKER  const  )tag);
    }
#line 490
    if (! marker_descr) {
      {
#line 494
      marker_range_descr = jfif_marker_range_match((enum JFIF_MARKER  const  )tag);
      }
#line 495
      if (! marker_range_descr) {
        {
#line 497
        ret = (bool )0;
#line 498
        error((char *)"JFIF parser: unknown tag 0x%02x", (int )tag);
        }
      }
    }
    {
#line 502
    tmp___29 = jfif_tag_name((enum JFIF_MARKER  const  )tag);
#line 502
    tmp___30 = jfif_skip_chunk(tmp___29, & ptr, & bytes, & written_bytes);
#line 502
    ret = (bool )((int )ret & (int )tmp___30);
    }
#line 504
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 509
  if (! ret) {
#line 509
    if (! saw_EOI) {
#line 509
      if (! saw_SOS) {
        {
#line 511
        ret = (bool )0;
#line 512
        error((char *)"JFIF parser: neither found SOS nor EOI, possibly corrupted file or not a supported JPEG/JFIF file format");
        }
      }
    }
  }
  {
#line 514
  debug((char *)"JFIF parser: %u dataset(s) inspected, total length: %lu byte(s)",
        jfif_chunks, bytes_left - (unsigned long const   )bytes);
  }
#line 516
  if (prefs.rewrite) {
    {
#line 517
    debug((char *)"JFIF parser: %lu byte(s) rewritten", written_bytes);
    }
  }
#line 518
  result->parsed_bytes = (unsigned long )(bytes_left - (unsigned long const   )bytes);
#line 519
  result->written_bytes = written_bytes;
#line 520
  result->ret = ret;
#line 521
  return;
}
}
#line 523 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
bool jfif_skip_chunk(char *label , unsigned char **ptr , long *bytes , unsigned long *written_bytes ) 
{ 
  unsigned char *p ;
  long b ;
  unsigned short l ;
  size_t tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 530
  b = *bytes;
#line 531
  p = *ptr;
#line 533
  debug((char *)"JFIF parser: %s chunk found", label);
  }
#line 536
  if (prefs.rewrite) {
    {
#line 537
    tmp = dump_rewrite(p, 1UL);
#line 537
    written_bytes += tmp;
    }
  }
#line 538
  b --;
#line 539
  p ++;
#line 541
  if (b < 2L) {
    {
#line 543
    error((char *)"JFIF parser: %s chunk underrun (%ld byte(s) remaining, 2 or more expected)",
          label, b);
    }
#line 545
    return ((bool )0);
  }
  {
#line 548
  tmp___0 = getbyte(p, 0UL);
#line 548
  tmp___1 = getbyte(p, 1UL);
#line 548
  l = (unsigned short )(((int )tmp___0 << 8) | (int )tmp___1);
  }
#line 549
  if (b < (long )l) {
    {
#line 551
    error((char *)"JFIF parser: %s chunk underrun (%ld byte(s) remaining, %ld byte(s) expected)",
          label, b, (int )l);
    }
#line 553
    return ((bool )0);
  }
#line 555
  l = (unsigned short )((int )l - 2);
#line 556
  b -= 2L;
#line 557
  p += 2;
#line 560
  b -= (long )l;
#line 561
  p += (int )l;
#line 563
  if (prefs.rewrite) {
    {
#line 565
    tmp___2 = dump_rewrite(*ptr + 1, (unsigned long )((int )l + 2));
#line 565
    *written_bytes += tmp___2;
    }
  }
#line 567
  *bytes = b;
#line 568
  *ptr = p;
#line 569
  return ((bool )1);
}
}
#line 572 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
struct jfif_marker_descr *jfif_marker_match(enum JFIF_MARKER  const  tag ) 
{ 
  register unsigned int i ;

  {
#line 576
  i = 0U;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! ((int )jfif_markers_descr[i].tag != 0)) {
#line 577
      goto while_break;
    }
#line 579
    if ((unsigned int const   )jfif_markers_descr[i].tag == (unsigned int const   )tag) {
#line 580
      return (& jfif_markers_descr[i]);
    }
#line 581
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  return ((struct jfif_marker_descr *)((void *)0));
}
}
#line 586 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
struct jfif_marker_range_descr *jfif_marker_range_match(enum JFIF_MARKER  const  tag ) 
{ 
  register unsigned int i ;

  {
#line 591
  i = 0U;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! ((int )jfif_marker_ranges_descr[i].lower_boundary != 0)) {
#line 592
      goto while_break;
    }
#line 594
    if ((unsigned int const   )tag <= (unsigned int const   )jfif_marker_ranges_descr[i].lower_boundary) {
#line 596
      return (& jfif_marker_ranges_descr[i]);
    } else
#line 594
    if ((unsigned int const   )tag <= (unsigned int const   )jfif_marker_ranges_descr[i].upper_boundary) {
#line 596
      return (& jfif_marker_ranges_descr[i]);
    }
#line 597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  return ((struct jfif_marker_range_descr *)((void *)0));
}
}
#line 602 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
char *jfif_tag_name(enum JFIF_MARKER  const  tag ) 
{ 
  struct jfif_marker_descr *marker_descr ;
  struct jfif_marker_range_descr *marker_range_descr ;

  {
  {
#line 607
  marker_descr = jfif_marker_match(tag);
  }
#line 608
  if (marker_descr) {
#line 609
    return (marker_descr->name);
  }
  {
#line 610
  marker_range_descr = jfif_marker_range_match(tag);
  }
#line 611
  if (marker_range_descr) {
#line 612
    return (marker_range_descr->name);
  }
#line 613
  return ((char *)"<unknown>");
}
}
#line 616 "/home/wheatley/newnew/temp/pecomato-0.0.15/jfif.c"
void jfif_dump_markers_list(void) 
{ 


  {
#line 618
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 678
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 333 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.h"
bool fisfile(char const   *filename ) ;
#line 334
bool fislink(char const   *filename ) ;
#line 336
char *fextension(char const   *path ) ;
#line 353
void setbyte(unsigned char *ptr , unsigned long offset , unsigned char byte ) ;
#line 355
void setlong(unsigned char *ptr , unsigned long offset , unsigned long dword ) ;
#line 358
void message_fatal_error(char *format , va_list args ) ;
#line 359
void message_error(char *format , va_list args ) ;
#line 360
void message_warning(char *format , va_list args ) ;
#line 361
void message_info(char *format , va_list args ) ;
#line 362
void message_debug(char *format , va_list args ) ;
#line 372
void context_print_text(void) ;
#line 386
bool get_hexa_value(char const   *param , unsigned long *var ) ;
#line 389
size_t strpos(char const   *string , char const   c ) ;
#line 390
size_t strrpos(char const   *string , char const   c ) ;
#line 393
bool filter_parse_line(char *buffer , size_t len , unsigned long line ) ;
#line 398
bool edit_parse_line(char const   *buffer , size_t len , unsigned long line ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 32 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
struct op_label op_labels[6]  = {      {(enum OP )0, (char *)"check", (char *)"just check embedded data structures"}, 
        {(enum OP )1,
      (char *)"dump", (char *)"show embedded data (headers only)"}, 
        {(enum OP )2, (char *)"dump-full", (char *)"show all embedded data (including values)"}, 
        {(enum OP )3,
      (char *)"dump-value", (char *)"show requested value (headers only)"}, 
        {(enum OP )4, (char *)"filter", (char *)"filter embedded data (see -i, -e and --edit)"}, 
        {(enum OP )5,
      (char *)((void *)0), (char *)((void *)0)}};
#line 54 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
struct log_level_descr log_levels[6]  = {      {(enum LOG_LEVEL )0, (char *)"quiet, no output at all"}, 
        {(enum LOG_LEVEL )1, (char *)"error messages only (default)"}, 
        {(enum LOG_LEVEL )2, (char *)"warning and error messages"}, 
        {(enum LOG_LEVEL )3, (char *)"informative, warning and error messages"}, 
        {(enum LOG_LEVEL )4, (char *)"all messages including debug ones"}, 
        {(enum LOG_LEVEL )5, (char *)((void *)0)}};
#line 71 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
struct exit_code_label exit_code_labels[7]  = {      {(enum EXIT_CODE )0, (char *)"normal exit"}, 
        {(enum EXIT_CODE )1, (char *)"usage error"}, 
        {(enum EXIT_CODE )2, (char *)"asynchronous signal termination"}, 
        {(enum EXIT_CODE )3, (char *)"normal exit, with warning(s)"}, 
        {(enum EXIT_CODE )4, (char *)"normal exit, with error(s)"}, 
        {(enum EXIT_CODE )5, (char *)"fatal error encountered"}, 
        {(enum EXIT_CODE )6, (char *)((void *)0)}};
#line 111 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned char *rewrite_cache  ;
#line 112 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned long rewrite_cache_offset  ;
#line 113 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned long rewrite_cache_size  ;
#line 114 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
FILE *output_file  ;
#line 115 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *output_filename  ;
#line 116 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
size_t input_length  ;
#line 123 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
size_t fsize(FILE *file ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 127
  fseek(file, 0L, 2);
#line 128
  tmp___0 = ftell(file);
#line 128
  tmp = (size_t )tmp___0;
#line 129
  fseek(file, 0L, 0);
  }
#line 130
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool fexist(char const   *filename ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 141
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 141
  if (tmp == 0) {
#line 142
    return ((bool )1);
  }
#line 143
  return ((bool )0);
}
}
#line 156 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
int frename(char const   *source_filename , char const   *target_filename ) 
{ 
  int err ;
  bool tmp ;

  {
  {
#line 160
  tmp = fexist(target_filename);
  }
#line 160
  if (tmp) {
    {
#line 168
    err = unlink(target_filename);
    }
#line 169
    if (err != 0) {
      {
#line 170
      error((char *)"frename: couldn\'t remove \'%s\' (error #%d)", target_filename,
            err);
      }
    }
  }
  {
#line 175
  err = rename(source_filename, target_filename);
  }
#line 176
  return (err);
}
}
#line 183 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool fisfile(char const   *filename ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 187
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 187
  if (tmp < 0) {
#line 188
    return ((bool )0);
  }
#line 189
  if ((st.st_mode & 61440U) == 32768U) {
#line 190
    return ((bool )1);
  }
#line 191
  return ((bool )0);
}
}
#line 198 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool fislink(char const   *filename ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 202
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 202
  if (tmp < 0) {
#line 203
    return ((bool )0);
  }
#line 204
  if ((st.st_mode & 61440U) == 40960U) {
#line 205
    return ((bool )1);
  }
#line 206
  return ((bool )0);
}
}
#line 213 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool fisdir(char const   *filename ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 217
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 217
  if (tmp < 0) {
#line 218
    return ((bool )0);
  }
#line 219
  if ((st.st_mode & 61440U) == 16384U) {
#line 220
    return ((bool )1);
  }
#line 221
  return ((bool )0);
}
}
#line 231 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *fextension(char const   *path ) 
{ 
  char *extension ;
  char const   *filename ;
  int dot ;
  int sep ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 239
  tmp = strrpos(path, (char const   )'/');
#line 239
  sep = (int )tmp;
  }
#line 240
  if (sep == 0) {
#line 241
    filename = path;
  } else {
#line 243
    filename = path + sep;
  }
  {
#line 245
  tmp___0 = strrpos(filename, (char const   )'.');
#line 245
  dot = (int )tmp___0;
  }
#line 246
  if (dot == 0) {
    {
#line 247
    tmp___1 = strdup("");
#line 247
    extension = tmp___1;
    }
  } else {
    {
#line 249
    tmp___2 = strdup(filename + dot);
#line 249
    extension = tmp___2;
    }
  }
#line 250
  return (extension);
}
}
#line 261 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *fbasename(char const   *path ) 
{ 
  char *basename___0 ;
  char const   *filename ;
  int dot ;
  int sep ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 269
  tmp = strrpos(path, (char const   )'/');
#line 269
  sep = (int )tmp;
  }
#line 270
  if (sep == 0) {
#line 271
    filename = path;
  } else {
#line 273
    filename = path + sep;
  }
  {
#line 275
  tmp___0 = strrpos(filename, (char const   )'.');
#line 275
  dot = (int )tmp___0;
  }
#line 276
  if (dot == 0) {
    {
#line 277
    tmp___1 = strdup(filename);
#line 277
    basename___0 = tmp___1;
    }
  } else {
    {
#line 279
    tmp___2 = strndup(filename, (size_t )(dot - 1));
#line 279
    basename___0 = tmp___2;
    }
  }
#line 280
  return (basename___0);
}
}
#line 290 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *ffilename(char const   *path ) 
{ 
  char *filename ;
  int sep ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 295
  tmp = strrpos(path, (char const   )'/');
#line 295
  sep = (int )tmp;
  }
#line 296
  if (sep == 0) {
    {
#line 297
    tmp___0 = strdup(path);
#line 297
    filename = tmp___0;
    }
  } else {
    {
#line 299
    tmp___1 = strdup(path + sep);
#line 299
    filename = tmp___1;
    }
  }
#line 300
  return (filename);
}
}
#line 311 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *fdirname(char const   *path ) 
{ 
  char *dirname ;
  int sep ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 316
  tmp = strrpos(path, (char const   )'/');
#line 316
  sep = (int )tmp;
  }
#line 317
  if (sep == 0) {
    {
#line 318
    tmp___0 = strdup("");
#line 318
    dirname = tmp___0;
    }
  } else {
    {
#line 320
    tmp___1 = strndup(path, (size_t )(sep - 1));
#line 320
    dirname = tmp___1;
    }
  }
#line 321
  return (dirname);
}
}
#line 331 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
char *fcleanpath(char const   *path ) 
{ 
  char const   *ptr ;
  size_t len ;
  char *tmp ;

  {
  {
#line 337
  len = strlen(path);
#line 338
  ptr = (path + len) - 1;
  }
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if ((unsigned long )ptr >= (unsigned long )path) {
#line 339
      if (! ((int const   )*ptr == 47)) {
#line 339
        goto while_break;
      }
    } else {
#line 339
      goto while_break;
    }
#line 341
    ptr --;
#line 342
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  tmp = strndup(path, len);
  }
#line 344
  return (tmp);
}
}
#line 355 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void backup_file(char const   *filename ) 
{ 
  char *backup_filename ;
  int err ;
  size_t tmp ;
  void *tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 361
  err = 0;
#line 362
  tmp = strlen(filename);
#line 362
  tmp___0 = malloc(((tmp + 1UL) + 4UL) * sizeof(char ));
#line 362
  backup_filename = (char *)tmp___0;
  }
#line 363
  if (! backup_filename) {
    {
#line 364
    fatal_error((char *)"backup_file: couldn\'t allocate space for backup filename");
    }
  }
  {
#line 365
  strcpy((char */* __restrict  */)backup_filename, (char const   */* __restrict  */)filename);
#line 366
  strcat((char */* __restrict  */)backup_filename, (char const   */* __restrict  */)".bak");
#line 367
  debug((char *)"backing up \'%s\' to \'%s\'", filename, backup_filename);
#line 370
  tmp___1 = fisfile((char const   *)backup_filename);
  }
#line 370
  if (tmp___1) {
#line 370
    goto _L;
  } else {
    {
#line 370
    tmp___2 = fislink((char const   *)backup_filename);
    }
#line 370
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 372
      err = remove((char const   *)backup_filename);
      }
#line 373
      if (err != 0) {
        {
#line 374
        error((char *)"backup_file: couldn\'t remove previous backup file \'%s\' (error #%d)",
              backup_filename, err);
        }
      }
    }
  }
  {
#line 379
  tmp___3 = fisfile(filename);
  }
#line 379
  if (tmp___3) {
#line 379
    goto _L___0;
  } else {
    {
#line 379
    tmp___4 = fislink((char const   *)backup_filename);
    }
#line 379
    if (tmp___4) {
      _L___0: /* CIL Label */ 
      {
#line 381
      err = frename(filename, (char const   *)backup_filename);
      }
#line 382
      if (err != 0) {
        {
#line 383
        error((char *)"backup_file: couldn\'t create backup \'%s\' from \'%s\' (error #%d)",
              backup_filename, filename, err);
        }
      }
    }
  }
#line 386
  if (err == 0) {
    {
#line 387
    info((char *)"\'%s\' file created", backup_filename);
    }
  }
  {
#line 390
  free((void *)backup_filename);
#line 391
  backup_filename = (char *)((void *)0);
  }
#line 392
  return;
}
}
#line 400 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned char getbyte(unsigned char *ptr , unsigned long offset ) 
{ 


  {
#line 402
  return (*(ptr + offset));
}
}
#line 411 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned short getword(unsigned char *ptr , unsigned long offset ) 
{ 


  {
#line 413
  return ((unsigned short )(((int )*(ptr + offset) << 8) | (int )*(ptr + (offset + 1UL))));
}
}
#line 422 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned short getrawword(unsigned char *ptr , unsigned long offset ) 
{ 


  {
#line 424
  return ((unsigned short )(((int )*(ptr + (offset + 1UL)) << 8) | (int )*(ptr + offset)));
}
}
#line 433 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned long getlong(unsigned char *ptr , unsigned long offset ) 
{ 


  {
#line 435
  return ((unsigned long )(((((int )*(ptr + offset) << 8) | (int )*(ptr + (offset + 1UL))) << 16) | (((int )*(ptr + (offset + 2UL)) << 8) | (int )*(ptr + (offset + 3UL)))));
}
}
#line 444 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned long getrawlong(unsigned char *ptr , unsigned long offset ) 
{ 


  {
#line 446
  return ((unsigned long )(((((int )*(ptr + (offset + 3UL)) << 8) | (int )*(ptr + (offset + 2UL))) << 16) | (((int )*(ptr + (offset + 1UL)) << 8) | (int )*(ptr + offset))));
}
}
#line 455 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned char *getstring(unsigned char *ptr , unsigned long offset , unsigned char *buf ,
                         unsigned long const   len ) 
{ 
  register unsigned int i ;

  {
#line 460
  i = 0U;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! ((unsigned long const   )i < len)) {
#line 460
      goto while_break;
    }
#line 461
    *(buf + i) = *(ptr + (offset + (unsigned long )i));
#line 460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  *(buf + i) = (unsigned char )'\000';
#line 463
  return (buf);
}
}
#line 472 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
unsigned char *getraw(unsigned char *ptr , unsigned long offset , unsigned char *buf ,
                      unsigned long const   len ) 
{ 


  {
  {
#line 475
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)(ptr + offset),
         (size_t )(len * (unsigned long const   )sizeof(unsigned char )));
  }
#line 476
  return (buf);
}
}
#line 485 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void setbyte(unsigned char *ptr , unsigned long offset , unsigned char byte ) 
{ 


  {
#line 487
  *(ptr + offset) = byte;
#line 488
  return;
}
}
#line 496 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void setword(unsigned char *ptr , unsigned long offset , unsigned short word ) 
{ 


  {
#line 498
  *(ptr + offset) = (unsigned char )(((int )word & 65280) >> 8);
#line 499
  *(ptr + (offset + 1UL)) = (unsigned char )((int )word & 255);
#line 500
  return;
}
}
#line 508 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void setlong(unsigned char *ptr , unsigned long offset , unsigned long dword ) 
{ 


  {
#line 510
  *(ptr + offset) = (unsigned char )((dword & 4278190080UL) >> 24);
#line 511
  *(ptr + (offset + 1UL)) = (unsigned char )((dword & 16711680UL) >> 16);
#line 512
  *(ptr + (offset + 2UL)) = (unsigned char )((dword & 65280UL) >> 8);
#line 513
  *(ptr + (offset + 3UL)) = (unsigned char )(dword & 255UL);
#line 514
  return;
}
}
#line 522 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message_fatal_error(char *format , va_list args ) 
{ 


  {
#line 524
  if ((unsigned int )prefs.log_level >= 1U) {
    {
#line 526
    context_print_text();
#line 527
    (prefs.context_errors) ++;
#line 528
    (prefs.errors) ++;
#line 529
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
#line 530
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 531
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nfatal error encountered, bailing out\n");
#line 532
    context_print_info();
    }
  }
  {
#line 534
  _exit(5);
  }
}
}
#line 543 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message_error(char *format , va_list args ) 
{ 


  {
#line 545
  if ((unsigned int )prefs.log_level >= 1U) {
    {
#line 547
    context_print_text();
#line 548
    (prefs.context_errors) ++;
#line 549
    (prefs.errors) ++;
#line 550
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: ");
#line 551
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 552
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 554
  return;
}
}
#line 562 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message_warning(char *format , va_list args ) 
{ 


  {
#line 564
  if ((unsigned int )prefs.log_level >= 2U) {
    {
#line 566
    context_print_text();
#line 567
    (prefs.context_warnings) ++;
#line 568
    (prefs.warnings) ++;
#line 569
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: ");
#line 570
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
             args);
#line 571
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 573
  return;
}
}
#line 581 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message_info(char *format , va_list args ) 
{ 


  {
#line 583
  if ((unsigned int )prefs.log_level >= 3U) {
    {
#line 585
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"info: ");
#line 586
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
             args);
#line 587
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
#line 588
    fflush(stdout);
    }
  }
#line 590
  return;
}
}
#line 598 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message_debug(char *format , va_list args ) 
{ 


  {
#line 600
  if ((unsigned int )prefs.log_level >= 4U) {
    {
#line 602
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"debug: ");
#line 603
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
             args);
#line 604
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
#line 605
    fflush(stdout);
    }
  }
#line 607
  return;
}
}
#line 615 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void fatal_error(char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 619
  __builtin_va_start(args, format);
#line 620
  message_fatal_error(format, args);
#line 621
  __builtin_va_end(args);
  }
#line 622
  return;
}
}
#line 630 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void error(char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 634
  __builtin_va_start(args, format);
#line 635
  message_error(format, args);
#line 636
  __builtin_va_end(args);
  }
#line 637
  return;
}
}
#line 645 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void warning(char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 649
  __builtin_va_start(args, format);
#line 650
  message_warning(format, args);
#line 651
  __builtin_va_end(args);
  }
#line 652
  return;
}
}
#line 660 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void info(char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 664
  __builtin_va_start(args, format);
#line 665
  message_info(format, args);
#line 666
  __builtin_va_end(args);
  }
#line 667
  return;
}
}
#line 675 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void debug(char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 679
  __builtin_va_start(args, format);
#line 680
  message_debug(format, args);
#line 681
  __builtin_va_end(args);
  }
#line 682
  return;
}
}
#line 690 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void message(enum SEVERITY severity , char *format  , ...) 
{ 
  va_list args ;

  {
  {
#line 694
  __builtin_va_start(args, format);
  }
  {
#line 697
  if ((unsigned int )severity == 0U) {
#line 697
    goto case_0;
  }
#line 701
  if ((unsigned int )severity == 1U) {
#line 701
    goto case_1;
  }
#line 705
  if ((unsigned int )severity == 2U) {
#line 705
    goto case_2;
  }
#line 709
  if ((unsigned int )severity == 3U) {
#line 709
    goto case_3;
  }
#line 713
  if ((unsigned int )severity == 4U) {
#line 713
    goto case_4;
  }
#line 695
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 698
  message_fatal_error(format, args);
  }
#line 699
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 702
  message_error(format, args);
  }
#line 703
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 706
  message_warning(format, args);
  }
#line 707
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 710
  message_info(format, args);
  }
#line 711
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 714
  message_debug(format, args);
  }
#line 715
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 717
  __builtin_va_end(args);
  }
#line 718
  return;
}
}
#line 726 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void context_set_text(char *text ) 
{ 


  {
#line 728
  prefs.context_text = text;
#line 729
  return;
}
}
#line 737 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void context_print_text(void) 
{ 


  {
#line 740
  if (prefs.context_text) {
#line 741
    if (prefs.context_warnings + prefs.context_errors == 0UL) {
      {
#line 742
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in file \'%s\':\n",
              prefs.context_text);
      }
    }
  }
#line 743
  return;
}
}
#line 751 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void context_print_info(void) 
{ 


  {
#line 753
  if (prefs.context_warnings + prefs.context_errors > 0UL) {
    {
#line 754
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lu warning(s), %lu error(s)\n",
            prefs.context_warnings, prefs.context_errors);
    }
  }
#line 756
  if (prefs.fix) {
#line 756
    if (prefs.context_fixes > 0UL) {
      {
#line 757
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%lu fix(es)\n",
              prefs.fixes);
      }
    }
  }
#line 759
  return;
}
}
#line 767 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void context_reset(void) 
{ 


  {
#line 769
  prefs.context_text = (char *)((void *)0);
#line 770
  prefs.context_warnings = 0UL;
#line 771
  prefs.context_errors = 0UL;
#line 772
  prefs.context_fixes = 0UL;
#line 773
  return;
}
}
#line 781 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
struct op_label *op_match_label(char *label ) 
{ 
  register int i ;
  int tmp ;

  {
#line 785
  i = 0;
  {
#line 786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 786
    if (! ((unsigned int )op_labels[i].op != 5U)) {
#line 786
      goto while_break;
    }
    {
#line 788
    tmp = strcmp((char const   *)op_labels[i].label, (char const   *)label);
    }
#line 788
    if (tmp == 0) {
#line 789
      return (& op_labels[i]);
    }
#line 790
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 792
  return ((struct op_label *)((void *)0));
}
}
#line 801 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void init_rewrite(void) 
{ 
  char *filename ;
  size_t len ;
  int fd ;
  FILE *file ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 808
  if (! prefs.rewrite) {
    {
#line 809
    fatal_error((char *)"init_rewrite: rewrite flag not set");
    }
  }
#line 810
  if (output_file) {
    {
#line 811
    fatal_error((char *)"init_rewrite: bad output file handler");
    }
  }
#line 812
  if (! output_filename) {
    {
#line 813
    fatal_error((char *)"init_rewrite: bad output filename");
    }
  }
  {
#line 816
  len = strlen((char const   *)output_filename);
#line 817
  tmp = malloc((((len + 1UL) + 6UL) + 1UL) * sizeof(char ));
#line 817
  filename = (char *)tmp;
  }
#line 818
  if (! filename) {
    {
#line 819
    fatal_error((char *)"init_rewrite: couldn\'t allocate space for init_rewrite");
    }
  }
  {
#line 820
  strcpy((char */* __restrict  */)filename, (char const   */* __restrict  */)output_filename);
#line 821
  strcat((char */* __restrict  */)filename, (char const   */* __restrict  */)".XXXXXX");
#line 822
  fd = mkstemp(filename);
  }
#line 823
  if (fd < 0) {
    {
#line 824
    fatal_error((char *)"init_rewrite: couldn\'t create a temporary file from \'%s\'",
                output_filename);
    }
  }
  {
#line 827
  file = fdopen(fd, "w+b");
  }
#line 828
  if (! file) {
    {
#line 830
    close(fd);
#line 831
    fatal_error((char *)"init_rewrite: couldn\'t open temporary file \'%s\' for writing",
                output_filename);
    }
  }
  {
#line 835
  output_file = file;
#line 836
  free((void *)output_filename);
#line 837
  tmp___0 = strdup((char const   *)filename);
#line 837
  output_filename = tmp___0;
#line 838
  free((void *)filename);
  }
#line 841
  if (prefs.rewrite_cached) {
    {
#line 843
    tmp___1 = malloc(input_length * sizeof(char ));
#line 843
    rewrite_cache = (unsigned char *)tmp___1;
    }
#line 844
    if (! rewrite_cache) {
      {
#line 845
      fatal_error((char *)"init_rewrite: couldn\'t allocate space for rewrite cache (%lu byte(s))",
                  rewrite_cache_size);
      }
    }
#line 847
    rewrite_cache_offset = 0UL;
#line 848
    rewrite_cache_size = input_length;
  }
#line 850
  return;
}
}
#line 858 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
size_t dump_rewrite(unsigned char *buffer , unsigned long length ) 
{ 
  size_t len ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 863
  if (! prefs.rewrite) {
    {
#line 864
    fatal_error((char *)"init_rewrite: rewrite flag not set");
    }
  }
  {
#line 866
  debug((char *)"dump_rewrite: writing %lu byte(s)", length);
#line 867
  len = (size_t )0;
  }
#line 868
  if (length > 0UL) {
#line 870
    if (prefs.rewrite_cached) {
#line 872
      if (rewrite_cache_offset + length > rewrite_cache_size) {
        {
#line 875
        rewrite_cache_size += length + 1024UL;
#line 876
        tmp = realloc((void *)rewrite_cache, rewrite_cache_size);
#line 876
        rewrite_cache = (unsigned char *)tmp;
        }
#line 877
        if (! rewrite_cache) {
          {
#line 878
          fatal_error((char *)"dump_rewrite: couldn\'t rellocate more space for rewrite_cache (%lu byte(s))",
                      rewrite_cache_size);
          }
        }
      }
      {
#line 882
      memcpy((void */* __restrict  */)(rewrite_cache + rewrite_cache_offset), (void const   */* __restrict  */)buffer,
             length);
#line 883
      rewrite_cache_offset += length;
#line 884
      len = length;
      }
    } else {
      {
#line 889
      len = fwrite((void const   */* __restrict  */)buffer, (size_t )1, length, (FILE */* __restrict  */)output_file);
      }
#line 890
      if (len != length) {
        {
#line 891
        tmp___0 = __errno_location();
#line 891
        error((char *)"dump_rewrite: error %d while attempting to write %lu byte(s) (%lu written)",
              *tmp___0, length, len);
        }
      }
    }
  }
#line 895
  return (len);
}
}
#line 904 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void post_rewrite(unsigned char *buffer , struct parser_result *result ) 
{ 
  unsigned long len ;
  int *tmp ;

  {
#line 908
  if (! prefs.rewrite) {
    {
#line 909
    fatal_error((char *)"post_rewrite: rewrite flag not set");
    }
  }
#line 910
  if (! result) {
    {
#line 911
    fatal_error((char *)"post_rewrite: bad pointer to struct result");
    }
  }
#line 914
  if (input_length > result->parsed_bytes) {
#line 916
    len = input_length - result->parsed_bytes;
  } else {
#line 923
    len = 0UL;
  }
#line 924
  if (prefs.rewrite_cached) {
#line 926
    if (len > 0UL) {
      {
#line 928
      debug((char *)"post_rewrite: writing remaining %lu byte(s) to cache", len);
#line 929
      memcpy((void */* __restrict  */)(rewrite_cache + rewrite_cache_offset), (void const   */* __restrict  */)(buffer + result->parsed_bytes),
             len);
#line 930
      rewrite_cache_offset += len;
      }
    }
    {
#line 933
    len = fwrite((void const   */* __restrict  */)rewrite_cache, (size_t )1, rewrite_cache_offset,
                 (FILE */* __restrict  */)output_file);
    }
#line 934
    if (len != rewrite_cache_offset) {
      {
#line 935
      tmp = __errno_location();
#line 935
      error((char *)"post_rewrite: error %d while attempting to flush %lu cached bytes (%lu written)",
            *tmp, rewrite_cache_offset, len);
      }
    }
#line 937
    if (rewrite_cache_offset > input_length) {
      {
#line 938
      info((char *)"rewritten file is %lu byte(s) bigger than the original", rewrite_cache_offset - input_length);
      }
    } else
#line 941
    if (rewrite_cache_offset < input_length) {
      {
#line 942
      info((char *)"rewritten file is %lu byte(s) smaller than the original", input_length - rewrite_cache_offset);
      }
    } else {
      {
#line 945
      info((char *)"rewritten file and original file have the same size");
      }
    }
  } else
#line 948
  if (len > 0UL) {
    {
#line 950
    debug((char *)"post_rewrite: writing remaining %lu byte(s)", len);
#line 951
    dump_rewrite(buffer + result->parsed_bytes, len);
    }
  }
  {
#line 955
  free((void *)rewrite_cache);
#line 956
  rewrite_cache = (unsigned char *)((void *)0);
  }
#line 957
  return;
}
}
#line 965 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool get_unsigned_value(char const   *param , unsigned long *var ) 
{ 
  unsigned int value ;
  char *chk ;
  unsigned long tmp ;

  {
  {
#line 970
  tmp = strtoul((char const   */* __restrict  */)param, (char **/* __restrict  */)(& chk),
                10);
#line 970
  value = (unsigned int )tmp;
  }
#line 971
  if (! *chk) {
#line 973
    *var = (unsigned long )value;
#line 974
    return ((bool )1);
  }
#line 976
  return ((bool )0);
}
}
#line 985 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool get_signed_value(char const   *param , long *var ) 
{ 
  int value ;
  char *chk ;
  long tmp ;

  {
  {
#line 990
  tmp = strtol((char const   */* __restrict  */)param, (char **/* __restrict  */)(& chk),
               10);
#line 990
  value = (int )tmp;
  }
#line 991
  if (! *chk) {
#line 993
    *var = (long )value;
#line 994
    return ((bool )1);
  }
#line 996
  return ((bool )0);
}
}
#line 1005 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool get_hexa_value(char const   *param , unsigned long *var ) 
{ 
  unsigned int value ;
  char *chk ;
  unsigned long tmp ;

  {
  {
#line 1010
  tmp = strtoul((char const   */* __restrict  */)param, (char **/* __restrict  */)(& chk),
                16);
#line 1010
  value = (unsigned int )tmp;
  }
#line 1011
  if (! *chk) {
#line 1013
    *var = (unsigned long )value;
#line 1014
    return ((bool )1);
  }
#line 1016
  return ((bool )0);
}
}
#line 1025 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
size_t strpos(char const   *string , char const   c ) 
{ 
  char *ptr ;

  {
#line 1029
  ptr = (char *)string;
  {
#line 1030
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1030
    if (! *ptr) {
#line 1030
      goto while_break;
    }
#line 1031
    if ((int )*ptr == (int )c) {
#line 1032
      return ((size_t )((ptr - (char *)string) + 1L));
    } else {
#line 1034
      ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return ((size_t )0);
}
}
#line 1044 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
size_t strrpos(char const   *string , char const   c ) 
{ 
  char *ptr ;
  size_t tmp ;

  {
  {
#line 1048
  tmp = strlen(string);
#line 1048
  ptr = ((char *)string + tmp) - 1;
  }
  {
#line 1049
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1049
    if (! ((unsigned long )ptr >= (unsigned long )string)) {
#line 1049
      goto while_break;
    }
#line 1050
    if ((int )*ptr == (int )c) {
#line 1051
      return ((size_t )((ptr - (char *)string) + 1L));
    } else {
#line 1053
      ptr --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  return ((size_t )0);
}
}
#line 1063 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void filenames_list_load(char ***filenames_list_ptr , int *filenames_count_ptr , FILE *list_file ) 
{ 
  char **filenames_list ;
  char *buffer ;
  ssize_t len ;
  unsigned long filenames_count ;
  size_t size ;
  int copy_limit ;
  void *tmp ;
  char *ptr ;
  char *p ;
  char *tmp___0 ;
  char **ptr___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1073
  copy_limit = 256;
#line 1074
  tmp = malloc((unsigned long )copy_limit * sizeof(char *));
#line 1074
  filenames_list = (char **)tmp;
  }
#line 1075
  if (! filenames_list) {
    {
#line 1076
    fatal_error((char *)"filenames_list_load: couldn\'t allocate more space for filenames list (%lu byte(s))",
                (unsigned long )copy_limit * sizeof(char *));
    }
  }
#line 1079
  filenames_count = 0UL;
#line 1080
  buffer = (char *)((void *)0);
#line 1081
  size = (size_t )32768;
  {
#line 1082
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1082
    len = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& size),
                  (FILE */* __restrict  */)list_file);
    }
#line 1082
    if (len != -1L) {
#line 1082
      if (! buffer) {
#line 1082
        goto while_break;
      }
    } else {
#line 1082
      goto while_break;
    }
#line 1087
    ptr = buffer;
    {
#line 1089
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1089
      if (*ptr) {
#line 1089
        if (! ((int )*ptr < 32)) {
#line 1089
          goto while_break___0;
        }
      } else {
#line 1089
        goto while_break___0;
      }
#line 1090
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1093
    p = (buffer + len) - 1;
    {
#line 1094
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1094
      if ((unsigned long )p >= (unsigned long )ptr) {
#line 1094
        if (! ((int )*p < 32)) {
#line 1094
          goto while_break___1;
        }
      } else {
#line 1094
        goto while_break___1;
      }
#line 1095
      tmp___0 = p;
#line 1095
      p --;
#line 1095
      *tmp___0 = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1096
    debug((char *)"filenames_list_load: line %lu, %lu byte(s)", filenames_count, len);
    }
#line 1098
    if (*buffer) {
#line 1101
      if ((int )filenames_count >= copy_limit) {
        {
#line 1105
        copy_limit += 256;
#line 1106
        tmp___1 = realloc((void *)filenames_list, (unsigned long )copy_limit * sizeof(char *));
#line 1106
        ptr___0 = (char **)tmp___1;
        }
#line 1107
        if (! ptr___0) {
          {
#line 1109
          free((void *)filenames_list);
#line 1110
          fatal_error((char *)"filenames_list_load: couldn\'t rellocate more space for filenames list (%lu byte(s))",
                      (unsigned long )copy_limit * sizeof(char *));
          }
        }
#line 1113
        filenames_list = ptr___0;
      }
      {
#line 1116
      tmp___2 = strlen((char const   *)buffer);
#line 1116
      *(filenames_list + filenames_count) = strndup((char const   *)buffer, tmp___2 + 1UL);
      }
#line 1117
      if (! *(filenames_list + filenames_count)) {
        {
#line 1118
        tmp___3 = strlen((char const   *)buffer);
#line 1118
        fatal_error((char *)"filenames_list_load: couldn\'t allocate space for filenames list contents (%lu byte(s))",
                    (tmp___3 + 1UL) * sizeof(char ));
        }
      }
#line 1120
      filenames_count ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  if (buffer) {
    {
#line 1124
    free((void *)buffer);
    }
  }
#line 1125
  *filenames_list_ptr = filenames_list;
#line 1126
  *filenames_count_ptr = (int )filenames_count;
#line 1127
  return;
}
}
#line 1135 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool filter_parse_line(char *buffer , size_t len , unsigned long line ) 
{ 
  char *ptr ;
  char *p ;
  int errors ;
  char *tmp ;
  unsigned long code ;
  unsigned long code2 ;
  size_t tmp___0 ;
  bool tmp___1 ;
  size_t tmp___2 ;
  bool tmp___3 ;
  size_t tmp___4 ;
  bool tmp___5 ;
  unsigned long record ;
  unsigned long dataset ;
  unsigned long dataset2 ;
  int pos ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  bool tmp___8 ;
  bool tmp___9 ;
  bool tmp___10 ;
  int tmp___11 ;
  bool tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 1141
  errors = 0;
#line 1143
  ptr = buffer;
  {
#line 1145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1145
    if (*ptr) {
#line 1145
      if (! ((int )*ptr <= 32)) {
#line 1145
        goto while_break;
      }
    } else {
#line 1145
      goto while_break;
    }
#line 1146
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1149
  p = (buffer + len) - 1;
  {
#line 1150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1150
    if ((unsigned long )p >= (unsigned long )ptr) {
#line 1150
      if (! ((int )*p <= 32)) {
#line 1150
        goto while_break___0;
      }
    } else {
#line 1150
      goto while_break___0;
    }
#line 1151
    tmp = p;
#line 1151
    p --;
#line 1151
    *tmp = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1154
  if (! *ptr) {
    {
#line 1155
    debug((char *)"filter_parse_file: ignore blank line or comment at line %lu", line);
    }
  } else
#line 1154
  if ((int )*ptr == 35) {
    {
#line 1155
    debug((char *)"filter_parse_file: ignore blank line or comment at line %lu", line);
    }
  } else {
    {
#line 1159
    tmp___15 = strncmp((char const   *)ptr, "IPTC.", (size_t )5);
    }
#line 1159
    if (tmp___15 == 0) {
      {
#line 1176
      debug((char *)"filter_parse_line: found IPTC filter item");
#line 1177
      ptr += 5;
#line 1178
      tmp___14 = strcmp((char const   *)ptr, "*");
      }
#line 1178
      if (tmp___14 == 0) {
        {
#line 1179
        iptc_filter_add_range(0U, 65535U);
        }
      } else {
        {
#line 1181
        tmp___13 = strncmp((char const   *)ptr, "0x", (size_t )2);
        }
#line 1181
        if (tmp___13 == 0) {
          {
#line 1187
          p = strstr((char const   *)ptr, "-0x");
          }
#line 1188
          if (p) {
            {
#line 1191
            debug((char *)"filter_parse_line: hexadecimal range at line %lu", line);
#line 1192
            *p = (char )'\000';
#line 1194
            p ++;
#line 1195
            tmp___0 = strlen((char const   *)ptr);
            }
#line 1195
            if (tmp___0 == 6UL) {
              {
#line 1195
              tmp___1 = get_hexa_value((char const   *)ptr, & code);
              }
#line 1195
              if (tmp___1) {
                {
#line 1195
                tmp___2 = strlen((char const   *)p);
                }
#line 1195
                if (tmp___2 == 6UL) {
                  {
#line 1195
                  tmp___3 = get_hexa_value((char const   *)p, & code2);
                  }
#line 1195
                  if (tmp___3) {
                    {
#line 1197
                    iptc_filter_add_range((unsigned int )code, (unsigned int )code2);
                    }
                  } else {
                    {
#line 1200
                    errors ++;
#line 1201
                    error((char *)"filter_parse_line: bad hexadecimal range (0xhhhh-0xhhhh) at line %lu",
                          line);
                    }
                  }
                } else {
                  {
#line 1200
                  errors ++;
#line 1201
                  error((char *)"filter_parse_line: bad hexadecimal range (0xhhhh-0xhhhh) at line %lu",
                        line);
                  }
                }
              } else {
                {
#line 1200
                errors ++;
#line 1201
                error((char *)"filter_parse_line: bad hexadecimal range (0xhhhh-0xhhhh) at line %lu",
                      line);
                }
              }
            } else {
              {
#line 1200
              errors ++;
#line 1201
              error((char *)"filter_parse_line: bad hexadecimal range (0xhhhh-0xhhhh) at line %lu",
                    line);
              }
            }
          } else {
            {
#line 1208
            debug((char *)"filter_parse_line: hexadecimal unary value at line %lu",
                  line);
#line 1209
            tmp___4 = strlen((char const   *)ptr);
            }
#line 1209
            if (tmp___4 == 6UL) {
              {
#line 1209
              tmp___5 = get_hexa_value((char const   *)ptr, & code);
              }
#line 1209
              if (tmp___5) {
                {
#line 1210
                iptc_filter_add_value((unsigned int )code);
                }
              } else {
                {
#line 1213
                errors ++;
#line 1214
                error((char *)"filter_parse_line: bad hexadecimal unary value (0xhhhh) at line %lu",
                      line);
                }
              }
            } else {
              {
#line 1213
              errors ++;
#line 1214
              error((char *)"filter_parse_line: bad hexadecimal unary value (0xhhhh) at line %lu",
                    line);
              }
            }
          }
        } else {
          {
#line 1227
          tmp___6 = strpos((char const   *)ptr, (char const   )':');
#line 1227
          pos = (int )tmp___6;
          }
#line 1228
          if (pos) {
            {
#line 1230
            debug((char *)"filter_parse_line: decimal value at line %lu", line);
#line 1231
            *(ptr + (pos - 1)) = (char )'\000';
#line 1232
            p = ptr + pos;
#line 1235
            tmp___12 = get_unsigned_value((char const   *)ptr, & record);
            }
#line 1235
            if (tmp___12) {
#line 1235
              if (record <= 255UL) {
                {
#line 1237
                tmp___11 = strcmp((char const   *)p, "*");
                }
#line 1237
                if (tmp___11 == 0) {
                  {
#line 1238
                  iptc_filter_add_range((unsigned int )((unsigned short )(record << 8)),
                                        (unsigned int )((int )((unsigned short )(record << 8)) | 255));
                  }
                } else {
                  {
#line 1243
                  ptr = p;
#line 1244
                  tmp___7 = strpos((char const   *)ptr, (char const   )'-');
#line 1244
                  pos = (int )tmp___7;
                  }
#line 1245
                  if (pos) {
                    {
#line 1247
                    *(ptr + (pos - 1)) = (char )'\000';
#line 1248
                    p = ptr + pos;
#line 1250
                    tmp___8 = get_unsigned_value((char const   *)ptr, & dataset);
                    }
#line 1250
                    if (tmp___8) {
#line 1250
                      if (dataset <= 255UL) {
                        {
#line 1250
                        tmp___9 = get_unsigned_value((char const   *)p, & dataset2);
                        }
#line 1250
                        if (tmp___9) {
#line 1250
                          if (dataset2 <= 255UL) {
                            {
#line 1252
                            iptc_filter_add_range((unsigned int )((unsigned long )((unsigned short )(record << 8)) | dataset),
                                                  (unsigned int )((unsigned long )((unsigned short )(record << 8)) | dataset2));
                            }
                          } else {
                            {
#line 1256
                            errors ++;
#line 1257
                            error((char *)"filter_parse_line: bad range value in decimal duplet (nnn-nnn) at line %lu",
                                  line);
                            }
                          }
                        } else {
                          {
#line 1256
                          errors ++;
#line 1257
                          error((char *)"filter_parse_line: bad range value in decimal duplet (nnn-nnn) at line %lu",
                                line);
                          }
                        }
                      } else {
                        {
#line 1256
                        errors ++;
#line 1257
                        error((char *)"filter_parse_line: bad range value in decimal duplet (nnn-nnn) at line %lu",
                              line);
                        }
                      }
                    } else {
                      {
#line 1256
                      errors ++;
#line 1257
                      error((char *)"filter_parse_line: bad range value in decimal duplet (nnn-nnn) at line %lu",
                            line);
                      }
                    }
                  } else {
                    {
#line 1264
                    tmp___10 = get_unsigned_value((char const   *)p, & dataset);
                    }
#line 1264
                    if (tmp___10) {
#line 1264
                      if (dataset < 255UL) {
                        {
#line 1265
                        iptc_filter_add_value((unsigned int )((unsigned short )((record << 8) | dataset)));
                        }
                      } else {
                        {
#line 1268
                        errors ++;
#line 1269
                        error((char *)"filter_parse_line: bad dataset value in decimal duplet (nnn) at line %lu",
                              line);
                        }
                      }
                    } else {
                      {
#line 1268
                      errors ++;
#line 1269
                      error((char *)"filter_parse_line: bad dataset value in decimal duplet (nnn) at line %lu",
                            line);
                      }
                    }
                  }
                }
              } else {
                {
#line 1277
                errors ++;
#line 1278
                error((char *)"filter_parse_line: bad record value in decimal duplet (nnn) at line %lu",
                      line);
                }
              }
            } else {
              {
#line 1277
              errors ++;
#line 1278
              error((char *)"filter_parse_line: bad record value in decimal duplet (nnn) at line %lu",
                    line);
              }
            }
          } else {
            {
#line 1284
            errors ++;
#line 1285
            error((char *)"filter_parse_line: bad decimal duplet value (nnn:nnn) at line %lu: %s",
                  line, ptr);
            }
          }
        }
      }
    } else {
      {
#line 1300
      errors ++;
#line 1301
      error((char *)"filter_parse_line: invalid filter file contents at line %lu (%lu byte(s))",
            line, len);
#line 1303
      debug((char *)"filter_parse_line: line is: %s", buffer);
      }
    }
  }
#line 1306
  return ((bool )(errors == 0));
}
}
#line 1315 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void filter_load_line(char *buffer ) 
{ 
  ssize_t len ;
  size_t tmp ;
  bool tmp___0 ;

  {
#line 1319
  if (! buffer) {
    {
#line 1320
    error((char *)"filter_load_line: bad pointer to buffer");
    }
  }
#line 1322
  if (! *buffer) {
    {
#line 1323
    error((char *)"filter_load_line: empty buffer");
    }
  }
  {
#line 1325
  iptc_filter_table_init();
#line 1326
  tmp = strlen((char const   *)buffer);
#line 1326
  len = (ssize_t )tmp;
#line 1327
  tmp___0 = filter_parse_line(buffer, (size_t )len, 0UL);
  }
#line 1327
  if (! tmp___0) {
    {
#line 1328
    fatal_error((char *)"filter_load_line: bad filter line");
    }
  }
#line 1329
  return;
}
}
#line 1337 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void filter_load_file(FILE *list_file ) 
{ 
  ssize_t len ;
  unsigned long line ;
  unsigned long errors ;
  char *buffer ;
  size_t size ;
  bool tmp ;

  {
#line 1345
  if (! list_file) {
    {
#line 1346
    error((char *)"filter_load_file: bad input file handler");
    }
  }
  {
#line 1348
  iptc_filter_table_init();
#line 1349
  line = 0UL;
#line 1350
  errors = 0UL;
#line 1351
  buffer = (char *)((void *)0);
#line 1352
  size = (size_t )100;
  }
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1353
    len = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& size),
                  (FILE */* __restrict  */)list_file);
    }
#line 1353
    if (len != -1L) {
#line 1353
      if (! buffer) {
#line 1353
        goto while_break;
      }
    } else {
#line 1353
      goto while_break;
    }
    {
#line 1355
    *(buffer + len) = (char )'\000';
#line 1356
    debug((char *)"filter_load_file: line %lu, %lu byte(s)", line, len);
#line 1358
    tmp = filter_parse_line(buffer, (size_t )len, line);
    }
#line 1358
    if (! tmp) {
#line 1359
      errors ++;
    }
#line 1360
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  if (buffer) {
    {
#line 1363
    free((void *)buffer);
    }
  }
  {
#line 1364
  debug((char *)"filter_load_file: %lu line(s), %lu error(s)", line, errors);
  }
#line 1365
  if (errors) {
    {
#line 1366
    fatal_error((char *)"filter_load_file: bad filter file");
    }
  }
#line 1367
  return;
}
}
#line 1375 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
bool edit_parse_line(char const   *buffer , size_t len , unsigned long line ) 
{ 
  char const   *const_ptr ;
  char *buffer_copy ;
  char *ptr ;
  char *p ;
  size_t buffer_length ;
  int errors ;
  void *tmp ;
  int pos ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  enum FILTER_EDIT_VALUE_TYPE type ;
  char *typename ;
  char *value ;
  char *stored_value ;
  size_t stored_value_length ;
  bool stored_value_in_use ;
  int tmp___2 ;
  int tmp___3 ;
  char *hex ;
  char one_byte[3] ;
  unsigned long byte_val ;
  char *bin ;
  void *tmp___4 ;
  bool tmp___5 ;
  void *tmp___6 ;
  unsigned long code ;
  size_t tmp___7 ;
  bool tmp___8 ;
  unsigned long record ;
  unsigned long dataset ;
  int pos___0 ;
  size_t tmp___9 ;
  bool tmp___10 ;
  bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 1387
  errors = 0;
#line 1390
  buffer_length = len;
#line 1391
  const_ptr = (buffer + buffer_length) - 1;
  {
#line 1392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1392
    if ((unsigned long )const_ptr >= (unsigned long )buffer) {
#line 1392
      if (! ((int const   )*const_ptr == 10)) {
#line 1392
        if (! ((int const   )*const_ptr == 13)) {
#line 1392
          goto while_break;
        }
      }
    } else {
#line 1392
      goto while_break;
    }
#line 1394
    buffer_length --;
#line 1395
    const_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1397
  buffer_length ++;
#line 1401
  tmp = malloc(buffer_length);
#line 1401
  buffer_copy = (char *)tmp;
  }
#line 1402
  if (! buffer_copy) {
    {
#line 1403
    fatal_error((char *)"edit_parse_line: couldn\'t allocate buffer_copy for value");
    }
  }
  {
#line 1404
  memcpy((void */* __restrict  */)buffer_copy, (void const   */* __restrict  */)buffer,
         buffer_length);
#line 1405
  *(buffer_copy + (buffer_length - 1UL)) = (char )'\000';
#line 1406
  ptr = buffer_copy;
  }
  {
#line 1409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1409
    if (*ptr) {
#line 1409
      if (! ((int )*ptr <= 32)) {
#line 1409
        goto while_break___0;
      }
    } else {
#line 1409
      goto while_break___0;
    }
#line 1410
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1413
  if (! *ptr) {
    {
#line 1414
    debug((char *)"edit_parse_file: ignore blank line or comment at line %lu", line);
    }
  } else
#line 1413
  if ((int )*ptr == 35) {
    {
#line 1414
    debug((char *)"edit_parse_file: ignore blank line or comment at line %lu", line);
    }
  } else {
    {
#line 1418
    tmp___13 = strncmp((char const   *)ptr, "IPTC.", (size_t )5);
    }
#line 1418
    if (tmp___13 == 0) {
      {
#line 1434
      debug((char *)"edit_parse_line: found IPTC edit item");
#line 1435
      ptr += 5;
#line 1437
      tmp___0 = strpos((char const   *)ptr, (char const   )'=');
#line 1437
      pos = (int )tmp___0;
      }
#line 1438
      if (pos) {
        {
#line 1441
        *(ptr + (pos - 1)) = (char )'\000';
#line 1442
        p = ptr + pos;
#line 1443
        tmp___1 = strpos((char const   *)p, (char const   )':');
#line 1443
        pos = (int )tmp___1;
        }
#line 1444
        if (pos) {
          {
#line 1446
          type = (enum FILTER_EDIT_VALUE_TYPE )0;
#line 1449
          stored_value = (char *)((void *)0);
#line 1450
          stored_value_length = (size_t )0;
#line 1451
          stored_value_in_use = (bool )0;
#line 1454
          *(p + (pos - 1)) = (char )'\000';
#line 1455
          typename = p;
#line 1456
          tmp___3 = strcmp((char const   *)typename, "hex");
          }
#line 1456
          if (tmp___3 == 0) {
#line 1457
            type = (enum FILTER_EDIT_VALUE_TYPE )1;
          } else {
            {
#line 1459
            tmp___2 = strcmp((char const   *)typename, "text");
            }
#line 1459
            if (tmp___2 == 0) {
#line 1460
              type = (enum FILTER_EDIT_VALUE_TYPE )2;
            } else {
              {
#line 1463
              errors ++;
#line 1464
              error((char *)"edit_parse_line: bad value type \'%s\' at line %lu, expected \'hex\' or \'text\'",
                    p, line);
              }
            }
          }
#line 1467
          if (errors) {
#line 1468
            goto edit_parse_line_abort;
          }
#line 1471
          value = p + pos;
#line 1472
          stored_value_length = (buffer_length - (size_t )(value - buffer_copy)) - 1UL;
#line 1475
          if (stored_value_length == 0UL) {
            {
#line 1477
            errors ++;
#line 1478
            error((char *)"edit_parse_line: empty %s value at line %lu", typename,
                  line);
            }
          }
#line 1481
          if ((unsigned int )type == 1U) {
#line 1488
            if (stored_value_length % 2UL) {
              {
#line 1490
              errors ++;
#line 1491
              error((char *)"edit_parse_line: invalid odd length (%lu byte(s)) for hex value \'%s\' at line %lu",
                    stored_value_length, value, line);
              }
            }
#line 1495
            hex = value;
            {
#line 1496
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1496
              if (*hex) {
#line 1496
                if (97 <= (int )*hex) {
#line 1496
                  if (! ((int )*hex <= 102)) {
#line 1496
                    goto _L___0;
                  }
                } else
                _L___0: /* CIL Label */ 
#line 1496
                if (65 <= (int )*hex) {
#line 1496
                  if (! ((int )*hex <= 70)) {
#line 1496
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 1496
                if (48 <= (int )*hex) {
#line 1496
                  if (! ((int )*hex <= 57)) {
#line 1496
                    goto while_break___1;
                  }
                } else {
#line 1496
                  goto while_break___1;
                }
              } else {
#line 1496
                goto while_break___1;
              }
#line 1500
              hex ++;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1501
            if ((int )*hex != 0) {
              {
#line 1503
              errors ++;
#line 1504
              error((char *)"edit_parse_line: invalid hex value \'%s\' at line %lu",
                    value, line);
              }
            }
            {
#line 1507
            stored_value_length /= 2UL;
#line 1508
            tmp___4 = malloc(stored_value_length);
#line 1508
            stored_value = (char *)tmp___4;
            }
#line 1509
            if (! stored_value) {
              {
#line 1510
              fatal_error((char *)"edit_parse_line: couldn\'t allocate storage buffer for hex value");
              }
            }
#line 1513
            one_byte[2] = (char)0;
#line 1514
            hex = value;
#line 1515
            bin = stored_value;
            {
#line 1516
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 1516
              if (! *hex) {
#line 1516
                goto while_break___2;
              }
              {
#line 1518
              one_byte[0] = *hex;
#line 1519
              one_byte[1] = *(hex + 1);
#line 1520
              tmp___5 = get_hexa_value((char const   *)(one_byte), & byte_val);
              }
#line 1520
              if (tmp___5) {
#line 1521
                *bin = (char )((unsigned char )byte_val);
              }
#line 1522
              hex += 2;
#line 1523
              bin ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else
#line 1527
          if ((unsigned int )type == 2U) {
            {
#line 1529
            tmp___6 = malloc(stored_value_length);
#line 1529
            stored_value = (char *)tmp___6;
            }
#line 1530
            if (! stored_value) {
              {
#line 1531
              fatal_error((char *)"edit_parse_line: couldn\'t allocate storage buffer for text value");
              }
            }
            {
#line 1532
            memcpy((void */* __restrict  */)stored_value, (void const   */* __restrict  */)value,
                   stored_value_length);
            }
          }
#line 1534
          if (errors) {
#line 1535
            goto edit_parse_line_abort;
          }
          {
#line 1538
          tmp___12 = strncmp((char const   *)ptr, "0x", (size_t )2);
          }
#line 1538
          if (tmp___12 == 0) {
            {
#line 1544
            debug((char *)"edit_parse_line: hexadecimal unary value at line %lu",
                  line);
#line 1545
            tmp___7 = strlen((char const   *)ptr);
            }
#line 1545
            if (tmp___7 == 6UL) {
              {
#line 1545
              tmp___8 = get_hexa_value((char const   *)ptr, & code);
              }
#line 1545
              if (tmp___8) {
                {
#line 1546
                iptc_edit_add_edit((unsigned int )code, stored_value_length, (unsigned char *)stored_value,
                                   & stored_value_in_use);
                }
              } else {
                {
#line 1551
                errors ++;
#line 1552
                error((char *)"edit_parse_line: bad hexadecimal unary value (0xhhhh) at line %lu: %s",
                      line, ptr);
                }
              }
            } else {
              {
#line 1551
              errors ++;
#line 1552
              error((char *)"edit_parse_line: bad hexadecimal unary value (0xhhhh) at line %lu: %s",
                    line, ptr);
              }
            }
          } else {
            {
#line 1563
            tmp___9 = strpos((char const   *)ptr, (char const   )':');
#line 1563
            pos___0 = (int )tmp___9;
            }
#line 1564
            if (pos___0) {
              {
#line 1566
              debug((char *)"edit_parse_line: decimal value at line %lu", line);
#line 1567
              *(ptr + (pos___0 - 1)) = (char )'\000';
#line 1568
              p = ptr + pos___0;
#line 1571
              tmp___11 = get_unsigned_value((char const   *)ptr, & record);
              }
#line 1571
              if (tmp___11) {
#line 1571
                if (record <= 255UL) {
                  {
#line 1574
                  tmp___10 = get_unsigned_value((char const   *)p, & dataset);
                  }
#line 1574
                  if (tmp___10) {
#line 1574
                    if (dataset < 255UL) {
                      {
#line 1575
                      iptc_edit_add_edit((unsigned int )((unsigned short )((record << 8) | dataset)),
                                         stored_value_length, (unsigned char *)stored_value,
                                         & stored_value_in_use);
                      }
                    } else {
                      {
#line 1580
                      errors ++;
#line 1581
                      error((char *)"edit_parse_line: bad dataset value in decimal duplet (nnn) at line %lu: %s",
                            line, p);
                      }
                    }
                  } else {
                    {
#line 1580
                    errors ++;
#line 1581
                    error((char *)"edit_parse_line: bad dataset value in decimal duplet (nnn) at line %lu: %s",
                          line, p);
                    }
                  }
                } else {
                  {
#line 1587
                  errors ++;
#line 1588
                  error((char *)"edit_parse_line: bad record value in decimal duplet (nnn) at line %lu: %s",
                        line, ptr);
                  }
                }
              } else {
                {
#line 1587
                errors ++;
#line 1588
                error((char *)"edit_parse_line: bad record value in decimal duplet (nnn) at line %lu: %s",
                      line, ptr);
                }
              }
            } else {
              {
#line 1594
              errors ++;
#line 1595
              error((char *)"edit_parse_line: bad decimal duplet value (nnn:nnn) at line %lu: %s",
                    line, ptr);
              }
            }
          }
          edit_parse_line_abort: 
#line 1600
          if (! stored_value_in_use) {
            {
#line 1602
            free((void *)stored_value);
#line 1603
            stored_value = (char *)((void *)0);
            }
          }
        } else {
          {
#line 1608
          errors ++;
#line 1609
          error((char *)"edit_parse_line: bad value sub-expression in edit expression at line %lu: %s",
                line, ptr);
          }
        }
      } else {
        {
#line 1615
        errors ++;
#line 1616
        error((char *)"edit_parse_line: invalid edit expression at line %lu: %s",
              line, ptr);
        }
      }
    } else {
      {
#line 1630
      errors ++;
#line 1631
      error((char *)"edit_parse_line: invalid edit file contents at line %lu (%lu byte(s))",
            line, buffer_length);
#line 1633
      debug((char *)"edit_parse_line: line is: %s", buffer);
      }
    }
  }
  {
#line 1636
  free((void *)buffer_copy);
  }
#line 1637
  return ((bool )(errors == 0));
}
}
#line 1646 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void edit_load_line(char const   *buffer ) 
{ 
  ssize_t len ;
  size_t tmp ;
  bool tmp___0 ;

  {
#line 1650
  if (! buffer) {
    {
#line 1651
    error((char *)"edit_load_line: bad pointer to buffer");
    }
  }
#line 1653
  if (! *buffer) {
    {
#line 1654
    error((char *)"edit_load_line: empty buffer");
    }
  }
  {
#line 1656
  iptc_edit_list_init();
#line 1658
  tmp = strlen(buffer);
#line 1658
  len = (ssize_t )tmp;
#line 1659
  tmp___0 = edit_parse_line(buffer, (size_t )len, 0UL);
  }
#line 1659
  if (! tmp___0) {
    {
#line 1660
    fatal_error((char *)"edit_load_line: bad edit line");
    }
  }
#line 1661
  return;
}
}
#line 1669 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void edit_load_file(FILE *list_file ) 
{ 
  ssize_t len ;
  unsigned long line ;
  unsigned long errors ;
  char *buffer ;
  size_t size ;
  bool tmp ;

  {
#line 1677
  if (! list_file) {
    {
#line 1678
    error((char *)"edit_load_file: bad input file handler");
    }
  }
  {
#line 1680
  iptc_edit_list_init();
#line 1681
  line = 0UL;
#line 1682
  errors = 0UL;
#line 1683
  buffer = (char *)((void *)0);
#line 1684
  size = (size_t )100;
  }
  {
#line 1685
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1685
    len = getline((char **/* __restrict  */)(& buffer), (size_t */* __restrict  */)(& size),
                  (FILE */* __restrict  */)list_file);
    }
#line 1685
    if (len != -1L) {
#line 1685
      if (! buffer) {
#line 1685
        goto while_break;
      }
    } else {
#line 1685
      goto while_break;
    }
    {
#line 1687
    *(buffer + len) = (char )'\000';
#line 1688
    debug((char *)"edit_load_file: line %lu, %lu byte(s)", line, len);
#line 1690
    tmp = edit_parse_line((char const   *)buffer, (size_t )len, line);
    }
#line 1690
    if (! tmp) {
#line 1691
      errors ++;
    }
#line 1692
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1694
  if (buffer) {
    {
#line 1695
    free((void *)buffer);
    }
  }
  {
#line 1696
  debug((char *)"edit_load_file: %lu line(s), %lu error(s)", line, errors);
  }
#line 1697
  if (errors) {
    {
#line 1698
    fatal_error((char *)"edit_load_file: bad edit file");
    }
  }
#line 1699
  return;
}
}
#line 1707 "/home/wheatley/newnew/temp/pecomato-0.0.15/util.c"
void dump_hexa(unsigned char *value , unsigned long length ) 
{ 
  unsigned long i ;

  {
  {
#line 1711
  printf((char const   */* __restrict  */)"[%lu byte(s)]:", length);
  }
#line 1712
  if ((int )prefs.wrap_dump > 0) {
    {
#line 1713
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
    {
#line 1715
    printf((char const   */* __restrict  */)" ");
    }
  }
#line 1716
  i = 1UL;
  {
#line 1716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1716
    if (! (i <= length)) {
#line 1716
      goto while_break;
    }
    {
#line 1718
    printf((char const   */* __restrict  */)"%02x ", (int )*(value + (i - 1UL)));
    }
#line 1719
    if ((int )prefs.wrap_dump > 0) {
#line 1721
      if (i % (unsigned long )prefs.wrap_dump == 0UL) {
        {
#line 1722
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 1716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1724
  if ((int )prefs.wrap_dump > 0) {
#line 1726
    if (length != (unsigned long )prefs.wrap_dump) {
      {
#line 1727
      printf((char const   */* __restrict  */)"\n");
      }
    }
  } else {
    {
#line 1730
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1731
  return;
}
}
#line 90 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.h"
struct adobe_resource_descr *adobe_match_resource(enum ADOBE_RESOURCE  const  resource ) ;
#line 91
struct adobe_resource_range_descr *adobe_match_resource_range(enum ADOBE_RESOURCE  const  resource ) ;
#line 92
void adobe_dump_resource_list(void) ;
#line 11 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
struct adobe_resource_descr adobe_resources_descr[55]  = 
#line 11 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
  {      {(unsigned short)1000, (char *)"raster info"}, 
        {(unsigned short)1001, (char *)"macintosh print info"}, 
        {(unsigned short)1003, (char *)"indexed color table"}, 
        {(unsigned short)1005, (char *)"resolution"}, 
        {(unsigned short)1006, (char *)"alpha channel names"}, 
        {(unsigned short)1007, (char *)"display"}, 
        {(unsigned short)1008, (char *)"caption"}, 
        {(unsigned short)1009, (char *)"border style"}, 
        {(unsigned short)1010, (char *)"bacrkground color"}, 
        {(unsigned short)1011, (char *)"print flags"}, 
        {(unsigned short)1012, (char *)"grayscale multichannel halftoning"}, 
        {(unsigned short)1013, (char *)"color halftoning"}, 
        {(unsigned short)1014, (char *)"duotone halftoning"}, 
        {(unsigned short)1015, (char *)"grayscale multichannel transfer"}, 
        {(unsigned short)1016, (char *)"color transfer"}, 
        {(unsigned short)1017, (char *)"duotone transfer"}, 
        {(unsigned short)1018, (char *)"duotone image"}, 
        {(unsigned short)1019, (char *)"bw values"}, 
        {(unsigned short)1020, (char *)"obsolete1"}, 
        {(unsigned short)1021, (char *)"eps options"}, 
        {(unsigned short)1022, (char *)"quick mask"}, 
        {(unsigned short)1023, (char *)"obsolete2"}, 
        {(unsigned short)1024, (char *)"layer state"}, 
        {(unsigned short)1025, (char *)"working path"}, 
        {(unsigned short)1026, (char *)"layer group"}, 
        {(unsigned short)1027, (char *)"obsolete3"}, 
        {(unsigned short)1028, (char *)"iptc file info"}, 
        {(unsigned short)1029, (char *)"image mode"}, 
        {(unsigned short)1030, (char *)"jpeg quality"}, 
        {(unsigned short)1032, (char *)"grid guides info"}, 
        {(unsigned short)1033, (char *)"thumbnail resource1"}, 
        {(unsigned short)1034, (char *)"copyright flag"}, 
        {(unsigned short)1035, (char *)"uniform resource locator"}, 
        {(unsigned short)1036, (char *)"thumbnail resource2"}, 
        {(unsigned short)1037, (char *)"global angle"}, 
        {(unsigned short)1038, (char *)"color samplers resource1"}, 
        {(unsigned short)1039, (char *)"icc profile"}, 
        {(unsigned short)1040, (char *)"watermark"}, 
        {(unsigned short)1041, (char *)"icc untagger"}, 
        {(unsigned short)1042, (char *)"effects visible"}, 
        {(unsigned short)1043, (char *)"spot halftone"}, 
        {(unsigned short)1044, (char *)"document specific ids"}, 
        {(unsigned short)1045, (char *)"unicode alpha names"}, 
        {(unsigned short)1046, (char *)"indexed color table count"}, 
        {(unsigned short)1047, (char *)"transparent index"}, 
        {(unsigned short)1049, (char *)"global altitude"}, 
        {(unsigned short)1050, (char *)"slices"}, 
        {(unsigned short)1051, (char *)"workflow url"}, 
        {(unsigned short)1052, (char *)"xpep jump"}, 
        {(unsigned short)1053, (char *)"alpha identifiers"}, 
        {(unsigned short)1054, (char *)"url list"}, 
        {(unsigned short)1057, (char *)"version info"}, 
        {(unsigned short)2999, (char *)"clipping path"}, 
        {(unsigned short)10000, (char *)"print flags info"}, 
        {(unsigned short)65535, (char *)((void *)0)}};
#line 71 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
struct adobe_resource_range_descr adobe_resource_ranges_descr[2]  = {      {(unsigned short)2000, (unsigned short)2998, (char *)"path info"}, 
        {(unsigned short)65535, (unsigned short)65535, (char *)((void *)0)}};
#line 82 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
void adobe_8bps_parse(unsigned char *buffer , unsigned long bytes_left , struct parser_result *result ) 
{ 
  struct parser_result res ;
  unsigned char *ptr ;
  unsigned long chunks ;
  unsigned long written_bytes ;
  long bytes ;
  bool ret ;
  size_t tmp ;
  unsigned short tmp___0 ;
  size_t tmp___1 ;
  unsigned short tmp___2 ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned short tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  unsigned long tmp___12 ;

  {
  {
#line 92
  chunks = 0UL;
#line 93
  ptr = buffer;
#line 94
  bytes = (long )bytes_left;
#line 95
  written_bytes = 0UL;
#line 96
  ret = (bool )1;
#line 97
  debug((char *)"8BPS parser: %ld byte(s) to parse", bytes);
  }
#line 100
  if (bytes < 26L) {
    {
#line 102
    ret = (bool )0;
#line 103
    error((char *)"8BPS parser: chunk underrun (%ld byte(s) remaining, 26 or more expected)",
          bytes);
    }
  } else {
    {
#line 109
    tmp___12 = getlong(ptr, 0UL);
    }
#line 109
    if (tmp___12 != 943870035UL) {
      {
#line 111
      ret = (bool )0;
#line 112
      error((char *)"8BPS parser: expected marker not matched");
      }
    } else {
#line 116
      if (prefs.rewrite) {
        {
#line 117
        tmp = dump_rewrite(ptr, 4UL);
#line 117
        written_bytes += tmp;
        }
      }
      {
#line 118
      bytes -= 4L;
#line 119
      ptr += 4;
#line 122
      tmp___11 = getword(ptr, 0UL);
      }
#line 122
      if ((int )tmp___11 != 1) {
        {
#line 124
        ret = (bool )0;
#line 125
        tmp___0 = getword(ptr, 0UL);
#line 125
        error((char *)"8BPS parser: expected version not matched (found 0x%04x, expected 0x0001)",
              (int )tmp___0, 1);
        }
      } else {
#line 130
        if (prefs.rewrite) {
          {
#line 131
          tmp___1 = dump_rewrite(ptr, 2UL);
#line 131
          written_bytes += tmp___1;
          }
        }
        {
#line 132
        bytes -= 2L;
#line 133
        ptr += 2;
#line 136
        tmp___9 = getlong(ptr, 0UL);
        }
#line 136
        if (tmp___9 != 0UL) {
          {
#line 138
          ret = (bool )0;
#line 139
          tmp___2 = getword(ptr, 4UL);
#line 139
          tmp___3 = getlong(ptr, 0UL);
#line 139
          error((char *)"8BPS parser: expected reserved bytes value not matched (found 0x%08lx%04x, expected 0x000000000000)",
                tmp___3, (int )tmp___2);
          }
        } else {
          {
#line 136
          tmp___10 = getword(ptr, 4UL);
          }
#line 136
          if ((int )tmp___10 != 0) {
            {
#line 138
            ret = (bool )0;
#line 139
            tmp___2 = getword(ptr, 4UL);
#line 139
            tmp___3 = getlong(ptr, 0UL);
#line 139
            error((char *)"8BPS parser: expected reserved bytes value not matched (found 0x%08lx%04x, expected 0x000000000000)",
                  tmp___3, (int )tmp___2);
            }
          } else {
#line 144
            if (prefs.rewrite) {
              {
#line 145
              tmp___4 = dump_rewrite(ptr, 6UL);
#line 145
              written_bytes += tmp___4;
              }
            }
#line 146
            bytes -= 6L;
#line 147
            ptr += 6;
#line 150
            if (prefs.rewrite) {
              {
#line 151
              tmp___5 = dump_rewrite(ptr, 14UL);
#line 151
              written_bytes += tmp___5;
              }
            }
#line 152
            bytes -= 14L;
#line 153
            ptr += 14;
#line 154
            chunks ++;
            {
#line 157
            while (1) {
              while_continue: /* CIL Label */ ;
#line 157
              if (! (bytes > 0L)) {
#line 157
                goto while_break;
              }
              {
#line 159
              tmp___8 = getlong(ptr, 0UL);
              }
#line 159
              if (tmp___8 == 943870035UL) {
                {
#line 161
                debug((char *)"8BPS parser: 8BPS marker found");
#line 162
                adobe_8bps_parse(ptr, (unsigned long )bytes, & res);
#line 163
                ret = res.ret;
#line 164
                ptr += res.parsed_bytes;
#line 165
                bytes = (long )((unsigned long )bytes - res.parsed_bytes);
#line 166
                written_bytes += res.written_bytes;
#line 167
                chunks ++;
                }
              } else {
                {
#line 170
                tmp___7 = getlong(ptr, 0UL);
                }
#line 170
                if (tmp___7 == 943868237UL) {
                  {
#line 172
                  debug((char *)"8BPS parser: 8BIM marker found");
#line 173
                  adobe_8bim_parse(ptr, (unsigned long )bytes, (unsigned short const   )0,
                                   & res);
#line 174
                  ret = res.ret;
#line 175
                  ptr += res.parsed_bytes;
#line 176
                  bytes = (long )((unsigned long )bytes - res.parsed_bytes);
#line 177
                  written_bytes += res.written_bytes;
#line 178
                  chunks ++;
                  }
                } else {
                  {
#line 181
                  tmp___6 = getword(buffer, 0UL);
                  }
#line 181
                  if ((int )tmp___6 == ((255 << 8) | 216)) {
                    {
#line 183
                    debug((char *)"8BPS parser: SOI tag found");
#line 184
                    jfif_parse(ptr, (unsigned long const   )bytes, & res);
#line 185
                    ret = res.ret;
#line 186
                    ptr += res.parsed_bytes;
#line 187
                    bytes = (long )((unsigned long )bytes - res.parsed_bytes);
#line 188
                    written_bytes += res.written_bytes;
#line 189
                    chunks ++;
                    }
                  } else {
#line 193
                    if (bytes > 0L) {
                      {
#line 195
                      ret = (bool )0;
#line 196
                      error((char *)"8BPS parser: unsupported chunk follows (%lu byte(s))",
                            bytes);
                      }
                    }
#line 199
                    goto while_break;
                  }
                }
              }
            }
            while_break: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  {
#line 209
  debug((char *)"8BPS parser: %u dataset(s) inspected, total length: %lu byte(s)",
        chunks, bytes_left - (unsigned long )bytes);
  }
#line 211
  if (prefs.rewrite) {
    {
#line 212
    debug((char *)"8BPS parser: %lu byte(s) rewritten", written_bytes);
    }
  }
#line 213
  result->parsed_bytes = bytes_left - (unsigned long )bytes;
#line 214
  result->written_bytes = written_bytes;
#line 215
  result->ret = ret;
#line 216
  return;
}
}
#line 219 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
void adobe_ffo_parse(unsigned char *buffer , unsigned long bytes_left , unsigned short const   photoshop_version ,
                     struct parser_result *result ) 
{ 
  struct parser_result res ;
  unsigned char *ptr ;
  unsigned long chunks ;
  long bytes ;
  unsigned long written_bytes ;
  bool ret ;
  unsigned char version___0 ;
  bool copyrighted ;
  unsigned long length ;
  unsigned char tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned char tmp___3 ;

  {
  {
#line 229
  chunks = 0UL;
#line 230
  ptr = buffer;
#line 231
  bytes = (long )bytes_left;
#line 232
  written_bytes = 0UL;
#line 233
  ret = (bool )1;
#line 234
  debug((char *)"8BIM parser: %ld byte(s), version: %u", bytes, (int const   )photoshop_version);
  }
#line 237
  if (bytes < 16L) {
    {
#line 239
    ret = (bool )0;
#line 240
    error((char *)"FFO parser: chunk underrun (%ld byte(s) remaining, 16 or more expected)",
          bytes);
    }
  } else {
    {
#line 246
    tmp___3 = getbyte(ptr, 0UL);
    }
#line 246
    if ((int )tmp___3 == 170) {
      {
#line 252
      debug((char *)"8BIM parser: FFO tag found");
#line 255
      version___0 = getbyte(ptr, 1UL);
      }
#line 256
      if (prefs.technical) {
#line 256
        if ((int )version___0 != 1) {
          {
#line 257
          warning((char *)"FFO parser: possibly unsupported FFO version %u (expected: 1)",
                  (int )version___0);
          }
        }
      }
      {
#line 260
      tmp = getbyte(ptr, 2UL);
#line 260
      copyrighted = (bool )tmp;
      }
#line 261
      if (copyrighted) {
#line 261
        tmp___0 = "";
      } else {
#line 261
        tmp___0 = "not";
      }
      {
#line 261
      debug((char *)"FFO parser: copyrighted flag is %sset", tmp___0);
      }
#line 263
      if (prefs.rewrite) {
        {
#line 264
        tmp___1 = dump_rewrite(ptr, 1UL);
#line 264
        written_bytes += tmp___1;
        }
      }
      {
#line 265
      ptr += 3;
#line 266
      bytes -= 3L;
#line 269
      length = getlong(ptr, 0UL);
      }
#line 270
      if (prefs.technical) {
#line 270
        if (length == 0UL) {
          {
#line 271
          warning((char *)"FFO parser: zero length image URL field (expected: 1 minimum)");
          }
        }
      }
#line 272
      length *= 2UL;
#line 274
      if (prefs.rewrite) {
        {
#line 275
        tmp___2 = dump_rewrite(ptr, length + 4UL);
#line 275
        written_bytes += tmp___2;
        }
      }
      {
#line 276
      ptr += length + 4UL;
#line 277
      bytes = (long )((unsigned long )bytes - (length + 4UL));
#line 283
      iptc_parse(ptr, (long const   )bytes, (bool const   )0, & res);
#line 284
      ret = res.ret;
      }
    } else {
      {
#line 288
      ret = (bool )0;
#line 289
      error((char *)"FFO parser: expected marker not matched");
      }
    }
  }
#line 293
  result->parsed_bytes = bytes_left - (unsigned long )bytes;
#line 294
  result->written_bytes = written_bytes;
#line 295
  result->ret = ret;
#line 296
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
void adobe_8bim_parse(unsigned char *buffer , unsigned long bytes_left , unsigned short const   photoshop_version ,
                      struct parser_result *result ) 
{ 
  struct parser_result res ;
  unsigned char *ptr ;
  unsigned long chunks ;
  unsigned long written_bytes ;
  unsigned long data_len ;
  unsigned short resource ;
  long bytes ;
  short str_len ;
  bool ret ;
  bool parsed ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned char tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct adobe_resource_descr *resource_descr ;
  struct adobe_resource_range_descr *resource_range_descr ;
  unsigned long offset ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned char foo ;
  size_t tmp___8 ;
  unsigned long tmp___9 ;

  {
  {
#line 313
  chunks = 0UL;
#line 314
  ptr = buffer;
#line 315
  bytes = (long )bytes_left;
#line 316
  written_bytes = 0UL;
#line 317
  ret = (bool )1;
#line 318
  debug((char *)"8BIM parser: %ld byte(s), version: %u", bytes, (int const   )photoshop_version);
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (bytes > 0L)) {
#line 321
      goto while_break;
    }
#line 323
    if (bytes < 4L) {
      {
#line 325
      ret = (bool )0;
#line 326
      error((char *)"8BIM parser: chunk underrun (%ld byte(s) remaining, 4 or more expected)",
            bytes);
      }
#line 328
      goto while_break;
    }
    {
#line 332
    tmp___9 = getlong(ptr, 0UL);
    }
#line 332
    if (tmp___9 == 943868237UL) {
      {
#line 336
      debug((char *)"8BIM parser: 8BIM tag found");
      }
#line 337
      if (prefs.rewrite) {
        {
#line 338
        tmp = dump_rewrite(ptr, 4UL);
#line 338
        written_bytes += tmp;
        }
      }
#line 339
      ptr += 4;
#line 340
      bytes -= 4L;
#line 342
      if (bytes < 2L) {
        {
#line 344
        ret = (bool )0;
#line 345
        error((char *)"8BIM parser: Photoshop generic chunk underrun (%ld byte(s) remaining, 2 or more expected)",
              bytes);
        }
#line 347
        goto while_break;
      }
      {
#line 351
      resource = getword(ptr, 0UL);
      }
#line 352
      if (prefs.rewrite) {
        {
#line 353
        tmp___0 = dump_rewrite(ptr, 2UL);
#line 353
        written_bytes += tmp___0;
        }
      }
      {
#line 354
      ptr += 2;
#line 355
      bytes -= 2L;
#line 357
      debug((char *)"8BIM parser: Photoshop generic chunk assumed");
      }
#line 359
      if (bytes < 6L) {
        {
#line 361
        ret = (bool )0;
#line 362
        error((char *)"8BIM parser: chunk underrun (%ld byte(s) remaining, 6 or more expected)",
              bytes);
        }
#line 364
        goto while_break;
      }
      {
#line 368
      tmp___1 = getbyte(ptr, 0UL);
#line 368
      str_len = (short )tmp___1;
#line 369
      str_len = (short )((int )str_len + 1);
      }
#line 371
      if ((int )str_len & 1) {
#line 372
        str_len = (short )((int )str_len + 1);
      }
#line 375
      if (prefs.rewrite) {
#line 375
        if ((int )str_len > 0) {
          {
#line 376
          tmp___2 = dump_rewrite(ptr, (unsigned long )str_len);
#line 376
          written_bytes += tmp___2;
          }
        }
      }
      {
#line 377
      ptr += (int )str_len;
#line 378
      bytes -= (long )str_len;
#line 381
      data_len = getlong(ptr, 0UL);
      }
#line 382
      if (prefs.rewrite) {
        {
#line 383
        tmp___3 = dump_rewrite(ptr, 4UL);
#line 383
        written_bytes += tmp___3;
        }
      }
#line 384
      ptr += 4;
#line 385
      bytes -= 4L;
#line 387
      if ((int )resource == 1028) {
        {
#line 390
        debug((char *)"8BIM parser: IPTC signature found, invoking sublevel IPTC parser");
#line 391
        iptc_parse(ptr, (long const   )data_len, (bool const   )0, & res);
#line 392
        ret = res.ret;
#line 393
        parsed = (bool )1;
        }
      } else {
        {
#line 400
        resource_descr = adobe_match_resource((enum ADOBE_RESOURCE  const  )resource);
        }
#line 401
        if (resource_descr) {
          {
#line 402
          debug((char *)"8BIM parser: Photoshop %s resource chunk found, skipped",
                resource_descr->label);
          }
        } else {
          {
#line 408
          resource_range_descr = adobe_match_resource_range((enum ADOBE_RESOURCE  const  )resource);
          }
#line 409
          if (resource_range_descr) {
            {
#line 410
            debug((char *)"8BIM parser: Photoshop %s resource chunk found, skipped",
                  resource_range_descr->label);
            }
          } else {
            {
#line 413
            warning((char *)"8BIM parser: unknown Adobe resource code %04x", (int )resource);
            }
          }
        }
#line 416
        res.parsed_bytes = 0UL;
#line 417
        res.written_bytes = 0UL;
#line 418
        parsed = (bool )0;
      }
#line 421
      if (prefs.rewrite) {
#line 423
        written_bytes += res.written_bytes;
#line 427
        if (res.written_bytes != res.parsed_bytes) {
          {
#line 429
          debug((char *)"8BIM parser: backward change of chunk length is necessary (%lu -> %lu)",
                res.parsed_bytes, res.written_bytes);
          }
#line 431
          if (prefs.rewrite_cached) {
            {
#line 436
            offset = (rewrite_cache_offset - res.written_bytes) - 4UL;
#line 437
            tmp___4 = getlong(rewrite_cache, offset);
#line 437
            debug((char *)"8BIM parser: chunk length to change backwardly at offset %lu: %lu (instead of %lu)",
                  offset, res.written_bytes, tmp___4);
#line 440
            setlong(rewrite_cache, offset, res.written_bytes);
            }
          } else {
            {
#line 443
            error((char *)"8BIM parser: attempting to do backward changes to uncached write buffer");
            }
          }
        }
      }
#line 448
      if (res.parsed_bytes > 0UL) {
#line 451
        if (res.parsed_bytes > (unsigned long )bytes) {
          {
#line 454
          ret = (bool )0;
#line 455
          error((char *)"8BIM parser: 8BIM chunk size inconsistency (%lu byte(s), %lu expected)",
                res.parsed_bytes, bytes);
          }
        } else
#line 462
        if (prefs.rewrite) {
#line 462
          if (res.parsed_bytes < data_len) {
            {
#line 463
            tmp___5 = dump_rewrite(ptr + res.parsed_bytes, data_len - res.parsed_bytes);
#line 463
            written_bytes += tmp___5;
            }
          }
        }
      } else
#line 468
      if (prefs.rewrite) {
#line 468
        if (data_len > 0UL) {
          {
#line 469
          tmp___6 = dump_rewrite(ptr, data_len);
#line 469
          written_bytes += tmp___6;
          }
        }
      }
#line 472
      if (data_len < (unsigned long )bytes) {
#line 472
        if (data_len & 1UL) {
          {
#line 474
          debug((char *)"8BIM parser: found padding byte");
          }
#line 476
          if (prefs.rewrite) {
#line 476
            if (! prefs.rewrite_cached) {
              {
#line 478
              tmp___7 = dump_rewrite(ptr + data_len, 1UL);
#line 478
              written_bytes += tmp___7;
#line 479
              debug((char *)"8BIM parser: written padding byte to file");
              }
            } else
#line 476
            if (! parsed) {
              {
#line 478
              tmp___7 = dump_rewrite(ptr + data_len, 1UL);
#line 478
              written_bytes += tmp___7;
#line 479
              debug((char *)"8BIM parser: written padding byte to file");
              }
            }
          }
#line 481
          data_len ++;
        }
      }
#line 485
      if (prefs.rewrite) {
#line 485
        if (prefs.rewrite_cached) {
#line 485
          if (parsed) {
#line 485
            if (res.written_bytes & 1UL) {
              {
#line 492
              foo = (unsigned char )'\000';
#line 493
              tmp___8 = dump_rewrite(& foo, 1UL);
#line 493
              written_bytes += tmp___8;
#line 494
              debug((char *)"8BIM parser: written padding byte to cache");
              }
            }
          }
        }
      }
#line 497
      ptr += data_len;
#line 498
      bytes = (long )((unsigned long )bytes - data_len);
#line 499
      chunks ++;
    } else {
      {
#line 503
      ret = (bool )0;
#line 504
      error((char *)"8BIM parser: expected marker not matched");
      }
#line 505
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  debug((char *)"8BIM parser: %u chunk(s) inspected, total length: %lu byte(s)", chunks,
        bytes_left - (unsigned long )bytes);
  }
#line 511
  if (prefs.rewrite) {
    {
#line 512
    debug((char *)"8BIM parser: %lu byte(s) rewritten", written_bytes);
    }
  }
#line 513
  result->parsed_bytes = bytes_left - (unsigned long )bytes;
#line 514
  result->written_bytes = written_bytes;
#line 515
  result->ret = ret;
#line 516
  return;
}
}
#line 518 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
struct adobe_resource_descr *adobe_match_resource(enum ADOBE_RESOURCE  const  resource ) 
{ 
  int i ;

  {
#line 522
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((int )adobe_resources_descr[i].resource != 65535)) {
#line 523
      goto while_break;
    }
#line 525
    if ((unsigned int const   )adobe_resources_descr[i].resource == (unsigned int const   )resource) {
#line 526
      return (& adobe_resources_descr[i]);
    }
#line 527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  return ((struct adobe_resource_descr *)((void *)0));
}
}
#line 532 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
struct adobe_resource_range_descr *adobe_match_resource_range(enum ADOBE_RESOURCE  const  resource ) 
{ 
  int i ;

  {
#line 537
  i = 0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! ((int )adobe_resource_ranges_descr[i].lower_boundary != 65535)) {
#line 538
      goto while_break;
    }
#line 540
    if ((unsigned int const   )resource <= (unsigned int const   )adobe_resource_ranges_descr[i].lower_boundary) {
#line 542
      return (& adobe_resource_ranges_descr[i]);
    } else
#line 540
    if ((unsigned int const   )resource <= (unsigned int const   )adobe_resource_ranges_descr[i].upper_boundary) {
#line 542
      return (& adobe_resource_ranges_descr[i]);
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  return ((struct adobe_resource_range_descr *)((void *)0));
}
}
#line 548 "/home/wheatley/newnew/temp/pecomato-0.0.15/adobe.c"
void adobe_dump_resource_list(void) 
{ 


  {
#line 550
  return;
}
}
