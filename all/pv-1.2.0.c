/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 14 "./src/include/options.h"
struct opts_s;
#line 15 "./src/include/options.h"
typedef struct opts_s *opts_t;
#line 17 "./src/include/options.h"
struct opts_s {
   char *program_name ;
   unsigned char do_nothing ;
   unsigned char progress ;
   unsigned char timer ;
   unsigned char eta ;
   unsigned char rate ;
   unsigned char average_rate ;
   unsigned char bytes ;
   unsigned char force ;
   unsigned char cursor ;
   unsigned char numeric ;
   unsigned char wait ;
   unsigned char linemode ;
   unsigned char no_op ;
   unsigned long long rate_limit ;
   unsigned long long buffer_size ;
   unsigned int remote ;
   unsigned long long size ;
   double interval ;
   unsigned int width ;
   unsigned int height ;
   char *name ;
   int argc ;
   char **argv ;
   char *current_file ;
   unsigned char exit_status ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 18 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/help.c"
struct optdesc_s {
   char *optshort ;
   char *optlong ;
   char *param ;
   char *description ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_9 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_10 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_11 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_12 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_13 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_14 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_15 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_8 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_9 _kill ;
   struct __anonstruct__timer_10 _timer ;
   struct __anonstruct__rt_11 _rt ;
   struct __anonstruct__sigchld_12 _sigchld ;
   struct __anonstruct__sigfault_13 _sigfault ;
   struct __anonstruct__sigpoll_14 _sigpoll ;
   struct __anonstruct__sigsys_15 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_7 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_8 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_7 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_27 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_27 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/msq.h"
typedef __syscall_ulong_t msgqnum_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/msq.h"
typedef __syscall_ulong_t msglen_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/msq.h"
struct msqid_ds {
   struct ipc_perm msg_perm ;
   __time_t msg_stime ;
   __time_t msg_rtime ;
   __time_t msg_ctime ;
   __syscall_ulong_t __msg_cbytes ;
   msgqnum_t msg_qnum ;
   msglen_t msg_qbytes ;
   __pid_t msg_lspid ;
   __pid_t msg_lrpid ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 23 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
struct remote_msg {
   long mtype ;
   unsigned char progress ;
   unsigned char timer ;
   unsigned char eta ;
   unsigned char rate ;
   unsigned char average_rate ;
   unsigned char bytes ;
   unsigned long long rate_limit ;
   unsigned long long buffer_size ;
   unsigned long long size ;
   double interval ;
   unsigned int width ;
   unsigned int height ;
   char name[256] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 130 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
struct pv_display_state {
   long percentage ;
   long double prev_elapsed_sec ;
   long double prev_rate ;
   long double prev_trans ;
   char *outbuffer ;
   long outbufsize ;
   opts_t opts ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 159 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/shm.h"
typedef __syscall_ulong_t shmatt_t;
#line 49 "/usr/include/x86_64-linux-gnu/bits/shm.h"
struct shmid_ds {
   struct ipc_perm shm_perm ;
   size_t shm_segsz ;
   __time_t shm_atime ;
   __time_t shm_dtime ;
   __time_t shm_ctime ;
   __pid_t shm_cpid ;
   __pid_t shm_lpid ;
   shmatt_t shm_nattch ;
   __syscall_ulong_t __glibc_reserved4 ;
   __syscall_ulong_t __glibc_reserved5 ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "./src/include/options.h"
opts_t opts_parse(int argc , char **argv ) ;
#line 47
void opts_free(opts_t opts ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 19 "./src/include/pv.h"
double pv_getnum_d(char *str ) ;
#line 20
int pv_getnum_i(char *str ) ;
#line 21
long long pv_getnum_ll(char *str ) ;
#line 22
int pv_getnum_check(char *str , int type ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 21 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/options.c"
void display_help(void) ;
#line 22
void display_version(void) ;
#line 28 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/options.c"
void opts_free(opts_t opts ) 
{ 


  {
#line 30
  if (! opts) {
#line 31
    return;
  }
#line 32
  if (opts->argv) {
    {
#line 33
    free((void *)opts->argv);
    }
  }
  {
#line 34
  free((void *)opts);
  }
#line 35
  return;
}
}
#line 48 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/options.c"
opts_t opts_parse(int argc , char **argv ) 
{ 
  struct option long_options[23] ;
  int option_index ;
  char *short_options ;
  int c ;
  int numopts ;
  opts_t opts ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  long long tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  long long tmp___14 ;
  long long tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 51
  long_options[0].name = "help";
#line 51
  long_options[0].has_arg = 0;
#line 51
  long_options[0].flag = (int *)0;
#line 51
  long_options[0].val = 'h';
#line 51
  long_options[1].name = "version";
#line 51
  long_options[1].has_arg = 0;
#line 51
  long_options[1].flag = (int *)0;
#line 51
  long_options[1].val = 'V';
#line 51
  long_options[2].name = "progress";
#line 51
  long_options[2].has_arg = 0;
#line 51
  long_options[2].flag = (int *)0;
#line 51
  long_options[2].val = 'p';
#line 51
  long_options[3].name = "timer";
#line 51
  long_options[3].has_arg = 0;
#line 51
  long_options[3].flag = (int *)0;
#line 51
  long_options[3].val = 't';
#line 51
  long_options[4].name = "eta";
#line 51
  long_options[4].has_arg = 0;
#line 51
  long_options[4].flag = (int *)0;
#line 51
  long_options[4].val = 'e';
#line 51
  long_options[5].name = "rate";
#line 51
  long_options[5].has_arg = 0;
#line 51
  long_options[5].flag = (int *)0;
#line 51
  long_options[5].val = 'r';
#line 51
  long_options[6].name = "average-rate";
#line 51
  long_options[6].has_arg = 0;
#line 51
  long_options[6].flag = (int *)0;
#line 51
  long_options[6].val = 'a';
#line 51
  long_options[7].name = "bytes";
#line 51
  long_options[7].has_arg = 0;
#line 51
  long_options[7].flag = (int *)0;
#line 51
  long_options[7].val = 'b';
#line 51
  long_options[8].name = "force";
#line 51
  long_options[8].has_arg = 0;
#line 51
  long_options[8].flag = (int *)0;
#line 51
  long_options[8].val = 'f';
#line 51
  long_options[9].name = "numeric";
#line 51
  long_options[9].has_arg = 0;
#line 51
  long_options[9].flag = (int *)0;
#line 51
  long_options[9].val = 'n';
#line 51
  long_options[10].name = "quiet";
#line 51
  long_options[10].has_arg = 0;
#line 51
  long_options[10].flag = (int *)0;
#line 51
  long_options[10].val = 'q';
#line 51
  long_options[11].name = "cursor";
#line 51
  long_options[11].has_arg = 0;
#line 51
  long_options[11].flag = (int *)0;
#line 51
  long_options[11].val = 'c';
#line 51
  long_options[12].name = "wait";
#line 51
  long_options[12].has_arg = 0;
#line 51
  long_options[12].flag = (int *)0;
#line 51
  long_options[12].val = 'W';
#line 51
  long_options[13].name = "size";
#line 51
  long_options[13].has_arg = 1;
#line 51
  long_options[13].flag = (int *)0;
#line 51
  long_options[13].val = 's';
#line 51
  long_options[14].name = "line-mode";
#line 51
  long_options[14].has_arg = 0;
#line 51
  long_options[14].flag = (int *)0;
#line 51
  long_options[14].val = 'l';
#line 51
  long_options[15].name = "interval";
#line 51
  long_options[15].has_arg = 1;
#line 51
  long_options[15].flag = (int *)0;
#line 51
  long_options[15].val = 'i';
#line 51
  long_options[16].name = "width";
#line 51
  long_options[16].has_arg = 1;
#line 51
  long_options[16].flag = (int *)0;
#line 51
  long_options[16].val = 'w';
#line 51
  long_options[17].name = "height";
#line 51
  long_options[17].has_arg = 1;
#line 51
  long_options[17].flag = (int *)0;
#line 51
  long_options[17].val = 'H';
#line 51
  long_options[18].name = "name";
#line 51
  long_options[18].has_arg = 1;
#line 51
  long_options[18].flag = (int *)0;
#line 51
  long_options[18].val = 'N';
#line 51
  long_options[19].name = "rate-limit";
#line 51
  long_options[19].has_arg = 1;
#line 51
  long_options[19].flag = (int *)0;
#line 51
  long_options[19].val = 'L';
#line 51
  long_options[20].name = "buffer-size";
#line 51
  long_options[20].has_arg = 1;
#line 51
  long_options[20].flag = (int *)0;
#line 51
  long_options[20].val = 'B';
#line 51
  long_options[21].name = "remote";
#line 51
  long_options[21].has_arg = 1;
#line 51
  long_options[21].flag = (int *)0;
#line 51
  long_options[21].val = 'R';
#line 51
  long_options[22].name = (char const   *)0;
#line 51
  long_options[22].has_arg = 0;
#line 51
  long_options[22].flag = (int *)0;
#line 51
  long_options[22].val = 0;
#line 76
  option_index = 0;
#line 78
  short_options = (char *)"hVpterabfnqcWs:li:w:H:N:L:B:R:";
#line 82
  tmp = calloc((size_t )1, sizeof(*opts));
#line 82
  opts = (opts_t )tmp;
  }
#line 83
  if (! opts) {
    {
#line 84
    tmp___0 = __errno_location();
#line 84
    tmp___1 = strerror(*tmp___0);
#line 84
    tmp___2 = gettext("%s: option structure allocation failed (%s)");
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
            *(argv + 0), tmp___1);
#line 87
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 88
    return ((opts_t )0);
  }
  {
#line 91
  opts->program_name = *(argv + 0);
#line 93
  opts->argc = 0;
#line 94
  tmp___3 = calloc((size_t )(argc + 1), sizeof(char *));
#line 94
  opts->argv = (char **)tmp___3;
  }
#line 95
  if (! opts->argv) {
    {
#line 96
    tmp___4 = __errno_location();
#line 96
    tmp___5 = strerror(*tmp___4);
#line 96
    tmp___6 = gettext("%s: option structure argv allocation failed (%s)");
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            *(argv + 0), tmp___5);
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 101
    opts_free(opts);
    }
#line 102
    return ((opts_t )0);
  }
#line 105
  numopts = 0;
#line 107
  opts->interval = (double )1;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 111
    c = getopt_long(argc, (char * const  *)argv, (char const   *)short_options, (struct option  const  *)(long_options),
                    & option_index);
    }
#line 117
    if (c < 0) {
#line 118
      goto __Cont;
    }
    {
#line 129
    if (c == 82) {
#line 129
      goto case_82;
    }
#line 129
    if (c == 66) {
#line 129
      goto case_82;
    }
#line 129
    if (c == 76) {
#line 129
      goto case_82;
    }
#line 129
    if (c == 72) {
#line 129
      goto case_82;
    }
#line 129
    if (c == 119) {
#line 129
      goto case_82;
    }
#line 129
    if (c == 115) {
#line 129
      goto case_82;
    }
#line 137
    if (c == 105) {
#line 137
      goto case_105;
    }
#line 145
    goto switch_default;
    case_82: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_115: /* CIL Label */ 
    {
#line 130
    tmp___8 = pv_getnum_check(optarg, 0);
    }
#line 130
    if (tmp___8) {
      {
#line 131
      tmp___7 = gettext("integer argument expected");
#line 131
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -%c: %s\n",
              *(argv + 0), c, tmp___7);
#line 133
      opts_free(opts);
      }
#line 134
      return ((opts_t )0);
    }
#line 136
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 138
    tmp___10 = pv_getnum_check(optarg, 1);
    }
#line 138
    if (tmp___10) {
      {
#line 139
      tmp___9 = gettext("numeric argument expected");
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -%c: %s\n",
              *(argv + 0), c, tmp___9);
#line 141
      opts_free(opts);
      }
#line 142
      return ((opts_t )0);
    }
#line 144
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 146
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 153
    if (c == 104) {
#line 153
      goto case_104;
    }
#line 158
    if (c == 86) {
#line 158
      goto case_86;
    }
#line 163
    if (c == 112) {
#line 163
      goto case_112;
    }
#line 167
    if (c == 116) {
#line 167
      goto case_116;
    }
#line 171
    if (c == 101) {
#line 171
      goto case_101;
    }
#line 175
    if (c == 114) {
#line 175
      goto case_114;
    }
#line 179
    if (c == 97) {
#line 179
      goto case_97;
    }
#line 183
    if (c == 98) {
#line 183
      goto case_98;
    }
#line 187
    if (c == 102) {
#line 187
      goto case_102;
    }
#line 190
    if (c == 110) {
#line 190
      goto case_110;
    }
#line 194
    if (c == 113) {
#line 194
      goto case_113;
    }
#line 198
    if (c == 99) {
#line 198
      goto case_99;
    }
#line 201
    if (c == 87) {
#line 201
      goto case_87;
    }
#line 204
    if (c == 115) {
#line 204
      goto case_115___0;
    }
#line 207
    if (c == 108) {
#line 207
      goto case_108;
    }
#line 210
    if (c == 105) {
#line 210
      goto case_105___0;
    }
#line 213
    if (c == 119) {
#line 213
      goto case_119___0;
    }
#line 216
    if (c == 72) {
#line 216
      goto case_72___0;
    }
#line 219
    if (c == 78) {
#line 219
      goto case_78;
    }
#line 222
    if (c == 76) {
#line 222
      goto case_76___0;
    }
#line 225
    if (c == 66) {
#line 225
      goto case_66___0;
    }
#line 228
    if (c == 82) {
#line 228
      goto case_82___0;
    }
#line 231
    goto switch_default___0;
    case_104: /* CIL Label */ 
    {
#line 154
    display_help();
#line 155
    opts->do_nothing = (unsigned char)1;
    }
#line 156
    return (opts);
#line 157
    goto switch_break___0;
    case_86: /* CIL Label */ 
    {
#line 159
    display_version();
#line 160
    opts->do_nothing = (unsigned char)1;
    }
#line 161
    return (opts);
#line 162
    goto switch_break___0;
    case_112: /* CIL Label */ 
#line 164
    opts->progress = (unsigned char)1;
#line 165
    numopts ++;
#line 166
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 168
    opts->timer = (unsigned char)1;
#line 169
    numopts ++;
#line 170
    goto switch_break___0;
    case_101: /* CIL Label */ 
#line 172
    opts->eta = (unsigned char)1;
#line 173
    numopts ++;
#line 174
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 176
    opts->rate = (unsigned char)1;
#line 177
    numopts ++;
#line 178
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 180
    opts->average_rate = (unsigned char)1;
#line 181
    numopts ++;
#line 182
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 184
    opts->bytes = (unsigned char)1;
#line 185
    numopts ++;
#line 186
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 188
    opts->force = (unsigned char)1;
#line 189
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 191
    opts->numeric = (unsigned char)1;
#line 192
    numopts ++;
#line 193
    goto switch_break___0;
    case_113: /* CIL Label */ 
#line 195
    opts->no_op = (unsigned char)1;
#line 196
    numopts ++;
#line 197
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 199
    opts->cursor = (unsigned char)1;
#line 200
    goto switch_break___0;
    case_87: /* CIL Label */ 
#line 202
    opts->wait = (unsigned char)1;
#line 203
    goto switch_break___0;
    case_115___0: /* CIL Label */ 
    {
#line 205
    tmp___11 = pv_getnum_ll(optarg);
#line 205
    opts->size = (unsigned long long )tmp___11;
    }
#line 206
    goto switch_break___0;
    case_108: /* CIL Label */ 
#line 208
    opts->linemode = (unsigned char)1;
#line 209
    goto switch_break___0;
    case_105___0: /* CIL Label */ 
    {
#line 211
    opts->interval = pv_getnum_d(optarg);
    }
#line 212
    goto switch_break___0;
    case_119___0: /* CIL Label */ 
    {
#line 214
    tmp___12 = pv_getnum_i(optarg);
#line 214
    opts->width = (unsigned int )tmp___12;
    }
#line 215
    goto switch_break___0;
    case_72___0: /* CIL Label */ 
    {
#line 217
    tmp___13 = pv_getnum_i(optarg);
#line 217
    opts->height = (unsigned int )tmp___13;
    }
#line 218
    goto switch_break___0;
    case_78: /* CIL Label */ 
#line 220
    opts->name = optarg;
#line 221
    goto switch_break___0;
    case_76___0: /* CIL Label */ 
    {
#line 223
    tmp___14 = pv_getnum_ll(optarg);
#line 223
    opts->rate_limit = (unsigned long long )tmp___14;
    }
#line 224
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 226
    tmp___15 = pv_getnum_ll(optarg);
#line 226
    opts->buffer_size = (unsigned long long )tmp___15;
    }
#line 227
    goto switch_break___0;
    case_82___0: /* CIL Label */ 
    {
#line 229
    tmp___16 = pv_getnum_i(optarg);
#line 229
    opts->remote = (unsigned int )tmp___16;
    }
#line 230
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 233
    tmp___17 = gettext("Try `%s --help\' for more information.");
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
            *(argv + 0));
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 242
    opts_free(opts);
    }
#line 243
    return ((opts_t )0);
#line 244
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 109
    if (! (c != -1)) {
#line 109
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  if (numopts == 0) {
#line 253
    opts->progress = (unsigned char)1;
#line 254
    opts->timer = (unsigned char)1;
#line 255
    opts->eta = (unsigned char)1;
#line 256
    opts->rate = (unsigned char)1;
#line 257
    opts->bytes = (unsigned char)1;
  }
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 263
    if (! (optind < argc)) {
#line 263
      goto while_break___0;
    }
#line 264
    tmp___18 = opts->argc;
#line 264
    (opts->argc) ++;
#line 264
    tmp___19 = optind;
#line 264
    optind ++;
#line 264
    *(opts->argv + tmp___18) = *(argv + tmp___19);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 267
  opts->exit_status = (unsigned char)0;
#line 269
  return (opts);
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 24 "./src/include/pv.h"
void pv_screensize(opts_t opts ) ;
#line 25
void pv_calc_total_size(opts_t opts ) ;
#line 27
int pv_main_loop(opts_t opts ) ;
#line 42
void pv_sig_init(void) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 23 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/main.c"
int remote_set(opts_t opts ) ;
#line 24
void remote_sig_init(opts_t opts ) ;
#line 31 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/main.c"
int main(int argc , char **argv ) 
{ 
  struct termios t ;
  struct termios t_save ;
  opts_t opts ;
  int retcode ;
  int tmp ;
  int tmp___0 ;
  int tmpheight ;
  int tmpwidth ;

  {
  {
#line 35
  retcode = 0;
#line 38
  setlocale(6, "");
#line 39
  bindtextdomain("pv", "/usr/local/share/locale");
#line 40
  textdomain("pv");
#line 43
  opts = opts_parse(argc, argv);
  }
#line 44
  if (! opts) {
#line 45
    return (1);
  }
#line 46
  if (opts->do_nothing) {
    {
#line 47
    opts_free(opts);
    }
#line 48
    return (0);
  }
#line 51
  if (opts->remote > 0U) {
#line 52
    if (opts->width < 0U) {
#line 53
      opts->width = 80U;
    }
#line 54
    if (opts->height < 0U) {
#line 55
      opts->height = 25U;
    }
#line 56
    if (opts->width > 999999U) {
#line 57
      opts->width = 999999U;
    }
#line 58
    if (opts->height > 999999U) {
#line 59
      opts->height = 999999U;
    }
#line 60
    if (opts->interval != (double )0) {
#line 60
      if (opts->interval < 0.1) {
#line 61
        opts->interval = 0.1;
      }
    }
#line 62
    if (opts->interval > (double )600) {
#line 63
      opts->interval = (double )600;
    }
    {
#line 64
    retcode = remote_set(opts);
#line 65
    opts_free(opts);
    }
#line 66
    return (retcode);
  }
#line 72
  if (opts->argc == 0) {
#line 73
    tmp = opts->argc;
#line 73
    (opts->argc) ++;
#line 73
    *(opts->argv + tmp) = (char *)"-";
  }
#line 76
  if (opts->size == 0ULL) {
    {
#line 77
    pv_calc_total_size(opts);
    }
  }
#line 80
  if (opts->size < 1ULL) {
#line 81
    opts->eta = (unsigned char)0;
  }
  {
#line 83
  tmp___0 = isatty(2);
  }
#line 83
  if (tmp___0 == 0) {
#line 83
    if ((int )opts->force == 0) {
#line 83
      if ((int )opts->numeric == 0) {
#line 86
        opts->no_op = (unsigned char)1;
      }
    }
  }
#line 89
  if (opts->width == 0U) {
    {
#line 91
    tmpheight = (int )opts->height;
#line 92
    pv_screensize(opts);
    }
#line 93
    if (tmpheight > 0) {
#line 94
      opts->height = (unsigned int )tmpheight;
    }
  }
#line 97
  if (opts->height == 0U) {
    {
#line 99
    tmpwidth = (int )opts->width;
#line 100
    pv_screensize(opts);
    }
#line 101
    if (tmpwidth > 0) {
#line 102
      opts->width = (unsigned int )tmpwidth;
    }
  }
#line 108
  if (opts->width < 1U) {
#line 109
    opts->width = 80U;
  }
#line 111
  if (opts->height < 1U) {
#line 112
    opts->height = 25U;
  }
#line 114
  if (opts->width > 999999U) {
#line 115
    opts->width = 999999U;
  }
#line 117
  if (opts->height > 999999U) {
#line 118
    opts->height = 999999U;
  }
#line 123
  if (opts->interval < 0.1) {
#line 124
    opts->interval = 0.1;
  }
#line 125
  if (opts->interval > (double )600) {
#line 126
    opts->interval = (double )600;
  }
  {
#line 145
  tcgetattr(2, & t);
#line 146
  t_save = t;
#line 147
  t.c_lflag |= 256U;
#line 148
  tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 150
  opts->current_file = (char *)"(stdin)";
#line 152
  pv_sig_init();
#line 153
  remote_sig_init(opts);
#line 155
  retcode = pv_main_loop(opts);
#line 157
  opts_free(opts);
#line 159
  tcsetattr(2, 0, (struct termios  const  *)(& t_save));
  }
#line 161
  return (retcode);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 29 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/help.c"
void display_help(void) 
{ 
  struct optdesc_s optlist[25] ;
  int i ;
  int col1max ;
  int tw ;
  char *optbuf ;
  char *tmp ;
  char *tmp___0 ;
  int width ;
  char *param ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *param___0 ;
  char *description ;
  char *start ;
  char *end ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 31
  optlist[0].optshort = (char *)"-p";
#line 31
  optlist[0].optlong = (char *)"--progress";
#line 31
  optlist[0].param = (char *)0;
#line 31
  optlist[0].description = (char *)"show progress bar";
#line 31
  optlist[1].optshort = (char *)"-t";
#line 31
  optlist[1].optlong = (char *)"--timer";
#line 31
  optlist[1].param = (char *)0;
#line 31
  optlist[1].description = (char *)"show elapsed time";
#line 31
  optlist[2].optshort = (char *)"-e";
#line 31
  optlist[2].optlong = (char *)"--eta";
#line 31
  optlist[2].param = (char *)0;
#line 31
  optlist[2].description = (char *)"show estimated time of arrival (completion)";
#line 31
  optlist[3].optshort = (char *)"-r";
#line 31
  optlist[3].optlong = (char *)"--rate";
#line 31
  optlist[3].param = (char *)0;
#line 31
  optlist[3].description = (char *)"show data transfer rate counter";
#line 31
  optlist[4].optshort = (char *)"-a";
#line 31
  optlist[4].optlong = (char *)"--average-rate";
#line 31
  optlist[4].param = (char *)0;
#line 31
  optlist[4].description = (char *)"show data transfer average rate counter";
#line 31
  optlist[5].optshort = (char *)"-b";
#line 31
  optlist[5].optlong = (char *)"--bytes";
#line 31
  optlist[5].param = (char *)0;
#line 31
  optlist[5].description = (char *)"show number of bytes transferred";
#line 31
  optlist[6].optshort = (char *)"-f";
#line 31
  optlist[6].optlong = (char *)"--force";
#line 31
  optlist[6].param = (char *)0;
#line 31
  optlist[6].description = (char *)"output even if standard error is not a terminal";
#line 31
  optlist[7].optshort = (char *)"-n";
#line 31
  optlist[7].optlong = (char *)"--numeric";
#line 31
  optlist[7].param = (char *)0;
#line 31
  optlist[7].description = (char *)"output percentages, not visual information";
#line 31
  optlist[8].optshort = (char *)"-q";
#line 31
  optlist[8].optlong = (char *)"--quiet";
#line 31
  optlist[8].param = (char *)0;
#line 31
  optlist[8].description = (char *)"do not output any transfer information at all";
#line 31
  optlist[9].optshort = (char *)"-c";
#line 31
  optlist[9].optlong = (char *)"--cursor";
#line 31
  optlist[9].param = (char *)0;
#line 31
  optlist[9].description = (char *)"use cursor positioning escape sequences";
#line 31
  optlist[10].optshort = (char *)"-W";
#line 31
  optlist[10].optlong = (char *)"--wait";
#line 31
  optlist[10].param = (char *)0;
#line 31
  optlist[10].description = (char *)"display nothing until first byte transferred";
#line 31
  optlist[11].optshort = (char *)"-s";
#line 31
  optlist[11].optlong = (char *)"--size";
#line 31
  optlist[11].param = (char *)"SIZE";
#line 31
  optlist[11].description = (char *)"set estimated data size to SIZE bytes";
#line 31
  optlist[12].optshort = (char *)"-l";
#line 31
  optlist[12].optlong = (char *)"--line-mode";
#line 31
  optlist[12].param = (char *)0;
#line 31
  optlist[12].description = (char *)"count lines instead of bytes";
#line 31
  optlist[13].optshort = (char *)"-i";
#line 31
  optlist[13].optlong = (char *)"--interval";
#line 31
  optlist[13].param = (char *)"SEC";
#line 31
  optlist[13].description = (char *)"update every SEC seconds";
#line 31
  optlist[14].optshort = (char *)"-w";
#line 31
  optlist[14].optlong = (char *)"--width";
#line 31
  optlist[14].param = (char *)"WIDTH";
#line 31
  optlist[14].description = (char *)"assume terminal is WIDTH characters wide";
#line 31
  optlist[15].optshort = (char *)"-H";
#line 31
  optlist[15].optlong = (char *)"--height";
#line 31
  optlist[15].param = (char *)"HEIGHT";
#line 31
  optlist[15].description = (char *)"assume terminal is HEIGHT rows high";
#line 31
  optlist[16].optshort = (char *)"-N";
#line 31
  optlist[16].optlong = (char *)"--name";
#line 31
  optlist[16].param = (char *)"NAME";
#line 31
  optlist[16].description = (char *)"prefix visual information with NAME";
#line 31
  optlist[17].optshort = (char *)"";
#line 31
  optlist[17].optlong = (char *)0;
#line 31
  optlist[17].param = (char *)0;
#line 31
  optlist[17].description = (char *)0;
#line 31
  optlist[18].optshort = (char *)"-L";
#line 31
  optlist[18].optlong = (char *)"--rate-limit";
#line 31
  optlist[18].param = (char *)"RATE";
#line 31
  optlist[18].description = (char *)"limit transfer to RATE bytes per second";
#line 31
  optlist[19].optshort = (char *)"-B";
#line 31
  optlist[19].optlong = (char *)"--buffer-size";
#line 31
  optlist[19].param = (char *)"BYTES";
#line 31
  optlist[19].description = (char *)"use a buffer size of BYTES";
#line 31
  optlist[20].optshort = (char *)"-R";
#line 31
  optlist[20].optlong = (char *)"--remote";
#line 31
  optlist[20].param = (char *)"PID";
#line 31
  optlist[20].description = (char *)"update settings of process PID";
#line 31
  optlist[21].optshort = (char *)"";
#line 31
  optlist[21].optlong = (char *)0;
#line 31
  optlist[21].param = (char *)0;
#line 31
  optlist[21].description = (char *)0;
#line 31
  optlist[22].optshort = (char *)"-h";
#line 31
  optlist[22].optlong = (char *)"--help";
#line 31
  optlist[22].param = (char *)0;
#line 31
  optlist[22].description = (char *)"show this help and exit";
#line 31
  optlist[23].optshort = (char *)"-V";
#line 31
  optlist[23].optlong = (char *)"--version";
#line 31
  optlist[23].param = (char *)0;
#line 31
  optlist[23].description = (char *)"show version information and exit";
#line 31
  optlist[24].optshort = (char *)0;
#line 31
  optlist[24].optlong = (char *)0;
#line 31
  optlist[24].param = (char *)0;
#line 31
  optlist[24].description = (char *)0;
#line 80
  col1max = 0;
#line 80
  tw = 77;
#line 83
  tmp = gettext("Usage: %s [OPTION] [FILE]...");
#line 83
  printf((char const   */* __restrict  */)tmp, "pv");
#line 85
  tmp___0 = gettext("Concatenate FILE(s), or standard input, to standard output,\nwith monitoring.");
#line 85
  printf((char const   */* __restrict  */)"\n%s\n\n", tmp___0);
#line 90
  i = 0;
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! optlist[i].optshort) {
#line 90
      goto while_break;
    }
    {
#line 91
    width = 0;
#line 94
    tmp___1 = strlen((char const   *)optlist[i].optshort);
#line 94
    width = (int )(2UL + tmp___1);
    }
#line 96
    if (optlist[i].optlong) {
      {
#line 97
      tmp___2 = strlen((char const   *)optlist[i].optlong);
#line 97
      width = (int )((size_t )width + (2UL + tmp___2));
      }
    }
#line 99
    param = optlist[i].param;
#line 100
    if (param) {
      {
#line 101
      param = gettext((char const   *)param);
      }
    }
#line 102
    if (param) {
      {
#line 103
      tmp___3 = strlen((char const   *)param);
#line 103
      width = (int )((size_t )width + (1UL + tmp___3));
      }
    }
#line 105
    if (width > col1max) {
#line 106
      col1max = width;
    }
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  col1max ++;
#line 111
  tmp___4 = malloc((size_t )(col1max + 16));
#line 111
  optbuf = (char *)tmp___4;
  }
#line 112
  if ((unsigned long )optbuf == (unsigned long )((void *)0)) {
    {
#line 113
    tmp___5 = __errno_location();
#line 113
    tmp___6 = strerror(*tmp___5);
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            "pv", tmp___6);
#line 114
    exit(1);
    }
  }
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    if (! optlist[i].optshort) {
#line 117
      goto while_break___0;
    }
#line 123
    if ((int )*(optlist[i].optshort + 0) == 0) {
      {
#line 124
      printf((char const   */* __restrict  */)"\n");
      }
#line 125
      goto __Cont;
    }
#line 128
    param___0 = optlist[i].param;
#line 129
    if (param___0) {
      {
#line 130
      param___0 = gettext((char const   *)param___0);
      }
    }
#line 131
    description = optlist[i].description;
#line 132
    if (description) {
      {
#line 133
      description = gettext((char const   *)description);
      }
    }
#line 135
    if (param___0) {
#line 135
      tmp___7 = (char const   *)param___0;
    } else {
#line 135
      tmp___7 = "";
    }
#line 135
    if (param___0) {
#line 135
      tmp___8 = " ";
    } else {
#line 135
      tmp___8 = "";
    }
#line 135
    if (optlist[i].optlong) {
#line 135
      tmp___9 = (char const   *)optlist[i].optlong;
    } else {
#line 135
      tmp___9 = "";
    }
#line 135
    if (optlist[i].optlong) {
#line 135
      tmp___10 = ", ";
    } else {
#line 135
      tmp___10 = "";
    }
    {
#line 135
    sprintf((char */* __restrict  */)optbuf, (char const   */* __restrict  */)"%s%s%s%s%s",
            optlist[i].optshort, tmp___10, tmp___9, tmp___8, tmp___7);
#line 145
    printf((char const   */* __restrict  */)"  %-*s ", col1max - 2, optbuf);
    }
#line 147
    if ((unsigned long )description == (unsigned long )((void *)0)) {
      {
#line 148
      printf((char const   */* __restrict  */)"\n");
      }
#line 149
      goto __Cont;
    }
#line 152
    start = description;
    {
#line 154
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 154
      tmp___11 = strlen((char const   *)start);
      }
#line 154
      if (! (tmp___11 > (size_t )(tw - col1max))) {
#line 154
        goto while_break___1;
      }
#line 155
      end = (start + tw) - col1max;
      {
#line 156
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 156
        if ((unsigned long )end > (unsigned long )start) {
#line 156
          if (! ((int )*(end + 0) != 32)) {
#line 156
            goto while_break___2;
          }
        } else {
#line 156
          goto while_break___2;
        }
#line 157
        end --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 158
      if ((unsigned long )end == (unsigned long )start) {
#line 159
        end = (start + tw) - col1max;
      } else {
#line 161
        end ++;
      }
      {
#line 163
      printf((char const   */* __restrict  */)"%.*s\n%*s ", (int )(end - start), start,
             col1max, "");
      }
#line 165
      if ((unsigned long )end == (unsigned long )start) {
#line 166
        end ++;
      }
#line 167
      start = end;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 170
    printf((char const   */* __restrict  */)"%s\n", start);
    }
    __Cont: /* CIL Label */ 
#line 117
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 173
  printf((char const   */* __restrict  */)"\n");
#line 174
  tmp___12 = gettext("Andrew Wood <andrew.wood@ivarch.com>");
#line 174
  tmp___13 = gettext("Please report any bugs to %s.");
#line 174
  printf((char const   */* __restrict  */)tmp___13, tmp___12);
#line 176
  printf((char const   */* __restrict  */)"\n");
  }
#line 177
  return;
}
}
#line 30 "./src/include/pv.h"
void pv_set_buffer_size(unsigned long long sz , int force ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname ,
                                                                             int __proj_id ) ;
#line 62 "/usr/include/x86_64-linux-gnu/sys/msg.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) msgctl)(int __msqid ,
                                                                             int __cmd ,
                                                                             struct msqid_ds *__buf ) ;
#line 65
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) msgget)(key_t __key ,
                                                                             int __msgflg ) ;
#line 71
extern ssize_t msgrcv(int __msqid , void *__msgp , size_t __msgsz , long __msgtyp ,
                      int __msgflg ) ;
#line 78
extern int msgsnd(int __msqid , void const   *__msgp , size_t __msgsz , int __msgflg ) ;
#line 41 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static opts_t remote__opts  =    (opts_t )((void *)0);
#line 53 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static key_t remote__genkey(opts_t opts ) 
{ 
  int uid ;
  key_t key ;
  __uid_t tmp ;
  key_t tmp___0 ;

  {
  {
#line 58
  tmp = geteuid();
#line 58
  uid = (int )tmp;
  }
#line 59
  if (uid < 0) {
#line 60
    uid = 0;
  }
  {
#line 62
  tmp___0 = ftok("/tmp", 'P');
#line 62
  key = tmp___0 | uid;
  }
#line 64
  return (key);
}
}
#line 72 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static int remote__msgget(opts_t opts ) 
{ 
  key_t tmp ;
  int tmp___0 ;

  {
  {
#line 74
  tmp = remote__genkey(opts);
#line 74
  tmp___0 = msgget(tmp, 896);
  }
#line 74
  return (tmp___0);
}
}
#line 85 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
int remote_set(opts_t opts ) 
{ 
  struct remote_msg msgbuf ;
  int msgid ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 90
  memset((void *)(& msgbuf), 0, sizeof(msgbuf));
#line 91
  msgbuf.mtype = (long )opts->remote;
#line 92
  msgbuf.progress = opts->progress;
#line 93
  msgbuf.timer = opts->timer;
#line 94
  msgbuf.eta = opts->eta;
#line 95
  msgbuf.rate = opts->rate;
#line 96
  msgbuf.average_rate = opts->average_rate;
#line 97
  msgbuf.rate_limit = opts->rate_limit;
#line 98
  msgbuf.buffer_size = opts->buffer_size;
#line 99
  msgbuf.size = opts->size;
#line 100
  msgbuf.interval = opts->interval;
#line 101
  msgbuf.width = opts->width;
#line 102
  msgbuf.height = opts->height;
  }
#line 103
  if ((unsigned long )opts->name != (unsigned long )((void *)0)) {
    {
#line 104
    strncpy((char */* __restrict  */)(msgbuf.name), (char const   */* __restrict  */)opts->name,
            sizeof(msgbuf.name) - 1UL);
    }
  }
  {
#line 107
  msgid = remote__msgget(opts);
  }
#line 108
  if (msgid < 0) {
    {
#line 109
    tmp = __errno_location();
#line 109
    tmp___0 = strerror(*tmp);
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            opts->program_name, tmp___0);
    }
#line 111
    return (1);
  }
  {
#line 114
  tmp___3 = msgsnd(msgid, (void const   *)(& msgbuf), sizeof(msgbuf) - sizeof(long ),
                   0);
  }
#line 114
  if (tmp___3 != 0) {
    {
#line 115
    tmp___1 = __errno_location();
#line 115
    tmp___2 = strerror(*tmp___1);
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            opts->program_name, tmp___2);
    }
#line 117
    return (1);
  }
  {
#line 120
  tmp___6 = kill((__pid_t )opts->remote, 10);
  }
#line 120
  if (tmp___6 != 0) {
    {
#line 121
    tmp___4 = __errno_location();
#line 121
    tmp___5 = strerror(*tmp___4);
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            opts->program_name, tmp___5);
    }
#line 123
    return (1);
  }
#line 126
  return (0);
}
}
#line 134 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static void remote__sig_usr1(int s ) 
{ 
  struct remote_msg msgbuf ;
  struct msqid_ds qbuf ;
  ssize_t got ;
  int msgid ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 141
  memset((void *)(& msgbuf), 0, sizeof(msgbuf));
#line 143
  msgid = remote__msgget(remote__opts);
  }
#line 144
  if (msgid < 0) {
#line 145
    return;
  }
  {
#line 148
  tmp = getpid();
#line 148
  got = msgrcv(msgid, (void *)(& msgbuf), sizeof(msgbuf) - sizeof(long ), (long )tmp,
               2048);
  }
#line 151
  if (got < 0L) {
    {
#line 152
    msgctl(msgid, 0, & qbuf);
    }
#line 153
    return;
  }
  {
#line 156
  tmp___0 = msgctl(msgid, 0, & qbuf);
  }
#line 156
  if (tmp___0 == 0) {
#line 157
    if (qbuf.msg_qnum < 1UL) {
      {
#line 158
      msgctl(msgid, 0, & qbuf);
      }
    }
  }
#line 162
  if (got < 1L) {
#line 163
    return;
  } else
#line 162
  if ((unsigned long )remote__opts == (unsigned long )((void *)0)) {
#line 163
    return;
  }
#line 167
  remote__opts->progress = msgbuf.progress;
#line 168
  remote__opts->timer = msgbuf.timer;
#line 169
  remote__opts->eta = msgbuf.eta;
#line 170
  remote__opts->rate = msgbuf.rate;
#line 171
  remote__opts->average_rate = msgbuf.average_rate;
#line 173
  if (msgbuf.rate_limit > 0ULL) {
#line 174
    remote__opts->rate_limit = msgbuf.rate_limit;
  }
#line 175
  if (msgbuf.buffer_size > 0ULL) {
    {
#line 176
    remote__opts->buffer_size = msgbuf.buffer_size;
#line 177
    pv_set_buffer_size(msgbuf.buffer_size, 1);
    }
  }
#line 179
  if (msgbuf.size > 0ULL) {
#line 180
    remote__opts->size = msgbuf.size;
  }
#line 181
  if (msgbuf.interval > (double )0) {
#line 182
    remote__opts->interval = msgbuf.interval;
  }
#line 183
  if (msgbuf.width > 0U) {
#line 184
    remote__opts->width = msgbuf.width;
  }
#line 185
  if (msgbuf.height > 0U) {
#line 186
    remote__opts->height = msgbuf.height;
  }
#line 187
  if ((int )msgbuf.name[0] != 0) {
    {
#line 188
    remote__opts->name = strdup((char const   *)(msgbuf.name));
    }
  }
#line 189
  return;
}
}
#line 196 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
void remote_sig_init(opts_t opts ) 
{ 
  struct sigaction sa ;

  {
  {
#line 200
  remote__opts = opts;
#line 202
  sa.__sigaction_handler.sa_handler = & remote__sig_usr1;
#line 203
  sigemptyset(& sa.sa_mask);
#line 204
  sa.sa_flags = 0;
#line 205
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 206
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/version.c"
void display_version(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 19
  tmp = gettext("Andrew Wood <andrew.wood@ivarch.com>");
#line 19
  tmp___0 = gettext("2010");
#line 19
  tmp___1 = gettext("%s %s - Copyright(C) %s %s");
#line 19
  printf((char const   */* __restrict  */)tmp___1, "pv", "1.2.0", tmp___0, tmp);
#line 21
  printf((char const   */* __restrict  */)"\n\n");
#line 22
  tmp___2 = gettext("Web site: %s");
#line 22
  printf((char const   */* __restrict  */)tmp___2, "http://www.ivarch.com/programs/pv.shtml");
#line 24
  printf((char const   */* __restrict  */)"\n\n");
#line 25
  tmp___3 = gettext("This program is free software, and is being distributed under the\nterms of the Artistic License 2.0.");
#line 25
  printf((char const   */* __restrict  */)"%s", tmp___3);
#line 28
  printf((char const   */* __restrict  */)"\n\n");
#line 29
  tmp___4 = gettext("This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
#line 29
  printf((char const   */* __restrict  */)"%s", tmp___4);
#line 34
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 35
  return;
}
}
#line 17 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
static int pv__isdigit(char c ) 
{ 
  int tmp ;

  {
#line 19
  if ((int )c >= 48) {
#line 19
    if ((int )c <= 57) {
#line 19
      tmp = 1;
    } else {
#line 19
      tmp = 0;
    }
  } else {
#line 19
    tmp = 0;
  }
#line 19
  return (tmp);
}
}
#line 26 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
long long pv_getnum_ll(char *str ) 
{ 
  long long n ;
  long long decimal ;
  int decdivisor ;
  int shift ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int shiftby ;

  {
#line 28
  n = 0LL;
#line 29
  decimal = 0LL;
#line 30
  decdivisor = 1;
#line 31
  shift = 0;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
#line 33
    if ((int )*(str + 0) != 0) {
      {
#line 33
      tmp = pv__isdigit(*(str + 0));
      }
#line 33
      if (tmp) {
#line 33
        goto while_break;
      }
    } else {
#line 33
      goto while_break;
    }
#line 34
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 36
    tmp___0 = pv__isdigit(*(str + 0));
    }
#line 36
    if (! tmp___0) {
#line 36
      goto while_break___0;
    }
#line 37
    n *= 10LL;
#line 38
    n += (long long )((int )*(str + 0) - 48);
#line 36
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 44
  if ((int )*(str + 0) == 46) {
#line 44
    goto _L;
  } else
#line 44
  if ((int )*(str + 0) == 44) {
    _L: /* CIL Label */ 
#line 45
    str ++;
    {
#line 46
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 46
      tmp___1 = pv__isdigit(*(str + 0));
      }
#line 46
      if (! tmp___1) {
#line 46
        goto while_break___1;
      }
#line 47
      if (decdivisor < 10000) {
#line 48
        decimal *= 10LL;
#line 49
        decimal += (long long )((int )*(str + 0) - 48);
#line 50
        decdivisor *= 10;
      }
#line 46
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 59
  if (*(str + 0)) {
    {
#line 60
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 60
      if (! ((int )*(str + 0) == 32)) {
#line 60
        if (! ((int )*(str + 0) == 9)) {
#line 60
          goto while_break___2;
        }
      }
#line 61
      str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 64
    if ((int )*(str + 0) == 75) {
#line 64
      goto case_75;
    }
#line 64
    if ((int )*(str + 0) == 107) {
#line 64
      goto case_75;
    }
#line 68
    if ((int )*(str + 0) == 77) {
#line 68
      goto case_77;
    }
#line 68
    if ((int )*(str + 0) == 109) {
#line 68
      goto case_77;
    }
#line 72
    if ((int )*(str + 0) == 71) {
#line 72
      goto case_71;
    }
#line 72
    if ((int )*(str + 0) == 103) {
#line 72
      goto case_71;
    }
#line 76
    if ((int )*(str + 0) == 84) {
#line 76
      goto case_84;
    }
#line 76
    if ((int )*(str + 0) == 116) {
#line 76
      goto case_84;
    }
#line 79
    goto switch_default;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 65
    shift = 10;
#line 66
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 69
    shift = 20;
#line 70
    goto switch_break;
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
#line 73
    shift = 30;
#line 74
    goto switch_break;
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 77
    shift = 40;
#line 78
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 80
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 89
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 89
    if (! (shift > 0)) {
#line 89
      goto while_break___3;
    }
#line 92
    shiftby = shift;
#line 93
    if (shiftby > 30) {
#line 94
      shiftby = 30;
    }
#line 96
    n <<= shiftby;
#line 97
    decimal <<= shiftby;
#line 98
    shift -= shiftby;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 104
  decimal /= (long long )decdivisor;
#line 105
  n += decimal;
#line 107
  return (n);
}
}
#line 114 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
double pv_getnum_d(char *str ) 
{ 
  double n ;
  double step ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 116
  n = 0.0;
#line 117
  step = (double )1;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if ((int )*(str + 0) != 0) {
      {
#line 119
      tmp = pv__isdigit(*(str + 0));
      }
#line 119
      if (tmp) {
#line 119
        goto while_break;
      }
    } else {
#line 119
      goto while_break;
    }
#line 120
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 122
    tmp___0 = pv__isdigit(*(str + 0));
    }
#line 122
    if (! tmp___0) {
#line 122
      goto while_break___0;
    }
#line 123
    n *= (double )10;
#line 124
    n += (double )((int )*(str + 0) - 48);
#line 122
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 127
  if ((int )*(str + 0) != 46) {
#line 127
    if ((int )*(str + 0) != 44) {
#line 128
      return (n);
    }
  }
#line 130
  str ++;
  {
#line 132
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 132
    tmp___1 = pv__isdigit(*(str + 0));
    }
#line 132
    if (tmp___1) {
#line 132
      if (! (step < (double )1000000)) {
#line 132
        goto while_break___1;
      }
    } else {
#line 132
      goto while_break___1;
    }
#line 133
    step *= (double )10;
#line 134
    n += (double )((int )*(str + 0) - 48) / step;
#line 132
    str ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 137
  return (n);
}
}
#line 144 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
int pv_getnum_i(char *str ) 
{ 
  long long tmp ;

  {
  {
#line 146
  tmp = pv_getnum_ll(str);
  }
#line 146
  return ((int )tmp);
}
}
#line 154 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
int pv_getnum_check(char *str , int type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 156
  if (! str) {
#line 157
    return (1);
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! ((int )*(str + 0) == 32)) {
#line 159
      if (! ((int )*(str + 0) == 9)) {
#line 159
        goto while_break;
      }
    }
#line 160
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  tmp = pv__isdigit(*(str + 0));
  }
#line 162
  if (! tmp) {
#line 163
    return (1);
  }
  {
#line 165
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 165
    tmp___0 = pv__isdigit(*(str + 0));
    }
#line 165
    if (! tmp___0) {
#line 165
      goto while_break___0;
    }
#line 165
    str ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  if ((int )*(str + 0) == 46) {
#line 168
    if (type == 0) {
#line 169
      return (1);
    }
#line 170
    str ++;
    {
#line 171
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 171
      tmp___1 = pv__isdigit(*(str + 0));
      }
#line 171
      if (! tmp___1) {
#line 171
        goto while_break___1;
      }
#line 171
      str ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 174
  if ((int )*(str + 0) == 0) {
#line 175
    return (0);
  }
#line 180
  if (type == 1) {
#line 181
    return (1);
  }
  {
#line 183
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 183
    if (! ((int )*(str + 0) == 32)) {
#line 183
      if (! ((int )*(str + 0) == 9)) {
#line 183
        goto while_break___2;
      }
    }
#line 184
    str ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 193
  if ((int )*(str + 0) == 84) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 116) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 71) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 103) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 77) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 109) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 75) {
#line 193
    goto case_84;
  }
#line 193
  if ((int )*(str + 0) == 107) {
#line 193
    goto case_84;
  }
#line 196
  goto switch_default;
  case_84: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_107: /* CIL Label */ 
#line 194
  str ++;
#line 195
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 197
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 200
  if (*(str + 0)) {
#line 201
    return (1);
  }
#line 203
  return (0);
}
}
#line 28 "./src/include/pv.h"
void pv_display(opts_t opts , long double esec , long long sl , long long tot ) ;
#line 35
void pv_crs_update(opts_t opts , char *str ) ;
#line 41
void pv_sig_checkbg(void) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 29 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
void pv_screensize(opts_t opts ) 
{ 
  struct winsize wsz ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp___0 = isatty(2);
  }
#line 34
  if (tmp___0) {
    {
#line 35
    tmp = ioctl(2, 21523UL, & wsz);
    }
#line 35
    if (tmp == 0) {
#line 36
      opts->width = (unsigned int )wsz.ws_col;
#line 37
      opts->height = (unsigned int )wsz.ws_row;
    }
  }
#line 41
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static long pv__calc_percentage(long long so_far , long long const   total ) 
{ 


  {
#line 49
  if (total < 1LL) {
#line 50
    return (0L);
  }
#line 52
  so_far *= 100LL;
#line 53
  so_far /= (long long )total;
#line 55
  return ((long )so_far);
}
}
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static long pv__calc_eta(long long const   so_far , long long const   total , long const   elapsed ) 
{ 
  long long amount_left ;

  {
#line 69
  if (so_far < 1LL) {
#line 70
    return (0L);
  }
#line 72
  amount_left = (long long )(total - so_far);
#line 73
  amount_left *= (long long )elapsed;
#line 74
  amount_left /= (long long )so_far;
#line 76
  return ((long )amount_left);
}
}
#line 90
static void pv__si_prefix(long double *value , char *prefix , long double const   ratio ) ;
#line 90 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char *pfx  =    (char *)((void *)0);
#line 91 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char const   *pfx_middle  =    (char const   *)((void *)0);
#line 87 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static void pv__si_prefix(long double *value , char *prefix , long double const   ratio ) 
{ 
  char const   *i ;
  char *tmp ;

  {
#line 94
  if ((unsigned long )pfx == (unsigned long )((void *)0)) {
    {
#line 95
    pfx = gettext("yzafpnum kMGTPEZY");
    }
  }
#line 98
  if ((unsigned long )pfx_middle == (unsigned long )((void *)0)) {
    {
#line 103
    tmp = strchr((char const   *)pfx, ' ');
#line 103
    pfx_middle = (char const   *)tmp;
    }
  }
#line 105
  i = pfx_middle;
#line 107
  *prefix = (char )'\000';
#line 112
  if (*value == (long double )0.0) {
#line 113
    return;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (*value >= (long double )1000.0) {
#line 115
      i ++;
#line 115
      if (! ((int const   )*i != 0)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    *value /= (long double )ratio;
#line 117
    *prefix = (char )*i;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (*value < (long double )1.0) {
#line 120
      i --;
#line 120
      if (! ((unsigned long )i != (unsigned long )(pfx - 1))) {
#line 120
        goto while_break___0;
      }
    } else {
#line 120
      goto while_break___0;
    }
#line 121
    *value *= (long double )ratio;
#line 122
    *prefix = (char )*i;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static void pv__state_init(struct pv_display_state *state___1 , opts_t opts ) 
{ 


  {
#line 148
  if ((unsigned long )state___1 == (unsigned long )((void *)0)) {
#line 149
    return;
  }
  {
#line 150
  memset((void *)state___1, 0, sizeof(struct pv_display_state ));
#line 151
  state___1->opts = opts;
  }
#line 152
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char *pv__format(struct pv_display_state *state___1 , long double elapsed_sec ,
                        long long bytes_since_last , long long total_bytes ) 
{ 
  long double time_since_last ;
  long double rate ;
  long double transferred ;
  long eta ;
  int component_count ;
  int static_portion_size ;
  char str_transferred[128] ;
  char str_timer[128] ;
  char str_rate[128] ;
  char str_average_rate[128] ;
  char str_eta[128] ;
  char si_prefix[2] ;
  char *units ;
  long double average_rate ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int name_length ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  int i ;
  size_t tmp___10 ;
  char pct[16] ;
  int available_width ;
  int i___0 ;
  size_t tmp___11 ;
  int p ;

  {
#line 185
  si_prefix[0] = (char )' ';
#line 185
  si_prefix[1] = (char )'\000';
#line 190
  if ((unsigned long )state___1 == (unsigned long )((void *)0)) {
#line 191
    return ((char *)((void *)0));
  }
#line 194
  if (total_bytes < 0LL) {
#line 195
    if (state___1->outbuffer) {
      {
#line 196
      free((void *)state___1->outbuffer);
      }
    }
#line 197
    state___1->outbuffer = (char *)((void *)0);
#line 198
    return ((char *)((void *)0));
  }
#line 207
  time_since_last = elapsed_sec - state___1->prev_elapsed_sec;
#line 208
  if (time_since_last <= (long double )0.01) {
#line 209
    rate = state___1->prev_rate;
#line 210
    state___1->prev_trans += (long double )bytes_since_last;
  } else {
#line 212
    rate = ((long double )bytes_since_last + state___1->prev_trans) / time_since_last;
#line 215
    state___1->prev_elapsed_sec = elapsed_sec;
#line 216
    state___1->prev_trans = (long double )0;
  }
#line 218
  state___1->prev_rate = rate;
#line 225
  if (bytes_since_last < 0LL) {
#line 225
    goto _L;
  } else
#line 225
  if ((state___1->opts)->average_rate) {
    _L: /* CIL Label */ 
#line 227
    if (elapsed_sec < (long double )0.000001) {
#line 228
      elapsed_sec = (long double )0.000001;
    }
#line 229
    average_rate = (long double )total_bytes / elapsed_sec;
#line 232
    if (bytes_since_last < 0LL) {
#line 233
      rate = average_rate;
    }
  }
#line 236
  if ((state___1->opts)->size <= 0ULL) {
#line 245
    if (rate > (long double )0) {
#line 246
      state___1->percentage += 2L;
    }
#line 247
    if (state___1->percentage > 199L) {
#line 248
      state___1->percentage = 0L;
    }
  } else
#line 249
  if ((state___1->opts)->numeric) {
    {
#line 255
    state___1->percentage = pv__calc_percentage(total_bytes, (long long const   )(state___1->opts)->size);
    }
  } else
#line 249
  if ((state___1->opts)->progress) {
    {
#line 255
    state___1->percentage = pv__calc_percentage(total_bytes, (long long const   )(state___1->opts)->size);
    }
  }
#line 262
  if ((unsigned long )state___1->outbuffer != (unsigned long )((void *)0)) {
#line 262
    if (state___1->outbufsize < (long )((state___1->opts)->width * 2U)) {
      {
#line 264
      free((void *)state___1->outbuffer);
#line 265
      state___1->outbuffer = (char *)((void *)0);
#line 266
      state___1->outbufsize = 0L;
      }
    }
  }
#line 272
  if ((unsigned long )state___1->outbuffer == (unsigned long )((void *)0)) {
#line 273
    state___1->outbufsize = (long )(2U * (state___1->opts)->width + 80U);
#line 274
    if ((state___1->opts)->name) {
      {
#line 275
      tmp = strlen((char const   *)(state___1->opts)->name);
#line 275
      state___1->outbufsize = (long )((size_t )state___1->outbufsize + tmp);
      }
    }
    {
#line 276
    tmp___0 = malloc((size_t )(state___1->outbufsize + 16L));
#line 276
    state___1->outbuffer = (char *)tmp___0;
    }
#line 277
    if ((unsigned long )state___1->outbuffer == (unsigned long )((void *)0)) {
      {
#line 278
      tmp___1 = __errno_location();
#line 278
      tmp___2 = strerror(*tmp___1);
#line 278
      tmp___3 = gettext("buffer allocation failed");
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              (state___1->opts)->program_name, tmp___3, tmp___2);
#line 282
      (state___1->opts)->exit_status = (unsigned char )((int )(state___1->opts)->exit_status | 64);
      }
#line 283
      return ((char *)((void *)0));
    }
#line 285
    *(state___1->outbuffer + 0) = (char)0;
  }
#line 289
  if ((state___1->opts)->numeric) {
#line 290
    if (state___1->percentage > 100L) {
      {
#line 292
      sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%ld\n",
              200L - state___1->percentage);
      }
    } else {
      {
#line 295
      sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%ld\n",
              state___1->percentage);
      }
    }
#line 298
    return (state___1->outbuffer);
  }
#line 309
  component_count = 0;
#line 310
  static_portion_size = 0;
#line 311
  str_transferred[0] = (char)0;
#line 312
  str_timer[0] = (char)0;
#line 313
  str_rate[0] = (char)0;
#line 314
  str_average_rate[0] = (char)0;
#line 315
  str_eta[0] = (char)0;
#line 318
  if ((state___1->opts)->name) {
    {
#line 321
    tmp___4 = strlen((char const   *)(state___1->opts)->name);
#line 321
    name_length = (int )tmp___4;
    }
#line 322
    if (name_length < 9) {
#line 323
      name_length = 9;
    }
#line 324
    if (name_length > 500) {
#line 325
      name_length = 500;
    }
#line 327
    component_count ++;
#line 328
    static_portion_size += name_length + 1;
  }
#line 332
  if ((state___1->opts)->bytes) {
#line 333
    transferred = (long double )total_bytes;
#line 335
    if ((state___1->opts)->linemode) {
      {
#line 336
      pv__si_prefix(& transferred, si_prefix, (long double const   )1000.0);
#line 337
      units = (char *)"";
      }
    } else {
      {
#line 339
      pv__si_prefix(& transferred, si_prefix, (long double const   )1024.0);
#line 340
      units = gettext("B");
      }
    }
#line 344
    if (transferred > (long double )100000) {
#line 345
      transferred = (long double )100000;
    }
    {
#line 347
    sprintf((char */* __restrict  */)(str_transferred), (char const   */* __restrict  */)"%4.3Lg%.1s%.16s",
            transferred, si_prefix, units);
#line 350
    component_count ++;
#line 351
    tmp___5 = strlen((char const   *)(str_transferred));
#line 351
    static_portion_size = (int )((size_t )static_portion_size + tmp___5);
    }
  }
#line 355
  if ((state___1->opts)->timer) {
#line 361
    if (elapsed_sec > 360000000.0L) {
#line 362
      elapsed_sec = 360000000.0L;
    }
    {
#line 364
    sprintf((char */* __restrict  */)(str_timer), (char const   */* __restrict  */)"%ld:%02ld:%02ld",
            (long )elapsed_sec / 3600L, ((long )elapsed_sec / 60L) % 60L, (long )elapsed_sec % 60L);
#line 369
    component_count ++;
#line 370
    tmp___6 = strlen((char const   *)(str_timer));
#line 370
    static_portion_size = (int )((size_t )static_portion_size + tmp___6);
    }
  }
#line 374
  if ((state___1->opts)->rate) {
#line 375
    if ((state___1->opts)->linemode) {
      {
#line 376
      pv__si_prefix(& rate, si_prefix, (long double const   )1000.0);
#line 377
      units = gettext("/s");
      }
    } else {
      {
#line 379
      pv__si_prefix(& rate, si_prefix, (long double const   )1024.0);
#line 380
      units = gettext("B/s");
      }
    }
#line 387
    if (rate > (long double )100000) {
#line 388
      rate = (long double )100000;
    }
    {
#line 390
    sprintf((char */* __restrict  */)(str_rate), (char const   */* __restrict  */)"[%4.3Lg%.1s%.16s]",
            rate, si_prefix, units);
#line 393
    component_count ++;
#line 394
    tmp___7 = strlen((char const   *)(str_rate));
#line 394
    static_portion_size = (int )((size_t )static_portion_size + tmp___7);
    }
  }
#line 398
  if ((state___1->opts)->average_rate) {
#line 399
    if ((state___1->opts)->linemode) {
      {
#line 400
      pv__si_prefix(& average_rate, si_prefix, (long double const   )1000.0);
#line 401
      units = gettext("/s");
      }
    } else {
      {
#line 403
      pv__si_prefix(& average_rate, si_prefix, (long double const   )1024.0);
#line 404
      units = gettext("B/s");
      }
    }
#line 408
    if (average_rate > (long double )100000) {
#line 409
      average_rate = (long double )100000;
    }
    {
#line 411
    sprintf((char */* __restrict  */)(str_average_rate), (char const   */* __restrict  */)"[%4.3Lg%.1s%.16s]",
            average_rate, si_prefix, units);
#line 414
    component_count ++;
#line 415
    tmp___8 = strlen((char const   *)(str_average_rate));
#line 415
    static_portion_size = (int )((size_t )static_portion_size + tmp___8);
    }
  }
#line 419
  if ((state___1->opts)->eta) {
#line 419
    if ((state___1->opts)->size > 0ULL) {
      {
#line 420
      eta = pv__calc_eta((long long const   )total_bytes, (long long const   )(state___1->opts)->size,
                         (long const   )elapsed_sec);
      }
#line 424
      if (eta < 0L) {
#line 425
        eta = 0L;
      }
#line 431
      if (eta > 360000000L) {
#line 432
        eta = 360000000L;
      }
      {
#line 434
      tmp___9 = gettext("ETA");
#line 434
      sprintf((char */* __restrict  */)(str_eta), (char const   */* __restrict  */)"%.16s %ld:%02ld:%02ld",
              tmp___9, eta / 3600L, (eta / 60L) % 60L, eta % 60L);
      }
#line 441
      if (bytes_since_last < 0LL) {
#line 443
        i = 0;
        {
#line 443
        while (1) {
          while_continue: /* CIL Label */ ;
#line 443
          if ((unsigned long )i < sizeof(str_eta)) {
#line 443
            if (! ((int )str_eta[i] != 0)) {
#line 443
              goto while_break;
            }
          } else {
#line 443
            goto while_break;
          }
#line 445
          str_eta[i] = (char )' ';
#line 443
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 449
      component_count ++;
#line 450
      tmp___10 = strlen((char const   *)(str_eta));
#line 450
      static_portion_size = (int )((size_t )static_portion_size + tmp___10);
      }
    }
  }
#line 460
  *(state___1->outbuffer + 0) = (char)0;
#line 462
  if ((state___1->opts)->name) {
    {
#line 463
    sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%9s:",
            (state___1->opts)->name);
    }
  }
#line 471
  if ((int )str_transferred[0] != 0) {
#line 471
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 471
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 471
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_transferred));
    }
  }
#line 472
  if ((int )str_timer[0] != 0) {
#line 472
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 472
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 472
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_timer));
    }
  }
#line 473
  if ((int )str_rate[0] != 0) {
#line 473
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 473
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 473
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_rate));
    }
  }
#line 474
  if ((int )str_average_rate[0] != 0) {
#line 474
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 474
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 474
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_average_rate));
    }
  }
#line 476
  if ((state___1->opts)->progress) {
#line 480
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 481
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 482
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"[");
    }
#line 484
    if ((state___1->opts)->size > 0ULL) {
#line 485
      if (state___1->percentage < 0L) {
#line 486
        state___1->percentage = 0L;
      }
#line 487
      if (state___1->percentage > 100000L) {
#line 488
        state___1->percentage = 100000L;
      }
      {
#line 489
      sprintf((char */* __restrict  */)(pct), (char const   */* __restrict  */)"%2ld%%",
              state___1->percentage);
#line 490
      tmp___11 = strlen((char const   *)(pct));
#line 490
      available_width = (int )(((size_t )(((state___1->opts)->width - (unsigned int )static_portion_size) - (unsigned int )component_count) - tmp___11) - 3UL);
#line 494
      i___0 = 0;
      }
      {
#line 494
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 494
        if (! ((long )i___0 < ((long )available_width * state___1->percentage) / 100L - 1L)) {
#line 494
          goto while_break___0;
        }
#line 498
        if (i___0 < available_width) {
          {
#line 499
          strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"=");
          }
        }
#line 494
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 501
      if (i___0 < available_width) {
        {
#line 502
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)">");
#line 503
        i___0 ++;
        }
      }
      {
#line 505
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 505
        if (! (i___0 < available_width)) {
#line 505
          goto while_break___1;
        }
        {
#line 506
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
#line 505
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 508
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"] ");
#line 509
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(pct));
      }
    } else {
#line 511
      p = (int )state___1->percentage;
#line 512
      available_width = (int )((((state___1->opts)->width - (unsigned int )static_portion_size) - (unsigned int )component_count) - 5U);
#line 515
      if (p > 100) {
#line 516
        p = 200 - p;
      }
#line 517
      i___0 = 0;
      {
#line 517
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 517
        if (! (i___0 < (available_width * p) / 100)) {
#line 517
          goto while_break___2;
        }
#line 518
        if (i___0 < available_width) {
          {
#line 519
          strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
          }
        }
#line 517
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 521
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"<=>");
      }
      {
#line 522
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 522
        if (! (i___0 < available_width)) {
#line 522
          goto while_break___3;
        }
        {
#line 523
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
#line 522
        i___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 525
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"]");
      }
    }
  }
#line 529
  if ((int )str_eta[0] != 0) {
#line 529
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 529
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 529
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_eta));
    }
  }
#line 531
  return (state___1->outbuffer);
}
}
#line 550 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static struct pv_display_state state  ;
#line 551 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static int initialised  =    0;
#line 548 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
void pv_display(opts_t opts , long double esec , long long sl , long long tot ) 
{ 
  char *display ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 554
  if (! initialised) {
    {
#line 555
    pv__state_init(& state, opts);
#line 556
    initialised = 1;
    }
  }
#line 559
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 560
    if (initialised) {
      {
#line 561
      pv__format(& state, (long double )0, 0LL, -1LL);
      }
    }
#line 562
    initialised = 0;
#line 563
    return;
  }
  {
#line 566
  pv_sig_checkbg();
#line 568
  display = pv__format(& state, esec, sl, tot);
  }
#line 569
  if ((unsigned long )display == (unsigned long )((void *)0)) {
#line 570
    return;
  }
#line 572
  if (opts->numeric) {
    {
#line 573
    tmp = strlen((char const   *)display);
#line 573
    write(2, (void const   *)display, tmp);
    }
  } else
#line 574
  if (opts->cursor) {
    {
#line 575
    pv_crs_update(opts, display);
    }
  } else {
    {
#line 577
    tmp___0 = strlen((char const   *)display);
#line 577
    write(2, (void const   *)display, tmp___0);
#line 578
    write(2, (void const   *)"\r", (size_t )1);
    }
  }
#line 580
  return;
}
}
#line 40 "./src/include/pv.h"
void pv_sig_allowpause(void) ;
#line 43
void pv_sig_nopause(void) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 22 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static int pv__sig_old_stderr  ;
#line 23 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static struct timeval pv__sig_tstp_time  ;
#line 25 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
struct timeval pv_sig_toffset  ;
#line 26 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
sig_atomic_t pv_sig_newsize  =    0;
#line 27 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
sig_atomic_t pv_sig_abort  =    0;
#line 30
void pv_crs_needreinit(void) ;
#line 41 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_ttou(int s ) 
{ 
  int fd ;

  {
  {
#line 45
  fd = open("/dev/null", 2);
  }
#line 46
  if (fd < 0) {
#line 47
    return;
  }
#line 49
  if (pv__sig_old_stderr == -1) {
    {
#line 50
    pv__sig_old_stderr = dup(2);
    }
  }
  {
#line 52
  dup2(fd, 2);
#line 53
  close(fd);
  }
#line 54
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_tstp(int s ) 
{ 


  {
  {
#line 63
  gettimeofday((struct timeval */* __restrict  */)(& pv__sig_tstp_time), (__timezone_ptr_t )((void *)0));
#line 64
  raise(19);
  }
#line 65
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_cont(int s ) 
{ 
  struct timeval tv ;
  struct termios t ;

  {
#line 78
  pv_sig_newsize = 1;
#line 80
  if (pv__sig_tstp_time.tv_sec == 0L) {
    {
#line 81
    tcgetattr(2, & t);
#line 82
    t.c_lflag |= 256U;
#line 83
    tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 85
    pv_crs_needreinit();
    }
#line 87
    return;
  }
  {
#line 90
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 92
  pv_sig_toffset.tv_sec += tv.tv_sec - pv__sig_tstp_time.tv_sec;
#line 93
  pv_sig_toffset.tv_usec += tv.tv_usec - pv__sig_tstp_time.tv_usec;
  }
#line 94
  if (pv_sig_toffset.tv_usec >= 1000000L) {
#line 95
    (pv_sig_toffset.tv_sec) ++;
#line 96
    pv_sig_toffset.tv_usec -= 1000000L;
  }
#line 98
  if (pv_sig_toffset.tv_usec < 0L) {
#line 99
    (pv_sig_toffset.tv_sec) --;
#line 100
    pv_sig_toffset.tv_usec += 1000000L;
  }
#line 103
  pv__sig_tstp_time.tv_sec = (__time_t )0;
#line 104
  pv__sig_tstp_time.tv_usec = (__suseconds_t )0;
#line 106
  if (pv__sig_old_stderr != -1) {
    {
#line 107
    dup2(pv__sig_old_stderr, 2);
#line 108
    close(pv__sig_old_stderr);
#line 109
    pv__sig_old_stderr = -1;
    }
  }
  {
#line 112
  tcgetattr(2, & t);
#line 113
  t.c_lflag |= 256U;
#line 114
  tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 117
  pv_crs_needreinit();
  }
#line 119
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_winch(int s ) 
{ 


  {
#line 127
  pv_sig_newsize = 1;
#line 128
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_term(int s ) 
{ 


  {
#line 136
  pv_sig_abort = 1;
#line 137
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
void pv_sig_init(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 147
  pv__sig_old_stderr = -1;
#line 148
  pv__sig_tstp_time.tv_sec = (__time_t )0;
#line 149
  pv__sig_tstp_time.tv_usec = (__suseconds_t )0;
#line 150
  pv_sig_toffset.tv_sec = (__time_t )0;
#line 151
  pv_sig_toffset.tv_usec = (__suseconds_t )0;
#line 157
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 158
  sigemptyset(& sa.sa_mask);
#line 159
  sa.sa_flags = 0;
#line 160
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 166
  sa.__sigaction_handler.sa_handler = & pv__sig_ttou;
#line 167
  sigemptyset(& sa.sa_mask);
#line 168
  sa.sa_flags = 0;
#line 169
  sigaction(22, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 175
  sa.__sigaction_handler.sa_handler = & pv__sig_tstp;
#line 176
  sigemptyset(& sa.sa_mask);
#line 177
  sa.sa_flags = 0;
#line 178
  sigaction(20, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 185
  sa.__sigaction_handler.sa_handler = & pv__sig_cont;
#line 186
  sigemptyset(& sa.sa_mask);
#line 187
  sa.sa_flags = 0;
#line 188
  sigaction(18, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 194
  sa.__sigaction_handler.sa_handler = & pv__sig_winch;
#line 195
  sigemptyset(& sa.sa_mask);
#line 196
  sa.sa_flags = 0;
#line 197
  sigaction(28, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 203
  sa.__sigaction_handler.sa_handler = & pv__sig_term;
#line 204
  sigemptyset(& sa.sa_mask);
#line 205
  sa.sa_flags = 0;
#line 206
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 208
  sa.__sigaction_handler.sa_handler = & pv__sig_term;
#line 209
  sigemptyset(& sa.sa_mask);
#line 210
  sa.sa_flags = 0;
#line 211
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 213
  sa.__sigaction_handler.sa_handler = & pv__sig_term;
#line 214
  sigemptyset(& sa.sa_mask);
#line 215
  sa.sa_flags = 0;
#line 216
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 217
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
void pv_sig_nopause(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 227
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 228
  sigemptyset(& sa.sa_mask);
#line 229
  sa.sa_flags = 0;
#line 230
  sigaction(20, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 232
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 233
  sigemptyset(& sa.sa_mask);
#line 234
  sa.sa_flags = 0;
#line 235
  sigaction(18, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 236
  return;
}
}
#line 242 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
void pv_sig_allowpause(void) 
{ 
  struct sigaction sa ;

  {
  {
#line 246
  sa.__sigaction_handler.sa_handler = & pv__sig_tstp;
#line 247
  sigemptyset(& sa.sa_mask);
#line 248
  sa.sa_flags = 0;
#line 249
  sigaction(20, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 251
  sa.__sigaction_handler.sa_handler = & pv__sig_cont;
#line 252
  sigemptyset(& sa.sa_mask);
#line 253
  sa.sa_flags = 0;
#line 254
  sigaction(18, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 255
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static time_t next_check  =    (time_t )0;
#line 264 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
void pv_sig_checkbg(void) 
{ 
  struct termios t ;
  time_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 269
  tmp = time((time_t *)((void *)0));
  }
#line 269
  if (tmp < next_check) {
#line 270
    return;
  }
  {
#line 272
  tmp___0 = time((time_t *)((void *)0));
#line 272
  next_check = tmp___0 + 1L;
  }
#line 274
  if (pv__sig_old_stderr == -1) {
#line 275
    return;
  }
  {
#line 277
  dup2(pv__sig_old_stderr, 2);
#line 278
  close(pv__sig_old_stderr);
#line 279
  pv__sig_old_stderr = -1;
#line 281
  tcgetattr(2, & t);
#line 282
  t.c_lflag |= 256U;
#line 283
  tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 286
  pv_crs_needreinit();
  }
#line 288
  return;
}
}
#line 29 "./src/include/pv.h"
long pv_transfer(opts_t opts , int fd , int *eof_in , int *eof_out , unsigned long long allowed ,
                 long *lineswritten ) ;
#line 31
int pv_next_file(opts_t opts , int filenum , int oldfd ) ;
#line 33
void pv_crs_fini(opts_t opts ) ;
#line 34
void pv_crs_init(opts_t opts ) ;
#line 230 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat64)(int __fd ,
                                                                                              struct stat64 *__buf ) ;
#line 37 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/loop.c"
static void pv_timeval_add_usec(struct timeval *val , long usec ) 
{ 


  {
#line 39
  val->tv_usec += usec;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (val->tv_usec < 0L)) {
#line 40
      goto while_break;
    }
#line 41
    (val->tv_sec) --;
#line 42
    val->tv_usec += 1000000L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (val->tv_usec >= 1000000L)) {
#line 44
      goto while_break___0;
    }
#line 45
    (val->tv_sec) ++;
#line 46
    val->tv_usec -= 1000000L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 105 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/loop.c"
int pv_main_loop(opts_t opts ) 
{ 
  long written ;
  long lineswritten ;
  long long total_written ;
  long long since_last ;
  long long cansend ;
  long long donealready ;
  long long target ;
  int eof_in ;
  int eof_out ;
  int final_update ;
  struct timeval start_time ;
  struct timeval next_update ;
  struct timeval next_reset ;
  struct timeval cur_time ;
  struct timeval init_time ;
  long double elapsed ;
  struct stat64 sb ;
  int fd ;
  int n ;
  int tmp ;

  {
  {
#line 131
  fd = -1;
#line 133
  pv_crs_init(opts);
#line 135
  eof_in = 0;
#line 136
  eof_out = 0;
#line 137
  total_written = 0LL;
#line 138
  since_last = 0LL;
#line 140
  gettimeofday((struct timeval */* __restrict  */)(& start_time), (__timezone_ptr_t )((void *)0));
#line 141
  gettimeofday((struct timeval */* __restrict  */)(& cur_time), (__timezone_ptr_t )((void *)0));
#line 143
  next_update.tv_sec = start_time.tv_sec;
#line 144
  next_update.tv_usec = start_time.tv_usec;
#line 145
  pv_timeval_add_usec(& next_update, (long )(1000000.0 * opts->interval));
#line 148
  next_reset.tv_sec = start_time.tv_sec;
#line 149
  next_reset.tv_usec = start_time.tv_usec;
#line 150
  pv_timeval_add_usec(& next_reset, 100000L);
#line 152
  cansend = 0LL;
#line 153
  donealready = 0LL;
#line 154
  final_update = 0;
#line 155
  n = 0;
#line 157
  fd = pv_next_file(opts, n, -1);
  }
#line 158
  if (fd < 0) {
#line 159
    return ((int )opts->exit_status);
  }
  {
#line 162
  tmp = fstat64(fd, & sb);
  }
#line 162
  if (tmp == 0) {
    {
#line 163
    pv_set_buffer_size((unsigned long long )(sb.st_blksize * 32L), 0);
    }
  }
#line 166
  if (opts->buffer_size > 0ULL) {
    {
#line 167
    pv_set_buffer_size(opts->buffer_size, 1);
    }
  }
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (eof_in) {
#line 170
      if (eof_out) {
#line 170
        if (! (! final_update)) {
#line 170
          goto while_break;
        }
      }
    }
#line 172
    if (pv_sig_abort) {
#line 173
      goto while_break;
    }
#line 175
    if (opts->rate_limit > 0ULL) {
#line 176
      target = (long long )((long double )opts->rate_limit / (long double )10);
#line 179
      cansend = target - donealready;
#line 180
      if (target < donealready) {
#line 181
        cansend = 0LL;
      }
    }
    {
#line 184
    written = pv_transfer(opts, fd, & eof_in, & eof_out, (unsigned long long )cansend,
                          & lineswritten);
    }
#line 187
    if (written < 0L) {
#line 188
      return ((int )opts->exit_status);
    }
#line 190
    if (opts->linemode) {
#line 191
      since_last += (long long )lineswritten;
#line 192
      total_written += (long long )lineswritten;
    } else {
#line 194
      since_last += (long long )written;
#line 195
      total_written += (long long )written;
    }
#line 197
    if (opts->rate_limit > 0ULL) {
#line 198
      donealready += (long long )written;
    }
#line 200
    if (eof_in) {
#line 200
      if (eof_out) {
#line 200
        if (n < opts->argc - 1) {
          {
#line 201
          n ++;
#line 202
          fd = pv_next_file(opts, n, fd);
          }
#line 203
          if (fd < 0) {
#line 204
            return ((int )opts->exit_status);
          }
#line 205
          eof_in = 0;
#line 206
          eof_out = 0;
        }
      }
    }
    {
#line 209
    gettimeofday((struct timeval */* __restrict  */)(& cur_time), (__timezone_ptr_t )((void *)0));
    }
#line 211
    if (eof_in) {
#line 211
      if (eof_out) {
#line 212
        final_update = 1;
#line 213
        next_update.tv_sec = cur_time.tv_sec - 1L;
      }
    }
#line 216
    if (cur_time.tv_sec > next_reset.tv_sec) {
#line 216
      goto _L;
    } else
#line 216
    if (cur_time.tv_sec == next_reset.tv_sec) {
#line 216
      if (cur_time.tv_usec >= next_reset.tv_usec) {
        _L: /* CIL Label */ 
        {
#line 219
        pv_timeval_add_usec(& next_reset, 100000L);
        }
#line 220
        if (next_reset.tv_sec < cur_time.tv_sec) {
#line 221
          next_reset.tv_sec = cur_time.tv_sec;
        }
#line 222
        donealready = 0LL;
      }
    }
#line 225
    if (opts->no_op) {
#line 226
      goto while_continue;
    }
#line 234
    if (opts->wait) {
#line 235
      if (opts->linemode) {
#line 236
        if (lineswritten < 1L) {
#line 237
          goto while_continue;
        }
      } else
#line 239
      if (written < 1L) {
#line 240
        goto while_continue;
      }
      {
#line 243
      opts->wait = (unsigned char)0;
#line 255
      pv_sig_nopause();
#line 256
      gettimeofday((struct timeval */* __restrict  */)(& start_time), (__timezone_ptr_t )((void *)0));
#line 257
      pv_sig_toffset.tv_sec = (__time_t )0;
#line 258
      pv_sig_toffset.tv_usec = (__suseconds_t )0;
#line 259
      pv_sig_allowpause();
#line 261
      next_update.tv_sec = start_time.tv_sec;
#line 262
      next_update.tv_usec = start_time.tv_usec;
#line 263
      pv_timeval_add_usec(& next_update, (long )(1000000.0 * opts->interval));
      }
    }
#line 268
    if (cur_time.tv_sec < next_update.tv_sec) {
#line 271
      goto while_continue;
    } else
#line 268
    if (cur_time.tv_sec == next_update.tv_sec) {
#line 268
      if (cur_time.tv_usec < next_update.tv_usec) {
#line 271
        goto while_continue;
      }
    }
    {
#line 274
    pv_timeval_add_usec(& next_update, (long )(1000000.0 * opts->interval));
    }
#line 277
    if (next_update.tv_sec < cur_time.tv_sec) {
#line 278
      next_update.tv_sec = cur_time.tv_sec;
#line 279
      next_update.tv_usec = cur_time.tv_usec;
    } else
#line 280
    if (next_update.tv_sec == cur_time.tv_sec) {
#line 280
      if (next_update.tv_usec < cur_time.tv_usec) {
#line 282
        next_update.tv_usec = cur_time.tv_usec;
      }
    }
#line 285
    init_time.tv_sec = start_time.tv_sec + pv_sig_toffset.tv_sec;
#line 287
    init_time.tv_usec = start_time.tv_usec + pv_sig_toffset.tv_usec;
#line 289
    if (init_time.tv_usec >= 1000000L) {
#line 290
      (init_time.tv_sec) ++;
#line 291
      init_time.tv_usec -= 1000000L;
    }
#line 293
    if (init_time.tv_usec < 0L) {
#line 294
      (init_time.tv_sec) --;
#line 295
      init_time.tv_usec += 1000000L;
    }
#line 298
    elapsed = (long double )(cur_time.tv_sec - init_time.tv_sec);
#line 299
    elapsed += (long double )((double )(cur_time.tv_usec - init_time.tv_usec) / 1000000.0);
#line 302
    if (final_update) {
#line 303
      since_last = -1LL;
    }
#line 305
    if (pv_sig_newsize) {
      {
#line 306
      pv_sig_newsize = 0;
#line 307
      pv_screensize(opts);
      }
    }
    {
#line 310
    pv_display(opts, elapsed, since_last, total_written);
#line 312
    since_last = 0LL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (opts->cursor) {
    {
#line 316
    pv_crs_fini(opts);
    }
  } else
#line 318
  if (! opts->numeric) {
#line 318
    if (! opts->no_op) {
      {
#line 319
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
  }
  {
#line 326
  pv_display((opts_t )0, (long double )0, 0LL, 0LL);
#line 327
  pv_transfer((opts_t )0, -1, (int *)0, (int *)0, 0ULL, (long *)((void *)0));
  }
#line 329
  if (pv_sig_abort) {
#line 330
    opts->exit_status = (unsigned char )((int )opts->exit_status | 32);
  }
#line 332
  return ((int )opts->exit_status);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 770
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ttyname)(int __fd ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/shm.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmctl)(int __shmid ,
                                                                             int __cmd ,
                                                                             struct shmid_ds *__buf ) ;
#line 53
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmget)(key_t __key ,
                                                                             size_t __size ,
                                                                             int __shmflg ) ;
#line 56
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) shmat)(int __shmid ,
                                                                              void const   *__shmaddr ,
                                                                              int __shmflg ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shmdt)(void const   *__shmaddr ) ;
#line 46 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__shmid  =    -1;
#line 47 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__pvcount  =    1;
#line 48 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__pvmax  =    0;
#line 49 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int *pv_crs__y_top  =    (int *)0;
#line 50 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_lastread  =    0;
#line 51 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_offset  =    0;
#line 52 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__needreinit  =    0;
#line 53 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__noipc  =    0;
#line 55 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__uselockfile  =    0;
#line 56 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__lock_fd  =    -1;
#line 57 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_start  =    0;
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__lock_lockfile(int fd ) 
{ 


  {
#line 108
  pv_crs__uselockfile = 1;
#line 110
  pv_crs__noipc = 1;
#line 114
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__lock(int fd ) 
{ 
  struct flock lock ;
  int *tmp ;
  int tmp___0 ;

  {
#line 125
  lock.l_type = (short)1;
#line 126
  lock.l_whence = (short)0;
#line 127
  lock.l_start = (__off_t )0;
#line 128
  lock.l_len = (__off_t )1;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___0 = fcntl(fd, 7, & lock);
    }
#line 129
    if (! (tmp___0 < 0)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp = __errno_location();
    }
#line 130
    if (*tmp != 4) {
      {
#line 131
      pv_crs__lock_lockfile(fd);
      }
#line 132
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__unlock(int fd ) 
{ 
  struct flock lock ;

  {
#line 146
  if (pv_crs__uselockfile) {
#line 147
    if (pv_crs__lock_fd >= 0) {
      {
#line 148
      close(pv_crs__lock_fd);
      }
    }
#line 149
    pv_crs__lock_fd = -1;
  } else {
    {
#line 151
    lock.l_type = (short)2;
#line 152
    lock.l_whence = (short)0;
#line 153
    lock.l_start = (__off_t )0;
#line 154
    lock.l_len = (__off_t )1;
#line 155
    fcntl(fd, 6, & lock);
    }
  }
#line 157
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__ipccount(void) 
{ 
  struct shmid_ds buf___1 ;

  {
  {
#line 171
  buf___1.shm_nattch = (shmatt_t )0;
#line 173
  shmctl(pv_crs__shmid, 2, & buf___1);
#line 174
  pv_crs__pvcount = (int )buf___1.shm_nattch;
  }
#line 176
  if (pv_crs__pvcount > pv_crs__pvmax) {
#line 177
    pv_crs__pvmax = pv_crs__pvcount;
  }
#line 178
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__get_ypos(int terminalfd ) 
{ 
  struct termios tty ;
  struct termios old_tty ;
  char cpr[32] ;
  int ypos ;

  {
  {
#line 193
  tcgetattr(terminalfd, & tty);
#line 194
  tcgetattr(terminalfd, & old_tty);
#line 195
  tty.c_lflag &= 4294967285U;
#line 196
  tcsetattr(terminalfd, 2, (struct termios  const  *)(& tty));
#line 197
  write(terminalfd, (void const   *)"\033[6n", (size_t )4);
#line 198
  memset((void *)(cpr), 0, sizeof(cpr));
#line 199
  read(terminalfd, (void *)(cpr), (size_t )6);
#line 200
  ypos = pv_getnum_i(cpr + 2);
#line 201
  tcsetattr(terminalfd, 2, (struct termios  const  *)(& old_tty));
  }
#line 203
  return (ypos);
}
}
#line 220 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__ipcinit(opts_t opts , char *ttyfile , int terminalfd ) 
{ 
  key_t key ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 229
  key = ftok((char const   *)ttyfile, 'p');
  }
#line 230
  if (key == -1) {
    {
#line 231
    tmp = __errno_location();
#line 231
    tmp___0 = strerror(*tmp);
#line 231
    tmp___1 = gettext("failed to open terminal");
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___1, tmp___0);
    }
#line 234
    return (1);
  }
  {
#line 237
  pv_crs__lock(terminalfd);
  }
#line 238
  if (pv_crs__noipc) {
    {
#line 239
    tmp___2 = __errno_location();
#line 239
    tmp___3 = strerror(*tmp___2);
#line 239
    tmp___4 = gettext("failed to lock terminal");
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___4, tmp___3);
    }
#line 242
    return (1);
  }
  {
#line 245
  pv_crs__shmid = shmget(key, sizeof(int ), 896);
  }
#line 246
  if (pv_crs__shmid < 0) {
    {
#line 247
    tmp___5 = __errno_location();
#line 247
    tmp___6 = strerror(*tmp___5);
#line 247
    tmp___7 = gettext("failed to open terminal");
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___7, tmp___6);
#line 250
    pv_crs__unlock(terminalfd);
    }
#line 251
    return (1);
  }
  {
#line 254
  tmp___8 = shmat(pv_crs__shmid, (void const   *)0, 0);
#line 254
  pv_crs__y_top = (int *)tmp___8;
#line 256
  pv_crs__ipccount();
  }
#line 263
  if (pv_crs__pvcount < 2) {
    {
#line 264
    pv_crs__y_start = pv_crs__get_ypos(terminalfd);
#line 265
    *pv_crs__y_top = pv_crs__y_start;
#line 266
    pv_crs__y_lastread = pv_crs__y_start;
    }
  }
#line 269
  pv_crs__y_offset = pv_crs__pvcount - 1;
#line 270
  if (pv_crs__y_offset < 0) {
#line 271
    pv_crs__y_offset = 0;
  }
#line 277
  if (pv_crs__pvcount > 1) {
#line 278
    pv_crs__y_start = *pv_crs__y_top;
#line 279
    pv_crs__y_lastread = pv_crs__y_start;
  }
  {
#line 282
  pv_crs__unlock(terminalfd);
  }
#line 284
  return (0);
}
}
#line 292 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
void pv_crs_init(opts_t opts ) 
{ 
  char *ttyfile ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 297
  if (! opts->cursor) {
#line 298
    return;
  }
  {
#line 300
  ttyfile = ttyname(2);
  }
#line 301
  if (! ttyfile) {
#line 302
    opts->cursor = (unsigned char)0;
#line 303
    return;
  }
  {
#line 306
  fd = open((char const   *)ttyfile, 2);
  }
#line 307
  if (fd < 0) {
    {
#line 308
    tmp = __errno_location();
#line 308
    tmp___0 = strerror(*tmp);
#line 308
    tmp___1 = gettext("failed to open terminal");
#line 308
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___1, tmp___0);
#line 311
    opts->cursor = (unsigned char)0;
    }
#line 312
    return;
  }
  {
#line 315
  tmp___2 = pv_crs__ipcinit(opts, ttyfile, fd);
  }
#line 315
  if (tmp___2) {
    {
#line 316
    opts->cursor = (unsigned char)0;
#line 317
    close(fd);
    }
#line 318
    return;
  }
#line 326
  if (pv_crs__noipc) {
    {
#line 333
    pv_crs__lock(fd);
#line 334
    pv_crs__y_start = pv_crs__get_ypos(fd);
#line 335
    pv_crs__unlock(fd);
    }
#line 337
    if (pv_crs__y_start < 1) {
#line 338
      opts->cursor = (unsigned char)0;
    }
  }
  {
#line 341
  close(fd);
  }
#line 342
  return;
}
}
#line 349 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
void pv_crs_needreinit(void) 
{ 


  {
#line 351
  pv_crs__needreinit += 2;
#line 352
  if (pv_crs__needreinit > 3) {
#line 353
    pv_crs__needreinit = 3;
  }
#line 354
  return;
}
}
#line 363 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
void pv_crs_reinit(void) 
{ 


  {
  {
#line 365
  pv_crs__lock(2);
#line 367
  pv_crs__needreinit --;
  }
#line 368
  if (pv_crs__y_offset < 1) {
#line 369
    pv_crs__needreinit = 0;
  }
#line 371
  if (pv_crs__needreinit > 0) {
    {
#line 372
    pv_crs__unlock(2);
    }
#line 373
    return;
  }
  {
#line 376
  pv_crs__y_start = pv_crs__get_ypos(2);
  }
#line 378
  if (pv_crs__y_offset < 1) {
#line 379
    *pv_crs__y_top = pv_crs__y_start;
  }
  {
#line 380
  pv_crs__y_lastread = pv_crs__y_start;
#line 382
  pv_crs__unlock(2);
  }
#line 383
  return;
}
}
#line 391 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
void pv_crs_update(opts_t opts , char *str ) 
{ 
  char pos[32] ;
  int y ;
  int offs ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 397
  if (! pv_crs__noipc) {
#line 398
    if (pv_crs__needreinit) {
      {
#line 399
      pv_crs_reinit();
      }
    }
    {
#line 401
    pv_crs__ipccount();
    }
#line 402
    if (pv_crs__y_lastread != *pv_crs__y_top) {
#line 403
      pv_crs__y_start = *pv_crs__y_top;
#line 404
      pv_crs__y_lastread = pv_crs__y_start;
    }
#line 407
    if (pv_crs__needreinit > 0) {
#line 408
      return;
    }
  }
#line 412
  y = pv_crs__y_start;
#line 421
  if ((unsigned int )(pv_crs__y_start + pv_crs__pvmax) > opts->height) {
#line 421
    if (! pv_crs__noipc) {
#line 426
      offs = (int )((unsigned int )(pv_crs__y_start + pv_crs__pvmax) - opts->height);
#line 428
      pv_crs__y_start -= offs;
#line 429
      if (pv_crs__y_start < 1) {
#line 430
        pv_crs__y_start = 1;
      }
#line 435
      if (pv_crs__y_offset == 0) {
        {
#line 436
        pv_crs__lock(2);
#line 438
        sprintf((char */* __restrict  */)(pos), (char const   */* __restrict  */)"\033[%d;1H",
                opts->height);
#line 439
        tmp = strlen((char const   *)(pos));
#line 439
        write(2, (void const   *)(pos), tmp);
        }
        {
#line 440
        while (1) {
          while_continue: /* CIL Label */ ;
#line 440
          if (! (offs > 0)) {
#line 440
            goto while_break;
          }
          {
#line 441
          write(2, (void const   *)"\n", (size_t )1);
#line 440
          offs --;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 444
        pv_crs__unlock(2);
        }
      }
    }
  }
#line 448
  if (! pv_crs__noipc) {
#line 449
    y = pv_crs__y_start + pv_crs__y_offset;
  }
#line 456
  if (y < 1) {
#line 457
    y = 1;
  } else
#line 456
  if (y > 999999) {
#line 457
    y = 1;
  }
  {
#line 458
  sprintf((char */* __restrict  */)(pos), (char const   */* __restrict  */)"\033[%d;1H",
          y);
#line 460
  pv_crs__lock(2);
#line 462
  tmp___0 = strlen((char const   *)(pos));
#line 462
  write(2, (void const   *)(pos), tmp___0);
#line 463
  tmp___1 = strlen((char const   *)str);
#line 463
  write(2, (void const   *)str, tmp___1);
#line 465
  pv_crs__unlock(2);
  }
#line 466
  return;
}
}
#line 472 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
void pv_crs_fini(opts_t opts ) 
{ 
  char pos[32] ;
  int y ;
  size_t tmp ;

  {
#line 477
  y = pv_crs__y_start;
#line 480
  if (pv_crs__pvmax > 0) {
#line 480
    if (! pv_crs__noipc) {
#line 481
      y += pv_crs__pvmax - 1;
    }
  }
#line 484
  if ((unsigned int )y > opts->height) {
#line 485
    y = (int )opts->height;
  }
#line 490
  if (y < 1) {
#line 491
    y = 1;
  } else
#line 490
  if (y > 999999) {
#line 491
    y = 1;
  }
  {
#line 493
  sprintf((char */* __restrict  */)(pos), (char const   */* __restrict  */)"\033[%d;1H\n",
          y);
#line 495
  pv_crs__lock(2);
#line 497
  tmp = strlen((char const   *)(pos));
#line 497
  write(2, (void const   *)(pos), tmp);
#line 500
  pv_crs__ipccount();
#line 501
  shmdt((void const   *)((void *)pv_crs__y_top));
  }
#line 507
  if (pv_crs__pvcount < 2) {
    {
#line 508
    shmctl(pv_crs__shmid, 0, (struct shmid_ds *)0);
    }
  }
  {
#line 512
  pv_crs__unlock(2);
  }
#line 513
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 31 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long long pv__bufsize  =    409600ULL;
#line 37 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
void pv_set_buffer_size(unsigned long long sz , int force ) 
{ 


  {
#line 39
  if (sz > 524288ULL) {
#line 39
    if (! force) {
#line 40
      sz = 524288ULL;
    }
  }
#line 41
  pv__bufsize = sz;
#line 42
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned char *buf  =    (unsigned char *)((void *)0);
#line 62 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long long buf_alloced  =    0ULL;
#line 63 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long in_buffer  =    0UL;
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long bytes_written  =    0UL;
#line 58 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
long pv_transfer(opts_t opts , int fd , int *eof_in , int *eof_out , unsigned long long allowed ,
                 long *lineswritten ) 
{ 
  struct timeval tv ;
  fd_set readfds ;
  fd_set writefds ;
  int max_fd ;
  long to_write ;
  long written ;
  ssize_t r ;
  ssize_t w ;
  int n ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned char *newptr ;
  void *tmp___3 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int ckidx ;
  int *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int nlidx ;

  {
#line 73
  if ((unsigned long )opts == (unsigned long )((void *)0)) {
#line 74
    if (buf) {
      {
#line 75
      free((void *)buf);
      }
    }
#line 76
    buf = (unsigned char *)((void *)0);
#line 77
    in_buffer = 0UL;
#line 78
    bytes_written = 0UL;
#line 79
    return (0L);
  }
#line 82
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 83
    buf_alloced = pv__bufsize;
#line 84
    tmp = malloc((size_t )(pv__bufsize + 32ULL));
#line 84
    buf = (unsigned char *)tmp;
    }
#line 85
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
      {
#line 86
      tmp___0 = __errno_location();
#line 86
      tmp___1 = strerror(*tmp___0);
#line 86
      tmp___2 = gettext("buffer allocation failed");
#line 86
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              opts->program_name, tmp___2, tmp___1);
#line 90
      opts->exit_status = (unsigned char )((int )opts->exit_status | 64);
      }
#line 91
      return (-1L);
    }
  }
#line 98
  if (buf_alloced < pv__bufsize) {
    {
#line 100
    tmp___3 = realloc((void *)buf, (size_t )(pv__bufsize + 32ULL));
#line 100
    newptr = (unsigned char *)tmp___3;
    }
#line 102
    if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 103
      pv__bufsize = buf_alloced;
    } else {
#line 105
      buf = newptr;
#line 106
      buf_alloced = pv__bufsize;
    }
  }
#line 110
  if (opts->linemode) {
#line 110
    if ((unsigned long )lineswritten != (unsigned long )((void *)0)) {
#line 111
      *lineswritten = 0L;
    }
  }
#line 113
  tv.tv_sec = (__time_t )0;
#line 114
  tv.tv_usec = (__suseconds_t )90000;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 116
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 117
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 117
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 119
  max_fd = 0;
#line 121
  if (! *eof_in) {
#line 121
    if ((unsigned long long )in_buffer < pv__bufsize) {
#line 122
      readfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 123
      if (fd > max_fd) {
#line 124
        max_fd = fd;
      }
    }
  }
#line 127
  to_write = (long )(in_buffer - bytes_written);
#line 128
  if (opts->rate_limit > 0ULL) {
#line 129
    if ((unsigned long long )to_write > allowed) {
#line 130
      to_write = (long )allowed;
    }
  }
#line 134
  if (! *eof_out) {
#line 134
    if (to_write > 0L) {
#line 135
      writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 1 % (8 * (int )sizeof(__fd_mask ));
#line 136
      if (1 > max_fd) {
#line 137
        max_fd = 1;
      }
    }
  }
#line 140
  if (*eof_in) {
#line 140
    if (*eof_out) {
#line 141
      return (0L);
    }
  }
  {
#line 143
  n = select(max_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
             (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
  }
#line 145
  if (n < 0) {
    {
#line 146
    tmp___4 = __errno_location();
    }
#line 146
    if (*tmp___4 == 4) {
#line 147
      return (0L);
    }
    {
#line 148
    tmp___5 = __errno_location();
#line 148
    tmp___6 = strerror(*tmp___5);
#line 148
    tmp___7 = gettext("select call failed");
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s: %d: %s\n",
            opts->program_name, opts->current_file, tmp___7, n, tmp___6);
#line 151
    opts->exit_status = (unsigned char )((int )opts->exit_status | 16);
    }
#line 152
    return (-1L);
  }
#line 155
  written = 0L;
#line 157
  if ((readfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 158
    r = read(fd, (void *)(buf + in_buffer), (size_t )(pv__bufsize - (unsigned long long )in_buffer));
    }
#line 160
    if (r < 0L) {
      {
#line 166
      tmp___8 = __errno_location();
      }
#line 166
      if (*tmp___8 == 4) {
        {
#line 167
        tv.tv_sec = (__time_t )0;
#line 168
        tv.tv_usec = (__suseconds_t )10000;
#line 169
        select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
        }
#line 170
        return (0L);
      } else {
        {
#line 166
        tmp___9 = __errno_location();
        }
#line 166
        if (*tmp___9 == 11) {
          {
#line 167
          tv.tv_sec = (__time_t )0;
#line 168
          tv.tv_usec = (__suseconds_t )10000;
#line 169
          select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
          }
#line 170
          return (0L);
        }
      }
      {
#line 172
      tmp___10 = __errno_location();
#line 172
      tmp___11 = strerror(*tmp___10);
#line 172
      tmp___12 = gettext("read failed");
#line 172
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s: %s\n",
              opts->program_name, opts->current_file, tmp___12, tmp___11);
#line 176
      opts->exit_status = (unsigned char )((int )opts->exit_status | 16);
#line 177
      *eof_in = 1;
      }
#line 178
      if (bytes_written >= in_buffer) {
#line 179
        *eof_out = 1;
      }
    } else
#line 180
    if (r == 0L) {
#line 181
      *eof_in = 1;
#line 182
      if (bytes_written >= in_buffer) {
#line 183
        *eof_out = 1;
      }
    } else {
#line 185
      in_buffer += (unsigned long )r;
    }
  }
#line 193
  if (opts->linemode) {
#line 195
    ckidx = 1;
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 195
      if (! ((long )ckidx < to_write)) {
#line 195
        goto while_break___1;
      }
#line 196
      if ((int )*(buf + ((bytes_written + (unsigned long )ckidx) - 1UL)) == 10) {
#line 197
        to_write = (long )ckidx;
      }
#line 195
      ckidx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 201
  if ((writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] & (1L << 1 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 201
    if (in_buffer > bytes_written) {
#line 201
      if (to_write > 0L) {
        {
#line 205
        signal(14, (void (*)(int  ))1);
#line 206
        alarm(1U);
#line 208
        w = write(1, (void const   *)(buf + bytes_written), (size_t )to_write);
#line 210
        alarm(0U);
        }
#line 212
        if (w < 0L) {
          {
#line 218
          tmp___13 = __errno_location();
          }
#line 218
          if (*tmp___13 == 4) {
            {
#line 219
            tv.tv_sec = (__time_t )0;
#line 220
            tv.tv_usec = (__suseconds_t )10000;
#line 221
            select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
            }
#line 222
            return (0L);
          } else {
            {
#line 218
            tmp___14 = __errno_location();
            }
#line 218
            if (*tmp___14 == 11) {
              {
#line 219
              tv.tv_sec = (__time_t )0;
#line 220
              tv.tv_usec = (__suseconds_t )10000;
#line 221
              select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
              }
#line 222
              return (0L);
            }
          }
          {
#line 228
          tmp___15 = __errno_location();
          }
#line 228
          if (*tmp___15 == 32) {
#line 229
            *eof_in = 1;
#line 230
            *eof_out = 1;
#line 231
            return (0L);
          }
          {
#line 233
          tmp___16 = __errno_location();
#line 233
          tmp___17 = strerror(*tmp___16);
#line 233
          tmp___18 = gettext("write failed");
#line 233
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                  opts->program_name, tmp___18, tmp___17);
#line 236
          opts->exit_status = (unsigned char )((int )opts->exit_status | 16);
#line 237
          *eof_out = 1;
#line 238
          written = -1L;
          }
        } else
#line 239
        if (w == 0L) {
#line 240
          *eof_out = 1;
        } else {
#line 242
          if (opts->linemode) {
#line 242
            if ((unsigned long )lineswritten != (unsigned long )((void *)0)) {
#line 244
              nlidx = 0;
              {
#line 244
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 244
                if (! ((ssize_t )nlidx < w)) {
#line 244
                  goto while_break___2;
                }
#line 245
                if ((int )*(buf + (bytes_written + (unsigned long )nlidx)) == 10) {
#line 247
                  *lineswritten = 1L + *lineswritten;
                }
#line 244
                nlidx ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
#line 252
          bytes_written += (unsigned long )w;
#line 253
          written += w;
#line 254
          if (bytes_written >= in_buffer) {
#line 255
            bytes_written = 0UL;
#line 256
            in_buffer = 0UL;
#line 257
            if (*eof_in) {
#line 258
              *eof_out = 1;
            }
          }
        }
      }
    }
  }
#line 267
  if (bytes_written > 0UL) {
#line 268
    if (bytes_written < in_buffer) {
      {
#line 269
      memmove((void *)buf, (void const   *)(buf + bytes_written), in_buffer - bytes_written);
#line 271
      in_buffer -= bytes_written;
#line 272
      bytes_written = 0UL;
      }
    } else {
#line 274
      bytes_written = 0UL;
#line 275
      in_buffer = 0UL;
    }
  }
#line 280
  return (written);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 228 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat64)(char const   * __restrict  __file ,
                                                                                               struct stat64 * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 345
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    int __whence ) ;
#line 156 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open64)(char const   *__file , int __oflag 
                                                     , ...) ;
#line 38 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/file.c"
void pv_calc_total_size(opts_t opts ) 
{ 
  struct stat64 sb ;
  int rc ;
  int i ;
  int j ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  __off64_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  unsigned char scanbuf[1024] ;
  int numread ;
  int i___0 ;
  ssize_t tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;

  {
#line 43
  opts->size = 0ULL;
#line 44
  rc = 0;
#line 46
  if (opts->argc < 1) {
    {
#line 47
    tmp = fstat64(0, & sb);
    }
#line 47
    if (tmp == 0) {
#line 48
      opts->size = (unsigned long long )sb.st_size;
    }
#line 49
    return;
  }
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < opts->argc)) {
#line 52
      goto while_break;
    }
    {
#line 53
    tmp___0 = strcmp((char const   *)*(opts->argv + i), "-");
    }
#line 53
    if (tmp___0 == 0) {
      {
#line 54
      rc = fstat64(0, & sb);
      }
#line 55
      if (rc != 0) {
#line 56
        opts->size = 0ULL;
#line 57
        return;
      }
    } else {
      {
#line 60
      rc = stat64((char const   */* __restrict  */)*(opts->argv + i), (struct stat64 */* __restrict  */)(& sb));
      }
#line 61
      if (rc == 0) {
        {
#line 62
        rc = access((char const   *)*(opts->argv + i), 4);
        }
      }
    }
#line 65
    if (rc != 0) {
      {
#line 66
      tmp___1 = __errno_location();
#line 66
      tmp___2 = strerror(*tmp___1);
#line 66
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              opts->program_name, *(opts->argv + i), tmp___2);
#line 68
      j = i;
      }
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! (j < opts->argc - 1)) {
#line 68
          goto while_break___0;
        }
#line 69
        *(opts->argv + j) = *(opts->argv + (j + 1));
#line 68
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 71
      (opts->argc) --;
#line 72
      i --;
#line 73
      opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
#line 74
      goto __Cont;
    }
#line 77
    if ((sb.st_mode & 61440U) == 24576U) {
      {
#line 82
      tmp___3 = strcmp((char const   *)*(opts->argv + i), "-");
      }
#line 82
      if (tmp___3 == 0) {
        {
#line 83
        fd = open64("/dev/stdin", 0);
        }
      } else {
        {
#line 85
        fd = open64((char const   *)*(opts->argv + i), 0);
        }
      }
#line 87
      if (fd >= 0) {
        {
#line 88
        tmp___4 = lseek64(fd, (__off64_t )0, 2);
#line 88
        opts->size += (unsigned long long )tmp___4;
#line 89
        close(fd);
        }
      } else {
        {
#line 91
        tmp___5 = __errno_location();
#line 91
        tmp___6 = strerror(*tmp___5);
#line 91
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                opts->program_name, *(opts->argv + i), tmp___6);
#line 94
        opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
        }
      }
    } else
#line 96
    if ((sb.st_mode & 61440U) == 32768U) {
#line 97
      opts->size += (unsigned long long )sb.st_size;
    } else {
#line 99
      opts->size = 0ULL;
    }
    __Cont: /* CIL Label */ 
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  if (! opts->linemode) {
#line 104
    return;
  }
#line 106
  opts->size = 0ULL;
#line 108
  i = 0;
  {
#line 108
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 108
    if (! (i < opts->argc)) {
#line 108
      goto while_break___1;
    }
    {
#line 109
    fd = -1;
#line 111
    tmp___7 = strcmp((char const   *)*(opts->argv + i), "-");
    }
#line 111
    if (tmp___7 == 0) {
      {
#line 112
      rc = fstat64(0, & sb);
      }
#line 113
      if (rc != 0) {
#line 114
        opts->size = 0ULL;
#line 115
        return;
      } else
#line 113
      if (! ((sb.st_mode & 61440U) == 32768U)) {
#line 114
        opts->size = 0ULL;
#line 115
        return;
      }
      {
#line 117
      fd = dup(0);
      }
    } else {
      {
#line 119
      rc = stat64((char const   */* __restrict  */)*(opts->argv + i), (struct stat64 */* __restrict  */)(& sb));
      }
#line 120
      if (rc != 0) {
#line 121
        opts->size = 0ULL;
#line 122
        return;
      } else
#line 120
      if (! ((sb.st_mode & 61440U) == 32768U)) {
#line 121
        opts->size = 0ULL;
#line 122
        return;
      }
      {
#line 124
      fd = open64((char const   *)*(opts->argv + i), 0);
      }
    }
#line 127
    if (fd < 0) {
      {
#line 128
      tmp___8 = __errno_location();
#line 128
      tmp___9 = strerror(*tmp___8);
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              opts->program_name, *(opts->argv + i), tmp___9);
#line 130
      opts->size = 0ULL;
#line 131
      opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
      }
#line 132
      return;
    }
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 139
      tmp___10 = read(fd, (void *)(scanbuf), sizeof(scanbuf));
#line 139
      numread = (int )tmp___10;
      }
#line 141
      if (numread < 0) {
        {
#line 142
        tmp___11 = __errno_location();
#line 142
        tmp___12 = strerror(*tmp___11);
#line 142
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
                opts->program_name, *(opts->argv + i___0), tmp___12);
#line 145
        opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
        }
#line 146
        goto while_break___2;
      } else
#line 147
      if (numread == 0) {
#line 148
        goto while_break___2;
      }
#line 150
      i___0 = 0;
      {
#line 150
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 150
        if (! (i___0 < numread)) {
#line 150
          goto while_break___3;
        }
#line 151
        if ((int )scanbuf[i___0] == 10) {
#line 152
          (opts->size) ++;
        }
#line 150
        i___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 156
    lseek64(fd, (__off64_t )0, 0);
#line 157
    close(fd);
#line 108
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 168 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/file.c"
int pv_next_file(opts_t opts , int filenum , int oldfd ) 
{ 
  struct stat64 isb ;
  struct stat64 osb ;
  int fd ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 174
  if (oldfd > 0) {
    {
#line 175
    tmp___2 = close(oldfd);
    }
#line 175
    if (tmp___2) {
      {
#line 176
      tmp = __errno_location();
#line 176
      tmp___0 = strerror(*tmp);
#line 176
      tmp___1 = gettext("failed to close file");
#line 176
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              opts->program_name, tmp___1, tmp___0);
#line 180
      opts->exit_status = (unsigned char )((int )opts->exit_status | 8);
      }
#line 181
      return (-1);
    }
  }
#line 185
  if (filenum >= opts->argc) {
#line 186
    opts->exit_status = (unsigned char )((int )opts->exit_status | 8);
#line 187
    return (-1);
  }
#line 190
  if (filenum < 0) {
#line 191
    opts->exit_status = (unsigned char )((int )opts->exit_status | 8);
#line 192
    return (-1);
  }
  {
#line 195
  tmp___6 = strcmp((char const   *)*(opts->argv + filenum), "-");
  }
#line 195
  if (tmp___6 == 0) {
#line 196
    fd = 0;
  } else {
    {
#line 198
    fd = open64((char const   *)*(opts->argv + filenum), 0);
    }
#line 199
    if (fd < 0) {
      {
#line 200
      tmp___3 = __errno_location();
#line 200
      tmp___4 = strerror(*tmp___3);
#line 200
      tmp___5 = gettext("failed to read file");
#line 200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s: %s\n",
              opts->program_name, tmp___5, *(opts->argv + filenum), tmp___4);
#line 204
      opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
      }
#line 205
      return (-1);
    }
  }
  {
#line 209
  tmp___10 = fstat64(fd, & isb);
  }
#line 209
  if (tmp___10) {
    {
#line 210
    tmp___7 = __errno_location();
#line 210
    tmp___8 = strerror(*tmp___7);
#line 210
    tmp___9 = gettext("failed to stat file");
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s: %s\n",
            opts->program_name, tmp___9, *(opts->argv + filenum), tmp___8);
#line 214
    close(fd);
#line 215
    opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
    }
#line 216
    return (-1);
  }
  {
#line 219
  tmp___14 = fstat64(1, & osb);
  }
#line 219
  if (tmp___14) {
    {
#line 220
    tmp___11 = __errno_location();
#line 220
    tmp___12 = strerror(*tmp___11);
#line 220
    tmp___13 = gettext("failed to stat output file");
#line 220
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___13, tmp___12);
#line 223
    close(fd);
#line 224
    opts->exit_status = (unsigned char )((int )opts->exit_status | 2);
    }
#line 225
    return (-1);
  }
#line 233
  if (isb.st_dev != osb.st_dev) {
#line 234
    return (fd);
  }
#line 235
  if (isb.st_ino != osb.st_ino) {
#line 236
    return (fd);
  }
  {
#line 237
  tmp___15 = isatty(fd);
  }
#line 237
  if (tmp___15) {
#line 238
    return (fd);
  }
#line 239
  if (! ((isb.st_mode & 61440U) == 32768U)) {
#line 239
    if (! ((isb.st_mode & 61440U) == 24576U)) {
#line 240
      return (fd);
    }
  }
  {
#line 242
  tmp___16 = gettext("input file is output file");
#line 242
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
          opts->program_name, tmp___16, *(opts->argv + filenum));
#line 245
  close(fd);
#line 246
  opts->exit_status = (unsigned char )((int )opts->exit_status | 4);
  }
#line 247
  return (-1);
}
}
#line 31 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long long pv__bufsize___0  =    409600ULL;
#line 61 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned char *buf___0  =    (unsigned char *)((void *)0);
#line 62 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long long buf_alloced___0  =    0ULL;
#line 63 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long in_buffer___0  =    0UL;
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/transfer.c"
static unsigned long bytes_written___0  =    0UL;
#line 46 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__shmid___0  =    -1;
#line 47 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__pvcount___0  =    1;
#line 48 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__pvmax___0  =    0;
#line 49 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int *pv_crs__y_top___0  =    (int *)0;
#line 50 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_lastread___0  =    0;
#line 51 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_offset___0  =    0;
#line 52 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__needreinit___0  =    0;
#line 53 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__noipc___0  =    0;
#line 55 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__uselockfile___0  =    0;
#line 56 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__lock_fd___0  =    -1;
#line 57 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__y_start___0  =    0;
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__lock_lockfile___0(int fd ) 
{ 


  {
#line 108
  pv_crs__uselockfile___0 = 1;
#line 110
  pv_crs__noipc___0 = 1;
#line 114
  return;
}
}
#line 121 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__lock___0(int fd ) 
{ 
  struct flock lock ;
  int *tmp ;
  int tmp___0 ;

  {
#line 125
  lock.l_type = (short)1;
#line 126
  lock.l_whence = (short)0;
#line 127
  lock.l_start = (__off_t )0;
#line 128
  lock.l_len = (__off_t )1;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___0 = fcntl(fd, 7, & lock);
    }
#line 129
    if (! (tmp___0 < 0)) {
#line 129
      goto while_break;
    }
    {
#line 130
    tmp = __errno_location();
    }
#line 130
    if (*tmp != 4) {
      {
#line 131
      pv_crs__lock_lockfile___0(fd);
      }
#line 132
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__unlock___0(int fd ) 
{ 
  struct flock lock ;

  {
#line 146
  if (pv_crs__uselockfile___0) {
#line 147
    if (pv_crs__lock_fd___0 >= 0) {
      {
#line 148
      close(pv_crs__lock_fd___0);
      }
    }
#line 149
    pv_crs__lock_fd___0 = -1;
  } else {
    {
#line 151
    lock.l_type = (short)2;
#line 152
    lock.l_whence = (short)0;
#line 153
    lock.l_start = (__off_t )0;
#line 154
    lock.l_len = (__off_t )1;
#line 155
    fcntl(fd, 6, & lock);
    }
  }
#line 157
  return;
}
}
#line 167 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static void pv_crs__ipccount___0(void) 
{ 
  struct shmid_ds buf___1 ;

  {
  {
#line 171
  buf___1.shm_nattch = (shmatt_t )0;
#line 173
  shmctl(pv_crs__shmid___0, 2, & buf___1);
#line 174
  pv_crs__pvcount___0 = (int )buf___1.shm_nattch;
  }
#line 176
  if (pv_crs__pvcount___0 > pv_crs__pvmax___0) {
#line 177
    pv_crs__pvmax___0 = pv_crs__pvcount___0;
  }
#line 178
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__get_ypos___0(int terminalfd ) 
{ 
  struct termios tty ;
  struct termios old_tty ;
  char cpr[32] ;
  int ypos ;

  {
  {
#line 193
  tcgetattr(terminalfd, & tty);
#line 194
  tcgetattr(terminalfd, & old_tty);
#line 195
  tty.c_lflag &= 4294967285U;
#line 196
  tcsetattr(terminalfd, 2, (struct termios  const  *)(& tty));
#line 197
  write(terminalfd, (void const   *)"\033[6n", (size_t )4);
#line 198
  memset((void *)(cpr), 0, sizeof(cpr));
#line 199
  read(terminalfd, (void *)(cpr), (size_t )6);
#line 200
  ypos = pv_getnum_i(cpr + 2);
#line 201
  tcsetattr(terminalfd, 2, (struct termios  const  *)(& old_tty));
  }
#line 203
  return (ypos);
}
}
#line 220 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/cursor.c"
static int pv_crs__ipcinit___0(opts_t opts , char *ttyfile , int terminalfd ) 
{ 
  key_t key ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 229
  key = ftok((char const   *)ttyfile, 'p');
  }
#line 230
  if (key == -1) {
    {
#line 231
    tmp = __errno_location();
#line 231
    tmp___0 = strerror(*tmp);
#line 231
    tmp___1 = gettext("failed to open terminal");
#line 231
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___1, tmp___0);
    }
#line 234
    return (1);
  }
  {
#line 237
  pv_crs__lock___0(terminalfd);
  }
#line 238
  if (pv_crs__noipc___0) {
    {
#line 239
    tmp___2 = __errno_location();
#line 239
    tmp___3 = strerror(*tmp___2);
#line 239
    tmp___4 = gettext("failed to lock terminal");
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___4, tmp___3);
    }
#line 242
    return (1);
  }
  {
#line 245
  pv_crs__shmid___0 = shmget(key, sizeof(int ), 896);
  }
#line 246
  if (pv_crs__shmid___0 < 0) {
    {
#line 247
    tmp___5 = __errno_location();
#line 247
    tmp___6 = strerror(*tmp___5);
#line 247
    tmp___7 = gettext("failed to open terminal");
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
            opts->program_name, tmp___7, tmp___6);
#line 250
    pv_crs__unlock___0(terminalfd);
    }
#line 251
    return (1);
  }
  {
#line 254
  tmp___8 = shmat(pv_crs__shmid___0, (void const   *)0, 0);
#line 254
  pv_crs__y_top___0 = (int *)tmp___8;
#line 256
  pv_crs__ipccount___0();
  }
#line 263
  if (pv_crs__pvcount___0 < 2) {
    {
#line 264
    pv_crs__y_start___0 = pv_crs__get_ypos___0(terminalfd);
#line 265
    *pv_crs__y_top___0 = pv_crs__y_start___0;
#line 266
    pv_crs__y_lastread___0 = pv_crs__y_start___0;
    }
  }
#line 269
  pv_crs__y_offset___0 = pv_crs__pvcount___0 - 1;
#line 270
  if (pv_crs__y_offset___0 < 0) {
#line 271
    pv_crs__y_offset___0 = 0;
  }
#line 277
  if (pv_crs__pvcount___0 > 1) {
#line 278
    pv_crs__y_start___0 = *pv_crs__y_top___0;
#line 279
    pv_crs__y_lastread___0 = pv_crs__y_start___0;
  }
  {
#line 282
  pv_crs__unlock___0(terminalfd);
  }
#line 284
  return (0);
}
}
#line 17 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/number.c"
static int pv__isdigit___0(char c ) 
{ 
  int tmp ;

  {
#line 19
  if ((int )c >= 48) {
#line 19
    if ((int )c <= 57) {
#line 19
      tmp = 1;
    } else {
#line 19
      tmp = 0;
    }
  } else {
#line 19
    tmp = 0;
  }
#line 19
  return (tmp);
}
}
#line 47 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static long pv__calc_percentage___0(long long so_far , long long const   total ) 
{ 


  {
#line 49
  if (total < 1LL) {
#line 50
    return (0L);
  }
#line 52
  so_far *= 100LL;
#line 53
  so_far /= (long long )total;
#line 55
  return ((long )so_far);
}
}
#line 64 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static long pv__calc_eta___0(long long const   so_far , long long const   total ,
                             long const   elapsed ) 
{ 
  long long amount_left ;

  {
#line 69
  if (so_far < 1LL) {
#line 70
    return (0L);
  }
#line 72
  amount_left = (long long )(total - so_far);
#line 73
  amount_left *= (long long )elapsed;
#line 74
  amount_left /= (long long )so_far;
#line 76
  return ((long )amount_left);
}
}
#line 90
static void pv__si_prefix___0(long double *value , char *prefix , long double const   ratio ) ;
#line 90 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char *pfx___0  =    (char *)((void *)0);
#line 91 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char const   *pfx_middle___0  =    (char const   *)((void *)0);
#line 87 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static void pv__si_prefix___0(long double *value , char *prefix , long double const   ratio ) 
{ 
  char const   *i ;
  char *tmp ;

  {
#line 94
  if ((unsigned long )pfx___0 == (unsigned long )((void *)0)) {
    {
#line 95
    pfx___0 = gettext("yzafpnum kMGTPEZY");
    }
  }
#line 98
  if ((unsigned long )pfx_middle___0 == (unsigned long )((void *)0)) {
    {
#line 103
    tmp = strchr((char const   *)pfx___0, ' ');
#line 103
    pfx_middle___0 = (char const   *)tmp;
    }
  }
#line 105
  i = pfx_middle___0;
#line 107
  *prefix = (char )'\000';
#line 112
  if (*value == (long double )0.0) {
#line 113
    return;
  }
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (*value >= (long double )1000.0) {
#line 115
      i ++;
#line 115
      if (! ((int const   )*i != 0)) {
#line 115
        goto while_break;
      }
    } else {
#line 115
      goto while_break;
    }
#line 116
    *value /= (long double )ratio;
#line 117
    *prefix = (char )*i;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (*value < (long double )1.0) {
#line 120
      i --;
#line 120
      if (! ((unsigned long )i != (unsigned long )(pfx___0 - 1))) {
#line 120
        goto while_break___0;
      }
    } else {
#line 120
      goto while_break___0;
    }
#line 121
    *value *= (long double )ratio;
#line 122
    *prefix = (char )*i;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 146 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static void pv__state_init___0(struct pv_display_state *state___1 , opts_t opts ) 
{ 


  {
#line 148
  if ((unsigned long )state___1 == (unsigned long )((void *)0)) {
#line 149
    return;
  }
  {
#line 150
  memset((void *)state___1, 0, sizeof(struct pv_display_state ));
#line 151
  state___1->opts = opts;
  }
#line 152
  return;
}
}
#line 172 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static char *pv__format___0(struct pv_display_state *state___1 , long double elapsed_sec ,
                            long long bytes_since_last , long long total_bytes ) 
{ 
  long double time_since_last ;
  long double rate ;
  long double transferred ;
  long eta ;
  int component_count ;
  int static_portion_size ;
  char str_transferred[128] ;
  char str_timer[128] ;
  char str_rate[128] ;
  char str_average_rate[128] ;
  char str_eta[128] ;
  char si_prefix[2] ;
  char *units ;
  long double average_rate ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int name_length ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  int i ;
  size_t tmp___10 ;
  char pct[16] ;
  int available_width ;
  int i___0 ;
  size_t tmp___11 ;
  int p ;

  {
#line 185
  si_prefix[0] = (char )' ';
#line 185
  si_prefix[1] = (char )'\000';
#line 190
  if ((unsigned long )state___1 == (unsigned long )((void *)0)) {
#line 191
    return ((char *)((void *)0));
  }
#line 194
  if (total_bytes < 0LL) {
#line 195
    if (state___1->outbuffer) {
      {
#line 196
      free((void *)state___1->outbuffer);
      }
    }
#line 197
    state___1->outbuffer = (char *)((void *)0);
#line 198
    return ((char *)((void *)0));
  }
#line 207
  time_since_last = elapsed_sec - state___1->prev_elapsed_sec;
#line 208
  if (time_since_last <= (long double )0.01) {
#line 209
    rate = state___1->prev_rate;
#line 210
    state___1->prev_trans += (long double )bytes_since_last;
  } else {
#line 212
    rate = ((long double )bytes_since_last + state___1->prev_trans) / time_since_last;
#line 215
    state___1->prev_elapsed_sec = elapsed_sec;
#line 216
    state___1->prev_trans = (long double )0;
  }
#line 218
  state___1->prev_rate = rate;
#line 225
  if (bytes_since_last < 0LL) {
#line 225
    goto _L;
  } else
#line 225
  if ((state___1->opts)->average_rate) {
    _L: /* CIL Label */ 
#line 227
    if (elapsed_sec < (long double )0.000001) {
#line 228
      elapsed_sec = (long double )0.000001;
    }
#line 229
    average_rate = (long double )total_bytes / elapsed_sec;
#line 232
    if (bytes_since_last < 0LL) {
#line 233
      rate = average_rate;
    }
  }
#line 236
  if ((state___1->opts)->size <= 0ULL) {
#line 245
    if (rate > (long double )0) {
#line 246
      state___1->percentage += 2L;
    }
#line 247
    if (state___1->percentage > 199L) {
#line 248
      state___1->percentage = 0L;
    }
  } else
#line 249
  if ((state___1->opts)->numeric) {
    {
#line 255
    state___1->percentage = pv__calc_percentage___0(total_bytes, (long long const   )(state___1->opts)->size);
    }
  } else
#line 249
  if ((state___1->opts)->progress) {
    {
#line 255
    state___1->percentage = pv__calc_percentage___0(total_bytes, (long long const   )(state___1->opts)->size);
    }
  }
#line 262
  if ((unsigned long )state___1->outbuffer != (unsigned long )((void *)0)) {
#line 262
    if (state___1->outbufsize < (long )((state___1->opts)->width * 2U)) {
      {
#line 264
      free((void *)state___1->outbuffer);
#line 265
      state___1->outbuffer = (char *)((void *)0);
#line 266
      state___1->outbufsize = 0L;
      }
    }
  }
#line 272
  if ((unsigned long )state___1->outbuffer == (unsigned long )((void *)0)) {
#line 273
    state___1->outbufsize = (long )(2U * (state___1->opts)->width + 80U);
#line 274
    if ((state___1->opts)->name) {
      {
#line 275
      tmp = strlen((char const   *)(state___1->opts)->name);
#line 275
      state___1->outbufsize = (long )((size_t )state___1->outbufsize + tmp);
      }
    }
    {
#line 276
    tmp___0 = malloc((size_t )(state___1->outbufsize + 16L));
#line 276
    state___1->outbuffer = (char *)tmp___0;
    }
#line 277
    if ((unsigned long )state___1->outbuffer == (unsigned long )((void *)0)) {
      {
#line 278
      tmp___1 = __errno_location();
#line 278
      tmp___2 = strerror(*tmp___1);
#line 278
      tmp___3 = gettext("buffer allocation failed");
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s\n",
              (state___1->opts)->program_name, tmp___3, tmp___2);
#line 282
      (state___1->opts)->exit_status = (unsigned char )((int )(state___1->opts)->exit_status | 64);
      }
#line 283
      return ((char *)((void *)0));
    }
#line 285
    *(state___1->outbuffer + 0) = (char)0;
  }
#line 289
  if ((state___1->opts)->numeric) {
#line 290
    if (state___1->percentage > 100L) {
      {
#line 292
      sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%ld\n",
              200L - state___1->percentage);
      }
    } else {
      {
#line 295
      sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%ld\n",
              state___1->percentage);
      }
    }
#line 298
    return (state___1->outbuffer);
  }
#line 309
  component_count = 0;
#line 310
  static_portion_size = 0;
#line 311
  str_transferred[0] = (char)0;
#line 312
  str_timer[0] = (char)0;
#line 313
  str_rate[0] = (char)0;
#line 314
  str_average_rate[0] = (char)0;
#line 315
  str_eta[0] = (char)0;
#line 318
  if ((state___1->opts)->name) {
    {
#line 321
    tmp___4 = strlen((char const   *)(state___1->opts)->name);
#line 321
    name_length = (int )tmp___4;
    }
#line 322
    if (name_length < 9) {
#line 323
      name_length = 9;
    }
#line 324
    if (name_length > 500) {
#line 325
      name_length = 500;
    }
#line 327
    component_count ++;
#line 328
    static_portion_size += name_length + 1;
  }
#line 332
  if ((state___1->opts)->bytes) {
#line 333
    transferred = (long double )total_bytes;
#line 335
    if ((state___1->opts)->linemode) {
      {
#line 336
      pv__si_prefix___0(& transferred, si_prefix, (long double const   )1000.0);
#line 337
      units = (char *)"";
      }
    } else {
      {
#line 339
      pv__si_prefix___0(& transferred, si_prefix, (long double const   )1024.0);
#line 340
      units = gettext("B");
      }
    }
#line 344
    if (transferred > (long double )100000) {
#line 345
      transferred = (long double )100000;
    }
    {
#line 347
    sprintf((char */* __restrict  */)(str_transferred), (char const   */* __restrict  */)"%4.3Lg%.1s%.16s",
            transferred, si_prefix, units);
#line 350
    component_count ++;
#line 351
    tmp___5 = strlen((char const   *)(str_transferred));
#line 351
    static_portion_size = (int )((size_t )static_portion_size + tmp___5);
    }
  }
#line 355
  if ((state___1->opts)->timer) {
#line 361
    if (elapsed_sec > 360000000.0L) {
#line 362
      elapsed_sec = 360000000.0L;
    }
    {
#line 364
    sprintf((char */* __restrict  */)(str_timer), (char const   */* __restrict  */)"%ld:%02ld:%02ld",
            (long )elapsed_sec / 3600L, ((long )elapsed_sec / 60L) % 60L, (long )elapsed_sec % 60L);
#line 369
    component_count ++;
#line 370
    tmp___6 = strlen((char const   *)(str_timer));
#line 370
    static_portion_size = (int )((size_t )static_portion_size + tmp___6);
    }
  }
#line 374
  if ((state___1->opts)->rate) {
#line 375
    if ((state___1->opts)->linemode) {
      {
#line 376
      pv__si_prefix___0(& rate, si_prefix, (long double const   )1000.0);
#line 377
      units = gettext("/s");
      }
    } else {
      {
#line 379
      pv__si_prefix___0(& rate, si_prefix, (long double const   )1024.0);
#line 380
      units = gettext("B/s");
      }
    }
#line 387
    if (rate > (long double )100000) {
#line 388
      rate = (long double )100000;
    }
    {
#line 390
    sprintf((char */* __restrict  */)(str_rate), (char const   */* __restrict  */)"[%4.3Lg%.1s%.16s]",
            rate, si_prefix, units);
#line 393
    component_count ++;
#line 394
    tmp___7 = strlen((char const   *)(str_rate));
#line 394
    static_portion_size = (int )((size_t )static_portion_size + tmp___7);
    }
  }
#line 398
  if ((state___1->opts)->average_rate) {
#line 399
    if ((state___1->opts)->linemode) {
      {
#line 400
      pv__si_prefix___0(& average_rate, si_prefix, (long double const   )1000.0);
#line 401
      units = gettext("/s");
      }
    } else {
      {
#line 403
      pv__si_prefix___0(& average_rate, si_prefix, (long double const   )1024.0);
#line 404
      units = gettext("B/s");
      }
    }
#line 408
    if (average_rate > (long double )100000) {
#line 409
      average_rate = (long double )100000;
    }
    {
#line 411
    sprintf((char */* __restrict  */)(str_average_rate), (char const   */* __restrict  */)"[%4.3Lg%.1s%.16s]",
            average_rate, si_prefix, units);
#line 414
    component_count ++;
#line 415
    tmp___8 = strlen((char const   *)(str_average_rate));
#line 415
    static_portion_size = (int )((size_t )static_portion_size + tmp___8);
    }
  }
#line 419
  if ((state___1->opts)->eta) {
#line 419
    if ((state___1->opts)->size > 0ULL) {
      {
#line 420
      eta = pv__calc_eta___0((long long const   )total_bytes, (long long const   )(state___1->opts)->size,
                             (long const   )elapsed_sec);
      }
#line 424
      if (eta < 0L) {
#line 425
        eta = 0L;
      }
#line 431
      if (eta > 360000000L) {
#line 432
        eta = 360000000L;
      }
      {
#line 434
      tmp___9 = gettext("ETA");
#line 434
      sprintf((char */* __restrict  */)(str_eta), (char const   */* __restrict  */)"%.16s %ld:%02ld:%02ld",
              tmp___9, eta / 3600L, (eta / 60L) % 60L, eta % 60L);
      }
#line 441
      if (bytes_since_last < 0LL) {
#line 443
        i = 0;
        {
#line 443
        while (1) {
          while_continue: /* CIL Label */ ;
#line 443
          if ((unsigned long )i < sizeof(str_eta)) {
#line 443
            if (! ((int )str_eta[i] != 0)) {
#line 443
              goto while_break;
            }
          } else {
#line 443
            goto while_break;
          }
#line 445
          str_eta[i] = (char )' ';
#line 443
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 449
      component_count ++;
#line 450
      tmp___10 = strlen((char const   *)(str_eta));
#line 450
      static_portion_size = (int )((size_t )static_portion_size + tmp___10);
      }
    }
  }
#line 460
  *(state___1->outbuffer + 0) = (char)0;
#line 462
  if ((state___1->opts)->name) {
    {
#line 463
    sprintf((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"%9s:",
            (state___1->opts)->name);
    }
  }
#line 471
  if ((int )str_transferred[0] != 0) {
#line 471
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 471
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 471
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_transferred));
    }
  }
#line 472
  if ((int )str_timer[0] != 0) {
#line 472
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 472
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 472
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_timer));
    }
  }
#line 473
  if ((int )str_rate[0] != 0) {
#line 473
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 473
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 473
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_rate));
    }
  }
#line 474
  if ((int )str_average_rate[0] != 0) {
#line 474
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 474
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 474
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_average_rate));
    }
  }
#line 476
  if ((state___1->opts)->progress) {
#line 480
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 481
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 482
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"[");
    }
#line 484
    if ((state___1->opts)->size > 0ULL) {
#line 485
      if (state___1->percentage < 0L) {
#line 486
        state___1->percentage = 0L;
      }
#line 487
      if (state___1->percentage > 100000L) {
#line 488
        state___1->percentage = 100000L;
      }
      {
#line 489
      sprintf((char */* __restrict  */)(pct), (char const   */* __restrict  */)"%2ld%%",
              state___1->percentage);
#line 490
      tmp___11 = strlen((char const   *)(pct));
#line 490
      available_width = (int )(((size_t )(((state___1->opts)->width - (unsigned int )static_portion_size) - (unsigned int )component_count) - tmp___11) - 3UL);
#line 494
      i___0 = 0;
      }
      {
#line 494
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 494
        if (! ((long )i___0 < ((long )available_width * state___1->percentage) / 100L - 1L)) {
#line 494
          goto while_break___0;
        }
#line 498
        if (i___0 < available_width) {
          {
#line 499
          strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"=");
          }
        }
#line 494
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 501
      if (i___0 < available_width) {
        {
#line 502
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)">");
#line 503
        i___0 ++;
        }
      }
      {
#line 505
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 505
        if (! (i___0 < available_width)) {
#line 505
          goto while_break___1;
        }
        {
#line 506
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
#line 505
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 508
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"] ");
#line 509
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(pct));
      }
    } else {
#line 511
      p = (int )state___1->percentage;
#line 512
      available_width = (int )((((state___1->opts)->width - (unsigned int )static_portion_size) - (unsigned int )component_count) - 5U);
#line 515
      if (p > 100) {
#line 516
        p = 200 - p;
      }
#line 517
      i___0 = 0;
      {
#line 517
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 517
        if (! (i___0 < (available_width * p) / 100)) {
#line 517
          goto while_break___2;
        }
#line 518
        if (i___0 < available_width) {
          {
#line 519
          strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
          }
        }
#line 517
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 521
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"<=>");
      }
      {
#line 522
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 522
        if (! (i___0 < available_width)) {
#line 522
          goto while_break___3;
        }
        {
#line 523
        strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
#line 522
        i___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 525
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)"]");
      }
    }
  }
#line 529
  if ((int )str_eta[0] != 0) {
#line 529
    if ((int )*(state___1->outbuffer + 0) != 0) {
      {
#line 529
      strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 529
    strcat((char */* __restrict  */)state___1->outbuffer, (char const   */* __restrict  */)(str_eta));
    }
  }
#line 531
  return (state___1->outbuffer);
}
}
#line 550 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static struct pv_display_state state___0  ;
#line 551 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/display.c"
static int initialised___0  =    0;
#line 41 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static opts_t remote__opts___0  =    (opts_t )((void *)0);
#line 53 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static key_t remote__genkey___0(opts_t opts ) 
{ 
  int uid ;
  key_t key ;
  __uid_t tmp ;
  key_t tmp___0 ;

  {
  {
#line 58
  tmp = geteuid();
#line 58
  uid = (int )tmp;
  }
#line 59
  if (uid < 0) {
#line 60
    uid = 0;
  }
  {
#line 62
  tmp___0 = ftok("/tmp", 'P');
#line 62
  key = tmp___0 | uid;
  }
#line 64
  return (key);
}
}
#line 72 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static int remote__msgget___0(opts_t opts ) 
{ 
  key_t tmp ;
  int tmp___0 ;

  {
  {
#line 74
  tmp = remote__genkey___0(opts);
#line 74
  tmp___0 = msgget(tmp, 896);
  }
#line 74
  return (tmp___0);
}
}
#line 134 "/home/wheatley/newnew/temp/pv-1.2.0/src/main/remote.c"
static void remote__sig_usr1___0(int s ) 
{ 
  struct remote_msg msgbuf ;
  struct msqid_ds qbuf ;
  ssize_t got ;
  int msgid ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 141
  memset((void *)(& msgbuf), 0, sizeof(msgbuf));
#line 143
  msgid = remote__msgget___0(remote__opts___0);
  }
#line 144
  if (msgid < 0) {
#line 145
    return;
  }
  {
#line 148
  tmp = getpid();
#line 148
  got = msgrcv(msgid, (void *)(& msgbuf), sizeof(msgbuf) - sizeof(long ), (long )tmp,
               2048);
  }
#line 151
  if (got < 0L) {
    {
#line 152
    msgctl(msgid, 0, & qbuf);
    }
#line 153
    return;
  }
  {
#line 156
  tmp___0 = msgctl(msgid, 0, & qbuf);
  }
#line 156
  if (tmp___0 == 0) {
#line 157
    if (qbuf.msg_qnum < 1UL) {
      {
#line 158
      msgctl(msgid, 0, & qbuf);
      }
    }
  }
#line 162
  if (got < 1L) {
#line 163
    return;
  } else
#line 162
  if ((unsigned long )remote__opts___0 == (unsigned long )((void *)0)) {
#line 163
    return;
  }
#line 167
  remote__opts___0->progress = msgbuf.progress;
#line 168
  remote__opts___0->timer = msgbuf.timer;
#line 169
  remote__opts___0->eta = msgbuf.eta;
#line 170
  remote__opts___0->rate = msgbuf.rate;
#line 171
  remote__opts___0->average_rate = msgbuf.average_rate;
#line 173
  if (msgbuf.rate_limit > 0ULL) {
#line 174
    remote__opts___0->rate_limit = msgbuf.rate_limit;
  }
#line 175
  if (msgbuf.buffer_size > 0ULL) {
    {
#line 176
    remote__opts___0->buffer_size = msgbuf.buffer_size;
#line 177
    pv_set_buffer_size(msgbuf.buffer_size, 1);
    }
  }
#line 179
  if (msgbuf.size > 0ULL) {
#line 180
    remote__opts___0->size = msgbuf.size;
  }
#line 181
  if (msgbuf.interval > (double )0) {
#line 182
    remote__opts___0->interval = msgbuf.interval;
  }
#line 183
  if (msgbuf.width > 0U) {
#line 184
    remote__opts___0->width = msgbuf.width;
  }
#line 185
  if (msgbuf.height > 0U) {
#line 186
    remote__opts___0->height = msgbuf.height;
  }
#line 187
  if ((int )msgbuf.name[0] != 0) {
    {
#line 188
    remote__opts___0->name = strdup((char const   *)(msgbuf.name));
    }
  }
#line 189
  return;
}
}
#line 22 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static int pv__sig_old_stderr___0  ;
#line 23 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static struct timeval pv__sig_tstp_time___0  ;
#line 41 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_ttou___0(int s ) 
{ 
  int fd ;

  {
  {
#line 45
  fd = open("/dev/null", 2);
  }
#line 46
  if (fd < 0) {
#line 47
    return;
  }
#line 49
  if (pv__sig_old_stderr___0 == -1) {
    {
#line 50
    pv__sig_old_stderr___0 = dup(2);
    }
  }
  {
#line 52
  dup2(fd, 2);
#line 53
  close(fd);
  }
#line 54
  return;
}
}
#line 61 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_tstp___0(int s ) 
{ 


  {
  {
#line 63
  gettimeofday((struct timeval */* __restrict  */)(& pv__sig_tstp_time___0), (__timezone_ptr_t )((void *)0));
#line 64
  raise(19);
  }
#line 65
  return;
}
}
#line 73 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_cont___0(int s ) 
{ 
  struct timeval tv ;
  struct termios t ;

  {
#line 78
  pv_sig_newsize = 1;
#line 80
  if (pv__sig_tstp_time___0.tv_sec == 0L) {
    {
#line 81
    tcgetattr(2, & t);
#line 82
    t.c_lflag |= 256U;
#line 83
    tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 85
    pv_crs_needreinit();
    }
#line 87
    return;
  }
  {
#line 90
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 92
  pv_sig_toffset.tv_sec += tv.tv_sec - pv__sig_tstp_time___0.tv_sec;
#line 93
  pv_sig_toffset.tv_usec += tv.tv_usec - pv__sig_tstp_time___0.tv_usec;
  }
#line 94
  if (pv_sig_toffset.tv_usec >= 1000000L) {
#line 95
    (pv_sig_toffset.tv_sec) ++;
#line 96
    pv_sig_toffset.tv_usec -= 1000000L;
  }
#line 98
  if (pv_sig_toffset.tv_usec < 0L) {
#line 99
    (pv_sig_toffset.tv_sec) --;
#line 100
    pv_sig_toffset.tv_usec += 1000000L;
  }
#line 103
  pv__sig_tstp_time___0.tv_sec = (__time_t )0;
#line 104
  pv__sig_tstp_time___0.tv_usec = (__suseconds_t )0;
#line 106
  if (pv__sig_old_stderr___0 != -1) {
    {
#line 107
    dup2(pv__sig_old_stderr___0, 2);
#line 108
    close(pv__sig_old_stderr___0);
#line 109
    pv__sig_old_stderr___0 = -1;
    }
  }
  {
#line 112
  tcgetattr(2, & t);
#line 113
  t.c_lflag |= 256U;
#line 114
  tcsetattr(2, 0, (struct termios  const  *)(& t));
#line 117
  pv_crs_needreinit();
  }
#line 119
  return;
}
}
#line 125 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_winch___0(int s ) 
{ 


  {
#line 127
  pv_sig_newsize = 1;
#line 128
  return;
}
}
#line 134 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static void pv__sig_term___0(int s ) 
{ 


  {
#line 136
  pv_sig_abort = 1;
#line 137
  return;
}
}
#line 266 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/signal.c"
static time_t next_check___0  =    (time_t )0;
#line 37 "/home/wheatley/newnew/temp/pv-1.2.0/src/pv/loop.c"
static void pv_timeval_add_usec___0(struct timeval *val , long usec ) 
{ 


  {
#line 39
  val->tv_usec += usec;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (val->tv_usec < 0L)) {
#line 40
      goto while_break;
    }
#line 41
    (val->tv_sec) --;
#line 42
    val->tv_usec += 1000000L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 44
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 44
    if (! (val->tv_usec >= 1000000L)) {
#line 44
      goto while_break___0;
    }
#line 45
    (val->tv_sec) ++;
#line 46
    val->tv_usec -= 1000000L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  return;
}
}
