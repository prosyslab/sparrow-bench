/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_38 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_39 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_40 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_41 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_42 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_43 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_36 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_37 _kill ;
   struct __anonstruct__timer_38 _timer ;
   struct __anonstruct__rt_39 _rt ;
   struct __anonstruct__sigchld_40 _sigchld ;
   struct __anonstruct__sigfault_41 _sigfault ;
   struct __anonstruct__sigpoll_42 _sigpoll ;
   struct __anonstruct__sigsys_43 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_35 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_36 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_35 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_55 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_55 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/poll.h"
typedef unsigned long nfds_t;
#line 39 "/usr/include/x86_64-linux-gnu/sys/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 928 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 933 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 940 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 947 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 946 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 927 "/home/june/collector/temp/autossh-1.4c/autossh.c"
union __anonunion_64 {
   int __in ;
   int __i ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 469
extern int pause(void) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 603
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/poll.h"
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
#line 81 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *__progname  ;
#line 84 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char const   *rcsid  =    "$Id: autossh.c,v 1.82 2011/10/12 20:29:22 harding Exp $";
#line 109 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int logtype  =    2;
#line 110 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int loglevel  =    6;
#line 111 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int syslog_perror  ;
#line 112 "/home/june/collector/temp/autossh-1.4c/autossh.c"
FILE *flog  ;
#line 114 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *writep  ;
#line 115 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char readp[16]  ;
#line 116 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *echop  ;
#line 117 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *mhost  =    (char *)"127.0.0.1";
#line 118 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *env_port  ;
#line 119 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *echo_message  =    (char *)"";
#line 120 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *pid_file_name  ;
#line 121 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int pid_file_created  ;
#line 122 "/home/june/collector/temp/autossh-1.4c/autossh.c"
time_t pid_start_time  ;
#line 123 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int poll_time  =    600;
#line 124 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int first_poll_time  =    600;
#line 125 "/home/june/collector/temp/autossh-1.4c/autossh.c"
double gate_time  =    (double )30;
#line 126 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int max_start  =    -1;
#line 127 "/home/june/collector/temp/autossh-1.4c/autossh.c"
double max_lifetime  =    (double )0;
#line 128 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int net_timeout  =    15000;
#line 129 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *ssh_path  =    (char *)"/usr/bin/ssh";
#line 130 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int start_count  ;
#line 131 "/home/june/collector/temp/autossh-1.4c/autossh.c"
time_t start_time  ;
#line 137 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int newac  ;
#line 138 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char **newav  ;
#line 141 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int cchild  ;
#line 143 "/home/june/collector/temp/autossh-1.4c/autossh.c"
sig_atomic_t volatile   restart_ssh  ;
#line 144 "/home/june/collector/temp/autossh-1.4c/autossh.c"
sig_atomic_t volatile   dolongjmp  ;
#line 145 "/home/june/collector/temp/autossh-1.4c/autossh.c"
sigjmp_buf jumpbuf  ;
#line 147
 __attribute__((__noreturn__)) void usage(int code ) ;
#line 148
void get_env_args(void) ;
#line 149
void add_arg(char *s ) ;
#line 150
void strip_arg(char *arg , char ch , char *opts ) ;
#line 151
void ssh_run(int sock , char **av ) ;
#line 152
int ssh_watch(int sock ) ;
#line 153
int ssh_wait(int options ) ;
#line 154
void ssh_kill(void) ;
#line 155
int conn_test(int sock , char *host , char *write_port ) ;
#line 156
int conn_poll_for_accept(int sock , struct pollfd *pfd ) ;
#line 157
int conn_send_and_receive(char *rp , char *wp , size_t len , struct pollfd *pfd ,
                          int ntopoll ) ;
#line 162
void conn_addr(char *host , char *port , struct addrinfo **resp ) ;
#line 164
int conn_listen(char *host , char *port ) ;
#line 165
int conn_remote(char *host , char *port ) ;
#line 166
void grace_time(time_t last_start ) ;
#line 167
void unlink_pid_file(void) ;
#line 168
void ( /* format attribute */  errlog)(int level , char *fmt  , ...) ;
#line 170
void ( /* format attribute */  xerrlog)(int level , char *fmt  , ...) ;
#line 172
void doerrlog(int level , char *fmt , va_list ap ) ;
#line 173
char *timestr(void) ;
#line 174
void sig_catch(int sig ) ;
#line 175
int exceeded_lifetime(void) ;
#line 177
 __attribute__((__noreturn__)) void usage(int code ) ;
#line 177 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void usage(int code ) 
{ 
  struct _IO_FILE *tmp ;

  {
#line 180
  if (code) {
#line 180
    tmp = stderr;
  } else {
#line 180
    tmp = stdout;
  }
  {
#line 180
  fprintf((FILE */* __restrict  */)tmp, (char const   */* __restrict  */)"usage: %s [-V] [-M monitor_port[:echo_port]] [-f] [SSH_OPTIONS]\n",
          __progname);
  }
#line 183
  if (code) {
    {
#line 184
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -M specifies monitor port. Overrides the environment\n       variable AUTOSSH_PORT. 0 turns monitoring loop off.\n       Alternatively, a port for an echo service on the remote\n       machine may be specified. (Normally port 7.)\n");
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -f run in background (autossh handles this, and does not\n       pass it to ssh.)\n");
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    -V print autossh version and exit.\n");
#line 199
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Environment variables are:\n");
#line 201
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_GATETIME    - how long must an ssh session be established\n                          before we decide it really was established\n                          (in seconds). Default is %d seconds; use of -f\n                          flag sets this to 0.\n",
            30);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_LOGFILE     - file to log to (default is to use the syslog\n                          facility)\n");
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_LOGLEVEL    - level of log verbosity\n");
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_MAXLIFETIME - set the maximum time to live (seconds)\n");
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_MAXSTART    - max times to restart (default is no limit)\n");
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_MESSAGE     - message to append to echo string (max 64 bytes)\n");
#line 232
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_PATH        - path to ssh if not default\n");
#line 235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_PIDFILE     - write pid to this file\n");
#line 238
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_POLL        - how often to check the connection (seconds)\n");
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_FIRST_POLL  - time before first connection check (seconds)\n");
#line 244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_PORT        - port to use for monitor connection\n");
#line 247
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"    AUTOSSH_DEBUG       - turn logging to maximum verbosity and log to\n                          stderr\n");
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 254
  exit(code);
  }
}
}
#line 257 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int n ;
  int ch ;
  char *s ;
  int wp ;
  int rp ;
  int ep ;
  char wmbuf[256] ;
  char rmbuf[256] ;
  FILE *pid_file ;
  int sock ;
  int done_fwds ;
  int runasdaemon ;
  int sawargstop ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  __pid_t tmp___9 ;
  int tmp___10 ;

  {
  {
#line 264
  ep = 0;
#line 268
  sock = -1;
#line 269
  done_fwds = 0;
#line 270
  runasdaemon = 0;
#line 271
  sawargstop = 0;
#line 277
  __progname = (char *)"autossh";
#line 283
  get_env_args();
  }
#line 286
  if (env_port) {
#line 287
    writep = env_port;
  }
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    ch = getopt(argc, (char * const  *)argv, "M:V1246ab:c:e:fgi:kl:m:no:p:qstvw:xyACD:F:I:MKL:NO:PR:S:TVXY");
    }
#line 293
    if (! (ch != -1)) {
#line 293
      goto while_break;
    }
    {
#line 295
    if (ch == 77) {
#line 295
      goto case_77;
    }
#line 298
    if (ch == 86) {
#line 298
      goto case_86;
    }
#line 302
    if (ch == 102) {
#line 302
      goto case_102;
    }
#line 310
    if (ch == 63) {
#line 310
      goto case_63;
    }
#line 313
    goto switch_default;
    case_77: /* CIL Label */ 
#line 296
    writep = optarg;
#line 297
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 299
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s %s\n",
            __progname, "1.4c");
#line 300
    exit(0);
    }
#line 301
    goto switch_break;
    case_102: /* CIL Label */ 
#line 303
    runasdaemon = 1;
#line 304
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 311
    usage(1);
    }
#line 312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 315
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (env_port) {
#line 324
    if (argc < 2) {
      {
#line 325
      usage(1);
      }
    }
  } else
#line 326
  if (! writep) {
    {
#line 327
    usage(1);
    }
  } else
#line 326
  if (argc < 4) {
    {
#line 327
    usage(1);
    }
  }
#line 329
  if (logtype & 2) {
    {
#line 330
    openlog((char const   *)__progname, 1 | syslog_perror, 1 << 3);
    }
  }
  {
#line 335
  s = strchr((char const   *)writep, ':');
  }
#line 335
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 336
    *s = (char )'\000';
#line 337
    echop = s + 1;
#line 338
    tmp = strtoul((char const   */* __restrict  */)echop, (char **/* __restrict  */)(& s),
                  0);
#line 338
    ep = (int )tmp;
    }
#line 339
    if ((int )*echop == 0) {
      {
#line 340
      xerrlog(3, (char *)"invalid echo port  \"%s\"", echop);
      }
    } else
#line 339
    if ((int )*s != 0) {
      {
#line 340
      xerrlog(3, (char *)"invalid echo port  \"%s\"", echop);
      }
    } else
#line 339
    if (ep == 0) {
      {
#line 340
      xerrlog(3, (char *)"invalid echo port  \"%s\"", echop);
      }
    }
  }
  {
#line 347
  tmp___0 = strtoul((char const   */* __restrict  */)writep, (char **/* __restrict  */)(& s),
                    0);
#line 347
  wp = (int )tmp___0;
  }
#line 348
  if ((int )*writep == 0) {
    {
#line 349
    xerrlog(3, (char *)"invalid port \"%s\"", writep);
    }
  } else
#line 348
  if ((int )*s != 0) {
    {
#line 349
    xerrlog(3, (char *)"invalid port \"%s\"", writep);
    }
  }
#line 350
  if (wp == 0) {
    {
#line 351
    errlog(6, (char *)"port set to 0, monitoring disabled");
#line 352
    writep = (char *)((void *)0);
    }
  } else
#line 354
  if (wp > 65534) {
    {
#line 355
    xerrlog(3, (char *)"monitor port (%d) out of range", wp);
    }
  } else
#line 354
  if (wp < 0) {
    {
#line 355
    xerrlog(3, (char *)"monitor port (%d) out of range", wp);
    }
  } else {
    {
#line 357
    rp = wp + 1;
#line 359
    snprintf((char */* __restrict  */)(readp), sizeof(readp), (char const   */* __restrict  */)"%d",
             rp);
    }
#line 362
    if (echop) {
#line 362
      tmp___1 = ep;
    } else {
#line 362
      tmp___1 = wp;
    }
    {
#line 362
    n = snprintf((char */* __restrict  */)(wmbuf), sizeof(wmbuf), (char const   */* __restrict  */)"%d:%s:%d",
                 wp, mhost, tmp___1);
    }
#line 364
    if ((unsigned long )n > sizeof(wmbuf)) {
      {
#line 365
      xerrlog(3, (char *)"overflow building forwarding string");
      }
    }
#line 367
    if (! echop) {
      {
#line 368
      n = snprintf((char */* __restrict  */)(rmbuf), sizeof(rmbuf), (char const   */* __restrict  */)"%d:%s:%d",
                   wp, mhost, rp);
      }
#line 370
      if ((unsigned long )n > sizeof(rmbuf)) {
        {
#line 371
        xerrlog(3, (char *)"overflow building forwarding string");
        }
      }
    }
  }
#line 383
  if ((poll_time * 1000) / 2 < net_timeout) {
    {
#line 384
    net_timeout = (poll_time * 1000) / 2;
#line 385
    errlog(6, (char *)"short poll time: adjusting net timeouts to %d", net_timeout);
    }
  }
  {
#line 394
  add_arg(ssh_path);
#line 401
  i = 1;
  }
  {
#line 401
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 401
    if (! (i < argc)) {
#line 401
      goto while_break___0;
    }
#line 406
    if ((int )*(*(argv + i) + 0) == 45) {
#line 406
      if ((int )*(*(argv + i) + 1) == 45) {
#line 407
        if (! sawargstop) {
#line 408
          sawargstop = 1;
#line 409
          goto __Cont;
        }
      }
    }
#line 412
    if (wp) {
#line 412
      if (! done_fwds) {
        {
#line 413
        add_arg((char *)"-L");
#line 414
        add_arg(wmbuf);
        }
#line 415
        if (! echop) {
          {
#line 416
          add_arg((char *)"-R");
#line 417
          add_arg(rmbuf);
          }
        }
#line 419
        done_fwds = 1;
      }
    }
#line 421
    if (! sawargstop) {
#line 421
      if ((int )*(*(argv + i) + 0) == 45) {
#line 421
        if ((int )*(*(argv + i) + 1) == 77) {
#line 422
          if ((int )*(*(argv + i) + 2) == 0) {
#line 423
            i ++;
          }
#line 424
          if (wp) {
#line 424
            if (! done_fwds) {
              {
#line 425
              add_arg((char *)"-L");
#line 426
              add_arg(wmbuf);
              }
#line 427
              if (! echop) {
                {
#line 428
                add_arg((char *)"-R");
#line 429
                add_arg(rmbuf);
                }
              }
#line 431
              done_fwds = 1;
            }
          }
#line 433
          goto __Cont;
        }
      }
    }
    {
#line 436
    strip_arg(*(argv + i), (char )'f', (char *)"M:V1246ab:c:e:fgi:kl:m:no:p:qstvw:xyACD:F:I:MKL:NO:PR:S:TVXY");
#line 437
    add_arg(*(argv + i));
    }
    __Cont: /* CIL Label */ 
#line 401
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 445
  if (writep) {
#line 446
    if (! echop) {
      {
#line 447
      sock = conn_listen(mhost, readp);
#line 449
      fcntl(sock, 2, 1);
      }
    } else {
#line 451
      sock = -2;
    }
  }
#line 454
  if (runasdaemon) {
    {
#line 455
    tmp___4 = daemon(0, 0);
    }
#line 455
    if (tmp___4 == -1) {
      {
#line 456
      tmp___2 = __errno_location();
#line 456
      tmp___3 = strerror(*tmp___2);
#line 456
      xerrlog(3, (char *)"run as daemon failed: %s", tmp___3);
      }
    }
#line 464
    gate_time = (double )0;
  }
#line 467
  if (pid_file_name) {
    {
#line 468
    pid_file = fopen((char const   */* __restrict  */)pid_file_name, (char const   */* __restrict  */)"w");
    }
#line 469
    if (! pid_file) {
      {
#line 470
      tmp___5 = __errno_location();
#line 470
      tmp___6 = strerror(*tmp___5);
#line 470
      xerrlog(3, (char *)"cannot open pid file \"%s\": %s", pid_file_name, tmp___6);
      }
    }
    {
#line 473
    pid_file_created = 1;
#line 474
    atexit(& unlink_pid_file);
#line 475
    tmp___9 = getpid();
#line 475
    tmp___10 = fprintf((FILE */* __restrict  */)pid_file, (char const   */* __restrict  */)"%d\n",
                       tmp___9);
    }
#line 475
    if (tmp___10 == 0) {
      {
#line 476
      tmp___7 = __errno_location();
#line 476
      tmp___8 = strerror(*tmp___7);
#line 476
      xerrlog(3, (char *)"write failed to pid file \"%s\": %s", pid_file_name, tmp___8);
      }
    }
    {
#line 478
    fflush(pid_file);
#line 479
    fclose(pid_file);
    }
  }
  {
#line 482
  ssh_run(sock, newav);
  }
#line 484
  if (sock >= 0) {
    {
#line 485
    shutdown(sock, 2);
#line 486
    close(sock);
    }
  }
#line 489
  if (logtype & 2) {
    {
#line 490
    closelog();
    }
  }
  {
#line 492
  exit(0);
  }
}
}
#line 503
void add_arg(char *s ) ;
#line 503 "/home/june/collector/temp/autossh-1.4c/autossh.c"
static size_t newamax  =    (size_t )16;
#line 498 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void add_arg(char *s ) 
{ 
  char *p ;
  size_t len ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 505
  len = strlen((char const   *)s);
  }
#line 506
  if (len == 0UL) {
#line 507
    return;
  }
#line 509
  if (! newav) {
    {
#line 510
    tmp = malloc(16UL * sizeof(char *));
#line 510
    newav = (char **)tmp;
    }
#line 511
    if (! newav) {
      {
#line 512
      tmp___0 = __errno_location();
#line 512
      tmp___1 = strerror(*tmp___0);
#line 512
      xerrlog(3, (char *)"malloc: %s", tmp___1);
      }
    }
  } else
#line 513
  if ((size_t )newac >= newamax - 1UL) {
    {
#line 514
    newamax *= 2UL;
#line 515
    tmp___2 = realloc((void *)newav, newamax * sizeof(char *));
#line 515
    newav = (char **)tmp___2;
    }
#line 516
    if (! newav) {
      {
#line 517
      tmp___3 = __errno_location();
#line 517
      tmp___4 = strerror(*tmp___3);
#line 517
      xerrlog(3, (char *)"realloc: %s", tmp___4);
      }
    }
  }
  {
#line 519
  tmp___5 = malloc(len + 1UL);
#line 519
  p = (char *)tmp___5;
  }
#line 520
  if (! p) {
    {
#line 520
    tmp___6 = __errno_location();
#line 520
    tmp___7 = strerror(*tmp___6);
#line 520
    xerrlog(3, (char *)"malloc: %s", tmp___7);
    }
  }
  {
#line 521
  memmove((void *)p, (void const   *)s, len);
#line 522
  *(p + len) = (char )'\000';
#line 523
  tmp___8 = newac;
#line 523
  newac ++;
#line 523
  *(newav + tmp___8) = p;
#line 524
  *(newav + newac) = (char *)((void *)0);
  }
#line 526
  return;
}
}
#line 535 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void strip_arg(char *arg , char ch , char *opts ) 
{ 
  char *f ;
  char *o ;
  size_t len ;

  {
#line 542
  if ((int )*(arg + 0) == 45) {
#line 542
    if ((int )*(arg + 1) != 0) {
      {
#line 543
      len = strlen((char const   *)arg);
#line 543
      f = arg;
      }
      {
#line 543
      while (1) {
        while_continue: /* CIL Label */ ;
#line 543
        if (! ((int )*f != 0)) {
#line 543
          goto while_break;
        }
        {
#line 553
        o = strchr((char const   *)opts, (int )*f);
        }
#line 553
        if ((unsigned long )o != (unsigned long )((void *)0)) {
#line 554
          if ((int )*(o + 1) == 58) {
#line 555
            return;
          }
        }
#line 557
        if ((int )*f == (int )ch) {
          {
#line 558
          memmove((void *)f, (void const   *)(f + 1), len);
          }
        }
#line 543
        f ++;
#line 543
        len --;
      }
      while_break: /* CIL Label */ ;
      }
#line 561
      if ((int )*(arg + 1) == 0) {
#line 562
        *(arg + 0) = (char )'\000';
      }
    }
  }
#line 565
  return;
}
}
#line 571 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void get_env_args(void) 
{ 
  char *s ;
  char *t ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  unsigned long tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 577
  s = getenv("AUTOSSH_PATH");
  }
#line 577
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 578
    ssh_path = s;
  }
  {
#line 580
  s = getenv("AUTOSSH_DEBUG");
  }
#line 580
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 582
    syslog_perror = 32;
#line 588
    loglevel = 7;
  } else {
    {
#line 589
    s = getenv("AUTOSSH_LOGLEVEL");
    }
#line 589
    if ((unsigned long )s != (unsigned long )((void *)0)) {
      {
#line 590
      tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                    0);
#line 590
      loglevel = (int )tmp;
      }
#line 591
      if ((int )*s == 0) {
        {
#line 593
        xerrlog(3, (char *)"invalid log level \"%s\"", s);
        }
      } else
#line 591
      if ((int )*t != 0) {
        {
#line 593
        xerrlog(3, (char *)"invalid log level \"%s\"", s);
        }
      } else
#line 591
      if (loglevel < 0) {
        {
#line 593
        xerrlog(3, (char *)"invalid log level \"%s\"", s);
        }
      } else
#line 591
      if (loglevel > 7) {
        {
#line 593
        xerrlog(3, (char *)"invalid log level \"%s\"", s);
        }
      }
    }
  }
  {
#line 596
  s = getenv("AUTOSSH_FIRST_POLL");
  }
#line 596
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 597
    tmp___0 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                      0);
#line 597
    first_poll_time = (int )tmp___0;
    }
#line 598
    if ((int )*s == 0) {
      {
#line 599
      xerrlog(3, (char *)"invalid first poll time \"%s\"", s);
      }
    } else
#line 598
    if (first_poll_time == 0) {
      {
#line 599
      xerrlog(3, (char *)"invalid first poll time \"%s\"", s);
      }
    } else
#line 598
    if ((int )*t != 0) {
      {
#line 599
      xerrlog(3, (char *)"invalid first poll time \"%s\"", s);
      }
    }
#line 601
    if (first_poll_time <= 0) {
#line 602
      first_poll_time = 600;
    }
  }
  {
#line 605
  s = getenv("AUTOSSH_POLL");
  }
#line 605
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 606
    tmp___1 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                      0);
#line 606
    poll_time = (int )tmp___1;
    }
#line 607
    if ((int )*s == 0) {
      {
#line 608
      xerrlog(3, (char *)"invalid poll time \"%s\"", s);
      }
    } else
#line 607
    if (poll_time == 0) {
      {
#line 608
      xerrlog(3, (char *)"invalid poll time \"%s\"", s);
      }
    } else
#line 607
    if ((int )*t != 0) {
      {
#line 608
      xerrlog(3, (char *)"invalid poll time \"%s\"", s);
      }
    }
#line 610
    if (poll_time <= 0) {
#line 611
      poll_time = 600;
    }
  }
  {
#line 614
  s = getenv("AUTOSSH_GATETIME");
  }
#line 614
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 615
    tmp___2 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                     0);
#line 615
    gate_time = (double )tmp___2;
    }
#line 616
    if ((int )*s == 0) {
      {
#line 617
      xerrlog(3, (char *)"invalid gate time \"%s\"", s);
      }
    } else
#line 616
    if (gate_time < (double )0) {
      {
#line 617
      xerrlog(3, (char *)"invalid gate time \"%s\"", s);
      }
    } else
#line 616
    if ((int )*t != 0) {
      {
#line 617
      xerrlog(3, (char *)"invalid gate time \"%s\"", s);
      }
    }
  }
  {
#line 620
  s = getenv("AUTOSSH_MAXSTART");
  }
#line 620
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 621
    tmp___3 = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                     0);
#line 621
    max_start = (int )tmp___3;
    }
#line 622
    if ((int )*s == 0) {
      {
#line 623
      xerrlog(3, (char *)"invalid max start number \"%s\"", s);
      }
    } else
#line 622
    if (max_start < 0) {
      {
#line 623
      xerrlog(3, (char *)"invalid max start number \"%s\"", s);
      }
    } else
#line 622
    if ((int )*t != 0) {
      {
#line 623
      xerrlog(3, (char *)"invalid max start number \"%s\"", s);
      }
    }
  }
  {
#line 626
  s = getenv("AUTOSSH_MESSAGE");
  }
#line 626
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 627
    if ((int )*s != 0) {
#line 628
      echo_message = s;
    }
    {
#line 629
    tmp___4 = strlen((char const   *)echo_message);
    }
#line 629
    if (tmp___4 > 64UL) {
      {
#line 630
      xerrlog(3, (char *)"echo message may only be %d bytes long", 64);
      }
    }
  }
  {
#line 635
  s = getenv("AUTOSSH_PORT");
  }
#line 635
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 636
    if ((int )*s != 0) {
#line 637
      env_port = s;
    }
  }
  {
#line 639
  s = getenv("AUTOSSH_MAXLIFETIME");
  }
#line 639
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 640
    tmp___5 = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)(& t),
                      0);
#line 640
    max_lifetime = (double )tmp___5;
    }
#line 641
    if ((int )*s == 0) {
      {
#line 642
      xerrlog(3, (char *)"invalid max lifetime \"%s\"", s);
      }
    } else
#line 641
    if ((int )*t != 0) {
      {
#line 642
      xerrlog(3, (char *)"invalid max lifetime \"%s\"", s);
      }
    }
#line 645
    if (max_lifetime <= (double )0) {
#line 646
      max_lifetime = (double )0;
    } else {
#line 648
      if ((double )poll_time > max_lifetime) {
        {
#line 649
        errlog(6, (char *)"poll time is greater then lifetime, dropping poll time to %.0f",
               max_lifetime);
#line 652
        poll_time = (int )max_lifetime;
        }
      }
#line 655
      if ((double )first_poll_time > max_lifetime) {
        {
#line 656
        errlog(6, (char *)"first poll time is greater then lifetime, dropping first poll time to %.0f",
               max_lifetime);
#line 659
        first_poll_time = (int )max_lifetime;
        }
      }
      {
#line 662
      time(& pid_start_time);
      }
    }
  }
  {
#line 666
  s = getenv("AUTOSSH_PIDFILE");
  }
#line 666
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 667
    if ((int )*s != 0) {
#line 668
      pid_file_name = s;
    }
  }
  {
#line 684
  s = getenv("AUTOSSH_LOGFILE");
  }
#line 684
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 685
    flog = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"a");
    }
#line 686
    if (! flog) {
      {
#line 687
      tmp___6 = __errno_location();
#line 687
      tmp___7 = strerror(*tmp___6);
#line 687
      xerrlog(3, (char *)"%s: %s", s, tmp___7);
      }
    }
#line 688
    logtype = 1;
  }
#line 691
  return;
}
}
#line 697 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void ssh_run(int sock , char **av ) 
{ 
  struct sigaction act ;
  struct timeval tv ;
  __pid_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 703
  act.__sigaction_handler.sa_handler = & sig_catch;
#line 704
  sigemptyset(& act.sa_mask);
#line 705
  act.sa_flags = 0;
#line 707
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 708
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 709
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 710
  sigaction(10, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 711
  sigaction(12, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 712
  sigaction(17, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 714
  act.sa_flags |= 268435456;
#line 715
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 721
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 722
  tmp = getpid();
#line 722
  srandom((unsigned int )(((long )tmp ^ tv.tv_usec) ^ tv.tv_sec));
  }
  {
#line 724
  while (1) {
    while_continue: /* CIL Label */ ;
#line 724
    if (! (max_start < 0)) {
#line 724
      if (! (start_count < max_start)) {
#line 724
        goto while_break;
      }
    }
    {
#line 725
    tmp___0 = exceeded_lifetime();
    }
#line 725
    if (tmp___0) {
#line 726
      return;
    }
    {
#line 727
    restart_ssh = (sig_atomic_t volatile   )0;
#line 728
    start_count ++;
#line 729
    grace_time(start_time);
#line 730
    time(& start_time);
    }
#line 731
    if (max_start < 0) {
      {
#line 732
      errlog(6, (char *)"starting ssh (count %d)", start_count);
      }
    } else {
      {
#line 735
      errlog(6, (char *)"starting ssh (count %d of %d)", start_count, max_start);
      }
    }
    {
#line 737
    cchild = fork();
    }
    {
#line 739
    if (cchild == 0) {
#line 739
      goto case_0;
    }
#line 747
    if (cchild == -1) {
#line 747
      goto case_neg_1;
    }
#line 751
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 740
    errlog(7, (char *)"execing %s", *(av + 0));
#line 741
    execvp((char const   *)*(av + 0), (char * const  *)av);
#line 742
    tmp___1 = __errno_location();
#line 742
    tmp___2 = strerror(*tmp___1);
#line 742
    xerrlog(3, (char *)"%s: %s", *(av + 0), tmp___2);
#line 744
    tmp___3 = getppid();
#line 744
    kill(15, tmp___3);
#line 745
    exit(1);
    }
#line 746
    goto switch_break;
    case_neg_1: /* CIL Label */ 
    {
#line 748
    cchild = 0;
#line 749
    tmp___4 = __errno_location();
#line 749
    tmp___5 = strerror(*tmp___4);
#line 749
    xerrlog(3, (char *)"fork: %s", tmp___5);
    }
#line 750
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 752
    errlog(6, (char *)"ssh child pid is %d", cchild);
#line 753
    tmp___6 = ssh_watch(sock);
    }
#line 753
    if (tmp___6 == 2) {
#line 754
      return;
    }
#line 755
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 759
  errlog(6, (char *)"max start count reached; exiting");
  }
#line 760
  return;
}
}
#line 772 "/home/june/collector/temp/autossh-1.4c/autossh.c"
static int secs_left  ;
#line 767 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int ssh_watch(int sock ) 
{ 
  int r ;
  int val ;
  int my_poll_time ;
  time_t now ;
  double secs_to_shutdown ;
  unsigned int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 773
  my_poll_time = first_poll_time;
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
#line 783
    if (restart_ssh) {
      {
#line 784
      errlog(6, (char *)"signalled to kill and restart ssh");
#line 785
      ssh_kill();
      }
#line 786
      return (1);
    }
    {
#line 788
    val = __sigsetjmp((struct __jmp_buf_tag *)(jumpbuf), 1);
    }
#line 788
    if (val == 0) {
      {
#line 790
      errlog(7, (char *)"check on child %d", cchild);
#line 793
      r = ssh_wait(1);
      }
#line 794
      if (r != 0) {
        {
#line 795
        errlog(7, (char *)"expired child, returning %d", r);
        }
#line 797
        return (r);
      }
      {
#line 800
      tmp = alarm(0U);
#line 800
      secs_left = (int )tmp;
      }
#line 801
      if (secs_left == 0) {
#line 802
        secs_left = my_poll_time;
      }
#line 804
      my_poll_time = poll_time;
#line 806
      if (max_lifetime != (double )0) {
        {
#line 807
        time(& now);
#line 808
        tmp___0 = difftime(now, pid_start_time);
#line 808
        secs_to_shutdown = max_lifetime - tmp___0;
        }
#line 809
        if (secs_to_shutdown < (double )poll_time) {
#line 810
          secs_left = (int )secs_to_shutdown;
        }
      }
      {
#line 813
      errlog(7, (char *)"set alarm for %d secs", secs_left);
#line 816
      alarm((unsigned int )secs_left);
#line 817
      dolongjmp = (sig_atomic_t volatile   )1;
#line 818
      pause();
      }
    } else {
      {
#line 826
      if (val == 6) {
#line 826
        goto case_6;
      }
#line 826
      if (val == 3) {
#line 826
        goto case_6;
      }
#line 826
      if (val == 15) {
#line 826
        goto case_6;
      }
#line 826
      if (val == 2) {
#line 826
        goto case_6;
      }
#line 832
      if (val == 14) {
#line 832
        goto case_14;
      }
#line 859
      goto switch_default;
      case_6: /* CIL Label */ 
      case_3: /* CIL Label */ 
      case_15: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 827
      errlog(6, (char *)"received signal to exit (%d)", val);
#line 829
      ssh_kill();
      }
#line 830
      return (2);
#line 831
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 833
      tmp___1 = exceeded_lifetime();
      }
#line 833
      if (tmp___1) {
        {
#line 834
        ssh_kill();
        }
#line 835
        return (2);
      }
#line 838
      if (writep) {
#line 838
        if (sock != -1) {
          {
#line 838
          tmp___2 = conn_test(sock, mhost, writep);
          }
#line 838
          if (! tmp___2) {
            {
#line 840
            errlog(6, (char *)"port down, restarting ssh");
#line 842
            ssh_kill();
            }
#line 843
            return (1);
          }
        }
      }
#line 858
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 860
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 870 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int exceeded_lifetime(void) 
{ 
  time_t now ;
  double tmp ;

  {
#line 875
  if (max_lifetime > (double )0) {
    {
#line 876
    time(& now);
#line 877
    tmp = difftime(now, pid_start_time);
    }
#line 877
    if (tmp >= max_lifetime) {
      {
#line 878
      errlog(6, (char *)"exceeded maximum time to live, shutting down");
      }
#line 880
      return (1);
    }
  }
#line 884
  return (0);
}
}
#line 919 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int ssh_wait(int options ) 
{ 
  int status ;
  int evalue ;
  time_t now ;
  union __anonunion_59 __constr_expr_0 ;
  union __anonunion_60 __constr_expr_1 ;
  union __anonunion_61 __constr_expr_2 ;
  union __anonunion_62 __constr_expr_3 ;
  double tmp ;
  union __anonunion_63 __constr_expr_4 ;
  union __anonunion_64 __constr_expr_5 ;
  __pid_t tmp___0 ;

  {
  {
#line 926
  tmp___0 = waitpid(cchild, & status, options);
  }
#line 926
  if (tmp___0 > 0) {
#line 927
    __constr_expr_5.__in = status;
#line 927
    if ((int )((signed char )((__constr_expr_5.__i & 127) + 1)) >> 1 > 0) {
#line 928
      __constr_expr_0.__in = status;
      {
#line 931
      if ((__constr_expr_0.__i & 127) == 9) {
#line 931
        goto case_9;
      }
#line 931
      if ((__constr_expr_0.__i & 127) == 15) {
#line 931
        goto case_9;
      }
#line 931
      if ((__constr_expr_0.__i & 127) == 2) {
#line 931
        goto case_9;
      }
#line 938
      goto switch_default;
      case_9: /* CIL Label */ 
      case_15: /* CIL Label */ 
      case_2: /* CIL Label */ 
      {
#line 933
      __constr_expr_1.__in = status;
#line 933
      errlog(6, (char *)"ssh exited on signal %d; parent exiting", __constr_expr_1.__i & 127);
      }
#line 936
      return (2);
#line 937
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 940
      __constr_expr_2.__in = status;
#line 940
      errlog(6, (char *)"ssh exited on signal %d, restarting ssh", __constr_expr_2.__i & 127);
      }
#line 943
      return (1);
#line 944
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 946
      __constr_expr_4.__in = status;
#line 946
      if ((__constr_expr_4.__i & 127) == 0) {
#line 947
        __constr_expr_3.__in = status;
#line 947
        evalue = (__constr_expr_3.__i & 65280) >> 8;
#line 948
        if (start_count == 1) {
#line 948
          if (gate_time != (double )0) {
            {
#line 952
            time(& now);
#line 953
            tmp = difftime(now, start_time);
            }
#line 953
            if (tmp <= gate_time) {
              {
#line 954
              errlog(3, (char *)"ssh exited prematurely with status %d; %s exiting",
                     evalue, __progname);
              }
#line 958
              return (2);
            }
          }
        }
        {
#line 962
        if (evalue == 255) {
#line 962
          goto case_255;
        }
#line 979
        if (evalue == 1) {
#line 979
          goto case_1;
        }
#line 1002
        goto switch_default___0;
        case_255: /* CIL Label */ 
        {
#line 973
        errlog(6, (char *)"ssh exited with error status %d; restarting ssh", evalue);
        }
#line 977
        return (1);
#line 978
        goto switch_break___0;
        case_1: /* CIL Label */ 
#line 988
        if (start_count > 1) {
          {
#line 989
          errlog(6, (char *)"ssh exited with error status %d; restarting ssh", evalue);
          }
#line 993
          return (1);
        } else
#line 988
        if (gate_time == (double )0) {
          {
#line 989
          errlog(6, (char *)"ssh exited with error status %d; restarting ssh", evalue);
          }
#line 993
          return (1);
        }
        switch_default___0: /* CIL Label */ 
        {
#line 1003
        errlog(6, (char *)"ssh exited with status %d; %s exiting", evalue, __progname);
        }
#line 1006
        return (2);
#line 1007
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 1013
  return (0);
}
}
#line 1021 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void ssh_kill(void) 
{ 
  int w ;
  int status ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 1027
  if (cchild) {
    {
#line 1029
    kill(cchild, 15);
    }
    {
#line 1033
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1034
      tmp = __errno_location();
#line 1034
      *tmp = 0;
#line 1035
      w = waitpid(cchild, & status, 0);
      }
#line 1033
      if (w < 0) {
        {
#line 1033
        tmp___0 = __errno_location();
        }
#line 1033
        if (! (*tmp___0 == 4)) {
#line 1033
          goto while_break;
        }
      } else {
#line 1033
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1038
    if (w <= 0) {
      {
#line 1039
      tmp___1 = __errno_location();
#line 1039
      tmp___2 = strerror(*tmp___1);
#line 1039
      errlog(3, (char *)"waitpid() not successful: %s", tmp___2);
      }
    }
  }
#line 1044
  return;
}
}
#line 1065 "/home/june/collector/temp/autossh-1.4c/autossh.c"
static int tries  ;
#line 1058 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void grace_time(time_t last_start ) 
{ 
  int n ;
  double t ;
  int interval ;
  time_t now ;
  double min_time ;
  double tmp ;

  {
#line 1074
  min_time = (double )(poll_time / 10);
#line 1075
  if (min_time < (double )10) {
#line 1075
    min_time = (double )10;
  }
  {
#line 1077
  time(& now);
#line 1078
  tmp = difftime(now, last_start);
  }
#line 1078
  if (tmp >= min_time) {
#line 1079
    tries = 0;
  } else {
#line 1081
    tries ++;
  }
  {
#line 1083
  errlog(7, (char *)"checking for grace period, tries = %d", tries);
  }
#line 1086
  if (tries > 5) {
#line 1087
    t = (double )(tries - 5);
#line 1088
    n = (int )(((double )poll_time / 100.0) * (t * (t / (double )3)));
#line 1089
    if (n > poll_time) {
#line 1089
      interval = poll_time;
    } else {
#line 1089
      interval = n;
    }
#line 1090
    if (interval) {
      {
#line 1091
      errlog(7, (char *)"sleeping for grace time %d secs", interval);
#line 1093
      sleep((unsigned int )interval);
      }
    }
  }
#line 1096
  return;
}
}
#line 1102 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void sig_catch(int sig ) 
{ 


  {
#line 1105
  if (sig == 10) {
#line 1106
    restart_ssh = (sig_atomic_t volatile   )1;
  }
#line 1107
  if (dolongjmp) {
    {
#line 1108
    dolongjmp = (sig_atomic_t volatile   )0;
#line 1109
    siglongjmp((struct __jmp_buf_tag *)(jumpbuf), sig);
    }
  }
#line 1111
  return;
}
}
#line 1118 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int conn_test(int sock , char *host , char *write_port ) 
{ 
  int rval ;
  int tries___0 ;
  int send_error ;
  struct pollfd pfd[2] ;
  int ntopoll ;
  int rd ;
  int wd ;
  long id ;
  struct utsname uts ;
  char wbuf[(64UL + sizeof(uts.nodename)) + 64UL] ;
  char rbuf[sizeof(wbuf)] ;
  __pid_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1133
  wd = -1;
#line 1134
  rd = -1;
#line 1135
  rval = 0;
#line 1136
  tries___0 = 0;
#line 1138
  uts.nodename[0] = (char )'\000';
#line 1139
  uname(& uts);
#line 1140
  id = random();
  }
#line 1142
  if (dolongjmp != (sig_atomic_t volatile   )0) {
    {
#line 1143
    errlog(3, (char *)"conn_test(): error: dolongjmp != 0");
    }
  }
  {
#line 1146
  wd = conn_remote(host, write_port);
  }
#line 1146
  if (wd == -1) {
#line 1147
    return (0);
  }
#line 1149
  pfd[1].fd = wd;
#line 1150
  pfd[1].events = (short)4;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    tmp___5 = tries___0;
#line 1152
    tries___0 ++;
#line 1152
    if (! (tmp___5 < 3)) {
#line 1152
      goto while_break;
    }
#line 1154
    if (tries___0 >= 3) {
      {
#line 1155
      errlog(7, (char *)"tried connection %d times and failed", tries___0);
      }
#line 1158
      goto while_break;
    }
#line 1162
    if (sock != -2) {
#line 1162
      if (rd != -1) {
        {
#line 1163
        shutdown(rd, 2);
#line 1164
        close(rd);
#line 1165
        rd = -1;
        }
      }
    }
    {
#line 1175
    tmp = getpid();
#line 1175
    tmp___0 = snprintf((char */* __restrict  */)(wbuf), sizeof(wbuf), (char const   */* __restrict  */)"%s %s %d %ld %s\r\n",
                       uts.nodename, __progname, tmp, id, echo_message);
    }
#line 1175
    if ((unsigned long )tmp___0 >= sizeof(wbuf)) {
      {
#line 1178
      xerrlog(3, (char *)"conn_test: buffer overflow");
      }
    }
    {
#line 1179
    memset((void *)(rbuf), '\000', sizeof(rbuf));
    }
#line 1181
    if (sock != -2) {
      {
#line 1187
      rd = conn_poll_for_accept(sock, pfd);
      }
#line 1188
      if (rd < 0) {
#line 1189
        goto while_break;
      }
#line 1190
      pfd[0].fd = rd;
#line 1191
      pfd[0].events = (short)1;
#line 1192
      ntopoll = 2;
    } else {
#line 1199
      pfd[0].fd = wd;
#line 1200
      pfd[0].events = (short)5;
#line 1201
      ntopoll = 1;
    }
    {
#line 1204
    tmp___1 = strlen((char const   *)(wbuf));
#line 1204
    send_error = conn_send_and_receive(rbuf, wbuf, tmp___1, pfd, ntopoll);
    }
#line 1206
    if (send_error == 0) {
      {
#line 1208
      tmp___2 = strcmp((char const   *)(rbuf), (char const   *)(wbuf));
      }
#line 1208
      if (tmp___2 == 0) {
        {
#line 1209
        errlog(7, (char *)"connection ok");
#line 1210
        rval = 1;
        }
#line 1211
        goto while_break;
      } else {
        {
#line 1213
        errlog(7, (char *)"not what I sent: \"%s\" : \"%s\"", wbuf, rbuf);
        }
      }
    } else
#line 1218
    if (send_error == 1) {
      {
#line 1219
      errlog(7, (char *)"timeout on io poll, looping to accept again");
      }
    } else {
      {
#line 1222
      tmp___3 = __errno_location();
#line 1222
      tmp___4 = strerror(*tmp___3);
#line 1222
      errlog(7, (char *)"error on poll: %s", tmp___4);
      }
#line 1224
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1228
  shutdown(wd, 2);
#line 1229
  close(wd);
  }
#line 1230
  if (sock != -2) {
    {
#line 1231
    shutdown(rd, 2);
#line 1232
    close(rd);
    }
  }
#line 1235
  return (rval);
}
}
#line 1242 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int conn_poll_for_accept(int sock , struct pollfd *pfd ) 
{ 
  int rd ;
  int timeo_polla ;
  struct sockaddr cliaddr ;
  socklen_t len ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 1250
  rd = 0;
#line 1251
  timeo_polla = net_timeout;
#line 1252
  len = (socklen_t )sizeof(struct sockaddr );
#line 1257
  (pfd + 0)->fd = sock;
#line 1258
  (pfd + 0)->events = (short)1;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1261
    tmp = poll(pfd, (nfds_t )1, timeo_polla);
    }
    {
#line 1262
    if (tmp == 0) {
#line 1262
      goto case_0;
    }
#line 1266
    if (tmp == -1) {
#line 1266
      goto case_neg_1;
    }
#line 1271
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 1263
    errlog(6, (char *)"timeout polling to accept read connection");
    }
#line 1265
    return (-1);
    case_neg_1: /* CIL Label */ 
    {
#line 1267
    tmp___0 = __errno_location();
#line 1267
    tmp___1 = strerror(*tmp___0);
#line 1267
    errlog(3, (char *)"error polling to accept read connection: %s", tmp___1);
    }
#line 1270
    return (-1);
    switch_default: /* CIL Label */ 
#line 1272
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1275
    if ((int )(pfd + 0)->revents & 1) {
      {
#line 1276
      rd = accept(sock, (struct sockaddr */* __restrict  */)(& cliaddr), (socklen_t */* __restrict  */)(& len));
      }
#line 1277
      if (rd == -1) {
        {
#line 1278
        tmp___2 = __errno_location();
#line 1278
        tmp___3 = strerror(*tmp___2);
#line 1278
        errlog(3, (char *)"error accepting read connection: %s", tmp___3);
        }
#line 1281
        return (-1);
      }
#line 1283
      goto while_break;
    }
#line 1285
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1288
  return (rd);
}
}
#line 1297 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int conn_send_and_receive(char *rp , char *wp , size_t len , struct pollfd *pfd ,
                          int ntopoll ) 
{ 
  ssize_t nwrite ;
  ssize_t nread ;
  size_t rleft ;
  size_t wleft ;
  int timeo_pollio ;
  int ird ;
  int iwr ;
  int loops ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 1305
  loops = 0;
#line 1307
  timeo_pollio = net_timeout;
#line 1308
  wleft = len;
#line 1308
  rleft = wleft;
#line 1314
  if (ntopoll == 2) {
#line 1315
    ird = 0;
#line 1316
    iwr = 1;
  } else {
#line 1318
    ird = 0;
#line 1318
    iwr = ird;
  }
  {
#line 1326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1326
    if (! (rleft > 0UL)) {
#line 1326
      goto while_break;
    }
    {
#line 1328
    tmp = poll(pfd, (nfds_t )ntopoll, timeo_pollio);
    }
    {
#line 1329
    if (tmp == 0) {
#line 1329
      goto case_0;
    }
#line 1332
    if (tmp == -1) {
#line 1332
      goto case_neg_1;
    }
#line 1335
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1330
    return (1);
#line 1331
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 1333
    return (-1);
#line 1334
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1336
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1339
    if (wleft) {
#line 1339
      if ((int )(pfd + iwr)->revents & 4) {
        {
#line 1340
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1340
          if (! (wleft > 0UL)) {
#line 1340
            goto while_break___0;
          }
          {
#line 1341
          nwrite = write((pfd + iwr)->fd, (void const   *)wp, wleft);
          }
#line 1342
          if (nwrite == 0L) {
#line 1343
            wleft = (size_t )0;
#line 1344
            goto while_break___0;
          } else
#line 1345
          if (nwrite == -1L) {
            {
#line 1346
            tmp___0 = __errno_location();
            }
#line 1346
            if (*tmp___0 == 4) {
#line 1347
              goto while_break___0;
            } else {
              {
#line 1346
              tmp___1 = __errno_location();
              }
#line 1346
              if (*tmp___1 == 11) {
#line 1347
                goto while_break___0;
              } else {
#line 1349
                return (-1);
              }
            }
          }
#line 1351
          wleft -= (size_t )nwrite;
#line 1352
          wp += nwrite;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1355
        if (wleft == 0UL) {
#line 1356
          ntopoll = 1;
#line 1362
          if (iwr == ird) {
#line 1363
            (pfd + ird)->events = (short)1;
          }
        }
      }
    }
#line 1367
    if ((int )(pfd + ird)->revents & 1) {
#line 1367
      goto _L;
    } else
#line 1367
    if ((int )(pfd + ird)->revents & 16) {
      _L: /* CIL Label */ 
      {
#line 1368
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1368
        if (! (rleft > 0UL)) {
#line 1368
          goto while_break___1;
        }
        {
#line 1369
        nread = read((pfd + ird)->fd, (void *)rp, rleft);
        }
#line 1370
        if (nread == 0L) {
#line 1371
          rleft = (size_t )0;
#line 1372
          goto while_break___1;
        } else
#line 1373
        if (nread == -1L) {
          {
#line 1374
          tmp___2 = __errno_location();
          }
#line 1374
          if (*tmp___2 == 4) {
#line 1375
            goto while_break___1;
          } else {
            {
#line 1374
            tmp___3 = __errno_location();
            }
#line 1374
            if (*tmp___3 == 11) {
#line 1375
              goto while_break___1;
            } else {
#line 1377
              return (-1);
            }
          }
        }
#line 1379
        rleft -= (size_t )nread;
#line 1380
        rp += nread;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1389
    tmp___4 = loops;
#line 1389
    loops ++;
#line 1389
    if (tmp___4 > 5) {
      {
#line 1390
      sleep(1U);
      }
#line 1391
      if (loops > 10) {
        {
#line 1392
        errlog(6, (char *)"too many loops without data");
        }
#line 1394
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1399
  return (0);
}
}
#line 1488 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void conn_addr(char *host , char *port , struct addrinfo **resp ) 
{ 
  int family ;
  struct addrinfo hints ;
  int error ;
  char const   *tmp ;

  {
  {
#line 1491
  family = 2;
#line 1495
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 1496
  hints.ai_family = family;
#line 1497
  hints.ai_socktype = 1;
#line 1498
  hints.ai_protocol = 6;
#line 1501
  hints.ai_flags |= 1;
  }
#line 1507
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1507
    if (hints.ai_family == 0) {
#line 1508
      hints.ai_family = 2;
    }
  }
  {
#line 1510
  error = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)port,
                      (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)resp);
  }
#line 1510
  if (error) {
    {
#line 1511
    tmp = gai_strerror(error);
#line 1511
    xerrlog(3, (char *)"%s", tmp);
    }
  }
#line 1513
  return;
}
}
#line 1523 "/home/june/collector/temp/autossh-1.4c/autossh.c"
static struct addrinfo *res  ;
#line 1519 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int conn_remote(char *host , char *port ) 
{ 
  int sock ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1526
  if (! res) {
    {
#line 1527
    conn_addr(host, port, & res);
    }
  }
  {
#line 1529
  sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  }
#line 1529
  if (sock == -1) {
    {
#line 1531
    tmp = __errno_location();
#line 1531
    tmp___0 = strerror(*tmp);
#line 1531
    xerrlog(3, (char *)"socket: %s", tmp___0);
    }
  }
  {
#line 1533
  tmp___3 = connect(sock, (struct sockaddr  const  *)res->ai_addr, res->ai_addrlen);
  }
#line 1533
  if (tmp___3 == -1) {
    {
#line 1534
    tmp___1 = __errno_location();
#line 1534
    tmp___2 = strerror(*tmp___1);
#line 1534
    errlog(6, (char *)"%s:%s: %s", host, port, tmp___2);
#line 1535
    close(sock);
    }
#line 1536
    return (-1);
  }
#line 1539
  return (sock);
}
}
#line 1546 "/home/june/collector/temp/autossh-1.4c/autossh.c"
int conn_listen(char *host , char *port ) 
{ 
  int sock ;
  struct addrinfo *res___0 ;
  int on ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1551
  on = 1;
#line 1558
  conn_addr(host, port, & res___0);
#line 1560
  sock = socket(res___0->ai_family, res___0->ai_socktype, res___0->ai_protocol);
  }
#line 1560
  if (sock == -1) {
    {
#line 1562
    tmp = __errno_location();
#line 1562
    tmp___0 = strerror(*tmp);
#line 1562
    xerrlog(3, (char *)"socket: %s", tmp___0);
    }
  }
  {
#line 1564
  tmp___3 = setsockopt(sock, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 1564
  if (tmp___3 != 0) {
    {
#line 1566
    tmp___1 = __errno_location();
#line 1566
    tmp___2 = strerror(*tmp___1);
#line 1566
    xerrlog(3, (char *)"setsockopt: %s", tmp___2);
    }
  }
  {
#line 1569
  tmp___6 = bind(sock, (struct sockaddr  const  *)res___0->ai_addr, res___0->ai_addrlen);
  }
#line 1569
  if (tmp___6 == -1) {
    {
#line 1571
    tmp___4 = __errno_location();
#line 1571
    tmp___5 = strerror(*tmp___4);
#line 1571
    xerrlog(3, (char *)"bind on %s:%s: %s", host, port, tmp___5);
    }
  }
  {
#line 1574
  tmp___9 = listen(sock, 1);
  }
#line 1574
  if (tmp___9 < 0) {
    {
#line 1575
    tmp___7 = __errno_location();
#line 1575
    tmp___8 = strerror(*tmp___7);
#line 1575
    xerrlog(3, (char *)"listen: %s", tmp___8);
    }
  }
  {
#line 1577
  freeaddrinfo(res___0);
  }
#line 1579
  return (sock);
}
}
#line 1588 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void unlink_pid_file(void) 
{ 


  {
#line 1591
  if (pid_file_created) {
    {
#line 1592
    unlink((char const   *)pid_file_name);
    }
  }
#line 1593
  pid_file_created = 0;
#line 1594
  return;
}
}
#line 1602 "/home/june/collector/temp/autossh-1.4c/autossh.c"
static char timestr___0[32]  ;
#line 1599 "/home/june/collector/temp/autossh-1.4c/autossh.c"
char *timestr(void) 
{ 
  time_t now ;
  struct tm *tm ;

  {
  {
#line 1606
  time(& now);
#line 1607
  tm = localtime((time_t const   *)(& now));
#line 1608
  strftime((char */* __restrict  */)(timestr___0), sizeof(timestr___0), (char const   */* __restrict  */)"%Y/%m/%d %H:%M:%S",
           (struct tm  const  */* __restrict  */)tm);
  }
#line 1611
  return (timestr___0);
}
}
#line 1617 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void ( /* format attribute */  errlog)(int level , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1622
  __builtin_va_start(ap, fmt);
#line 1623
  doerrlog(level, fmt, ap);
#line 1624
  __builtin_va_end(ap);
  }
#line 1625
  return;
}
}
#line 1630 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void ( /* format attribute */  xerrlog)(int level , char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 1635
  __builtin_va_start(ap, fmt);
#line 1636
  doerrlog(level, fmt, ap);
#line 1637
  __builtin_va_end(ap);
#line 1639
  ssh_kill();
#line 1640
  unlink_pid_file();
#line 1641
  _exit(1);
  }
}
}
#line 1650 "/home/june/collector/temp/autossh-1.4c/autossh.c"
void doerrlog(int level , char *fmt , va_list ap ) 
{ 
  FILE *fl ;
  __pid_t tmp ;
  char *tmp___0 ;

  {
#line 1658
  fl = flog;
#line 1660
  if (loglevel >= level) {
#line 1661
    if (logtype & 2) {
      {
#line 1666
      vsyslog(level, (char const   *)fmt, ap);
      }
    } else
#line 1668
    if (! fl) {
#line 1674
      fl = stderr;
    }
#line 1676
    if (logtype & 1) {
#line 1676
      if (fl) {
        {
#line 1677
        tmp = getpid();
#line 1677
        tmp___0 = timestr();
#line 1677
        fprintf((FILE */* __restrict  */)fl, (char const   */* __restrict  */)"%s %s[%d]: ",
                tmp___0, __progname, tmp);
#line 1680
        vfprintf((FILE */* __restrict  */)fl, (char const   */* __restrict  */)fmt,
                 ap);
#line 1681
        fprintf((FILE */* __restrict  */)fl, (char const   */* __restrict  */)"\n");
#line 1682
        fflush(fl);
        }
      }
    }
  }
#line 1685
  return;
}
}
