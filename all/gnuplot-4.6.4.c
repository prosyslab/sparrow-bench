/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
struct __anonstruct_range_58 {
   float xmin ;
   float xmax ;
   float ymin ;
   float ymax ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
typedef struct __anonstruct_range_58 range;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_19 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_19 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_20 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_20 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_21 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_21 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_22 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_22 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_23 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_23 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_24 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_24 XSetWindowAttributes;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_25 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_25 XWindowAttributes;
#line 372 "/usr/include/X11/Xlib.h"
struct funcs {
   struct _XImage *(*create_image)(struct _XDisplay * , Visual * , unsigned int  ,
                                   int  , int  , char * , unsigned int  , unsigned int  ,
                                   int  , int  ) ;
   int (*destroy_image)(struct _XImage * ) ;
   unsigned long (*get_pixel)(struct _XImage * , int  , int  ) ;
   int (*put_pixel)(struct _XImage * , int  , int  , unsigned long  ) ;
   struct _XImage *(*sub_image)(struct _XImage * , int  , int  , unsigned int  , unsigned int  ) ;
   int (*add_pixel)(struct _XImage * , long  ) ;
};
#line 372 "/usr/include/X11/Xlib.h"
struct _XImage {
   int width ;
   int height ;
   int xoffset ;
   int format ;
   char *data ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_bit_order ;
   int bitmap_pad ;
   int depth ;
   int bytes_per_line ;
   int bits_per_pixel ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   XPointer obdata ;
   struct funcs f ;
};
#line 372 "/usr/include/X11/Xlib.h"
typedef struct _XImage XImage;
#line 422 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColor_29 {
   unsigned long pixel ;
   unsigned short red ;
   unsigned short green ;
   unsigned short blue ;
   char flags ;
   char pad ;
};
#line 422 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColor_29 XColor;
#line 434 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSegment_30 {
   short x1 ;
   short y1 ;
   short x2 ;
   short y2 ;
};
#line 434 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSegment_30 XSegment;
#line 438 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPoint_31 {
   short x ;
   short y ;
};
#line 438 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPoint_31 XPoint;
#line 442 "/usr/include/X11/Xlib.h"
struct __anonstruct_XRectangle_32 {
   short x ;
   short y ;
   unsigned short width ;
   unsigned short height ;
};
#line 442 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XRectangle_32 XRectangle;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_38 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_38 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_39 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_39 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_40 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_40 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_41 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_41 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_42 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_42 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_43 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_43 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_44 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_44 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_45 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_45 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_46 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_46 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_47 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_47 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_48 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_48 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_49 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_49 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_50 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_51 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_52 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_53 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_54 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_55 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_56 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_57 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_58 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_59 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_60 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_61 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_62 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_63 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_64 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_65 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_67 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_66 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_67 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_66 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_68 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_69 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_69 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_70 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_71 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_72 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_73 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_73 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_74 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_74 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_75 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_75 XFontStruct;
#line 1096 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontSetExtents_80 {
   XRectangle max_ink_extent ;
   XRectangle max_logical_extent ;
};
#line 1096 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontSetExtents_80 XFontSetExtents;
#line 1106
struct _XOC;
#line 1106 "/usr/include/X11/Xlib.h"
typedef struct _XOC *XFontSet;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_98 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_98 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 326
enum __anonenum_XrmOptionKind_99 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
#line 326 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmOptionKind_99 XrmOptionKind;
#line 338 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmOptionDescRec_100 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_100 XrmOptionDescRec;
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_100 *XrmOptionDescList;
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_min_aspect_102 {
   int x ;
   int y ;
};
#line 81 "/usr/include/X11/Xutil.h"
struct __anonstruct_XSizeHints_101 {
   long flags ;
   int x ;
   int y ;
   int width ;
   int height ;
   int min_width ;
   int min_height ;
   int max_width ;
   int max_height ;
   int width_inc ;
   int height_inc ;
   struct __anonstruct_min_aspect_102 min_aspect ;
   struct __anonstruct_min_aspect_102 max_aspect ;
   int base_width ;
   int base_height ;
   int win_gravity ;
};
#line 81 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XSizeHints_101 XSizeHints;
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_103 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_103 XWMHints;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_107 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_107 XClassHint;
#line 231 "/usr/include/X11/Xutil.h"
struct _XComposeStatus {
   XPointer compose_ptr ;
   int chars_matched ;
};
#line 231 "/usr/include/X11/Xutil.h"
typedef struct _XComposeStatus XComposeStatus;
#line 287 "/usr/include/X11/Xutil.h"
struct __anonstruct_XVisualInfo_108 {
   Visual *visual ;
   VisualID visualid ;
   int screen ;
   int depth ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int colormap_size ;
   int bits_per_rgb ;
};
#line 287 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XVisualInfo_108 XVisualInfo;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gp_types.h"
enum DATA_TYPES {
    INTGR = 1,
    CMPLX = 2,
    STRING = 3
} ;
#line 129 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gp_types.h"
struct cmplx {
   double real ;
   double imag ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gp_types.h"
union __anonunion_v_150 {
   int int_val ;
   struct cmplx cmplx_val ;
   char *string_val ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gp_types.h"
struct value {
   enum DATA_TYPES type ;
   union __anonunion_v_150 v ;
};
#line 133 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gp_types.h"
typedef struct value t_value;
#line 53 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
enum operators {
    PUSH = 0,
    PUSHC = 1,
    PUSHD1 = 2,
    PUSHD2 = 3,
    PUSHD = 4,
    POP = 5,
    CALL = 6,
    CALLN = 7,
    SUM = 8,
    LNOT = 9,
    BNOT = 10,
    UMINUS = 11,
    LOR = 12,
    LAND = 13,
    BOR = 14,
    XOR = 15,
    BAND = 16,
    EQ = 17,
    NE = 18,
    GT = 19,
    LT = 20,
    GE = 21,
    LE = 22,
    PLUS = 23,
    MINUS = 24,
    MULT = 25,
    DIV = 26,
    MOD = 27,
    POWER = 28,
    FACTORIAL = 29,
    BOOLE = 30,
    DOLLARS = 31,
    CONCATENATE = 32,
    EQS = 33,
    NES = 34,
    RANGE = 35,
    ASSIGN = 36,
    JUMP = 37,
    JUMPZ = 38,
    JUMPNZ = 39,
    JTERN = 40,
    SF_START = 41,
    COLUMN = 42,
    STRINGCOLUMN = 43
} ;
#line 72
struct at_type;
#line 72 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
struct udft_entry {
   struct udft_entry *next_udf ;
   char *udf_name ;
   struct at_type *at ;
   char *definition ;
   int dummy_num ;
   t_value dummy_values[12] ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
struct udvt_entry {
   struct udvt_entry *next_udv ;
   char *udv_name ;
   _Bool udv_undef ;
   t_value udv_value ;
};
#line 91 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
union argument {
   int j_arg ;
   struct value v_arg ;
   struct udvt_entry *udv_arg ;
   struct udft_entry *udf_arg ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
struct at_entry {
   enum operators index ;
   union argument arg ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/eval.h"
struct at_type {
   int a_count ;
   struct at_entry actions[150] ;
};
#line 77 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
enum __anonenum_palette_color_mode_152 {
    SMPAL_COLOR_MODE_NONE = 48,
    SMPAL_COLOR_MODE_GRAY = 103,
    SMPAL_COLOR_MODE_RGB = 114,
    SMPAL_COLOR_MODE_FUNCTIONS = 102,
    SMPAL_COLOR_MODE_GRADIENT = 100,
    SMPAL_COLOR_MODE_CUBEHELIX = 99
} ;
#line 77 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
typedef enum __anonenum_palette_color_mode_152 palette_color_mode;
#line 90 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
struct __anonstruct_rgb_color_153 {
   double r ;
   double g ;
   double b ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
typedef struct __anonstruct_rgb_color_153 rgb_color;
#line 110 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
struct __anonstruct_gradient_struct_156 {
   double pos ;
   rgb_color col ;
};
#line 110 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
typedef struct __anonstruct_gradient_struct_156 gradient_struct;
#line 126 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
struct __anonstruct_t_sm_palette_157 {
   int colorFormulae ;
   palette_color_mode colorMode ;
   int formulaR ;
   int formulaG ;
   int formulaB ;
   char positive ;
   int use_maxcolors ;
   int colors ;
   rgb_color *color ;
   char ps_allcF ;
   int gradient_num ;
   gradient_struct *gradient ;
   int cmodel ;
   struct udft_entry Afunc ;
   struct udft_entry Bfunc ;
   struct udft_entry Cfunc ;
   double gamma ;
   double cubehelix_start ;
   double cubehelix_cycles ;
   double cubehelix_saturation ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
typedef struct __anonstruct_t_sm_palette_157 t_sm_palette;
#line 74 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/term_api.h"
enum JUSTIFY {
    LEFT = 0,
    CENTRE = 1,
    RIGHT = 2
} ;
#line 279
enum set_encoding_id {
    S_ENC_DEFAULT = 0,
    S_ENC_ISO8859_1 = 1,
    S_ENC_ISO8859_2 = 2,
    S_ENC_ISO8859_9 = 3,
    S_ENC_ISO8859_15 = 4,
    S_ENC_CP437 = 5,
    S_ENC_CP850 = 6,
    S_ENC_CP852 = 7,
    S_ENC_CP950 = 8,
    S_ENC_CP1250 = 9,
    S_ENC_CP1251 = 10,
    S_ENC_CP1254 = 11,
    S_ENC_KOI8_R = 12,
    S_ENC_KOI8_U = 13,
    S_ENC_SJIS = 14,
    S_ENC_UTF8 = 15,
    S_ENC_INVALID = 16
} ;
#line 179 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
struct axis_scale_t {
   int term_lower ;
   double term_scale ;
   double min ;
   double logbase ;
};
#line 179 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
typedef struct axis_scale_t axis_scale_t;
#line 218 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
struct cmap_t {
   struct cmap_t *prev_cmap ;
   struct cmap_t *next_cmap ;
   Colormap colormap ;
   unsigned long colors[13] ;
   unsigned long rgbcolors[13] ;
   unsigned long xorpixel ;
   int total ;
   int allocated ;
   unsigned long *pixels ;
};
#line 218 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
typedef struct cmap_t cmap_t;
#line 236 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
struct cmap_struct {
   cmap_t *cmap ;
   struct cmap_struct *next_cmap_struct ;
};
#line 236 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
typedef struct cmap_struct cmap_struct;
#line 242 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
struct plot_struct {
   Window window ;
   Window external_container ;
   Pixmap pixmap ;
   unsigned int posn_flags ;
   int x ;
   int y ;
   unsigned int width ;
   unsigned int height ;
   unsigned int gheight ;
   unsigned int px ;
   unsigned int py ;
   int ncommands ;
   int max_commands ;
   char **commands ;
   char *titlestring ;
   int button ;
   char str[255] ;
   Time time ;
   int lwidth ;
   int type ;
   int user_width ;
   enum JUSTIFY jmode ;
   double angle ;
   int lt ;
   _Bool mouse_on ;
   _Bool ruler_on ;
   _Bool ruler_lineto_on ;
   int ruler_x ;
   int ruler_y ;
   int ruler_lineto_x ;
   int ruler_lineto_y ;
   _Bool zoombox_on ;
   int zoombox_x1 ;
   int zoombox_y1 ;
   int zoombox_x2 ;
   int zoombox_y2 ;
   char zoombox_str1a[64] ;
   char zoombox_str1b[64] ;
   char zoombox_str2a[64] ;
   char zoombox_str2b[64] ;
   _Bool resizing ;
   cmap_t *cmap ;
   cmap_struct *first_cmap_struct ;
   int almost2d ;
   int axis_mask ;
   axis_scale_t axis_scale[8] ;
   int xLast ;
   int yLast ;
   int xSave ;
   int ySave ;
   unsigned long current_rgb ;
   struct plot_struct *prev_plot ;
   struct plot_struct *next_plot ;
   int plot_number ;
};
#line 242 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
typedef struct plot_struct plot_struct;
#line 320 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
struct plot_remove_struct {
   Window plot_window_to_remove ;
   struct plot_remove_struct *next_remove ;
   int processed ;
};
#line 320 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
typedef struct plot_remove_struct plot_remove_struct;
#line 49 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/mousecmn.h"
struct gp_event_t {
   int type ;
   int mx ;
   int my ;
   int par1 ;
   int par2 ;
   int winid ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.h"
struct gpe_fifo_t {
   struct gpe_fifo_t *prev ;
   struct gp_event_t ge ;
   struct gpe_fifo_t *next ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.h"
typedef struct gpe_fifo_t gpe_fifo_t;
#line 96 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./color.h"
struct __anonstruct_rgb255_color_62 {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./color.h"
typedef struct __anonstruct_rgb255_color_62 rgb255_color;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 65 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.h"
float *alloc_vector(int nl , int nh ) ;
#line 47
float **matrix(int nrl , int nrh , int ncl , int nch ) ;
#line 50
void free_matrix(float **m , int nrl , int nrh , int ncl ) ;
#line 51
void free_vector(float *vec , int nl ) ;
#line 54
int fwrite_matrix(FILE *fout , float **m , int nrl , int nrh , int ncl , int nch ,
                  float *row_title , float *column_title ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
void int_error(int dummy , char const   *error_text ) ;
#line 31
void FreeHelp(void) ;
#line 34
static float function(int p , double x , double y ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
static range TheRange[3]  = {      {(float )-3, (float )3, (float )-2, (float )2}, 
        {(float )-3, (float )3, (float )-3, (float )3}, 
        {(float )-3, (float )3, (float )-3, (float )3}};
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
void int_error(int dummy , char const   *error_text ) 
{ 


  {
  {
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal error..\n%s\n...now exiting to system ...\n",
          error_text);
#line 54
  exit(1);
  }
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
void FreeHelp(void) 
{ 


  {
#line 61
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
static float function(int p , double x , double y ) 
{ 
  float t ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 69
  t = (float )0;
  {
#line 72
  if (p == 0) {
#line 72
    goto case_0;
  }
#line 75
  if (p == 1) {
#line 75
    goto case_1;
  }
#line 80
  if (p == 2) {
#line 80
    goto case_2;
  }
#line 87
  goto switch_default;
  case_0: /* CIL Label */ 
#line 73
  t = (float )(1.0 / ((x * x + y * y) + 1.0));
#line 74
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 76
  tmp = sin(x * x + y * y);
#line 76
  t = (float )(tmp / (x * x + y * y));
  }
#line 77
  if ((double )t > 1.0) {
#line 78
    t = (float )1.0;
  }
#line 79
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 81
  tmp___0 = sin(x * x + y * y);
#line 81
  t = (float )(tmp___0 / (x * x + y * y));
#line 83
  tmp___1 = sin(4. * (x * x + y * y));
#line 83
  t = (float )((double )t * (tmp___1 / (4. * (x * x + y * y))));
  }
#line 84
  if ((double )t > 1.0) {
#line 85
    t = (float )1.0;
  }
#line 86
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown function\n");
  }
#line 89
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 91
  return (t);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/bf_test.c"
int main(void) 
{ 
  int plot ;
  int i ;
  int j ;
  float x ;
  float y ;
  float *rt ;
  float *ct ;
  float **m ;
  int xsize ;
  int ysize ;
  char buf___0[256] ;
  FILE *fout ;

  {
#line 109
  plot = 0;
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (plot < 2)) {
#line 109
      goto while_break;
    }
    {
#line 110
    xsize = (int )((double )(TheRange[plot].xmax - TheRange[plot].xmin) * 5.0 + (double )1);
#line 111
    ysize = (int )((double )(TheRange[plot].ymax - TheRange[plot].ymin) * 5.0 + (double )1);
#line 113
    rt = alloc_vector(0, xsize - 1);
#line 114
    ct = alloc_vector(0, ysize - 1);
#line 115
    m = matrix(0, xsize - 1, 0, ysize - 1);
#line 117
    y = TheRange[plot].ymin;
#line 117
    j = 0;
    }
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (j < ysize)) {
#line 117
        goto while_break___0;
      }
#line 118
      *(ct + j) = y;
#line 117
      j ++;
#line 117
      y = (float )((double )y + 1.0 / 5.0);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    x = TheRange[plot].xmin;
#line 121
    i = 0;
    {
#line 121
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 121
      if (! (i < xsize)) {
#line 121
        goto while_break___1;
      }
#line 122
      *(rt + i) = x;
#line 123
      y = TheRange[plot].ymin;
#line 123
      j = 0;
      {
#line 123
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 123
        if (! (j < ysize)) {
#line 123
          goto while_break___2;
        }
        {
#line 124
        *(*(m + i) + j) = function(plot, (double )x, (double )y);
#line 123
        j ++;
#line 123
        y = (float )((double )y + 1.0 / 5.0);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 121
      i ++;
#line 121
      x = (float )((double )x + 1.0 / 5.0);
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 128
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"binary%d",
            plot + 1);
#line 129
    fout = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"wb");
    }
#line 129
    if (fout) {
      {
#line 132
      fwrite_matrix(fout, m, 0, xsize - 1, 0, ysize - 1, rt, ct);
      }
    } else {
      {
#line 130
      int_error(0, "Could not open file");
      }
    }
    {
#line 134
    free_vector(rt, 0);
#line 135
    free_vector(ct, 0);
#line 136
    free_matrix(m, 0, xsize - 1, 0);
#line 109
    plot ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  xsize = (int )((double )(TheRange[plot].xmax - TheRange[plot].xmin) * 5.0 + (double )1);
#line 141
  ysize = (int )((double )(TheRange[plot].ymax - TheRange[plot].ymin) * 5.0 + (double )1);
#line 143
  rt = alloc_vector(0, xsize - 1);
#line 144
  ct = alloc_vector(0, ysize - 1);
#line 145
  m = matrix(0, xsize - 1, 0, ysize - 1);
#line 147
  y = TheRange[plot].ymin;
#line 147
  j = 0;
  }
  {
#line 147
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 147
    if (! (j < ysize)) {
#line 147
      goto while_break___3;
    }
#line 148
    if (y > (float )0) {
#line 148
      *(ct + j) = (float )2 * y;
    } else {
#line 148
      *(ct + j) = y;
    }
#line 147
    j ++;
#line 147
    y = (float )((double )y + 1.0 / 5.0);
  }
  while_break___3: /* CIL Label */ ;
  }
#line 150
  x = TheRange[plot].xmin;
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 150
    if (! (i < xsize)) {
#line 150
      goto while_break___4;
    }
#line 151
    if (x > (float )0) {
#line 151
      *(rt + i) = (float )2 * x;
    } else {
#line 151
      *(rt + i) = x;
    }
#line 152
    y = TheRange[plot].ymin;
#line 152
    j = 0;
    {
#line 152
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 152
      if (! (j < ysize)) {
#line 152
        goto while_break___5;
      }
      {
#line 153
      *(*(m + i) + j) = function(plot, (double )x, (double )y);
#line 152
      j ++;
#line 152
      y = (float )((double )y + 1.0 / 5.0);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 150
    i ++;
#line 150
    x = (float )((double )x + 1.0 / 5.0);
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 157
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"binary%d",
          plot + 1);
#line 158
  fout = fopen((char const   */* __restrict  */)(buf___0), (char const   */* __restrict  */)"wb");
  }
#line 158
  if (fout) {
    {
#line 161
    fwrite_matrix(fout, m, 0, xsize - 1, 0, ysize - 1, rt, ct);
    }
  } else {
    {
#line 159
    int_error(0, "Could not open file");
    }
  }
  {
#line 163
  free_vector(rt, 0);
#line 164
  free_vector(ct, 0);
#line 165
  free_matrix(m, 0, xsize - 1, 0);
  }
#line 167
  return (0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.h"
float *extend_vector(float *vec , int old_nl , int new_nh ) ;
#line 46
float *retract_vector(float *v , int old_nl , int new_nh ) ;
#line 48
float **extend_matrix(float **a , int nrl , int nrh , int ncl , int nch , int srh ,
                      int sch ) ;
#line 49
float **retract_matrix(float **a , int nrl , int nrh , int ncl , int nch , int srh ,
                       int sch ) ;
#line 52
int is_binary_file(FILE *fp ) ;
#line 53
int fread_matrix(FILE *fin , float ***ret_matrix , int *nr , int *nc , float **row_title ,
                 float **column_title ) ;
#line 55
float **convert_matrix(float *a , int nrl , int nrh , int ncl , int nch ) ;
#line 56
void free_convert_matrix(float **b , int nrl ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/alloc.h"
void *gp_alloc(size_t size , char const   *message ) ;
#line 51
void *gp_realloc(void *p , size_t size , char const   *message ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
int is_binary_file(FILE *fp ) 
{ 
  int i ;
  int len ;
  int odd ;
  long where ;
  unsigned char *c ;
  unsigned char buffer[512] ;
  size_t tmp ;

  {
  {
#line 49
  where = ftell(fp);
  }
#line 49
  if (where == -1L) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Notice: Assuming unseekable data is not binary\n");
    }
#line 51
    return (0);
  } else {
    {
#line 53
    rewind(fp);
#line 55
    tmp = fread((void */* __restrict  */)(buffer), sizeof(char ), (size_t )512, (FILE */* __restrict  */)fp);
#line 55
    len = (int )tmp;
    }
#line 56
    if (len <= 0) {
#line 57
      return (0);
    }
#line 59
    c = buffer;
#line 62
    odd = 0;
#line 63
    i = 0;
    {
#line 63
    while (1) {
      while_continue: /* CIL Label */ ;
#line 63
      if (! (i < len)) {
#line 63
        goto while_break;
      }
#line 64
      if (! *c) {
#line 65
        odd += len;
#line 66
        goto while_break;
      } else
#line 67
      if ((int )*c & 128) {
#line 72
        odd ++;
      } else
#line 67
      if ((int )*c == 127) {
#line 72
        odd ++;
      } else
#line 67
      if ((int )*c < 32) {
#line 67
        if ((int )*c != 10) {
#line 67
          if ((int )*c != 13) {
#line 67
            if ((int )*c != 8) {
#line 67
              if ((int )*c != 9) {
#line 67
                if ((int )*c != 12) {
#line 67
                  if ((int )*c != 27) {
#line 72
                    odd ++;
                  }
                }
              }
            }
          }
        }
      }
#line 63
      i ++;
#line 63
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 75
    fseek(fp, where, 0);
    }
#line 77
    if (odd * 10 > len) {
#line 78
      return (1);
    } else {
#line 80
      return (0);
    }
  }
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
int fread_matrix(FILE *fin , float ***ret_matrix , int *nr , int *nc , float **row_title ,
                 float **column_title ) 
{ 
  float **m ;
  float *rt ;
  float *ct ;
  int num_rows ;
  size_t num_cols ;
  int current_row ;
  float **temp_array ;
  float fdummy ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 108
  num_rows = 100;
#line 110
  current_row = 0;
#line 114
  tmp = fread((void */* __restrict  */)(& fdummy), sizeof(fdummy), (size_t )1, (FILE */* __restrict  */)fin);
  }
#line 114
  if (tmp != 1UL) {
#line 115
    return (0);
  }
  {
#line 117
  num_cols = (size_t )fdummy;
#line 122
  ct = alloc_vector(0, (int )(num_cols - 1UL));
#line 123
  fread((void */* __restrict  */)ct, sizeof(*ct), num_cols, (FILE */* __restrict  */)fin);
#line 125
  rt = alloc_vector(0, num_rows - 1);
#line 126
  m = matrix(0, num_rows - 1, 0, (int )(num_cols - 1UL));
  }
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 128
    tmp___1 = fread((void */* __restrict  */)(rt + current_row), sizeof(*(rt + current_row)),
                    (size_t )1, (FILE */* __restrict  */)fin);
    }
#line 128
    if (! (tmp___1 == 1UL)) {
#line 128
      goto while_break;
    }
    {
#line 130
    tmp___0 = fread((void */* __restrict  */)*(m + current_row), sizeof(*(*(m + current_row))),
                    num_cols, (FILE */* __restrict  */)fin);
    }
#line 130
    if (tmp___0 != num_cols) {
#line 131
      return (0);
    }
#line 133
    current_row ++;
#line 134
    if (current_row >= num_rows) {
      {
#line 135
      temp_array = extend_matrix(m, 0, num_rows - 1, 0, (int )(num_cols - 1UL), (num_rows + 50) - 1,
                                 (int )(num_cols - 1UL));
#line 137
      rt = extend_vector(rt, 0, (num_rows + 50) - 1);
#line 139
      num_rows += 50;
#line 140
      m = temp_array;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  temp_array = retract_matrix(m, 0, num_rows - 1, 0, (int )(num_cols - 1UL), current_row - 1,
                              (int )(num_cols - 1UL));
#line 148
  *ret_matrix = temp_array;
#line 149
  *row_title = retract_vector(rt, 0, current_row - 1);
#line 150
  *column_title = ct;
#line 151
  *nr = current_row;
#line 152
  *nc = (int )num_cols;
  }
#line 153
  return (1);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
int fwrite_matrix(FILE *fout , float **m , int nrl , int nrh , int ncl , int nch ,
                  float *row_title , float *column_title ) 
{ 
  int j ;
  float length ;
  int col_length ;
  int status ;
  float *title ;
  size_t tmp ;

  {
  {
#line 174
  title = (float *)((void *)0);
#line 176
  col_length = (nch - ncl) + 1;
#line 176
  length = (float )col_length;
#line 178
  tmp = fwrite((void const   */* __restrict  */)((char *)(& length)), sizeof(float ),
               (size_t )1, (FILE */* __restrict  */)fout);
#line 178
  status = (int )tmp;
  }
#line 178
  if (status != 1) {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fwrite 1 returned %d\n",
            status);
    }
#line 180
    return (0);
  }
#line 182
  if (! column_title) {
    {
#line 183
    title = alloc_vector(ncl, nch);
#line 183
    column_title = title;
#line 184
    j = ncl;
    }
    {
#line 184
    while (1) {
      while_continue: /* CIL Label */ ;
#line 184
      if (! (j <= nch)) {
#line 184
        goto while_break;
      }
#line 185
      *(title + j) = (float )j;
#line 184
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 187
  fwrite((void const   */* __restrict  */)((char *)column_title), sizeof(float ),
         (size_t )col_length, (FILE */* __restrict  */)fout);
  }
#line 188
  if (title) {
    {
#line 189
    free_vector(title, ncl);
#line 190
    title = (float *)((void *)0);
    }
  }
#line 192
  if (! row_title) {
    {
#line 193
    title = alloc_vector(nrl, nrh);
#line 193
    row_title = title;
#line 194
    j = nrl;
    }
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! (j <= nrh)) {
#line 194
        goto while_break___0;
      }
#line 195
      *(title + j) = (float )j;
#line 194
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 197
  j = nrl;
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    if (! (j <= nrh)) {
#line 197
      goto while_break___1;
    }
    {
#line 198
    fwrite((void const   */* __restrict  */)((char *)(row_title + j)), sizeof(float ),
           (size_t )1, (FILE */* __restrict  */)fout);
#line 199
    fwrite((void const   */* __restrict  */)((char *)(*(m + j) + ncl)), sizeof(float ),
           (size_t )col_length, (FILE */* __restrict  */)fout);
#line 197
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 201
  if (title) {
    {
#line 202
    free_vector(title, nrl);
    }
  }
#line 204
  return (1);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float *alloc_vector(int nl , int nh ) 
{ 
  float *vec ;
  void *tmp ;

  {
  {
#line 223
  tmp = gp_alloc((unsigned long )((nh - nl) + 1) * sizeof(float ), (char const   *)((void *)0));
#line 223
  vec = (float *)tmp;
  }
#line 223
  if (! vec) {
    {
#line 224
    int_error(-1, "not enough memory to create vector");
    }
#line 225
    return ((float *)((void *)0));
  }
#line 227
  return (vec - nl);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
void free_vector(float *vec , int nl ) 
{ 


  {
  {
#line 241
  free((void *)(vec + nl));
  }
#line 242
  return;
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float *extend_vector(float *vec , int old_nl , int new_nh ) 
{ 
  float *new_v ;
  void *tmp ;

  {
  {
#line 248
  tmp = gp_realloc((void *)(vec + old_nl), (unsigned long )((new_nh - old_nl) + 1) * sizeof(*(new_v + 0)),
                   "extend/retract vector");
#line 248
  new_v = (float *)tmp;
  }
#line 251
  return (new_v - old_nl);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float *retract_vector(float *v , int old_nl , int new_nh ) 
{ 
  float *tmp ;

  {
  {
#line 257
  tmp = extend_vector(v, old_nl, new_nh);
  }
#line 257
  return (tmp);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float **matrix(int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  float **m ;
  void *tmp ;
  float *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 287
  tmp = gp_alloc((unsigned long )((nrh - nrl) + 1) * sizeof(*(m + 0)), "matrix rows");
#line 287
  m = (float **)tmp;
#line 288
  m -= nrl;
#line 290
  i = nrl;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i <= nrh)) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp___1 = gp_alloc((unsigned long )((nch - ncl) + 1) * sizeof(*(*(m + i) + 0)),
                       (char const   *)((void *)0));
#line 291
    tmp___0 = (float *)tmp___1;
#line 291
    *(m + i) = tmp___0;
    }
#line 291
    if (! tmp___0) {
      {
#line 292
      free_matrix(m, nrl, i - 1, ncl);
#line 293
      int_error(-1, "not enough memory to create matrix");
      }
#line 294
      return ((float **)((void *)0));
    }
#line 296
    *(m + i) -= ncl;
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return (m);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
void free_matrix(float **m , int nrl , int nrh , int ncl ) 
{ 
  int i ;

  {
#line 316
  i = nrl;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i <= nrh)) {
#line 316
      goto while_break;
    }
    {
#line 317
    free((void *)(*(m + i) + ncl));
#line 316
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 318
  free((void *)(m + nrl));
  }
#line 319
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float **extend_matrix(float **a , int nrl , int nrh , int ncl , int nch , int srh ,
                      int sch ) 
{ 
  int i ;
  float **m ;
  void *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 332
  tmp = gp_realloc((void *)(a + nrl), (unsigned long )((srh - nrl) + 1) * sizeof(*(m + 0)),
                   "extend matrix");
#line 332
  m = (float **)tmp;
#line 334
  m -= nrl;
  }
#line 336
  if (sch != nch) {
#line 337
    i = nrl;
    {
#line 337
    while (1) {
      while_continue: /* CIL Label */ ;
#line 337
      if (! (i <= nrh)) {
#line 337
        goto while_break;
      }
      {
#line 338
      tmp___0 = extend_vector(*(m + i), ncl, sch);
#line 338
      *(m + i) = tmp___0;
      }
#line 338
      if (! tmp___0) {
        {
#line 339
        free_matrix(m, nrl, nrh, ncl);
#line 340
        int_error(-1, "not enough memory to extend matrix");
        }
#line 341
        return ((float **)((void *)0));
      }
#line 337
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 345
  i = nrh + 1;
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 345
    if (! (i <= srh)) {
#line 345
      goto while_break___0;
    }
    {
#line 346
    tmp___2 = gp_alloc((unsigned long )((nch - ncl) + 1) * sizeof(*(*(m + i) + 0)),
                       (char const   *)((void *)0));
#line 346
    tmp___1 = (float *)tmp___2;
#line 346
    *(m + i) = tmp___1;
    }
#line 346
    if (! tmp___1) {
      {
#line 347
      free_matrix(m, nrl, i - 1, nrl);
#line 348
      int_error(-1, "not enough memory to extend matrix");
      }
#line 349
      return ((float **)((void *)0));
    }
#line 351
    *(m + i) -= ncl;
#line 345
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 353
  return (m);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float **retract_matrix(float **a , int nrl , int nrh , int ncl , int nch , int srh ,
                       int sch ) 
{ 
  int i ;
  float **m ;
  void *tmp ;
  float *tmp___0 ;

  {
#line 365
  i = srh + 1;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! (i <= nrh)) {
#line 365
      goto while_break;
    }
    {
#line 366
    free_vector(*(a + i), ncl);
#line 365
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 369
  tmp = gp_realloc((void *)(a + nrl), (unsigned long )((srh - nrl) + 1) * sizeof(*(m + 0)),
                   "retract matrix");
#line 369
  m = (float **)tmp;
#line 371
  m -= nrl;
  }
#line 373
  if (sch != nch) {
#line 374
    i = nrl;
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if (! (i <= srh)) {
#line 374
        goto while_break___0;
      }
      {
#line 375
      tmp___0 = retract_vector(*(m + i), ncl, sch);
#line 375
      *(m + i) = tmp___0;
      }
#line 375
      if (! tmp___0) {
        {
#line 377
        free_matrix(m, nrl, srh, ncl);
#line 378
        int_error(-1, "not enough memory to retract matrix");
        }
#line 379
        return ((float **)((void *)0));
      }
#line 374
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 382
  return (m);
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
float **convert_matrix(float *a , int nrl , int nrh , int ncl , int nch ) 
{ 
  int i ;
  int j ;
  int ncol ;
  int nrow ;
  float **m ;
  void *tmp ;

  {
  {
#line 401
  nrow = (nrh - nrl) + 1;
#line 402
  ncol = (nch - ncl) + 1;
#line 403
  tmp = gp_alloc((unsigned long )((nrh - nrl) + 1) * sizeof(*(m + 0)), "convert_matrix");
#line 403
  m = (float **)tmp;
#line 405
  m -= nrl;
#line 407
  *(m + nrl) = a - ncl;
#line 408
  i = 1;
#line 408
  j = nrl + 1;
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i <= nrow - 1)) {
#line 408
      goto while_break;
    }
#line 409
    *(m + j) = *(m + (j - 1)) + ncol;
#line 408
    i ++;
#line 408
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (m);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/binary.c"
void free_convert_matrix(float **b , int nrl ) 
{ 


  {
  {
#line 417
  free((void *)(b + nrl));
  }
#line 418
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 259 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/alloc.c"
void *gp_alloc(size_t size , char const   *message ) 
{ 
  char *p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 265
  tmp = malloc(size);
#line 265
  p = (char *)tmp;
  }
#line 266
  if ((unsigned long )p == (unsigned long )((char *)((void *)0))) {
    {
#line 267
    FreeHelp();
#line 269
    tmp___0 = malloc(size);
#line 269
    p = (char *)tmp___0;
    }
#line 270
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 272
      if ((unsigned long )message != (unsigned long )((void *)0)) {
        {
#line 273
        int_error(-1, "out of memory for %s", message);
        }
      }
    }
  }
#line 281
  return ((void *)p);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/alloc.c"
void *gp_realloc(void *p , size_t size , char const   *message ) 
{ 
  char *res ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 296
  if (! p) {
    {
#line 297
    tmp = gp_alloc(size, message);
    }
#line 297
    return (tmp);
  }
  {
#line 300
  tmp___0 = realloc(p, size);
#line 300
  res = (char *)tmp___0;
  }
#line 301
  if ((unsigned long )res == (unsigned long )((char *)((void *)0))) {
    {
#line 302
    FreeHelp();
#line 304
    tmp___1 = realloc(p, size);
#line 304
    res = (char *)tmp___1;
    }
#line 305
    if ((unsigned long )res == (unsigned long )((char *)((void *)0))) {
#line 307
      if ((unsigned long )message != (unsigned long )((void *)0)) {
        {
#line 308
        int_error(-1, "out of memory for %s", message);
        }
      }
    }
  }
#line 316
  return ((void *)res);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.h"
char const   gnuplot_version[4] ;
#line 43
char const   gnuplot_patchlevel[2] ;
#line 44
char const   gnuplot_date[12] ;
#line 45
char const   gnuplot_copyright[47] ;
#line 46
char const   faq_location[29] ;
#line 47
char const   bug_email[35] ;
#line 48
char const   help_email[35] ;
#line 50 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.h"
char os_name[32]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.h"
char os_rel[32]  ;
#line 53
char *compile_options ;
#line 42 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   gnuplot_version[4]  = {      (char const   )'4',      (char const   )'.',      (char const   )'6',      (char const   )'\000'};
#line 43 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   gnuplot_patchlevel[2]  = {      (char const   )'4',      (char const   )'\000'};
#line 44 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   gnuplot_date[12]  = 
#line 44
  {      (char const   )'2',      (char const   )'0',      (char const   )'1',      (char const   )'3', 
        (char const   )'-',      (char const   )'1',      (char const   )'0',      (char const   )'-', 
        (char const   )'0',      (char const   )'6',      (char const   )' ',      (char const   )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   gnuplot_copyright[47]  = 
#line 45
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'(',      (char const   )'C', 
        (char const   )')',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'8',      (char const   )'6',      (char const   )'-',      (char const   )'1', 
        (char const   )'9',      (char const   )'9',      (char const   )'3',      (char const   )',', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'8',      (char const   )',',      (char const   )' ',      (char const   )'2', 
        (char const   )'0',      (char const   )'0',      (char const   )'4',      (char const   )',', 
        (char const   )' ',      (char const   )'2',      (char const   )'0',      (char const   )'0', 
        (char const   )'7',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'1',      (char const   )'3',      (char const   )'\000'};
#line 47 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   faq_location[29]  = 
#line 47
  {      (char const   )'h',      (char const   )'t',      (char const   )'t',      (char const   )'p', 
        (char const   )':',      (char const   )'/',      (char const   )'/',      (char const   )'w', 
        (char const   )'w',      (char const   )'w',      (char const   )'.',      (char const   )'g', 
        (char const   )'n',      (char const   )'u',      (char const   )'p',      (char const   )'l', 
        (char const   )'o',      (char const   )'t',      (char const   )'.',      (char const   )'i', 
        (char const   )'n',      (char const   )'f',      (char const   )'o',      (char const   )'/', 
        (char const   )'f',      (char const   )'a',      (char const   )'q',      (char const   )'/', 
        (char const   )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char *compile_options  =    (char *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   bug_email[35]  = 
#line 51
  {      (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'p', 
        (char const   )'l',      (char const   )'o',      (char const   )'t',      (char const   )'-', 
        (char const   )'b',      (char const   )'e',      (char const   )'t',      (char const   )'a', 
        (char const   )'@',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'s',      (char const   )'.',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'g',      (char const   )'e',      (char const   )'.',      (char const   )'n', 
        (char const   )'e',      (char const   )'t',      (char const   )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/version.c"
char const   help_email[35]  = 
#line 52
  {      (char const   )'g',      (char const   )'n',      (char const   )'u',      (char const   )'p', 
        (char const   )'l',      (char const   )'o',      (char const   )'t',      (char const   )'-', 
        (char const   )'b',      (char const   )'e',      (char const   )'t',      (char const   )'a', 
        (char const   )'@',      (char const   )'l',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'s',      (char const   )'.',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'g',      (char const   )'e',      (char const   )'.',      (char const   )'n', 
        (char const   )'e',      (char const   )'t',      (char const   )'\000'};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 1406 "/usr/include/X11/Xlib.h"
extern XFontStruct *XLoadQueryFont(Display * , char const   * ) ;
#line 1453
extern XImage *XCreateImage(Display * , Visual * , unsigned int  , int  , int  , char * ,
                            unsigned int  , unsigned int  , int  , int  ) ;
#line 1468
extern XImage *XGetImage(Display * , Drawable  , int  , int  , unsigned int  , unsigned int  ,
                         unsigned long  , int  ) ;
#line 1495
extern Display *XOpenDisplay(char const   * ) ;
#line 1499
extern void XrmInitialize(void) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1564
extern Colormap XCreateColormap(Display * , Window  , Visual * , int  ) ;
#line 1588
extern Cursor XCreateFontCursor(Display * , unsigned int  ) ;
#line 1596
extern GC XCreateGC(Display * , Drawable  , unsigned long  , XGCValues * ) ;
#line 1609
extern Pixmap XCreatePixmap(Display * , Drawable  , unsigned int  , unsigned int  ,
                            unsigned int  ) ;
#line 1616
extern Pixmap XCreateBitmapFromData(Display * , Drawable  , char const   * , unsigned int  ,
                                    unsigned int  ) ;
#line 1633
extern Window XCreateSimpleWindow(Display * , Window  , int  , int  , unsigned int  ,
                                  unsigned int  , unsigned int  , unsigned long  ,
                                  unsigned long  ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1662
extern Colormap *XListInstalledColormaps(Display * , Window  , int * ) ;
#line 1698
extern KeySym __attribute__((__deprecated__))  XKeycodeToKeysym(Display * , KeyCode  ,
                                                                int  ) ;
#line 1725
extern long XMaxRequestSize(Display * ) ;
#line 1731
extern char *XResourceManagerString(Display * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1934
extern void XFreeStringList(char ** ) ;
#line 1970
extern int XAllocColor(Display * , Colormap  , XColor * ) ;
#line 2050
extern int XChangeGC(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2097
extern int XChangeWindowAttributes(Display * , Window  , unsigned long  , XSetWindowAttributes * ) ;
#line 2127
extern int XCheckTypedWindowEvent(Display * , Window  , int  , XEvent * ) ;
#line 2134
extern int XCheckWindowEvent(Display * , Window  , long  , XEvent * ) ;
#line 2167
extern int XClearWindow(Display * , Window  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2209
extern int XCopyGC(Display * , GC  , unsigned long  , GC  ) ;
#line 2243
extern int XDefineCursor(Display * , Window  , Cursor  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2314
extern int XDrawArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2334
extern int XDrawImageString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                            int  ) ;
#line 2354
extern int XDrawLine(Display * , Drawable  , GC  , int  , int  , int  , int  ) ;
#line 2364
extern int XDrawLines(Display * , Drawable  , GC  , XPoint * , int  , int  ) ;
#line 2373
extern int XDrawPoint(Display * , Drawable  , GC  , int  , int  ) ;
#line 2390
extern int XDrawRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2408
extern int XDrawSegments(Display * , Drawable  , GC  , XSegment * , int  ) ;
#line 2416
extern int XDrawString(Display * , Drawable  , GC  , int  , int  , char const   * ,
                       int  ) ;
#line 2471
extern int XFillArc(Display * , Drawable  , GC  , int  , int  , unsigned int  , unsigned int  ,
                    int  , int  ) ;
#line 2491
extern int XFillPolygon(Display * , Drawable  , GC  , XPoint * , int  , int  , int  ) ;
#line 2501
extern int XFillRectangle(Display * , Drawable  , GC  , int  , int  , unsigned int  ,
                          unsigned int  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2532
extern int XFreeColormap(Display * , Colormap  ) ;
#line 2537
extern int XFreeColors(Display * , Colormap  , unsigned long * , int  , unsigned long  ) ;
#line 2554
extern int XFreeFont(Display * , XFontStruct * ) ;
#line 2573
extern int XFreeGC(Display * , GC  ) ;
#line 2582
extern int XFreePixmap(Display * , Pixmap  ) ;
#line 2625
extern int XGetGCValues(Display * , GC  , unsigned long  , XGCValues * ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2803
extern int XLowerWindow(Display * , Window  ) ;
#line 2808
extern int XMapRaised(Display * , Window  ) ;
#line 2818
extern int XMapWindow(Display * , Window  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2858
extern int XNoOp(Display * ) ;
#line 2862
extern int XParseColor(Display * , Colormap  , char const   * , XColor * ) ;
#line 2869
extern int XParseGeometry(char const   * , int * , int * , unsigned int * , unsigned int * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 2915
extern int XPutImage(Display * , Drawable  , GC  , XImage * , int  , int  , int  ,
                     int  , unsigned int  , unsigned int  ) ;
#line 2969
extern int XQueryColor(Display * , Colormap  , XColor * ) ;
#line 2995
extern int XQueryPointer(Display * , Window  , Window * , Window * , int * , int * ,
                         int * , int * , unsigned int * ) ;
#line 3038
extern int XRaiseWindow(Display * , Window  ) ;
#line 3111
extern int XResizeWindow(Display * , Window  , unsigned int  , unsigned int  ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 3166
extern int XSetBackground(Display * , GC  , unsigned long  ) ;
#line 3207
extern int XSetDashes(Display * , GC  , int  , char const   * , int  ) ;
#line 3221
extern int XSetFillStyle(Display * , GC  , int  ) ;
#line 3227
extern int XSetFont(Display * , GC  , Font  ) ;
#line 3239
extern int XSetForeground(Display * , GC  , unsigned long  ) ;
#line 3257
extern int XSetIconName(Display * , Window  , char const   * ) ;
#line 3263
extern int XSetInputFocus(Display * , Window  , int  , Time  ) ;
#line 3270
extern int XSetLineAttributes(Display * , GC  , unsigned int  , int  , int  , int  ) ;
#line 3304
extern int XSetSelectionOwner(Display * , Atom  , Window  , Time  ) ;
#line 3320
extern int XSetStipple(Display * , GC  , Pixmap  ) ;
#line 3345
extern int XSetWindowBackground(Display * , Window  , unsigned long  ) ;
#line 3351
extern int XSetWindowBackgroundPixmap(Display * , Window  , Pixmap  ) ;
#line 3357
extern int XSetWindowBorder(Display * , Window  , unsigned long  ) ;
#line 3375
extern int XSetWindowColormap(Display * , Window  , Colormap  ) ;
#line 3388
extern int XStoreBytes(Display * , char const   * , int  ) ;
#line 3407
extern int XStoreName(Display * , Window  , char const   * ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3446
extern int XTextWidth(XFontStruct * , char const   * , int  ) ;
#line 3469
extern int XUndefineCursor(Display * , Window  ) ;
#line 3526
extern int XWarpPointer(Display * , Window  , Window  , int  , int  , unsigned int  ,
                        unsigned int  , int  , int  ) ;
#line 3563
extern int XSupportsLocale(void) ;
#line 3621
extern XFontSet XCreateFontSet(Display * , char const   * , char *** , int * , char ** ) ;
#line 3629
extern void XFreeFontSet(Display * , XFontSet  ) ;
#line 3634
extern int XFontsOfFontSet(XFontSet  , XFontStruct *** , char *** ) ;
#line 3660
extern XFontSetExtents *XExtentsOfFontSet(XFontSet  ) ;
#line 3664
extern int XmbTextEscapement(XFontSet  , char const   * , int  ) ;
#line 3772
extern void XmbDrawString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                          char const   * , int  ) ;
#line 3805
extern void XmbDrawImageString(Display * , Drawable  , XFontSet  , GC  , int  , int  ,
                               char const   * , int  ) ;
#line 223 "/usr/include/X11/Xresource.h"
extern int XrmGetResource(XrmDatabase  , char const   * , char const   * , char ** ,
                          XrmValue * ) ;
#line 266
extern XrmDatabase XrmGetFileDatabase(char const   * ) ;
#line 276
extern XrmDatabase XrmGetStringDatabase(char const   * ) ;
#line 285
extern void XrmMergeDatabases(XrmDatabase  , XrmDatabase * ) ;
#line 346
extern void XrmParseCommand(XrmDatabase * , XrmOptionDescList  , int  , char const   * ,
                            int * , char ** ) ;
#line 471 "/usr/include/X11/Xutil.h"
extern XVisualInfo *XGetVisualInfo(Display * , long  , XVisualInfo * , int * ) ;
#line 534
extern int XLookupString(XKeyEvent * , char * , int  , KeySym * , XComposeStatus * ) ;
#line 583
extern int XSetClassHint(Display * , Window  , XClassHint * ) ;
#line 596
extern int XSetNormalHints(Display * , Window  , XSizeHints * ) ;
#line 641
extern int XSetWMHints(Display * , Window  , XWMHints * ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 717
extern int system(char const   *__command ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 100
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 181
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 279
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) rint)(double __x ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 207 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/color.h"
t_sm_palette sm_palette ;
#line 359 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/term_api.h"
enum set_encoding_id encoding ;
#line 39 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/getcolor.h"
void rgb1_from_gray(double gray , rgb_color *color ) ;
#line 44
double quantize_gray(double gray ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.h"
int pipe_died ;
#line 69
void pipe_died_handler(int signum ) ;
#line 80
int buffered_output_pending ;
#line 85
void gp_exec_event(char type___0 , int mx , int my , int par1 , int par2 , int winid ) ;
#line 403 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gadgets.h"
double pointsize ;
#line 231 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static cmap_t default_cmap  ;
#line 307
static plot_struct *Add_Plot_To_Linked_List(int plot_number ) ;
#line 308
static void Remove_Plot_From_Linked_List(Window plot_window ) ;
#line 309
static plot_struct *Find_Plot_In_Linked_List_By_Number(int plot_number ) ;
#line 310
static plot_struct *Find_Plot_In_Linked_List_By_Window(Window window ) ;
#line 311
static plot_struct *Find_Plot_In_Linked_List_By_CMap(cmap_t *cmp ) ;
#line 313 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct plot_struct *current_plot  =    (struct plot_struct *)((void *)0);
#line 314 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int most_recent_plot_number  =    0;
#line 315 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct plot_struct *plot_list_start  =    (struct plot_struct *)((void *)0);
#line 317
static void x11_setfill(GC *gc___0 , int style ) ;
#line 326
static void Add_Plot_To_Remove_FIFO_Queue(Window plot_window ) ;
#line 327
static void Process_Remove_FIFO_Queue(void) ;
#line 329 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct plot_remove_struct *remove_fifo_queue_start  =    (struct plot_remove_struct *)((void *)0);
#line 330 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int process_remove_fifo_queue  =    0;
#line 332
static cmap_t *Add_CMap_To_Linked_List(void) ;
#line 333
static void Remove_CMap_From_Linked_List(cmap_t *cmp ) ;
#line 334
static cmap_t *Find_CMap_In_Linked_List(cmap_t *colormap ) ;
#line 335
static int cmaps_differ(cmap_t *cmap1 , cmap_t *cmap2 ) ;
#line 345 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct cmap_t *current_cmap  =    (struct cmap_t *)((void *)0);
#line 346 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct cmap_t *cmap_list_start  =    (struct cmap_t *)((void *)0);
#line 355 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char selection[255]  = {      (char )'\000'};
#line 368
static void CmapClear(cmap_t *cmap_ptr ) ;
#line 369
static void RecolorWindow(plot_struct *plot ) ;
#line 370
static void FreeColormapList(plot_struct *plot ) ;
#line 371
static void FreeColors(cmap_t *cmp ) ;
#line 372
static void ReleaseColormap(cmap_t *cmp ) ;
#line 373
static unsigned long *ReallocColors(cmap_t *cmap , int n ) ;
#line 374
static void PaletteMake(t_sm_palette *tpal ) ;
#line 375
static void PaletteSetColor(plot_struct *plot , double gray ) ;
#line 376
static int GetVisual(int class , Visual **visual , int *depth ) ;
#line 377
static void scan_palette_from_buf(void) ;
#line 379
static unsigned short BitMaskDetails(unsigned long mask , unsigned short *left_shift ,
                                     unsigned short *right_shift ) ;
#line 381 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
_Bool swap_endian  =    (_Bool)0;
#line 383 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
__inline static void byteswap(char *data , int datalen ) 
{ 
  char tmp ;
  char *dest ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 386
  dest = (data + datalen) - 1;
#line 387
  if (datalen < 2) {
#line 387
    return;
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! ((unsigned long )dest > (unsigned long )data)) {
#line 388
      goto while_break;
    }
#line 389
    tmp = *dest;
#line 390
    tmp___0 = dest;
#line 390
    dest --;
#line 390
    *tmp___0 = *data;
#line 391
    tmp___1 = data;
#line 391
    data ++;
#line 391
    *tmp___1 = tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
char byteswap_char  ;
#line 409
static void store_command(char *buffer , plot_struct *plot ) ;
#line 410
static void prepare_plot(plot_struct *plot ) ;
#line 411
static void delete_plot(plot_struct *plot ) ;
#line 413
static int record(void) ;
#line 414
static void process_event(XEvent *event ) ;
#line 415
static void process_configure_notify_event(XEvent *event ) ;
#line 417
static void mainloop(void) ;
#line 419
static void display(plot_struct *plot ) ;
#line 420
static void UpdateWindow(plot_struct *plot ) ;
#line 422
static void gp_execute_GE_plotdone(int windowid ) ;
#line 424
static int ErrorHandler(Display *display___0 , XErrorEvent *error_event ) ;
#line 425
static void DrawRuler(plot_struct *plot ) ;
#line 426
static void EventuallyDrawMouseAddOns(plot_struct *plot ) ;
#line 427
static void DrawBox(plot_struct *plot ) ;
#line 428
static void DrawLineToRuler(plot_struct *plot ) ;
#line 429
static void AnnotatePoint(plot_struct *plot , int x , int y , char const   *xstr ,
                          char const   *ystr ) ;
#line 430
static long SetTime(plot_struct *plot , Time t ) ;
#line 431
static unsigned long AllocateXorPixel(cmap_t *cmap_ptr ) ;
#line 432
static void GetGCXor(plot_struct *plot , GC *ret ) ;
#line 433
static void GetGCXorDashed(plot_struct *plot , GC *gc___0 ) ;
#line 434
static void EraseCoords(plot_struct *plot ) ;
#line 435
static void DrawCoords(plot_struct *plot , char const   *str ) ;
#line 436
static void DisplayCoords(plot_struct *plot , char const   *s ) ;
#line 438
static _Bool is_meta(KeySym mod ) ;
#line 441 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long gnuplotXID  =    0UL;
#line 442
static char *getMultiTabConsoleSwitchCommand(unsigned long *newGnuplotXID___0 ) ;
#line 447
static void DrawRotated(plot_struct *plot , Display *dpy___0 , GC gc___0 , int xdest ,
                        int ydest , char const   *str , int len ) ;
#line 449
static int DrawRotatedErrorHandler(Display *display___0 , XErrorEvent *error_event ) ;
#line 450
static void exec_cmd(plot_struct *plot , char *command ) ;
#line 452
static void reset_cursor(void) ;
#line 454
static void preset(int argc , char **argv ) ;
#line 455
static char *pr_GetR(XrmDatabase xrdb , char *resource ) ;
#line 456
static void pr_color(cmap_t *cmap_ptr ) ;
#line 457
static void pr_dashes(void) ;
#line 458
static void pr_encoding(void) ;
#line 459
static void pr_font(char *fontname ) ;
#line 460
static void pr_geometry(char *instr ) ;
#line 461
static void pr_pointsize(void) ;
#line 462
static void pr_width(void) ;
#line 463
static void pr_window(plot_struct *plot ) ;
#line 464
static void pr_raise(void) ;
#line 465
static void pr_persist(void) ;
#line 466
static void pr_feedback(void) ;
#line 467
static void pr_ctrlq(void) ;
#line 468
static void pr_fastrotate(void) ;
#line 471
static void export_graph(struct plot_struct *plot ) ;
#line 472
static void handle_selection_event(XEvent *event ) ;
#line 473
static void pr_exportselection(void) ;
#line 477
static void mouse_to_coords(plot_struct *plot , XEvent *event , double *x , double *y ,
                            double *x2 , double *y2 ) ;
#line 479
static double mouse_to_axis(int mouse_coord , axis_scale_t *axis ) ;
#line 482 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *FallbackFont  =    (char *)"fixed";
#line 484 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *FallbackFontMB  =    (char *)"mbfont:*-medium-r-normal--14-*;*-medium-r-normal--16-*";
#line 487 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int usemultibyte  =    0;
#line 488 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int multibyte_fonts_usable  =    1;
#line 489
static int fontset_transsep(char *nfname , char *ofname , int n ) ;
#line 491
static int gpXTextWidth(XFontStruct *cfont , char const   *str , int count ) ;
#line 492
static int gpXTextHeight(XFontStruct *cfont ) ;
#line 493
static void gpXSetFont(Display *disp , GC gc___0 , Font fontid ) ;
#line 494
static void gpXDrawImageString(Display *disp , Drawable d , GC gc___0 , int x , int y ,
                               char const   *str , int len ) ;
#line 495
static void gpXDrawString(Display *disp , Drawable d , GC gc___0 , int x , int y ,
                          char const   *str , int len ) ;
#line 496
static void gpXFreeFont(Display *disp , XFontStruct *cfont ) ;
#line 497
static XFontStruct *gpXLoadQueryFont(Display *disp , char *fontname ) ;
#line 498
static char *gpFallbackFont(void) ;
#line 499
static int gpXGetFontascent(XFontStruct *cfont ) ;
#line 501 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
enum set_encoding_id encoding  =    (enum set_encoding_id )0;
#line 502 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char default_font[64]  = {      (char )'\000'};
#line 503 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char default_encoding[16]  = {      (char )'\000'};
#line 506 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int widths[10]  = 
#line 506
  {      2U,      0U,      0U,      0U, 
        0U,      0U,      0U,      0U, 
        0U,      0U};
#line 509 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char dashes[10][5]  ;
#line 511 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
t_sm_palette sm_palette  = 
#line 511
     {-1, (palette_color_mode )48, 0, 0, 0, (char)0, 0, -1, (rgb_color *)0, (char)0,
    0, (gradient_struct *)0, 0, {(struct udft_entry *)0, (char *)0, (struct at_type *)0,
                                 (char *)0, 0, {{0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}},
                                                {0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}},
                                                {0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}},
                                                {0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}},
                                                {0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}},
                                                {0U, {.cmplx_val = {0., 0.}}}, {0U,
                                                                                {.cmplx_val = {0.,
                                                                                               0.}}}}},
    {(struct udft_entry *)0, (char *)0, (struct at_type *)0, (char *)0, 0, {{0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}}}},
    {(struct udft_entry *)0, (char *)0, (struct at_type *)0, (char *)0, 0, {{0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}},
                                                                            {0U, {.cmplx_val = {0.,
                                                                                                0.}}}}},
    0., 0., 0., 0.};
#line 525 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int have_pm3d  =    1;
#line 526 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int num_colormaps  =    0;
#line 527 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int maximal_possible_colors  =    256U;
#line 528 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int minimal_possible_colors  ;
#line 533 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *visual_name[7]  = {      (char *)"StaticGray",      (char *)"GrayScale",      (char *)"StaticColor",      (char *)"PseudoColor", 
        (char *)"TrueColor",      (char *)"DirectColor",      (char *)0};
#line 543 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Display *dpy  ;
#line 544 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int scr  ;
#line 545 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Window root  ;
#line 546 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Visual *vis  =    (Visual *)0;
#line 547 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC gc  =    (GC )0;
#line 548 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC *current_gc  =    (GC *)0;
#line 549 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC gc_xor  =    (GC )0;
#line 550 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC gc_xor_dashed  =    (GC )0;
#line 551 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC fill_gc  =    (GC )0;
#line 552 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XFontStruct *font  =    (XFontStruct *)((void *)0);
#line 554 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XFontSet mbfont  =    (XFontSet )((void *)0);
#line 556 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int do_raise  =    1;
#line 556 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int persist  =    0;
#line 557 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool fast_rotate  =    (_Bool)1;
#line 558 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int feedback  =    1;
#line 559 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int ctrlq  =    0;
#line 560 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int dashedlines  =    0;
#line 562 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool exportselection  =    (_Bool)1;
#line 564 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor  ;
#line 565 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_default  ;
#line 567 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_exchange  ;
#line 568 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_sizing  ;
#line 569 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_zooming  ;
#line 571 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_waiting  ;
#line 572 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Cursor cursor_save  ;
#line 573 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int button_pressed  =    0;
#line 577 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int windows_open  =    0;
#line 579 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int gX  =    100;
#line 579 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int gY  =    100;
#line 580 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int gW  =    640U;
#line 580 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int gH  =    450U;
#line 581 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int gFlags  =    (unsigned int )(1L << 3);
#line 583 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int BorderWidth  =    2U;
#line 584 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int dep  ;
#line 585 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static long max_request_size  ;
#line 587 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int Mono  =    0;
#line 587 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int Gray  =    0;
#line 587 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int Rv  =    0;
#line 587 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int Clear  =    0;
#line 588 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char X_Name[64]  = 
#line 588
  {      (char )'g',      (char )'n',      (char )'u',      (char )'p', 
        (char )'l',      (char )'o',      (char )'t',      (char )'\000'};
#line 589 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char X_Class[64]  = 
#line 589
  {      (char )'G',      (char )'n',      (char )'u',      (char )'p', 
        (char )'l',      (char )'o',      (char )'t',      (char )'\000'};
#line 591 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int cx  =    0;
#line 591 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int cy  =    0;
#line 594 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int vchar  ;
#line 594 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int hchar  ;
#line 597 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static double xscale  =    - 1.;
#line 598 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static double yscale  =    - 1.;
#line 599 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
double pointsize  =    - 1.;
#line 610 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char buf[1024]  ;
#line 611 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int buffered_input_available  =    0;
#line 613 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static FILE *X11_ipc  ;
#line 620 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom WM_PROTOCOLS  ;
#line 620 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom WM_DELETE_WINDOW  ;
#line 622 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XPoint Diamond[5]  ;
#line 622 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XPoint Triangle[4]  ;
#line 623 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XSegment Plus[2]  ;
#line 623 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XSegment Cross[2]  ;
#line 623 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XSegment Star[4]  ;
#line 632 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char const   stipple_pattern_bits[8][8]  = 
#line 632
  { {        (char const   )0,        (char const   )0,        (char const   )0,        (char const   )0, 
            (char const   )0,        (char const   )0,        (char const   )0,        (char const   )0}, 
   {        (char const   )129,        (char const   )66,        (char const   )36,        (char const   )24, 
            (char const   )24,        (char const   )36,        (char const   )66,        (char const   )65}, 
   {        (char const   )136,        (char const   )85,        (char const   )34,        (char const   )85, 
            (char const   )136,        (char const   )85,        (char const   )34,        (char const   )85}, 
   {        (char const   )255,        (char const   )255,        (char const   )255,        (char const   )255, 
            (char const   )255,        (char const   )255,        (char const   )255,        (char const   )255}, 
   {        (char const   )1,        (char const   )2,        (char const   )4,        (char const   )8, 
            (char const   )16,        (char const   )32,        (char const   )64,        (char const   )128}, 
   {        (char const   )128,        (char const   )64,        (char const   )32,        (char const   )16, 
            (char const   )8,        (char const   )4,        (char const   )2,        (char const   )1}, 
   {        (char const   )17,        (char const   )17,        (char const   )34,        (char const   )34, 
            (char const   )68,        (char const   )68,        (char const   )136,        (char const   )136}, 
   {        (char const   )136,        (char const   )136,        (char const   )68,        (char const   )68, 
            (char const   )34,        (char const   )34,        (char const   )17,        (char const   )17}};
#line 643 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Pixmap stipple_pattern[8]  ;
#line 644 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int stipple_initialized  =    0;
#line 647 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XPoint *polyline  =    (XPoint *)((void *)0);
#line 648 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int polyline_space  =    0;
#line 649 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int polyline_size  =    0;
#line 757 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void mainloop(void) 
{ 
  int nf ;
  int cn ;
  int in ;
  int nfds ;
  struct timeval timeout ;
  struct timeval *timer ;
  fd_set tset ;
  int usleep_count ;
  int out ;
  int tmp ;
  int tmp___0 ;
  int __d0 ;
  int __d1 ;
  int *tmp___1 ;
  XEvent xe ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 760
  cn = ((_XPrivDisplay )dpy)->fd;
#line 762
  timer = (struct timeval *)0;
#line 766
  usleep_count = 0;
#line 768
  out = fileno(stdout);
#line 771
  X11_ipc = stdin;
#line 772
  in = fileno(X11_ipc);
  }
#line 775
  if (out > in) {
#line 776
    if (cn > out) {
#line 776
      tmp = cn;
    } else {
#line 776
      tmp = out;
    }
#line 776
    nfds = tmp + 1;
  } else {
#line 779
    if (cn > in) {
#line 779
      tmp___0 = cn;
    } else {
#line 779
      tmp___0 = in;
    }
#line 779
    nfds = tmp___0 + 1;
  }
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 797
    XFlush(dpy);
    }
    {
#line 799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 799
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& tset.__fds_bits[0]): "memory");
#line 799
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 800
    tset.__fds_bits[cn / (8 * (int )sizeof(__fd_mask ))] |= 1L << cn % (8 * (int )sizeof(__fd_mask ));
#line 806
    if (buffered_input_available) {
#line 807
      timeout.tv_sec = (__time_t )0;
#line 808
      timeout.tv_usec = (__suseconds_t )0;
#line 809
      timer = & timeout;
    } else {
#line 811
      timer = (struct timeval *)0;
#line 812
      tset.__fds_bits[in / (8 * (int )sizeof(__fd_mask ))] |= 1L << in % (8 * (int )sizeof(__fd_mask ));
    }
#line 816
    if (buffered_output_pending) {
#line 816
      if (! pipe_died) {
#line 818
        tset.__fds_bits[out / (8 * (int )sizeof(__fd_mask ))] |= 1L << out % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 822
    usleep_count ++;
#line 822
    if (usleep_count > 10) {
      {
#line 823
      usleep((__useconds_t )100);
#line 824
      usleep_count = 0;
      }
    }
    {
#line 829
    nf = select(nfds, (fd_set */* __restrict  */)(& tset), (fd_set */* __restrict  */)0,
                (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)timer);
    }
#line 831
    if (nf < 0) {
      {
#line 832
      tmp___1 = __errno_location();
      }
#line 832
      if (*tmp___1 == 4) {
#line 833
        goto while_continue;
      }
      {
#line 834
      perror("gnuplot_x11: select failed");
      }
      {
#line 835
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 835
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 835
        close(1);
#line 835
        close(0);
#line 835
        exit(1);
        }
#line 835
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 838
    if (nf > 0) {
      {
#line 839
      XNoOp(dpy);
      }
    }
    {
#line 841
    tmp___3 = XPending(dpy);
    }
#line 841
    if (tmp___3) {
      {
#line 854
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 855
        XNextEvent(dpy, & xe);
#line 856
        process_event(& xe);
#line 854
        tmp___2 = XPending(dpy);
        }
#line 854
        if (! tmp___2) {
#line 854
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 860
    if ((tset.__fds_bits[in / (8 * (int )sizeof(__fd_mask ))] & (1L << in % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 860
      goto _L;
    } else
#line 860
    if (buffered_input_available) {
      _L: /* CIL Label */ 
      {
#line 861
      tmp___4 = record();
      }
#line 861
      if (! tmp___4) {
#line 862
        return;
      }
    }
#line 865
    if (! pipe_died) {
#line 865
      if ((tset.__fds_bits[out / (8 * (int )sizeof(__fd_mask ))] & (1L << out % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 866
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
        }
      } else
#line 865
      if (buffered_output_pending) {
        {
#line 866
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
        }
      }
    }
#line 874
    if (process_remove_fifo_queue) {
      {
#line 875
      Process_Remove_FIFO_Queue();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1022 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void delete_plot(plot_struct *plot ) 
{ 
  int i ;
  int i___0 ;

  {
#line 1029
  i = 0;
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1029
    if (! (i < plot->ncommands)) {
#line 1029
      goto while_break;
    }
    {
#line 1030
    free((void *)*(plot->commands + i));
#line 1029
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1031
  plot->ncommands = 0;
#line 1032
  if (plot->commands) {
    {
#line 1033
    free((void *)plot->commands);
    }
  }
#line 1034
  plot->commands = (char **)((void *)0);
#line 1035
  plot->max_commands = 0;
#line 1039
  if (plot->titlestring) {
    {
#line 1040
    free((void *)plot->titlestring);
#line 1041
    plot->titlestring = (char *)0;
    }
  }
#line 1044
  if (plot->window) {
    {
#line 1046
    XDestroyWindow(dpy, plot->window);
#line 1047
    plot->window = (Window )0L;
#line 1048
    windows_open --;
    }
  }
#line 1051
  if (stipple_initialized) {
#line 1053
    i___0 = 0;
    {
#line 1053
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1053
      if (! (i___0 < 8)) {
#line 1053
        goto while_break___0;
      }
      {
#line 1054
      XFreePixmap(dpy, stipple_pattern[i___0]);
#line 1053
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1055
    stipple_initialized = 0;
  }
#line 1058
  if (plot->pixmap) {
    {
#line 1059
    XFreePixmap(dpy, plot->pixmap);
#line 1060
    plot->pixmap = (Pixmap )0L;
    }
  }
  {
#line 1063
  FreeColormapList(plot);
  }
#line 1064
  return;
}
}
#line 1068 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void prepare_plot(plot_struct *plot ) 
{ 
  int i ;

  {
#line 1073
  i = 0;
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (! (i < plot->ncommands)) {
#line 1073
      goto while_break;
    }
    {
#line 1074
    free((void *)*(plot->commands + i));
#line 1073
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  plot->ncommands = 0;
#line 1077
  if (! plot->posn_flags) {
#line 1081
    plot->posn_flags = gFlags;
#line 1082
    plot->x = gX;
#line 1083
    plot->y = gY;
#line 1084
    plot->width = gW;
#line 1085
    plot->height = gH;
#line 1086
    plot->window = (Window )0L;
#line 1087
    plot->pixmap = (Pixmap )0L;
#line 1089
    plot->gheight = gH;
#line 1090
    plot->resizing = (_Bool)0;
#line 1091
    plot->str[0] = (char )'\000';
#line 1092
    plot->zoombox_on = (_Bool)0;
#line 1094
    plot->first_cmap_struct = (cmap_struct *)((void *)0);
  }
#line 1096
  if (plot->window == 0UL) {
    {
#line 1097
    plot->cmap = current_cmap;
#line 1098
    pr_window(plot);
#line 1104
    plot->button = 0;
#line 1105
    plot->mouse_on = (_Bool)1;
#line 1106
    plot->x = -1;
#line 1107
    plot->y = -1;
    }
#line 1108
    if ((int )plot->str[0] != 0) {
#line 1111
      plot->str[0] = (char )' ';
#line 1112
      plot->str[1] = (char )'\000';
    }
#line 1114
    plot->time = (Time )0;
  }
  {
#line 1119
  FreeColormapList(plot);
#line 1121
  plot->cmap = current_cmap;
#line 1127
  plot->angle = (double )0;
#line 1128
  reset_cursor();
#line 1129
  XDefineCursor(dpy, plot->window, cursor);
  }
#line 1130
  return;
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void store_command(char *buffer , plot_struct *plot ) 
{ 
  char *p ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 1138
  if (plot->ncommands >= plot->max_commands) {
#line 1139
    plot->max_commands = plot->max_commands * 2 + 1;
#line 1140
    if (plot->commands) {
      {
#line 1140
      tmp = realloc((void *)plot->commands, (unsigned long )plot->max_commands * sizeof(char *));
#line 1140
      plot->commands = (char **)tmp;
      }
    } else {
      {
#line 1140
      tmp___0 = malloc(sizeof(char *));
#line 1140
      plot->commands = (char **)tmp___0;
      }
    }
  }
  {
#line 1144
  tmp___1 = strlen((char const   *)buffer);
#line 1144
  tmp___2 = malloc(tmp___1 + 1UL);
#line 1144
  p = (char *)tmp___2;
  }
#line 1145
  if (! plot->commands) {
#line 1145
    goto _L;
  } else
#line 1145
  if (! p) {
    _L: /* CIL Label */ 
    {
#line 1146
    fputs((char const   */* __restrict  */)"gnuplot: can\'t get memory. X11 aborted.\n",
          (FILE */* __restrict  */)stderr);
    }
    {
#line 1147
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1147
      gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 1147
      close(1);
#line 1147
      close(0);
#line 1147
      exit(1);
      }
#line 1147
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1149
  tmp___3 = plot->ncommands;
#line 1149
  (plot->ncommands) ++;
#line 1149
  *(plot->commands + tmp___3) = strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)buffer);
  }
#line 1150
  return;
}
}
#line 1154
static int read_input(void) ;
#line 1163 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int rdbuf_size  =    10240;
#line 1164 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char rdbuf[10240]  ;
#line 1165 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int total_chars  ;
#line 1166 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int rdbuf_offset  ;
#line 1167 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int buf_offset  ;
#line 1168 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int partial_read  =    0;
#line 1160 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int read_input(void) 
{ 
  int fd ;
  int tmp ;
  ssize_t tmp___0 ;
  char c ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1169
  tmp = fileno(X11_ipc);
#line 1169
  fd = tmp;
  }
#line 1171
  if (! partial_read) {
#line 1172
    buf_offset = 0;
  }
#line 1174
  if (! buffered_input_available) {
    {
#line 1175
    tmp___0 = read(fd, (void *)(rdbuf), (size_t )rdbuf_size);
#line 1175
    total_chars = (int )tmp___0;
#line 1176
    buffered_input_available = 1;
#line 1177
    partial_read = 0;
#line 1178
    rdbuf_offset = 0;
    }
#line 1179
    if (total_chars == 0) {
#line 1180
      return (-2);
    }
#line 1181
    if (total_chars < 0) {
#line 1182
      return (-1);
    }
  }
#line 1185
  if (rdbuf_offset < total_chars) {
    {
#line 1186
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1186
      if (rdbuf_offset < total_chars) {
#line 1186
        if (! (buf_offset < 1024)) {
#line 1186
          goto while_break;
        }
      } else {
#line 1186
        goto while_break;
      }
#line 1187
      tmp___1 = rdbuf_offset;
#line 1187
      rdbuf_offset ++;
#line 1187
      c = rdbuf[tmp___1];
#line 1188
      tmp___2 = buf_offset;
#line 1188
      buf_offset ++;
#line 1188
      buf[tmp___2] = c;
#line 1189
      if ((int )c == 10) {
#line 1190
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1193
    if (buf_offset == 1024) {
      {
#line 1194
      fputs((char const   */* __restrict  */)"\ngplt_x11.c: buffer overflow in read_input!\n            X11 aborted.\n",
            (FILE */* __restrict  */)stderr);
      }
      {
#line 1196
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1196
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 1196
        close(1);
#line 1196
        close(0);
#line 1196
        exit(1);
        }
#line 1196
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1198
      buf[buf_offset] = (char )'\000';
    }
  }
#line 1201
  if (rdbuf_offset == total_chars) {
#line 1202
    buffered_input_available = 0;
#line 1203
    if ((int )buf[buf_offset - 1] != 10) {
#line 1204
      partial_read = 1;
    }
  }
#line 1207
  return (partial_read);
}
}
#line 1210
static void read_input_line(void) ;
#line 1216 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void read_input_line(void) 
{ 
  int i_read ;
  int tmp ;

  {
#line 1220
  i_read = 1;
  {
#line 1220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1220
    tmp = read_input();
    }
#line 1220
    if (! (tmp == 1)) {
#line 1220
      goto while_break;
    }
#line 1221
    if (i_read == 5) {
      {
#line 1222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngplt_x11.c: A complete buffer instruction is not appearing across\n            link.  Check for system overload or driver error.\n");
      }
    }
#line 1220
    i_read ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1225
  return;
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char frac[8]  = 
#line 1289
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
#line 1246 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void scan_palette_from_buf(void) 
{ 
  t_sm_palette tpal ;
  char cm ;
  char pos ;
  char mod ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int i ;
  int tmp___2 ;
  void *tmp___3 ;
  char *b ;
  unsigned int rgb_component ;

  {
  {
#line 1251
  tmp = sscanf((char const   */* __restrict  */)(buf + 2), (char const   */* __restrict  */)"%c %c %c %d",
               & cm, & pos, & mod, & tpal.use_maxcolors);
  }
#line 1251
  if (4 != tmp) {
    {
#line 1253
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d error in setting palette.\n",
            "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
            1254);
    }
#line 1256
    return;
  }
#line 1259
  tpal.colorMode = (palette_color_mode )cm;
#line 1260
  tpal.positive = pos;
#line 1261
  tpal.cmodel = (int )mod;
#line 1262
  tpal.gradient = (gradient_struct *)((void *)0);
#line 1265
  if ((unsigned int )tpal.colorMode == 102U) {
#line 1266
    tpal.colorMode = (palette_color_mode )100;
  }
#line 1267
  if ((unsigned int )tpal.colorMode == 99U) {
#line 1268
    tpal.colorMode = (palette_color_mode )100;
  }
  {
#line 1271
  if ((unsigned int )tpal.colorMode == 103U) {
#line 1271
    goto case_103;
  }
#line 1279
  if ((unsigned int )tpal.colorMode == 114U) {
#line 1279
    goto case_114;
  }
#line 1288
  if ((unsigned int )tpal.colorMode == 100U) {
#line 1288
    goto case_100;
  }
#line 1318
  if ((unsigned int )tpal.colorMode == 102U) {
#line 1318
    goto case_102;
  }
#line 1322
  goto switch_default;
  case_103: /* CIL Label */ 
  {
#line 1272
  read_input_line();
#line 1273
  tmp___0 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lf",
                   & tpal.gamma);
  }
#line 1273
  if (1 != tmp___0) {
    {
#line 1274
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d error in setting palette.\n",
            "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
            1275);
    }
#line 1276
    return;
  }
#line 1278
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 1280
  read_input_line();
#line 1281
  tmp___1 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d %d %d",
                   & tpal.formulaR, & tpal.formulaG, & tpal.formulaB);
  }
#line 1281
  if (3 != tmp___1) {
    {
#line 1283
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d error in setting palette.\n",
            "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
            1284);
    }
#line 1285
    return;
  }
#line 1287
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 1290
  i = 0;
#line 1291
  read_input_line();
#line 1292
  tmp___2 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d",
                   & tpal.gradient_num);
  }
#line 1292
  if (1 != tmp___2) {
    {
#line 1293
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d error in setting palette.\n",
            "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
            1294);
    }
#line 1295
    return;
  }
  {
#line 1297
  tmp___3 = malloc((unsigned long )tpal.gradient_num * sizeof(gradient_struct ));
#line 1297
  tpal.gradient = (gradient_struct *)tmp___3;
  }
#line 1299
  if (! tpal.gradient) {
    {
#line 1299
    __assert_fail("tpal.gradient", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
                  1299U, "scan_palette_from_buf");
    }
  }
#line 1300
  i = 0;
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! (i < tpal.gradient_num)) {
#line 1300
      goto while_break;
    }
#line 1301
    b = & buf[12 * (i % 50)];
#line 1304
    if (i % 50 == 0) {
      {
#line 1305
      read_input_line();
      }
    }
    {
#line 1307
    memcpy((void */* __restrict  */)(frac), (void const   */* __restrict  */)b, (size_t )6);
#line 1308
    (tpal.gradient + i)->pos = atof((char const   *)(frac));
#line 1309
    sscanf((char const   */* __restrict  */)(b + 6), (char const   */* __restrict  */)"%2x",
           & rgb_component);
#line 1310
    (tpal.gradient + i)->col.r = (double )rgb_component / 255.;
#line 1311
    sscanf((char const   */* __restrict  */)(b + 8), (char const   */* __restrict  */)"%2x",
           & rgb_component);
#line 1312
    (tpal.gradient + i)->col.g = (double )rgb_component / 255.;
#line 1313
    sscanf((char const   */* __restrict  */)(b + 10), (char const   */* __restrict  */)"%2x",
           & rgb_component);
#line 1314
    (tpal.gradient + i)->col.b = (double )rgb_component / 255.;
#line 1300
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1316
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 1319
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d ooops: No function palettes for x11!\n",
          "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
          1320);
  }
#line 1321
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1323
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d ooops: Unknown colorMode \'%c\'.\n",
          "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
          1324, (int )((char )tpal.colorMode));
#line 1325
  tpal.colorMode = (palette_color_mode )103;
  }
#line 1326
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1328
  PaletteMake(& tpal);
  }
#line 1330
  if (tpal.gradient) {
    {
#line 1331
    free((void *)tpal.gradient);
    }
  }
#line 1332
  return;
}
}
#line 1342 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int record(void) 
{ 
  int status ;
  int tmp ;
  int itmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned long ultmp ;
  Window window_id ;
  plot_struct *tmpplot ;
  plot_struct *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int itmp___0 ;
  plot_struct *psp ;
  size_t tmp___5 ;
  int tmp___6 ;
  int itmp___1 ;
  plot_struct *psp___0 ;
  plot_struct *psp___1 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int itmp___2 ;
  plot_struct *psp___2 ;
  plot_struct *psp___3 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *cp ;
  char *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  char cmapidx[6] ;
  unsigned int tmp___14 ;
  int cm_index ;
  cmap_struct *csp ;
  unsigned short tmp___15 ;
  int tmp_do_raise ;
  int tmp_persist ;
  int tmp_dashed ;
  int tmp_ctrlq ;
  char strtmp[256] ;
  int c ;
  int x ;
  int y ;
  int tmp___16 ;
  int tmp___17 ;
  int where ;
  char *second ;
  int tmp___18 ;
  size_t tmp___19 ;
  int x___0 ;
  int y___0 ;
  int len ;
  size_t tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int scaled_hchar ;
  int scaled_vchar ;
  char *c___0 ;
  size_t tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
  {
#line 1345
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1346
    tmp = read_input();
#line 1346
    status = tmp;
    }
#line 1347
    if (status == -2) {
#line 1348
      return (0);
    }
#line 1349
    if (status != 0) {
#line 1350
      return (status);
    }
    {
#line 1353
    if ((int )buf[0] == 71) {
#line 1353
      goto case_71;
    }
#line 1411
    if ((int )buf[0] == 78) {
#line 1411
      goto case_78;
    }
#line 1424
    if ((int )buf[0] == 119) {
#line 1424
      goto case_119;
    }
#line 1446
    if ((int )buf[0] == 67) {
#line 1446
      goto case_67;
    }
#line 1459
    if ((int )buf[0] == 94) {
#line 1459
      goto case_94;
    }
#line 1482
    if ((int )buf[0] == 118) {
#line 1482
      goto case_118;
    }
#line 1500
    if ((int )buf[0] == 110) {
#line 1500
      goto case_110;
    }
#line 1519
    if ((int )buf[0] == 69) {
#line 1519
      goto case_69;
    }
#line 1527
    if ((int )buf[0] == 82) {
#line 1527
      goto case_82;
    }
#line 1531
    if ((int )buf[0] == 112) {
#line 1531
      goto case_112;
    }
#line 1551
    if ((int )buf[0] == 66) {
#line 1551
      goto case_66;
    }
#line 1562
    if ((int )buf[0] == 88) {
#line 1562
      goto case_88;
    }
#line 1578
    if ((int )buf[0] == 115) {
#line 1578
      goto case_115;
    }
#line 1587
    if ((int )buf[0] == 117) {
#line 1587
      goto case_117;
    }
#line 1649
    if ((int )buf[0] == 116) {
#line 1649
      goto case_116;
    }
#line 1701
    if ((int )buf[0] == 114) {
#line 1701
      goto case_114;
    }
#line 1726
    if ((int )buf[0] == 122) {
#line 1726
      goto case_122;
    }
#line 1745
    if ((int )buf[0] == 81) {
#line 1745
      goto case_81;
    }
#line 1769
    goto switch_default;
    case_71: /* CIL Label */ 
    {
#line 1361
    sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"G%lu",
           & gnuplotXID);
    }
#line 1366
    if (! current_plot) {
      {
#line 1367
      current_plot = Add_Plot_To_Linked_List(most_recent_plot_number);
      }
    }
#line 1368
    if (current_plot) {
      {
#line 1369
      prepare_plot(current_plot);
      }
    }
#line 1399
    if (! button_pressed) {
#line 1400
      cursor_save = cursor;
#line 1401
      cursor = cursor_waiting;
#line 1402
      if (current_plot) {
        {
#line 1403
        XDefineCursor(dpy, current_plot->window, cursor);
        }
      }
    }
#line 1410
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 1414
    tmp___0 = strcspn((char const   *)(buf + 1), " \n");
    }
#line 1414
    if (tmp___0) {
      {
#line 1414
      tmp___1 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"N%d",
                       & itmp);
      }
#line 1414
      if (tmp___1) {
#line 1415
        if (itmp >= 0) {
          {
#line 1416
          most_recent_plot_number = itmp;
#line 1417
          current_plot = Add_Plot_To_Linked_List(itmp);
          }
        }
      }
    }
#line 1420
    return (1);
#line 1422
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 1427
    tmp___3 = strcspn((char const   *)(buf + 1), " \n");
    }
#line 1427
    if (tmp___3) {
      {
#line 1427
      tmp___4 = sscanf((char const   */* __restrict  */)(buf + 1), (char const   */* __restrict  */)"%lx",
                       & ultmp);
      }
#line 1427
      if (tmp___4) {
        {
#line 1428
        window_id = ultmp;
#line 1429
        tmp___2 = Find_Plot_In_Linked_List_By_Window(window_id);
#line 1429
        tmpplot = tmp___2;
        }
#line 1430
        if (tmpplot) {
#line 1431
          current_plot = tmpplot;
#line 1432
          most_recent_plot_number = tmpplot->plot_number;
        } else {
          {
#line 1435
          current_plot = Add_Plot_To_Linked_List(-1);
          }
#line 1436
          if (current_plot) {
            {
#line 1437
            current_plot->external_container = window_id;
#line 1438
            prepare_plot(current_plot);
            }
          }
        }
      }
    }
#line 1442
    return (1);
#line 1444
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 1449
    tmp___5 = strcspn((char const   *)(buf + 1), " \n");
    }
#line 1449
    if (tmp___5) {
      {
#line 1449
      tmp___6 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"C%d",
                       & itmp___0);
      }
#line 1449
      if (tmp___6) {
        {
#line 1451
        psp = Find_Plot_In_Linked_List_By_Number(itmp___0);
        }
#line 1451
        if (psp) {
          {
#line 1452
          Remove_Plot_From_Linked_List(psp->window);
          }
        }
      } else {
#line 1449
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1453
    if (current_plot) {
      {
#line 1454
      Remove_Plot_From_Linked_List(current_plot->window);
      }
    }
#line 1456
    return (1);
#line 1458
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 1462
    tmp___7 = strcspn((char const   *)(buf + 1), " \n");
    }
#line 1462
    if (tmp___7) {
      {
#line 1462
      tmp___8 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"^%d",
                       & itmp___1);
      }
#line 1462
      if (tmp___8) {
        {
#line 1464
        psp___0 = Find_Plot_In_Linked_List_By_Number(itmp___1);
        }
#line 1464
        if (psp___0) {
          {
#line 1465
          XRaiseWindow(dpy, psp___0->window);
          }
        }
      } else {
#line 1462
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1469
      psp___1 = plot_list_start;
      {
#line 1470
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1470
        if (! ((unsigned long )psp___1 != (unsigned long )((void *)0))) {
#line 1470
          goto while_break___0;
        }
#line 1471
        if ((unsigned long )psp___1->next_plot == (unsigned long )((void *)0)) {
#line 1471
          goto while_break___0;
        }
#line 1472
        psp___1 = psp___1->next_plot;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1474
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1474
        if (! ((unsigned long )psp___1 != (unsigned long )((void *)0))) {
#line 1474
          goto while_break___1;
        }
        {
#line 1475
        XRaiseWindow(dpy, psp___1->window);
#line 1476
        psp___1 = psp___1->prev_plot;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1479
    return (1);
#line 1481
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 1485
    tmp___9 = strcspn((char const   *)(buf + 1), " \n");
    }
#line 1485
    if (tmp___9) {
      {
#line 1485
      tmp___10 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"v%d",
                        & itmp___2);
      }
#line 1485
      if (tmp___10) {
        {
#line 1487
        psp___2 = Find_Plot_In_Linked_List_By_Number(itmp___2);
        }
#line 1487
        if (psp___2) {
          {
#line 1488
          XLowerWindow(dpy, psp___2->window);
          }
        }
      } else {
#line 1485
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1490
    if (current_plot) {
#line 1491
      psp___3 = plot_list_start;
      {
#line 1492
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1492
        if (! ((unsigned long )psp___3 != (unsigned long )((void *)0))) {
#line 1492
          goto while_break___2;
        }
        {
#line 1493
        XLowerWindow(dpy, psp___3->window);
#line 1494
        psp___3 = psp___3->next_plot;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1497
    return (1);
#line 1499
    goto switch_break;
    case_110: /* CIL Label */ 
#line 1502
    if (! current_plot) {
      {
#line 1503
      current_plot = Add_Plot_To_Linked_List(most_recent_plot_number);
      }
    }
#line 1504
    if (current_plot) {
#line 1506
      if (current_plot->titlestring) {
        {
#line 1507
        free((void *)current_plot->titlestring);
        }
      }
      {
#line 1508
      tmp___12 = strlen((char const   *)(buf + 1));
#line 1508
      tmp___13 = malloc(tmp___12 + 1UL);
#line 1508
      tmp___11 = (char *)tmp___13;
#line 1508
      current_plot->titlestring = tmp___11;
      }
#line 1508
      if (tmp___11) {
        {
#line 1509
        strcpy((char */* __restrict  */)current_plot->titlestring, (char const   */* __restrict  */)(buf + 1));
#line 1510
        cp = current_plot->titlestring;
        }
      } else {
#line 1512
        cp = (char *)"<lost name>";
      }
#line 1513
      if (current_plot->window) {
        {
#line 1514
        XStoreName(dpy, current_plot->window, (char const   *)cp);
        }
      }
    }
#line 1516
    return (1);
#line 1518
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1520
    if (current_plot) {
      {
#line 1521
      display(current_plot);
      }
    }
#line 1523
    if (current_plot) {
      {
#line 1524
      gp_execute_GE_plotdone((int )current_plot->window);
      }
    }
#line 1526
    return (1);
    case_82: /* CIL Label */ 
    {
#line 1528
    reset_cursor();
    }
#line 1529
    return (0);
    case_112: /* CIL Label */ 
#line 1532
    if (have_pm3d) {
#line 1533
      cmapidx[0] = (char )'e';
#line 1533
      cmapidx[1] = (char )'\000';
#line 1533
      tmp___14 = 2U;
      {
#line 1533
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1533
        if (tmp___14 >= 6U) {
#line 1533
          goto while_break___3;
        }
#line 1533
        cmapidx[tmp___14] = (char)0;
#line 1533
        tmp___14 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1537
      scan_palette_from_buf();
#line 1540
      csp = current_plot->first_cmap_struct;
#line 1541
      cm_index = 0;
      }
      {
#line 1541
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1541
        if (! csp) {
#line 1541
          goto while_break___4;
        }
#line 1542
        if ((unsigned long )csp->cmap == (unsigned long )current_cmap) {
#line 1543
          goto while_break___4;
        }
#line 1544
        csp = csp->next_cmap_struct;
#line 1541
        cm_index ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1546
      sprintf((char */* __restrict  */)(cmapidx + 1), (char const   */* __restrict  */)"%3u%c",
              cm_index, '\000');
#line 1547
      store_command(cmapidx, current_plot);
      }
    }
#line 1549
    return (1);
    case_66: /* CIL Label */ 
#line 1554
    tmp___15 = (unsigned short)21075;
#line 1555
    *((char *)(& tmp___15) + 0) = buf[1];
#line 1556
    *((char *)(& tmp___15) + 1) = buf[2];
#line 1557
    if ((int )tmp___15 == 21075) {
#line 1557
      swap_endian = (_Bool)0;
    } else {
#line 1558
      swap_endian = (_Bool)1;
    }
#line 1560
    return (1);
    case_88: /* CIL Label */ 
    {
#line 1564
    tmp_do_raise = -1;
#line 1564
    tmp_persist = -1;
#line 1565
    tmp_dashed = -1;
#line 1565
    tmp_ctrlq = -1;
#line 1566
    sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"X%d%d%d%d",
           & tmp_do_raise, & tmp_persist, & tmp_dashed, & tmp_ctrlq);
    }
#line 1567
    if (-1 != tmp_do_raise) {
#line 1568
      do_raise = tmp_do_raise;
    }
#line 1569
    if (-1 != tmp_persist) {
#line 1570
      persist = tmp_persist;
    }
#line 1571
    if (-1 != tmp_dashed) {
#line 1572
      dashedlines = tmp_dashed;
    }
#line 1573
    if (-1 != tmp_ctrlq) {
#line 1574
      ctrlq = tmp_ctrlq;
    }
#line 1576
    return (1);
    case_115: /* CIL Label */ 
    {
#line 1581
    sscanf((char const   */* __restrict  */)(& buf[2]), (char const   */* __restrict  */)"%s",
           strtmp);
#line 1582
    pr_geometry(strtmp);
    }
#line 1584
    return (1);
    case_117: /* CIL Label */ 
#line 1589
    if (! pipe_died) {
      {
#line 1594
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"u%4d%4d%4d",
             & c, & x, & y);
      }
#line 1595
      if (current_plot) {
        {
#line 1597
        if (c == -4) {
#line 1597
          goto case_neg_4;
        }
#line 1601
        if (c == -3) {
#line 1601
          goto case_neg_3;
        }
#line 1609
        if (c == -2) {
#line 1609
          goto case_neg_2;
        }
#line 1612
        if (c == -1) {
#line 1612
          goto case_neg_1;
        }
#line 1618
        if (c == 0) {
#line 1618
          goto case_0;
        }
#line 1622
        if (c == 1) {
#line 1622
          goto case_1;
        }
#line 1626
        if (c == 2) {
#line 1626
          goto case_2;
        }
#line 1630
        if (c == 3) {
#line 1630
          goto case_3;
        }
#line 1596
        goto switch_break___0;
        case_neg_4: /* CIL Label */ 
        {
#line 1598
        DrawLineToRuler(current_plot);
#line 1599
        current_plot->ruler_lineto_on = (_Bool)0;
        }
#line 1600
        goto switch_break___0;
        case_neg_3: /* CIL Label */ 
#line 1602
        if (current_plot->ruler_on) {
#line 1602
          if (current_plot->ruler_lineto_on) {
#line 1603
            goto switch_break___0;
          }
        }
        {
#line 1604
        current_plot->ruler_lineto_x = (int )((double )x * xscale);
#line 1605
        current_plot->ruler_lineto_y = (int )((double )(4095 - y) * yscale);
#line 1606
        current_plot->ruler_lineto_on = (_Bool)1;
#line 1607
        DrawLineToRuler(current_plot);
        }
#line 1608
        goto switch_break___0;
        case_neg_2: /* CIL Label */ 
        {
#line 1610
        XWarpPointer(dpy, (Window )0L, current_plot->window, 0, 0, 0U, 0U, (int )((double )x * xscale),
                     (int )((double )(4095 - y) * yscale));
        }
        case_neg_1: /* CIL Label */ 
        {
#line 1613
        tmp___16 = (int )((double )x * xscale);
#line 1613
        current_plot->zoombox_x2 = tmp___16;
#line 1613
        current_plot->zoombox_x1 = tmp___16;
#line 1614
        tmp___17 = (int )((double )(4095 - y) * yscale);
#line 1614
        current_plot->zoombox_y2 = tmp___17;
#line 1614
        current_plot->zoombox_y1 = tmp___17;
#line 1615
        current_plot->zoombox_on = (_Bool)1;
#line 1616
        DrawBox(current_plot);
        }
#line 1617
        goto switch_break___0;
        case_0: /* CIL Label */ 
        {
#line 1619
        cursor = cursor_default;
#line 1620
        XDefineCursor(dpy, current_plot->window, cursor);
        }
#line 1621
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 1623
        cursor = cursor_exchange;
#line 1624
        XDefineCursor(dpy, current_plot->window, cursor);
        }
#line 1625
        goto switch_break___0;
        case_2: /* CIL Label */ 
        {
#line 1627
        cursor = cursor_sizing;
#line 1628
        XDefineCursor(dpy, current_plot->window, cursor);
        }
#line 1629
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 1631
        cursor = cursor_zooming;
#line 1632
        XDefineCursor(dpy, current_plot->window, cursor);
        }
#line 1633
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 1635
        if (c >= 0) {
#line 1635
          if (current_plot->zoombox_on) {
            {
#line 1637
            DrawBox(current_plot);
#line 1638
            current_plot->zoombox_on = (_Bool)0;
            }
          }
        }
#line 1640
        if (c >= 0) {
#line 1640
          if (current_plot->ruler_lineto_on) {
            {
#line 1642
            DrawLineToRuler(current_plot);
#line 1643
            current_plot->ruler_lineto_on = (_Bool)0;
            }
          }
        }
      }
    }
#line 1647
    return (1);
    case_116: /* CIL Label */ 
#line 1651
    if (! pipe_died) {
      {
#line 1656
      tmp___18 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"t%4d",
                        & where);
      }
#line 1656
      if (tmp___18 != 1) {
#line 1657
        return (1);
      }
      {
#line 1658
      tmp___19 = strlen((char const   *)(buf));
#line 1658
      buf[tmp___19 - 1UL] = (char)0;
      }
#line 1659
      if (current_plot) {
        {
#line 1661
        if (where == 0) {
#line 1661
          goto case_0___0;
        }
#line 1664
        if (where == 1) {
#line 1664
          goto case_1___0;
        }
#line 1680
        if (where == 2) {
#line 1680
          goto case_2___0;
        }
#line 1660
        goto switch_break___1;
        case_0___0: /* CIL Label */ 
        {
#line 1662
        DisplayCoords(current_plot, (char const   *)(buf + 5));
        }
#line 1663
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
        {
#line 1665
        second = strchr((char const   *)(buf + 5), '\r');
        }
#line 1666
        if ((unsigned long )second == (unsigned long )((void *)0)) {
#line 1667
          current_plot->zoombox_str1a[0] = (char )'\000';
#line 1668
          current_plot->zoombox_str1b[0] = (char )'\000';
#line 1669
          goto switch_break___1;
        }
#line 1671
        *second = (char)0;
#line 1672
        second ++;
#line 1673
        if (current_plot->zoombox_on) {
          {
#line 1674
          DrawBox(current_plot);
          }
        }
        {
#line 1675
        strcpy((char */* __restrict  */)(current_plot->zoombox_str1a), (char const   */* __restrict  */)(buf + 5));
#line 1676
        strcpy((char */* __restrict  */)(current_plot->zoombox_str1b), (char const   */* __restrict  */)second);
        }
#line 1677
        if (current_plot->zoombox_on) {
          {
#line 1678
          DrawBox(current_plot);
          }
        }
#line 1679
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
        {
#line 1681
        second = strchr((char const   *)(buf + 5), '\r');
        }
#line 1682
        if ((unsigned long )second == (unsigned long )((void *)0)) {
#line 1683
          current_plot->zoombox_str2a[0] = (char )'\000';
#line 1684
          current_plot->zoombox_str2b[0] = (char )'\000';
#line 1685
          goto switch_break___1;
        }
#line 1687
        *second = (char)0;
#line 1688
        second ++;
#line 1689
        if (current_plot->zoombox_on) {
          {
#line 1690
          DrawBox(current_plot);
          }
        }
        {
#line 1691
        strcpy((char */* __restrict  */)(current_plot->zoombox_str2a), (char const   */* __restrict  */)(buf + 5));
#line 1692
        strcpy((char */* __restrict  */)(current_plot->zoombox_str2b), (char const   */* __restrict  */)second);
        }
#line 1693
        if (current_plot->zoombox_on) {
          {
#line 1694
          DrawBox(current_plot);
          }
        }
#line 1695
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1699
    return (1);
    case_114: /* CIL Label */ 
#line 1703
    if (! pipe_died) {
#line 1706
      if (current_plot) {
        {
#line 1708
        DrawRuler(current_plot);
#line 1709
        sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r%4d%4d",
               & x___0, & y___0);
        }
#line 1710
        if (x___0 < 0) {
          {
#line 1711
          DrawLineToRuler(current_plot);
#line 1712
          current_plot->ruler_on = (_Bool)0;
          }
        } else {
          {
#line 1714
          current_plot->ruler_on = (_Bool)1;
#line 1715
          current_plot->ruler_x = x___0;
#line 1716
          current_plot->ruler_y = y___0;
#line 1717
          current_plot->ruler_lineto_x = (int )((double )x___0 * xscale);
#line 1718
          current_plot->ruler_lineto_y = (int )((double )(4095 - y___0) * yscale);
#line 1719
          DrawLineToRuler(current_plot);
          }
        }
        {
#line 1721
        DrawRuler(current_plot);
        }
      }
    }
#line 1724
    return (1);
    case_122: /* CIL Label */ 
#line 1728
    if (! pipe_died) {
      {
#line 1731
      tmp___20 = strlen((char const   *)(buf + 1));
#line 1731
      len = (int )(tmp___20 - 1UL);
      }
#line 1732
      if (len < 255) {
#line 1732
        tmp___21 = len;
      } else {
#line 1732
        tmp___21 = 255;
      }
      {
#line 1732
      memcpy((void */* __restrict  */)(selection), (void const   */* __restrict  */)(buf + 1),
             (size_t )tmp___21);
      }
#line 1734
      if (len + 1 < 255) {
#line 1734
        tmp___22 = len + 1;
      } else {
#line 1734
        tmp___22 = 254;
      }
      {
#line 1734
      selection[tmp___22] = (char )'\000';
#line 1735
      XStoreBytes(dpy, (char const   *)(buf + 1), len);
#line 1736
      XFlush(dpy);
      }
#line 1738
      if (current_plot) {
#line 1738
        if (exportselection) {
          {
#line 1739
          export_graph(current_plot);
          }
        }
      }
    }
#line 1742
    return (1);
    case_81: /* CIL Label */ 
#line 1747
    if ((int )buf[1] == 71) {
      {
#line 1749
      tmp___23 = strlen((char const   *)(buf));
#line 1749
      c___0 = & buf[tmp___23 - 1UL];
      }
      {
#line 1750
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1750
        if (! ((int )*c___0 <= 32)) {
#line 1750
          goto while_break___5;
        }
#line 1750
        tmp___24 = c___0;
#line 1750
        c___0 --;
#line 1750
        *tmp___24 = (char )'\000';
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1751
      tmp___25 = strlen((char const   *)(& buf[2]));
#line 1751
      strncpy((char */* __restrict  */)(default_font), (char const   */* __restrict  */)(& buf[2]),
              tmp___25 + 1UL);
#line 1752
      pr_font((char *)((void *)0));
      }
#line 1753
      if (current_plot) {
#line 1756
        if (current_plot->width > 0U) {
#line 1756
          xscale = (double )current_plot->width / 4096.;
        } else {
#line 1756
          xscale = (double )gW / 4096.;
        }
#line 1757
        if (current_plot->height > 0U) {
#line 1757
          yscale = (double )current_plot->height / 4096.;
        } else {
#line 1757
          yscale = (double )gH / 4096.;
        }
        {
#line 1758
        scaled_hchar = (int )((1.0 / xscale) * (double )hchar);
#line 1759
        scaled_vchar = (int )((1.0 / yscale) * (double )vchar);
#line 1762
        gp_exec_event((char)11, (int )current_plot->width, (int )current_plot->height,
                      scaled_hchar, scaled_vchar, 0);
        }
      }
#line 1765
      return (1);
    }
    switch_default: /* CIL Label */ 
#line 1770
    if (current_plot) {
      {
#line 1771
      store_command(buf, current_plot);
      }
    }
#line 1772
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1775
  tmp___26 = feof(X11_ipc);
  }
#line 1775
  if (tmp___26) {
#line 1776
    return (0);
  } else {
    {
#line 1775
    tmp___27 = ferror(X11_ipc);
    }
#line 1775
    if (tmp___27) {
#line 1776
      return (0);
    } else {
#line 1778
      return (1);
    }
  }
}
}
#line 1842 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int DrawRotatedErrorHandler(Display *display___0 , XErrorEvent *error_event ) 
{ 


  {
#line 1845
  return (0);
}
}
#line 1863 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static double const   deg2rad  =    (double const   ).01745329251994329576;
#line 1888 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static GC bitmapGC  =    (GC )0;
#line 1848 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DrawRotated(plot_struct *plot , Display *dpy___0 , GC gc___0 , int xdest ,
                        int ydest , char const   *str , int len ) 
{ 
  Window w ;
  Drawable d ;
  double angle___0 ;
  enum JUSTIFY just ;
  int x ;
  int y ;
  double src_x ;
  double src_y ;
  double dest_x ;
  double dest_y ;
  int width ;
  int tmp ;
  int height ;
  double src_cen_x ;
  double src_cen_y ;
  double sa ;
  double tmp___0 ;
  double ca ;
  double tmp___1 ;
  int dest_width ;
  double tmp___2 ;
  double tmp___3 ;
  int dest_height ;
  double tmp___4 ;
  double tmp___5 ;
  double dest_cen_x ;
  double dest_cen_y ;
  char *data ;
  void *tmp___6 ;
  Pixmap pixmap_src ;
  Pixmap tmp___7 ;
  XImage *image_src ;
  XImage *image_dest ;
  XImage *image_scr ;
  unsigned long fgpixel ;
  unsigned long bgpixel ;
  XWindowAttributes win_attrib ;
  int xscr ;
  int yscr ;
  int xoff ;
  int yoff ;
  unsigned int scr_width ;
  unsigned int scr_height ;
  int (*prevErrorHandler)(Display * , XErrorEvent * ) ;
  unsigned long gcFunctionMask ;
  XGCValues gcValues ;
  int gcCurrentFunction ;
  int s ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;

  {
  {
#line 1852
  w = plot->window;
#line 1853
  d = plot->pixmap;
#line 1854
  angle___0 = plot->angle;
#line 1855
  just = plot->jmode;
#line 1859
  tmp = gpXTextWidth(font, str, len);
#line 1859
  width = tmp;
#line 1860
  height = vchar;
#line 1861
  src_cen_x = (double )width * 0.5;
#line 1862
  src_cen_y = (double )height * 0.5;
#line 1864
  tmp___0 = sin(angle___0 * (double )deg2rad);
#line 1864
  sa = tmp___0;
#line 1865
  tmp___1 = cos(angle___0 * (double )deg2rad);
#line 1865
  ca = tmp___1;
#line 1866
  tmp___2 = fabs(sa);
#line 1866
  tmp___3 = fabs(ca);
#line 1866
  dest_width = (int )(((double )height * tmp___2 + (double )width * tmp___3) + (double )2);
#line 1867
  tmp___4 = fabs(sa);
#line 1867
  tmp___5 = fabs(ca);
#line 1867
  dest_height = (int )(((double )width * tmp___4 + (double )height * tmp___5) + (double )2);
#line 1868
  dest_cen_x = (double )dest_width * 0.5;
#line 1869
  dest_cen_y = (double )dest_height * 0.5;
#line 1870
  tmp___6 = malloc((unsigned long )(dest_width * dest_height) * sizeof(char ));
#line 1870
  data = (char *)tmp___6;
#line 1871
  tmp___7 = XCreatePixmap(dpy___0, root, (unsigned int )width, (unsigned int )height,
                          1U);
#line 1871
  pixmap_src = tmp___7;
#line 1875
  fgpixel = 0UL;
#line 1876
  bgpixel = 0UL;
#line 1882
  gcFunctionMask = 1UL;
#line 1884
  gcCurrentFunction = 0;
  }
#line 1891
  if ((unsigned long )((GC )0) == (unsigned long )bitmapGC) {
    {
#line 1892
    bitmapGC = XCreateGC(dpy___0, pixmap_src, 0UL, (XGCValues *)0);
#line 1893
    XSetForeground(dpy___0, bitmapGC, 1UL);
#line 1894
    XSetBackground(dpy___0, bitmapGC, 0UL);
    }
  }
  {
#line 1897
  s = XGetGCValues(dpy___0, gc___0, (gcFunctionMask | (unsigned long )(1L << 2)) | (unsigned long )(1L << 3),
                   & gcValues);
  }
#line 1898
  if (s) {
#line 1900
    fgpixel = gcValues.foreground;
#line 1901
    bgpixel = gcValues.background;
#line 1902
    gcCurrentFunction = gcValues.function;
  }
#line 1906
  if (font) {
    {
#line 1907
    gpXSetFont(dpy___0, bitmapGC, font->fid);
    }
  }
  {
#line 1910
  tmp___8 = gpXGetFontascent(font);
#line 1910
  gpXDrawImageString(dpy___0, pixmap_src, bitmapGC, 0, tmp___8, str, len);
#line 1914
  image_src = XGetImage(dpy___0, pixmap_src, 0, 0, (unsigned int )width, (unsigned int )height,
                        1UL, 1);
  }
#line 1918
  if (! data) {
    {
#line 1918
    __assert_fail("data", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
                  1918U, "DrawRotated");
    }
  }
  {
#line 1919
  memset((void *)data, 0, (size_t )dest_width * (size_t )dest_height);
#line 1920
  image_dest = XCreateImage(dpy___0, vis, 1U, 0, 0, data, (unsigned int )dest_width,
                            (unsigned int )dest_height, 8, 0);
#line 1926
  y = 0;
#line 1926
  src_y = - src_cen_y;
  }
  {
#line 1926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1926
    if (! (y < height)) {
#line 1926
      goto while_break;
    }
#line 1927
    x = 0;
#line 1927
    src_x = - src_cen_x;
    {
#line 1927
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1927
      if (! (x < width)) {
#line 1927
        goto while_break___0;
      }
      {
#line 1929
      dest_x = rint((src_x * ca + src_y * sa) + dest_cen_x);
#line 1930
      dest_y = rint((- src_x * sa + src_y * ca) + dest_cen_y);
      }
#line 1931
      if (dest_x >= (double )0) {
#line 1931
        if (dest_x < (double )dest_width) {
#line 1931
          if (dest_y >= (double )0) {
#line 1931
            if (dest_y < (double )dest_height) {
              {
#line 1932
              tmp___9 = (*(image_src->f.get_pixel))(image_src, x, y);
#line 1932
              (*(image_dest->f.put_pixel))(image_dest, (int )dest_x, (int )dest_y,
                                           tmp___9);
              }
            }
          }
        }
      }
#line 1927
      x ++;
#line 1927
      src_x += (double )1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1926
    y ++;
#line 1926
    src_y += (double )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1936
  src_cen_y = (double )0;
  {
#line 1944
  if ((unsigned int )just == 1U) {
#line 1944
    goto case_1;
  }
#line 1948
  if ((unsigned int )just == 2U) {
#line 1948
    goto case_2;
  }
#line 1940
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1941
  xdest = (int )((double )xdest - ((- src_cen_x * ca + src_cen_y * sa) + dest_cen_x));
#line 1942
  ydest = (int )((double )ydest - ((- (- src_cen_x) * sa + src_cen_y * ca) + dest_cen_y));
#line 1943
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1945
  xdest = (int )((double )xdest - (((double )0 * ca + src_cen_y * sa) + dest_cen_x));
#line 1946
  ydest = (int )((double )ydest - (((double )0 * sa + src_cen_y * ca) + dest_cen_y));
#line 1947
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1949
  xdest = (int )((double )xdest - ((src_cen_x * ca + src_cen_y * sa) + dest_cen_x));
#line 1950
  ydest = (int )((double )ydest - ((- src_cen_x * sa + src_cen_y * ca) + dest_cen_y));
#line 1951
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1957
  if (fast_rotate) {
#line 1962
    if (! s) {
      {
#line 1962
      __assert_fail("s", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
                    1962U, "DrawRotated");
      }
    }
    {
#line 1964
    gcValues.function = 1;
#line 1965
    gcValues.background = (((_XPrivDisplay )dpy___0)->screens + scr)->white_pixel;
#line 1966
    gcValues.foreground = (((_XPrivDisplay )dpy___0)->screens + scr)->black_pixel;
#line 1967
    XChangeGC(dpy___0, gc___0, (gcFunctionMask | (unsigned long )(1L << 3)) | (unsigned long )(1L << 2),
              & gcValues);
#line 1968
    XPutImage(dpy___0, d, gc___0, image_dest, 0, 0, xdest, ydest, (unsigned int )dest_width,
              (unsigned int )dest_height);
#line 1971
    gcValues.function = 7;
#line 1972
    gcValues.background = (((_XPrivDisplay )dpy___0)->screens + scr)->black_pixel;
#line 1973
    gcValues.foreground = fgpixel;
#line 1974
    XChangeGC(dpy___0, gc___0, (gcFunctionMask | (unsigned long )(1L << 3)) | (unsigned long )(1L << 2),
              & gcValues);
#line 1975
    XPutImage(dpy___0, d, gc___0, image_dest, 0, 0, xdest, ydest, (unsigned int )dest_width,
              (unsigned int )dest_height);
    }
  } else {
#line 1983
    if (! s) {
      {
#line 1983
      __assert_fail("s", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
                    1983U, "DrawRotated");
      }
    }
    {
#line 1984
    gcValues.function = 3;
#line 1985
    XChangeGC(dpy___0, gc___0, gcFunctionMask, & gcValues);
#line 1986
    s = XGetWindowAttributes(dpy___0, w, & win_attrib);
    }
#line 1988
    if (xdest < 0) {
#line 1988
      xscr = 0;
    } else {
#line 1988
      xscr = xdest;
    }
#line 1989
    if (ydest < 0) {
#line 1989
      yscr = 0;
    } else {
#line 1989
      yscr = ydest;
    }
#line 1990
    scr_width = (unsigned int )dest_width;
#line 1990
    scr_height = (unsigned int )dest_height;
#line 1991
    if (xscr + dest_width > win_attrib.width) {
#line 1992
      scr_width = (unsigned int )(win_attrib.width - xscr);
    }
#line 1993
    if (yscr + dest_height > win_attrib.height) {
#line 1994
      scr_height = (unsigned int )(win_attrib.height - yscr);
    }
    {
#line 1995
    xoff = xscr - xdest;
#line 1996
    yoff = yscr - ydest;
#line 1997
    scr_width -= (unsigned int )xoff;
#line 1998
    scr_height -= (unsigned int )yoff;
#line 1999
    prevErrorHandler = XSetErrorHandler(& DrawRotatedErrorHandler);
#line 2001
    image_scr = XGetImage(dpy___0, d, xscr, yscr, scr_width, scr_height, (unsigned long )(~ 0L),
                          1);
    }
#line 2003
    if ((unsigned long )image_scr != (unsigned long )((XImage *)0)) {
#line 2005
      y = 0;
      {
#line 2005
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2005
        if (! ((unsigned int )y < scr_height)) {
#line 2005
          goto while_break___1;
        }
#line 2006
        x = 0;
        {
#line 2006
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2006
          if (! ((unsigned int )x < scr_width)) {
#line 2006
            goto while_break___2;
          }
          {
#line 2007
          tmp___10 = (*(image_dest->f.get_pixel))(image_dest, x + xoff, y + yoff);
          }
#line 2007
          if (tmp___10) {
            {
#line 2008
            (*(image_scr->f.put_pixel))(image_scr, x, y, fgpixel);
            }
          }
#line 2006
          x ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 2005
        y ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2013
      XPutImage(dpy___0, d, gc___0, image_scr, 0, 0, xscr, yscr, scr_width, scr_height);
#line 2015
      (*(image_scr->f.destroy_image))(image_scr);
      }
    }
    {
#line 2017
    XSetErrorHandler(prevErrorHandler);
    }
  }
  {
#line 2021
  XFreePixmap(dpy___0, pixmap_src);
#line 2022
  (*(image_src->f.destroy_image))(image_src);
#line 2023
  (*(image_dest->f.destroy_image))(image_dest);
  }
#line 2025
  if (s) {
    {
#line 2027
    gcValues.function = gcCurrentFunction;
#line 2028
    gcValues.background = bgpixel;
#line 2029
    XChangeGC(dpy___0, gc___0, gcFunctionMask | (unsigned long )(1L << 3), & gcValues);
    }
  }
#line 2031
  return;
}
}
#line 2510 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XPoint *points  =    (XPoint *)((void *)0);
#line 2511 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int st_npoints  =    0;
#line 2512 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int saved_npoints  =    -1;
#line 2512 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int saved_i  =    -1;
#line 2582 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool transferring  =    (_Bool)0;
#line 2583 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned char *iptr___0  ;
#line 2584 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int int_cache[2]  ;
#line 2585 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int i_remaining___0  ;
#line 2588 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool code_detected___0  =    (_Bool)0;
#line 2589 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XPoint *points___0  =    (XPoint *)((void *)0);
#line 2590 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int st_npoints___0  =    0;
#line 2591 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int npoints___0  =    0;
#line 2591 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int style___1  =    0;
#line 2683 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned char *iptr___1  ;
#line 2684 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool transferring___0  =    (_Bool)0;
#line 2685 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short *image  ;
#line 2686 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int M  ;
#line 2686 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int N  ;
#line 2687 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int pixel_1_1_x  ;
#line 2687 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int pixel_1_1_y  ;
#line 2687 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int pixel_M_N_x  ;
#line 2687 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int pixel_M_N_y  ;
#line 2688 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int visual_1_1_x  ;
#line 2688 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int visual_1_1_y  ;
#line 2688 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int visual_M_N_x  ;
#line 2688 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int visual_M_N_y  ;
#line 2689 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int color_mode  ;
#line 2690 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned int i_remaining___1  ;
#line 2733 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool code_detected___1  =    (_Bool)0;
#line 2758 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short R_msb_mask  =    (unsigned short)0;
#line 2758 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short R_rshift  ;
#line 2758 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short R_lshift  ;
#line 2759 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short G_msb_mask  ;
#line 2759 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short G_rshift  ;
#line 2759 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short G_lshift  ;
#line 2760 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short B_msb_mask  ;
#line 2760 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short B_rshift  ;
#line 2760 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short B_lshift  ;
#line 2761 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long prev_red_mask  ;
#line 2761 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long prev_green_mask  ;
#line 2761 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long prev_blue_mask  ;
#line 2813 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *display_error_text_after  =    (char *)" display class cannot use component\n                     data.  Try palette mode.\n\n";
#line 2036 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void exec_cmd(plot_struct *plot , char *command ) 
{ 
  int x ;
  int y ;
  int sw ;
  int sl ;
  int sj ;
  char *buffer ;
  char *str ;
  void *tmp ;
  char *c ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int x_offset ;
  int y_offset ;
  int v_offset ;
  int xtmp ;
  int ytmp ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  size_t tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  int style ;
  int xtmp___0 ;
  int ytmp___0 ;
  int w ;
  int h ;
  int tmp___13 ;
  size_t tmp___14 ;
  int point ;
  unsigned char fill ;
  unsigned char upside_down_fill ;
  short upside_down_sign ;
  int delta ;
  short temp_x ;
  short temp_y ;
  int lt ;
  int rgb255color ;
  XColor xcolor ;
  int tmp___15 ;
  double gray ;
  unsigned char *iptr ;
  float gray___0 ;
  unsigned int i_remaining ;
  char *bptr ;
  _Bool code_detected ;
  unsigned char uctmp ;
  char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  int i ;
  int npoints ;
  int style___0 ;
  char *ptr ;
  XPoint *new_points ;
  void *tmp___19 ;
  unsigned short i_buffer ;
  char *bptr___0 ;
  unsigned char uctmp___0 ;
  char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  XPoint *new_points___0 ;
  void *tmp___23 ;
  int i___0 ;
  void *tmp___24 ;
  int tmp___25 ;
  unsigned short i_buffer___0 ;
  char *bptr___1 ;
  unsigned char uctmp___1 ;
  char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  _Bool create_image ;
  int i___1 ;
  short R_bits ;
  short G_bits ;
  short B_bits ;
  short min_bits ;
  int tmp___30 ;
  int tmp___31 ;
  int M_pixel ;
  int N_pixel ;
  int M_view ;
  int N_view ;
  int pixel_1_1_x_plot ;
  int pixel_1_1_y_plot ;
  int pixel_M_N_x_plot ;
  int pixel_M_N_y_plot ;
  int view_1_1_x_plot ;
  int view_1_1_y_plot ;
  int view_M_N_x_plot ;
  int view_M_N_y_plot ;
  int final_1_1_x_plot ;
  int final_1_1_y_plot ;
  int i_start ;
  int j_start ;
  int itmp ;
  char *sample_data ;
  short sample_data_size ;
  int i_view ;
  int j_view ;
  void *tmp___32 ;
  XImage *image_src ;
  XImage *image_dest ;
  int j ;
  int row_start ;
  int i___2 ;
  unsigned long pixel ;
  unsigned short index___0 ;
  int index3 ;
  unsigned long pixel___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int index4 ;
  double alpha ;
  unsigned long pixel___1 ;
  unsigned long tmp___35 ;
  unsigned int red ;
  unsigned int green ;
  unsigned int blue ;
  int tmp___36 ;
  int tmp___37 ;
  int axis ;
  int axis_mask ;
  int cm_index ;
  int i___3 ;
  cmap_struct *csp ;

  {
#line 2042
  buffer = command;
#line 2046
  if ((int )*buffer == 86) {
    {
#line 2047
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"V%4d%4d",
           & x, & y);
    }
#line 2048
    if (polyline_size == 0) {
#line 2049
      (polyline + polyline_size)->x = (short )((int )((double )cx * xscale));
#line 2050
      (polyline + polyline_size)->y = (short )((int )((double )(4095 - cy) * yscale));
    }
#line 2052
    polyline_size ++;
#line 2052
    if (polyline_size >= polyline_space) {
      {
#line 2053
      polyline_space += 100;
#line 2054
      tmp = realloc((void *)polyline, (unsigned long )polyline_space * sizeof(XPoint ));
#line 2054
      polyline = (XPoint *)tmp;
      }
#line 2055
      if (! polyline) {
        {
#line 2055
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Panic: cannot realloc polyline\n");
        }
      }
    }
#line 2057
    (polyline + polyline_size)->x = (short )((int )((double )x * xscale));
#line 2058
    (polyline + polyline_size)->y = (short )((int )((double )(4095 - y) * yscale));
#line 2059
    cx = x;
#line 2060
    cy = y;
#line 2062
    if ((long )polyline_size > max_request_size) {
      {
#line 2064
      XDrawLines(dpy, plot->pixmap, *current_gc, polyline, polyline_size + 1, 0);
#line 2066
      polyline_size = 0;
      }
    }
#line 2068
    return;
  } else
#line 2069
  if (polyline_size > 0) {
    {
#line 2071
    XDrawLines(dpy, plot->pixmap, *current_gc, polyline, polyline_size + 1, 0);
#line 2073
    polyline_size = 0;
    }
  }
#line 2085
  if ((int )*buffer == 77) {
    {
#line 2086
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"M%4d%4d",
           & cx, & cy);
    }
  } else
#line 2089
  if ((int )*buffer == 81) {
    {
#line 2092
    if ((int )*(buffer + 1) == 70) {
#line 2092
      goto case_70;
    }
#line 2100
    if ((int )*(buffer + 1) == 69) {
#line 2100
      goto case_69;
    }
#line 2109
    if ((int )*(buffer + 1) == 68) {
#line 2109
      goto case_68;
    }
#line 2091
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 2094
    tmp___0 = strlen((char const   *)buffer);
#line 2094
    c = buffer + (tmp___0 - 1UL);
    }
    {
#line 2095
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2095
      if (! ((int )*c <= 32)) {
#line 2095
        goto while_break;
      }
#line 2095
      tmp___1 = c;
#line 2095
      c --;
#line 2095
      *tmp___1 = (char )'\000';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2096
    pr_font(buffer + 2);
    }
#line 2097
    if (font) {
      {
#line 2098
      gpXSetFont(dpy, gc, font->fid);
      }
    }
#line 2099
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 2104
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"QE%d",
           & tmp___2);
#line 2105
    encoding = (enum set_encoding_id )tmp___2;
    }
#line 2108
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 2111
    tmp___3 = strlen((char const   *)buffer);
#line 2111
    c = buffer + (tmp___3 - 1UL);
    }
    {
#line 2112
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2112
      if (! ((int )*c <= 32)) {
#line 2112
        goto while_break___0;
      }
#line 2112
      tmp___4 = c;
#line 2112
      c --;
#line 2112
      *tmp___4 = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2113
    tmp___5 = strlen((char const   *)(buffer + 2));
#line 2113
    strncpy((char */* __restrict  */)(default_font), (char const   */* __restrict  */)(buffer + 2),
            tmp___5 + 1UL);
    }
#line 2115
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 2120
  if ((int )*buffer == 84) {
#line 2122
    x_offset = 0;
#line 2122
    y_offset = 0;
#line 2122
    v_offset = 0;
    {
#line 2126
    if ((int )*(buffer + 1) == 106) {
#line 2126
      goto case_106;
    }
#line 2131
    if ((int )*(buffer + 1) == 107) {
#line 2131
      goto case_107;
    }
#line 2136
    if ((int )*(buffer + 1) == 108) {
#line 2136
      goto case_108;
    }
#line 2144
    if ((int )*(buffer + 1) == 115) {
#line 2144
      goto case_115;
    }
#line 2144
    if ((int )*(buffer + 1) == 117) {
#line 2144
      goto case_115;
    }
#line 2144
    if ((int )*(buffer + 1) == 99) {
#line 2144
      goto case_115;
    }
#line 2144
    if ((int )*(buffer + 1) == 111) {
#line 2144
      goto case_115;
    }
#line 2160
    if ((int )*(buffer + 1) == 112) {
#line 2160
      goto case_112;
    }
#line 2164
    if ((int )*(buffer + 1) == 114) {
#line 2164
      goto case_114;
    }
#line 2168
    goto switch_default;
    case_106: /* CIL Label */ 
    {
#line 2127
    sscanf((char const   */* __restrict  */)(buffer + 2), (char const   */* __restrict  */)"%4d%4d",
           & x_offset, & y_offset);
#line 2128
    plot->xLast = x_offset - (plot->xLast - x_offset);
#line 2129
    plot->yLast = (int )((double )y_offset - (double )(vchar / 3) / yscale);
    }
#line 2130
    return;
    case_107: /* CIL Label */ 
    {
#line 2132
    sscanf((char const   */* __restrict  */)(buffer + 2), (char const   */* __restrict  */)"%4d%4d",
           & x_offset, & y_offset);
#line 2133
    plot->xLast = (int )((double )x_offset - 0.5 * (double )(plot->xLast - x_offset));
#line 2134
    plot->yLast = (int )((double )y_offset - (double )(vchar / 3) / yscale);
    }
#line 2135
    return;
    case_108: /* CIL Label */ 
    {
#line 2137
    sscanf((char const   */* __restrict  */)(buffer + 2), (char const   */* __restrict  */)"%4d%4d",
           & x_offset, & y_offset);
#line 2138
    plot->xLast = x_offset;
#line 2139
    plot->yLast = (int )((double )y_offset - (double )(vchar / 3) / yscale);
    }
#line 2140
    return;
    case_115: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_111: /* CIL Label */ 
    {
#line 2145
    sscanf((char const   */* __restrict  */)(buffer + 2), (char const   */* __restrict  */)"%4d%4d",
           & x_offset, & y_offset);
    }
#line 2147
    if (plot->angle != (double )0) {
      {
#line 2148
      xtmp = 0;
#line 2148
      ytmp = 0;
#line 2149
      tmp___6 = cos(plot->angle * 0.01745);
#line 2149
      xtmp = (int )((double )xtmp + (double )x_offset * tmp___6);
#line 2150
      tmp___7 = sin(plot->angle * 0.01745);
#line 2150
      xtmp = (int )((double )xtmp - (((double )y_offset * tmp___7) * yscale) / xscale);
#line 2151
      tmp___8 = sin(plot->angle * 0.01745);
#line 2151
      ytmp = (int )((double )ytmp + (((double )x_offset * tmp___8) * xscale) / yscale);
#line 2152
      tmp___9 = cos(plot->angle * 0.01745);
#line 2152
      ytmp = (int )((double )ytmp + (double )y_offset * tmp___9);
#line 2153
      x_offset = xtmp;
#line 2154
      y_offset = ytmp;
      }
    }
#line 2156
    x = plot->xLast + x_offset;
#line 2157
    y = plot->yLast + y_offset;
#line 2158
    str = buffer + 10;
#line 2159
    goto switch_break___0;
    case_112: /* CIL Label */ 
#line 2161
    plot->xSave = plot->xLast;
#line 2162
    plot->ySave = plot->yLast;
#line 2163
    return;
    case_114: /* CIL Label */ 
#line 2165
    plot->xLast = plot->xSave;
#line 2166
    plot->yLast = plot->ySave;
#line 2167
    return;
    switch_default: /* CIL Label */ 
    {
#line 2169
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"T%4d%4d",
           & x, & y);
#line 2170
    v_offset = vchar / 3;
#line 2171
    str = buffer + 9;
    }
#line 2172
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2175
    tmp___10 = strlen((char const   *)str);
#line 2175
    sl = (int )(tmp___10 - 1UL);
#line 2176
    sw = gpXTextWidth(font, (char const   *)str, sl);
    }
    {
#line 2189
    if ((unsigned int )plot->jmode == 1U) {
#line 2189
      goto case_1;
    }
#line 2192
    if ((unsigned int )plot->jmode == 2U) {
#line 2192
      goto case_2;
    }
#line 2185
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 2187
    sj = 0;
#line 2188
    goto switch_break___1;
    case_1: /* CIL Label */ 
#line 2190
    sj = - sw / 2;
#line 2191
    goto switch_break___1;
    case_2: /* CIL Label */ 
#line 2193
    sj = - sw;
#line 2194
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 2197
    if (! (sl == 0)) {
#line 2199
      if (! ((int )*(buffer + 1) == 115)) {
#line 2201
        if (plot->angle != (double )0) {
          {
#line 2203
          DrawRotated(plot, dpy, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale),
                      (char const   *)str, sl);
          }
        } else {
          {
#line 2206
          gpXDrawString(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale) + sj,
                        (int )((double )(4095 - y) * yscale) + v_offset, (char const   *)str,
                        sl);
          }
        }
      }
    }
#line 2211
    if ((int )*(buffer + 1) == 99) {
#line 2212
      plot->xLast = (int )(((double )(((int )((double )x * xscale) + sj) + sw / 2) + 0.5) / xscale - (double )x_offset);
#line 2213
      plot->yLast = y - y_offset;
    } else
#line 2214
    if ((int )*(buffer + 1) != 111) {
#line 2215
      plot->xLast = (int )(((double )(((int )((double )x * xscale) + sj) + sw) + 0.5) / xscale - (double )x_offset);
#line 2216
      plot->yLast = y - y_offset;
#line 2217
      if (plot->angle != (double )0) {
        {
#line 2218
        tmp___11 = sin(plot->angle * 0.01745);
#line 2218
        plot->yLast = (int )((double )plot->yLast + (((((double )sw + 0.5) / xscale) * tmp___11) * xscale) / yscale);
#line 2219
        tmp___12 = cos(plot->angle * 0.01745);
#line 2219
        plot->xLast = (int )((double )plot->xLast - (((double )sw + 0.5) / xscale) * (1.0 - tmp___12));
        }
      }
    }
  } else
#line 2223
  if ((int )*buffer == 70) {
    {
#line 2226
    tmp___13 = sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%4d%4d%4d%4d%4d",
                      & style, & xtmp___0, & ytmp___0, & w, & h);
    }
#line 2226
    if (tmp___13 == 5) {
#line 2229
      if (! fill_gc) {
        {
#line 2230
        fill_gc = XCreateGC(dpy, plot->window, 0UL, (XGCValues *)0);
        }
      }
      {
#line 2231
      XCopyGC(dpy, *current_gc, (unsigned long )(~ 0), fill_gc);
#line 2232
      x11_setfill(& fill_gc, style);
#line 2237
      ytmp___0 += h;
#line 2238
      w = (int )((double )w * xscale);
#line 2239
      h = (int )((double )h * yscale);
#line 2240
      XFillRectangle(dpy, plot->pixmap, fill_gc, (int )((double )xtmp___0 * xscale),
                     (int )((double )(4095 - ytmp___0) * yscale), (unsigned int )(w + 1),
                     (unsigned int )(h + 1));
      }
    }
  } else
#line 2244
  if ((int )*buffer == 74) {
    {
#line 2245
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"J%4d",
           (int *)(& plot->jmode));
    }
  } else
#line 2247
  if ((int )*buffer == 65) {
    {
#line 2248
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%lf",
           & plot->angle);
    }
  } else
#line 2251
  if ((int )*buffer == 87) {
    {
#line 2252
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%4d",
           & plot->user_width);
    }
  } else
#line 2255
  if ((int )*buffer == 76) {
    {
#line 2256
    sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"L%4d",
           & plot->lt);
#line 2257
    plot->lt = plot->lt % 8 + 2;
    }
#line 2260
    if (plot->lt < 0) {
#line 2261
      plot->lt = -3;
#line 2262
      plot->lwidth = plot->user_width;
    } else {
#line 2266
      if (widths[plot->lt]) {
#line 2266
        plot->lwidth = (int )((unsigned int )plot->user_width * widths[plot->lt]);
      } else {
#line 2266
        plot->lwidth = plot->user_width;
      }
#line 2268
      if (dashedlines) {
#line 2268
        if (dashes[plot->lt][0]) {
          {
#line 2270
          plot->type = 1;
#line 2271
          tmp___14 = strlen((char const   *)(dashes[plot->lt]));
#line 2271
          XSetDashes(dpy, gc, 0, (char const   *)(dashes[plot->lt]), (int )tmp___14);
          }
        } else {
#line 2268
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2268
      if (plot->lt == 1) {
#line 2268
        if (dashes[1][0]) {
          {
#line 2270
          plot->type = 1;
#line 2271
          tmp___14 = strlen((char const   *)(dashes[plot->lt]));
#line 2271
          XSetDashes(dpy, gc, 0, (char const   *)(dashes[plot->lt]), (int )tmp___14);
          }
        } else {
#line 2273
          plot->type = 0;
        }
      } else {
#line 2273
        plot->type = 0;
      }
    }
    {
#line 2277
    XSetForeground(dpy, gc, (plot->cmap)->colors[plot->lt + 3]);
#line 2278
    XSetLineAttributes(dpy, gc, (unsigned int )plot->lwidth, plot->type, 1, 2);
#line 2279
    plot->current_rgb = (plot->cmap)->rgbcolors[plot->lt + 3];
#line 2280
    current_gc = & gc;
    }
  } else
#line 2283
  if ((int )*buffer == 80) {
    {
#line 2285
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%d %d %d",
           & point, & x, & y);
    }
#line 2286
    if (point == -2) {
#line 2288
      plot->px = (unsigned int )((int )(((double )x * xscale) * pointsize));
#line 2289
      plot->py = (unsigned int )((int )(((double )y * yscale) * pointsize));
    } else
#line 2290
    if (point == -1) {
      {
#line 2292
      XDrawPoint(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale));
      }
    } else {
      {
#line 2294
      fill = (unsigned char)0;
#line 2295
      upside_down_fill = (unsigned char)0;
#line 2296
      upside_down_sign = (short)1;
#line 2297
      delta = (int )(((plot->px + plot->py) + 1U) / 2U);
#line 2300
      XSetLineAttributes(dpy, *current_gc, (unsigned int )plot->lwidth, 0, 2, 1);
      }
      {
#line 2303
      if (point % 13 == 0) {
#line 2303
        goto case_0;
      }
#line 2315
      if (point % 13 == 1) {
#line 2315
        goto case_1___0;
      }
#line 2327
      if (point % 13 == 2) {
#line 2327
        goto case_2___0;
      }
#line 2347
      if (point % 13 == 3) {
#line 2347
        goto case_3;
      }
#line 2352
      if (point % 13 == 4) {
#line 2352
        goto case_4;
      }
#line 2356
      if (point % 13 == 5) {
#line 2356
        goto case_5;
      }
#line 2361
      if (point % 13 == 6) {
#line 2361
        goto case_6;
      }
#line 2365
      if (point % 13 == 10) {
#line 2365
        goto case_10;
      }
#line 2368
      if (point % 13 == 9) {
#line 2368
        goto case_9;
      }
#line 2370
      if (point % 13 == 8) {
#line 2370
        goto case_8;
      }
#line 2373
      if (point % 13 == 7) {
#line 2373
        goto case_7;
      }
#line 2398
      if (point % 13 == 12) {
#line 2398
        goto case_12;
      }
#line 2401
      if (point % 13 == 11) {
#line 2401
        goto case_11;
      }
#line 2302
      goto switch_break___2;
      case_0: /* CIL Label */ 
      {
#line 2304
      Plus[0].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2305
      Plus[0].y1 = (short )((int )((double )(4095 - y) * yscale));
#line 2306
      Plus[0].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2307
      Plus[0].y2 = (short )((int )((double )(4095 - y) * yscale));
#line 2308
      Plus[1].x1 = (short )((int )((double )x * xscale));
#line 2309
      Plus[1].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2310
      Plus[1].x2 = (short )((int )((double )x * xscale));
#line 2311
      Plus[1].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2313
      XDrawSegments(dpy, plot->pixmap, *current_gc, Plus, 2);
      }
#line 2314
      goto switch_break___2;
      case_1___0: /* CIL Label */ 
      {
#line 2316
      Cross[0].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2317
      Cross[0].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2318
      Cross[0].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2319
      Cross[0].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2320
      Cross[1].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2321
      Cross[1].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2322
      Cross[1].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2323
      Cross[1].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2325
      XDrawSegments(dpy, plot->pixmap, *current_gc, Cross, 2);
      }
#line 2326
      goto switch_break___2;
      case_2___0: /* CIL Label */ 
      {
#line 2328
      Star[0].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2329
      Star[0].y1 = (short )((int )((double )(4095 - y) * yscale));
#line 2330
      Star[0].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2331
      Star[0].y2 = (short )((int )((double )(4095 - y) * yscale));
#line 2332
      Star[1].x1 = (short )((int )((double )x * xscale));
#line 2333
      Star[1].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2334
      Star[1].x2 = (short )((int )((double )x * xscale));
#line 2335
      Star[1].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2336
      Star[2].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2337
      Star[2].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2338
      Star[2].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2339
      Star[2].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2340
      Star[3].x1 = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2341
      Star[3].y1 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) + delta);
#line 2342
      Star[3].x2 = (short )((int )((short )((int )((double )x * xscale))) + delta);
#line 2343
      Star[3].y2 = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - delta);
#line 2345
      XDrawSegments(dpy, plot->pixmap, *current_gc, Star, 4);
      }
#line 2346
      goto switch_break___2;
      case_3: /* CIL Label */ 
      {
#line 2348
      XDrawRectangle(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale) - delta,
                     (int )((double )(4095 - y) * yscale) - delta, (unsigned int )(delta + delta),
                     (unsigned int )(delta + delta));
#line 2350
      XDrawPoint(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale));
      }
#line 2351
      goto switch_break___2;
      case_4: /* CIL Label */ 
      {
#line 2353
      XFillRectangle(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale) - delta,
                     (int )((double )(4095 - y) * yscale) - delta, (unsigned int )(delta + delta),
                     (unsigned int )(delta + delta));
      }
#line 2355
      goto switch_break___2;
      case_5: /* CIL Label */ 
      {
#line 2357
      XDrawArc(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale) - delta,
               (int )((double )(4095 - y) * yscale) - delta, (unsigned int )(2 * delta),
               (unsigned int )(2 * delta), 0, 23040);
#line 2359
      XDrawPoint(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale));
      }
#line 2360
      goto switch_break___2;
      case_6: /* CIL Label */ 
      {
#line 2362
      XFillArc(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale) - delta,
               (int )((double )(4095 - y) * yscale) - delta, (unsigned int )(2 * delta),
               (unsigned int )(2 * delta), 0, 23040);
      }
#line 2364
      goto switch_break___2;
      case_10: /* CIL Label */ 
#line 2366
      upside_down_fill = (unsigned char)1;
      case_9: /* CIL Label */ 
#line 2369
      upside_down_sign = (short)-1;
      case_8: /* CIL Label */ 
#line 2371
      fill = (unsigned char)1;
      case_7: /* CIL Label */ 
#line 2377
      temp_x = (short )(1.33 * (double )delta + 0.5);
#line 2378
      temp_y = (short )(1.33 * (double )delta + 0.5);
#line 2380
      Triangle[0].x = (short )((int )((double )x * xscale));
#line 2381
      Triangle[0].y = (short )((int )((short )((int )((double )(4095 - y) * yscale))) - (int )upside_down_sign * (int )temp_y);
#line 2382
      Triangle[1].x = temp_x;
#line 2383
      Triangle[1].y = (short )(((int )upside_down_sign * 2) * delta);
#line 2384
      Triangle[2].x = (short )(- (2 * (int )temp_x));
#line 2385
      Triangle[2].y = (short)0;
#line 2386
      Triangle[3].x = temp_x;
#line 2387
      Triangle[3].y = (short )(- (((int )upside_down_sign * 2) * delta));
#line 2389
      if ((int )upside_down_sign == 1) {
#line 2389
        if (fill) {
          {
#line 2390
          XFillPolygon(dpy, plot->pixmap, *current_gc, Triangle, 4, 2, 1);
          }
        } else {
#line 2389
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2389
      if (upside_down_fill) {
        {
#line 2390
        XFillPolygon(dpy, plot->pixmap, *current_gc, Triangle, 4, 2, 1);
        }
      } else {
        {
#line 2393
        XDrawLines(dpy, plot->pixmap, *current_gc, Triangle, 4, 1);
#line 2394
        XDrawPoint(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale));
        }
      }
#line 2397
      goto switch_break___2;
      case_12: /* CIL Label */ 
#line 2399
      fill = (unsigned char)1;
      case_11: /* CIL Label */ 
#line 2402
      Diamond[0].x = (short )((int )((short )((int )((double )x * xscale))) - delta);
#line 2403
      Diamond[0].y = (short )((int )((double )(4095 - y) * yscale));
#line 2404
      Diamond[1].x = (short )delta;
#line 2405
      Diamond[1].y = (short )(- delta);
#line 2406
      Diamond[2].x = (short )delta;
#line 2407
      Diamond[2].y = (short )delta;
#line 2408
      Diamond[3].x = (short )(- delta);
#line 2409
      Diamond[3].y = (short )delta;
#line 2410
      Diamond[4].x = (short )(- delta);
#line 2411
      Diamond[4].y = (short )(- delta);
#line 2417
      if (fill) {
        {
#line 2418
        XFillPolygon(dpy, plot->pixmap, *current_gc, Diamond, 5, 2, 1);
        }
      } else {
        {
#line 2421
        XDrawLines(dpy, plot->pixmap, *current_gc, Diamond, 5, 1);
#line 2422
        XDrawPoint(dpy, plot->pixmap, *current_gc, (int )((double )x * xscale), (int )((double )(4095 - y) * yscale));
        }
      }
#line 2424
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
      {
#line 2428
      XSetLineAttributes(dpy, *current_gc, (unsigned int )plot->lwidth, plot->type,
                         1, 2);
      }
    }
  } else
#line 2431
  if ((int )*buffer == 108) {
    {
#line 2433
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%4d",
           & lt);
#line 2434
    lt = lt % 8 + 2;
    }
#line 2435
    if (lt < 0) {
#line 2436
      lt = -3;
    }
    {
#line 2437
    XSetForeground(dpy, gc, (plot->cmap)->colors[lt + 3]);
#line 2438
    plot->current_rgb = (plot->cmap)->rgbcolors[lt + 3];
#line 2439
    current_gc = & gc;
    }
  } else
#line 2440
  if ((int )*buffer == 103) {
    {
#line 2443
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%x",
           & rgb255color);
#line 2444
    xcolor.red = (unsigned short )(((double )65535 * (double )((rgb255color >> 16) & 255)) / 255.);
#line 2445
    xcolor.green = (unsigned short )(((double )65535 * (double )((rgb255color >> 8) & 255)) / 255.);
#line 2446
    xcolor.blue = (unsigned short )(((double )65535 * (double )(rgb255color & 255)) / 255.);
#line 2449
    tmp___15 = XAllocColor(dpy, (plot->cmap)->colormap, & xcolor);
    }
#line 2449
    if (tmp___15) {
      {
#line 2450
      XSetForeground(dpy, gc, xcolor.pixel);
#line 2451
      plot->current_rgb = (unsigned long )rgb255color;
      }
    }
#line 2455
    current_gc = & gc;
  } else
#line 2457
  if ((int )*buffer == 107) {
#line 2458
    if (have_pm3d) {
      {
#line 2460
      sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%lf",
             & gray);
#line 2461
      PaletteSetColor(plot, gray);
#line 2462
      current_gc = & gc;
      }
    }
  } else
#line 2466
  if ((int )*buffer == 99) {
#line 2467
    if (have_pm3d) {
#line 2475
      code_detected = (_Bool)0;
#line 2477
      iptr = (unsigned char *)(& gray___0);
#line 2478
      i_remaining = (unsigned int )sizeof(gray___0);
#line 2481
      bptr = buffer + 1;
      {
#line 2481
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2481
        if (! i_remaining) {
#line 2481
          goto while_break___1;
        }
#line 2482
        tmp___16 = bptr;
#line 2482
        bptr ++;
#line 2482
        uctmp = (unsigned char )*tmp___16;
#line 2483
        if (code_detected) {
#line 2484
          code_detected = (_Bool)0;
#line 2485
          tmp___17 = iptr;
#line 2485
          iptr ++;
#line 2485
          *tmp___17 = (unsigned char )(((int )uctmp - 1) + 3);
#line 2486
          i_remaining --;
        } else
#line 2489
        if ((int )uctmp == 5) {
#line 2490
          code_detected = (_Bool)1;
        } else {
#line 2493
          tmp___18 = iptr;
#line 2493
          iptr ++;
#line 2493
          *tmp___18 = (unsigned char )((int )uctmp + 3);
#line 2494
          i_remaining --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2499
      if (swap_endian) {
        {
#line 2500
        byteswap((char *)(& gray___0), (int )sizeof(gray___0));
        }
      }
      {
#line 2503
      PaletteSetColor(plot, (double )gray___0);
#line 2504
      current_gc = & gc;
      }
    }
  } else
#line 2508
  if ((int )*buffer == 73) {
#line 2509
    if (have_pm3d) {
      {
#line 2514
      ptr = buffer + 1;
#line 2516
      sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%4d",
             & npoints);
      }
#line 2518
      if (npoints > 0) {
        {
#line 2519
        ptr += 4;
#line 2520
        sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%4d",
               & style___0);
        }
      }
#line 2525
      if (npoints == -1) {
#line 2527
        if (saved_npoints < 100) {
          {
#line 2528
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot_x11: filled_polygon() protocol error\n");
          }
          {
#line 2529
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 2529
            gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 2529
            close(1);
#line 2529
            close(0);
#line 2529
            exit(1);
            }
#line 2529
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 2532
        i = saved_i;
#line 2533
        npoints = saved_npoints;
      } else {
#line 2535
        saved_npoints = npoints;
#line 2536
        i = 0;
      }
#line 2539
      ptr += 4;
#line 2540
      if (npoints > st_npoints) {
        {
#line 2541
        tmp___19 = realloc((void *)points, sizeof(XPoint ) * (unsigned long )npoints);
#line 2541
        new_points = (XPoint *)tmp___19;
#line 2542
        st_npoints = npoints;
        }
#line 2543
        if (! new_points) {
          {
#line 2544
          perror("gnuplot_x11: exec_cmd()->points");
          }
          {
#line 2545
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 2545
            gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 2545
            close(1);
#line 2545
            close(0);
#line 2545
            exit(1);
            }
#line 2545
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 2547
        points = new_points;
      }
      {
#line 2550
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2550
        if ((int )*ptr != 120) {
#line 2550
          if (! (i < npoints)) {
#line 2550
            goto while_break___4;
          }
        } else {
#line 2550
          goto while_break___4;
        }
        {
#line 2551
        sscanf((char const   */* __restrict  */)ptr, (char const   */* __restrict  */)"%4d%4d",
               & x, & y);
#line 2552
        ptr += 8;
#line 2553
        (points + i)->x = (short )((int )((double )x * xscale));
#line 2554
        (points + i)->y = (short )((int )((double )(4095 - y) * yscale));
#line 2555
        i ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2558
      if (i >= npoints) {
#line 2560
        if (! fill_gc) {
          {
#line 2561
          fill_gc = XCreateGC(dpy, plot->window, 0UL, (XGCValues *)0);
          }
        }
        {
#line 2562
        XCopyGC(dpy, *current_gc, (unsigned long )(~ 0), fill_gc);
#line 2564
        x11_setfill(& fill_gc, style___0);
#line 2566
        XFillPolygon(dpy, plot->pixmap, fill_gc, points, npoints, 1, 0);
#line 2570
        saved_i = -1;
#line 2570
        saved_npoints = saved_i;
        }
      } else {
#line 2573
        saved_i = i;
      }
    }
  } else
#line 2580
  if ((int )*buffer == 102) {
#line 2581
    if (have_pm3d) {
#line 2596
      if (! transferring) {
#line 2597
        iptr___0 = (unsigned char *)(int_cache);
#line 2598
        i_remaining___0 = (unsigned int )sizeof(int_cache);
      }
#line 2601
      i_buffer = (unsigned short)1021;
#line 2604
      bptr___0 = buffer + 1;
      {
#line 2604
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2604
        if (i_buffer) {
#line 2604
          if (! i_remaining___0) {
#line 2604
            goto while_break___5;
          }
        } else {
#line 2604
          goto while_break___5;
        }
#line 2606
        tmp___20 = bptr___0;
#line 2606
        bptr___0 ++;
#line 2606
        uctmp___0 = (unsigned char )*tmp___20;
#line 2608
        if (code_detected___0) {
#line 2609
          code_detected___0 = (_Bool)0;
#line 2610
          tmp___21 = iptr___0;
#line 2610
          iptr___0 ++;
#line 2610
          *tmp___21 = (unsigned char )(((int )uctmp___0 - 1) + -13);
#line 2611
          i_remaining___0 --;
        } else
#line 2613
        if ((int )uctmp___0 == 5) {
#line 2614
          code_detected___0 = (_Bool)1;
        } else {
#line 2616
          tmp___22 = iptr___0;
#line 2616
          iptr___0 ++;
#line 2616
          *tmp___22 = (unsigned char )((int )uctmp___0 + -13);
#line 2617
          i_remaining___0 --;
        }
#line 2621
        if (! i_remaining___0) {
#line 2621
          if (! transferring) {
#line 2623
            if (swap_endian) {
              {
#line 2624
              byteswap((char *)(& int_cache[0]), (int )sizeof(int ));
#line 2625
              byteswap((char *)(& int_cache[1]), (int )sizeof(int ));
              }
            }
#line 2627
            npoints___0 = int_cache[0];
#line 2628
            style___1 = int_cache[1];
#line 2629
            if (npoints___0 > st_npoints___0) {
              {
#line 2630
              tmp___23 = realloc((void *)points___0, (unsigned long )(npoints___0 * 2) * sizeof(int ));
#line 2630
              new_points___0 = (XPoint *)tmp___23;
#line 2631
              st_npoints___0 = npoints___0;
              }
#line 2632
              if (! new_points___0) {
                {
#line 2633
                perror("gnuplot_x11: exec_cmd()->points");
                }
                {
#line 2634
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  {
#line 2634
                  gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 2634
                  close(1);
#line 2634
                  close(0);
#line 2634
                  exit(1);
                  }
#line 2634
                  goto while_break___6;
                }
                while_break___6: /* CIL Label */ ;
                }
              }
#line 2636
              points___0 = new_points___0;
            }
#line 2638
            i_remaining___0 = (unsigned int )((unsigned long )(npoints___0 * 2) * sizeof(int ));
#line 2639
            iptr___0 = (unsigned char *)points___0;
#line 2640
            transferring = (_Bool)1;
          }
        }
#line 2604
        i_buffer = (unsigned short )((int )i_buffer - 1);
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2645
      if (! i_remaining___0) {
#line 2649
        transferring = (_Bool)0;
#line 2652
        if (swap_endian) {
#line 2653
          i___0 = 2 * npoints___0;
#line 2654
          i___0 --;
          {
#line 2654
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 2654
            if (! (i___0 >= 0)) {
#line 2654
              goto while_break___7;
            }
            {
#line 2655
            byteswap((char *)((int *)points___0 + i___0), (int )sizeof(int ));
#line 2654
            i___0 --;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
        }
#line 2662
        i___0 = 0;
        {
#line 2662
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 2662
          if (! (i___0 < npoints___0)) {
#line 2662
            goto while_break___8;
          }
#line 2663
          (points___0 + i___0)->x = (short )((int )((double )*((int *)points___0 + 2 * i___0) * xscale));
#line 2664
          (points___0 + i___0)->y = (short )((int )((double )(4095 - *((int *)points___0 + (2 * i___0 + 1))) * yscale));
#line 2662
          i___0 ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 2668
        if (! fill_gc) {
          {
#line 2669
          fill_gc = XCreateGC(dpy, plot->window, 0UL, (XGCValues *)0);
          }
        }
        {
#line 2670
        XCopyGC(dpy, *current_gc, (unsigned long )(~ 0), fill_gc);
#line 2672
        x11_setfill(& fill_gc, style___1);
#line 2674
        XFillPolygon(dpy, plot->pixmap, fill_gc, points___0, npoints___0, 1, 0);
        }
      }
    }
  } else
#line 2681
  if ((int )*buffer == 105) {
#line 2693
    if (! have_pm3d) {
#line 2694
      return;
    }
#line 2700
    if (! transferring___0) {
      {
#line 2703
      tmp___25 = sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%x %x %x %x %x %x %x %x %x %x %x",
                        & M, & N, & pixel_1_1_x, & pixel_1_1_y, & pixel_M_N_x, & pixel_M_N_y,
                        & visual_1_1_x, & visual_1_1_y, & visual_M_N_x, & visual_M_N_y,
                        & color_mode);
      }
#line 2703
      if (11 != tmp___25) {
        {
#line 2706
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Couldn\'t read image parameters correctly.\n\n");
        }
      } else {
#line 2710
        i_remaining___1 = (unsigned int )((unsigned long )(M * N) * sizeof(*(image + 0)));
#line 2711
        if (color_mode == 1) {
#line 2712
          i_remaining___1 *= 3U;
        } else
#line 2713
        if (color_mode == 2) {
#line 2714
          i_remaining___1 *= 4U;
        }
#line 2716
        if (! i_remaining___1) {
          {
#line 2717
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Image of size zero.\n\n");
          }
        } else {
          {
#line 2719
          tmp___24 = malloc((size_t )i_remaining___1);
#line 2719
          image = (unsigned short *)tmp___24;
          }
#line 2720
          if (image) {
#line 2721
            iptr___1 = (unsigned char *)image;
#line 2722
            transferring___0 = (_Bool)1;
          } else {
            {
#line 2724
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Cannot allocate memory for image.\n\n");
            }
          }
        }
      }
    } else {
#line 2735
      i_buffer___0 = (unsigned short)1021;
#line 2738
      bptr___1 = buffer + 1;
      {
#line 2738
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2738
        if (i_buffer___0) {
#line 2738
          if (! i_remaining___1) {
#line 2738
            goto while_break___9;
          }
        } else {
#line 2738
          goto while_break___9;
        }
#line 2739
        tmp___26 = bptr___1;
#line 2739
        bptr___1 ++;
#line 2739
        uctmp___1 = (unsigned char )*tmp___26;
#line 2740
        if (code_detected___1) {
#line 2741
          code_detected___1 = (_Bool)0;
#line 2742
          tmp___27 = iptr___1;
#line 2742
          iptr___1 ++;
#line 2742
          *tmp___27 = (unsigned char )(((int )uctmp___1 - 1) + 45);
#line 2743
          i_remaining___1 --;
        } else
#line 2745
        if ((int )uctmp___1 == 1) {
#line 2746
          code_detected___1 = (_Bool)1;
        } else {
#line 2748
          tmp___28 = iptr___1;
#line 2748
          iptr___1 ++;
#line 2748
          *tmp___28 = (unsigned char )((int )uctmp___1 + 45);
#line 2749
          i_remaining___1 --;
        }
#line 2738
        i_buffer___0 = (unsigned short )((int )i_buffer___0 - 1);
      }
      while_break___9: /* CIL Label */ ;
      }
#line 2754
      if (! i_remaining___1) {
#line 2766
        create_image = (_Bool)0;
#line 2773
        transferring___0 = (_Bool)0;
#line 2776
        if (swap_endian) {
#line 2777
          i___1 = M * N;
#line 2778
          if (color_mode == 1) {
#line 2779
            i___1 *= 3;
          } else
#line 2780
          if (color_mode == 2) {
#line 2781
            i___1 *= 4;
          }
#line 2782
          i___1 --;
          {
#line 2782
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 2782
            if (! (i___1 >= 0)) {
#line 2782
              goto while_break___10;
            }
#line 2784
            byteswap_char = *((char *)(image + i___1) + 0);
#line 2784
            *((char *)(image + i___1) + 0) = *((char *)(image + i___1) + 1);
#line 2784
            *((char *)(image + i___1) + 1) = byteswap_char;
#line 2782
            i___1 --;
          }
          while_break___10: /* CIL Label */ ;
          }
        }
#line 2788
        if (color_mode == 0) {
#line 2807
          create_image = (_Bool)1;
        } else {
          {
#line 2816
          if (vis->class == 4) {
#line 2816
            goto case_4___0;
          }
#line 2900
          if (vis->class == 3) {
#line 2900
            goto case_3___0;
          }
#line 2905
          if (vis->class == 1) {
#line 2905
            goto case_1___1;
          }
#line 2910
          if (vis->class == 2) {
#line 2910
            goto case_2___1;
          }
#line 2915
          if (vis->class == 0) {
#line 2915
            goto case_0___0;
          }
#line 2920
          if (vis->class == 5) {
#line 2920
            goto case_5___0;
          }
#line 2925
          goto switch_default___1;
          case_4___0: /* CIL Label */ 
#line 2836
          if (! R_msb_mask) {
#line 2836
            goto _L___1;
          } else
#line 2836
          if (vis->red_mask != prev_red_mask) {
#line 2836
            goto _L___1;
          } else
#line 2836
          if (vis->green_mask != prev_green_mask) {
#line 2836
            goto _L___1;
          } else
#line 2836
          if (vis->blue_mask != prev_blue_mask) {
            _L___1: /* CIL Label */ 
            {
#line 2839
            prev_red_mask = vis->red_mask;
#line 2840
            prev_green_mask = vis->green_mask;
#line 2841
            prev_blue_mask = vis->blue_mask;
#line 2842
            R_msb_mask = BitMaskDetails(vis->red_mask, & R_rshift, & R_lshift);
#line 2843
            G_msb_mask = BitMaskDetails(vis->green_mask, & G_rshift, & G_lshift);
#line 2844
            B_msb_mask = BitMaskDetails(vis->blue_mask, & B_rshift, & B_lshift);
#line 2854
            R_bits = (short )((32 - (int )R_rshift) - (int )R_lshift);
#line 2855
            G_bits = (short )((32 - (int )G_rshift) - (int )G_lshift);
#line 2856
            B_bits = (short )((32 - (int )B_rshift) - (int )B_lshift);
            }
#line 2857
            if ((int )R_bits < (int )G_bits) {
#line 2857
              tmp___31 = (int )R_bits;
            } else {
#line 2857
              tmp___31 = (int )G_bits;
            }
#line 2857
            if (tmp___31 < (int )B_bits) {
#line 2857
              if ((int )R_bits < (int )G_bits) {
#line 2857
                tmp___30 = (int )R_bits;
              } else {
#line 2857
                tmp___30 = (int )G_bits;
              }
#line 2857
              min_bits = (short )tmp___30;
            } else {
#line 2857
              min_bits = B_bits;
            }
#line 2858
            if ((int )R_bits > (int )min_bits) {
#line 2859
              R_msb_mask = (unsigned short )((int )R_msb_mask >> ((int )R_bits - (int )min_bits));
#line 2860
              R_lshift = (unsigned short )((int )R_lshift + ((int )R_bits - (int )min_bits));
#line 2861
              R_bits = min_bits;
            }
#line 2863
            if ((int )G_bits > (int )min_bits) {
#line 2864
              G_msb_mask = (unsigned short )((int )G_msb_mask >> ((int )G_bits - (int )min_bits));
#line 2865
              G_lshift = (unsigned short )((int )G_lshift + ((int )G_bits - (int )min_bits));
#line 2866
              G_bits = min_bits;
            }
#line 2868
            if ((int )B_bits > (int )min_bits) {
#line 2869
              B_msb_mask = (unsigned short )((int )B_msb_mask >> ((int )B_bits - (int )min_bits));
#line 2870
              B_lshift = (unsigned short )((int )B_lshift + ((int )B_bits - (int )min_bits));
#line 2871
              B_bits = min_bits;
            }
#line 2873
            R_rshift = (unsigned short )(16 - (int )R_bits);
#line 2874
            G_rshift = (unsigned short )(16 - (int )G_bits);
#line 2875
            B_rshift = (unsigned short )(16 - (int )B_bits);
          }
#line 2897
          create_image = (_Bool)1;
#line 2898
          goto switch_break___3;
          case_3___0: /* CIL Label */ 
          {
#line 2901
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  PseudoColor");
#line 2902
          fputs((char const   */* __restrict  */)display_error_text_after, (FILE */* __restrict  */)stderr);
          }
#line 2903
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 2906
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  GrayScale");
#line 2907
          fputs((char const   */* __restrict  */)display_error_text_after, (FILE */* __restrict  */)stderr);
          }
#line 2908
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 2911
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  StaticColor");
#line 2912
          fputs((char const   */* __restrict  */)display_error_text_after, (FILE */* __restrict  */)stderr);
          }
#line 2913
          goto switch_break___3;
          case_0___0: /* CIL Label */ 
          {
#line 2916
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  StaticGray");
#line 2917
          fputs((char const   */* __restrict  */)display_error_text_after, (FILE */* __restrict  */)stderr);
          }
#line 2918
          goto switch_break___3;
          case_5___0: /* CIL Label */ 
          {
#line 2921
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  DirectColor display class currently\n                     not supported.\n\n");
          }
#line 2923
          goto switch_break___3;
          switch_default___1: /* CIL Label */ 
          {
#line 2926
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Unknown X11 display class.\n\n");
          }
#line 2927
          goto switch_break___3;
          switch_break___3: /* CIL Label */ ;
          }
        }
#line 2933
        if (create_image) {
#line 2944
          pixel_1_1_x_plot = (int )((double )pixel_1_1_x * xscale);
#line 2945
          pixel_M_N_x_plot = (int )((double )pixel_M_N_x * xscale);
#line 2946
          M_pixel = pixel_M_N_x_plot - pixel_1_1_x_plot;
#line 2947
          if (M_pixel < 0) {
#line 2948
            M_pixel = - M_pixel;
#line 2949
            itmp = pixel_1_1_x_plot;
#line 2950
            pixel_1_1_x_plot = pixel_M_N_x_plot;
#line 2951
            pixel_M_N_x_plot = itmp;
          }
#line 2953
          pixel_1_1_y_plot = (int )((double )(4095 - pixel_1_1_y) * yscale);
#line 2954
          pixel_M_N_y_plot = (int )((double )(4095 - pixel_M_N_y) * yscale);
#line 2955
          N_pixel = pixel_M_N_y_plot - pixel_1_1_y_plot;
#line 2956
          if (N_pixel < 0) {
#line 2957
            N_pixel = - N_pixel;
#line 2958
            itmp = pixel_1_1_y_plot;
#line 2959
            pixel_1_1_y_plot = pixel_M_N_y_plot;
#line 2960
            pixel_M_N_y_plot = itmp;
          }
#line 2964
          view_1_1_x_plot = (int )((double )visual_1_1_x * xscale);
#line 2965
          view_M_N_x_plot = (int )((double )visual_M_N_x * xscale);
#line 2966
          if (view_M_N_x_plot < view_1_1_x_plot) {
#line 2967
            itmp = view_1_1_x_plot;
#line 2968
            view_1_1_x_plot = view_M_N_x_plot;
#line 2969
            view_M_N_x_plot = itmp;
          }
#line 2971
          view_1_1_y_plot = (int )((double )(4095 - visual_1_1_y) * yscale);
#line 2972
          view_M_N_y_plot = (int )((double )(4095 - visual_M_N_y) * yscale);
#line 2973
          if (view_M_N_y_plot < view_1_1_y_plot) {
#line 2974
            itmp = view_1_1_y_plot;
#line 2975
            view_1_1_y_plot = view_M_N_y_plot;
#line 2976
            view_M_N_y_plot = itmp;
          }
#line 2980
          itmp = view_1_1_x_plot - pixel_1_1_x_plot;
#line 2981
          if (itmp > 0) {
#line 2982
            i_start = itmp;
#line 2982
            final_1_1_x_plot = view_1_1_x_plot;
          } else {
#line 2984
            i_start = 0;
#line 2984
            final_1_1_x_plot = pixel_1_1_x_plot;
          }
#line 2986
          itmp = pixel_M_N_x_plot - view_M_N_x_plot;
#line 2987
          if (itmp > 0) {
#line 2988
            M_view = (M_pixel - itmp) - i_start;
          } else {
#line 2990
            M_view = M_pixel - i_start;
          }
#line 2993
          itmp = view_1_1_y_plot - pixel_1_1_y_plot;
#line 2994
          if (itmp > 0) {
#line 2995
            j_start = itmp;
#line 2995
            final_1_1_y_plot = view_1_1_y_plot;
          } else {
#line 2997
            j_start = 0;
#line 2997
            final_1_1_y_plot = pixel_1_1_y_plot;
          }
#line 2999
          itmp = pixel_M_N_y_plot - view_M_N_y_plot;
#line 3000
          if (itmp > 0) {
#line 3001
            N_view = (N_pixel - itmp) - j_start;
          } else {
#line 3003
            N_view = N_pixel - j_start;
          }
#line 3006
          if (M_view > 0) {
#line 3006
            if (N_view > 0) {
#line 3013
              if (dep > 16U) {
#line 3013
                sample_data_size = (short)4;
              } else {
#line 3013
                sample_data_size = (short)2;
              }
              {
#line 3016
              tmp___32 = malloc((size_t )((M_view * N_view) * (int )sample_data_size));
#line 3016
              sample_data = (char *)tmp___32;
              }
#line 3018
              if (sample_data) {
                {
#line 3020
                image_src = (XImage *)((void *)0);
#line 3024
                image_dest = XCreateImage(dpy, vis, dep, 2, 0, sample_data, (unsigned int )M_view,
                                          (unsigned int )N_view, 8 * (int )sample_data_size,
                                          M_view * (int )sample_data_size);
                }
#line 3026
                if (! image_dest) {
                  {
#line 3027
                  fputs((char const   */* __restrict  */)"gnuplot_x11: can\'t get memory for image object.\n",
                        (FILE */* __restrict  */)stderr);
                  }
                  {
#line 3028
                  while (1) {
                    while_continue___11: /* CIL Label */ ;
                    {
#line 3028
                    gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 3028
                    close(1);
#line 3028
                    close(0);
#line 3028
                    exit(1);
                    }
#line 3028
                    goto while_break___11;
                  }
                  while_break___11: /* CIL Label */ ;
                  }
                }
#line 3032
                if (color_mode == 2) {
                  {
#line 3033
                  image_src = XGetImage(dpy, plot->pixmap, final_1_1_x_plot, final_1_1_y_plot,
                                        (unsigned int )M_view, (unsigned int )N_view,
                                        (unsigned long )(~ 0L), 2);
                  }
                }
#line 3037
                j_view = 0;
                {
#line 3037
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 3037
                  if (! (j_view < N_view)) {
#line 3037
                    goto while_break___12;
                  }
#line 3038
                  j = ((j_view + j_start) * N) / N_pixel;
#line 3039
                  row_start = j * M;
#line 3040
                  i_view = 0;
                  {
#line 3040
                  while (1) {
                    while_continue___13: /* CIL Label */ ;
#line 3040
                    if (! (i_view < M_view)) {
#line 3040
                      goto while_break___13;
                    }
#line 3041
                    i___2 = ((i_view + i_start) * M) / M_pixel;
#line 3042
                    if (color_mode == 0) {
                      {
#line 3066
                      index___0 = (unsigned short )((unsigned long )(plot->cmap)->allocated * (unsigned long )*(image + (row_start + i___2)) >> 16);
#line 3067
                      pixel = *((plot->cmap)->pixels + index___0);
#line 3075
                      (*(image_dest->f.put_pixel))(image_dest, i_view, j_view, pixel);
                      }
                    } else
#line 3076
                    if (color_mode == 1) {
                      {
#line 3077
                      index3 = 3 * (row_start + i___2);
#line 3078
                      tmp___33 = index3;
#line 3078
                      index3 ++;
#line 3078
                      pixel___0 = (unsigned long )((unsigned int )(((int )*(image + tmp___33) >> (int )R_rshift) & (int )R_msb_mask) << (int )R_lshift);
#line 3079
                      tmp___34 = index3;
#line 3079
                      index3 ++;
#line 3079
                      pixel___0 |= (unsigned long )((unsigned int )(((int )*(image + tmp___34) >> (int )G_rshift) & (int )G_msb_mask) << (int )G_lshift);
#line 3080
                      pixel___0 |= (unsigned long )((unsigned int )(((int )*(image + index3) >> (int )B_rshift) & (int )B_msb_mask) << (int )B_lshift);
#line 3081
                      (*(image_dest->f.put_pixel))(image_dest, i_view, j_view, pixel___0);
                      }
                    } else {
                      {
#line 3086
                      index4 = 4 * (row_start + i___2);
#line 3087
                      alpha = (double )((int )*(image + (index4 + 3)) & 255) / 255.;
#line 3090
                      tmp___35 = (*(image_src->f.get_pixel))(image_src, i_view, j_view);
#line 3090
                      pixel___1 = tmp___35;
#line 3091
                      red = (unsigned int )(((pixel___1 >> (int )R_lshift) & (unsigned long )R_msb_mask) << (int )R_rshift);
#line 3092
                      green = (unsigned int )(((pixel___1 >> (int )G_lshift) & (unsigned long )G_msb_mask) << (int )G_rshift);
#line 3093
                      blue = (unsigned int )(((pixel___1 >> (int )B_lshift) & (unsigned long )B_msb_mask) << (int )B_rshift);
#line 3095
                      tmp___36 = index4;
#line 3095
                      index4 ++;
#line 3095
                      red = (unsigned int )(alpha * (double )*(image + tmp___36) + (1. - alpha) * (double )red);
#line 3096
                      tmp___37 = index4;
#line 3096
                      index4 ++;
#line 3096
                      green = (unsigned int )(alpha * (double )*(image + tmp___37) + (1. - alpha) * (double )green);
#line 3097
                      blue = (unsigned int )(alpha * (double )*(image + index4) + (1. - alpha) * (double )blue);
#line 3098
                      pixel___1 = (unsigned long )(((red >> (int )R_rshift) & (unsigned int )R_msb_mask) << (int )R_lshift);
#line 3099
                      pixel___1 |= (unsigned long )(((green >> (int )G_rshift) & (unsigned int )G_msb_mask) << (int )G_lshift);
#line 3100
                      pixel___1 |= (unsigned long )(((blue >> (int )B_rshift) & (unsigned int )B_msb_mask) << (int )B_lshift);
#line 3101
                      (*(image_dest->f.put_pixel))(image_dest, i_view, j_view, pixel___1);
                      }
                    }
#line 3040
                    i_view ++;
                  }
                  while_break___13: /* CIL Label */ ;
                  }
#line 3037
                  j_view ++;
                }
                while_break___12: /* CIL Label */ ;
                }
                {
#line 3123
                XPutImage(dpy, plot->pixmap, gc, image_dest, 0, 0, final_1_1_x_plot,
                          final_1_1_y_plot, (unsigned int )M_view, (unsigned int )N_view);
#line 3127
                (*(image_dest->f.destroy_image))(image_dest);
                }
#line 3128
                if (color_mode == 2) {
                  {
#line 3129
                  (*(image_src->f.destroy_image))(image_src);
                  }
                }
              } else {
                {
#line 3134
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Could not allocate memory for image.\n\n");
                }
              }
            }
          }
        }
        {
#line 3141
        free((void *)image);
        }
      }
    }
  } else
#line 3150
  if ((int )*buffer == 83) {
    {
#line 3153
    sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%d %d",
           & axis, & axis_mask);
    }
#line 3154
    if (axis == -2) {
#line 3155
      plot->almost2d = axis_mask;
    } else
#line 3156
    if (axis < 0) {
#line 3157
      plot->axis_mask = axis_mask;
    } else
#line 3158
    if (axis < 8) {
      {
#line 3159
      sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%d %lg %d %lg %lg",
             & axis, & plot->axis_scale[axis].min, & plot->axis_scale[axis].term_lower,
             & plot->axis_scale[axis].term_scale, & plot->axis_scale[axis].logbase);
      }
    }
  } else
#line 3169
  if ((int )*buffer == 101) {
#line 3170
    if (have_pm3d) {
      {
#line 3174
      sscanf((char const   */* __restrict  */)(buffer + 1), (char const   */* __restrict  */)"%u",
             & cm_index);
#line 3175
      csp = plot->first_cmap_struct;
#line 3176
      i___3 = 0;
      }
      {
#line 3176
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 3176
        if (! (i___3 < cm_index)) {
#line 3176
          goto while_break___14;
        }
#line 3177
        csp = csp->next_cmap_struct;
#line 3176
        i___3 ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 3178
      plot->cmap = csp->cmap;
    }
  } else {
    {
#line 3182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot_x11: unknown command <%s>\n",
            buffer);
    }
  }
#line 3184
  return;
}
}
#line 3189 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void display(plot_struct *plot ) 
{ 
  int n ;
  int i ;

  {
#line 3196
  if (plot->ncommands == 0) {
#line 3197
    return;
  }
#line 3200
  xscale = (double )plot->width / 4096.0;
#line 3201
  yscale = (double )plot->gheight / 4096.0;
#line 3204
  plot->px = (unsigned int )((int )(xscale * pointsize));
#line 3205
  plot->py = (unsigned int )((int )(yscale * pointsize));
#line 3208
  if (plot->pixmap == 0UL) {
    {
#line 3210
    plot->pixmap = XCreatePixmap(dpy, root, plot->width, plot->gheight + (unsigned int )vchar,
                                 dep);
    }
  }
#line 3213
  if (gc) {
    {
#line 3214
    XFreeGC(dpy, gc);
    }
  }
  {
#line 3216
  gc = XCreateGC(dpy, plot->pixmap, 0UL, (XGCValues *)0);
  }
#line 3218
  if (font) {
    {
#line 3219
    gpXSetFont(dpy, gc, font->fid);
    }
  }
  {
#line 3221
  XSetFillStyle(dpy, gc, 0);
  }
#line 3224
  if (! stipple_initialized) {
#line 3226
    i = 0;
    {
#line 3226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3226
      if (! (i < 8)) {
#line 3226
        goto while_break;
      }
      {
#line 3227
      stipple_pattern[i] = XCreateBitmapFromData(dpy, plot->pixmap, stipple_pattern_bits[i],
                                                 8U, 8U);
#line 3226
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3230
    stipple_initialized = 1;
  }
  {
#line 3234
  XSetForeground(dpy, gc, (plot->cmap)->colors[0]);
#line 3235
  XFillRectangle(dpy, plot->pixmap, gc, 0, 0, plot->width, (plot->gheight + (unsigned int )vchar) + (unsigned int )vchar);
#line 3236
  XSetBackground(dpy, gc, (plot->cmap)->colors[0]);
  }
#line 3238
  if (plot->window == 0UL) {
    {
#line 3239
    pr_window(plot);
    }
  }
#line 3242
  if (do_raise) {
    {
#line 3243
    XMapRaised(dpy, plot->window);
    }
  }
#line 3246
  if (Clear) {
    {
#line 3247
    XClearWindow(dpy, plot->window);
#line 3248
    XFlush(dpy);
    }
  }
#line 3251
  n = 0;
  {
#line 3251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3251
    if (! (n < plot->ncommands)) {
#line 3251
      goto while_break___0;
    }
    {
#line 3252
    exec_cmd(plot, *(plot->commands + n));
#line 3251
    n ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3256
  if (exportselection) {
    {
#line 3257
    export_graph(plot);
    }
  }
  {
#line 3260
  UpdateWindow(plot);
  }
#line 3270
  if (! button_pressed) {
#line 3271
    if (cursor_save) {
#line 3271
      cursor = cursor_save;
    } else {
#line 3271
      cursor = cursor_default;
    }
    {
#line 3272
    cursor_save = (Cursor )0;
#line 3273
    XDefineCursor(dpy, plot->window, cursor);
    }
  }
#line 3277
  return;
}
}
#line 3279 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void UpdateWindow(plot_struct *plot ) 
{ 
  XEvent event ;
  int tmp ;

  {
#line 3289
  if (0UL == plot->window) {
#line 3290
    return;
  } else
#line 3289
  if (0UL == plot->pixmap) {
#line 3290
    return;
  }
  {
#line 3293
  XSetWindowBackgroundPixmap(dpy, plot->window, plot->pixmap);
#line 3294
  XClearWindow(dpy, plot->window);
#line 3297
  EventuallyDrawMouseAddOns(plot);
#line 3299
  XFlush(dpy);
  }
  {
#line 3305
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3305
    tmp = XCheckWindowEvent(dpy, plot->window, 1L << 15, & event);
    }
#line 3305
    if (! tmp) {
#line 3305
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3308
  return;
}
}
#line 3311 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void CmapClear(cmap_t *cmap_ptr ) 
{ 


  {
#line 3314
  cmap_ptr->total = 0;
#line 3315
  cmap_ptr->allocated = 0;
#line 3316
  cmap_ptr->pixels = (unsigned long *)0;
#line 3317
  return;
}
}
#line 3319 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void RecolorWindow(plot_struct *plot ) 
{ 
  cmap_struct **cspp ;
  cmap_struct *csp ;
  void *tmp ;

  {
#line 3322
  cspp = & plot->first_cmap_struct;
#line 3323
  csp = plot->first_cmap_struct;
  {
#line 3324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3324
    if (! csp) {
#line 3324
      goto while_break;
    }
#line 3325
    if ((unsigned long )csp->cmap == (unsigned long )plot->cmap) {
#line 3326
      goto while_break;
    }
#line 3327
    cspp = & csp->next_cmap_struct;
#line 3328
    csp = csp->next_cmap_struct;
  }
  while_break: /* CIL Label */ ;
  }
#line 3330
  if (! csp) {
    {
#line 3332
    tmp = malloc(sizeof(cmap_struct ));
#line 3332
    *cspp = (cmap_struct *)tmp;
    }
#line 3333
    if (*cspp) {
      {
#line 3335
      memset((void *)*cspp, 0, sizeof(cmap_struct ));
#line 3336
      (*cspp)->cmap = plot->cmap;
      }
    } else {
      {
#line 3339
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Could not allocate memory for cmap_struct.\n\n");
      }
#line 3340
      return;
    }
  }
#line 3343
  if (0UL != plot->window) {
    {
#line 3344
    XSetWindowColormap(dpy, plot->window, (plot->cmap)->colormap);
#line 3345
    XSetWindowBackground(dpy, plot->window, (plot->cmap)->colors[0]);
#line 3346
    XSetWindowBorder(dpy, plot->window, (plot->cmap)->colors[1]);
    }
#line 3348
    if (gc_xor) {
      {
#line 3349
      XFreeGC(dpy, gc_xor);
#line 3350
      gc_xor = (GC )0;
#line 3351
      GetGCXor(plot, & gc_xor);
      }
    }
  }
#line 3355
  return;
}
}
#line 3357 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void FreeColormapList(plot_struct *plot ) 
{ 
  cmap_struct *freethis ;
  plot_struct *tmp ;

  {
  {
#line 3360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3360
    if (! ((unsigned long )plot->first_cmap_struct != (unsigned long )((void *)0))) {
#line 3360
      goto while_break;
    }
#line 3361
    freethis = plot->first_cmap_struct;
#line 3366
    if ((unsigned long )(plot->first_cmap_struct)->cmap != (unsigned long )current_cmap) {
      {
#line 3366
      tmp = Find_Plot_In_Linked_List_By_CMap((plot->first_cmap_struct)->cmap);
      }
#line 3366
      if (! tmp) {
        {
#line 3367
        Remove_CMap_From_Linked_List((plot->first_cmap_struct)->cmap);
        }
      }
    }
    {
#line 3368
    plot->first_cmap_struct = (plot->first_cmap_struct)->next_cmap_struct;
#line 3369
    free((void *)freethis);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3371
  return;
}
}
#line 3379 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void FreeColors(cmap_t *cmp ) 
{ 


  {
#line 3382
  if (cmp->total) {
#line 3382
    if (cmp->pixels) {
#line 3383
      if (cmp->allocated) {
        {
#line 3385
        XFreeColors(dpy, cmp->colormap, cmp->pixels, cmp->allocated, 0UL);
        }
      }
      {
#line 3388
      free((void *)cmp->pixels);
      }
    }
  }
  {
#line 3390
  CmapClear(cmp);
  }
#line 3391
  return;
}
}
#line 3399 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void ReleaseColormap(cmap_t *cmp ) 
{ 


  {
#line 3402
  if (cmp) {
#line 3402
    if ((unsigned long )cmp != (unsigned long )current_cmap) {
      {
#line 3403
      FreeColors(cmp);
      }
#line 3405
      if (cmp->colormap) {
#line 3405
        if (cmp->colormap != current_cmap->colormap) {
          {
#line 3406
          XFreeColormap(dpy, cmp->colormap);
          }
        }
      }
      {
#line 3408
      free((void *)((char *)cmp));
      }
    }
  }
#line 3410
  return;
}
}
#line 3412 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long *ReallocColors(cmap_t *cmap , int n ) 
{ 
  void *tmp ;

  {
  {
#line 3415
  FreeColors(cmap);
#line 3416
  cmap->total = n;
#line 3417
  tmp = malloc(sizeof(unsigned long ) * (unsigned long )cmap->total);
#line 3417
  cmap->pixels = (unsigned long *)tmp;
  }
#line 3419
  return (cmap->pixels);
}
}
#line 3436 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int GetVisual(int class , Visual **visual , int *depth ) 
{ 
  XVisualInfo *visualsavailable ;
  int nvisuals ;
  long vinfo_mask ;
  XVisualInfo vinfo ;
  int i ;

  {
  {
#line 3440
  nvisuals = 0;
#line 3441
  vinfo_mask = 8L;
#line 3444
  vinfo.class = class;
#line 3445
  *depth = 0;
#line 3446
  *visual = (Visual *)0;
#line 3448
  visualsavailable = XGetVisualInfo(dpy, vinfo_mask, & vinfo, & nvisuals);
  }
#line 3450
  if (visualsavailable) {
#line 3450
    if (nvisuals > 0) {
#line 3452
      i = 0;
      {
#line 3452
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3452
        if (! (i < nvisuals)) {
#line 3452
          goto while_break;
        }
#line 3453
        if ((visualsavailable + i)->depth > *depth) {
#line 3454
          *visual = (visualsavailable + i)->visual;
#line 3455
          *depth = (visualsavailable + i)->depth;
        }
#line 3452
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3458
      XFree((void *)visualsavailable);
      }
#line 3459
      if (*visual) {
#line 3459
        if ((*visual)->class == ((((_XPrivDisplay )dpy)->screens + scr)->root_visual)->class) {
#line 3459
          if (*depth == (((_XPrivDisplay )dpy)->screens + scr)->root_depth) {
#line 3461
            *visual = (((_XPrivDisplay )dpy)->screens + scr)->root_visual;
          }
        }
      }
    }
  }
#line 3464
  return (nvisuals > 0);
}
}
#line 3467 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void PaletteMake(t_sm_palette *tpal ) 
{ 
  int max_colors ;
  int min_colors ;
  cmap_t *new_cmap ;
  cmap_t *tmp ;
  int tmp___0 ;
  Colormap *tmp___1 ;
  XColor xcolor ;
  double fact ;
  double gray ;
  rgb_color color ;
  int tmp___2 ;
  cmap_t *cmp ;
  int tmp___3 ;
  plot_struct *tmp___4 ;

  {
  {
#line 3486
  tmp = Add_CMap_To_Linked_List();
#line 3486
  new_cmap = tmp;
  }
  {
#line 3489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3491
    if (tpal) {
#line 3493
      if (tpal->use_maxcolors > 0) {
#line 3494
        max_colors = tpal->use_maxcolors;
      } else {
#line 3496
        max_colors = (int )maximal_possible_colors;
      }
#line 3503
      if (sm_palette.gradient) {
        {
#line 3504
        free((void *)sm_palette.gradient);
#line 3505
        sm_palette.gradient = (gradient_struct *)((void *)0);
#line 3506
        sm_palette.gradient_num = 0;
        }
      }
#line 3509
      sm_palette.colorMode = tpal->colorMode;
#line 3510
      sm_palette.positive = tpal->positive;
#line 3511
      sm_palette.use_maxcolors = tpal->use_maxcolors;
#line 3512
      sm_palette.cmodel = tpal->cmodel;
      {
#line 3515
      if ((unsigned int )sm_palette.colorMode == 103U) {
#line 3515
        goto case_103;
      }
#line 3518
      if ((unsigned int )sm_palette.colorMode == 114U) {
#line 3518
        goto case_114;
      }
#line 3523
      if ((unsigned int )sm_palette.colorMode == 102U) {
#line 3523
        goto case_102;
      }
#line 3526
      if ((unsigned int )sm_palette.colorMode == 100U) {
#line 3526
        goto case_100;
      }
#line 3532
      goto switch_default;
      case_103: /* CIL Label */ 
#line 3516
      sm_palette.gamma = tpal->gamma;
#line 3517
      goto switch_break;
      case_114: /* CIL Label */ 
#line 3519
      sm_palette.formulaR = tpal->formulaR;
#line 3520
      sm_palette.formulaG = tpal->formulaG;
#line 3521
      sm_palette.formulaB = tpal->formulaB;
#line 3522
      goto switch_break;
      case_102: /* CIL Label */ 
      {
#line 3524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ooops:  no SMPAL_COLOR_MODE_FUNCTIONS here!\n");
      }
#line 3525
      goto switch_break;
      case_100: /* CIL Label */ 
#line 3527
      sm_palette.gradient_num = tpal->gradient_num;
#line 3529
      sm_palette.gradient = tpal->gradient;
#line 3530
      tpal->gradient = (gradient_struct *)((void *)0);
#line 3531
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3533
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d ooops: Unknown color mode \'%c\'.\n",
              "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
              3534, (int )((char )sm_palette.colorMode));
      }
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 3538
      max_colors = (int )maximal_possible_colors;
    }
#line 3542
    if (minimal_possible_colors < (unsigned int )max_colors) {
#line 3543
      min_colors = (int )minimal_possible_colors;
    } else {
#line 3545
      if (num_colormaps > 1) {
#line 3545
        tmp___0 = 2;
      } else {
#line 3545
        tmp___0 = 8;
      }
#line 3545
      min_colors = max_colors / tmp___0;
    }
#line 3547
    if (current_plot) {
#line 3567
      if (! num_colormaps) {
        {
#line 3568
        tmp___1 = XListInstalledColormaps(dpy, current_plot->window, & num_colormaps);
#line 3568
        XFree((void *)tmp___1);
        }
      }
    }
    {
#line 3587
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3587
      if (! (max_colors >= min_colors)) {
#line 3587
        goto while_break___0;
      }
#line 3590
      fact = 1.0 / (double )(max_colors - 1);
#line 3592
      if (current_plot) {
        {
#line 3593
        ReallocColors(new_cmap, max_colors);
        }
      }
#line 3595
      new_cmap->allocated = 0;
      {
#line 3595
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3595
        if (! (new_cmap->allocated < max_colors)) {
#line 3595
          goto while_break___1;
        }
        {
#line 3597
        gray = (double )new_cmap->allocated * fact;
#line 3599
        rgb1_from_gray(gray, & color);
#line 3600
        xcolor.red = (unsigned short )((double )65535 * color.r + 0.5);
#line 3601
        xcolor.green = (unsigned short )((double )65535 * color.g + 0.5);
#line 3602
        xcolor.blue = (unsigned short )((double )65535 * color.b + 0.5);
#line 3604
        tmp___2 = XAllocColor(dpy, new_cmap->colormap, & xcolor);
        }
#line 3604
        if (tmp___2) {
#line 3605
          *(new_cmap->pixels + new_cmap->allocated) = xcolor.pixel;
        } else {
#line 3608
          goto while_break___1;
        }
#line 3595
        (new_cmap->allocated) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3612
      if (new_cmap->allocated == max_colors) {
#line 3613
        goto while_break___0;
      }
      {
#line 3618
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 3618
        if (max_colors > new_cmap->allocated) {
#line 3618
          if (! (max_colors >= min_colors)) {
#line 3618
            goto while_break___2;
          }
        } else {
#line 3618
          goto while_break___2;
        }
#line 3619
        max_colors /= 2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 3587
      max_colors /= 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3627
    if (new_cmap->allocated < min_colors) {
#line 3627
      if (tpal) {
#line 3630
        tpal = (t_sm_palette *)0;
      } else {
#line 3632
        goto while_break;
      }
    } else {
#line 3632
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3640
  cmp = cmap_list_start;
  {
#line 3642
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3642
    if (! ((unsigned long )cmp != (unsigned long )((void *)0))) {
#line 3642
      goto while_break___3;
    }
#line 3643
    if ((unsigned long )cmp != (unsigned long )new_cmap) {
      {
#line 3643
      tmp___3 = cmaps_differ(cmp, new_cmap);
      }
#line 3643
      if (! tmp___3) {
#line 3644
        goto while_break___3;
      }
    }
#line 3645
    cmp = cmp->next_cmap;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3648
  if ((unsigned long )cmp != (unsigned long )((void *)0)) {
    {
#line 3655
    Remove_CMap_From_Linked_List(new_cmap);
    }
#line 3656
    if (current_plot) {
      {
#line 3657
      current_plot->cmap = cmp;
#line 3658
      RecolorWindow(current_plot);
      }
    }
#line 3660
    current_cmap = cmp;
  } else {
#line 3663
    if (current_plot) {
      {
#line 3664
      current_plot->cmap = new_cmap;
#line 3665
      RecolorWindow(current_plot);
      }
    }
    {
#line 3668
    tmp___4 = Find_Plot_In_Linked_List_By_CMap(current_cmap);
    }
#line 3668
    if (! tmp___4) {
      {
#line 3669
      Remove_CMap_From_Linked_List(current_cmap);
      }
    }
#line 3670
    current_cmap = new_cmap;
  }
#line 3685
  return;
}
}
#line 3687 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void PaletteSetColor(plot_struct *plot , double gray ) 
{ 
  int index___0 ;
  double tmp ;

  {
#line 3690
  if ((plot->cmap)->allocated) {
#line 3695
    if (sm_palette.use_maxcolors == (plot->cmap)->allocated) {
      {
#line 3696
      gray = quantize_gray(gray);
      }
    } else {
      {
#line 3699
      tmp = floor(gray * (double )(plot->cmap)->allocated);
#line 3699
      gray = tmp / (double )((plot->cmap)->allocated - 1);
      }
    }
#line 3701
    index___0 = (int )(gray * (double )((plot->cmap)->allocated - 1));
#line 3702
    if (index___0 >= (plot->cmap)->allocated) {
#line 3703
      index___0 = (plot->cmap)->allocated - 1;
    }
    {
#line 3705
    XSetForeground(dpy, gc, *((plot->cmap)->pixels + index___0));
#line 3706
    plot->current_rgb = *((plot->cmap)->pixels + index___0);
    }
  }
#line 3708
  return;
}
}
#line 3716 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int last_window_id  =    -1;
#line 3713 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void gp_execute_GE_plotdone(int windowid ) 
{ 


  {
#line 3717
  if (windowid == last_window_id) {
    {
#line 3718
    gp_exec_event((char)8, 0, 0, 0, 0, 0);
    }
  } else {
    {
#line 3720
    gp_exec_event((char)8, 0, 0, 0, 0, windowid);
#line 3721
    last_window_id = windowid;
    }
  }
#line 3723
  return;
}
}
#line 3725 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int ErrorHandler(Display *display___0 , XErrorEvent *error_event ) 
{ 


  {
  {
#line 3730
  Add_Plot_To_Remove_FIFO_Queue(error_event->resourceid);
#line 3731
  gp_exec_event((char)10, 0, 0, 0, 0, 0);
  }
#line 3732
  return (0);
}
}
#line 3735 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DrawRuler(plot_struct *plot ) 
{ 
  int x ;
  int y ;

  {
#line 3738
  if (plot->ruler_on) {
#line 3739
    x = (int )((double )plot->ruler_x * xscale);
#line 3740
    y = (int )((double )(4095 - plot->ruler_y) * yscale);
#line 3741
    if (! gc_xor) {
      {
#line 3743
      GetGCXor(plot, & gc_xor);
      }
    }
    {
#line 3746
    XDrawLine(dpy, plot->window, gc_xor, x, 0, x, (int )plot->gheight);
#line 3748
    XDrawLine(dpy, plot->window, gc_xor, 0, y, (int )plot->width, y);
    }
  }
#line 3750
  return;
}
}
#line 3752 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void EventuallyDrawMouseAddOns(plot_struct *plot ) 
{ 


  {
  {
#line 3755
  DrawRuler(plot);
#line 3756
  DrawLineToRuler(plot);
  }
#line 3757
  if (plot->zoombox_on) {
    {
#line 3758
    DrawBox(plot);
    }
  }
  {
#line 3759
  DrawCoords(plot, (char const   *)(plot->str));
  }
#line 3763
  return;
}
}
#line 3771 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DrawLineToRuler(plot_struct *plot ) 
{ 


  {
#line 3774
  if ((int )plot->ruler_on == 0) {
#line 3775
    return;
  } else
#line 3774
  if ((int )plot->ruler_lineto_on == 0) {
#line 3775
    return;
  }
#line 3776
  if (plot->ruler_lineto_x < 0) {
#line 3777
    return;
  }
#line 3778
  if (! gc_xor) {
    {
#line 3779
    GetGCXor(plot, & gc_xor);
    }
  }
  {
#line 3781
  XDrawLine(dpy, plot->window, gc_xor, (int )((double )plot->ruler_x * xscale), (int )((double )(4095 - plot->ruler_y) * yscale),
            plot->ruler_lineto_x, plot->ruler_lineto_y);
  }
#line 3784
  return;
}
}
#line 3795 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DrawBox(plot_struct *plot ) 
{ 
  int width ;
  int height ;
  int X0 ;
  int Y0 ;
  int X1 ;
  int Y1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 3800
  X0 = plot->zoombox_x1;
#line 3801
  Y0 = plot->zoombox_y1;
#line 3802
  X1 = plot->zoombox_x2;
#line 3803
  Y1 = plot->zoombox_y2;
#line 3805
  if (! gc_xor_dashed) {
    {
#line 3806
    GetGCXorDashed(plot, & gc_xor_dashed);
    }
  }
#line 3809
  if (X1 < X0) {
#line 3810
    tmp = X1;
#line 3811
    X1 = X0;
#line 3812
    X0 = tmp;
  }
#line 3815
  if (Y1 < Y0) {
#line 3816
    tmp___0 = Y1;
#line 3817
    Y1 = Y0;
#line 3818
    Y0 = tmp___0;
  }
  {
#line 3821
  width = X1 - X0;
#line 3822
  height = Y1 - Y0;
#line 3824
  XDrawRectangle(dpy, plot->window, gc_xor_dashed, X0, Y0, (unsigned int )width, (unsigned int )height);
  }
#line 3826
  if (plot->zoombox_str1a[0]) {
    {
#line 3827
    AnnotatePoint(plot, plot->zoombox_x1, plot->zoombox_y1, (char const   *)(plot->zoombox_str1a),
                  (char const   *)(plot->zoombox_str1b));
    }
  } else
#line 3826
  if (plot->zoombox_str1b[0]) {
    {
#line 3827
    AnnotatePoint(plot, plot->zoombox_x1, plot->zoombox_y1, (char const   *)(plot->zoombox_str1a),
                  (char const   *)(plot->zoombox_str1b));
    }
  }
#line 3828
  if (plot->zoombox_str2a[0]) {
    {
#line 3829
    AnnotatePoint(plot, plot->zoombox_x2, plot->zoombox_y2, (char const   *)(plot->zoombox_str2a),
                  (char const   *)(plot->zoombox_str2b));
    }
  } else
#line 3828
  if (plot->zoombox_str2b[0]) {
    {
#line 3829
    AnnotatePoint(plot, plot->zoombox_x2, plot->zoombox_y2, (char const   *)(plot->zoombox_str2a),
                  (char const   *)(plot->zoombox_str2b));
    }
  }
#line 3830
  return;
}
}
#line 3839 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void AnnotatePoint(plot_struct *plot , int x , int y , char const   *xstr ,
                          char const   *ystr ) 
{ 
  int ylen ;
  int xlen ;
  int xwidth ;
  int ywidth ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 3845
  tmp = strlen(xstr);
#line 3845
  xlen = (int )tmp;
#line 3846
  xwidth = gpXTextWidth(font, xstr, xlen);
#line 3848
  tmp___0 = strlen(ystr);
#line 3848
  ylen = (int )tmp___0;
#line 3849
  ywidth = gpXTextWidth(font, ystr, ylen);
  }
#line 3853
  if (! gc_xor) {
    {
#line 3854
    GetGCXor(plot, & gc_xor);
    }
  }
  {
#line 3856
  gpXDrawString(dpy, plot->window, gc_xor, x, y - 3, xstr, xlen);
#line 3857
  gpXDrawString(dpy, plot->window, gc_xor, x, y + vchar, ystr, ylen);
  }
#line 3858
  return;
}
}
#line 3861 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static long SetTime(plot_struct *plot , Time t ) 
{ 
  long diff ;
  long tmp ;

  {
#line 3864
  diff = (long )(t - plot->time);
#line 3868
  plot->time = t;
#line 3869
  if (diff > 0L) {
#line 3869
    tmp = diff;
  } else {
#line 3869
    tmp = 0L;
  }
#line 3869
  return (tmp);
}
}
#line 3872 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long AllocateXorPixel(cmap_t *cmap_ptr ) 
{ 
  unsigned long pixel ;
  XColor xcolor ;
  int tmp ;

  {
  {
#line 3878
  xcolor.pixel = cmap_ptr->colors[0];
#line 3879
  XQueryColor(dpy, cmap_ptr->colormap, & xcolor);
  }
#line 3881
  if (((int )xcolor.red + (int )xcolor.green) + (int )xcolor.blue < 65535) {
    {
#line 3887
    xcolor.red = (unsigned short )(~ ((int )xcolor.red));
#line 3888
    xcolor.green = (unsigned short )(~ ((int )xcolor.green));
#line 3889
    xcolor.blue = (unsigned short )(~ ((int )xcolor.blue));
#line 3890
    tmp = XAllocColor(dpy, cmap_ptr->colormap, & xcolor);
    }
#line 3890
    if (tmp) {
#line 3892
      pixel = xcolor.pixel;
    } else {
#line 3895
      pixel = (((_XPrivDisplay )dpy)->screens + scr)->white_pixel;
    }
  } else {
#line 3901
    pixel = xcolor.pixel;
  }
#line 3903
  cmap_ptr->xorpixel = pixel;
#line 3904
  return (pixel);
}
}
#line 3907 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void GetGCXor(plot_struct *plot , GC *ret ) 
{ 
  XGCValues values ;
  unsigned long mask ;

  {
  {
#line 3911
  mask = 0UL;
#line 3913
  values.foreground = AllocateXorPixel(plot->cmap);
  }
#line 3916
  if (usemultibyte) {
#line 3917
    mask = (unsigned long )((1L << 2) | 1L);
#line 3918
    values.function = 6;
  } else {
#line 3922
    mask = (unsigned long )(((1L << 2) | 1L) | (1L << 14));
#line 3923
    values.function = 6;
#line 3924
    values.font = font->fid;
  }
  {
#line 3927
  *ret = XCreateGC(dpy, plot->window, mask, & values);
  }
#line 3928
  return;
}
}
#line 3930 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void GetGCXorDashed(plot_struct *plot , GC *gc___0 ) 
{ 


  {
  {
#line 3933
  GetGCXor(plot, gc___0);
#line 3934
  XSetLineAttributes(dpy, *gc___0, 0U, 1, 0, 0);
  }
#line 3938
  return;
}
}
#line 3942 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void EraseCoords(plot_struct *plot ) 
{ 


  {
  {
#line 3945
  DrawCoords(plot, (char const   *)(plot->str));
  }
#line 3946
  return;
}
}
#line 3949 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DrawCoords(plot_struct *plot , char const   *str ) 
{ 
  size_t tmp ;

  {
#line 3952
  if (! gc_xor) {
    {
#line 3953
    GetGCXor(plot, & gc_xor);
    }
  }
#line 3956
  if ((int const   )*(str + 0) != 0) {
    {
#line 3957
    tmp = strlen(str);
#line 3957
    gpXDrawString(dpy, plot->window, gc_xor, 1, (int )((plot->gheight + (unsigned int )vchar) - 1U),
                  str, (int )tmp);
    }
  }
#line 3958
  return;
}
}
#line 3962 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void DisplayCoords(plot_struct *plot , char const   *s ) 
{ 


  {
  {
#line 3966
  EraseCoords(plot);
  }
#line 3968
  if ((int const   )*(s + 0) == 0) {
#line 3970
    if (plot->height > plot->gheight) {
#line 3972
      if (! plot->resizing) {
#line 3974
        if (plot->external_container != 0UL) {
          {
#line 3975
          plot->gheight = plot->height;
#line 3976
          display(plot);
          }
        } else {
          {
#line 3980
          XResizeWindow(dpy, plot->window, plot->width, plot->gheight);
          }
        }
#line 3981
        plot->resizing = (_Bool)1;
      }
    }
  } else
#line 3986
  if (plot->height == plot->gheight) {
#line 3988
    if (! plot->resizing) {
#line 3990
      if (plot->external_container != 0UL) {
        {
#line 3991
        plot->gheight = plot->height - (unsigned int )vchar;
#line 3992
        display(plot);
        }
      } else {
        {
#line 3995
        XResizeWindow(dpy, plot->window, plot->width, plot->gheight + (unsigned int )vchar);
        }
      }
#line 3996
      plot->resizing = (_Bool)1;
    }
  }
  {
#line 4002
  DrawCoords(plot, s);
#line 4005
  strcpy((char */* __restrict  */)(plot->str), (char const   */* __restrict  */)s);
  }
#line 4006
  return;
}
}
#line 4009 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool is_meta(KeySym mod ) 
{ 


  {
#line 4013
  if (65312UL <= mod) {
#line 4013
    if (mod <= 65343UL) {
#line 4014
      return ((_Bool)1);
    }
  }
  {
#line 4026
  if (mod == 65514UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65513UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65512UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65511UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65508UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65507UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65506UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65505UL) {
#line 4026
    goto case_65514;
  }
#line 4026
  if (mod == 65312UL) {
#line 4026
    goto case_65514;
  }
#line 4028
  goto switch_default;
  case_65514: /* CIL Label */ 
  case_65513: /* CIL Label */ 
  case_65512: /* CIL Label */ 
  case_65511: /* CIL Label */ 
  case_65508: /* CIL Label */ 
  case_65507: /* CIL Label */ 
  case_65506: /* CIL Label */ 
  case_65505: /* CIL Label */ 
  case_65312: /* CIL Label */ 
#line 4027
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 4029
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4045 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *getMultiTabConsoleSwitchCommand(unsigned long *newGnuplotXID___0 ) 
{ 
  char *cmd___0 ;
  char *ptr ;
  char *tmp ;
  char *konsole_name ;
  char *konsole_tab ;
  unsigned long w ;
  FILE *p ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 4050
  cmd___0 = (char *)((void *)0);
#line 4051
  tmp = getenv("KONSOLE_DCOP_SESSION");
#line 4051
  ptr = tmp;
#line 4052
  *newGnuplotXID___0 = 0UL;
  }
#line 4053
  if (ptr) {
#line 4068
    konsole_name = (char *)((void *)0);
#line 4069
    *newGnuplotXID___0 = 0UL;
    {
#line 4071
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4075
      ptr = strchr((char const   *)ptr, '(');
      }
#line 4077
      if (! ptr) {
#line 4077
        return ((char *)((void *)0));
      }
      {
#line 4078
      konsole_name = strdup((char const   *)(ptr + 1));
#line 4079
      konsole_tab = strchr((char const   *)konsole_name, ',');
      }
#line 4080
      if (! konsole_tab) {
#line 4080
        goto while_break;
      }
      {
#line 4081
      tmp___0 = konsole_tab;
#line 4081
      konsole_tab ++;
#line 4081
      *tmp___0 = (char)0;
#line 4082
      ptr = strchr((char const   *)konsole_tab, ')');
      }
#line 4083
      if (ptr) {
#line 4083
        *ptr = (char)0;
      }
      {
#line 4091
      tmp___1 = strlen((char const   *)konsole_name);
#line 4091
      tmp___2 = strlen((char const   *)konsole_tab);
#line 4091
      tmp___3 = malloc((tmp___1 + tmp___2) + 64UL);
#line 4091
      cmd___0 = (char *)tmp___3;
#line 4093
      sprintf((char */* __restrict  */)cmd___0, (char const   */* __restrict  */)"dcop %s konsole-mainwindow#1 getWinID 2>/dev/null",
              konsole_name);
#line 4095
      p = popen((char const   *)cmd___0, "r");
      }
#line 4096
      if (p) {
        {
#line 4097
        fscanf((FILE */* __restrict  */)p, (char const   */* __restrict  */)"%lu",
               & w);
#line 4098
        pclose(p);
        }
      }
#line 4100
      if (gnuplotXID) {
#line 4101
        if (w != gnuplotXID) {
#line 4101
          goto while_break;
        }
      } else {
#line 4104
        *newGnuplotXID___0 = w;
      }
      {
#line 4112
      sprintf((char */* __restrict  */)cmd___0, (char const   */* __restrict  */)"dcop %s konsole activateSession %s",
              konsole_name, konsole_tab);
#line 4114
      free((void *)konsole_name);
      }
#line 4115
      return (cmd___0);
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4117
    free((void *)konsole_name);
#line 4118
    free((void *)cmd___0);
    }
#line 4119
    return ((char *)((void *)0));
  }
#line 4127
  return ((char *)((void *)0));
}
}
#line 4138 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void reset_cursor(void) 
{ 
  plot_struct *plot ;

  {
#line 4141
  plot = plot_list_start;
  {
#line 4143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4143
    if (! plot) {
#line 4143
      goto while_break;
    }
#line 4144
    if (plot->window) {
      {
#line 4146
      XUndefineCursor(dpy, plot->window);
      }
    }
#line 4148
    plot = plot->next_plot;
  }
  while_break: /* CIL Label */ ;
  }
#line 4152
  return;
}
}
#line 4163 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int modifier_mask  =    0;
#line 4165
static void update_modifiers(unsigned int state ) ;
#line 4167 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void update_modifiers(unsigned int state ) 
{ 
  int old_mod_mask ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4172
  old_mod_mask = modifier_mask;
#line 4173
  if (state & 1U) {
#line 4173
    tmp = 1;
  } else {
#line 4173
    tmp = 0;
  }
#line 4173
  if (state & (unsigned int )(1 << 2)) {
#line 4173
    tmp___0 = 2;
  } else {
#line 4173
    tmp___0 = 0;
  }
#line 4173
  if (state & (unsigned int )(1 << 3)) {
#line 4173
    tmp___1 = 4;
  } else {
#line 4173
    tmp___1 = 0;
  }
#line 4173
  modifier_mask = (tmp | tmp___0) | tmp___1;
#line 4176
  if (old_mod_mask != modifier_mask) {
    {
#line 4177
    gp_exec_event((char)7, 0, 0, modifier_mask, 0, 0);
    }
  }
#line 4179
  return;
}
}
#line 4183 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void process_configure_notify_event(XEvent *event ) 
{ 
  plot_struct *plot ;
  int force_redraw ;
  int tmp ;
  int w ;
  int h ;
  int tmp___0 ;
  int i ;

  {
  {
#line 4187
  force_redraw = 0;
#line 4190
  XSync(dpy, 0);
  }
  {
#line 4191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4191
    tmp = XCheckTypedWindowEvent(dpy, event->xany.window, 22, event);
    }
#line 4191
    if (! tmp) {
#line 4191
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4194
  plot = Find_Plot_In_Linked_List_By_Window(event->xconfigure.window);
  }
#line 4195
  if (plot) {
#line 4196
    w = event->xconfigure.width;
#line 4196
    h = event->xconfigure.height;
#line 4203
    if (event->xconfigure.x != 0) {
#line 4204
      plot->x = event->xconfigure.x;
#line 4205
      plot->y = event->xconfigure.y;
#line 4206
      plot->posn_flags = (unsigned int )(((long )plot->posn_flags & ~ (1L << 2)) | 1L);
    } else
#line 4203
    if (event->xconfigure.y != 0) {
#line 4204
      plot->x = event->xconfigure.x;
#line 4205
      plot->y = event->xconfigure.y;
#line 4206
      plot->posn_flags = (unsigned int )(((long )plot->posn_flags & ~ (1L << 2)) | 1L);
    }
#line 4210
    if (plot->resizing) {
#line 4217
      if ((unsigned int )w == plot->width) {
#line 4217
        if ((unsigned int )h == plot->gheight) {
#line 4217
          goto _L;
        } else
#line 4217
        if ((unsigned int )h == plot->gheight + (unsigned int )vchar) {
          _L: /* CIL Label */ 
#line 4221
          plot->resizing = (_Bool)0;
#line 4222
          if ((unsigned int )w == plot->width) {
#line 4222
            if (plot->str[0]) {
#line 4222
              tmp___0 = vchar;
            } else {
#line 4222
              tmp___0 = 0;
            }
#line 4222
            if ((unsigned int )h == plot->gheight + (unsigned int )tmp___0) {
#line 4225
              plot->height = (unsigned int )h;
#line 4226
              return;
            } else {
#line 4232
              force_redraw = 1;
            }
          } else {
#line 4232
            force_redraw = 1;
          }
        }
      }
    }
#line 4238
    if (w > 1) {
#line 4238
      if (h > 1) {
#line 4238
        if (force_redraw) {
#line 4238
          goto _L___0;
        } else
#line 4238
        if ((unsigned int )w != plot->width) {
#line 4238
          goto _L___0;
        } else
#line 4238
        if ((unsigned int )h != plot->height) {
          _L___0: /* CIL Label */ 
#line 4240
          plot->width = (unsigned int )w;
#line 4241
          plot->height = (unsigned int )h;
#line 4244
          if (plot->str[0]) {
#line 4245
            if ((unsigned int )vchar > plot->height) {
#line 4245
              plot->gheight = 0U;
            } else {
#line 4245
              plot->gheight = plot->height - (unsigned int )vchar;
            }
          } else {
#line 4247
            plot->gheight = plot->height;
          }
#line 4249
          plot->posn_flags = (unsigned int )(((long )plot->posn_flags & ~ (1L << 3)) | (1L << 1));
#line 4251
          if (stipple_initialized) {
#line 4253
            i = 0;
            {
#line 4253
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4253
              if (! (i < 8)) {
#line 4253
                goto while_break___0;
              }
              {
#line 4254
              XFreePixmap(dpy, stipple_pattern[i]);
#line 4253
              i ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 4255
            stipple_initialized = 0;
          }
#line 4258
          if (plot->pixmap) {
            {
#line 4261
            XFreePixmap(dpy, plot->pixmap);
#line 4262
            plot->pixmap = (Pixmap )0L;
            }
          }
#line 4266
          if (plot->external_container != 0UL) {
            {
#line 4269
            XResizeWindow(dpy, plot->window, plot->width, plot->height);
#line 4275
            XResizeWindow(dpy, plot->external_container, plot->width, plot->height);
            }
          }
          {
#line 4280
          display(plot);
          }
        }
      }
    }
  }
#line 4283
  return;
}
}
#line 4315 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int cmd_tried  =    0;
#line 4316 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *cmd  =    (char *)((void *)0);
#line 4317 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned long newGnuplotXID  =    0UL;
#line 4285 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void process_event(XEvent *event ) 
{ 
  plot_struct *plot ;
  KeySym keysym ;
  char key_sequence[8] ;
  char const   *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  KeySym __attribute__((__deprecated__))  tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  Window root___0 ;
  Window child ;
  int root_x ;
  int root_y ;
  int pos_x ;
  int pos_y ;
  unsigned int keys_buttons ;
  int tmp___9 ;
  char mouse_format[60] ;
  char *m ;
  double x ;
  double y ;
  double x2 ;
  double y2 ;
  long doubleclick ;
  long tmp___10 ;

  {
  {
#line 4295
  if (event->type == 22) {
#line 4295
    goto case_22;
  }
#line 4299
  if (event->type == 2) {
#line 4299
    goto case_2;
  }
#line 4561
  if (event->type == 3) {
#line 4561
    goto case_3;
  }
#line 4574
  if (event->type == 33) {
#line 4574
    goto case_33;
  }
#line 4583
  if (event->type == 17) {
#line 4583
    goto case_17;
  }
#line 4590
  if (event->type == 12) {
#line 4590
    goto case_12;
  }
#line 4618
  if (event->type == 7) {
#line 4618
    goto case_7;
  }
#line 4639
  if (event->type == 6) {
#line 4639
    goto case_6;
  }
#line 4703
  if (event->type == 4) {
#line 4703
    goto case_4;
  }
#line 4718
  if (event->type == 5) {
#line 4718
    goto case_5;
  }
#line 4753
  if (event->type == 31) {
#line 4753
    goto case_31;
  }
#line 4755
  if (event->type == 30) {
#line 4755
    goto case_30;
  }
#line 4294
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 4296
  process_configure_notify_event(event);
  }
#line 4297
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 4300
  plot = Find_Plot_In_Linked_List_By_Window(event->xkey.window);
#line 4305
  XLookupString((XKeyEvent *)event, key_sequence, (int )sizeof(key_sequence), & keysym,
                (XComposeStatus *)((void *)0));
#line 4308
  update_modifiers(event->xkey.state);
  }
  {
#line 4314
  if (keysym == 32UL) {
#line 4314
    goto case_32;
  }
#line 4339
  if (keysym == 109UL) {
#line 4339
    goto case_109;
  }
#line 4350
  if (keysym == 113UL) {
#line 4350
    goto case_113;
  }
#line 4361
  goto switch_default;
  case_32: /* CIL Label */ 
#line 4320
  if (ctrlq) {
#line 4320
    if (! (modifier_mask & 2)) {
#line 4321
      goto switch_break___0;
    }
  }
#line 4323
  if (! cmd_tried) {
    {
#line 4324
    cmd = getMultiTabConsoleSwitchCommand(& newGnuplotXID);
#line 4325
    cmd_tried = 1;
    }
  }
#line 4328
  if (newGnuplotXID) {
#line 4328
    gnuplotXID = newGnuplotXID;
  }
#line 4329
  if (cmd) {
    {
#line 4329
    system((char const   *)cmd);
    }
  }
#line 4331
  if (gnuplotXID) {
    {
#line 4332
    XMapRaised(dpy, gnuplotXID);
#line 4333
    XSetInputFocus(dpy, gnuplotXID, 0, (Time )0L);
#line 4334
    XFlush(dpy);
    }
  }
#line 4336
  return;
  case_109: /* CIL Label */ 
#line 4340
  if ((unsigned long )plot != (unsigned long )current_plot) {
#line 4340
    if (! modifier_mask) {
#line 4340
      goto _L;
    } else {
#line 4340
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 4340
  if (pipe_died) {
    _L: /* CIL Label */ 
#line 4345
    plot->mouse_on = (_Bool )(! plot->mouse_on);
#line 4346
    if (plot->mouse_on) {
#line 4346
      tmp = " ";
    } else {
#line 4346
      tmp = "";
    }
    {
#line 4346
    DisplayCoords(plot, tmp);
    }
  }
#line 4348
  goto switch_break___0;
  case_113: /* CIL Label */ 
#line 4353
  if (ctrlq) {
#line 4353
    if (! (modifier_mask & 2)) {
#line 4355
      goto switch_break___0;
    }
  }
  {
#line 4359
  Remove_Plot_From_Linked_List(event->xkey.window);
  }
#line 4360
  return;
  switch_default: /* CIL Label */ 
#line 4362
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 4366
  tmp___0 = is_meta(keysym);
  }
#line 4366
  if (tmp___0) {
#line 4367
    return;
  }
  {
#line 4390
  if (keysym == 65288UL) {
#line 4390
    goto case_65288;
  }
#line 4392
  if (keysym == 65289UL) {
#line 4392
    goto case_65289;
  }
#line 4394
  if (keysym == 65290UL) {
#line 4394
    goto case_65290;
  }
#line 4396
  if (keysym == 65291UL) {
#line 4396
    goto case_65291;
  }
#line 4398
  if (keysym == 65293UL) {
#line 4398
    goto case_65293;
  }
#line 4400
  if (keysym == 65299UL) {
#line 4400
    goto case_65299;
  }
#line 4402
  if (keysym == 65300UL) {
#line 4402
    goto case_65300;
  }
#line 4405
  if (keysym == 65301UL) {
#line 4405
    goto case_65301;
  }
#line 4408
  if (keysym == 65307UL) {
#line 4408
    goto case_65307;
  }
#line 4410
  if (keysym == 65379UL) {
#line 4410
    goto case_65379;
  }
#line 4412
  if (keysym == 65535UL) {
#line 4412
    goto case_65535;
  }
#line 4414
  if (keysym == 65360UL) {
#line 4414
    goto case_65360;
  }
#line 4416
  if (keysym == 65361UL) {
#line 4416
    goto case_65361;
  }
#line 4419
  if (keysym == 65362UL) {
#line 4419
    goto case_65362;
  }
#line 4422
  if (keysym == 65363UL) {
#line 4422
    goto case_65363;
  }
#line 4425
  if (keysym == 65364UL) {
#line 4425
    goto case_65364;
  }
#line 4428
  if (keysym == 65365UL) {
#line 4428
    goto case_65365;
  }
#line 4430
  if (keysym == 65366UL) {
#line 4430
    goto case_65366;
  }
#line 4432
  if (keysym == 65367UL) {
#line 4432
    goto case_65367;
  }
#line 4434
  if (keysym == 65368UL) {
#line 4434
    goto case_65368;
  }
#line 4436
  if (keysym == 65408UL) {
#line 4436
    goto case_65408;
  }
#line 4438
  if (keysym == 65417UL) {
#line 4438
    goto case_65417;
  }
#line 4440
  if (keysym == 65421UL) {
#line 4440
    goto case_65421;
  }
#line 4442
  if (keysym == 65425UL) {
#line 4442
    goto case_65425;
  }
#line 4444
  if (keysym == 65426UL) {
#line 4444
    goto case_65426;
  }
#line 4446
  if (keysym == 65427UL) {
#line 4446
    goto case_65427;
  }
#line 4448
  if (keysym == 65428UL) {
#line 4448
    goto case_65428;
  }
#line 4451
  if (keysym == 65429UL) {
#line 4451
    goto case_65429;
  }
#line 4455
  if (keysym == 65430UL) {
#line 4455
    goto case_65430;
  }
#line 4459
  if (keysym == 65431UL) {
#line 4459
    goto case_65431;
  }
#line 4463
  if (keysym == 65432UL) {
#line 4463
    goto case_65432;
  }
#line 4467
  if (keysym == 65433UL) {
#line 4467
    goto case_65433;
  }
#line 4471
  if (keysym == 65434UL) {
#line 4471
    goto case_65434;
  }
#line 4475
  if (keysym == 65435UL) {
#line 4475
    goto case_65435;
  }
#line 4479
  if (keysym == 65436UL) {
#line 4479
    goto case_65436;
  }
#line 4483
  if (keysym == 65437UL) {
#line 4483
    goto case_65437;
  }
#line 4487
  if (keysym == 65438UL) {
#line 4487
    goto case_65438;
  }
#line 4491
  if (keysym == 65439UL) {
#line 4491
    goto case_65439;
  }
#line 4494
  if (keysym == 65469UL) {
#line 4494
    goto case_65469;
  }
#line 4496
  if (keysym == 65450UL) {
#line 4496
    goto case_65450;
  }
#line 4498
  if (keysym == 65451UL) {
#line 4498
    goto case_65451;
  }
#line 4500
  if (keysym == 65452UL) {
#line 4500
    goto case_65452;
  }
#line 4502
  if (keysym == 65453UL) {
#line 4502
    goto case_65453;
  }
#line 4504
  if (keysym == 65454UL) {
#line 4504
    goto case_65454;
  }
#line 4506
  if (keysym == 65455UL) {
#line 4506
    goto case_65455;
  }
#line 4509
  if (keysym == 65456UL) {
#line 4509
    goto case_65456;
  }
#line 4511
  if (keysym == 65457UL) {
#line 4511
    goto case_65457;
  }
#line 4513
  if (keysym == 65458UL) {
#line 4513
    goto case_65458;
  }
#line 4515
  if (keysym == 65459UL) {
#line 4515
    goto case_65459;
  }
#line 4517
  if (keysym == 65460UL) {
#line 4517
    goto case_65460;
  }
#line 4519
  if (keysym == 65461UL) {
#line 4519
    goto case_65461;
  }
#line 4521
  if (keysym == 65462UL) {
#line 4521
    goto case_65462;
  }
#line 4523
  if (keysym == 65463UL) {
#line 4523
    goto case_65463;
  }
#line 4525
  if (keysym == 65464UL) {
#line 4525
    goto case_65464;
  }
#line 4527
  if (keysym == 65465UL) {
#line 4527
    goto case_65465;
  }
#line 4530
  if (keysym == 65470UL) {
#line 4530
    goto case_65470;
  }
#line 4532
  if (keysym == 65471UL) {
#line 4532
    goto case_65471;
  }
#line 4534
  if (keysym == 65472UL) {
#line 4534
    goto case_65472;
  }
#line 4536
  if (keysym == 65473UL) {
#line 4536
    goto case_65473;
  }
#line 4538
  if (keysym == 65474UL) {
#line 4538
    goto case_65474;
  }
#line 4540
  if (keysym == 65475UL) {
#line 4540
    goto case_65475;
  }
#line 4542
  if (keysym == 65476UL) {
#line 4542
    goto case_65476;
  }
#line 4544
  if (keysym == 65477UL) {
#line 4544
    goto case_65477;
  }
#line 4546
  if (keysym == 65478UL) {
#line 4546
    goto case_65478;
  }
#line 4548
  if (keysym == 65479UL) {
#line 4548
    goto case_65479;
  }
#line 4550
  if (keysym == 65480UL) {
#line 4550
    goto case_65480;
  }
#line 4552
  if (keysym == 65481UL) {
#line 4552
    goto case_65481;
  }
#line 4555
  goto switch_default___0;
  case_65288: /* CIL Label */ 
#line 4391
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4391
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  8, 0, plot->plot_number);
    }
  } else {
    {
#line 4391
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  8, 0, plot->plot_number);
    }
  }
#line 4391
  return;
  case_65289: /* CIL Label */ 
#line 4393
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4393
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  9, 0, plot->plot_number);
    }
  } else {
    {
#line 4393
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  9, 0, plot->plot_number);
    }
  }
#line 4393
  return;
  case_65290: /* CIL Label */ 
#line 4395
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4395
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1001, 0, plot->plot_number);
    }
  } else {
    {
#line 4395
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1001, 0, plot->plot_number);
    }
  }
#line 4395
  return;
  case_65291: /* CIL Label */ 
#line 4397
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4397
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1002, 0, plot->plot_number);
    }
  } else {
    {
#line 4397
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1002, 0, plot->plot_number);
    }
  }
#line 4397
  return;
  case_65293: /* CIL Label */ 
#line 4399
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4399
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  13, 0, plot->plot_number);
    }
  } else {
    {
#line 4399
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  13, 0, plot->plot_number);
    }
  }
#line 4399
  return;
  case_65299: /* CIL Label */ 
#line 4401
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4401
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1003, 0, plot->plot_number);
    }
  } else {
    {
#line 4401
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1003, 0, plot->plot_number);
    }
  }
#line 4401
  return;
  case_65300: /* CIL Label */ 
#line 4403
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4403
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1004, 0, plot->plot_number);
    }
  } else {
    {
#line 4403
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1004, 0, plot->plot_number);
    }
  }
#line 4403
  return;
  case_65301: /* CIL Label */ 
#line 4406
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4406
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1005, 0, plot->plot_number);
    }
  } else {
    {
#line 4406
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1005, 0, plot->plot_number);
    }
  }
#line 4406
  return;
  case_65307: /* CIL Label */ 
#line 4409
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4409
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  27, 0, plot->plot_number);
    }
  } else {
    {
#line 4409
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  27, 0, plot->plot_number);
    }
  }
#line 4409
  return;
  case_65379: /* CIL Label */ 
#line 4411
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4411
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1006, 0, plot->plot_number);
    }
  } else {
    {
#line 4411
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1006, 0, plot->plot_number);
    }
  }
#line 4411
  return;
  case_65535: /* CIL Label */ 
#line 4413
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4413
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  127, 0, plot->plot_number);
    }
  } else {
    {
#line 4413
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  127, 0, plot->plot_number);
    }
  }
#line 4413
  return;
  case_65360: /* CIL Label */ 
#line 4415
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4415
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1007, 0, plot->plot_number);
    }
  } else {
    {
#line 4415
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1007, 0, plot->plot_number);
    }
  }
#line 4415
  return;
  case_65361: /* CIL Label */ 
#line 4417
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4417
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 4417
      tmp___1 = XCheckTypedWindowEvent(dpy, event->xany.window, 2, event);
      }
#line 4417
      if (! tmp___1) {
#line 4417
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4418
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4418
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1008, 0, plot->plot_number);
    }
  } else {
    {
#line 4418
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1008, 0, plot->plot_number);
    }
  }
#line 4418
  return;
  case_65362: /* CIL Label */ 
#line 4420
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4420
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4420
      tmp___2 = XCheckTypedWindowEvent(dpy, event->xany.window, 2, event);
      }
#line 4420
      if (! tmp___2) {
#line 4420
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4421
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4421
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1009, 0, plot->plot_number);
    }
  } else {
    {
#line 4421
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1009, 0, plot->plot_number);
    }
  }
#line 4421
  return;
  case_65363: /* CIL Label */ 
#line 4423
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4423
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 4423
      tmp___3 = XCheckTypedWindowEvent(dpy, event->xany.window, 2, event);
      }
#line 4423
      if (! tmp___3) {
#line 4423
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 4424
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4424
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1010, 0, plot->plot_number);
    }
  } else {
    {
#line 4424
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1010, 0, plot->plot_number);
    }
  }
#line 4424
  return;
  case_65364: /* CIL Label */ 
#line 4426
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4426
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 4426
      tmp___4 = XCheckTypedWindowEvent(dpy, event->xany.window, 2, event);
      }
#line 4426
      if (! tmp___4) {
#line 4426
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 4427
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4427
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1011, 0, plot->plot_number);
    }
  } else {
    {
#line 4427
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1011, 0, plot->plot_number);
    }
  }
#line 4427
  return;
  case_65365: /* CIL Label */ 
#line 4429
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4429
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1012, 0, plot->plot_number);
    }
  } else {
    {
#line 4429
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1012, 0, plot->plot_number);
    }
  }
#line 4429
  return;
  case_65366: /* CIL Label */ 
#line 4431
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4431
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1013, 0, plot->plot_number);
    }
  } else {
    {
#line 4431
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1013, 0, plot->plot_number);
    }
  }
#line 4431
  return;
  case_65367: /* CIL Label */ 
#line 4433
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4433
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1014, 0, plot->plot_number);
    }
  } else {
    {
#line 4433
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1014, 0, plot->plot_number);
    }
  }
#line 4433
  return;
  case_65368: /* CIL Label */ 
#line 4435
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4435
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1015, 0, plot->plot_number);
    }
  } else {
    {
#line 4435
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1015, 0, plot->plot_number);
    }
  }
#line 4435
  return;
  case_65408: /* CIL Label */ 
#line 4437
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4437
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1016, 0, plot->plot_number);
    }
  } else {
    {
#line 4437
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1016, 0, plot->plot_number);
    }
  }
#line 4437
  return;
  case_65417: /* CIL Label */ 
#line 4439
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4439
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1017, 0, plot->plot_number);
    }
  } else {
    {
#line 4439
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1017, 0, plot->plot_number);
    }
  }
#line 4439
  return;
  case_65421: /* CIL Label */ 
#line 4441
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4441
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  10, 0, plot->plot_number);
    }
  } else {
    {
#line 4441
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  10, 0, plot->plot_number);
    }
  }
#line 4441
  return;
  case_65425: /* CIL Label */ 
#line 4443
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4443
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1018, 0, plot->plot_number);
    }
  } else {
    {
#line 4443
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1018, 0, plot->plot_number);
    }
  }
#line 4443
  return;
  case_65426: /* CIL Label */ 
#line 4445
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4445
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1019, 0, plot->plot_number);
    }
  } else {
    {
#line 4445
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1019, 0, plot->plot_number);
    }
  }
#line 4445
  return;
  case_65427: /* CIL Label */ 
#line 4447
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4447
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1020, 0, plot->plot_number);
    }
  } else {
    {
#line 4447
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1020, 0, plot->plot_number);
    }
  }
#line 4447
  return;
  case_65428: /* CIL Label */ 
#line 4449
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4449
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1021, 0, plot->plot_number);
    }
  } else {
    {
#line 4449
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1021, 0, plot->plot_number);
    }
  }
#line 4449
  return;
  case_65429: /* CIL Label */ 
#line 4452
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4452
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1029, 0, plot->plot_number);
    }
  } else {
    {
#line 4452
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1029, 0, plot->plot_number);
    }
  }
#line 4452
  return;
  case_65430: /* CIL Label */ 
#line 4456
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4456
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1026, 0, plot->plot_number);
    }
  } else {
    {
#line 4456
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1026, 0, plot->plot_number);
    }
  }
#line 4456
  return;
  case_65431: /* CIL Label */ 
#line 4460
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4460
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1030, 0, plot->plot_number);
    }
  } else {
    {
#line 4460
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1030, 0, plot->plot_number);
    }
  }
#line 4460
  return;
  case_65432: /* CIL Label */ 
#line 4464
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4464
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1028, 0, plot->plot_number);
    }
  } else {
    {
#line 4464
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1028, 0, plot->plot_number);
    }
  }
#line 4464
  return;
  case_65433: /* CIL Label */ 
#line 4468
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4468
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1024, 0, plot->plot_number);
    }
  } else {
    {
#line 4468
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1024, 0, plot->plot_number);
    }
  }
#line 4468
  return;
  case_65434: /* CIL Label */ 
#line 4472
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4472
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1031, 0, plot->plot_number);
    }
  } else {
    {
#line 4472
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1031, 0, plot->plot_number);
    }
  }
#line 4472
  return;
  case_65435: /* CIL Label */ 
#line 4476
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4476
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1025, 0, plot->plot_number);
    }
  } else {
    {
#line 4476
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1025, 0, plot->plot_number);
    }
  }
#line 4476
  return;
  case_65436: /* CIL Label */ 
#line 4480
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4480
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1023, 0, plot->plot_number);
    }
  } else {
    {
#line 4480
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1023, 0, plot->plot_number);
    }
  }
#line 4480
  return;
  case_65437: /* CIL Label */ 
#line 4484
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4484
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1027, 0, plot->plot_number);
    }
  } else {
    {
#line 4484
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1027, 0, plot->plot_number);
    }
  }
#line 4484
  return;
  case_65438: /* CIL Label */ 
#line 4488
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4488
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1022, 0, plot->plot_number);
    }
  } else {
    {
#line 4488
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1022, 0, plot->plot_number);
    }
  }
#line 4488
  return;
  case_65439: /* CIL Label */ 
#line 4492
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4492
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1032, 0, plot->plot_number);
    }
  } else {
    {
#line 4492
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1032, 0, plot->plot_number);
    }
  }
#line 4492
  return;
  case_65469: /* CIL Label */ 
#line 4495
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4495
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1033, 0, plot->plot_number);
    }
  } else {
    {
#line 4495
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1033, 0, plot->plot_number);
    }
  }
#line 4495
  return;
  case_65450: /* CIL Label */ 
#line 4497
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4497
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1034, 0, plot->plot_number);
    }
  } else {
    {
#line 4497
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1034, 0, plot->plot_number);
    }
  }
#line 4497
  return;
  case_65451: /* CIL Label */ 
#line 4499
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4499
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1035, 0, plot->plot_number);
    }
  } else {
    {
#line 4499
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1035, 0, plot->plot_number);
    }
  }
#line 4499
  return;
  case_65452: /* CIL Label */ 
#line 4501
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4501
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1036, 0, plot->plot_number);
    }
  } else {
    {
#line 4501
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1036, 0, plot->plot_number);
    }
  }
#line 4501
  return;
  case_65453: /* CIL Label */ 
#line 4503
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4503
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1037, 0, plot->plot_number);
    }
  } else {
    {
#line 4503
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1037, 0, plot->plot_number);
    }
  }
#line 4503
  return;
  case_65454: /* CIL Label */ 
#line 4505
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4505
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1038, 0, plot->plot_number);
    }
  } else {
    {
#line 4505
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1038, 0, plot->plot_number);
    }
  }
#line 4505
  return;
  case_65455: /* CIL Label */ 
#line 4507
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4507
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1039, 0, plot->plot_number);
    }
  } else {
    {
#line 4507
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1039, 0, plot->plot_number);
    }
  }
#line 4507
  return;
  case_65456: /* CIL Label */ 
#line 4510
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4510
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1040, 0, plot->plot_number);
    }
  } else {
    {
#line 4510
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1040, 0, plot->plot_number);
    }
  }
#line 4510
  return;
  case_65457: /* CIL Label */ 
#line 4512
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4512
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1041, 0, plot->plot_number);
    }
  } else {
    {
#line 4512
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1041, 0, plot->plot_number);
    }
  }
#line 4512
  return;
  case_65458: /* CIL Label */ 
#line 4514
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4514
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1042, 0, plot->plot_number);
    }
  } else {
    {
#line 4514
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1042, 0, plot->plot_number);
    }
  }
#line 4514
  return;
  case_65459: /* CIL Label */ 
#line 4516
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4516
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1043, 0, plot->plot_number);
    }
  } else {
    {
#line 4516
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1043, 0, plot->plot_number);
    }
  }
#line 4516
  return;
  case_65460: /* CIL Label */ 
#line 4518
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4518
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1044, 0, plot->plot_number);
    }
  } else {
    {
#line 4518
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1044, 0, plot->plot_number);
    }
  }
#line 4518
  return;
  case_65461: /* CIL Label */ 
#line 4520
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4520
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1045, 0, plot->plot_number);
    }
  } else {
    {
#line 4520
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1045, 0, plot->plot_number);
    }
  }
#line 4520
  return;
  case_65462: /* CIL Label */ 
#line 4522
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4522
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1046, 0, plot->plot_number);
    }
  } else {
    {
#line 4522
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1046, 0, plot->plot_number);
    }
  }
#line 4522
  return;
  case_65463: /* CIL Label */ 
#line 4524
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4524
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1047, 0, plot->plot_number);
    }
  } else {
    {
#line 4524
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1047, 0, plot->plot_number);
    }
  }
#line 4524
  return;
  case_65464: /* CIL Label */ 
#line 4526
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4526
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1048, 0, plot->plot_number);
    }
  } else {
    {
#line 4526
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1048, 0, plot->plot_number);
    }
  }
#line 4526
  return;
  case_65465: /* CIL Label */ 
#line 4528
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4528
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1049, 0, plot->plot_number);
    }
  } else {
    {
#line 4528
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1049, 0, plot->plot_number);
    }
  }
#line 4528
  return;
  case_65470: /* CIL Label */ 
#line 4531
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4531
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1050, 0, plot->plot_number);
    }
  } else {
    {
#line 4531
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1050, 0, plot->plot_number);
    }
  }
#line 4531
  return;
  case_65471: /* CIL Label */ 
#line 4533
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4533
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1051, 0, plot->plot_number);
    }
  } else {
    {
#line 4533
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1051, 0, plot->plot_number);
    }
  }
#line 4533
  return;
  case_65472: /* CIL Label */ 
#line 4535
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4535
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1052, 0, plot->plot_number);
    }
  } else {
    {
#line 4535
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1052, 0, plot->plot_number);
    }
  }
#line 4535
  return;
  case_65473: /* CIL Label */ 
#line 4537
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4537
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1053, 0, plot->plot_number);
    }
  } else {
    {
#line 4537
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1053, 0, plot->plot_number);
    }
  }
#line 4537
  return;
  case_65474: /* CIL Label */ 
#line 4539
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4539
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1054, 0, plot->plot_number);
    }
  } else {
    {
#line 4539
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1054, 0, plot->plot_number);
    }
  }
#line 4539
  return;
  case_65475: /* CIL Label */ 
#line 4541
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4541
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1055, 0, plot->plot_number);
    }
  } else {
    {
#line 4541
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1055, 0, plot->plot_number);
    }
  }
#line 4541
  return;
  case_65476: /* CIL Label */ 
#line 4543
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4543
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1056, 0, plot->plot_number);
    }
  } else {
    {
#line 4543
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1056, 0, plot->plot_number);
    }
  }
#line 4543
  return;
  case_65477: /* CIL Label */ 
#line 4545
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4545
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1057, 0, plot->plot_number);
    }
  } else {
    {
#line 4545
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1057, 0, plot->plot_number);
    }
  }
#line 4545
  return;
  case_65478: /* CIL Label */ 
#line 4547
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4547
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1058, 0, plot->plot_number);
    }
  } else {
    {
#line 4547
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1058, 0, plot->plot_number);
    }
  }
#line 4547
  return;
  case_65479: /* CIL Label */ 
#line 4549
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4549
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1059, 0, plot->plot_number);
    }
  } else {
    {
#line 4549
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1059, 0, plot->plot_number);
    }
  }
#line 4549
  return;
  case_65480: /* CIL Label */ 
#line 4551
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4551
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1060, 0, plot->plot_number);
    }
  } else {
    {
#line 4551
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1060, 0, plot->plot_number);
    }
  }
#line 4551
  return;
  case_65481: /* CIL Label */ 
#line 4553
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4553
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1061, 0, plot->plot_number);
    }
  } else {
    {
#line 4553
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  1061, 0, plot->plot_number);
    }
  }
#line 4553
  return;
  switch_default___0: /* CIL Label */ 
#line 4556
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4556
    gp_exec_event((char)3, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  (int )keysym, 0, plot->plot_number);
    }
  } else {
    {
#line 4556
    gp_exec_event((char)6, (int )(((double )event->xkey.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xkey.y + 0.5) / yscale),
                  (int )keysym, 0, plot->plot_number);
    }
  }
#line 4556
  return;
#line 4557
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 4560
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 4563
  update_modifiers(event->xkey.state);
#line 4564
  tmp___5 = XKeycodeToKeysym(dpy, (KeyCode )event->xkey.keycode, 0);
#line 4564
  keysym = (KeySym )tmp___5;
#line 4565
  tmp___6 = is_meta(keysym);
  }
#line 4565
  if (tmp___6) {
    {
#line 4566
    plot = Find_Plot_In_Linked_List_By_Window(event->xkey.window);
#line 4567
    cursor = cursor_default;
    }
#line 4568
    if (plot) {
      {
#line 4569
      XDefineCursor(dpy, plot->window, cursor);
      }
    }
  }
#line 4572
  goto switch_break;
  case_33: /* CIL Label */ 
#line 4575
  if (event->xclient.message_type == WM_PROTOCOLS) {
#line 4575
    if (event->xclient.format == 32) {
#line 4575
      if ((Atom )event->xclient.data.l[0] == WM_DELETE_WINDOW) {
        {
#line 4577
        Remove_Plot_From_Linked_List(event->xclient.window);
        }
      }
    }
  }
#line 4580
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 4584
  plot = Find_Plot_In_Linked_List_By_Window(event->xconfigure.window);
  }
#line 4585
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4586
    gp_exec_event((char)10, 0, 0, 0, 0, 0);
    }
  }
#line 4588
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 4606
  tmp___7 = XCheckTypedWindowEvent(dpy, event->xany.window, 22, event);
  }
#line 4606
  if (tmp___7) {
    {
#line 4607
    process_configure_notify_event(event);
    }
#line 4608
    goto switch_break;
  }
  {
#line 4610
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 4610
    tmp___8 = XCheckTypedWindowEvent(dpy, event->xany.window, 12, event);
    }
#line 4610
    if (! tmp___8) {
#line 4610
      goto while_break___3;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 4612
  plot = Find_Plot_In_Linked_List_By_Window(event->xexpose.window);
  }
#line 4614
  if (plot) {
    {
#line 4615
    UpdateWindow(plot);
    }
  }
#line 4616
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 4619
  plot = Find_Plot_In_Linked_List_By_Window(event->xcrossing.window);
  }
#line 4620
  if (! plot) {
#line 4621
    goto switch_break;
  }
#line 4622
  if ((unsigned long )plot == (unsigned long )current_plot) {
#line 4623
    if (xscale < 0.) {
      {
#line 4623
      display(plot);
      }
    }
    {
#line 4624
    gp_exec_event((char)0, (int )(((double )event->xcrossing.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xcrossing.y + 0.5) / yscale),
                  0, 0, 0);
    }
  }
#line 4626
  if (plot->zoombox_on) {
    {
#line 4627
    DrawBox(plot);
#line 4628
    plot->zoombox_x2 = event->xcrossing.x;
#line 4629
    plot->zoombox_y2 = event->xcrossing.y;
#line 4630
    DrawBox(plot);
    }
  }
#line 4632
  if (plot->ruler_on) {
    {
#line 4633
    DrawLineToRuler(plot);
#line 4634
    plot->ruler_lineto_x = event->xcrossing.x;
#line 4635
    plot->ruler_lineto_y = event->xcrossing.y;
#line 4636
    DrawLineToRuler(plot);
    }
  }
#line 4638
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 4640
  update_modifiers(event->xmotion.state);
#line 4641
  plot = Find_Plot_In_Linked_List_By_Window(event->xmotion.window);
  }
#line 4642
  if (! plot) {
#line 4643
    goto switch_break;
  }
  {
#line 4648
  tmp___9 = XQueryPointer(dpy, event->xmotion.window, & root___0, & child, & root_x,
                          & root_y, & pos_x, & pos_y, & keys_buttons);
  }
#line 4648
  if (! tmp___9) {
#line 4649
    goto switch_break;
  }
#line 4651
  if ((unsigned long )plot == (unsigned long )current_plot) {
#line 4651
    if (! pipe_died) {
#line 4656
      if (xscale < 0.) {
        {
#line 4656
        display(plot);
        }
      }
      {
#line 4657
      gp_exec_event((char)0, (int )(((double )pos_x + 0.5) / xscale), (int )((double )4095 - ((double )pos_y + 0.5) / yscale),
                    0, 0, 0);
      }
    } else {
#line 4651
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 4659
  if (plot->axis_mask) {
#line 4659
    if (plot->mouse_on) {
#line 4659
      if (plot->almost2d) {
        {
#line 4662
        m = mouse_format;
#line 4665
        *m = (char )'\000';
#line 4666
        mouse_to_coords(plot, event, & x, & y, & x2, & y2);
        }
#line 4667
        if (plot->axis_mask & (1 << 2)) {
          {
#line 4668
          sprintf((char */* __restrict  */)m, (char const   */* __restrict  */)"x=  %10g %c",
                  x, '\000');
#line 4669
          m += 15;
          }
        }
#line 4671
        if (plot->axis_mask & (1 << 6)) {
          {
#line 4672
          sprintf((char */* __restrict  */)m, (char const   */* __restrict  */)"x2= %10g %c",
                  x2, '\000');
#line 4673
          m += 15;
          }
        }
#line 4675
        if (plot->axis_mask & (1 << 1)) {
          {
#line 4676
          sprintf((char */* __restrict  */)m, (char const   */* __restrict  */)"y=  %10g %c",
                  y, '\000');
#line 4677
          m += 15;
          }
        }
#line 4679
        if (plot->axis_mask & (1 << 5)) {
          {
#line 4680
          sprintf((char */* __restrict  */)m, (char const   */* __restrict  */)"y2= %10g %c",
                  y2, '\000');
#line 4681
          m += 15;
          }
        }
        {
#line 4683
        DisplayCoords(plot, (char const   *)(mouse_format));
        }
      } else {
#line 4659
        goto _L___2;
      }
    } else {
#line 4659
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 4684
  if (! plot->mouse_on) {
    {
#line 4685
    DisplayCoords(plot, "");
    }
  }
#line 4689
  if (plot->zoombox_on) {
    {
#line 4690
    DrawBox(plot);
#line 4691
    plot->zoombox_x2 = pos_x;
#line 4692
    plot->zoombox_y2 = pos_y;
#line 4693
    DrawBox(plot);
    }
  }
#line 4695
  if (plot->ruler_on) {
#line 4695
    if (plot->ruler_lineto_on) {
      {
#line 4696
      DrawLineToRuler(plot);
#line 4697
      plot->ruler_lineto_x = event->xcrossing.x;
#line 4698
      plot->ruler_lineto_y = event->xcrossing.y;
#line 4699
      DrawLineToRuler(plot);
      }
    }
  }
#line 4702
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 4704
  update_modifiers(event->xbutton.state);
#line 4706
  button_pressed |= 1 << event->xbutton.button;
#line 4708
  plot = Find_Plot_In_Linked_List_By_Window(event->xbutton.window);
  }
#line 4709
  if (! plot) {
#line 4710
    goto switch_break;
  }
#line 4712
  if ((unsigned long )plot == (unsigned long )current_plot) {
#line 4713
    if (xscale < 0.) {
      {
#line 4713
      display(plot);
      }
    }
    {
#line 4714
    gp_exec_event((char)1, (int )(((double )event->xbutton.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xbutton.y + 0.5) / yscale),
                  (int )event->xbutton.button, 0, 0);
    }
  }
#line 4717
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 4720
  button_pressed &= ~ (1 << event->xbutton.button);
#line 4722
  plot = Find_Plot_In_Linked_List_By_Window(event->xbutton.window);
  }
#line 4723
  if (! plot) {
#line 4724
    goto switch_break;
  }
#line 4725
  if ((unsigned long )plot == (unsigned long )current_plot) {
    {
#line 4727
    tmp___10 = SetTime(plot, event->xbutton.time);
#line 4727
    doubleclick = tmp___10;
#line 4729
    update_modifiers(event->xbutton.state);
    }
#line 4730
    if (xscale < 0.) {
      {
#line 4730
      display(plot);
      }
    }
    {
#line 4731
    gp_exec_event((char)2, (int )(((double )event->xbutton.x + 0.5) / xscale), (int )((double )4095 - ((double )event->xbutton.y + 0.5) / yscale),
                  (int )event->xbutton.button, (int )doubleclick, 0);
    }
  }
#line 4750
  goto switch_break;
  case_31: /* CIL Label */ 
#line 4754
  goto switch_break;
  case_30: /* CIL Label */ 
#line 4756
  if (exportselection) {
    {
#line 4757
    handle_selection_event(event);
    }
  }
#line 4758
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4762
  return;
}
}
#line 4778 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmDatabase dbCmd  ;
#line 4778 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmDatabase dbApp  ;
#line 4778 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmDatabase dbDef  ;
#line 4778 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmDatabase dbEnv  ;
#line 4778 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmDatabase db  =    (XrmDatabase )0;
#line 4780 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *type[20]  ;
#line 4781 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmValue value  ;
#line 4783 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XrmOptionDescRec options[35]  = 
#line 4783
  {      {(char *)"-mono", (char *)".mono", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-gray", (char *)".gray", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-clear", (char *)".clear", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-tvtwm", (char *)".tvtwm", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-pointsize", (char *)".pointsize", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-display",
      (char *)".display", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-name", (char *)".name", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-geometry",
      (char *)"*geometry", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-background", (char *)"*background", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-bg",
      (char *)"*background", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-foreground", (char *)"*foreground", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-fg",
      (char *)"*foreground", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-bordercolor", (char *)"*bordercolor", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-bd",
      (char *)"*bordercolor", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-borderwidth", (char *)".borderWidth", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-bw",
      (char *)".borderWidth", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-font", (char *)"*font", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-fn",
      (char *)"*font", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-reverse", (char *)"*reverseVideo", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-rv",
      (char *)"*reverseVideo", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"+rv", (char *)"*reverseVideo", (XrmOptionKind )0, (XPointer )"off"}, 
        {(char *)"-iconic",
      (char *)"*iconic", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-synchronous", (char *)"*synchronous", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-xnllanguage",
      (char *)"*xnllanguage", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-selectionTimeout", (char *)"*selectionTimeout", (XrmOptionKind )3,
      (XPointer )((void *)0)}, 
        {(char *)"-title", (char *)".title", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-xrm",
      (char *)((void *)0), (XrmOptionKind )4, (XPointer )((void *)0)}, 
        {(char *)"-raise", (char *)"*raise", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-noraise", (char *)"*raise", (XrmOptionKind )0, (XPointer )"off"}, 
        {(char *)"-feedback", (char *)"*feedback", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-nofeedback",
      (char *)"*feedback", (XrmOptionKind )0, (XPointer )"off"}, 
        {(char *)"-ctrlq", (char *)"*ctrlq", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-dashed", (char *)"*dashed", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-solid", (char *)"*dashed", (XrmOptionKind )0, (XPointer )"off"}, 
        {(char *)"-persist", (char *)"*persist", (XrmOptionKind )0, (XPointer )"on"}};
#line 4823 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void preset(int argc , char **argv ) 
{ 
  int Argc ;
  char **Argv ;
  char *ldisplay ;
  char *tmp ;
  char *home ;
  char *tmp___0 ;
  char *server_defaults ;
  char *env ;
  char buffer[256] ;
  char *db_string ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  char *appdefdir ;
  char *p ;
  char host[64] ;
  int tmp___6 ;
  char *tmp___8 ;
  Visual *visual ;
  int depth ;
  char **ptr ;
  int i ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___12 ;
  int itmp ;
  double tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___17 ;
  int itmp___0 ;
  double tmp___18 ;
  int tmp___19 ;

  {
  {
#line 4826
  Argc = argc;
#line 4827
  Argv = argv;
#line 4832
  tmp = getenv("DISPLAY");
#line 4832
  ldisplay = tmp;
#line 4834
  tmp___0 = getenv("HOME");
#line 4834
  home = tmp___0;
  }
#line 4845
  if ((unsigned long )ldisplay == (unsigned long )((void *)0)) {
#line 4846
    ldisplay = (char *)"";
  }
#line 4847
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 4848
    home = (char *)"";
  }
  {
#line 4852
  signal(2, (void (*)(int  ))1);
#line 4854
  signal(20, (void (*)(int  ))1);
  }
  {
#line 4859
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4859
    Argv ++;
#line 4859
    Argc --;
#line 4859
    if (! (Argc > 0)) {
#line 4859
      goto while_break;
    }
    {
#line 4860
    tmp___1 = strcmp((char const   *)*Argv, "-name");
    }
#line 4860
    if (! tmp___1) {
#line 4860
      if (Argc > 1) {
        {
#line 4861
        strncpy((char */* __restrict  */)(X_Name), (char const   */* __restrict  */)*(Argv + 1),
                sizeof(X_Name) - 1UL);
#line 4862
        strncpy((char */* __restrict  */)(X_Class), (char const   */* __restrict  */)*(Argv + 1),
                sizeof(X_Class) - 1UL);
#line 4864
        X_Name[sizeof(X_Name) - 1UL] = (char )'\000';
#line 4865
        X_Class[sizeof(X_Class) - 1UL] = (char )'\000';
        }
#line 4866
        if ((int )X_Class[0] >= 97) {
#line 4866
          if ((int )X_Class[0] <= 122) {
#line 4867
            X_Class[0] = (char )((int )X_Class[0] - 32);
          }
        }
      }
    }
    {
#line 4869
    tmp___2 = strcmp((char const   *)*Argv, "--version");
    }
#line 4869
    if (! tmp___2) {
      {
#line 4870
      printf((char const   */* __restrict  */)"gnuplot %s patchlevel %s\n", gnuplot_version,
             gnuplot_patchlevel);
#line 4872
      exit(1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4875
  Argc = argc;
#line 4876
  Argv = argv;
#line 4880
  XrmInitialize();
#line 4881
  XrmParseCommand(& dbCmd, options, (int )(sizeof(options) / sizeof(options[0])),
                  (char const   *)(X_Name), & Argc, Argv);
  }
#line 4882
  if (Argc > 1) {
    {
#line 4884
    tmp___3 = strcmp((char const   *)*(Argv + 1), "-noevents");
    }
#line 4884
    if (tmp___3) {
      {
#line 4888
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: bad option: %s\ngnuplot: X11 aborted.\n",
              *(Argv + 1));
      }
      {
#line 4891
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 4891
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 4891
        close(1);
#line 4891
        close(0);
#line 4891
        exit(1);
        }
#line 4891
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 4885
      pipe_died = 1;
    }
  }
  {
#line 4896
  tmp___4 = pr_GetR(dbCmd, (char *)".display");
  }
#line 4896
  if (tmp___4) {
#line 4897
    ldisplay = value.addr;
  }
  {
#line 4902
  XSetErrorHandler(& ErrorHandler);
#line 4904
  dpy = XOpenDisplay((char const   *)ldisplay);
  }
#line 4905
  if (! dpy) {
    {
#line 4906
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: unable to open display \'%s\'\ngnuplot: X11 aborted.\n",
            ldisplay);
    }
    {
#line 4909
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 4909
      gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 4909
      close(1);
#line 4909
      close(0);
#line 4909
      exit(1);
      }
#line 4909
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 4911
  scr = ((_XPrivDisplay )dpy)->default_screen;
#line 4912
  root = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 4913
  server_defaults = XResourceManagerString(dpy);
#line 4914
  vis = (((_XPrivDisplay )dpy)->screens + scr)->root_visual;
#line 4915
  dep = (unsigned int )(((_XPrivDisplay )dpy)->screens + scr)->root_depth;
#line 4916
  default_cmap.colormap = (((_XPrivDisplay )dpy)->screens + scr)->cmap;
#line 4917
  current_cmap = & default_cmap;
#line 4918
  tmp___5 = XMaxRequestSize(dpy);
#line 4918
  max_request_size = tmp___5 / 2L;
#line 4923
  WM_PROTOCOLS = XInternAtom(dpy, "WM_PROTOCOLS", 0);
#line 4924
  WM_DELETE_WINDOW = XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
#line 4943
  appdefdir = getenv("XAPPLRESDIR");
  }
#line 4943
  if ((unsigned long )appdefdir == (unsigned long )((void *)0)) {
    {
#line 4945
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"/etc/X11/app-defaults/");
#line 4946
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"/");
#line 4947
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"Gnuplot");
    }
  } else {
    {
#line 4952
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)appdefdir);
#line 4953
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"/");
#line 4954
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"Gnuplot");
    }
  }
  {
#line 4959
  dbApp = XrmGetFileDatabase((char const   *)(buffer));
#line 4960
  XrmMergeDatabases(dbApp, & db);
  }
#line 4964
  if (server_defaults) {
    {
#line 4965
    dbDef = XrmGetStringDatabase((char const   *)server_defaults);
    }
  } else {
    {
#line 4970
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)home);
#line 4971
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"/.Xdefaults");
#line 4973
    dbDef = XrmGetFileDatabase((char const   *)(buffer));
    }
  }
  {
#line 4975
  XrmMergeDatabases(dbDef, & db);
#line 4980
  env = getenv("XENVIRONMENT");
  }
#line 4980
  if ((unsigned long )env != (unsigned long )((void *)0)) {
    {
#line 4981
    dbEnv = XrmGetFileDatabase((char const   *)env);
    }
  } else {
    {
#line 4983
    p = (char *)((void *)0);
#line 4985
    tmp___6 = gethostname(host, (size_t )64);
    }
#line 4985
    if (tmp___6 < 0) {
      {
#line 4986
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: %s failed. X11 aborted.\n",
              "gethostname");
      }
      {
#line 4987
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 4987
        gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 4987
        close(1);
#line 4987
        close(0);
#line 4987
        exit(1);
        }
#line 4987
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 4989
    p = strchr((char const   *)(host), '.');
    }
#line 4989
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 4990
      *p = (char )'\000';
    }
    {
#line 4991
    strcpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)home);
#line 4992
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"/.Xdefaults-");
#line 4993
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)(host));
#line 4994
    dbEnv = XrmGetFileDatabase((char const   *)(buffer));
    }
  }
  {
#line 4996
  XrmMergeDatabases(dbEnv, & db);
#line 5001
  XrmMergeDatabases(dbCmd, & db);
#line 5006
  tmp___8 = pr_GetR(db, (char *)".visual");
  }
#line 5006
  if (tmp___8) {
#line 5006
    db_string = value.addr;
  } else {
#line 5006
    db_string = (char *)0;
  }
#line 5007
  if (db_string) {
#line 5008
    visual = (Visual *)0;
#line 5009
    depth = 0;
#line 5010
    ptr = visual_name;
#line 5012
    i = 0;
    {
#line 5012
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 5012
      if (! *ptr) {
#line 5012
        goto while_break___3;
      }
      {
#line 5013
      tmp___10 = strcmp((char const   *)db_string, (char const   *)*ptr);
      }
#line 5013
      if (! tmp___10) {
        {
#line 5019
        tmp___9 = GetVisual(i, & visual, & depth);
        }
#line 5019
        if (tmp___9) {
#line 5020
          vis = visual;
#line 5021
          dep = (unsigned int )depth;
#line 5022
          if ((unsigned long )vis != (unsigned long )(((_XPrivDisplay )dpy)->screens + scr)->root_visual) {
            {
#line 5024
            default_cmap.colormap = XCreateColormap(dpy, root, vis, 0);
            }
          }
        } else {
          {
#line 5027
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s not supported by %s, using default.\n",
                  *ptr, ldisplay);
          }
        }
#line 5029
        goto while_break___3;
      }
#line 5012
      i ++;
#line 5012
      ptr ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 5038
  CmapClear(& default_cmap);
  }
#line 5041
  if (dep > 12U) {
#line 5042
    maximal_possible_colors = 512U;
  } else
#line 5043
  if (dep > 8U) {
#line 5044
    maximal_possible_colors = 256U;
  } else {
#line 5047
    maximal_possible_colors = 240U;
  }
  {
#line 5051
  tmp___12 = pr_GetR(db, (char *)".maxcolors");
  }
#line 5051
  if (tmp___12) {
#line 5051
    db_string = value.addr;
  } else {
#line 5051
    db_string = (char *)0;
  }
#line 5052
  if (db_string) {
    {
#line 5054
    tmp___14 = sscanf((char const   */* __restrict  */)db_string, (char const   */* __restrict  */)"%d",
                      & itmp);
    }
#line 5054
    if (tmp___14) {
#line 5055
      if (itmp <= 0) {
        {
#line 5056
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nmaxcolors must be strictly positive.\n");
        }
      } else {
        {
#line 5057
        tmp___13 = pow((double )2, (double )dep);
        }
#line 5057
        if ((double )itmp > tmp___13) {
          {
#line 5058
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\noops, cannot use this many colors on a %d bit deep display.\n",
                  dep);
          }
        } else {
#line 5060
          maximal_possible_colors = (unsigned int )itmp;
        }
      }
    } else {
      {
#line 5063
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nunable to parse \'%s\' as integer\n",
              db_string);
      }
    }
  }
#line 5068
  if (num_colormaps > 1) {
#line 5068
    tmp___15 = 2;
  } else {
#line 5068
    tmp___15 = 8;
  }
  {
#line 5068
  minimal_possible_colors = maximal_possible_colors / (unsigned int )tmp___15;
#line 5070
  tmp___17 = pr_GetR(db, (char *)".mincolors");
  }
#line 5070
  if (tmp___17) {
#line 5070
    db_string = value.addr;
  } else {
#line 5070
    db_string = (char *)0;
  }
#line 5071
  if (db_string) {
    {
#line 5073
    tmp___19 = sscanf((char const   */* __restrict  */)db_string, (char const   */* __restrict  */)"%d",
                      & itmp___0);
    }
#line 5073
    if (tmp___19) {
#line 5074
      if (itmp___0 <= 0) {
        {
#line 5075
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nmincolors must be strictly positive.\n");
        }
      } else {
        {
#line 5076
        tmp___18 = pow((double )2, (double )dep);
        }
#line 5076
        if ((double )itmp___0 > tmp___18) {
          {
#line 5077
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\noops, cannot use this many colors on a %d bit deep display.\n",
                  dep);
          }
        } else
#line 5078
        if ((unsigned int )itmp___0 > maximal_possible_colors) {
          {
#line 5079
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nmincolors must be <= %d\n",
                  maximal_possible_colors);
          }
        } else {
#line 5081
          minimal_possible_colors = (unsigned int )itmp___0;
        }
      }
    } else {
      {
#line 5084
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nunable to parse \'%s\' as integer\n",
              db_string);
      }
    }
  }
  {
#line 5088
  pr_geometry((char *)((void *)0));
#line 5089
  pr_encoding();
#line 5090
  pr_font((char *)((void *)0));
#line 5091
  pr_color(& default_cmap);
#line 5092
  pr_width();
#line 5093
  pr_dashes();
#line 5094
  pr_pointsize();
#line 5095
  pr_raise();
#line 5096
  pr_persist();
#line 5097
  pr_feedback();
#line 5098
  pr_ctrlq();
#line 5099
  pr_fastrotate();
#line 5101
  pr_exportselection();
  }
#line 5104
  return;
}
}
#line 5110 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *pr_GetR(XrmDatabase xrdb , char *resource ) 
{ 
  char name[128] ;
  char class[128] ;
  char *rc ;
  int tmp___0 ;

  {
  {
#line 5115
  strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)(X_Name));
#line 5116
  strcat((char */* __restrict  */)(name), (char const   */* __restrict  */)resource);
#line 5117
  strcpy((char */* __restrict  */)(class), (char const   */* __restrict  */)(X_Class));
#line 5118
  strcat((char */* __restrict  */)(class), (char const   */* __restrict  */)resource);
#line 5119
  tmp___0 = XrmGetResource(xrdb, (char const   *)(name), (char const   *)(class),
                           type, & value);
  }
#line 5119
  if (tmp___0) {
#line 5119
    rc = value.addr;
  } else {
#line 5119
    rc = (char *)0;
  }
#line 5121
  return (rc);
}
}
#line 5128 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char const   color_keys[13][30]  = 
#line 5128
  { {        (char const   )'b',        (char const   )'a',        (char const   )'c',        (char const   )'k', 
            (char const   )'g',        (char const   )'r',        (char const   )'o',        (char const   )'u', 
            (char const   )'n',        (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'b',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'c',        (char const   )'o', 
            (char const   )'l',        (char const   )'o',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'e',        (char const   )'x',        (char const   )'t', 
            (char const   )'\000'}, 
   {        (char const   )'b',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'a',        (char const   )'x',        (char const   )'i',        (char const   )'s', 
            (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'1',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'2',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'3',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'4',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'5',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'6',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'7',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'8',        (char const   )'\000'}};
#line 5133 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char color_values[13][30]  = 
#line 5133
  { {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'r',        (char )'e',        (char )'d',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'e',        (char )'e', 
            (char )'n',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'u',        (char )'e', 
            (char )'\000'}, 
   {        (char )'m',        (char )'a',        (char )'g',        (char )'e', 
            (char )'n',        (char )'t',        (char )'a',        (char )'\000'}, 
   {        (char )'c',        (char )'y',        (char )'a',        (char )'n', 
            (char )'\000'}, 
   {        (char )'s',        (char )'i',        (char )'e',        (char )'n', 
            (char )'n',        (char )'a',        (char )'\000'}, 
   {        (char )'o',        (char )'r',        (char )'a',        (char )'n', 
            (char )'g',        (char )'e',        (char )'\000'}, 
   {        (char )'c',        (char )'o',        (char )'r',        (char )'a', 
            (char )'l',        (char )'\000'}};
#line 5138 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char color_values_rv[13][30]  = 
#line 5138
  { {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'r',        (char )'e',        (char )'d',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'e',        (char )'e', 
            (char )'n',        (char )'\000'}, 
   {        (char )'b',        (char )'l',        (char )'u',        (char )'e', 
            (char )'\000'}, 
   {        (char )'m',        (char )'a',        (char )'g',        (char )'e', 
            (char )'n',        (char )'t',        (char )'a',        (char )'\000'}, 
   {        (char )'c',        (char )'y',        (char )'a',        (char )'n', 
            (char )'\000'}, 
   {        (char )'s',        (char )'i',        (char )'e',        (char )'n', 
            (char )'n',        (char )'a',        (char )'\000'}, 
   {        (char )'o',        (char )'r',        (char )'a',        (char )'n', 
            (char )'g',        (char )'e',        (char )'\000'}, 
   {        (char )'c',        (char )'o',        (char )'r',        (char )'a', 
            (char )'l',        (char )'\000'}};
#line 5143 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char gray_values[13][30]  = 
#line 5143
  { {        (char )'b',        (char )'l',        (char )'a',        (char )'c', 
            (char )'k',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'w',        (char )'h',        (char )'i',        (char )'t', 
            (char )'e',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'5',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'5',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'1',        (char )'0',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'6',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'8',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'4',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'9',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'5',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'7',        (char )'0',        (char )'\000'}, 
   {        (char )'g',        (char )'r',        (char )'a',        (char )'y', 
            (char )'3',        (char )'0',        (char )'\000'}};
#line 5149 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_color(cmap_t *cmap_ptr ) 
{ 
  unsigned long black ;
  unsigned long white ;
  char option[20] ;
  char color[30] ;
  char *v ;
  char *ctype ;
  XColor xcolor ;
  double intensity ;
  int n ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 5152
  black = (((_XPrivDisplay )dpy)->screens + scr)->black_pixel;
#line 5152
  white = (((_XPrivDisplay )dpy)->screens + scr)->white_pixel;
#line 5155
  intensity = (double )-1;
#line 5158
  tmp = pr_GetR(db, (char *)".mono");
  }
#line 5158
  if (tmp) {
    {
#line 5158
    tmp___0 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5158
    if (tmp___0) {
      {
#line 5158
      tmp___1 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5158
      if (! tmp___1) {
#line 5159
        Mono ++;
      }
    } else {
#line 5159
      Mono ++;
    }
  }
  {
#line 5160
  tmp___2 = pr_GetR(db, (char *)".gray");
  }
#line 5160
  if (tmp___2) {
    {
#line 5160
    tmp___3 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5160
    if (tmp___3) {
      {
#line 5160
      tmp___4 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5160
      if (! tmp___4) {
#line 5161
        Gray ++;
      }
    } else {
#line 5161
      Gray ++;
    }
  }
  {
#line 5162
  tmp___5 = pr_GetR(db, (char *)".reverseVideo");
  }
#line 5162
  if (tmp___5) {
    {
#line 5162
    tmp___6 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5162
    if (tmp___6) {
      {
#line 5162
      tmp___7 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5162
      if (! tmp___7) {
#line 5163
        Rv ++;
      }
    } else {
#line 5163
      Rv ++;
    }
  }
#line 5165
  if (! Gray) {
#line 5165
    if (vis->class == 1) {
#line 5166
      Mono ++;
    } else
#line 5165
    if (vis->class == 0) {
#line 5166
      Mono ++;
    }
  }
#line 5168
  if (! Mono) {
#line 5170
    if (Gray) {
#line 5170
      ctype = (char *)"Gray";
    } else {
#line 5170
      ctype = (char *)"Color";
    }
#line 5172
    if ((unsigned long )current_cmap != (unsigned long )cmap_ptr) {
      {
#line 5175
      xcolor.red = (unsigned short)0;
#line 5176
      xcolor.green = (unsigned short)0;
#line 5177
      xcolor.blue = (unsigned short)0;
#line 5178
      XAllocColor(dpy, cmap_ptr->colormap, & xcolor);
      }
    }
#line 5181
    n = 0;
    {
#line 5181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5181
      if (! (n < 13)) {
#line 5181
        goto while_break;
      }
      {
#line 5182
      strcpy((char */* __restrict  */)(option), (char const   */* __restrict  */)".");
#line 5183
      strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)(color_keys[n]));
      }
#line 5184
      if (n > 1) {
        {
#line 5185
        strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)ctype);
        }
      }
      {
#line 5186
      tmp___11 = pr_GetR(db, option);
      }
#line 5186
      if (tmp___11) {
#line 5186
        v = value.addr;
      } else {
#line 5186
        if (Gray) {
#line 5186
          tmp___10 = gray_values[n];
        } else {
#line 5186
          if (Rv) {
#line 5186
            tmp___9 = color_values_rv[n];
          } else {
#line 5186
            tmp___9 = color_values[n];
          }
#line 5186
          tmp___10 = tmp___9;
        }
#line 5186
        v = tmp___10;
      }
      {
#line 5190
      tmp___12 = sscanf((char const   */* __restrict  */)v, (char const   */* __restrict  */)"%30[^, ], %lf",
                        color, & intensity);
      }
#line 5190
      if (tmp___12 == 2) {
#line 5191
        if (intensity < (double )0) {
          {
#line 5192
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: invalid color intensity in \'%s\'\n",
                  color);
#line 5193
          intensity = (double )1;
          }
        } else
#line 5191
        if (intensity > (double )1) {
          {
#line 5192
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: invalid color intensity in \'%s\'\n",
                  color);
#line 5193
          intensity = (double )1;
          }
        }
      } else {
        {
#line 5196
        strcpy((char */* __restrict  */)(color), (char const   */* __restrict  */)v);
#line 5197
        intensity = (double )1;
        }
      }
      {
#line 5200
      tmp___14 = XParseColor(dpy, cmap_ptr->colormap, (char const   *)(color), & xcolor);
      }
#line 5200
      if (tmp___14) {
        {
#line 5204
        xcolor.red = (unsigned short )((double )xcolor.red * intensity);
#line 5205
        xcolor.green = (unsigned short )((double )xcolor.green * intensity);
#line 5206
        xcolor.blue = (unsigned short )((double )xcolor.blue * intensity);
#line 5207
        tmp___13 = XAllocColor(dpy, cmap_ptr->colormap, & xcolor);
        }
#line 5207
        if (tmp___13) {
#line 5208
          cmap_ptr->colors[n] = xcolor.pixel;
#line 5209
          cmap_ptr->rgbcolors[n] = (unsigned long )((((((int )xcolor.red >> 8) & 255) << 16) + ((((int )xcolor.green >> 8) & 255) << 8)) + ((int )xcolor.blue >> 8));
        } else {
          {
#line 5213
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: can\'t allocate \'%s\'. Using black.\n",
                  v);
#line 5214
          cmap_ptr->colors[n] = black;
          }
        }
      } else {
        {
#line 5201
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: unable to parse \'%s\'. Using black.\n",
                color);
#line 5202
        cmap_ptr->colors[n] = black;
        }
      }
#line 5181
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 5219
    if (Rv) {
#line 5219
      cmap_ptr->colors[0] = black;
    } else {
#line 5219
      cmap_ptr->colors[0] = white;
    }
#line 5220
    n = 1;
    {
#line 5220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5220
      if (! (n < 13)) {
#line 5220
        goto while_break___0;
      }
#line 5221
      if (Rv) {
#line 5221
        cmap_ptr->colors[n] = white;
      } else {
#line 5221
        cmap_ptr->colors[n] = black;
      }
#line 5220
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 5228
  AllocateXorPixel(cmap_ptr);
  }
#line 5231
  return;
}
}
#line 5237 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char const   dash_keys[10][10]  = 
#line 5237
  { {        (char const   )'b',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'a',        (char const   )'x',        (char const   )'i',        (char const   )'s', 
            (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'1',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'2',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'3',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'4',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'5',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'6',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'7',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'8',        (char const   )'\000'}};
#line 5242 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char dash_mono[10][10]  = 
#line 5242
  { {        (char )'0',        (char )'\000'}, 
   {        (char )'1',        (char )'6',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'4',        (char )'2',        (char )'\000'}, 
   {        (char )'1',        (char )'3',        (char )'\000'}, 
   {        (char )'4',        (char )'4',        (char )'\000'}, 
   {        (char )'1',        (char )'5',        (char )'\000'}, 
   {        (char )'4',        (char )'4',        (char )'4',        (char )'1', 
            (char )'\000'}, 
   {        (char )'4',        (char )'2',        (char )'\000'}, 
   {        (char )'1',        (char )'3',        (char )'\000'}};
#line 5247 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char dash_color[10][10]  = 
#line 5247
  { {        (char )'0',        (char )'\000'}, 
   {        (char )'1',        (char )'6',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}, 
   {        (char )'0',        (char )'\000'}};
#line 5252 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_dashes(void) 
{ 
  int n ;
  int j ;
  int l ;
  int ok ;
  char option[20] ;
  char *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 5258
  tmp___2 = pr_GetR(db, (char *)".dashed");
  }
#line 5258
  if (tmp___2) {
    {
#line 5259
    tmp = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5259
    if (tmp) {
      {
#line 5259
      tmp___0 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5259
      if (tmp___0) {
#line 5259
        tmp___1 = 0;
      } else {
#line 5259
        tmp___1 = 1;
      }
    } else {
#line 5259
      tmp___1 = 1;
    }
#line 5259
    dashedlines = tmp___1;
  }
#line 5262
  n = 0;
  {
#line 5262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5262
    if (! (n < 10)) {
#line 5262
      goto while_break;
    }
    {
#line 5263
    strcpy((char */* __restrict  */)(option), (char const   */* __restrict  */)".");
#line 5264
    strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)(dash_keys[n]));
#line 5265
    strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)"Dashes");
#line 5266
    tmp___5 = pr_GetR(db, option);
    }
#line 5266
    if (tmp___5) {
#line 5266
      v = value.addr;
    } else {
#line 5266
      if (Mono) {
#line 5266
        tmp___4 = dash_mono[n];
      } else {
#line 5266
        tmp___4 = dash_color[n];
      }
#line 5266
      v = tmp___4;
    }
    {
#line 5268
    tmp___6 = strlen((char const   *)v);
#line 5268
    l = (int )tmp___6;
    }
#line 5269
    if (l == 1) {
#line 5269
      if ((int )*v == 48) {
#line 5270
        dashes[n][0] = (char)0;
#line 5271
        goto __Cont;
      }
    }
#line 5273
    ok = 0;
#line 5273
    j = 0;
    {
#line 5273
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5273
      if (! (j < l)) {
#line 5273
        goto while_break___0;
      }
#line 5274
      if ((int )*(v + j) >= 49) {
#line 5274
        if ((int )*(v + j) <= 57) {
#line 5275
          ok ++;
        }
      }
#line 5273
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5277
    if (ok != l) {
      {
#line 5278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: illegal dashes value %s:%s\n",
              option, v);
#line 5280
      dashes[n][0] = (char)0;
      }
#line 5281
      goto __Cont;
    } else
#line 5277
    if (ok != 2) {
#line 5277
      if (ok != 4) {
        {
#line 5278
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: illegal dashes value %s:%s\n",
                option, v);
#line 5280
        dashes[n][0] = (char)0;
        }
#line 5281
        goto __Cont;
      }
    }
#line 5283
    j = 0;
    {
#line 5283
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5283
      if (! (j < l)) {
#line 5283
        goto while_break___1;
      }
#line 5284
      dashes[n][j] = (char )((unsigned char )((int )*(v + j) - 48));
#line 5283
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5286
    dashes[n][l] = (char)0;
    __Cont: /* CIL Label */ 
#line 5262
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5288
  return;
}
}
#line 5295 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int gpXTextWidth(XFontStruct *cfont , char const   *str , int count ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 5298
  if (usemultibyte) {
    {
#line 5299
    tmp = XmbTextEscapement(mbfont, str, count);
    }
#line 5299
    return (tmp);
  }
  {
#line 5301
  tmp___0 = XTextWidth(cfont, str, count);
  }
#line 5301
  return (tmp___0);
}
}
#line 5307 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XFontSetExtents *extents  ;
#line 5304 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int gpXTextHeight(XFontStruct *cfont ) 
{ 


  {
#line 5308
  if (usemultibyte) {
    {
#line 5309
    extents = XExtentsOfFontSet(mbfont);
    }
#line 5310
    return ((int )extents->max_logical_extent.height);
  } else {
#line 5313
    return (cfont->ascent + cfont->descent);
  }
}
}
#line 5316 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void gpXSetFont(Display *disp , GC gc___0 , Font fontid ) 
{ 


  {
#line 5319
  if (! usemultibyte) {
    {
#line 5321
    XSetFont(disp, gc___0, fontid);
    }
  }
#line 5322
  return;
}
}
#line 5324 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void gpXDrawImageString(Display *disp , Drawable d , GC gc___0 , int x , int y ,
                               char const   *str , int len ) 
{ 


  {
#line 5328
  if (usemultibyte) {
    {
#line 5329
    XmbDrawImageString(disp, d, mbfont, gc___0, x, y, str, len);
    }
#line 5330
    return;
  }
  {
#line 5333
  XDrawImageString(disp, d, gc___0, x, y, str, len);
  }
#line 5334
  return;
}
}
#line 5336 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void gpXDrawString(Display *disp , Drawable d , GC gc___0 , int x , int y ,
                          char const   *str , int len ) 
{ 


  {
#line 5340
  if (usemultibyte) {
    {
#line 5341
    XmbDrawString(disp, d, mbfont, gc___0, x, y, str, len);
    }
#line 5342
    return;
  }
  {
#line 5345
  XDrawString(disp, d, gc___0, x, y, str, len);
  }
#line 5346
  return;
}
}
#line 5348 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void gpXFreeFont(Display *disp , XFontStruct *cfont ) 
{ 


  {
#line 5354
  if (font) {
    {
#line 5355
    XFreeFont(disp, font);
#line 5356
    font = (XFontStruct *)((void *)0);
    }
  }
#line 5358
  if (mbfont) {
    {
#line 5359
    XFreeFontSet(disp, mbfont);
#line 5360
    mbfont = (XFontSet )((void *)0);
    }
  }
#line 5363
  return;
}
}
#line 5370 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char **miss  ;
#line 5370 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *def  ;
#line 5371 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static _Bool first_time  =    (_Bool)1;
#line 5365 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XFontStruct *gpXLoadQueryFont(Display *disp , char *fontname ) 
{ 
  int n_miss ;
  char tmpfname[256] ;
  XFontStruct *tmp ;
  int tmp___0 ;

  {
#line 5375
  if (! usemultibyte) {
    {
#line 5376
    tmp = XLoadQueryFont(disp, (char const   *)fontname);
    }
#line 5376
    return (tmp);
  } else {
    {
#line 5378
    fontset_transsep(tmpfname, fontname, 255);
#line 5379
    mbfont = XCreateFontSet(disp, (char const   *)(tmpfname), & miss, & n_miss, & def);
    }
#line 5386
    if (n_miss > 0) {
#line 5393
      if (first_time) {
        {
#line 5394
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot_x11: Some character sets not available\n");
#line 5395
        first_time = (_Bool)0;
        }
      }
      {
#line 5397
      while (1) {
        while_continue: /* CIL Label */ ;
#line 5397
        tmp___0 = n_miss;
#line 5397
        n_miss --;
#line 5397
        if (! (tmp___0 > 0)) {
#line 5397
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 5400
      XFreeStringList(miss);
      }
    }
#line 5403
    return ((XFontStruct *)((void *)0));
  }
}
}
#line 5408 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char *gpFallbackFont(void) 
{ 


  {
#line 5411
  if (usemultibyte) {
#line 5412
    return (FallbackFontMB);
  }
#line 5414
  return (FallbackFont);
}
}
#line 5422 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XFontStruct **eachfonts  ;
#line 5417 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int gpXGetFontascent(XFontStruct *cfont ) 
{ 
  char **fontnames ;
  int max_ascent ;
  int i ;
  int n_fonts ;

  {
#line 5424
  max_ascent = 0;
#line 5427
  if (! usemultibyte) {
#line 5427
    return (font->ascent);
  }
  {
#line 5428
  n_fonts = XFontsOfFontSet(mbfont, & eachfonts, & fontnames);
#line 5429
  i = 0;
  }
  {
#line 5429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5429
    if (! (i < n_fonts)) {
#line 5429
      goto while_break;
    }
#line 5430
    if ((*(eachfonts + i))->ascent > max_ascent) {
#line 5431
      max_ascent = (*(eachfonts + i))->ascent;
    }
#line 5429
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5433
  return (max_ascent);
}
}
#line 5438 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int fontset_transsep(char *nfname , char *ofname , int n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 5442
  strncpy((char */* __restrict  */)nfname, (char const   */* __restrict  */)ofname,
          (size_t )n);
  }
#line 5443
  if ((int )*(nfname + (n - 1)) != 0) {
#line 5444
    *(nfname + n) = (char )'\000';
  }
  {
#line 5445
  tmp = strchr((char const   *)nfname, ',');
  }
#line 5445
  if (tmp) {
#line 5446
    return (1);
  }
#line 5447
  s = nfname;
  {
#line 5448
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5448
    s = strchr((char const   *)nfname, ';');
    }
#line 5448
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 5448
      goto while_break;
    }
#line 5449
    *s = (char )',';
#line 5450
    nfname = s;
  }
  while_break: /* CIL Label */ ;
  }
#line 5452
  return (0);
}
}
#line 5456 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_encoding(void) 
{ 
  char *encoding___0 ;

  {
  {
#line 5460
  encoding___0 = pr_GetR(db, (char *)".encoding");
  }
#line 5460
  if (encoding___0) {
    {
#line 5461
    strncpy((char */* __restrict  */)(default_encoding), (char const   */* __restrict  */)encoding___0,
            sizeof(default_encoding) - 1UL);
    }
  }
#line 5463
  return;
}
}
#line 5469 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char previous_font_name[128]  ;
#line 5465 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_font(char *fontname ) 
{ 
  char fontspec[128] ;
  int fontsize ;
  char *orgfontname ;
  int tmp ;
  char shortname[64] ;
  char *fontencoding ;
  char slant ;
  char *weight ;
  int sep ;
  int backfont ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  size_t tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;

  {
#line 5471
  fontsize = 0;
#line 5473
  orgfontname = (char *)((void *)0);
#line 5476
  if (! fontname) {
#line 5477
    fontname = default_font;
#line 5478
    previous_font_name[0] = (char )'\000';
  } else
#line 5476
  if (! *fontname) {
#line 5477
    fontname = default_font;
#line 5478
    previous_font_name[0] = (char )'\000';
  }
#line 5481
  if (! fontname) {
#line 5481
    goto _L;
  } else
#line 5481
  if (! *fontname) {
    _L: /* CIL Label */ 
    {
#line 5482
    fontname = pr_GetR(db, (char *)".font");
    }
#line 5482
    if (fontname) {
      {
#line 5483
      strncpy((char */* __restrict  */)(default_font), (char const   */* __restrict  */)fontname,
              sizeof(default_font) - 1UL);
      }
    }
  }
#line 5489
  if (fontname) {
    {
#line 5489
    tmp = strncmp((char const   *)fontname, "mbfont:", (size_t )7);
    }
#line 5489
    if (tmp == 0) {
#line 5490
      if (multibyte_fonts_usable) {
#line 5491
        usemultibyte = 1;
#line 5492
        orgfontname = fontname;
#line 5493
        fontname += 7;
      } else {
#line 5495
        usemultibyte = 0;
#line 5496
        fontname = (char *)((void *)0);
      }
    } else {
#line 5498
      usemultibyte = 0;
    }
  } else {
#line 5498
    usemultibyte = 0;
  }
#line 5500
  if (! fontname) {
    {
#line 5501
    fontname = gpFallbackFont();
    }
  }
  {
#line 5506
  gpXFreeFont(dpy, font);
#line 5508
  font = gpXLoadQueryFont(dpy, fontname);
  }
#line 5513
  if (! font) {
#line 5513
    if (! mbfont) {
      {
#line 5513
      tmp___47 = strchr((char const   *)fontname, ';');
      }
#line 5513
      if (! tmp___47) {
        {
#line 5520
        backfont = 0;
#line 5526
        tmp___0 = strncmp((char const   *)fontname, "DEFAULT", (size_t )7);
        }
#line 5526
        if (tmp___0) {
#line 5533
          if ((int )*fontname == 44) {
            {
#line 5534
            sscanf((char const   */* __restrict  */)(fontname + 1), (char const   */* __restrict  */)"%d",
                   & fontsize);
#line 5535
            fontname = previous_font_name;
#line 5537
            backfont = 1;
            }
          }
        } else {
          {
#line 5527
          sscanf((char const   */* __restrict  */)(fontname + 8), (char const   */* __restrict  */)"%d",
                 & fontsize);
#line 5528
          fontname = default_font;
#line 5529
          previous_font_name[0] = (char )'\000';
#line 5531
          backfont = 1;
          }
        }
#line 5541
        if (backfont) {
#line 5541
          if (fontname) {
            {
#line 5541
            tmp___1 = strncmp((char const   *)fontname, "mbfont:", (size_t )7);
            }
#line 5541
            if (tmp___1 == 0) {
#line 5541
              if (multibyte_fonts_usable) {
#line 5543
                usemultibyte = 1;
#line 5544
                orgfontname = fontname;
#line 5545
                fontname += 7;
              }
            }
          }
        }
        {
#line 5549
        tmp___2 = strcspn((char const   *)fontname, ",");
#line 5549
        sep = (int )tmp___2;
        }
#line 5550
        if ((unsigned long )sep >= sizeof(shortname)) {
#line 5551
          sep = (int )(sizeof(shortname) - 1UL);
        }
        {
#line 5552
        strncpy((char */* __restrict  */)(shortname), (char const   */* __restrict  */)fontname,
                (size_t )sep);
#line 5553
        shortname[sep] = (char )'\000';
        }
#line 5554
        if (! fontsize) {
          {
#line 5555
          sscanf((char const   */* __restrict  */)(fontname + (sep + 1)), (char const   */* __restrict  */)"%d",
                 & fontsize);
          }
        }
#line 5556
        if (fontsize > 99) {
#line 5557
          fontsize = 12;
        } else
#line 5556
        if (fontsize < 1) {
#line 5557
          fontsize = 12;
        }
        {
#line 5559
        tmp___7 = strstr((char const   *)(fontname + (sep + 1)), "italic");
        }
#line 5559
        if (tmp___7) {
#line 5559
          slant = (char )'i';
        } else {
          {
#line 5559
          tmp___6 = strstr((char const   *)(fontname + (sep + 1)), "oblique");
          }
#line 5559
          if (tmp___6) {
#line 5559
            tmp___5 = 'o';
          } else {
#line 5559
            tmp___5 = 'r';
          }
#line 5559
          slant = (char )tmp___5;
        }
        {
#line 5563
        tmp___12 = strstr((char const   *)(fontname + (sep + 1)), "bold");
        }
#line 5563
        if (tmp___12) {
#line 5563
          weight = (char *)"bold";
        } else {
          {
#line 5563
          tmp___11 = strstr((char const   *)(fontname + (sep + 1)), "medium");
          }
#line 5563
          if (tmp___11) {
#line 5563
            tmp___10 = "medium";
          } else {
#line 5563
            tmp___10 = "*";
          }
#line 5563
          weight = (char *)tmp___10;
        }
        {
#line 5567
        tmp___21 = strncmp("Symbol", (char const   *)(shortname), (size_t )6);
        }
#line 5567
        if (tmp___21) {
          {
#line 5567
          tmp___22 = strncmp("symbol", (char const   *)(shortname), (size_t )6);
          }
#line 5567
          if (tmp___22) {
#line 5570
            if (usemultibyte) {
#line 5571
              fontencoding = (char *)"*-*";
            } else
#line 5574
            if ((unsigned int )encoding == 5U) {
#line 5574
              fontencoding = (char *)"dosencoding-cp437";
            } else {
#line 5574
              if ((unsigned int )encoding == 6U) {
#line 5574
                tmp___20 = "dosencoding-cp850";
              } else {
#line 5574
                if ((unsigned int )encoding == 1U) {
#line 5574
                  tmp___19 = "iso8859-1";
                } else {
#line 5574
                  if ((unsigned int )encoding == 2U) {
#line 5574
                    tmp___18 = "iso8859-2";
                  } else {
#line 5574
                    if ((unsigned int )encoding == 4U) {
#line 5574
                      tmp___17 = "iso8859-15";
                    } else {
#line 5574
                      if ((unsigned int )encoding == 12U) {
#line 5574
                        tmp___16 = "koi8-r";
                      } else {
#line 5574
                        if ((unsigned int )encoding == 13U) {
#line 5574
                          tmp___15 = "koi8-u";
                        } else {
#line 5574
                          if ((unsigned int )encoding == 15U) {
#line 5574
                            tmp___14 = "iso10646-1";
                          } else {
#line 5574
                            if (default_encoding[0]) {
#line 5574
                              tmp___13 = (char const   *)(default_encoding);
                            } else {
#line 5574
                              tmp___13 = "iso8859-1";
                            }
#line 5574
                            tmp___14 = tmp___13;
                          }
#line 5574
                          tmp___15 = tmp___14;
                        }
#line 5574
                        tmp___16 = tmp___15;
                      }
#line 5574
                      tmp___17 = tmp___16;
                    }
#line 5574
                    tmp___18 = tmp___17;
                  }
#line 5574
                  tmp___19 = tmp___18;
                }
#line 5574
                tmp___20 = tmp___19;
              }
#line 5574
              fontencoding = (char *)tmp___20;
            }
          } else {
#line 5568
            fontencoding = (char *)"*-*";
          }
        } else {
#line 5568
          fontencoding = (char *)"*-*";
        }
        {
#line 5590
        sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-%s-%s-%c-*-*-%d-*-*-*-*-*-%s",
                shortname, weight, (int )slant, fontsize, fontencoding);
#line 5593
        font = gpXLoadQueryFont(dpy, fontspec);
        }
#line 5598
        if (! font) {
#line 5598
          if (! mbfont) {
            {
#line 5601
            tmp___45 = strcmp("Times-Bold", (char const   *)(shortname));
            }
#line 5601
            if (tmp___45) {
              {
#line 5601
              tmp___46 = strcmp("times-bold", (char const   *)(shortname));
              }
#line 5601
              if (tmp___46) {
                {
#line 5605
                tmp___43 = strcmp("Times-Roman", (char const   *)(shortname));
                }
#line 5605
                if (tmp___43) {
                  {
#line 5605
                  tmp___44 = strcmp("times-roman", (char const   *)(shortname));
                  }
#line 5605
                  if (tmp___44) {
                    {
#line 5609
                    tmp___41 = strcmp("Times-Italic", (char const   *)(shortname));
                    }
#line 5609
                    if (tmp___41) {
                      {
#line 5609
                      tmp___42 = strcmp("times-italic", (char const   *)(shortname));
                      }
#line 5609
                      if (tmp___42) {
                        {
#line 5613
                        tmp___39 = strcmp("Times-BoldItalic", (char const   *)(shortname));
                        }
#line 5613
                        if (tmp___39) {
                          {
#line 5613
                          tmp___40 = strcmp("times-bolditalic", (char const   *)(shortname));
                          }
#line 5613
                          if (tmp___40) {
                            {
#line 5617
                            tmp___37 = strcmp("Helvetica-Bold", (char const   *)(shortname));
                            }
#line 5617
                            if (tmp___37) {
                              {
#line 5617
                              tmp___38 = strcmp("helvetica-bold", (char const   *)(shortname));
                              }
#line 5617
                              if (tmp___38) {
                                {
#line 5621
                                tmp___35 = strcmp("Helvetica-Oblique", (char const   *)(shortname));
                                }
#line 5621
                                if (tmp___35) {
                                  {
#line 5621
                                  tmp___36 = strcmp("helvetica-oblique", (char const   *)(shortname));
                                  }
#line 5621
                                  if (tmp___36) {
                                    {
#line 5625
                                    tmp___33 = strcmp("Helvetica-BoldOblique", (char const   *)(shortname));
                                    }
#line 5625
                                    if (tmp___33) {
                                      {
#line 5625
                                      tmp___34 = strcmp("helvetica-boldoblique", (char const   *)(shortname));
                                      }
#line 5625
                                      if (tmp___34) {
                                        {
#line 5629
                                        tmp___31 = strcmp("Helvetica-Narrow-Bold",
                                                          (char const   *)(shortname));
                                        }
#line 5629
                                        if (tmp___31) {
                                          {
#line 5629
                                          tmp___32 = strcmp("helvetica-narrow-bold",
                                                            (char const   *)(shortname));
                                          }
#line 5629
                                          if (tmp___32) {
#line 5637
                                            if (multibyte_fonts_usable) {
                                              {
#line 5637
                                              tmp___27 = strlen("Ryumin-Light");
#line 5637
                                              tmp___28 = strncmp("Ryumin-Light", (char const   *)(shortname),
                                                                 tmp___27);
                                              }
#line 5637
                                              if (tmp___28) {
                                                {
#line 5637
                                                tmp___29 = strlen("ryumin-light");
#line 5637
                                                tmp___30 = strncmp("ryumin-light",
                                                                   (char const   *)(shortname),
                                                                   tmp___29);
                                                }
#line 5637
                                                if (tmp___30) {
#line 5637
                                                  goto _L___1;
                                                } else {
                                                  _L___2: /* CIL Label */ 
#line 5642
                                                  if (! usemultibyte) {
#line 5643
                                                    usemultibyte = 1;
#line 5644
                                                    orgfontname = fontname;
                                                  }
                                                  {
#line 5646
                                                  sprintf((char */* __restrict  */)(fontspec),
                                                          (char const   */* __restrict  */)"-*-mincho-medium-%c-*--%d-*",
                                                          (int )slant, fontsize);
                                                  }
                                                }
                                              } else {
#line 5637
                                                goto _L___2;
                                              }
                                            } else
                                            _L___1: /* CIL Label */ 
#line 5649
                                            if (multibyte_fonts_usable) {
                                              {
#line 5649
                                              tmp___23 = strlen("GothicBBB-Medium");
#line 5649
                                              tmp___24 = strncmp("GothicBBB-Medium",
                                                                 (char const   *)(shortname),
                                                                 tmp___23);
                                              }
#line 5649
                                              if (tmp___24) {
                                                {
#line 5649
                                                tmp___25 = strlen("gothicbbb-medium");
#line 5649
                                                tmp___26 = strncmp("gothicbbb-medium",
                                                                   (char const   *)(shortname),
                                                                   tmp___25);
                                                }
#line 5649
                                                if (! tmp___26) {
                                                  _L___0: /* CIL Label */ 
#line 5654
                                                  if (! usemultibyte) {
#line 5655
                                                    usemultibyte = 1;
#line 5656
                                                    orgfontname = fontname;
                                                  }
                                                  {
#line 5660
                                                  sprintf((char */* __restrict  */)(fontspec),
                                                          (char const   */* __restrict  */)"-*-gothic-bold-%c-*--%d-*",
                                                          (int )slant, fontsize);
                                                  }
                                                }
                                              } else {
#line 5649
                                                goto _L___0;
                                              }
                                            }
                                          } else {
                                            {
#line 5631
                                            sprintf((char */* __restrict  */)(fontspec),
                                                    (char const   */* __restrict  */)"-*-arial narrow-bold-r-*-*-%d-*-*-*-*-*-%s",
                                                    fontsize, fontencoding);
                                            }
                                          }
                                        } else {
                                          {
#line 5631
                                          sprintf((char */* __restrict  */)(fontspec),
                                                  (char const   */* __restrict  */)"-*-arial narrow-bold-r-*-*-%d-*-*-*-*-*-%s",
                                                  fontsize, fontencoding);
                                          }
                                        }
                                      } else {
                                        {
#line 5627
                                        sprintf((char */* __restrict  */)(fontspec),
                                                (char const   */* __restrict  */)"-*-helvetica-bold-o-*-*-%d-*-*-*-*-*-%s",
                                                fontsize, fontencoding);
                                        }
                                      }
                                    } else {
                                      {
#line 5627
                                      sprintf((char */* __restrict  */)(fontspec),
                                              (char const   */* __restrict  */)"-*-helvetica-bold-o-*-*-%d-*-*-*-*-*-%s",
                                              fontsize, fontencoding);
                                      }
                                    }
                                  } else {
                                    {
#line 5623
                                    sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-helvetica-medium-o-*-*-%d-*-*-*-*-*-%s",
                                            fontsize, fontencoding);
                                    }
                                  }
                                } else {
                                  {
#line 5623
                                  sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-helvetica-medium-o-*-*-%d-*-*-*-*-*-%s",
                                          fontsize, fontencoding);
                                  }
                                }
                              } else {
                                {
#line 5619
                                sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-helvetica-bold-r-*-*-%d-*-*-*-*-*-%s",
                                        fontsize, fontencoding);
                                }
                              }
                            } else {
                              {
#line 5619
                              sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-helvetica-bold-r-*-*-%d-*-*-*-*-*-%s",
                                      fontsize, fontencoding);
                              }
                            }
                          } else {
                            {
#line 5615
                            sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-bold-i-*-*-%d-*-*-*-*-*-%s",
                                    fontsize, fontencoding);
                            }
                          }
                        } else {
                          {
#line 5615
                          sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-bold-i-*-*-%d-*-*-*-*-*-%s",
                                  fontsize, fontencoding);
                          }
                        }
                      } else {
                        {
#line 5611
                        sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-medium-i-*-*-%d-*-*-*-*-*-%s",
                                fontsize, fontencoding);
                        }
                      }
                    } else {
                      {
#line 5611
                      sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-medium-i-*-*-%d-*-*-*-*-*-%s",
                              fontsize, fontencoding);
                      }
                    }
                  } else {
                    {
#line 5607
                    sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-medium-r-*-*-%d-*-*-*-*-*-%s",
                            fontsize, fontencoding);
                    }
                  }
                } else {
                  {
#line 5607
                  sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-medium-r-*-*-%d-*-*-*-*-*-%s",
                          fontsize, fontencoding);
                  }
                }
              } else {
                {
#line 5603
                sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-bold-r-*-*-%d-*-*-*-*-*-%s",
                        fontsize, fontencoding);
                }
              }
            } else {
              {
#line 5603
              sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-times-bold-r-*-*-%d-*-*-*-*-*-%s",
                      fontsize, fontencoding);
              }
            }
            {
#line 5663
            font = gpXLoadQueryFont(dpy, fontspec);
            }
#line 5666
            if (usemultibyte) {
#line 5666
              if (! mbfont) {
                {
#line 5670
                sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"*-%s-%c-*--%d-*",
                        weight, (int )slant, fontsize);
#line 5671
                font = gpXLoadQueryFont(dpy, fontspec);
                }
              }
            }
          }
        }
      }
    }
  }
#line 5681
  if (font) {
#line 5681
    goto _L___3;
  } else
#line 5681
  if (mbfont) {
    _L___3: /* CIL Label */ 
#line 5682
    if (usemultibyte) {
#line 5682
      if (orgfontname) {
#line 5683
        fontname = orgfontname;
      }
    }
    {
#line 5685
    strncpy((char */* __restrict  */)(previous_font_name), (char const   */* __restrict  */)fontname,
            sizeof(previous_font_name) - 1UL);
    }
  }
#line 5695
  if (! usemultibyte) {
#line 5695
    if (! font) {
      {
#line 5697
      sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-bitstream vera sans-bold-r-*-*-%d-*-*-*-*-*-*-*",
              fontsize);
#line 5698
      font = gpXLoadQueryFont(dpy, fontspec);
#line 5699
      fontname = fontspec;
      }
#line 5700
      if (! font) {
        {
#line 5701
        sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-arial-medium-r-*-*-%d-*-*-*-*-*-*-*",
                fontsize);
#line 5702
        font = gpXLoadQueryFont(dpy, fontspec);
        }
      }
#line 5704
      if (! font) {
        {
#line 5705
        sprintf((char */* __restrict  */)(fontspec), (char const   */* __restrict  */)"-*-helvetica-medium-r-*-*-%d-*-*-*-*-*-*",
                fontsize);
#line 5706
        font = gpXLoadQueryFont(dpy, fontspec);
        }
      }
#line 5708
      if (! font) {
        {
#line 5709
        tmp___48 = gpFallbackFont();
#line 5709
        font = gpXLoadQueryFont(dpy, tmp___48);
#line 5710
        fontname = gpFallbackFont();
        }
      }
#line 5712
      if (! font) {
        {
#line 5713
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot_x11: can\'t find usable font - X11 aborted.\n");
        }
        {
#line 5714
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 5714
          gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 5714
          close(1);
#line 5714
          close(0);
#line 5714
          exit(1);
          }
#line 5714
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 5719
  if (usemultibyte) {
#line 5719
    if (! mbfont) {
      {
#line 5720
      tmp___49 = gpFallbackFont();
#line 5720
      font = gpXLoadQueryFont(dpy, tmp___49);
      }
#line 5721
      if (! mbfont) {
        {
#line 5722
        usemultibyte = 0;
#line 5723
        tmp___50 = gpFallbackFont();
#line 5723
        font = gpXLoadQueryFont(dpy, tmp___50);
        }
#line 5724
        if (! font) {
          {
#line 5725
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot_x11: can\'t find usable font - X11 aborted.\n");
          }
          {
#line 5726
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 5726
            gp_exec_event((char)12, 0, 0, 0, 0, 0);
#line 5726
            close(1);
#line 5726
            close(0);
#line 5726
            exit(1);
            }
#line 5726
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 5729
      fontname = gpFallbackFont();
      }
    }
  }
  {
#line 5733
  vchar = gpXTextHeight(font);
#line 5734
  tmp___51 = gpXTextWidth(font, "0123456789", 10);
#line 5734
  hchar = tmp___51 / 10;
  }
#line 5739
  return;
}
}
#line 5745 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_geometry(char *instr ) 
{ 
  char *geometry ;
  char *tmp ;
  char *tmp___0 ;
  int x ;
  int y ;
  int flags ;
  unsigned int w ;
  unsigned int h ;

  {
#line 5748
  if ((unsigned long )instr != (unsigned long )((void *)0)) {
#line 5748
    tmp___0 = instr;
  } else {
    {
#line 5748
    tmp = pr_GetR(db, (char *)".geometry");
#line 5748
    tmp___0 = tmp;
    }
  }
#line 5748
  geometry = tmp___0;
#line 5752
  if (geometry) {
    {
#line 5753
    flags = XParseGeometry((char const   *)geometry, & x, & y, & w, & h);
    }
#line 5754
    if (flags & 4) {
#line 5755
      gW = w;
    }
#line 5756
    if (flags & 8) {
#line 5757
      gH = h;
    }
#line 5758
    if (flags & 12) {
#line 5759
      gFlags = (unsigned int )(((long )gFlags & ~ (1L << 3)) | (1L << 1));
    }
#line 5761
    if (flags & 1) {
#line 5762
      if (flags & 16) {
#line 5762
        gX = (int )(((unsigned int )(x + (((_XPrivDisplay )dpy)->screens + scr)->width) - gW) - BorderWidth * 2U);
      } else {
#line 5762
        gX = x;
      }
    }
#line 5764
    if (flags & 2) {
#line 5765
      if (flags & 32) {
#line 5765
        gY = (int )(((unsigned int )(y + (((_XPrivDisplay )dpy)->screens + scr)->height) - gH) - BorderWidth * 2U);
      } else {
#line 5765
        gY = y;
      }
    }
#line 5767
    if (flags & 3) {
#line 5768
      gFlags = (unsigned int )(((long )gFlags & ~ (1L << 2)) | 1L);
    }
  }
#line 5770
  return;
}
}
#line 5776 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_pointsize(void) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 5779
  tmp___0 = pr_GetR(db, (char *)".pointsize");
  }
#line 5779
  if (tmp___0) {
    {
#line 5780
    tmp = sscanf((char const   */* __restrict  */)value.addr, (char const   */* __restrict  */)"%lf",
                 & pointsize);
    }
#line 5780
    if (tmp == 1) {
#line 5781
      if (pointsize <= (double )0) {
        {
#line 5782
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: invalid pointsize \'%s\'\n",
                value.addr);
#line 5783
        pointsize = (double )1;
        }
      } else
#line 5781
      if (pointsize > (double )10) {
        {
#line 5782
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: invalid pointsize \'%s\'\n",
                value.addr);
#line 5783
        pointsize = (double )1;
        }
      }
    } else {
      {
#line 5786
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ngnuplot: invalid pointsize \'%s\'\n",
              value.addr);
#line 5787
      pointsize = (double )1;
      }
    }
  } else {
#line 5790
    pointsize = (double )1;
  }
#line 5792
  return;
}
}
#line 5798 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static char const   width_keys[10][30]  = 
#line 5798
  { {        (char const   )'b',        (char const   )'o',        (char const   )'r',        (char const   )'d', 
            (char const   )'e',        (char const   )'r',        (char const   )'\000'}, 
   {        (char const   )'a',        (char const   )'x',        (char const   )'i',        (char const   )'s', 
            (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'1',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'2',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'3',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'4',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'5',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'6',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'7',        (char const   )'\000'}, 
   {        (char const   )'l',        (char const   )'i',        (char const   )'n',        (char const   )'e', 
            (char const   )'8',        (char const   )'\000'}};
#line 5803 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_width(void) 
{ 
  int n ;
  char option[20] ;
  char *v ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 5809
  n = 0;
  {
#line 5809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5809
    if (! (n < 10)) {
#line 5809
      goto while_break;
    }
    {
#line 5810
    strcpy((char */* __restrict  */)(option), (char const   */* __restrict  */)".");
#line 5811
    strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)(width_keys[n]));
#line 5812
    strcat((char */* __restrict  */)(option), (char const   */* __restrict  */)"Width");
#line 5813
    v = pr_GetR(db, option);
    }
#line 5813
    if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 5814
      if ((int )*v < 48) {
        {
#line 5815
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: illegal width value %s:%s\n",
                option, v);
        }
      } else
#line 5814
      if ((int )*v > 57) {
        {
#line 5815
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: illegal width value %s:%s\n",
                option, v);
        }
      } else {
        {
#line 5814
        tmp___0 = strlen((char const   *)v);
        }
#line 5814
        if (tmp___0 > 1UL) {
          {
#line 5815
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gnuplot: illegal width value %s:%s\n",
                  option, v);
          }
        } else {
          {
#line 5817
          tmp = atoi((char const   *)v);
#line 5817
          widths[n] = (unsigned int )tmp;
          }
        }
      }
    }
#line 5809
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5820
  return;
}
}
#line 5830 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XSizeHints hints  ;
#line 5831 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static XClassHint class_hint  ;
#line 5826 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_window(plot_struct *plot ) 
{ 
  char *title___0 ;
  char *tmp ;
  int Tvtwm ;
  long event_mask ;
  XWindowAttributes gattr ;
  XSetWindowAttributes attr ;
  unsigned long mask ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  XWMHints wmh ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char numstr[(sizeof("gplt") + 16UL) + 1UL] ;
  int orig_len ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;

  {
  {
#line 5829
  tmp = pr_GetR(db, (char *)".title");
#line 5829
  title___0 = tmp;
#line 5832
  Tvtwm = 0;
#line 5833
  event_mask = (((((((1L | (1L << 1)) | (1L << 17)) | (1L << 6)) | (1L << 7)) | (1L << 2)) | (1L << 3)) | (1L << 15)) | (1L << 4);
  }
#line 5840
  if (plot->external_container != 0UL) {
    {
#line 5842
    XGetWindowAttributes(dpy, plot->external_container, & gattr);
#line 5843
    plot->x = 0;
#line 5844
    plot->y = 0;
#line 5845
    plot->width = (unsigned int )gattr.width;
#line 5846
    plot->height = (unsigned int )gattr.height;
#line 5847
    plot->gheight = (unsigned int )gattr.height;
    }
#line 5848
    if (! plot->window) {
      {
#line 5849
      plot->window = XCreateWindow(dpy, plot->external_container, plot->x, plot->y,
                                   plot->width, plot->height, 0U, (int )dep, 1U, vis,
                                   0UL, (XSetWindowAttributes *)((void *)0));
#line 5851
      gp_execute_GE_plotdone((int )plot->window);
      }
    }
  }
#line 5856
  if (have_pm3d) {
#line 5858
    mask = (unsigned long )(((1L << 1) | (1L << 3)) | (1L << 13));
#line 5859
    attr.background_pixel = (plot->cmap)->colors[0];
#line 5860
    attr.border_pixel = (plot->cmap)->colors[1];
#line 5861
    attr.colormap = (plot->cmap)->colormap;
#line 5862
    if (! plot->window) {
      {
#line 5863
      plot->window = XCreateWindow(dpy, root, plot->x, plot->y, plot->width, plot->height,
                                   BorderWidth, (int )dep, 1U, vis, mask, & attr);
#line 5865
      gp_execute_GE_plotdone((int )plot->window);
      }
    } else {
      {
#line 5868
      XChangeWindowAttributes(dpy, plot->window, mask, & attr);
      }
    }
  } else
#line 5871
  if (! plot->window) {
    {
#line 5874
    plot->window = XCreateSimpleWindow(dpy, root, plot->x, plot->y, plot->width, plot->height,
                                       BorderWidth, (plot->cmap)->colors[1], (plot->cmap)->colors[0]);
#line 5876
    gp_execute_GE_plotdone((int )plot->window);
    }
  }
#line 5880
  if (plot->window == 0UL) {
#line 5881
    return;
  }
  {
#line 5887
  XChangeProperty(dpy, plot->window, WM_PROTOCOLS, (Atom )4, 32, 0, (unsigned char const   *)((unsigned char *)(& WM_DELETE_WINDOW)),
                  1);
#line 5889
  tmp___0 = pr_GetR(db, (char *)".clear");
  }
#line 5889
  if (tmp___0) {
    {
#line 5889
    tmp___1 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5889
    if (tmp___1) {
      {
#line 5889
      tmp___2 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5889
      if (! tmp___2) {
#line 5890
        Clear ++;
      }
    } else {
#line 5890
      Clear ++;
    }
  }
  {
#line 5891
  tmp___3 = pr_GetR(db, (char *)".tvtwm");
  }
#line 5891
  if (tmp___3) {
    {
#line 5891
    tmp___4 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5891
    if (tmp___4) {
      {
#line 5891
      tmp___5 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5891
      if (! tmp___5) {
#line 5892
        Tvtwm ++;
      }
    } else {
#line 5892
      Tvtwm ++;
    }
  }
#line 5894
  if (! Tvtwm) {
#line 5895
    hints.flags = (long )plot->posn_flags;
  } else {
#line 5897
    hints.flags = ((long )plot->posn_flags & -2L) | (1L << 2);
  }
  {
#line 5899
  hints.x = gX;
#line 5900
  hints.y = gY;
#line 5901
  hints.width = (int )plot->width;
#line 5902
  hints.height = (int )plot->height;
#line 5904
  XSetNormalHints(dpy, plot->window, & hints);
#line 5907
  class_hint.res_name = (char *)"gnuplot";
#line 5908
  class_hint.res_class = (char *)"Gnuplot";
#line 5909
  XSetClassHint(dpy, plot->window, & class_hint);
#line 5911
  tmp___6 = pr_GetR(db, (char *)".iconic");
  }
#line 5911
  if (tmp___6) {
    {
#line 5911
    tmp___7 = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5911
    if (tmp___7) {
      {
#line 5911
      tmp___8 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5911
      if (! tmp___8) {
        {
#line 5914
        wmh.flags = 1L << 1;
#line 5915
        wmh.initial_state = 3;
#line 5916
        XSetWMHints(dpy, plot->window, & wmh);
        }
      }
    } else {
      {
#line 5914
      wmh.flags = 1L << 1;
#line 5915
      wmh.initial_state = 3;
#line 5916
      XSetWMHints(dpy, plot->window, & wmh);
      }
    }
  }
  {
#line 5926
  XSelectInput(dpy, plot->window, event_mask);
  }
#line 5931
  if (plot->external_container != 0UL) {
    {
#line 5932
    XSelectInput(dpy, plot->external_container, event_mask & ~ ((1L << 2) | (1L << 3)));
    }
  }
  {
#line 5934
  XSync(dpy, 0);
  }
#line 5943
  if (plot->plot_number > 0) {
    {
#line 5944
    sprintf((char */* __restrict  */)(numstr), (char const   */* __restrict  */)"%s%d%c",
            "gplt", plot->plot_number, '\000');
    }
  } else {
    {
#line 5946
    sprintf((char */* __restrict  */)(numstr), (char const   */* __restrict  */)"%s%c",
            "gplt", '\000');
    }
  }
  {
#line 5948
  XSetIconName(dpy, plot->window, (char const   *)(numstr));
  }
#line 5950
  if (! plot->titlestring) {
#line 5952
    if (! title___0) {
#line 5952
      title___0 = X_Class;
    }
    {
#line 5953
    tmp___9 = strlen((char const   *)title___0);
#line 5953
    orig_len = (int )tmp___9;
    }
#line 5955
    if (orig_len) {
#line 5955
      if (plot->plot_number > 0) {
#line 5955
        tmp___13 = 1;
      } else {
#line 5955
        tmp___13 = 0;
      }
    } else {
#line 5955
      tmp___13 = 0;
    }
    {
#line 5955
    tmp___14 = strlen((char const   *)(numstr));
#line 5955
    tmp___15 = strlen("gplt");
#line 5955
    tmp___16 = malloc((((size_t )(orig_len + tmp___13) + tmp___14) - tmp___15) + 1UL);
#line 5955
    tmp___12 = (char *)tmp___16;
#line 5955
    plot->titlestring = tmp___12;
    }
#line 5955
    if (tmp___12) {
      {
#line 5956
      strcpy((char */* __restrict  */)plot->titlestring, (char const   */* __restrict  */)title___0);
      }
#line 5957
      if (orig_len) {
#line 5957
        if (plot->plot_number > 0) {
#line 5958
          tmp___10 = orig_len;
#line 5958
          orig_len ++;
#line 5958
          *(plot->titlestring + tmp___10) = (char )' ';
        }
      }
      {
#line 5959
      tmp___11 = strlen("gplt");
#line 5959
      strcpy((char */* __restrict  */)(plot->titlestring + orig_len), (char const   */* __restrict  */)(numstr + tmp___11));
#line 5960
      XStoreName(dpy, plot->window, (char const   *)plot->titlestring);
      }
    } else {
      {
#line 5962
      XStoreName(dpy, plot->window, (char const   *)title___0);
      }
    }
  } else {
    {
#line 5964
    XStoreName(dpy, plot->window, (char const   *)plot->titlestring);
    }
  }
  {
#line 5970
  XMapWindow(dpy, plot->window);
  }
#line 5972
  if (plot->external_container != 0UL) {
    {
#line 5973
    XMapWindow(dpy, plot->external_container);
    }
  }
#line 5976
  windows_open ++;
#line 5977
  return;
}
}
#line 5981 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_raise(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 5984
  tmp___2 = pr_GetR(db, (char *)".raise");
  }
#line 5984
  if (tmp___2) {
    {
#line 5985
    tmp = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5985
    if (tmp) {
      {
#line 5985
      tmp___0 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5985
      if (tmp___0) {
#line 5985
        tmp___1 = 0;
      } else {
#line 5985
        tmp___1 = 1;
      }
    } else {
#line 5985
      tmp___1 = 1;
    }
#line 5985
    do_raise = tmp___1;
  }
#line 5986
  return;
}
}
#line 5989 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_persist(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 5992
  tmp___2 = pr_GetR(db, (char *)".persist");
  }
#line 5992
  if (tmp___2) {
    {
#line 5993
    tmp = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 5993
    if (tmp) {
      {
#line 5993
      tmp___0 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 5993
      if (tmp___0) {
#line 5993
        tmp___1 = 0;
      } else {
#line 5993
        tmp___1 = 1;
      }
    } else {
#line 5993
      tmp___1 = 1;
    }
#line 5993
    persist = tmp___1;
  }
#line 5994
  return;
}
}
#line 5996 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_feedback(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 5999
  tmp___2 = pr_GetR(db, (char *)".feedback");
  }
#line 5999
  if (tmp___2) {
    {
#line 6000
    tmp = strncasecmp((char const   *)value.addr, "off", (size_t )3);
    }
#line 6000
    if (tmp) {
      {
#line 6000
      tmp___0 = strncasecmp((char const   *)value.addr, "false", (size_t )5);
      }
#line 6000
      if (tmp___0) {
#line 6000
        tmp___1 = 1;
      } else {
#line 6000
        tmp___1 = 0;
      }
    } else {
#line 6000
      tmp___1 = 0;
    }
#line 6000
    feedback = tmp___1;
  }
#line 6002
  return;
}
}
#line 6004 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_ctrlq(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 6007
  tmp___2 = pr_GetR(db, (char *)".ctrlq");
  }
#line 6007
  if (tmp___2) {
    {
#line 6008
    tmp = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 6008
    if (tmp) {
      {
#line 6008
      tmp___0 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 6008
      if (tmp___0) {
#line 6008
        tmp___1 = 0;
      } else {
#line 6008
        tmp___1 = 1;
      }
    } else {
#line 6008
      tmp___1 = 1;
    }
#line 6008
    ctrlq = tmp___1;
  }
#line 6011
  return;
}
}
#line 6013 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_fastrotate(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 6016
  tmp___2 = pr_GetR(db, (char *)".fastrotate");
  }
#line 6016
  if (tmp___2) {
    {
#line 6017
    tmp = strncasecmp((char const   *)value.addr, "on", (size_t )2);
    }
#line 6017
    if (tmp) {
      {
#line 6017
      tmp___0 = strncasecmp((char const   *)value.addr, "true", (size_t )4);
      }
#line 6017
      if (tmp___0) {
#line 6017
        tmp___1 = 0;
      } else {
#line 6017
        tmp___1 = 1;
      }
    } else {
#line 6017
      tmp___1 = 1;
    }
#line 6017
    fast_rotate = (_Bool )tmp___1;
  }
#line 6020
  return;
}
}
#line 6023 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void pr_exportselection(void) 
{ 
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 6027
  tmp___1 = pr_GetR(db, (char *)".exportselection");
  }
#line 6027
  if (tmp___1) {
    {
#line 6028
    tmp = strncmp((char const   *)value.addr, "off", (size_t )3);
    }
#line 6028
    if (tmp) {
      {
#line 6028
      tmp___0 = strncmp((char const   *)value.addr, "false", (size_t )5);
      }
#line 6028
      if (! tmp___0) {
#line 6029
        exportselection = (_Bool)0;
      }
    } else {
#line 6029
      exportselection = (_Bool)0;
    }
  }
#line 6033
  return;
}
}
#line 6041 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static struct plot_struct *exported_plot  ;
#line 6042 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Time export_time  ;
#line 6044 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void export_graph(struct plot_struct *plot ) 
{ 


  {
  {
#line 6049
  XSetSelectionOwner(dpy, (Atom )1, plot->window, (Time )0L);
  }
#line 6053
  if (! selection[0]) {
#line 6054
    exported_plot = plot;
#line 6055
    if (! plot) {
#line 6055
      export_time = (Time )1;
    } else
#line 6055
    if (! plot->time) {
#line 6055
      export_time = (Time )1;
    } else {
#line 6055
      export_time = plot->time;
    }
  }
#line 6057
  return;
}
}
#line 6067 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom XA_TARGETS  =    (Atom )0;
#line 6068 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom XA_TIMESTAMP  =    (Atom )0;
#line 6085 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom targets[2]  = {      (Atom )20,      (Atom )7};
#line 6086 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static Atom mousecoord[1]  = {      (Atom )31};
#line 6059 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void handle_selection_event(XEvent *event ) 
{ 
  XEvent reply ;
  size_t tmp ;

  {
  {
#line 6063
  if (event->type == 30) {
#line 6063
    goto case_30;
  }
#line 6062
  goto switch_break;
  case_30: /* CIL Label */ 
#line 6070
  if (XA_TARGETS == 0UL) {
    {
#line 6071
    XA_TARGETS = XInternAtom(dpy, "TARGETS", 0);
    }
  }
#line 6072
  if (XA_TIMESTAMP == 0UL) {
    {
#line 6073
    XA_TIMESTAMP = XInternAtom(dpy, "TIMESTAMP", 0);
    }
  }
#line 6075
  reply.type = 31;
#line 6076
  reply.xselection.send_event = 1;
#line 6077
  reply.xselection.display = event->xselectionrequest.display;
#line 6078
  reply.xselection.requestor = event->xselectionrequest.requestor;
#line 6079
  reply.xselection.selection = event->xselectionrequest.selection;
#line 6080
  reply.xselection.target = event->xselectionrequest.target;
#line 6081
  reply.xselection.property = event->xselectionrequest.property;
#line 6082
  reply.xselection.time = event->xselectionrequest.time;
#line 6084
  if (reply.xselection.target == XA_TARGETS) {
#line 6090
    if (selection[0]) {
      {
#line 6091
      XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property,
                      reply.xselection.target, 32, 0, (unsigned char const   *)((unsigned char *)(mousecoord)),
                      1);
      }
    } else
#line 6094
    if (exported_plot) {
      {
#line 6095
      XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property,
                      reply.xselection.target, 32, 0, (unsigned char const   *)((unsigned char *)(targets)),
                      2);
      }
    }
  } else
#line 6098
  if (reply.xselection.target == 7UL) {
    {
#line 6102
    XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target,
                    32, 0, (unsigned char const   *)((unsigned char *)(& default_cmap.colormap)),
                    1);
    }
  } else
#line 6105
  if (reply.xselection.target == 20UL) {
#line 6105
    if (exported_plot) {
      {
#line 6109
      XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property,
                      reply.xselection.target, 32, 0, (unsigned char const   *)((unsigned char *)(& exported_plot->pixmap)),
                      1);
#line 6112
      exported_plot = (struct plot_struct *)((void *)0);
      }
    } else {
#line 6105
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 6113
  if (reply.xselection.target == XA_TIMESTAMP) {
    {
#line 6118
    XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property, reply.xselection.target,
                    32, 0, (unsigned char const   *)((unsigned char *)(& export_time)),
                    1);
    }
  } else
#line 6122
  if (reply.xselection.target == 31UL) {
#line 6122
    if (selection[0]) {
      {
#line 6124
      tmp = strlen((char const   *)(selection));
#line 6124
      XChangeProperty(dpy, reply.xselection.requestor, reply.xselection.property,
                      reply.xselection.target, 8, 0, (unsigned char const   *)((unsigned char *)(selection)),
                      (int )tmp);
#line 6127
      selection[0] = (char )'\000';
      }
    } else {
#line 6122
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6131
    reply.xselection.property = (Atom )0L;
#line 6132
    if (! exported_plot) {
#line 6132
      if (! selection[0]) {
        {
#line 6134
        XSetSelectionOwner(dpy, (Atom )1, (Window )0L, (Time )0L);
        }
      }
    }
  }
  {
#line 6137
  XSendEvent(dpy, reply.xselection.requestor, 0, 0L, & reply);
#line 6142
  XFlush(dpy);
  }
#line 6144
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6146
  return;
}
}
#line 6152 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void mouse_to_coords(plot_struct *plot , XEvent *event , double *x , double *y ,
                            double *x2 , double *y2 ) 
{ 
  int xx ;
  int yy ;

  {
  {
#line 6156
  xx = (int )((4096. * ((double )event->xbutton.x + 0.5)) / (double )plot->width);
#line 6157
  yy = (int )(4095. - (4096. * ((double )event->xbutton.y + 0.5)) / (double )plot->gheight);
#line 6161
  *x = mouse_to_axis(xx, & plot->axis_scale[2]);
#line 6162
  *y = mouse_to_axis(yy, & plot->axis_scale[1]);
#line 6163
  *x2 = mouse_to_axis(xx, & plot->axis_scale[6]);
#line 6164
  *y2 = mouse_to_axis(yy, & plot->axis_scale[5]);
  }
#line 6167
  return;
}
}
#line 6169 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static double mouse_to_axis(int mouse_coord , axis_scale_t *axis ) 
{ 
  double axis_coord ;

  {
#line 6174
  if (axis->term_scale == 0.0) {
#line 6175
    return (0.);
  }
#line 6177
  axis_coord = (double )(mouse_coord - axis->term_lower) / axis->term_scale + axis->min;
#line 6178
  if (axis->logbase > 0.0) {
    {
#line 6179
    axis_coord = exp(axis_coord * axis->logbase);
    }
  }
#line 6181
  return (axis_coord);
}
}
#line 6190 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static plot_struct *Add_Plot_To_Linked_List(int plot_number ) 
{ 
  plot_struct *psp ;
  void *tmp ;

  {
#line 6194
  if (plot_number >= 0) {
    {
#line 6196
    psp = Find_Plot_In_Linked_List_By_Number(plot_number);
    }
  } else {
#line 6198
    psp = (plot_struct *)((void *)0);
  }
#line 6200
  if ((unsigned long )psp == (unsigned long )((void *)0)) {
    {
#line 6201
    tmp = malloc(sizeof(plot_struct ));
#line 6201
    psp = (plot_struct *)tmp;
    }
#line 6202
    if (psp) {
      {
#line 6204
      memset((void *)psp, 0, sizeof(plot_struct ));
#line 6205
      psp->plot_number = plot_number;
      }
#line 6208
      if (plot_number >= 0) {
#line 6209
        psp->external_container = (Window )0L;
      }
#line 6212
      psp->prev_plot = (struct plot_struct *)((void *)0);
#line 6213
      if ((unsigned long )plot_list_start != (unsigned long )((void *)0)) {
#line 6214
        plot_list_start->prev_plot = psp;
#line 6215
        psp->next_plot = plot_list_start;
      } else {
#line 6217
        psp->next_plot = (struct plot_struct *)((void *)0);
      }
#line 6218
      plot_list_start = psp;
    } else {
      {
#line 6221
      psp = (plot_struct *)((void *)0);
#line 6222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Could not allocate memory for plot.\n\n");
      }
    }
  }
#line 6226
  return (psp);
}
}
#line 6234 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void Remove_Plot_From_Linked_List(Window plot_window ) 
{ 
  plot_struct *psp ;
  plot_struct *tmp ;

  {
  {
#line 6238
  tmp = Find_Plot_In_Linked_List_By_Window(plot_window);
#line 6238
  psp = tmp;
  }
#line 6240
  if ((unsigned long )psp != (unsigned long )((void *)0)) {
#line 6242
    if ((unsigned long )psp->next_plot != (unsigned long )((void *)0)) {
#line 6243
      (psp->next_plot)->prev_plot = psp->prev_plot;
    }
#line 6244
    if ((unsigned long )psp->prev_plot != (unsigned long )((void *)0)) {
#line 6245
      (psp->prev_plot)->next_plot = psp->next_plot;
    } else {
#line 6247
      plot_list_start = psp->next_plot;
    }
#line 6250
    if ((unsigned long )current_plot == (unsigned long )psp) {
#line 6257
      current_plot = (struct plot_struct *)((void *)0);
    }
    {
#line 6261
    delete_plot(psp);
#line 6262
    free((void *)psp);
    }
  }
#line 6264
  return;
}
}
#line 6271 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static plot_struct *Find_Plot_In_Linked_List_By_Number(int plot_number ) 
{ 
  plot_struct *psp ;

  {
#line 6274
  psp = plot_list_start;
  {
#line 6276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6276
    if (! ((unsigned long )psp != (unsigned long )((void *)0))) {
#line 6276
      goto while_break;
    }
#line 6277
    if (psp->plot_number == plot_number) {
#line 6278
      goto while_break;
    }
#line 6279
    psp = psp->next_plot;
  }
  while_break: /* CIL Label */ ;
  }
#line 6282
  return (psp);
}
}
#line 6290 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static plot_struct *Find_Plot_In_Linked_List_By_Window(Window window ) 
{ 
  plot_struct *psp ;

  {
#line 6293
  psp = plot_list_start;
  {
#line 6295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6295
    if (! ((unsigned long )psp != (unsigned long )((void *)0))) {
#line 6295
      goto while_break;
    }
#line 6296
    if (psp->window == window) {
#line 6297
      goto while_break;
    }
#line 6298
    psp = psp->next_plot;
  }
  while_break: /* CIL Label */ ;
  }
#line 6302
  if ((unsigned long )psp != (unsigned long )((void *)0)) {
#line 6303
    return (psp);
  }
#line 6307
  psp = plot_list_start;
  {
#line 6309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6309
    if (! ((unsigned long )psp != (unsigned long )((void *)0))) {
#line 6309
      goto while_break___0;
    }
#line 6310
    if (psp->external_container != 0UL) {
#line 6310
      if (psp->external_container == window) {
#line 6311
        goto while_break___0;
      }
    }
#line 6312
    psp = psp->next_plot;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6316
  return (psp);
}
}
#line 6325 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static plot_struct *Find_Plot_In_Linked_List_By_CMap(cmap_t *cmp ) 
{ 
  plot_struct *psp ;
  cmap_struct *csp ;

  {
#line 6328
  psp = plot_list_start;
  {
#line 6330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6330
    if (! ((unsigned long )psp != (unsigned long )((void *)0))) {
#line 6330
      goto while_break;
    }
#line 6331
    csp = psp->first_cmap_struct;
    {
#line 6332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6332
      if (! ((unsigned long )csp != (unsigned long )((void *)0))) {
#line 6332
        goto while_break___0;
      }
#line 6333
      if ((unsigned long )csp->cmap == (unsigned long )cmp) {
#line 6334
        goto while_break___0;
      }
#line 6335
      csp = csp->next_cmap_struct;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 6337
    if ((unsigned long )csp != (unsigned long )((void *)0)) {
#line 6338
      goto while_break;
    }
#line 6339
    psp = psp->next_plot;
  }
  while_break: /* CIL Label */ ;
  }
#line 6342
  return (psp);
}
}
#line 6369 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void Add_Plot_To_Remove_FIFO_Queue(Window plot_window ) 
{ 
  plot_remove_struct *prsp ;
  plot_remove_struct *prsp_new ;
  void *tmp ;

  {
#line 6373
  prsp = remove_fifo_queue_start;
  {
#line 6375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6375
    if (! ((unsigned long )prsp != (unsigned long )((void *)0))) {
#line 6375
      goto while_break;
    }
#line 6376
    if (prsp->processed) {
      {
#line 6377
      remove_fifo_queue_start = prsp->next_remove;
#line 6378
      free((void *)prsp);
#line 6379
      prsp = remove_fifo_queue_start;
      }
    } else {
#line 6382
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6387
    if (! ((unsigned long )prsp != (unsigned long )((void *)0))) {
#line 6387
      goto while_break___0;
    }
#line 6388
    if (prsp->plot_window_to_remove == plot_window) {
#line 6393
      return;
    }
#line 6395
    if ((unsigned long )prsp->next_remove == (unsigned long )((void *)0)) {
#line 6396
      goto while_break___0;
    } else {
#line 6398
      prsp = prsp->next_remove;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6402
  tmp = malloc(sizeof(plot_remove_struct ));
#line 6402
  prsp_new = (plot_remove_struct *)tmp;
  }
#line 6403
  if (prsp_new) {
#line 6405
    prsp_new->next_remove = (struct plot_remove_struct *)((void *)0);
#line 6406
    prsp_new->plot_window_to_remove = plot_window;
#line 6407
    prsp_new->processed = 0;
#line 6408
    if (remove_fifo_queue_start) {
#line 6409
      prsp->next_remove = prsp_new;
    } else {
#line 6411
      remove_fifo_queue_start = prsp_new;
    }
#line 6412
    process_remove_fifo_queue = 1;
  } else {
    {
#line 6416
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Could not allocate memory for plot remove queue.\n\n");
    }
  }
#line 6418
  return;
}
}
#line 6425 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void Process_Remove_FIFO_Queue(void) 
{ 
  plot_remove_struct *prsp ;
  plot_remove_struct prs ;

  {
#line 6428
  prsp = remove_fifo_queue_start;
#line 6435
  process_remove_fifo_queue = 0;
  {
#line 6442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6442
    if (! ((unsigned long )prsp != (unsigned long )((void *)0))) {
#line 6442
      goto while_break;
    }
#line 6450
    prs.plot_window_to_remove = prsp->plot_window_to_remove;
#line 6451
    prs.next_remove = prsp->next_remove;
#line 6452
    prs.processed = prsp->processed;
#line 6464
    prsp->processed = 1;
#line 6468
    if (! prs.processed) {
      {
#line 6469
      Remove_Plot_From_Linked_List(prs.plot_window_to_remove);
      }
    }
#line 6471
    prsp = prs.next_remove;
  }
  while_break: /* CIL Label */ ;
  }
#line 6484
  return;
}
}
#line 6493 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static unsigned short BitMaskDetails(unsigned long mask , unsigned short *left_shift ,
                                     unsigned short *right_shift ) 
{ 
  unsigned short i ;
  unsigned long m ;

  {
#line 6497
  m = mask;
#line 6499
  if (mask == 0UL) {
#line 6500
    *left_shift = (unsigned short)0;
#line 6501
    *right_shift = (unsigned short)0;
#line 6502
    return ((unsigned short)0);
  }
#line 6505
  i = (unsigned short)0;
  {
#line 6505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6505
    if (! ((int )i < 32)) {
#line 6505
      goto while_break;
    }
#line 6506
    if (((m << 1) & 4294967295UL) >> 1 != m) {
#line 6507
      goto while_break;
    } else {
#line 6509
      m <<= 1;
    }
#line 6505
    i = (unsigned short )((int )i + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 6511
  *left_shift = i;
#line 6513
  m = mask;
#line 6514
  i = (unsigned short)0;
  {
#line 6514
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6514
    if (! ((int )i < 32)) {
#line 6514
      goto while_break___0;
    }
#line 6515
    if ((m >> 1) << 1 != m) {
#line 6516
      goto while_break___0;
    } else {
#line 6518
      m >>= 1;
    }
#line 6514
    i = (unsigned short )((int )i + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6520
  *right_shift = i;
#line 6522
  return ((unsigned short )m);
}
}
#line 6530 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static cmap_t *Add_CMap_To_Linked_List(void) 
{ 
  cmap_t *cmp ;
  void *tmp ;

  {
  {
#line 6533
  tmp = malloc(sizeof(cmap_t ));
#line 6533
  cmp = (cmap_t *)tmp;
  }
#line 6534
  if (cmp) {
#line 6536
    cmp->prev_cmap = (struct cmap_t *)((void *)0);
#line 6537
    if ((unsigned long )cmap_list_start != (unsigned long )((void *)0)) {
#line 6538
      cmap_list_start->prev_cmap = cmp;
#line 6539
      cmp->next_cmap = cmap_list_start;
    } else {
#line 6541
      cmp->next_cmap = (struct cmap_t *)((void *)0);
    }
#line 6542
    cmap_list_start = cmp;
  } else {
    {
#line 6544
    cmp = (cmap_t *)((void *)0);
#line 6545
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nGNUPLOT (gplt_x11):  Could not allocate memory for color map.\n\n");
    }
  }
  {
#line 6548
  CmapClear(cmp);
#line 6549
  cmp->colormap = XCreateColormap(dpy, root, vis, 0);
  }
#line 6550
  if (! cmp->colormap) {
    {
#line 6550
    __assert_fail("cmp->colormap", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c",
                  6550U, "Add_CMap_To_Linked_List");
    }
  }
  {
#line 6551
  pr_color(cmp);
  }
#line 6552
  return (cmp);
}
}
#line 6560 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void Remove_CMap_From_Linked_List(cmap_t *cmp ) 
{ 


  {
  {
#line 6564
  cmp = Find_CMap_In_Linked_List(cmp);
  }
#line 6566
  if ((unsigned long )cmp != (unsigned long )((void *)0)) {
#line 6568
    if ((unsigned long )cmp->next_cmap != (unsigned long )((void *)0)) {
#line 6569
      (cmp->next_cmap)->prev_cmap = cmp->prev_cmap;
    }
#line 6570
    if ((unsigned long )cmp->prev_cmap != (unsigned long )((void *)0)) {
#line 6571
      (cmp->prev_cmap)->next_cmap = cmp->next_cmap;
    } else {
#line 6573
      cmap_list_start = cmp->next_cmap;
    }
#line 6576
    if ((unsigned long )current_cmap == (unsigned long )cmp) {
#line 6583
      current_cmap = & default_cmap;
    }
    {
#line 6587
    ReleaseColormap(cmp);
    }
  }
#line 6589
  return;
}
}
#line 6596 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static cmap_t *Find_CMap_In_Linked_List(cmap_t *colormap ) 
{ 
  cmap_t *cmp ;

  {
#line 6599
  cmp = cmap_list_start;
  {
#line 6601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6601
    if (! ((unsigned long )cmp != (unsigned long )((void *)0))) {
#line 6601
      goto while_break;
    }
#line 6602
    if ((unsigned long )cmp == (unsigned long )colormap) {
#line 6603
      goto while_break;
    }
#line 6604
    cmp = cmp->next_cmap;
  }
  while_break: /* CIL Label */ ;
  }
#line 6607
  return (cmp);
}
}
#line 6615 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static int cmaps_differ(cmap_t *cmap1 , cmap_t *cmap2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 6620
  tmp = memcmp((void const   *)(& cmap1->colors[0]), (void const   *)(& cmap2->colors[0]),
               (size_t )((long )(& cmap1->pixels) - (long )(& cmap1->colors[0])));
  }
#line 6620
  if (tmp) {
#line 6621
    return (1);
  }
#line 6624
  if (cmap1->allocated) {
#line 6625
    if (cmap1->pixels) {
#line 6625
      if (cmap2->pixels) {
        {
#line 6626
        tmp___0 = memcmp((void const   *)cmap1->pixels, (void const   *)cmap2->pixels,
                         (unsigned long )cmap1->allocated * sizeof(*(cmap1->pixels + 0)));
        }
#line 6626
        if (tmp___0) {
#line 6627
          return (1);
        }
      } else {
#line 6629
        return (1);
      }
    } else {
#line 6629
      return (1);
    }
  }
#line 6632
  return (0);
}
}
#line 6640 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gplt_x11.c"
static void x11_setfill(GC *gc___0 , int style ) 
{ 
  int fillpar ;
  XColor xcolor ;
  XColor bgnd ;
  float dim ;
  int idx ;
  int tmp ;

  {
#line 6643
  fillpar = style >> 4;
#line 6648
  style &= 15;
  {
#line 6652
  if (style == 4) {
#line 6652
    goto case_4;
  }
#line 6652
  if (style == 1) {
#line 6652
    goto case_4;
  }
#line 6673
  if (style == 5) {
#line 6673
    goto case_5;
  }
#line 6673
  if (style == 2) {
#line 6673
    goto case_5;
  }
#line 6686
  if (style == 0) {
#line 6686
    goto case_0;
  }
#line 6691
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 6654
  if (fillpar >= 100) {
#line 6655
    goto switch_break;
  }
  {
#line 6656
  dim = (float )((double )fillpar / 100.);
#line 6658
  xcolor.red = (unsigned short )(((double )65535 * (double )((current_plot->current_rgb >> 16) & 255UL)) / 255.);
#line 6659
  xcolor.green = (unsigned short )(((double )65535 * (double )((current_plot->current_rgb >> 8) & 255UL)) / 255.);
#line 6660
  xcolor.blue = (unsigned short )(((double )65535 * (double )(current_plot->current_rgb & 255UL)) / 255.);
#line 6661
  bgnd.red = (unsigned short )(((double )65535 * (double )(((current_plot->cmap)->rgbcolors[0] >> 16) & 255UL)) / 255.);
#line 6662
  bgnd.green = (unsigned short )(((double )65535 * (double )(((current_plot->cmap)->rgbcolors[0] >> 8) & 255UL)) / 255.);
#line 6663
  bgnd.blue = (unsigned short )(((double )65535 * (double )((current_plot->cmap)->rgbcolors[0] & 255UL)) / 255.);
#line 6664
  xcolor.red = (unsigned short )((double )(dim * (float )xcolor.red) + (1. - (double )dim) * (double )bgnd.red);
#line 6665
  xcolor.green = (unsigned short )((double )(dim * (float )xcolor.green) + (1. - (double )dim) * (double )bgnd.green);
#line 6666
  xcolor.blue = (unsigned short )((double )(dim * (float )xcolor.blue) + (1. - (double )dim) * (double )bgnd.blue);
#line 6669
  tmp = XAllocColor(dpy, (current_plot->cmap)->colormap, & xcolor);
  }
#line 6669
  if (tmp) {
    {
#line 6670
    XSetForeground(dpy, *gc___0, xcolor.pixel);
    }
  }
#line 6671
  goto switch_break;
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 6675
  idx = fillpar;
#line 6676
  if (idx < 0) {
#line 6677
    idx = 0;
  }
  {
#line 6678
  idx %= 8;
#line 6679
  XSetStipple(dpy, *gc___0, stipple_pattern[idx]);
  }
#line 6680
  if (style == 5) {
    {
#line 6681
    XSetFillStyle(dpy, *gc___0, 2);
    }
  } else {
    {
#line 6683
    XSetFillStyle(dpy, *gc___0, 3);
    }
  }
  {
#line 6684
  XSetBackground(dpy, *gc___0, (current_plot->cmap)->colors[0]);
  }
#line 6685
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 6688
  XSetFillStyle(dpy, *gc___0, 0);
#line 6689
  XSetForeground(dpy, *gc___0, (current_plot->cmap)->colors[0]);
  }
#line 6690
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 6693
  XSetFillStyle(dpy, *gc___0, 0);
  }
#line 6694
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 6696
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
int pipe_died  =    0;
#line 67
static gpe_fifo_t *gpe_init(void) ;
#line 68
static void gpe_push(gpe_fifo_t **base___0 , struct gp_event_t *ge ) ;
#line 69
static struct gp_event_t *gpe_front(gpe_fifo_t **base___0 ) ;
#line 70
static int gpe_pop(gpe_fifo_t **base___0 ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
int buffered_output_pending  =    0;
#line 147 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
static gpe_fifo_t *gpe_init(void) 
{ 
  gpe_fifo_t *base___0 ;
  void *tmp ;

  {
  {
#line 150
  tmp = malloc(sizeof(gpe_fifo_t ));
#line 150
  base___0 = (gpe_fifo_t *)tmp;
  }
#line 152
  if (! base___0) {
    {
#line 152
    __assert_fail("base", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c",
                  152U, "gpe_init");
    }
  }
#line 153
  base___0->next = (gpe_fifo_t *)0;
#line 154
  base___0->prev = (gpe_fifo_t *)0;
#line 155
  return (base___0);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
static void gpe_push(gpe_fifo_t **base___0 , struct gp_event_t *ge ) 
{ 
  gpe_fifo_t *new ;
  void *tmp ;

  {
#line 161
  buffered_output_pending ++;
#line 162
  if ((*base___0)->prev) {
    {
#line 163
    tmp = malloc(sizeof(gpe_fifo_t ));
#line 163
    new = (gpe_fifo_t *)tmp;
    }
#line 165
    if (! new) {
      {
#line 165
      __assert_fail("new", "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c",
                    165U, "gpe_push");
      }
    }
#line 166
    ((*base___0)->prev)->next = new;
#line 167
    new->prev = (*base___0)->prev;
#line 168
    (*base___0)->prev = new;
#line 169
    new->next = (gpe_fifo_t *)0;
  } else {
#line 172
    (*base___0)->next = (gpe_fifo_t *)0;
#line 173
    (*base___0)->prev = *base___0;
  }
#line 175
  ((*base___0)->prev)->ge = *ge;
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
static struct gp_event_t *gpe_front(gpe_fifo_t **base___0 ) 
{ 


  {
#line 181
  return (& (*base___0)->ge);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
static int gpe_pop(gpe_fifo_t **base___0 ) 
{ 
  gpe_fifo_t *save ;

  {
#line 187
  buffered_output_pending --;
#line 188
  if ((unsigned long )(*base___0)->prev == (unsigned long )*base___0) {
#line 189
    (*base___0)->prev = (gpe_fifo_t *)0;
#line 190
    return (0);
  } else {
    {
#line 192
    save = *base___0;
#line 194
    ((*base___0)->next)->prev = (*base___0)->prev;
#line 195
    *base___0 = (*base___0)->next;
#line 196
    free((void *)save);
    }
#line 197
    return (1);
  }
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
void pipe_died_handler(int signum ) 
{ 


  {
  {
#line 208
  close(1);
#line 209
  pipe_died = 1;
  }
#line 210
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
static struct gpe_fifo_t *base  =    (gpe_fifo_t *)0;
#line 213 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/gpexecute.c"
void gp_exec_event(char type___0 , int mx , int my , int par1 , int par2 , int winid ) 
{ 
  struct gp_event_t ge ;
  int status ;
  struct gp_event_t *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 221
  ge.type = (int )type___0;
#line 222
  ge.mx = mx;
#line 223
  ge.my = my;
#line 224
  ge.par1 = par1;
#line 225
  ge.par2 = par2;
#line 226
  ge.winid = winid;
#line 228
  if (pipe_died) {
#line 229
    return;
  }
#line 234
  if (! base) {
    {
#line 235
    base = gpe_init();
    }
  }
#line 237
  if (12 != (int )type___0) {
    {
#line 238
    gpe_push(& base, & ge);
    }
  } else
#line 239
  if (! buffered_output_pending) {
#line 240
    return;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 249
    tmp = gpe_front(& base);
#line 249
    tmp___0 = write(1, (void const   *)tmp, sizeof(ge));
#line 249
    status = (int )tmp___0;
    }
#line 250
    if (-1 == status) {
      {
#line 251
      tmp___1 = __errno_location();
      }
      {
#line 252
      if (*tmp___1 == 11) {
#line 252
        goto case_11;
      }
#line 256
      goto switch_default;
      case_11: /* CIL Label */ ;
#line 255
      goto switch_break;
      switch_default: /* CIL Label */ ;
#line 258
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 260
      goto while_break;
    }
    {
#line 248
    tmp___2 = gpe_pop(& base);
    }
#line 248
    if (! tmp___2) {
#line 248
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return;
}
}
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.h"
void rgb255_from_rgb1(rgb_color rgb1 , rgb255_color *rgb255 ) ;
#line 42
void rgb1maxcolors_from_gray(double gray , rgb_color *color ) ;
#line 43
void rgb255maxcolors_from_gray(double gray , rgb255_color *rgb255 ) ;
#line 51
int palettes_differ(t_sm_palette *p1 , t_sm_palette *p2 ) ;
#line 54
gradient_struct *approximate_palette(t_sm_palette *palette , int samples , double allowed_deviation ,
                                     int *gradient_num ) ;
#line 56
double GetColorValueFromFormula(int formula , double x ) ;
#line 58
char const   *ps_math_color_formulae[76] ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void color_components_from_gray(double gray , rgb_color *color ) ;
#line 38
static int interpolate_color_from_gray(double gray , rgb_color *color ) ;
#line 39
static double get_max_dev(rgb_color *colors , int j , double limit ) ;
#line 40
static int is_extremum(rgb_color left , rgb_color mid , rgb_color right ) ;
#line 41
static void CMY_2_RGB(rgb_color *col ) ;
#line 42
static void CIEXYZ_2_RGB(rgb_color *col ) ;
#line 43
static void YIQ_2_RGB(rgb_color *col ) ;
#line 44
static void HSV_2_RGB(rgb_color *col ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
int palettes_differ(t_sm_palette *p1 , t_sm_palette *p2 ) 
{ 
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int i ;

  {
#line 51
  if ((unsigned int )p1->colorMode != (unsigned int )p2->colorMode) {
#line 52
    return (1);
  }
#line 53
  if ((int )p1->positive != (int )p2->positive) {
#line 54
    return (1);
  }
#line 55
  if (p1->cmodel != p2->cmodel) {
#line 56
    return (1);
  }
#line 57
  if (p1->use_maxcolors != p2->use_maxcolors) {
#line 58
    return (1);
  }
  {
#line 61
  if ((unsigned int )p1->colorMode == 48U) {
#line 61
    goto case_48;
  }
#line 63
  if ((unsigned int )p1->colorMode == 103U) {
#line 63
    goto case_103;
  }
#line 67
  if ((unsigned int )p1->colorMode == 114U) {
#line 67
    goto case_114;
  }
#line 79
  if ((unsigned int )p1->colorMode == 102U) {
#line 79
    goto case_102;
  }
#line 88
  if ((unsigned int )p1->colorMode == 100U) {
#line 88
    goto case_100;
  }
#line 104
  if ((unsigned int )p1->colorMode == 99U) {
#line 104
    goto case_99;
  }
#line 60
  goto switch_break;
  case_48: /* CIL Label */ 
#line 62
  return (0);
  case_103: /* CIL Label */ 
  {
#line 64
  tmp = fabs(p1->gamma - p2->gamma);
  }
#line 64
  if (tmp > 1e-3) {
#line 65
    return (1);
  }
#line 66
  goto switch_break;
  case_114: /* CIL Label */ 
#line 68
  if (p1->colorFormulae != p2->colorFormulae) {
#line 69
    return (1);
  }
#line 70
  if (p1->formulaR != p2->formulaR) {
#line 71
    return (1);
  }
#line 72
  if (p1->formulaG != p2->formulaG) {
#line 73
    return (1);
  }
#line 74
  if (p1->formulaB != p2->formulaB) {
#line 75
    return (1);
  }
#line 78
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 81
  tmp___0 = strcmp((char const   *)p1->Afunc.definition, (char const   *)p2->Afunc.definition);
  }
#line 81
  if (tmp___0) {
#line 82
    return (1);
  }
  {
#line 83
  tmp___1 = strcmp((char const   *)p1->Bfunc.definition, (char const   *)p2->Bfunc.definition);
  }
#line 83
  if (tmp___1) {
#line 84
    return (1);
  }
  {
#line 85
  tmp___2 = strcmp((char const   *)p1->Cfunc.definition, (char const   *)p2->Cfunc.definition);
  }
#line 85
  if (tmp___2) {
#line 86
    return (1);
  }
#line 87
  goto switch_break;
  case_100: /* CIL Label */ 
#line 89
  i = 0;
#line 91
  if (p1->gradient_num != p2->gradient_num) {
#line 92
    return (1);
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < p1->gradient_num)) {
#line 93
      goto while_break;
    }
#line 94
    if ((p1->gradient + i)->pos != (p2->gradient + i)->pos) {
#line 95
      return (1);
    }
#line 96
    if ((p1->gradient + i)->col.r != (p2->gradient + i)->col.r) {
#line 97
      return (1);
    }
#line 98
    if ((p1->gradient + i)->col.g != (p2->gradient + i)->col.g) {
#line 99
      return (1);
    }
#line 100
    if ((p1->gradient + i)->col.b != (p2->gradient + i)->col.b) {
#line 101
      return (1);
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  goto switch_break;
  case_99: /* CIL Label */ 
#line 105
  return (1);
#line 106
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 110
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static int interpolate_color_from_gray(double gray , rgb_color *color ) 
{ 
  int idx ;
  int maxidx ;
  rgb_color *col1 ;
  rgb_color *col2 ;
  int topidx ;
  int tmpidx ;
  double dx ;
  double f ;

  {
#line 132
  if (gray < (double )0) {
#line 133
    color->r = (sm_palette.gradient + 0)->col.r;
#line 134
    color->g = (sm_palette.gradient + 0)->col.g;
#line 135
    color->b = (sm_palette.gradient + 0)->col.b;
#line 136
    return (1);
  }
#line 139
  maxidx = sm_palette.gradient_num;
#line 140
  if (gray > (double )1) {
#line 141
    color->r = (sm_palette.gradient + (maxidx - 1))->col.r;
#line 142
    color->g = (sm_palette.gradient + (maxidx - 1))->col.g;
#line 143
    color->b = (sm_palette.gradient + (maxidx - 1))->col.b;
#line 144
    return (1);
  }
#line 148
  idx = 0;
#line 149
  if (maxidx > 1) {
#line 150
    topidx = maxidx - 1;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      if (! (idx != topidx)) {
#line 152
        goto while_break;
      }
#line 153
      tmpidx = (idx + topidx) / 2;
#line 154
      if ((sm_palette.gradient + tmpidx)->pos < gray) {
#line 155
        idx = tmpidx + 1;
      } else {
#line 157
        topidx = tmpidx;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 161
  col2 = & (sm_palette.gradient + idx)->col;
#line 162
  if (gray == (sm_palette.gradient + idx)->pos) {
#line 164
    color->r = col2->r;
#line 165
    color->g = col2->g;
#line 166
    color->b = col2->b;
  } else {
#line 169
    dx = (sm_palette.gradient + idx)->pos - (sm_palette.gradient + (idx - 1))->pos;
#line 171
    f = (gray - (sm_palette.gradient + (idx - 1))->pos) / dx;
#line 173
    col1 = & (sm_palette.gradient + (idx - 1))->col;
#line 174
    color->r = col1->r + f * (col2->r - col1->r);
#line 175
    color->g = col1->g + f * (col2->g - col1->g);
#line 176
    color->b = col1->b + f * (col2->b - col1->b);
  }
#line 178
  return (0);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void color_components_from_gray(double gray , rgb_color *color ) 
{ 
  double tmp ;
  double tmp___0 ;
  double phi ;
  double a ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 233
  if (gray < (double )0) {
#line 234
    gray = (double )0;
  } else
#line 235
  if (gray > 1.0) {
#line 236
    gray = 1.0;
  }
  {
#line 239
  if ((unsigned int )sm_palette.colorMode == 103U) {
#line 239
    goto case_103;
  }
#line 242
  if ((unsigned int )sm_palette.colorMode == 114U) {
#line 242
    goto case_114;
  }
#line 247
  if ((unsigned int )sm_palette.colorMode == 100U) {
#line 247
    goto case_100;
  }
#line 255
  if ((unsigned int )sm_palette.colorMode == 99U) {
#line 255
    goto case_99;
  }
#line 270
  goto switch_default;
  case_103: /* CIL Label */ 
  {
#line 240
  tmp___0 = pow(gray, 1.0 / sm_palette.gamma);
#line 240
  color->b = tmp___0;
#line 240
  tmp = tmp___0;
#line 240
  color->g = tmp;
#line 240
  color->r = tmp;
  }
#line 241
  return;
  case_114: /* CIL Label */ 
  {
#line 243
  color->r = GetColorValueFromFormula(sm_palette.formulaR, gray);
#line 244
  color->g = GetColorValueFromFormula(sm_palette.formulaG, gray);
#line 245
  color->b = GetColorValueFromFormula(sm_palette.formulaB, gray);
  }
#line 246
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 248
  interpolate_color_from_gray(gray, color);
  }
#line 249
  goto switch_break;
  case_99: /* CIL Label */ 
#line 257
  phi = (2. * 3.14159265358979323846) * (sm_palette.cubehelix_start / 3. + gray * sm_palette.cubehelix_cycles);
#line 259
  if (sm_palette.gamma != 1.0) {
    {
#line 260
    gray = pow(gray, 1. / sm_palette.gamma);
    }
  }
  {
#line 261
  a = ((sm_palette.cubehelix_saturation * gray) * (1. - gray)) / 2.;
#line 262
  tmp___1 = cos(phi);
#line 262
  tmp___2 = sin(phi);
#line 262
  color->r = gray + a * (- 0.14861 * tmp___1 + 1.78277 * tmp___2);
#line 263
  tmp___3 = cos(phi);
#line 263
  tmp___4 = sin(phi);
#line 263
  color->g = gray + a * (- 0.29227 * tmp___3 - 0.90649 * tmp___4);
#line 264
  tmp___5 = cos(phi);
#line 264
  color->b = gray + a * (1.97294 * tmp___5);
  }
#line 265
  if (color->r > 1.0) {
#line 265
    color->r = 1.0;
  }
#line 265
  if (color->r < 0.0) {
#line 265
    color->r = 0.0;
  }
#line 266
  if (color->g > 1.0) {
#line 266
    color->g = 1.0;
  }
#line 266
  if (color->g < 0.0) {
#line 266
    color->g = 0.0;
  }
#line 267
  if (color->b > 1.0) {
#line 267
    color->b = 1.0;
  }
#line 267
  if (color->b < 0.0) {
#line 267
    color->b = 0.0;
  }
#line 269
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 271
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d ooops: Unknown colorMode \'%c\'.\n",
          "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c",
          272, (int )((char )sm_palette.colorMode));
  }
  switch_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
void rgb1_from_gray(double gray , rgb_color *color ) 
{ 


  {
  {
#line 288
  color_components_from_gray(gray, color);
  }
#line 289
  if ((unsigned int )sm_palette.colorMode == 103U) {
#line 290
    return;
  }
  {
#line 294
  if (sm_palette.cmodel == 114) {
#line 294
    goto case_114;
  }
#line 296
  if (sm_palette.cmodel == 104) {
#line 296
    goto case_104;
  }
#line 299
  if (sm_palette.cmodel == 99) {
#line 299
    goto case_99;
  }
#line 302
  if (sm_palette.cmodel == 121) {
#line 302
    goto case_121;
  }
#line 305
  if (sm_palette.cmodel == 120) {
#line 305
    goto case_120;
  }
#line 308
  goto switch_default;
  case_114: /* CIL Label */ 
#line 295
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 297
  HSV_2_RGB(color);
  }
#line 298
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 300
  CMY_2_RGB(color);
  }
#line 301
  goto switch_break;
  case_121: /* CIL Label */ 
  {
#line 303
  YIQ_2_RGB(color);
  }
#line 304
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 306
  CIEXYZ_2_RGB(color);
  }
#line 307
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 309
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d ooops: Unknown color model \'%c\'\n",
          "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c",
          310, (int )((char )sm_palette.cmodel));
  }
  switch_break: /* CIL Label */ ;
  }
#line 312
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
void rgb255_from_rgb1(rgb_color rgb1 , rgb255_color *rgb255 ) 
{ 


  {
#line 321
  rgb255->r = (unsigned char )((double )255 * rgb1.r + 0.5);
#line 322
  rgb255->g = (unsigned char )((double )255 * rgb1.g + 0.5);
#line 323
  rgb255->b = (unsigned char )((double )255 * rgb1.b + 0.5);
#line 324
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
void rgb1maxcolors_from_gray(double gray , rgb_color *color ) 
{ 


  {
#line 340
  if (sm_palette.use_maxcolors != 0) {
    {
#line 341
    gray = quantize_gray(gray);
    }
  }
  {
#line 343
  rgb1_from_gray(gray, color);
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
double quantize_gray(double gray ) 
{ 
  double degray ;
  double tmp ;
  int j ;

  {
  {
#line 349
  tmp = floor(gray * (double )sm_palette.use_maxcolors);
#line 349
  degray = tmp / (double )(sm_palette.use_maxcolors - 1);
  }
#line 352
  if ((unsigned int )sm_palette.colorMode == 100U) {
#line 354
    if (sm_palette.gradient_num <= 2) {
#line 354
      if (! (degray == (double )0)) {
#line 354
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 356
      j = 0;
      {
#line 356
      while (1) {
        while_continue: /* CIL Label */ ;
#line 356
        if (! (j < sm_palette.gradient_num)) {
#line 356
          goto while_break;
        }
#line 357
        if (gray >= (sm_palette.gradient + j)->pos) {
#line 357
          if (gray < (sm_palette.gradient + (j + 1))->pos) {
#line 359
            if (degray < (sm_palette.gradient + j)->pos) {
#line 361
              degray = ((sm_palette.gradient + j)->pos + (sm_palette.gradient + (j + 1))->pos) / 2.;
            } else
#line 359
            if (degray > (sm_palette.gradient + (j + 1))->pos) {
#line 361
              degray = ((sm_palette.gradient + j)->pos + (sm_palette.gradient + (j + 1))->pos) / 2.;
            }
          }
        }
#line 364
        if (gray < (sm_palette.gradient + (j + 1))->pos) {
#line 365
          goto while_break;
        }
#line 356
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 369
  return (degray);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
void rgb255maxcolors_from_gray(double gray , rgb255_color *rgb255 ) 
{ 
  rgb_color rgb1 ;

  {
  {
#line 381
  rgb1maxcolors_from_gray(gray, & rgb1);
#line 382
  rgb255_from_rgb1(rgb1, rgb255);
  }
#line 383
  return;
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static double get_max_dev(rgb_color *colors , int j , double limit ) 
{ 
  double max_dev ;
  double rdev ;
  double gdev ;
  double bdev ;
  double r ;
  double g ;
  double b ;
  int i ;
  double sr ;
  double sg ;
  double sb ;
  double dx ;

  {
#line 392
  max_dev = 0.0;
#line 394
  r = (colors + 0)->r;
#line 394
  g = (colors + 0)->g;
#line 394
  b = (colors + 0)->b;
#line 396
  sr = ((colors + j)->r - r) / (double )j;
#line 397
  sg = ((colors + j)->g - g) / (double )j;
#line 398
  sb = ((colors + j)->b - b) / (double )j;
#line 400
  i = 1;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < j)) {
#line 400
      goto while_break;
    }
    {
#line 401
    dx = (double )i;
#line 403
    rdev = fabs((sr * dx + r) - (colors + i)->r);
#line 404
    gdev = fabs((sg * dx + g) - (colors + i)->g);
#line 405
    bdev = fabs((sb * dx + b) - (colors + i)->b);
    }
#line 406
    if (rdev > max_dev) {
#line 407
      max_dev = rdev;
    }
#line 408
    if (gdev > max_dev) {
#line 409
      max_dev = gdev;
    }
#line 410
    if (bdev > max_dev) {
#line 411
      max_dev = bdev;
    }
#line 412
    if (max_dev >= limit) {
#line 413
      goto while_break;
    }
#line 400
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return (max_dev);
}
}
#line 423 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static int is_extremum(rgb_color left , rgb_color mid , rgb_color right ) 
{ 


  {
#line 427
  if (left.r < mid.r) {
#line 427
    if (mid.r > right.r) {
#line 428
      return (1);
    }
  }
#line 429
  if (left.g < mid.g) {
#line 429
    if (mid.g > right.g) {
#line 430
      return (1);
    }
  }
#line 431
  if (left.b < mid.b) {
#line 431
    if (mid.b > right.b) {
#line 432
      return (1);
    }
  }
#line 435
  if (left.r > mid.r) {
#line 435
    if (mid.r < right.r) {
#line 436
      return (1);
    }
  }
#line 437
  if (left.g > mid.g) {
#line 437
    if (mid.g < right.g) {
#line 438
      return (1);
    }
  }
#line 439
  if (left.b > mid.b) {
#line 439
    if (mid.b < right.b) {
#line 440
      return (1);
    }
  }
#line 442
  return (0);
}
}
#line 469 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
gradient_struct *approximate_palette(t_sm_palette *palette , int samples , double allowed_deviation ,
                                     int *gradient_num ) 
{ 
  int i ;
  int j ;
  double gray ;
  int gradient_size ;
  gradient_struct *gradient ;
  int colors_size ;
  rgb_color *colors ;
  int cnt ;
  rgb_color color ;
  double max_dev ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 474
  i = 0;
#line 474
  j = 0;
#line 475
  gray = (double )0;
#line 476
  gradient_size = 50;
#line 478
  colors_size = 100;
#line 480
  cnt = 0;
#line 482
  max_dev = 0.0;
#line 486
  if (samples <= 0) {
#line 487
    samples = 2000;
  }
#line 488
  if (allowed_deviation <= (double )0) {
#line 489
    allowed_deviation = 0.003;
  }
  {
#line 491
  tmp = malloc((unsigned long )gradient_size * sizeof(gradient_struct ));
#line 491
  gradient = (gradient_struct *)tmp;
#line 493
  tmp___0 = malloc((unsigned long )colors_size * sizeof(rgb_color ));
#line 493
  colors = (rgb_color *)tmp___0;
#line 496
  cnt = 0;
#line 497
  color_components_from_gray(0.0, colors + 0);
#line 498
  (gradient + 0)->pos = 0.0;
#line 499
  (gradient + 0)->col = *(colors + 0);
#line 500
  cnt ++;
#line 501
  color_components_from_gray(1.0 / (double )samples, colors + 1);
#line 503
  i = 0;
  }
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < samples)) {
#line 503
      goto while_break;
    }
#line 504
    j = 2;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! (i + j <= samples)) {
#line 504
        goto while_break___0;
      }
#line 505
      gray = (double )(i + j) / (double )samples;
#line 506
      if (j == colors_size) {
        {
#line 507
        colors_size += 50;
#line 508
        tmp___1 = realloc((void *)colors, (unsigned long )colors_size * sizeof(gradient_struct ));
#line 508
        colors = (rgb_color *)tmp___1;
        }
      }
      {
#line 511
      color_components_from_gray(gray, colors + j);
#line 514
      tmp___2 = is_extremum(*(colors + (j - 2)), *(colors + (j - 1)), *(colors + j));
      }
#line 514
      if (tmp___2) {
#line 517
        goto while_break___0;
      }
      {
#line 521
      max_dev = get_max_dev(colors, j, allowed_deviation);
      }
#line 522
      if (max_dev > allowed_deviation) {
#line 524
        goto while_break___0;
      }
#line 504
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 527
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 527
      if (cnt == gradient_size) {
        {
#line 527
        gradient_size += 25;
#line 527
        tmp___3 = realloc((void *)gradient, (unsigned long )gradient_size * sizeof(gradient_struct ));
#line 527
        gradient = (gradient_struct *)tmp___3;
        }
      }
#line 527
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 529
    (gradient + cnt)->pos = gray;
#line 530
    (gradient + cnt)->col = *(colors + (j - 1));
#line 531
    cnt ++;
#line 535
    *(colors + 0) = *(colors + (j - 1));
#line 536
    *(colors + 1) = *(colors + j);
#line 537
    i += j - 1;
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 540
  color_components_from_gray(1.0, & color);
  }
  {
#line 541
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 541
    if (cnt == gradient_size) {
      {
#line 541
      gradient_size ++;
#line 541
      tmp___4 = realloc((void *)gradient, (unsigned long )gradient_size * sizeof(gradient_struct ));
#line 541
      gradient = (gradient_struct *)tmp___4;
      }
    }
#line 541
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 542
  (gradient + cnt)->pos = 1.0;
#line 543
  (gradient + cnt)->col = color;
#line 544
  cnt ++;
#line 554
  free((void *)colors);
#line 555
  *gradient_num = cnt;
  }
#line 556
  return (gradient);
}
}
#line 565 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
double GetColorValueFromFormula(int formula , double x ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 569
  if (formula < 0) {
#line 570
    x = (double )1 - x;
#line 571
    formula = - formula;
  }
  {
#line 574
  if (formula == 0) {
#line 574
    goto case_0;
  }
#line 576
  if (formula == 1) {
#line 576
    goto case_1;
  }
#line 578
  if (formula == 2) {
#line 578
    goto case_2;
  }
#line 580
  if (formula == 3) {
#line 580
    goto case_3;
  }
#line 582
  if (formula == 4) {
#line 582
    goto case_4;
  }
#line 585
  if (formula == 5) {
#line 585
    goto case_5;
  }
#line 588
  if (formula == 6) {
#line 588
    goto case_6;
  }
#line 591
  if (formula == 7) {
#line 591
    goto case_7;
  }
#line 594
  if (formula == 8) {
#line 594
    goto case_8;
  }
#line 597
  if (formula == 9) {
#line 597
    goto case_9;
  }
#line 600
  if (formula == 10) {
#line 600
    goto case_10;
  }
#line 603
  if (formula == 11) {
#line 603
    goto case_11;
  }
#line 606
  if (formula == 12) {
#line 606
    goto case_12;
  }
#line 609
  if (formula == 13) {
#line 609
    goto case_13;
  }
#line 612
  if (formula == 14) {
#line 612
    goto case_14;
  }
#line 615
  if (formula == 15) {
#line 615
    goto case_15;
  }
#line 618
  if (formula == 16) {
#line 618
    goto case_16;
  }
#line 621
  if (formula == 17) {
#line 621
    goto case_17;
  }
#line 624
  if (formula == 18) {
#line 624
    goto case_18;
  }
#line 627
  if (formula == 19) {
#line 627
    goto case_19;
  }
#line 630
  if (formula == 20) {
#line 630
    goto case_20;
  }
#line 633
  if (formula == 21) {
#line 633
    goto case_21;
  }
#line 636
  if (formula == 22) {
#line 636
    goto case_22;
  }
#line 639
  if (formula == 23) {
#line 639
    goto case_23;
  }
#line 642
  if (formula == 24) {
#line 642
    goto case_24;
  }
#line 645
  if (formula == 25) {
#line 645
    goto case_25;
  }
#line 648
  if (formula == 26) {
#line 648
    goto case_26;
  }
#line 651
  if (formula == 27) {
#line 651
    goto case_27;
  }
#line 654
  if (formula == 28) {
#line 654
    goto case_28;
  }
#line 657
  if (formula == 29) {
#line 657
    goto case_29;
  }
#line 660
  if (formula == 30) {
#line 660
    goto case_30;
  }
#line 667
  if (formula == 31) {
#line 667
    goto case_31;
  }
#line 674
  if (formula == 32) {
#line 674
    goto case_32;
  }
#line 680
  if (formula == 33) {
#line 680
    goto case_33;
  }
#line 683
  if (formula == 34) {
#line 683
    goto case_34;
  }
#line 686
  if (formula == 35) {
#line 686
    goto case_35;
  }
#line 689
  if (formula == 36) {
#line 689
    goto case_36;
  }
#line 699
  goto switch_default;
  case_0: /* CIL Label */ 
#line 575
  return ((double )0);
  case_1: /* CIL Label */ 
#line 577
  return (0.5);
  case_2: /* CIL Label */ 
#line 579
  return ((double )1);
  case_3: /* CIL Label */ 
#line 581
  goto switch_break;
  case_4: /* CIL Label */ 
#line 583
  x *= x;
#line 584
  goto switch_break;
  case_5: /* CIL Label */ 
#line 586
  x = (x * x) * x;
#line 587
  goto switch_break;
  case_6: /* CIL Label */ 
#line 589
  x = ((x * x) * x) * x;
#line 590
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 592
  x = sqrt(x);
  }
#line 593
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 595
  tmp = sqrt(x);
#line 595
  x = sqrt(tmp);
  }
#line 596
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 598
  x = sin(((double )90 * x) * (3.14159265358979323846 / 180.0));
  }
#line 599
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 601
  x = cos(((double )90 * x) * (3.14159265358979323846 / 180.0));
  }
#line 602
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 604
  x = fabs(x - 0.5);
  }
#line 605
  goto switch_break;
  case_12: /* CIL Label */ 
#line 607
  x = ((double )2 * x - (double )1) * (2.0 * x - (double )1);
#line 608
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 610
  x = sin(((double )180 * x) * (3.14159265358979323846 / 180.0));
  }
#line 611
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 613
  tmp___0 = cos(((double )180 * x) * (3.14159265358979323846 / 180.0));
#line 613
  x = fabs(tmp___0);
  }
#line 614
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 616
  x = sin(((double )360 * x) * (3.14159265358979323846 / 180.0));
  }
#line 617
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 619
  x = cos(((double )360 * x) * (3.14159265358979323846 / 180.0));
  }
#line 620
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 622
  tmp___1 = sin(((double )360 * x) * (3.14159265358979323846 / 180.0));
#line 622
  x = fabs(tmp___1);
  }
#line 623
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 625
  tmp___2 = cos(((double )360 * x) * (3.14159265358979323846 / 180.0));
#line 625
  x = fabs(tmp___2);
  }
#line 626
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 628
  tmp___3 = sin(((double )720 * x) * (3.14159265358979323846 / 180.0));
#line 628
  x = fabs(tmp___3);
  }
#line 629
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 631
  tmp___4 = cos(((double )720 * x) * (3.14159265358979323846 / 180.0));
#line 631
  x = fabs(tmp___4);
  }
#line 632
  goto switch_break;
  case_21: /* CIL Label */ 
#line 634
  x = (double )3 * x;
#line 635
  goto switch_break;
  case_22: /* CIL Label */ 
#line 637
  x = (double )3 * x - (double )1;
#line 638
  goto switch_break;
  case_23: /* CIL Label */ 
#line 640
  x = (double )3 * x - (double )2;
#line 641
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 643
  x = fabs((double )3 * x - (double )1);
  }
#line 644
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 646
  x = fabs((double )3 * x - (double )2);
  }
#line 647
  goto switch_break;
  case_26: /* CIL Label */ 
#line 649
  x = 1.5 * x - 0.5;
#line 650
  goto switch_break;
  case_27: /* CIL Label */ 
#line 652
  x = 1.5 * x - (double )1;
#line 653
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 655
  x = fabs(1.5 * x - 0.5);
  }
#line 656
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 658
  x = fabs(1.5 * x - (double )1);
  }
#line 659
  goto switch_break;
  case_30: /* CIL Label */ 
#line 661
  if (x <= 0.25) {
#line 662
    return ((double )0);
  }
#line 663
  if (x >= 0.57) {
#line 664
    return ((double )1);
  }
#line 665
  x = x / 0.32 - 0.78125;
#line 666
  goto switch_break;
  case_31: /* CIL Label */ 
#line 668
  if (x <= 0.42) {
#line 669
    return ((double )0);
  }
#line 670
  if (x >= 0.92) {
#line 671
    return ((double )1);
  }
#line 672
  x = (double )2 * x - 0.84;
#line 673
  goto switch_break;
  case_32: /* CIL Label */ 
#line 675
  if (x <= 0.42) {
#line 676
    x *= (double )4;
  } else
#line 678
  if (x <= 0.92) {
#line 678
    x = (double )-2 * x + 1.84;
  } else {
#line 678
    x = x / 0.08 - 11.5;
  }
#line 679
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 681
  x = fabs((double )2 * x - 0.5);
  }
#line 682
  goto switch_break;
  case_34: /* CIL Label */ 
#line 684
  x = (double )2 * x;
#line 685
  goto switch_break;
  case_35: /* CIL Label */ 
#line 687
  x = (double )2 * x - 0.5;
#line 688
  goto switch_break;
  case_36: /* CIL Label */ 
#line 690
  x = (double )2 * x - (double )1;
#line 691
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 700
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal: undefined color formula (can be 0--%i)\n",
          sm_palette.colorFormulae - 1);
#line 701
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 703
  if (x <= (double )0) {
#line 704
    return ((double )0);
  }
#line 705
  if (x >= (double )1) {
#line 706
    return ((double )1);
  }
#line 707
  return (x);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
char const   *ps_math_color_formulae[76]  = 
#line 719
  {      "pop 0",      "0",      "pop 0.5",      "0.5", 
        "pop 1",      "1",      " ",      "x", 
        "dup mul",      "x^2",      "dup dup mul mul",      "x^3", 
        "dup mul dup mul",      "x^4",      "sqrt",      "sqrt(x)", 
        "sqrt sqrt",      "sqrt(sqrt(x))",      "90 mul sin",      "sin(90x)", 
        "90 mul cos",      "cos(90x)",      "0.5 sub abs",      "|x-0.5|", 
        "2 mul 1 sub dup mul",      "(2x-1)^2",      "180 mul sin",      "sin(180x)", 
        "180 mul cos abs",      "|cos(180x)|",      "360 mul sin",      "sin(360x)", 
        "360 mul cos",      "cos(360x)",      "360 mul sin abs",      "|sin(360x)|", 
        "360 mul cos abs",      "|cos(360x)|",      "720 mul sin abs",      "|sin(720x)|", 
        "720 mul cos abs",      "|cos(720x)|",      "3 mul",      "3x", 
        "3 mul 1 sub",      "3x-1",      "3 mul 2 sub",      "3x-2", 
        "3 mul 1 sub abs",      "|3x-1|",      "3 mul 2 sub abs",      "|3x-2|", 
        "1.5 mul .5 sub",      "(3x-1)/2",      "1.5 mul 1 sub",      "(3x-2)/2", 
        "1.5 mul .5 sub abs",      "|(3x-1)/2|",      "1.5 mul 1 sub abs",      "|(3x-2)/2|", 
        "0.32 div 0.78125 sub",      "x/0.32-0.78125",      "2 mul 0.84 sub",      "2*x-0.84", 
        "dup 0.42 le {4 mul} {dup 0.92 le {-2 mul 1.84 add} {0.08 div 11.5 sub} ifelse} ifelse",      "4x;1;-2x+1.84;x/0.08-11.5",      "2 mul 0.5 sub abs",      "|2*x - 0.5|", 
        "2 mul",      "2*x",      "2 mul 0.5 sub",      "2*x - 0.5", 
        "2 mul 1 sub",      "2*x - 1",      "",      ""};
#line 768 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void CMY_2_RGB(rgb_color *col ) 
{ 
  double c ;
  double m ;
  double y ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 772
  c = col->r;
#line 773
  m = col->g;
#line 774
  y = col->b;
#line 775
  if (1.0 - c < (double )0) {
#line 775
    col->r = (double )0;
  } else {
#line 775
    if (1.0 - c > (double )1) {
#line 775
      tmp = (double )1;
    } else {
#line 775
      tmp = 1.0 - c;
    }
#line 775
    col->r = tmp;
  }
#line 776
  if (1.0 - m < (double )0) {
#line 776
    col->g = (double )0;
  } else {
#line 776
    if (1.0 - m > (double )1) {
#line 776
      tmp___0 = (double )1;
    } else {
#line 776
      tmp___0 = 1.0 - m;
    }
#line 776
    col->g = tmp___0;
  }
#line 777
  if (1.0 - y < (double )0) {
#line 777
    col->b = (double )0;
  } else {
#line 777
    if (1.0 - y > (double )1) {
#line 777
      tmp___1 = (double )1;
    } else {
#line 777
      tmp___1 = 1.0 - y;
    }
#line 777
    col->b = tmp___1;
  }
#line 778
  return;
}
}
#line 780 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void CIEXYZ_2_RGB(rgb_color *col ) 
{ 
  double x ;
  double y ;
  double z ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 785
  x = col->r;
#line 786
  y = col->g;
#line 787
  z = col->b;
#line 788
  if ((1.9100 * x - 0.5338 * y) - 0.2891 * z < (double )0) {
#line 788
    col->r = (double )0;
  } else {
#line 788
    if ((1.9100 * x - 0.5338 * y) - 0.2891 * z > (double )1) {
#line 788
      tmp = (double )1;
    } else {
#line 788
      tmp = (1.9100 * x - 0.5338 * y) - 0.2891 * z;
    }
#line 788
    col->r = tmp;
  }
#line 789
  if ((- 0.9844 * x + 1.9990 * y) - 0.0279 * z < (double )0) {
#line 789
    col->g = (double )0;
  } else {
#line 789
    if ((- 0.9844 * x + 1.9990 * y) - 0.0279 * z > (double )1) {
#line 789
      tmp___0 = (double )1;
    } else {
#line 789
      tmp___0 = (- 0.9844 * x + 1.9990 * y) - 0.0279 * z;
    }
#line 789
    col->g = tmp___0;
  }
#line 790
  if ((0.0585 * x - 0.1187 * y) - 0.9017 * z < (double )0) {
#line 790
    col->b = (double )0;
  } else {
#line 790
    if ((0.0585 * x - 0.1187 * y) - 0.9017 * z > (double )1) {
#line 790
      tmp___1 = (double )1;
    } else {
#line 790
      tmp___1 = (0.0585 * x - 0.1187 * y) - 0.9017 * z;
    }
#line 790
    col->b = tmp___1;
  }
#line 791
  return;
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void YIQ_2_RGB(rgb_color *col ) 
{ 
  double y ;
  double i ;
  double q ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 798
  y = col->r;
#line 799
  i = col->g;
#line 800
  q = col->b;
#line 801
  if ((y - 0.956 * i) + 0.621 * q < (double )0) {
#line 801
    col->r = (double )0;
  } else {
#line 801
    if ((y - 0.956 * i) + 0.621 * q > (double )1) {
#line 801
      tmp = (double )1;
    } else {
#line 801
      tmp = (y - 0.956 * i) + 0.621 * q;
    }
#line 801
    col->r = tmp;
  }
#line 802
  if ((y - 0.272 * i) - 0.647 * q < (double )0) {
#line 802
    col->g = (double )0;
  } else {
#line 802
    if ((y - 0.272 * i) - 0.647 * q > (double )1) {
#line 802
      tmp___0 = (double )1;
    } else {
#line 802
      tmp___0 = (y - 0.272 * i) - 0.647 * q;
    }
#line 802
    col->g = tmp___0;
  }
#line 803
  if ((y - 1.105 * i) - 1.702 * q < (double )0) {
#line 803
    col->b = (double )0;
  } else {
#line 803
    if ((y - 1.105 * i) - 1.702 * q > (double )1) {
#line 803
      tmp___1 = (double )1;
    } else {
#line 803
      tmp___1 = (y - 1.105 * i) - 1.702 * q;
    }
#line 803
    col->b = tmp___1;
  }
#line 804
  return;
}
}
#line 806 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/src/./getcolor.c"
static void HSV_2_RGB(rgb_color *col ) 
{ 
  double h ;
  double s ;
  double v ;
  double f ;
  double p ;
  double q ;
  double t ;
  int i ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 812
  h = col->r;
#line 813
  s = col->g;
#line 814
  v = col->b;
#line 815
  if (s == (double )0) {
#line 816
    tmp___0 = v;
#line 816
    col->b = tmp___0;
#line 816
    tmp = tmp___0;
#line 816
    col->g = tmp;
#line 816
    col->r = tmp;
#line 817
    return;
  }
  {
#line 820
  h *= 6.;
#line 821
  tmp___1 = floor(h);
#line 821
  i = (int )tmp___1;
#line 822
  f = h - (double )i;
#line 823
  p = v * (1.0 - s);
#line 824
  q = v * (1.0 - s * f);
#line 825
  t = v * (1.0 - s * (1.0 - f));
  }
  {
#line 827
  if (i % 6 == 0) {
#line 827
    goto case_0;
  }
#line 832
  if (i % 6 == 1) {
#line 832
    goto case_1;
  }
#line 837
  if (i % 6 == 2) {
#line 837
    goto case_2;
  }
#line 842
  if (i % 6 == 3) {
#line 842
    goto case_3;
  }
#line 847
  if (i % 6 == 4) {
#line 847
    goto case_4;
  }
#line 852
  goto switch_default;
  case_0: /* CIL Label */ 
#line 828
  col->r = v;
#line 829
  col->g = t;
#line 830
  col->b = p;
#line 831
  goto switch_break;
  case_1: /* CIL Label */ 
#line 833
  col->r = q;
#line 834
  col->g = v;
#line 835
  col->b = p;
#line 836
  goto switch_break;
  case_2: /* CIL Label */ 
#line 838
  col->r = p;
#line 839
  col->g = v;
#line 840
  col->b = t;
#line 841
  goto switch_break;
  case_3: /* CIL Label */ 
#line 843
  col->r = p;
#line 844
  col->g = q;
#line 845
  col->b = v;
#line 846
  goto switch_break;
  case_4: /* CIL Label */ 
#line 848
  col->r = t;
#line 849
  col->g = p;
#line 850
  col->b = v;
#line 851
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 853
  col->r = v;
#line 854
  col->g = p;
#line 855
  col->b = q;
#line 856
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 858
  return;
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2x.h"
char *termtext[2924]  = 
#line 68 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2x.h"
  {      (char *)"C#gpic",      (char *)"1 gpic",      (char *)"?commands set terminal gpic",      (char *)"?set terminal gpic", 
        (char *)"?set term gpic",      (char *)"?terminal gpic",      (char *)"?term gpic",      (char *)"?gpic", 
        (char *)" The `gpic` terminal driver generates GPIC graphs in the Free Software",      (char *)" Foundations\'s \"groff\" package.  The default size is 5 x 3 inches.  The only",      (char *)" option is the origin, which defaults to (0,0).",      (char *)"", 
        (char *)" Syntax:",      (char *)"       set terminal gpic {<x> <y>}",      (char *)"",      (char *)" where `x` and `y` are in inches.", 
        (char *)"",      (char *)" A simple graph can be formatted using",      (char *)"",      (char *)"       groff -p -mpic -Tps file.pic > file.ps.", 
        (char *)"",      (char *)" The output from pic can be pipe-lined into eqn, so it is possible to put",      (char *)" complex functions in a graph with the `set label` and `set {x/y}label`",      (char *)" commands.  For instance,", 
        (char *)"",      (char *)"       set ylab \'@space 0 int from 0 to x alpha ( t ) roman d t@\'",      (char *)"",      (char *)" will label the y axis with a nice integral if formatted with the command:", 
        (char *)"",      (char *)"       gpic filename.pic | geqn -d@@ -Tps | groff -m[macro-package] -Tps",      (char *)"           > filename.ps",      (char *)"", 
        (char *)" Figures made this way can be scaled to fit into a document.  The pic language",      (char *)" is easy to understand, so the graphs can be edited by hand if need be.  All",      (char *)" co-ordinates in the pic-file produced by `gnuplot` are given as x+gnuplotx",      (char *)" and y+gnuploty.  By default x and y are given the value 0.  If this line is", 
        (char *)" removed with an editor in a number of files, one can put several graphs in",      (char *)" one figure like this (default size is 5.0x3.0 inches):",      (char *)"",      (char *)"       .PS 8.0", 
        (char *)"       x=0;y=3",      (char *)"       copy \"figa.pic\"",      (char *)"       x=5;y=3",      (char *)"       copy \"figb.pic\"", 
        (char *)"       x=0;y=0",      (char *)"       copy \"figc.pic\"",      (char *)"       x=5;y=0",      (char *)"       copy \"figd.pic\"", 
        (char *)"       .PE",      (char *)"",      (char *)" This will produce an 8-inch-wide figure with four graphs in two rows on top",      (char *)" of each other.", 
        (char *)"",      (char *)" One can also achieve the same thing by the command",      (char *)"",      (char *)"       set terminal gpic x y", 
        (char *)"",      (char *)" for example, using",      (char *)"",      (char *)"       .PS 6.0", 
        (char *)"       copy \"trig.pic\"",      (char *)"       .PE",      (char *)"C#",      (char *)"C#regis", 
        (char *)"1 regis",      (char *)"?commands set terminal regis",      (char *)"?set terminal regis",      (char *)"?set term regis", 
        (char *)"?terminal regis",      (char *)"?term regis",      (char *)"?regis",      (char *)" The `regis` terminal device generates output in the REGIS graphics language.", 
        (char *)" It has the option of using 4 (the default) or 16 colors.",      (char *)"",      (char *)" Syntax:",      (char *)"       set terminal regis {4 | 16}", 
        (char *)"C#",      (char *)"C#tek410x",      (char *)"1 tek410x",      (char *)"?commands set terminal tek410x", 
        (char *)"?set terminal tek410x",      (char *)"?set term tek410x",      (char *)"?terminal tek410x",      (char *)"?term tek410x", 
        (char *)"?tek410x",      (char *)" The `tek410x` terminal driver supports the 410x and 420x family of Tektronix",      (char *)" terminals.  It has no options.",      (char *)"C#", 
        (char *)"C#tek40",      (char *)"1 tek40",      (char *)"?commands set terminal tek40xx",      (char *)"?set terminal tek40xx", 
        (char *)"?set term tek40xx",      (char *)"?terminal tek40xx",      (char *)"?term tek40xx",      (char *)"?tek40", 
        (char *)"?commands set terminal vttek",      (char *)"?set terminal vttek",      (char *)"?set term vttek",      (char *)"?terminal vttek", 
        (char *)"?term vttek",      (char *)"?vttek",      (char *)"?commands set terminal xterm",      (char *)"?set terminal xterm", 
        (char *)"?set term xterm",      (char *)"?terminal xterm",      (char *)"?term xterm",      (char *)"?xterm", 
        (char *)" This family of terminal drivers supports a variety of VT-like terminals.",      (char *)" `tek40xx` supports Tektronix 4010 and others as well as most TEK emulators.",      (char *)" `vttek` supports VT-like tek40xx terminal emulators.",      (char *)" The following are present only if selected when gnuplot is built:", 
        (char *)" `kc-tek40xx` supports MS-DOS Kermit Tek4010 terminal emulators in color;",      (char *)" `km-tek40xx` supports them in monochrome. `selanar` supports Selanar graphics.",      (char *)" `bitgraph` supports BBN Bitgraph terminals.",      (char *)" None have any options.", 
        (char *)"C#",      (char *)"C#x11",      (char *)"1 x11",      (char *)"?commands set terminal x11", 
        (char *)"?set terminal x11",      (char *)"?set term x11",      (char *)"?terminal x11",      (char *)"?term x11", 
        (char *)"?x11",      (char *)"?X11",      (char *)"",      (char *)" Syntax:", 
        (char *)"    set terminal x11 {<n> | window \"<string>\"}",      (char *)"                     {title \"<string>\"}",      (char *)"                     {{no}enhanced} {font <fontspec>}",      (char *)"                     {linewidth LW} {solid|dashed}", 
        (char *)"                     {{no}persist} {{no}raise} {{no}ctrlq}",      (char *)"                     {close}",      (char *)"                     {size XX,YY} {position XX,YY}",      (char *)"    set terminal x11 {reset}", 
        (char *)"",      (char *)" Multiple plot windows are supported: `set terminal x11 <n>` directs the",      (char *)" output to plot window number n.  If n is not 0, the terminal number will be",      (char *)" appended to the window title (unless a title has been supplied manually)", 
        (char *)" and the icon will be labeled `Gnuplot <n>`.  The active window may be",      (char *)" distinguished by a change in cursor (from default to crosshair).",      (char *)"",      (char *)" The `x11` terminal can connect to X windows previously created by an outside", 
        (char *)" application via the option `window` followed by a string containing the",      (char *)" X ID for the window in hexadecimal format.  Gnuplot uses that external X",      (char *)" window as a container since X does not allow for multiple clients selecting",      (char *)" the ButtonPress event.  In this way, gnuplot\'s mouse features work within", 
        (char *)" the contained plot window.",      (char *)"",      (char *)"    set term x11 window \"220001e\"",      (char *)"", 
        (char *)" The x11 terminal supports enhanced text mode (see `enhanced`), subject",      (char *)" to the available fonts. In order for font size commands embedded in text",      (char *)" to have any effect, the default x11 font must be scalable. Thus the first",      (char *)" example below will work as expected, but the second will not.", 
        (char *)"",      (char *)"    set term x11 enhanced font \"arial,15\" ",      (char *)"    set title \'{/=20 Big} Medium {/=5 Small}\' ",      (char *)"", 
        (char *)"    set term x11 enhanced font \"terminal-14\" ",      (char *)"    set title \'{/=20 Big} Medium {/=5 Small}\' ",      (char *)"",      (char *)" Plot windows remain open even when the `gnuplot` driver is changed to a", 
        (char *)" different device.  A plot window can be closed by pressing the letter q",      (char *)" while that window has input focus, or by choosing `close` from a window",      (char *)" manager menu.  All plot windows can be closed by specifying `reset`, which",      (char *)" actually terminates the subprocess which maintains the windows (unless", 
        (char *)" `-persist` was specified).  The `close` command can be used to close",      (char *)" individual plot windows by number.  However, after a `reset`, those plot",      (char *)" windows left due to persist cannot be closed with the command `close`.",      (char *)" A `close` without a number closes the current active plot window.", 
        (char *)"",      (char *)" The gnuplot outboard driver, gnuplot_x11, is searched in a default place",      (char *)" chosen when the program is compiled.  You can override that by defining",      (char *)" the environment variable GNUPLOT_DRIVER_DIR to point to a different", 
        (char *)" location.",      (char *)"",      (char *)" Plot windows will automatically be closed at the end of the session",      (char *)" unless the `-persist` option was given.", 
        (char *)"",      (char *)" The options `persist` and `raise` are unset by default, which means that",      (char *)" the defaults (persist == no and raise == yes) or the command line options",      (char *)" -persist / -raise or the Xresources are taken.  If [no]persist or", 
        (char *)" [no]raise are specified, they will override command line options and",      (char *)" Xresources.  Setting one of these options takes place immediately, so",      (char *)" the behaviour of an already running driver can be modified.  If the window",      (char *)" does not get raised, see discussion in `raise`.", 
        (char *)"",      (char *)" The option `title \"<title name>\"` will supply the title name of the window",      (char *)" for the current plot window or plot window <n> if a number is given.",      (char *)" Where (or if) this title is shown depends on your X window manager.", 
        (char *)"",      (char *)" The size option can be used to set the size of the plot window.  The",      (char *)" size option will only apply to newly created windows.",      (char *)"", 
        (char *)" The position option can be used to set the position of the plot window.  The",      (char *)" position option will only apply to newly created windows.",      (char *)"",      (char *)" The size or aspect ratio of a plot may be changed by resizing the `gnuplot`", 
        (char *)" window.",      (char *)"",      (char *)" Linewidths and pointsizes may be changed from within `gnuplot` with",      (char *)" `set linestyle`.", 
        (char *)"",      (char *)" For terminal type `x11`, `gnuplot` accepts (when initialized) the standard",      (char *)" X Toolkit options and resources such as geometry, font, and name from the",      (char *)" command line arguments or a configuration file.  See the X(1) man page", 
        (char *)" (or its equivalent) for a description of such options.",      (char *)"",      (char *)"=X resources",      (char *)" A number of other `gnuplot` options are available for the `x11` terminal.", 
        (char *)" These may be specified either as command-line options when `gnuplot` is",      (char *)" invoked or as resources in the configuration file \".Xdefaults\".  They are",      (char *)" set upon initialization and cannot be altered during a `gnuplot` session.",      (char *)" (except `persist` and `raise`)", 
        (char *)"2 x11_fonts",      (char *)"?commands set terminal x11 x11_fonts",      (char *)"?set terminal x11 x11_fonts",      (char *)"?set term x11 x11_fonts", 
        (char *)"?x11 x11_fonts",      (char *)"?x11_fonts",      (char *)"=fonts",      (char *)" Upon initial startup, the default font is taken from the X11 resources", 
        (char *)" as set in the system or user .Xdefaults file or on the command line.",      (char *)"",      (char *)" Example:",      (char *)"       gnuplot*font: lucidasans-bold-12", 
        (char *)" A new default font may be specified to the x11 driver from inside",      (char *)" gnuplot using",      (char *)"      `set term x11 font \"<fontspec>\"`",      (char *)" The driver first queries the X-server for a font of the exact name given.", 
        (char *)" If this query fails, then it tries to interpret <fontspec> as",      (char *)" \"<font>,<size>,<slant>,<weight>\" and to construct a full X11 font name",      (char *)" of the form",      (char *)"       -*-<font>-<weight>-<s>-*-*-<size>-*-*-*-*-*-<encoding>", 
        (char *)"",      (char *)"  <font> is the base name of the font (e.g. Times or Symbol)",      (char *)"  <size> is the point size (defaults to 12 if not specified)",      (char *)"  <s> is `i` if <slant>==\"italic\" `o` if <slant>==\"oblique\" `r` otherwise", 
        (char *)"  <weight> is `medium` or `bold` if explicitly requested, otherwise `*`",      (char *)"  <encoding> is set based on the current character set (see `set encoding`).",      (char *)" So `set term x11 font \"arial,15,italic\"` will be translated to",      (char *)" -*-arial-*-i-*-*-15-*-*-*-*-*-iso8859-1 (assuming default encoding).", 
        (char *)" The <size>, <slant>, and <weight> specifications are all optional.",      (char *)" If you do not specify <slant> or <weight> then you will get whatever font ",      (char *)" variant the font server offers first.",      (char *)" You may set a default enconding via the corresponding X11 resource. E.g.", 
        (char *)"       gnuplot*encoding: iso8859-15",      (char *)" The driver also recognizes some common PostScript font names and",      (char *)" replaces them with possible X11 or TrueType equivalents.",      (char *)" This same sequence is used to process font requests from `set label`.", 
        (char *)"",      (char *)" If your gnuplot was built with configuration option --enable-x11-mbfonts,",      (char *)" you can specify multi-byte fonts by using the prefix \"mbfont:\" on the font",      (char *)" name. An additional font may be given, separated by a semicolon.", 
        (char *)" Since multi-byte font encodings are interpreted according to the locale",      (char *)" setting, you must make sure that the environmental variable LC_CTYPE is set",      (char *)" to some appropriate locale value such as ja_JP.eucJP, ko_KR.EUC, or zh_CN.EUC.",      (char *)"", 
        (char *)" Example:",      (char *)"       set term x11 font \'mbfont:kana14;k14\'",      (char *)"             # \'kana14\' and \'k14\' are Japanese X11 font aliases, and \';\'",      (char *)"             # is the separator of font names.", 
        (char *)"       set term x11 font \'mbfont:fixed,16,r,medium\'",      (char *)"             # <font>,<size>,<slant>,<weight> form is also usable.",      (char *)"       set title \'(mb strings)\' font \'mbfont:*-fixed-medium-r-normal--14-*\'",      (char *)"", 
        (char *)" The same syntax applies to the default font in Xresources settings,",      (char *)" for example,",      (char *)"       gnuplot*font: \\",      (char *)"           mbfont:-misc-fixed-medium-r-normal--14-*-*-*-c-*-jisx0208.1983-0", 
        (char *)"",      (char *)" If gnuplot is built with --enable-x11-mbfonts, you can use two special",      (char *)" PostScript font names \'Ryumin-Light-*\' and \'GothicBBB-Medium-*\' (standard",      (char *)" Japanese PS fonts) without the prefix \"mbfont:\".", 
        (char *)"",      (char *)"2 command-line_options",      (char *)"?commands set terminal x11 command-line-options",      (char *)"?set terminal x11 command-line-options", 
        (char *)"?set term x11 command-line-options",      (char *)"?x11 command-line-options",      (char *)"?command-line-options",      (char *)" In addition to the X Toolkit options, the following options may be specified", 
        (char *)" on the command line when starting `gnuplot` or as resources in your",      (char *)" \".Xdefaults\" file (note that `raise` and `persist` can be overridden",      (char *)" later by `set term x11 [no]raise [no]persist)`:",      (char *)"@start table - first is interactive cleartext form", 
        (char *)"  `-mono`     forces monochrome rendering on color displays.",      (char *)"  `-gray`     requests grayscale rendering on grayscale or color displays.",      (char *)"              (Grayscale displays receive monochrome rendering by default.)",      (char *)"  `-clear`    requests that the window be cleared momentarily before a", 
        (char *)"              new plot is displayed.",      (char *)"  `-tvtwm`    requests that geometry specifications for position of the",      (char *)"              window be made relative to the currently displayed portion",      (char *)"              of the virtual root.", 
        (char *)"  `-raise`    raises plot window after each plot",      (char *)"  `-noraise`  does not raise plot window after each plot",      (char *)"  `-noevents` does not process mouse and key events",      (char *)"  `-ctrlq   ` closes window on ctrl-q rather than q", 
        (char *)"  `-persist`  plot windows survive after main gnuplot program exits",      (char *)"#\\begin{tabular}{|cl|} \\hline",      (char *)"#`-mono`     & forces monochrome rendering on color displays.\\\\",      (char *)"#`-gray`     & requests grayscale rendering on grayscale or color displays.\\\\", 
        (char *)"#            & (Grayscale displays receive monochrome rendering by default.) \\\\",      (char *)"#`-clear`    & requests that the window be cleared momentarily before a\\\\",      (char *)"#            & new plot is displayed. \\\\",      (char *)"#`-tvtwm`    & requests that geometry specifications for position of the\\\\", 
        (char *)"#            & window be made relative to the currently displayed portion\\\\",      (char *)"#            & of the virtual root. \\\\",      (char *)"#`-raise`    & raises plot window after each plot. \\\\",      (char *)"#`-noraise`  & does not raise plot window after each plot. \\\\", 
        (char *)"#`-noevents` & does not process mouse and key events. \\\\",      (char *)"#`-persist`  & plot windows survive after main gnuplot program exits. \\\\",      (char *)"%c l .",      (char *)"%`-mono`@forces monochrome rendering on color displays.", 
        (char *)"%`-gray`@requests grayscale rendering on grayscale or color displays.",      (char *)"%       @(Grayscale displays receive monochrome rendering by default.)",      (char *)"%`-clear`@requests that the window be cleared momentarily before a",      (char *)"%        @new plot is displayed.", 
        (char *)"%`-tvtwm`@requests that geometry specifications for position of the",      (char *)"%        @window be made relative to the currently displayed portion",      (char *)"%        @of the virtual root.",      (char *)"%`-raise`@raises plot window after each plot", 
        (char *)"%`-noraise`@does not raise plot window after each plot",      (char *)"%`-novevents`@does not process mouse and key events",      (char *)"%`-ctrlq`@closes window on ctrl-q rather than q",      (char *)"%`-persist`@plot windows survive after main gnuplot program exits", 
        (char *)"@end table",      (char *)"=X resources",      (char *)" The options are shown above in their command-line syntax.  When entered as",      (char *)" resources in \".Xdefaults\", they require a different syntax.", 
        (char *)"",      (char *)" Example:",      (char *)"       gnuplot*gray:  on",      (char *)"       gnuplot*ctrlq: on", 
        (char *)"",      (char *)" `gnuplot` also provides a command line option (`-pointsize <v>`) and a",      (char *)" resource, `gnuplot*pointsize: <v>`, to control the size of points plotted",      (char *)" with the `points` plotting style.  The value `v` is a real number (greater", 
        (char *)" than 0 and less than or equal to ten) used as a scaling factor for point",      (char *)" sizes.  For example, `-pointsize 2` uses points twice the default size, and",      (char *)" `-pointsize 0.5` uses points half the normal size.",      (char *)"", 
        (char *)" The `-noevents` switch disables all mouse and key event processing (except",      (char *)" for `q` and `<space>` for closing the window). This is useful for programs",      (char *)" which use the x11 driver independent of the gnuplot main program.",      (char *)"", 
        (char *)" The `-ctrlq` switch changes the hot-key that closes a plot window from `q`",      (char *)" to `<ctrl>q`. This is useful is you are using the keystroke-capture feature",      (char *)" `pause mouse keystroke`, since it allows the character `q` to be captured",      (char *)" just as all other alphanumeric characters. The `-ctrlq` switch similarly", 
        (char *)" replaces the <space> hot-key with <ctrl><space> for the same reason.",      (char *)"",      (char *)"2 monochrome_options",      (char *)"?commands set terminal x11 monochrome_options", 
        (char *)"?set terminal x11 monochrome_options",      (char *)"?set term x11 monochrome_options",      (char *)"?x11 monochrome_options",      (char *)"?monochrome_options", 
        (char *)"=X resources",      (char *)" For monochrome displays, `gnuplot` does not honor foreground or background",      (char *)" colors.  The default is black-on-white.  `-rv` or `gnuplot*reverseVideo: on`",      (char *)" requests white-on-black.", 
        (char *)"",      (char *)"2 color_resources",      (char *)"?commands set terminal x11 color_resources",      (char *)"?set terminal x11 color_resources", 
        (char *)"?set term x11 color_resources",      (char *)"?x11 color_resources",      (char *)"?color_resources",      (char *)"=X resources", 
        (char *)" The X11 terminal honors the following resources (shown here with their",      (char *)" default values) or the greyscale resources.  The values may be color names",      (char *)" as listed in the X11 rgb.txt file on your system, hexadecimal RGB color",      (char *)" specifications (see X11 documentation), or a color name followed by a comma", 
        (char *)" and an `intensity` value from 0 to 1.  For example, `blue, 0.5` means a half",      (char *)" intensity blue.",      (char *)"@start table - first is interactive cleartext form",      (char *)"  gnuplot*background:  white", 
        (char *)"  gnuplot*textColor:   black",      (char *)"  gnuplot*borderColor: black",      (char *)"  gnuplot*axisColor:   black",      (char *)"  gnuplot*line1Color:  red", 
        (char *)"  gnuplot*line2Color:  green",      (char *)"  gnuplot*line3Color:  blue",      (char *)"  gnuplot*line4Color:  magenta",      (char *)"  gnuplot*line5Color:  cyan", 
        (char *)"  gnuplot*line6Color:  sienna",      (char *)"  gnuplot*line7Color:  orange",      (char *)"  gnuplot*line8Color:  coral",      (char *)"#\\begin{tabular}{|cl|} \\hline", 
        (char *)"#&gnuplot*background: white\\\\",      (char *)"#&gnuplot*textColor: black\\\\",      (char *)"#&gnuplot*borderColor: black\\\\",      (char *)"#&gnuplot*axisColor: black\\\\", 
        (char *)"#&gnuplot*line1Color: red\\\\",      (char *)"#&gnuplot*line2Color: green\\\\",      (char *)"#&gnuplot*line3Color: blue\\\\",      (char *)"#&gnuplot*line4Color: magenta\\\\", 
        (char *)"#&gnuplot*line5Color: cyan\\\\",      (char *)"#&gnuplot*line6Color: sienna\\\\",      (char *)"#&gnuplot*line7Color: orange\\\\",      (char *)"#&gnuplot*line8Color: coral\\\\", 
        (char *)"%c l .",      (char *)"%@gnuplot*background: white",      (char *)"%@gnuplot*textColor: black",      (char *)"%@gnuplot*borderColor: black", 
        (char *)"%@gnuplot*axisColor: black",      (char *)"%@gnuplot*line1Color: red",      (char *)"%@gnuplot*line2Color: green",      (char *)"%@gnuplot*line3Color: blue", 
        (char *)"%@gnuplot*line4Color: magenta",      (char *)"%@gnuplot*line5Color: cyan",      (char *)"%@gnuplot*line6Color: sienna",      (char *)"%@gnuplot*line7Color: orange", 
        (char *)"%@gnuplot*line8Color: coral",      (char *)"@end table",      (char *)"",      (char *)" The command-line syntax for these is simple only for background,", 
        (char *)" which maps directly to the usual X11 toolkit option \"-bg\".  All",      (char *)" others can only be set on the command line by use of the generic",      (char *)" \"-xrm\" resource override option",      (char *)"", 
        (char *)" Examples:",      (char *)"",      (char *)"       gnuplot -background coral",      (char *)" to change the background color.", 
        (char *)"",      (char *)"       gnuplot -xrm \'gnuplot*line1Color:blue\'",      (char *)" to override the first linetype color.",      (char *)"", 
        (char *)"2 grayscale_resources",      (char *)"?commands set terminal x11 grayscale_resources",      (char *)"?set terminal x11 grayscale_resources",      (char *)"?set term x11 grayscale_resources", 
        (char *)"?x11 grayscale_resources",      (char *)"?grayscale_resources",      (char *)"=X resources",      (char *)" When `-gray` is selected, `gnuplot` honors the following resources for", 
        (char *)" grayscale or color displays (shown here with their default values).  Note",      (char *)" that the default background is black.",      (char *)"@start table - first is interactive cleartext form",      (char *)"  gnuplot*background: black", 
        (char *)"  gnuplot*textGray:   white",      (char *)"  gnuplot*borderGray: gray50",      (char *)"  gnuplot*axisGray:   gray50",      (char *)"  gnuplot*line1Gray:  gray100", 
        (char *)"  gnuplot*line2Gray:  gray60",      (char *)"  gnuplot*line3Gray:  gray80",      (char *)"  gnuplot*line4Gray:  gray40",      (char *)"  gnuplot*line5Gray:  gray90", 
        (char *)"  gnuplot*line6Gray:  gray50",      (char *)"  gnuplot*line7Gray:  gray70",      (char *)"  gnuplot*line8Gray:  gray30",      (char *)"#\\begin{tabular}{|cl|} \\hline", 
        (char *)"#&gnuplot*background: black\\\\",      (char *)"#&gnuplot*textGray: white\\\\",      (char *)"#&gnuplot*borderGray: gray50\\\\",      (char *)"#&gnuplot*axisGray: gray50\\\\", 
        (char *)"#&gnuplot*line1Gray: gray100\\\\",      (char *)"#&gnuplot*line2Gray: gray60\\\\",      (char *)"#&gnuplot*line3Gray: gray80\\\\",      (char *)"#&gnuplot*line4Gray: gray40\\\\", 
        (char *)"#&gnuplot*line5Gray: gray90\\\\",      (char *)"#&gnuplot*line6Gray: gray50\\\\",      (char *)"#&gnuplot*line7Gray: gray70\\\\",      (char *)"#&gnuplot*line8Gray: gray30\\\\", 
        (char *)"%c l .",      (char *)"%@gnuplot*background: black",      (char *)"%@gnuplot*textGray: white",      (char *)"%@gnuplot*borderGray: gray50", 
        (char *)"%@gnuplot*axisGray: gray50",      (char *)"%@gnuplot*line1Gray: gray100",      (char *)"%@gnuplot*line2Gray: gray60",      (char *)"%@gnuplot*line3Gray: gray80", 
        (char *)"%@gnuplot*line4Gray: gray40",      (char *)"%@gnuplot*line5Gray: gray90",      (char *)"%@gnuplot*line6Gray: gray50",      (char *)"%@gnuplot*line7Gray: gray70", 
        (char *)"%@gnuplot*line8Gray: gray30",      (char *)"@end table",      (char *)"",      (char *)"2 line_resources", 
        (char *)"?commands set terminal x11 line_resources",      (char *)"?set terminal x11 line_resources",      (char *)"?set term x11 line_resources",      (char *)"?x11 line_resources", 
        (char *)"?line_resources",      (char *)"=X resources",      (char *)" `gnuplot` honors the following resources for setting the width (in pixels) of",      (char *)" plot lines (shown here with their default values.)  0 or 1 means a minimal", 
        (char *)" width line of 1 pixel width.  A value of 2 or 3 may improve the appearance of",      (char *)" some plots.",      (char *)"@start table - first is interactive cleartext form",      (char *)"  gnuplot*borderWidth: 2", 
        (char *)"  gnuplot*axisWidth:   0",      (char *)"  gnuplot*line1Width:  0",      (char *)"  gnuplot*line2Width:  0",      (char *)"  gnuplot*line3Width:  0", 
        (char *)"  gnuplot*line4Width:  0",      (char *)"  gnuplot*line5Width:  0",      (char *)"  gnuplot*line6Width:  0",      (char *)"  gnuplot*line7Width:  0", 
        (char *)"  gnuplot*line8Width:  0",      (char *)"#\\begin{tabular}{|cl|} \\hline",      (char *)"#&gnuplot*borderWidth: 2\\\\",      (char *)"#&gnuplot*axisWidth: 0\\\\", 
        (char *)"#&gnuplot*line1Width: 0\\\\",      (char *)"#&gnuplot*line2Width: 0\\\\",      (char *)"#&gnuplot*line3Width: 0\\\\",      (char *)"#&gnuplot*line4Width: 0\\\\", 
        (char *)"#&gnuplot*line5Width: 0\\\\",      (char *)"#&gnuplot*line6Width: 0\\\\",      (char *)"#&gnuplot*line7Width: 0\\\\",      (char *)"#&gnuplot*line8Width: 0\\\\", 
        (char *)"%c l .",      (char *)"%@gnuplot*borderWidth: 2",      (char *)"%@gnuplot*axisWidth: 0",      (char *)"%@gnuplot*line1Width: 0", 
        (char *)"%@gnuplot*line2Width: 0",      (char *)"%@gnuplot*line3Width: 0",      (char *)"%@gnuplot*line4Width: 0",      (char *)"%@gnuplot*line5Width: 0", 
        (char *)"%@gnuplot*line6Width: 0",      (char *)"%@gnuplot*line7Width: 0",      (char *)"%@gnuplot*line8Width: 0",      (char *)"@end table", 
        (char *)"",      (char *)" `gnuplot` honors the following resources for setting the dash style used for",      (char *)" plotting lines.  0 means a solid line.  A two-digit number `jk` (`j` and `k`",      (char *)" are >= 1 and <= 9) means a dashed line with a repeated pattern of `j` pixels", 
        (char *)" on followed by `k` pixels off.  For example, \'16\' is a dotted line with one",      (char *)" pixel on followed by six pixels off.  More elaborate on/off patterns can be",      (char *)" specified with a four-digit value.  For example, \'4441\' is four on, four off,",      (char *)" four on, one off.  The default values shown below are for monochrome displays", 
        (char *)" or monochrome rendering on color or grayscale displays.",      (char *)" Color displays default to dashed:off ",      (char *)"@start table - first is interactive cleartext form",      (char *)"  gnuplot*dashed:       off", 
        (char *)"  gnuplot*borderDashes:   0",      (char *)"  gnuplot*axisDashes:    16",      (char *)"  gnuplot*line1Dashes:    0",      (char *)"  gnuplot*line2Dashes:   42", 
        (char *)"  gnuplot*line3Dashes:   13",      (char *)"  gnuplot*line4Dashes:   44",      (char *)"  gnuplot*line5Dashes:   15",      (char *)"  gnuplot*line6Dashes: 4441", 
        (char *)"  gnuplot*line7Dashes:   42",      (char *)"  gnuplot*line8Dashes:   13",      (char *)"#\\begin{tabular}{|cl|} \\hline",      (char *)"#&gnuplot*dashed: off\\\\", 
        (char *)"#&gnuplot*borderDashes: 0\\\\",      (char *)"#&gnuplot*axisDashes: 16\\\\",      (char *)"#&gnuplot*line1Dashes: 0\\\\",      (char *)"#&gnuplot*line2Dashes: 42\\\\", 
        (char *)"#&gnuplot*line3Dashes: 13\\\\",      (char *)"#&gnuplot*line4Dashes: 44\\\\",      (char *)"#&gnuplot*line5Dashes: 15\\\\",      (char *)"#&gnuplot*line6Dashes: 4441\\\\", 
        (char *)"#&gnuplot*line7Dashes: 42\\\\",      (char *)"#&gnuplot*line8Dashes: 13\\\\",      (char *)"%c l .",      (char *)"%@gnuplot*dashed: off", 
        (char *)"%@gnuplot*borderDashes: 0",      (char *)"%@gnuplot*axisDashes: 16",      (char *)"%@gnuplot*line1Dashes: 0",      (char *)"%@gnuplot*line2Dashes: 42", 
        (char *)"%@gnuplot*line3Dashes: 13",      (char *)"%@gnuplot*line4Dashes: 44",      (char *)"%@gnuplot*line5Dashes: 15",      (char *)"%@gnuplot*line6Dashes: 4441", 
        (char *)"%@gnuplot*line7Dashes: 42",      (char *)"%@gnuplot*line8Dashes: 13",      (char *)"@end table",      (char *)"", 
        (char *)"2 x11 pm3d_resources",      (char *)"?commands set terminal x11 pm3d_resources",      (char *)"?set terminal x11 pm3d_resources",      (char *)"?set term x11 pm3d_resources", 
        (char *)"?x11 pm3d_resources",      (char *)"?pm3d_resources",      (char *)"?x11 pm3d",      (char *)"=X resources", 
        (char *)" Choosing the appropriate visual class and number of colors is a crucial",      (char *)" point in X11 applications and a bit awkward, since X11 supports six visual",      (char *)" types in different depths.",      (char *)"", 
        (char *)" By default `gnuplot` uses the default visual of the screen. The number of",      (char *)" colors which can be allocated depends on the visual class chosen. On a",      (char *)" visual class with a depth > 12bit, gnuplot starts with a maximal number",      (char *)" of 0x200 colors.  On a visual class with a depth > 8bit (but <= 12 bit)", 
        (char *)" the maximal number of colors is 0x100, on <= 8bit displays the maximum",      (char *)" number of colors is 240 (16 are left for line colors).",      (char *)"",      (char *)" Gnuplot first starts to allocate the maximal number of colors as stated", 
        (char *)" above.  If this fails, the number of colors is reduced by the factor 2",      (char *)" until gnuplot gets all colors which are requested. If dividing `maxcolors`",      (char *)" by 2 repeatedly results in a number which is smaller than `mincolors`",      (char *)" `gnuplot` tries to install a private colormap. In this case the window", 
        (char *)" manager is responsible for swapping colormaps when the pointer is moved",      (char *)" in and out the x11 driver\'s window.",      (char *)"",      (char *)" The default for `mincolors` is maxcolors / (num_colormaps > 1 ? 2 : 8),", 
        (char *)" where num_colormaps is the number of colormaps which are currently used",      (char *)" by gnuplot (usually 1, if only one x11 window is open).",      (char *)"",      (char *)" Some systems support multiple (different) visual classes together on one", 
        (char *)" screen. On these systems it might be necessary to force gnuplot to use a",      (char *)" specific visual class, e.g. the default visual might be 8bit PseudoColor",      (char *)" but the screen would also support 24bit TrueColor which would be the",      (char *)" preferred choice.", 
        (char *)"",      (char *)" The information about an Xserver\'s capabilities can be obtained with the",      (char *)" program `xdpyinfo`.  For the visual names below you can choose one of",      (char *)" StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor, DirectColor.", 
        (char *)" If an Xserver supports a requested visual type at different depths,",      (char *)" `gnuplot` chooses the visual class with the highest depth (deepest).",      (char *)" If the requested visual class matches the default visual and multiple",      (char *)" classes of this type are supported, the default visual is preferred.", 
        (char *)"",      (char *)" Example: on an 8bit PseudoColor visual you can force a private color map",      (char *)" by specifying `gnuplot*maxcolors: 240` and `gnuplot*mincolors: 240`.",      (char *)"", 
        (char *)"@start table - first is interactive cleartext form",      (char *)"  gnuplot*maxcolors:  <integer>",      (char *)"  gnuplot*mincolors:  <integer>",      (char *)"  gnuplot*visual:     <visual name>", 
        (char *)"#\\begin{tabular}{|cl|} \\hline",      (char *)"#&gnuplot*maxcolors:  integer\\\\",      (char *)"#&gnuplot*mincolors:  integer\\\\",      (char *)"#&gnuplot*visual:     visual name\\\\", 
        (char *)"%c l .",      (char *)"%@gnuplot*maxcolors:  <integer number>",      (char *)"%@gnuplot*mincolors:  <integer number>",      (char *)"%@gnuplot*visual:     <visual name>", 
        (char *)"@end table",      (char *)"",      (char *)"2 x11 other_resources",      (char *)"?commands set terminal x11 other_resources", 
        (char *)"?set terminal x11 other_resources",      (char *)"?set term x11 other_resources",      (char *)"?x11 other_resources",      (char *)"=X resources", 
        (char *)" By default the contents of the current plot window are exported to the X11",      (char *)" clipboard in response to X events in the window. Setting the resource",      (char *)" \'gnuplot*exportselection\' to \'off\' or \'false\' will disable this.",      (char *)"", 
        (char *)" By default text rotation is done using a method that is fast, but can",      (char *)" corrupt nearby colors depending on the background.  If this is a problem,",      (char *)" you can set the resource \'gnuplot.fastrotate\' to \'off\'",      (char *)"", 
        (char *)"@start table - other x11 resources",      (char *)"  gnuplot*exportselection:  off",      (char *)"  gnuplot*fastrotate:  on",      (char *)"  gnuplot*ctrlq:  off", 
        (char *)"#\\begin{tabular}{|cl|} \\hline",      (char *)"#&gnuplot*exportselection:  off\\\\",      (char *)"#&gnuplot*fastrotate:  on\\\\",      (char *)"#&gnuplot*ctrlq:  off\\\\", 
        (char *)"%c l .",      (char *)"%@gnuplot*exportselection:  off",      (char *)"%@gnuplot*fastrotate:  on",      (char *)"%@gnuplot*ctrlq:  off", 
        (char *)"@end table",      (char *)"C#",      (char *)"C#xlib",      (char *)"1 xlib", 
        (char *)"?commands set terminal xlib",      (char *)"?set terminal xlib",      (char *)"?set term xlib",      (char *)"?terminal xlib", 
        (char *)"?term xlib",      (char *)"?xlib",      (char *)" The `xlib` terminal driver supports the X11 Windows System.  It generates",      (char *)" gnuplot_x11 commands, but sends them to the output file specified by", 
        (char *)" `set output \'<filename>\'`. `set term x11` is equivalent to",      (char *)" `set output \"|gnuplot_x11 -noevents\"; set term xlib`.",      (char *)" `xlib` takes the same set of options as `x11`.",      (char *)"C#", 
        (char *)"C#canvas",      (char *)"1 canvas",      (char *)"?commands set terminal canvas",      (char *)"?set terminal canvas", 
        (char *)"?set term canvas",      (char *)"?terminal canvas",      (char *)"?term canvas",      (char *)"", 
        (char *)" The `canvas` terminal creates a set of javascript commands that draw onto the",      (char *)" HTML5 canvas element.",      (char *)" Syntax:",      (char *)"       set terminal canvas {size <xsize>, <ysize>} {background <rgb_color>}", 
        (char *)"                           {font {<fontname>}{,<fontsize>}} | {fsize <fontsize>}",      (char *)"                           {{no}enhanced} {linewidth <lw>}",      (char *)"                           {rounded | butt}",      (char *)"                           {solid | dashed {dashlength <dl>}}", 
        (char *)"                           {standalone {mousing} | name \'<funcname>\'}",      (char *)"                           {jsdir \'URL/for/javascripts\'}",      (char *)"                           {title \'<some string>\'}",      (char *)"", 
        (char *)" where <xsize> and <ysize> set the size of the plot area in pixels.",      (char *)" The default size in standalone mode is 600 by 400 pixels.",      (char *)" The default font size is 10.",      (char *)"", 
        (char *)" NB: Only one font is available, the ascii portion of Hershey simplex Roman",      (char *)" provided in the file canvastext.js. You can replace this with the file",      (char *)" canvasmath.js, which contains also UTF-8 encoded Hershey simplex Greek and",      (char *)" math symbols. For consistency with other terminals, it is also possible to", 
        (char *)" use `font \"name,size\"`. Currently the font `name` is ignored, but browser",      (char *)" support for named fonts is likely to arrive eventually.",      (char *)"",      (char *)" The default `standalone` mode creates an html page containing javascript", 
        (char *)" code that renders the plot using the HTML 5 canvas element.  The html page",      (char *)" links to two required javascript files \'canvastext.js\' and \'gnuplot_common.js\'.",      (char *)" An additional file \'gnuplot_dashedlines.js\' is needed to support dashed lines.",      (char *)" By default these point to local files, on unix-like systems usually in", 
        (char *)" directory /usr/local/share/gnuplot/<version>/js.  See installation notes for",      (char *)" other platforms. You can change this by using the `jsdir` option to specify",      (char *)" either a different local directory or a general URL.  The latter is usually",      (char *)" appropriate if the plot is exported for viewing on remote client machines.", 
        (char *)"",      (char *)" All plots produced by the canvas terminal are mouseable.  The additional",      (char *)" keyword `mousing` causes the `standalone` mode to add a mouse-tracking box",      (char *)" underneath the plot. It also adds a link to a javascript file", 
        (char *)" \'gnuplot_mouse.js\' and to a stylesheet for the mouse box \'gnuplot_mouse.css\'",      (char *)" in the same local or URL directory as \'canvastext.js\'.",      (char *)"",      (char *)" The `name` option creates a file containing only javascript. Both the", 
        (char *)" javascript function it contains and the id of the canvas element that it",      (char *)" draws onto are taken from the following string parameter.  The commands",      (char *)"       set term canvas name \'fishplot\'",      (char *)"       set output \'fishplot.js\'", 
        (char *)" will create a file containing a javascript function fishplot() that will",      (char *)" draw onto a canvas with id=fishplot.  An html page that invokes this",      (char *)" javascript function must also load the canvastext.js function as described",      (char *)" above.  A minimal html file to wrap the fishplot created above might be:", 
        (char *)"",      (char *)"       <html>",      (char *)"       <head>",      (char *)"           <script src=\"canvastext.js\"></script>", 
        (char *)"           <script src=\"gnuplot_common.js\"></script>",      (char *)"       </head>",      (char *)"       <body onload=\"fishplot();\">",      (char *)"           <script src=\"fishplot.js\"></script>", 
        (char *)"           <canvas id=\"fishplot\" width=600 height=400>",      (char *)"               <div id=\"err_msg\">No support for HTML 5 canvas element</div>",      (char *)"           </canvas>",      (char *)"       </body>", 
        (char *)"       </html>",      (char *)"",      (char *)" The individual plots drawn on this canvas will have names fishplot_plot_1,",      (char *)" fishplot_plot_2, and so on. These can be referenced by external javascript", 
        (char *)" routines, for example gnuplot.toggle_visibility(\"fishplot_plot_2\").",      (char *)"",      (char *)"C#",      (char *)"C#cgm", 
        (char *)"1 cgm",      (char *)"?commands set terminal cgm",      (char *)"?set terminal cgm",      (char *)"?set term cgm", 
        (char *)"?terminal cgm",      (char *)"?term cgm",      (char *)"?cgm",      (char *)" The `cgm` terminal generates a Computer Graphics Metafile, Version 1. ", 
        (char *)" This file format is a subset of the ANSI X3.122-1986 standard entitled",      (char *)" \"Computer Graphics - Metafile for the Storage and Transfer of Picture",      (char *)" Description Information\".",      (char *)"", 
        (char *)" Syntax:",      (char *)"       set terminal cgm {color | monochrome} {solid | dashed} {{no}rotate}",      (char *)"                        {<mode>} {width <plot_width>} {linewidth <line_width>}",      (char *)"                        {font \"<fontname>,<fontsize>\"}", 
        (char *)"                        {background <rgb_color>}",      (char *)"   [deprecated]         {<color0> <color1> <color2> ...}",      (char *)"",      (char *)" `solid` draws all curves with solid lines, overriding any dashed patterns;", 
        (char *)" <mode> is `landscape`, `portrait`, or `default`;",      (char *)" <plot_width> is the assumed width of the plot in points; ",      (char *)" <line_width> is the line width in points (default 1); ",      (char *)" <fontname> is the name of a font (see list of fonts below)", 
        (char *)" <fontsize> is the size of the font in points (default 12).",      (char *)"",      (char *)" The first six options can be in any order.  Selecting `default` sets all",      (char *)" options to their default values.", 
        (char *)"",      (char *)" The mechanism of setting line colors in the `set term` command is",      (char *)" deprecated.  Instead you should set the background using a separate",      (char *)" keyword and set the line colors using `set linetype`.", 
        (char *)" The deprecated mechanism accepted colors of the form \'xrrggbb\', where x is",      (char *)" the literal character \'x\' and \'rrggbb\' are the red, green and blue components",      (char *)" in hex. The first color was used for the background, subsequent colors are",      (char *)" assigned to successive line types.", 
        (char *)"",      (char *)" Examples:",      (char *)"       set terminal cgm landscape color rotate dashed width 432 \\",      (char *)"                      linewidth 1  \'Helvetica Bold\' 12       # defaults", 
        (char *)"       set terminal cgm linewidth 2  14  # wider lines & larger font",      (char *)"       set terminal cgm portrait \"Times Italic\" 12",      (char *)"       set terminal cgm color solid      # no pesky dashes!",      (char *)"2 cgm font", 
        (char *)"?commands set terminal cgm font",      (char *)"?set terminal cgm font",      (char *)"?set term cgm font",      (char *)"?cgm font", 
        (char *)" The first part of a Computer Graphics Metafile, the metafile description,",      (char *)" includes a font table.  In the picture body, a font is designated by an",      (char *)" index into this table.  By default, this terminal generates a table with",      (char *)" the following 35 fonts, plus six more with `italic` replaced by", 
        (char *)" `oblique`, or vice-versa (since at least the Microsoft Office and Corel",      (char *)" Draw CGM import filters treat `italic` and `oblique` as equivalent):",      (char *)"@start table - first is interactive cleartext form",      (char *)"       Helvetica", 
        (char *)"       Helvetica Bold",      (char *)"       Helvetica Oblique",      (char *)"       Helvetica Bold Oblique",      (char *)"       Times Roman", 
        (char *)"       Times Bold",      (char *)"       Times Italic",      (char *)"       Times Bold Italic",      (char *)"       Courier", 
        (char *)"       Courier Bold",      (char *)"       Courier Oblique",      (char *)"       Courier Bold Oblique",      (char *)"       Symbol", 
        (char *)"       Hershey/Cartographic_Roman",      (char *)"       Hershey/Cartographic_Greek",      (char *)"       Hershey/Simplex_Roman",      (char *)"       Hershey/Simplex_Greek", 
        (char *)"       Hershey/Simplex_Script",      (char *)"       Hershey/Complex_Roman",      (char *)"       Hershey/Complex_Greek",      (char *)"       Hershey/Complex_Script", 
        (char *)"       Hershey/Complex_Italic",      (char *)"       Hershey/Complex_Cyrillic",      (char *)"       Hershey/Duplex_Roman",      (char *)"       Hershey/Triplex_Roman", 
        (char *)"       Hershey/Triplex_Italic",      (char *)"       Hershey/Gothic_German",      (char *)"       Hershey/Gothic_English",      (char *)"       Hershey/Gothic_Italian", 
        (char *)"       Hershey/Symbol_Set_1",      (char *)"       Hershey/Symbol_Set_2",      (char *)"       Hershey/Symbol_Math",      (char *)"       ZapfDingbats", 
        (char *)"       Script",      (char *)"       15",      (char *)"#\\begin{tabular}{|lll|} \\hline",      (char *)"#\\multicolumn{3}{|c|}{CGM fonts}\\\\\\hline", 
        (char *)"#&Helvetica&Hershey/Cartographic\\_Roman\\\\",      (char *)"#&Helvetica Bold&Hershey/Cartographic\\_Greek\\\\",      (char *)"#&Helvetica Oblique&Hershey/Simplex\\_Roman\\\\",      (char *)"#&Helvetica Bold Oblique&Hershey/Simplex\\_Greek\\\\", 
        (char *)"#&Times Roman&Hershey/Simplex\\_Script\\\\",      (char *)"#&Times Bold&Hershey/Complex\\_Roman\\\\",      (char *)"#&Times Italic&Hershey/Complex\\_Greek\\\\",      (char *)"#&Times Bold Italic&Hershey/Complex\\_Italic\\\\", 
        (char *)"#&Courier&Hershey/Complex\\_Cyrillic\\\\",      (char *)"#&Courier Bold&Hershey/Duplex\\_Roman\\\\",      (char *)"#&Courier Oblique&Hershey/Triplex\\_Roman\\\\",      (char *)"#&Courier Bold Oblique&Hershey/Triplex\\_Italic\\\\", 
        (char *)"#&Symbol&Hershey/Gothic\\_German\\\\",      (char *)"#&ZapfDingbats&Hershey/Gothic\\_English\\\\",      (char *)"#&Script&Hershey/Gothic\\_Italian\\\\",      (char *)"#&15&Hershey/Symbol\\_Set\\_1\\\\", 
        (char *)"#&&Hershey/Symbol\\_Set\\_2\\\\",      (char *)"#&&Hershey/Symbol\\_Math\\\\",      (char *)"%c c l .",      (char *)"%@@CGM fonts", 
        (char *)"%_",      (char *)"%@@Helvetica",      (char *)"%@@Helvetica Bold",      (char *)"%@@Helvetica Oblique", 
        (char *)"%@@Helvetica Bold Oblique",      (char *)"%@@Times Roman",      (char *)"%@@Times Bold",      (char *)"%@@Times Italic", 
        (char *)"%@@Times Bold Italic",      (char *)"%@@Courier",      (char *)"%@@Courier Bold",      (char *)"%@@Courier Oblique", 
        (char *)"%@@Courier Bold Oblique",      (char *)"%@@Symbol",      (char *)"%@@Hershey/Cartographic_Roman",      (char *)"%@@Hershey/Cartographic_Greek", 
        (char *)"%@@Hershey/Simplex_Roman",      (char *)"%@@Hershey/Simplex_Greek",      (char *)"%@@Hershey/Simplex_Script",      (char *)"%@@Hershey/Complex_Roman", 
        (char *)"%@@Hershey/Complex_Greek",      (char *)"%@@Hershey/Complex_Script",      (char *)"%@@Hershey/Complex_Italic",      (char *)"%@@Hershey/Complex_Cyrillic", 
        (char *)"%@@Hershey/Duplex_Roman",      (char *)"%@@Hershey/Triplex_Roman",      (char *)"%@@Hershey/Triplex_Italic",      (char *)"%@@Hershey/Gothic_German", 
        (char *)"%@@Hershey/Gothic_English",      (char *)"%@@Hershey/Gothic_Italian",      (char *)"%@@Hershey/Symbol_Set_1",      (char *)"%@@Hershey/Symbol_Set_2", 
        (char *)"%@@Hershey/Symbol_Math",      (char *)"%@@ZapfDingbats",      (char *)"%@@Script",      (char *)"%@@15", 
        (char *)"@end table",      (char *)" The first thirteen of these fonts are required for WebCGM.  The",      (char *)" Microsoft Office CGM import filter implements the 13 standard fonts",      (char *)" listed above, and also \'ZapfDingbats\' and \'Script\'.  However, the", 
        (char *)" script font may only be accessed under the name \'15\'.  For more on",      (char *)" Microsoft import filter font substitutions, check its help file which",      (char *)" you may find here:",      (char *)"   C:\\Program Files\\Microsoft Office\\Office\\Cgmimp32.hlp", 
        (char *)" and/or its configuration file, which you may find here:",      (char *)"   C:\\Program Files\\Common Files\\Microsoft Shared\\Grphflt\\Cgmimp32.cfg",      (char *)"",      (char *)" In the `set term` command, you may specify a font name which does not", 
        (char *)" appear in the default font table.  In that case, a new font table is",      (char *)" constructed with the specified font as its first entry. You must ensure",      (char *)" that the spelling, capitalization, and spacing of the name are",      (char *)" appropriate for the application that will read the CGM file.  (Gnuplot", 
        (char *)" and any MIL-D-28003A compliant application ignore case in font names.)",      (char *)" If you need to add several new fonts, use several `set term` commands.",      (char *)"",      (char *)" Example:", 
        (char *)"       set terminal cgm \'Old English\'",      (char *)"       set terminal cgm \'Tengwar\'",      (char *)"       set terminal cgm \'Arabic\'",      (char *)"       set output \'myfile.cgm\'", 
        (char *)"       plot ...",      (char *)"       set output",      (char *)"",      (char *)" You cannot introduce a new font in a `set label` command.", 
        (char *)"2 cgm fontsize",      (char *)"?commands set terminal cgm fontsize",      (char *)"?set terminal cgm fontsize",      (char *)"?set term cgm fontsize", 
        (char *)"?cgm fontsize",      (char *)" Fonts are scaled assuming the page is 6 inches wide.  If the `size`",      (char *)" command is used to change the aspect ratio of the page or the CGM file",      (char *)" is converted to a different width, the resulting font sizes will be", 
        (char *)" scaled up or down accordingly.  To change the assumed width, use the",      (char *)" `width` option.",      (char *)"2 cgm linewidth",      (char *)"?commands set terminal cgm linewidth", 
        (char *)"?set terminal cgm linewidth",      (char *)"?set term cgm linewidth",      (char *)"?cgm linewidth",      (char *)" The `linewidth` option sets the width of lines in pt.  The default width", 
        (char *)" is 1 pt.  Scaling is affected by the actual width of the page, as",      (char *)" discussed under the `fontsize` and `width` options.",      (char *)"2 cgm rotate",      (char *)"?commands set terminal cgm rotate", 
        (char *)"?set terminal cgm rotate",      (char *)"?set term cgm rotate",      (char *)"?cgm rotate",      (char *)" The `norotate` option may be used to disable text rotation.  For", 
        (char *)" example, the CGM input filter for Word for Windows 6.0c can accept",      (char *)" rotated text, but the DRAW editor within Word cannot.  If you edit a",      (char *)" graph (for example, to label a curve), all rotated text is restored to",      (char *)" horizontal.  The Y axis label will then extend beyond the clip boundary.", 
        (char *)" With `norotate`, the Y axis label starts in a less attractive location,",      (char *)" but the page can be edited without damage.  The `rotate` option confirms",      (char *)" the default behavior.",      (char *)"2 cgm solid", 
        (char *)"?set terminal cgm solid",      (char *)"?set term cgm solid",      (char *)"?cgm solid",      (char *)" The `solid` option may be used to disable dashed line styles in the", 
        (char *)" plots.  This is useful when color is enabled and the dashing of the",      (char *)" lines detracts from the appearance of the plot. The `dashed` option",      (char *)" confirms the default behavior, which gives a different dash pattern to",      (char *)" each line type.", 
        (char *)"2 cgm size",      (char *)"?commands set terminal cgm size",      (char *)"?set terminal cgm size",      (char *)"?set term cgm size", 
        (char *)"?cgm size",      (char *)" Default size of a CGM plot is 32599 units wide and 23457 units high for",      (char *)" landscape, or 23457 units wide by 32599 units high for portrait.",      (char *)"2 cgm width", 
        (char *)"?commands set terminal cgm width",      (char *)"?set terminal cgm width",      (char *)"?set term cgm width",      (char *)"?cgm width", 
        (char *)" All distances in the CGM file are in abstract units.  The application",      (char *)" that reads the file determines the size of the final plot.  By default,",      (char *)" the width of the final plot is assumed to be 6 inches (15.24 cm).  This",      (char *)" distance is used to calculate the correct font size, and may be changed", 
        (char *)" with the `width` option.  The keyword should be followed by the width in",      (char *)" points.  (Here, a point is 1/72 inch, as in PostScript.  This unit is",      (char *)" known as a \"big point\" in TeX.)  Gnuplot `expressions` can be used to",      (char *)" convert from other units.", 
        (char *)"",      (char *)" Example:",      (char *)"       set terminal cgm width 432            # default",      (char *)"       set terminal cgm width 6*72           # same as above", 
        (char *)"       set terminal cgm width 10/2.54*72     # 10 cm wide",      (char *)"2 cgm nofontlist",      (char *)"?commands set terminal cgm nofontlist",      (char *)"?set terminal cgm nofontlist", 
        (char *)"?set term cgm nofontlist",      (char *)"?cgm nofontlist",      (char *)"?set terminal cgm winword6",      (char *)"?set term cgm winword6", 
        (char *)"?cgm winword6",      (char *)" The default font table includes the fonts recommended for WebCGM, which",      (char *)" are compatible with the Computer Graphics Metafile input filter for",      (char *)" Microsoft Office and Corel Draw.  Another application might use", 
        (char *)" different fonts and/or different font names, which may not be",      (char *)" documented.  The `nofontlist` (synonym `winword6`) option deletes the font",      (char *)" table from the CGM file.  In this case, the reading application should",      (char *)" use a default table.  Gnuplot will still use its own default font table", 
        (char *)" to select font indices.  Thus, \'Helvetica\' will give you an index of 1,",      (char *)" which should get you the first entry in your application\'s default font",      (char *)" table. \'Helvetica Bold\' will give you its second entry, etc.",      (char *)"", 
        (char *)"C#",      (char *)"C#corel",      (char *)"1 corel",      (char *)"?commands set terminal corel", 
        (char *)"?set terminal corel",      (char *)"?set term corel",      (char *)"?terminal corel",      (char *)"?term corel", 
        (char *)"?corel",      (char *)" The `corel` terminal driver supports CorelDraw.",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal corel {  default",      (char *)"                           | {monochrome | color",      (char *)"                                {\"<font>\" {<fontsize> ",      (char *)"                                   {<xsize> <ysize> {<linewidth> }}}}}", 
        (char *)"",      (char *)" where the fontsize and linewidth are specified in points and the sizes in",      (char *)" inches.  The defaults are monochrome, \"SwitzerlandLight\", 22, 8.2, 10 and 1.2.",      (char *)"C#", 
        (char *)"C#dumb",      (char *)"1 dumb",      (char *)"?commands set terminal dumb",      (char *)"?set terminal dumb", 
        (char *)"?set term dumb",      (char *)"?terminal dumb",      (char *)"?term dumb",      (char *)"?dumb", 
        (char *)" The `dumb` terminal driver plots into a text block using ascii characters.",      (char *)" It has an optional size specification and a trailing linefeed flag.",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal dumb {size <xchars>,<ychars>} {[no]feed}",      (char *)"                         {[no]enhanced}",      (char *)"",      (char *)" where <xchars> and <ychars> set the size of the text block. The default is", 
        (char *)" 79 by 24. The last newline is printed only if `feed` is enabled.",      (char *)"",      (char *)" Example:",      (char *)"       set term dumb size 60,15", 
        (char *)"       plot [-5:6.5] sin(x) with impulse",      (char *)"",      (char *)"            1 +-------------------------------------------------+",      (char *)"          0.8 +|||++                   ++||||++   sin(x) +----+ |", 
        (char *)"          0.6 +|||||+                 ++|||||||+                |",      (char *)"          0.4 +||||||+               ++|||||||||+               |",      (char *)"          0.2 +|||||||+             ++|||||||||||+             +|",      (char *)"            0 ++++++++++++++++++++++++++++++++++++++++++++++++++|", 
        (char *)"         -0.2 +        +|||||||||||+              +|||||||||||+ |",      (char *)"         -0.4 +         +|||||||||+                +|||||||||+  |",      (char *)"         -0.6 +          +|||||||+                  +|||||||+   |",      (char *)"         -0.8 +   +       ++||||+   +       +        ++||||+  + |", 
        (char *)"           -1 +---+--------+--------+-------+--------+--------+-+",      (char *)"                 -4       -2        0       2        4        6  ",      (char *)"C#",      (char *)"C#dxf", 
        (char *)"1 dxf",      (char *)"?commands set terminal dxf",      (char *)"?set terminal dxf",      (char *)"?set term dxf", 
        (char *)"?terminal dxf",      (char *)"?term dxf",      (char *)"?dxf",      (char *)" The `dxf` terminal driver creates pictures that can be imported into AutoCad", 
        (char *)" (Release 10.x).  It has no options of its own, but some features of its plots",      (char *)" may be modified by other means.  The default size is 120x80 AutoCad units,",      (char *)" which can be changed by `set size`.  `dxf` uses seven colors (white, red,",      (char *)" yellow, green, cyan, blue and magenta), which can be changed only by", 
        (char *)" modifying the source file.  If a black-and-white plotting device is used, the",      (char *)" colors are mapped to differing line thicknesses.  See the description of the",      (char *)" AutoCad print/plot command.",      (char *)"C#", 
        (char *)"C#emf",      (char *)"1 emf",      (char *)"?commands set terminal emf",      (char *)"?set terminal emf", 
        (char *)"?set term emf",      (char *)"?terminal emf",      (char *)"?term emf",      (char *)"?emf", 
        (char *)" The `emf` terminal generates an Enhanced Metafile Format file.",      (char *)" This file format is recognized by many Windows applications.",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal emf {color | monochrome} {solid | dashed}",      (char *)"                        {enhanced {noproportional}}",      (char *)"                        {rounded | butt}",      (char *)"                        {linewidth <LW>} {dashlength <DL>}", 
        (char *)"                        {size XX,YY} {background <rgb_color>}",      (char *)"                        {font \"<fontname>{,<fontsize>}\"}",      (char *)"                        {fontscale <scale>}",      (char *)"", 
        (char *)" In `monochrome` mode successive line types cycle through dash patterns.",      (char *)" In `color` mode successive line types use successive colors, and only after",      (char *)" all 8 default colors are exhausted is the dash pattern incremented.",      (char *)" `solid` draws all curves with solid lines, overriding any dashed patterns;", 
        (char *)" `linewidth <factor>` multiplies all line widths by this factor.",      (char *)" `dashlength <factor>` is useful for thick lines.",      (char *)" <fontname> is the name of a font; and ",      (char *)" `<fontsize>` is the size of the font in points.", 
        (char *)"",      (char *)" The nominal size of the output image defaults to 1024x768 in arbitrary",      (char *)" units. You may specify a different nominal size using the `size` option.",      (char *)"", 
        (char *)" Enhanced text mode tries to approximate proportional character spacing.",      (char *)" If you are using a monospaced font, or don\'t like the approximation, you",      (char *)" can turn off this correction using the `noproportional` option.",      (char *)"", 
        (char *)" The default settings are `color solid font \"Arial,12\" size 1024,768`",      (char *)" Selecting `default` sets all options to their default values.",      (char *)"",      (char *)" Examples:", 
        (char *)"       set terminal emf \'Times Roman Italic, 12\'",      (char *)"       set terminal emf dashed    # otherwise all lines are solid",      (char *)"C#",      (char *)"C#fig", 
        (char *)"1 fig",      (char *)"?commands set terminal fig",      (char *)"?set terminal fig",      (char *)"?set term fig", 
        (char *)"?terminal fig",      (char *)"?term fig",      (char *)"?fig",      (char *)"?xfig", 
        (char *)" The `fig` terminal device generates output in the Fig graphics language.",      (char *)"",      (char *)" Syntax:",      (char *)"       set terminal fig {monochrome | color}", 
        (char *)"                        {landscape | portrait}",      (char *)"                        {small | big | size <xsize> <ysize>}",      (char *)"                        {metric | inches}",      (char *)"                        {pointsmax <max_points>}", 
        (char *)"                        {solid | dashed}",      (char *)"                        {font \"<fontname>{,<fontsize>}\"}",      (char *)"                        {textnormal | {textspecial texthidden textrigid}}",      (char *)"                        {{thickness|linewidth} <units>}", 
        (char *)"                        {depth <layer>}",      (char *)"                        {version <number>}",      (char *)"",      (char *)" `monochrome` and `color` determine whether the picture is black-and-white or", 
        (char *)" `color`.  `small` and `big` produce a 5x3 or 8x5 inch graph in the default",      (char *)" `landscape` mode and 3x5 or 5x8 inches in `portrait` mode.",      (char *)" `size` sets (overrides) the size of the drawing",      (char *)" area to <xsize>*<ysize> in units of inches or centimeters depending on the", 
        (char *)" `inches` or `metric` setting in effect.",      (char *)" The latter settings is also used as default units for editing with \"xfig\".",      (char *)"",      (char *)" `pointsmax <max_points>` sets the maximum number of points per polyline.", 
        (char *)"",      (char *)" `solid` inhibits automatic usage of `dash`ed lines when solid linestyles are",      (char *)" used up, which otherwise occurs.",      (char *)"", 
        (char *)" `font` sets the text font face to <fontname> and its size to <fontsize>",      (char *)" points. `textnormal` resets the text flags and selects postscript fonts,",      (char *)" `textspecial` sets the text flags for LaTeX specials, `texthidden` sets the",      (char *)" hidden flag and `textrigid` the rigid flag.", 
        (char *)"",      (char *)" `depth` sets the default depth layer for all lines and text.  The default",      (char *)" depth is 10 to leave room for adding material with \"xfig\" on top of the",      (char *)" plot.", 
        (char *)"",      (char *)" `version` sets the format version of the generated fig output. Currently",      (char *)" only versions 3.1 and 3.2 are supported.",      (char *)"", 
        (char *)" `thickness` sets the default line thickness, which is 1 if not specified.",      (char *)" Overriding the thickness can be achieved by adding a multiple of 100 to the",      (char *)" `linetype` value for a `plot` command.  In a similar way the `depth`",      (char *)" of plot elements (with respect to the default depth) can be controlled by", 
        (char *)" adding a multiple of 1000 to <linetype>.  The depth is then <layer> +",      (char *)" <linetype>/1000 and the thickness is (<linetype>%1000)/100 or, if that is",      (char *)" zero, the default line thickness. `linewidth` is a synonym for `thickness`.",      (char *)"", 
        (char *)" Additional point-plot symbols are also available with the `fig` driver. The",      (char *)" symbols can be used through `pointtype` values % 100 above 50, with different",      (char *)" fill intensities controlled by <pointtype> % 5 and outlines in black (for",      (char *)" <pointtype> % 10 < 5) or in the current color.  Available symbols are", 
        (char *)"         50 - 59:  circles",      (char *)"         60 - 69:  squares",      (char *)"         70 - 79:  diamonds",      (char *)"         80 - 89:  upwards triangles", 
        (char *)"         90 - 99:  downwards triangles",      (char *)" The size of these symbols is linked to the font size.  The depth of symbols",      (char *)" is by default one less than the depth for lines to achieve nice error bars.",      (char *)" If <pointtype> is above 1000, the depth is <layer> + <pointtype>/1000-1.  If", 
        (char *)" <pointtype>%1000 is above 100, the fill color is (<pointtype>%1000)/100-1.",      (char *)"",      (char *)" Available fill colors are (from 1 to 9): black, blue, green, cyan, red,",      (char *)" magenta, yellow, white and dark blue (in monochrome mode: black for 1 to 6", 
        (char *)" and white for 7 to 9).",      (char *)"",      (char *)" See `plot with` for details of <linetype> and <pointtype>.",      (char *)"", 
        (char *)" The `big` option is a substitute for the `bfig` terminal in earlier versions,",      (char *)" which is no longer supported.",      (char *)"",      (char *)" Examples:", 
        (char *)"       set terminal fig monochrome small pointsmax 1000  # defaults",      (char *)"",      (char *)"       plot \'file.dat\' with points linetype 102 pointtype 759",      (char *)" would produce circles with a blue outline of width 1 and yellow fill color.", 
        (char *)"",      (char *)"       plot \'file.dat\' using 1:2:3 with err linetype 1 pointtype 554",      (char *)" would produce errorbars with black lines and circles filled red.  These",      (char *)" circles are one layer above the lines (at depth 9 by default).", 
        (char *)"",      (char *)" To plot the error bars on top of the circles use",      (char *)"       plot \'file.dat\' using 1:2:3 with err linetype 1 pointtype 2554",      (char *)"C#", 
        (char *)"C#hp2623a",      (char *)"1 hp2623a",      (char *)"?commands set terminal hp2623a",      (char *)"?set terminal hp2623a", 
        (char *)"?set term hp2623a",      (char *)"?terminal hp2623a",      (char *)"?term hp2623a",      (char *)"?hp2623a", 
        (char *)" The `hp2623a` terminal driver supports the Hewlett Packard HP2623A.  It has",      (char *)" no options.",      (char *)"C#",      (char *)"C#hp2648", 
        (char *)"1 hp2648",      (char *)"?commands set terminal hp2648",      (char *)"?set terminal hp2648",      (char *)"?set term hp2648", 
        (char *)"?terminal hp2648",      (char *)"?term hp2648",      (char *)"?hp2648",      (char *)" The `hp2648` terminal driver supports the Hewlett Packard HP2647 and HP2648.", 
        (char *)" It has no options.",      (char *)"C#",      (char *)"C#hpgl",      (char *)"1 hpgl", 
        (char *)"?commands set terminal hpgl",      (char *)"?set terminal hpgl",      (char *)"?set term hpgl",      (char *)"?terminal hpgl", 
        (char *)"?term hpgl",      (char *)"?hpgl",      (char *)"?commands set terminal pcl5",      (char *)"?set terminal pcl5", 
        (char *)"?set term pcl5",      (char *)"?terminal pcl5",      (char *)"?term pcl5",      (char *)"?pcl5", 
        (char *)" The `hpgl` driver produces HPGL output for devices like the HP7475A plotter.",      (char *)" There are two options which can be set: the number of pens and `eject`,",      (char *)" which tells the plotter to eject a page when done.  The default is to use 6",      (char *)" pens and not to eject the page when done.", 
        (char *)"",      (char *)" The international character sets ISO-8859-1 and CP850 are recognized via",      (char *)" `set encoding iso_8859_1` or `set encoding cp850` (see `set encoding` for",      (char *)" details).", 
        (char *)"",      (char *)" Syntax:",      (char *)"       set terminal hpgl {<number_of_pens>} {eject}",      (char *)"", 
        (char *)" The selection",      (char *)"",      (char *)"       set terminal hpgl 8 eject",      (char *)"", 
        (char *)" is equivalent to the previous `hp7550` terminal, and the selection",      (char *)"",      (char *)"       set terminal hpgl 4",      (char *)"", 
        (char *)" is equivalent to the previous `hp7580b` terminal.",      (char *)"",      (char *)" The `pcl5` driver supports plotters such as the Hewlett-Packard Designjet",      (char *)" 750C, the Hewlett-Packard Laserjet III, and the Hewlett-Packard Laserjet IV.", 
        (char *)" It actually uses HPGL-2, but there is a name conflict among the terminal",      (char *)" devices.  It has several options which must be specified in the order",      (char *)" indicated below:",      (char *)"", 
        (char *)" Syntax:",      (char *)"       set terminal pcl5 {mode <mode>} {<plotsize>}",      (char *)"           {{color {<number_of_pens>}} | monochrome} {solid | dashed}",      (char *)"           {font <font>} {size <fontsize>} {pspoints | nopspoints}", 
        (char *)"",      (char *)" <mode> is `landscape` or `portrait`. <plotsize> is the physical",      (char *)" plotting size of the plot, which is one of the following: `letter` for",      (char *)" standard (8 1/2\" X 11\") displays, `legal` for (8 1/2\" X 14\") displays,", 
        (char *)" `noextended` for (36\" X 48\") displays (a letter size ratio) or,",      (char *)" `extended` for (36\" X 55\") displays (almost a legal size ratio).",      (char *)" `color` is for multi-pen (i.e. color) plots, and <number_of_pens> is",      (char *)" the number of pens (i.e. colors) used in color plots. `monochrome` is for", 
        (char *)" one (e.g. black) pen plots. `solid` draws all lines as solid lines, or",      (char *)" `dashed` will draw lines with different dashed and dotted line patterns.",      (char *)" <font> is `stick`, `univers`, `cg_times`, `zapf_dingbats`, `antique_olive`,",      (char *)" `arial`, `courier`, `garamond_antigua`, `letter_gothic`, `cg_omega`,", 
        (char *)" `albertus`, `times_new_roman`, `clarendon`, `coronet`, `marigold`,",      (char *)" `truetype_symbols`, or `wingdings`. <fontsize> is the font size in points.",      (char *)" The point type selection can be the standard default set by specifying",      (char *)" `nopspoints`, or the same set of point types found in the postscript terminal", 
        (char *)" by specifying `pspoints`.",      (char *)"",      (char *)" Note that built-in support of some of these options is printer device",      (char *)" dependent. For instance, all the fonts are supposedly supported by the HP", 
        (char *)" Laserjet IV, but only a few (e.g. univers, stick) may be supported by the HP",      (char *)" Laserjet III and the Designjet 750C. Also, color obviously won\'t work on the",      (char *)" the laserjets since they are monochrome devices.",      (char *)"", 
        (char *)" Defaults: landscape, noextended, color (6 pens), solid, univers, 12 point,",      (char *)"           and nopspoints.",      (char *)"",      (char *)" With `pcl5` international characters are handled by the printer; you just put", 
        (char *)" the appropriate 8-bit character codes into the text strings.  You don\'t need",      (char *)" to bother with `set encoding`.",      (char *)"",      (char *)" HPGL graphics can be imported by many software packages.", 
        (char *)"C#",      (char *)"C#imagen",      (char *)"1 imagen",      (char *)"?commands set terminal imagen", 
        (char *)"?set terminal imagen",      (char *)"?set term imagen",      (char *)"?terminal imagen",      (char *)"?term imagen", 
        (char *)"?imagen",      (char *)" The `imagen` terminal driver supports Imagen laser printers.  It is capable",      (char *)" of placing multiple graphs on a single page.",      (char *)"", 
        (char *)" Syntax:",      (char *)"       set terminal imagen {<fontsize>} {portrait | landscape}",      (char *)"                           {[<horiz>,<vert>]}",      (char *)"", 
        (char *)" where `fontsize` defaults to 12 points and the layout defaults to `landscape`.",      (char *)" `<horiz>` and `<vert>` are the number of graphs in the horizontal and",      (char *)" vertical directions; these default to unity.",      (char *)"", 
        (char *)" Example:",      (char *)"       set terminal imagen portrait [2,3]",      (char *)"",      (char *)" puts six graphs on the page in three rows of two in portrait orientation.", 
        (char *)"C#",      (char *)"C#mif",      (char *)"1 mif",      (char *)"?commands set terminal mif", 
        (char *)"?set terminal mif",      (char *)"?set term mif",      (char *)"?terminal mif",      (char *)"?term mif", 
        (char *)"?mif",      (char *)" The `mif` terminal driver produces Frame Maker MIF format version 3.00.  It",      (char *)" plots in MIF Frames with the size 15*10 cm, and plot primitives with the same",      (char *)" pen will be grouped in the same MIF group.  Plot primitives in a `gnuplot`", 
        (char *)" page will be plotted in a MIF Frame, and several MIF Frames are collected in",      (char *)" one large MIF Frame.  The MIF font used for text is \"Times\".",      (char *)"",      (char *)" Several options may be set in the MIF 3.00 driver.", 
        (char *)"",      (char *)" Syntax:",      (char *)"       set terminal mif {color | colour | monochrome} {polyline | vectors}",      (char *)"                        {help | ?}", 
        (char *)"",      (char *)" `colour` plots lines with line types >= 0 in colour (MIF sep. 2--7) and",      (char *)" `monochrome` plots all line types in black (MIF sep. 0).",      (char *)" `polyline` plots curves as continuous curves and `vectors` plots curves as", 
        (char *)" collections of vectors.",      (char *)" `help` and `?` print online help on standard error output---both print a",      (char *)" short description of the usage; `help` also lists the options.",      (char *)"", 
        (char *)" Examples:",      (char *)"       set term mif colour polylines    # defaults",      (char *)"       set term mif                     # defaults",      (char *)"       set term mif vectors", 
        (char *)"       set term mif help",      (char *)"C#",      (char *)"C#00psglobal",      (char *)"", 
        (char *)"C#",      (char *)"C#epslatex",      (char *)"1 epslatex",      (char *)"?commands set terminal epslatex", 
        (char *)"?set terminal epslatex",      (char *)"?set term epslatex",      (char *)"?terminal epslatex",      (char *)"?term epslatex", 
        (char *)"?epslatex",      (char *)" The `epslatex` driver generates output for further processing by LaTeX.",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal epslatex   {default}",      (char *)"       set terminal epslatex   {standalone | input}",      (char *)"                               {oldstyle | newstyle}",      (char *)"                               {level1 | leveldefault}", 
        (char *)"                               {color | colour | monochrome}",      (char *)"                               {background <rgbcolor> | nobackground}",      (char *)"                               {solid | dashed}",      (char *)"                               {dashlength | dl <DL>}", 
        (char *)"                               {linewidth | lw <LW>}",      (char *)"                               {rounded | butt}",      (char *)"                               {clip | noclip}",      (char *)"                               {palfuncparam <samples>{,<maxdeviation>}}", 
        (char *)"                               {size <XX>{unit},<YY>{unit}}",      (char *)"                               {header <header> | noheader}",      (char *)"                               {blacktext | colortext | colourtext}",      (char *)"                               {{font} \"fontname{,fontsize}\" {<fontsize>}}", 
        (char *)"                               {fontscale <scale>}",      (char *)"",      (char *)" The epslatex terminal prints a plot as `terminal postscript eps`",      (char *)" but transfers the texts to LaTeX instead of including in the PostScript", 
        (char *)" code. Thus, many options are the same as in the `postscript terminal`.",      (char *)"",      (char *)" The appearance of the epslatex terminal changed between versions 4.0 and 4.2",      (char *)" to reach better consistency with the postscript terminal:", 
        (char *)" The plot size has been changed from 5 x 3 inches to 5 x 3.5 inches;",      (char *)" the character width is now estimated to be 60% of the font size",      (char *)" while the old epslatex terminal used 50%;  now, the larger number of",      (char *)" postscript linetypes and symbols are used.  To reach an appearance that is", 
        (char *)" nearly identical to the old one specify the option `oldstyle`. (In fact",      (char *)" some small differences remain: the symbol sizes are slightly different, the",      (char *)" tics are half as large as in the old terminal which can be changed using",      (char *)" `set tics scale`, and the arrows have all features as in the postscript", 
        (char *)" terminal.)",      (char *)"",      (char *)" If you see the error message",      (char *)"       \"Can\'t find PostScript prologue file ... \"", 
        (char *)" Please see and follow the instructions in `postscript prologue`.",      (char *)"",      (char *)" The option `color` enables color, while `monochrome` prefers black and white",      (char *)" drawing elements. Further, `monochrome` uses gray `palette` but it does not", 
        (char *)" change color of objects specified with an explicit `colorspec`.",      (char *)" `solid` draws all plots with solid lines, overriding any dashed patterns.",      (char *)" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>,",      (char *)" which is a floating-point number greater than zero.", 
        (char *)" `linewidth` or `lw` scales all linewidths by <LW>.",      (char *)"",      (char *)" By default the generated PostScript code uses language features that were",      (char *)" introduced in PostScript Level 2, notably filters and pattern-fill of", 
        (char *)" irregular objects such as filledcurves.  PostScript Level 2 features are",      (char *)" conditionally protected so that PostScript Level 1 interpreters do not issue",      (char *)" errors but, rather, display a message or a PostScript Level 1 approximation.",      (char *)" The `level1` option substitutes PostScript Level 1 approximations of these", 
        (char *)" features and uses no PostScript Level 2 code.  This may be required by some",      (char *)" old printers and old versions of Adobe Illustrator.  The flag `level1` can be",      (char *)" toggled later by editing a single line in the PostScript output file to force",      (char *)" PostScript Level 1 interpretation.  In the case of files containing level 2", 
        (char *)" code, the above features will not appear or will be replaced by a note when",      (char *)" this flag is set or when the interpreting program does not indicate that it",      (char *)" understands level 2 PostScript or higher.",      (char *)"", 
        (char *)" `rounded` sets line caps and line joins to be rounded; `butt` is the",      (char *)" default, butt caps and mitered joins.",      (char *)"",      (char *)" `clip` tells PostScript to clip all output to the bounding box;", 
        (char *)" `noclip` is the default.",      (char *)"",      (char *)" `palfuncparam` controls how `set palette functions` are encoded as gradients",      (char *)" in the output. Analytic color component functions (set via", 
        (char *)" `set palette functions`) are encoded as linear interpolated gradients in the",      (char *)" postscript output:  The color component functions are sampled at <samples>",      (char *)" points and all points are removed from this gradient which can be removed",      (char *)" without changing the resulting colors by more than <maxdeviation>. For", 
        (char *)" almost every useful palette you may safely leave the defaults of",      (char *)" <samples>=2000 and <maxdeviation>=0.003 untouched.",      (char *)"",      (char *)" The default size for postscript output is 10 inches x 7 inches. The default", 
        (char *)" for eps output is 5 x 3.5 inches.  The `size` option changes this to",      (char *)" whatever the user requests. By default the X and Y sizes are taken to be in",      (char *)" inches, but other units are possibly (currently only cm). The BoundingBox",      (char *)" of the plot is correctly adjusted to contain the resized image.", 
        (char *)" Screen coordinates always run from 0.0 to 1.0 along the full length of the",      (char *)" plot edges as specified by the `size` option.",      (char *)" NB: `this is a change from the previously recommended method of using the",      (char *)" set size command prior to setting the terminal type`.  The old method left", 
        (char *)" the BoundingBox unchanged and screen coordinates did not correspond to the",      (char *)" actual limits of the plot.",      (char *)"",      (char *)" `blacktext` forces all text to be written in black even in color mode;", 
        (char *)"",      (char *)" The epslatex driver offers a special way of controlling text positioning:",      (char *)" (a) If any text string begins with \'{\', you also need to include a \'}\' at the",      (char *)" end of the text, and the whole text will be centered both horizontally", 
        (char *)" and vertically by LaTeX.  (b) If the text string begins with \'[\', you need",      (char *)" to continue it with: a position specification (up to two out of t,b,l,r,c),",      (char *)" \']{\', the text itself, and finally, \'}\'. The text itself may be anything",      (char *)" LaTeX can typeset as an LR-box. \\rule{}{}\'s may help for best positioning.", 
        (char *)" See also the documentation for the `pslatex` terminal driver.",      (char *)" To create multiline labels, use \\shortstack, for example",      (char *)"    set ylabel \'[r]{\\shortstack{first line \\\\ second line}}\' ",      (char *)"", 
        (char *)" The `back` option of `set label` commands is handled slightly different",      (char *)" than in other terminals. Labels using \'back\' are printed behind all other",      (char *)" elements of the plot while labels using \'front\' are printed above ",      (char *)" everything else.", 
        (char *)"",      (char *)" The driver produces two different files, one for the eps part of the figure",      (char *)" and one for the LaTeX part. The name of the LaTeX file is taken from the",      (char *)" `set output` command. The name of the eps file is derived by replacing", 
        (char *)" the file extension (normally `.tex`) with `.eps` instead.  There is no",      (char *)" LaTeX output if no output file is given!  Remember to close the",      (char *)" `output file` before next plot unless in `multiplot` mode.",      (char *)"", 
        (char *)" In your LaTeX documents use \'\\input{filename}\' to include the figure.",      (char *)" The `.eps` file is included by the command \\includegraphics{...}, so you",      (char *)" must also include \\usepackage{graphicx} in the LaTeX preamble.  If you",      (char *)" want to use coloured text (option `textcolour`) you also have to include", 
        (char *)" \\usepackage{color} in the LaTeX preamble.",      (char *)"",      (char *)" Pdf files can be made from the eps file using \'epstopdf\'. If the graphics",      (char *)" package is properly configured, the LaTeX files can also be processed by", 
        (char *)" pdflatex without changes, using the pdf files instead of the eps files.",      (char *)" The behaviour concerning font selection depends on the header mode.",      (char *)" In all cases, the given font size is used for the calculation of proper",      (char *)" spacing. When not using the `standalone` mode the actual LaTeX font and", 
        (char *)" font size at the point of inclusion is taken, so use LaTeX commands for",      (char *)" changing fonts. If you use e.g. 12pt as font size for your LaTeX",      (char *)" document, use \'\"\" 12\' as options. The font name is ignored. If using",      (char *)" `standalone` the given font and font size are used, see below for a", 
        (char *)" detailed description.",      (char *)"",      (char *)" If text is printed coloured is controlled by the TeX booleans \\ifGPcolor",      (char *)" and \\ifGPblacktext. Only if \\ifGPcolor is true and \\ifGPblacktext is", 
        (char *)" false, text is printed coloured. You may either change them in the",      (char *)" generated TeX file or provide them globally in your TeX file, for example",      (char *)" by using",      (char *)"    \\newif\\ifGPblacktext", 
        (char *)"    \\GPblacktexttrue",      (char *)" in the preamble of your document. The local assignment is only done if no",      (char *)" global value is given.",      (char *)"", 
        (char *)" When using the epslatex terminal give the name of the TeX file in the",      (char *)" `set output` command including the file extension (normally \".tex\").",      (char *)" The eps filename is generated by replacing the extension by \".eps\".",      (char *)"", 
        (char *)" If using the `standalone` mode a complete LaTeX header is added to the",      (char *)" LaTeX file; and \"-inc\" is added to the filename of the eps file.",      (char *)" The `standalone` mode generates a TeX file that produces",      (char *)" output with the correct size when using dvips, pdfTeX, or VTeX.", 
        (char *)" The default, `input`, generates a file that has to be included into a",      (char *)" LaTeX document using the \\input command.",      (char *)"",      (char *)" If a font other than \"\" or \"default\" is given it is interpreted as", 
        (char *)" LaTeX font name.  It contains up to three parts, separated by a comma:",      (char *)" \'fontname,fontseries,fontshape\'.  If the default fontshape or fontseries",      (char *)" are requested, they can be omitted.  Thus, the real syntax for the fontname",      (char *)" is \'[fontname][,fontseries][,fontshape]\'.  The naming convention for all", 
        (char *)" parts is given by the LaTeX font scheme.  The fontname is 3 to 4 characters",      (char *)" long and is built as follows: One character for the font vendor, two",      (char *)" characters for the name of the font, and optionally one additional",      (char *)" character for special fonts, e.g., \'j\' for fonts with old-style numerals", 
        (char *)" or \'x\' for expert fonts. The names of many fonts is described in",      (char *)"^ <a href=\"http://www.tug.org/fontname/fontname.pdf\">",      (char *)"           http://www.tug.org/fontname/fontname.pdf",      (char *)"^ </a>", 
        (char *)" For example, \'cmr\' stands for Computer Modern Roman, \'ptm\' for Times-Roman,",      (char *)" and \'phv\' for Helvetica.  The font series denotes the thickness of the",      (char *)" glyphs, in most cases \'m\' for normal (\"medium\") and \'bx\' or \'b\' for bold",      (char *)" fonts.  The font shape is \'n\' for upright, \'it\' for italics, \'sl\' for", 
        (char *)" slanted, or \'sc\' for small caps, in general.  Some fonts may provide",      (char *)" different font series or shapes.",      (char *)"",      (char *)" Examples:", 
        (char *)"",      (char *)" Use Times-Roman boldface (with the same shape as in the surrounding text):",      (char *)"       set terminal epslatex \'ptm,bx\'",      (char *)" Use Helvetica, boldface, italics:", 
        (char *)"       set terminal epslatex \'phv,bx,it\'",      (char *)" Continue to use the surrounding font in slanted shape:",      (char *)"       set terminal epslatex \',,sl\'",      (char *)" Use small capitals:", 
        (char *)"       set terminal epslatex \',,sc\'",      (char *)"",      (char *)" By this method, only text fonts are changed. If you also want to change",      (char *)" the math fonts you have to use the \"gnuplot.cfg\" file or the `header`", 
        (char *)" option, described below.",      (char *)"",      (char *)" In standalone mode, the font size is taken from the given font size in the",      (char *)" `set terminal` command. To be able to use a specified font size, a file", 
        (char *)" \"size<size>.clo\" has to reside in the LaTeX search path.  By default,",      (char *)" 10pt, 11pt, and 12pt are supported.  If the package \"extsizes\" is",      (char *)" installed, 8pt, 9pt, 14pt, 17pt, and 20pt are added.",      (char *)"", 
        (char *)" The `header` option takes a string as argument.  This string is written",      (char *)" into the generated LaTeX file.  If using the `standalone` mode, it is ",      (char *)" written into the preamble, directly before the \\begin{document} command.",      (char *)" In the `input` mode, it is placed directly after the \\begingroup command", 
        (char *)" to ensure that all settings are local to the plot.",      (char *)"",      (char *)" Examples:",      (char *)"", 
        (char *)" Use T1 fontencoding, change the text and math font to Times-Roman as well",      (char *)" as the sans-serif font to Helvetica:",      (char *)"     set terminal epslatex standalone header \\",      (char *)"     \"\\\\usepackage[T1]{fontenc}\\n\\\\usepackage{mathptmx}\\n\\\\usepackage{helvet}\"", 
        (char *)" Use a boldface font in the plot, not influencing the text outside the plot:",      (char *)"     set terminal epslatex input header \"\\\\bfseries\"",      (char *)"",      (char *)" If the file \"gnuplot.cfg\" is found by LaTeX it is input in the preamble", 
        (char *)" the LaTeX document, when using `standalone` mode.  It can be used for",      (char *)" further settings, e.g., changing the document font to Times-Roman,",      (char *)" Helvetica, and Courier, including math fonts (handled by \"mathptmx.sty\"):",      (char *)"       \\usepackage{mathptmx}", 
        (char *)"       \\usepackage[scaled=0.92]{helvet}",      (char *)"       \\usepackage{courier}",      (char *)" The file \"gnuplot.cfg\" is loaded before the header information given",      (char *)" by the `header` command.  Thus, you can use `header` to overwrite some of", 
        (char *)" settings performed using \"gnuplot.cfg\"",      (char *)"",      (char *)"C#",      (char *)"C#pslatex", 
        (char *)"1 pslatex and pstex",      (char *)"?commands set terminal pslatex",      (char *)"?set terminal pslatex",      (char *)"?set term pslatex", 
        (char *)"?terminal pslatex",      (char *)"?term pslatex",      (char *)"?pslatex",      (char *)"?commands set terminal pstex", 
        (char *)"?set terminal pstex",      (char *)"?set term pstex",      (char *)"?terminal pstex",      (char *)"?term pstex", 
        (char *)"?pstex",      (char *)" The `pslatex` driver generates output for further processing by LaTeX,",      (char *)" while the `pstex` driver generates output for further processing by",      (char *)" TeX. `pslatex` uses \\specials understandable by dvips and xdvi. Figures", 
        (char *)" generated by `pstex` can be included in any plain-based format (including",      (char *)" LaTeX).",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal [pslatex | pstex] {default}",      (char *)"       set terminal [pslatex | pstex]",      (char *)"                               {rotate | norotate}",      (char *)"                               {oldstyle | newstyle}", 
        (char *)"                               {auxfile | noauxfile}",      (char *)"                               {level1 | leveldefault}",      (char *)"                               {color | colour | monochrome}",      (char *)"                               {background <rgbcolor> | nobackground}", 
        (char *)"                               {solid | dashed}",      (char *)"                               {dashlength | dl <DL>}",      (char *)"                               {linewidth | lw <LW>}",      (char *)"                               {rounded | butt}", 
        (char *)"                               {clip | noclip}",      (char *)"                               {palfuncparam <samples>{,<maxdeviation>}}",      (char *)"                               {size <XX>{unit},<YY>{unit}}",      (char *)"                               {<font_size>}", 
        (char *)"",      (char *)" If you see the error message",      (char *)"       \"Can\'t find PostScript prologue file ... \"",      (char *)" Please see and follow the instructions in `postscript prologue`.", 
        (char *)"",      (char *)" The option `color` enables color, while `monochrome` prefers black and white",      (char *)" drawing elements. Further, `monochrome` uses gray `palette` but it does not",      (char *)" change color of objects specified with an explicit `colorspec`.", 
        (char *)" `solid` draws all plots with solid lines, overriding any dashed patterns.",      (char *)" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>,",      (char *)" which is a floating-point number greater than zero.",      (char *)" `linewidth` or `lw` scales all linewidths by <LW>.", 
        (char *)"",      (char *)" By default the generated PostScript code uses language features that were",      (char *)" introduced in PostScript Level 2, notably filters and pattern-fill of",      (char *)" irregular objects such as filledcurves.  PostScript Level 2 features are", 
        (char *)" conditionally protected so that PostScript Level 1 interpreters do not issue",      (char *)" errors but, rather, display a message or a PostScript Level 1 approximation.",      (char *)" The `level1` option substitutes PostScript Level 1 approximations of these",      (char *)" features and uses no PostScript Level 2 code.  This may be required by some", 
        (char *)" old printers and old versions of Adobe Illustrator.  The flag `level1` can be",      (char *)" toggled later by editing a single line in the PostScript output file to force",      (char *)" PostScript Level 1 interpretation.  In the case of files containing level 2",      (char *)" code, the above features will not appear or will be replaced by a note when", 
        (char *)" this flag is set or when the interpreting program does not indicate that it",      (char *)" understands level 2 PostScript or higher.",      (char *)"",      (char *)" `rounded` sets line caps and line joins to be rounded; `butt` is the", 
        (char *)" default, butt caps and mitered joins.",      (char *)"",      (char *)" `clip` tells PostScript to clip all output to the bounding box;",      (char *)" `noclip` is the default.", 
        (char *)"",      (char *)" `palfuncparam` controls how `set palette functions` are encoded as gradients",      (char *)" in the output. Analytic color component functions (set via",      (char *)" `set palette functions`) are encoded as linear interpolated gradients in the", 
        (char *)" postscript output:  The color component functions are sampled at <samples>",      (char *)" points and all points are removed from this gradient which can be removed",      (char *)" without changing the resulting colors by more than <maxdeviation>. For",      (char *)" almost every useful palette you may safely leave the defaults of", 
        (char *)" <samples>=2000 and <maxdeviation>=0.003 untouched.",      (char *)"",      (char *)" The default size for postscript output is 10 inches x 7 inches. The default",      (char *)" for eps output is 5 x 3.5 inches.  The `size` option changes this to", 
        (char *)" whatever the user requests. By default the X and Y sizes are taken to be in",      (char *)" inches, but other units are possibly (currently only cm). The BoundingBox",      (char *)" of the plot is correctly adjusted to contain the resized image.",      (char *)" Screen coordinates always run from 0.0 to 1.0 along the full length of the", 
        (char *)" plot edges as specified by the `size` option.",      (char *)" NB: `this is a change from the previously recommended method of using the",      (char *)" set size command prior to setting the terminal type`.  The old method left",      (char *)" the BoundingBox unchanged and screen coordinates did not correspond to the", 
        (char *)" actual limits of the plot.",      (char *)"",      (char *)" if `rotate` is specified, the y-axis label is rotated.",      (char *)" <font_size> is the size (in pts) of the desired font.", 
        (char *)"",      (char *)" If `auxfile` is specified, it directs the driver to put the PostScript",      (char *)" commands into an auxiliary file instead of directly into the LaTeX file.",      (char *)" This is useful if your pictures are large enough that dvips cannot handle", 
        (char *)" them.  The name of the auxiliary PostScript file is derived from the name of",      (char *)" the TeX file given on the `set output` command; it is determined by replacing",      (char *)" the trailing `.tex` (actually just the final extent in the file name) with",      (char *)" `.ps` in the output file name, or, if the TeX file has no extension, `.ps`", 
        (char *)" is appended.  The `.ps` is included into the `.tex` file by a",      (char *)" \\special{psfile=...} command.  Remember to close the `output file` before",      (char *)" next plot unless in `multiplot` mode.",      (char *)"", 
        (char *)" Gnuplot versions prior to version 4.2 generated plots of the size",      (char *)" 5 x 3 inches using the ps(la)tex terminal while the current version generates",      (char *)" 5 x 3.5 inches to be consistent with the postscript eps terminal.  In",      (char *)" addition, the character width is now estimated to be 60% of the font size", 
        (char *)" while the old epslatex terminal used 50%. To reach the old format specify",      (char *)" the option `oldstyle`.",      (char *)"",      (char *)" The pslatex driver offers a special way of controlling text positioning: ", 
        (char *)" (a) If any text string begins with \'{\', you also need to include a \'}\' at the",      (char *)" end of the text, and the whole text will be centered both horizontally",      (char *)" and vertically by LaTeX.  (b) If the text string begins with \'[\', you need",      (char *)" to continue it with: a position specification (up to two out of t,b,l,r),", 
        (char *)" \']{\', the text itself, and finally, \'}\'. The text itself may be anything",      (char *)" LaTeX can typeset as an LR-box. \\rule{}{}\'s may help for best positioning.",      (char *)"",      (char *)" The options not described here are identical to the `Postscript terminal`.", 
        (char *)" Look there if you want to know what they do.",      (char *)"",      (char *)" Examples:",      (char *)"       set term pslatex monochrome dashed rotate       # set to defaults", 
        (char *)" To write the PostScript commands into the file \"foo.ps\":",      (char *)"       set term pslatex auxfile",      (char *)"       set output \"foo.tex\"; plot ...; set output",      (char *)" About label positioning:", 
        (char *)" Use gnuplot defaults (mostly sensible, but sometimes not really best):",      (char *)"        set title \'\\LaTeX\\ -- $ \\gamma $\'",      (char *)" Force centering both horizontally and vertically:",      (char *)"        set label \'{\\LaTeX\\ -- $ \\gamma $}\' at 0,0", 
        (char *)" Specify own positioning (top here):",      (char *)"        set xlabel \'[t]{\\LaTeX\\ -- $ \\gamma $}\'",      (char *)" The other label -- account for long ticlabels:",      (char *)"        set ylabel \'[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}\'", 
        (char *)"",      (char *)" Linewidths and pointsizes may be changed with `set style line`.",      (char *)"C#",      (char *)"C#post", 
        (char *)"1 postscript",      (char *)"?commands set terminal postscript",      (char *)"?set terminal postscript",      (char *)"?set term postscript", 
        (char *)"?terminal postscript",      (char *)"?term postscript",      (char *)"?postscript",      (char *)" Several options may be set in the `postscript` driver.", 
        (char *)"",      (char *)" Syntax:",      (char *)"       set terminal postscript {default}",      (char *)"       set terminal postscript {landscape | portrait | eps}", 
        (char *)"                               {enhanced | noenhanced}",      (char *)"                               {defaultplex | simplex | duplex}",      (char *)"                               {fontfile [add | delete] \"<filename>\"",      (char *)"                                | nofontfiles} {{no}adobeglyphnames}", 
        (char *)"                               {level1 | leveldefault}",      (char *)"                               {color | colour | monochrome}",      (char *)"                               {background <rgbcolor> | nobackground}",      (char *)"                               {solid | dashed}", 
        (char *)"                               {dashlength | dl <DL>}",      (char *)"                               {linewidth | lw <LW>}",      (char *)"                               {rounded | butt}",      (char *)"                               {clip | noclip}", 
        (char *)"                               {palfuncparam <samples>{,<maxdeviation>}}",      (char *)"                               {size <XX>{unit},<YY>{unit}}",      (char *)"                               {blacktext | colortext | colourtext}",      (char *)"                               {{font} \"fontname{,fontsize}\" {<fontsize>}}", 
        (char *)"                               {fontscale <scale>}",      (char *)" If you see the error message",      (char *)"       \"Can\'t find PostScript prologue file ... \"",      (char *)" Please see and follow the instructions in `postscript prologue`.", 
        (char *)"",      (char *)"",      (char *)" `landscape` and `portrait` choose the plot orientation.",      (char *)" `eps` mode generates EPS (Encapsulated PostScript) output, which is just", 
        (char *)" regular PostScript with some additional lines that allow the file to be",      (char *)" imported into a variety of other applications.  (The added lines are",      (char *)" PostScript comment lines, so the file may still be printed by itself.)  To",      (char *)" get EPS output, use the `eps` mode and make only one plot per file.  In `eps`", 
        (char *)" mode the whole plot, including the fonts, is reduced to half of the default",      (char *)" size.",      (char *)"",      (char *)" `enhanced` enables enhanced text mode features (subscripts,", 
        (char *)" superscripts and mixed fonts). See `enhanced` for more information.",      (char *)" `blacktext` forces all text to be written in black even in color mode;",      (char *)"",      (char *)" Duplexing in PostScript is the ability of the printer to print on both", 
        (char *)" sides of the same sheet of paper.  With `defaultplex`, the default setting",      (char *)" of the printer is used; with `simplex` only one side is printed; `duplex`",      (char *)" prints on both sides (ignored if your printer can\'t do it).",      (char *)"", 
        (char *)" `\"<fontname>\"` is the name of a valid PostScript font; and `<fontsize>` is",      (char *)" the size of the font in PostScript points.",      (char *)" In addition to the standard postscript fonts, an oblique version of the",      (char *)" Symbol font, useful for mathematics, is defined. It is called", 
        (char *)" \"Symbol-Oblique\".",      (char *)"",      (char *)" `default` sets all options to their defaults: `landscape`, `monochrome`,",      (char *)" `dashed`, `dl 1.0`, `lw 1.0`, `defaultplex`, `noenhanced`, \"Helvetica\" and", 
        (char *)" 14pt.  Default size of a PostScript plot is 10 inches wide and 7 inches high.",      (char *)" The option `color` enables color, while `monochrome` prefers black and white",      (char *)" drawing elements. Further, `monochrome` uses gray `palette` but it does not",      (char *)" change color of objects specified with an explicit `colorspec`.", 
        (char *)" `solid` draws all plots with solid lines, overriding any dashed patterns.",      (char *)" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>,",      (char *)" which is a floating-point number greater than zero.",      (char *)" `linewidth` or `lw` scales all linewidths by <LW>.", 
        (char *)"",      (char *)" By default the generated PostScript code uses language features that were",      (char *)" introduced in PostScript Level 2, notably filters and pattern-fill of",      (char *)" irregular objects such as filledcurves.  PostScript Level 2 features are", 
        (char *)" conditionally protected so that PostScript Level 1 interpreters do not issue",      (char *)" errors but, rather, display a message or a PostScript Level 1 approximation.",      (char *)" The `level1` option substitutes PostScript Level 1 approximations of these",      (char *)" features and uses no PostScript Level 2 code.  This may be required by some", 
        (char *)" old printers and old versions of Adobe Illustrator.  The flag `level1` can be",      (char *)" toggled later by editing a single line in the PostScript output file to force",      (char *)" PostScript Level 1 interpretation.  In the case of files containing level 2",      (char *)" code, the above features will not appear or will be replaced by a note when", 
        (char *)" this flag is set or when the interpreting program does not indicate that it",      (char *)" understands level 2 PostScript or higher.",      (char *)"",      (char *)" `rounded` sets line caps and line joins to be rounded; `butt` is the", 
        (char *)" default, butt caps and mitered joins.",      (char *)"",      (char *)" `clip` tells PostScript to clip all output to the bounding box;",      (char *)" `noclip` is the default.", 
        (char *)"",      (char *)" `palfuncparam` controls how `set palette functions` are encoded as gradients",      (char *)" in the output. Analytic color component functions (set via",      (char *)" `set palette functions`) are encoded as linear interpolated gradients in the", 
        (char *)" postscript output:  The color component functions are sampled at <samples>",      (char *)" points and all points are removed from this gradient which can be removed",      (char *)" without changing the resulting colors by more than <maxdeviation>. For",      (char *)" almost every useful palette you may safely leave the defaults of", 
        (char *)" <samples>=2000 and <maxdeviation>=0.003 untouched.",      (char *)"",      (char *)" The default size for postscript output is 10 inches x 7 inches. The default",      (char *)" for eps output is 5 x 3.5 inches.  The `size` option changes this to", 
        (char *)" whatever the user requests. By default the X and Y sizes are taken to be in",      (char *)" inches, but other units are possibly (currently only cm). The BoundingBox",      (char *)" of the plot is correctly adjusted to contain the resized image.",      (char *)" Screen coordinates always run from 0.0 to 1.0 along the full length of the", 
        (char *)" plot edges as specified by the `size` option.",      (char *)" NB: `this is a change from the previously recommended method of using the",      (char *)" set size command prior to setting the terminal type`.  The old method left",      (char *)" the BoundingBox unchanged and screen coordinates did not correspond to the", 
        (char *)" actual limits of the plot.",      (char *)"",      (char *)" Fonts listed by `fontfile` or `fontfile add` encapsulate the font",      (char *)" definitions of the listed font from a postscript Type 1 or TrueType font", 
        (char *)" file directly into the gnuplot output postscript file.  Thus, the enclosed",      (char *)" font can be used in labels, titles, etc.  See the section",      (char *)" `postscript fontfile` for more details.  With `fontfile delete`, a fontfile",      (char *)" is deleted from the list of embedded files.  `nofontfiles` cleans the list", 
        (char *)" of embedded fonts.",      (char *)"",      (char *)" Examples:",      (char *)"       set terminal postscript default       # old postscript", 
        (char *)"       set terminal postscript enhanced      # old enhpost",      (char *)"       set terminal postscript landscape 22  # old psbig",      (char *)"       set terminal postscript eps 14        # old epsf1",      (char *)"       set terminal postscript eps 22        # old epsf2", 
        (char *)"       set size 0.7,1.4; set term post portrait color \"Times-Roman\" 14",      (char *)"       set term post \"VAGRoundedBT_Regular\" 14 fontfile \"bvrr8a.pfa\"",      (char *)"",      (char *)" Linewidths and pointsizes may be changed with `set style line`.", 
        (char *)"",      (char *)" The `postscript` driver supports about 70 distinct pointtypes, selectable",      (char *)" through the `pointtype` option on `plot` and `set style line`.",      (char *)"", 
        (char *)" Several possibly useful files about `gnuplot`\'s PostScript are included",      (char *)" in the /docs/psdoc subdirectory of the `gnuplot` distribution and at the",      (char *)" distribution sites.  These are \"ps_symbols.gpi\" (a `gnuplot` command file",      (char *)" that, when executed, creates the file \"ps_symbols.ps\" which shows all the", 
        (char *)" symbols available through the `postscript` terminal), \"ps_guide.ps\" (a",      (char *)" PostScript file that contains a summary of the enhanced syntax and a page",      (char *)" showing what the octal codes produce with text and symbol fonts),",      (char *)" \"ps_file.doc\" (a text file that contains a discussion of the organization", 
        (char *)" of a PostScript file written by `gnuplot`), and \"ps_fontfile_doc.tex\"",      (char *)" (a LaTeX file which contains a short documentation concerning the",      (char *)" encapsulation of LaTeX fonts with a glyph table of the math fonts).",      (char *)"", 
        (char *)" A PostScript file is editable, so once `gnuplot` has created one, you are",      (char *)" free to modify it to your heart\'s desire.  See the `editing postscript`",      (char *)" section for some hints.",      (char *)"2 editing postscript", 
        (char *)"?commands set terminal postscript editing",      (char *)"?set terminal postscript editing",      (char *)"?set term postscript editing",      (char *)"?terminal postscript editing", 
        (char *)"?term postscript editing",      (char *)"?editing_postscript",      (char *)"?editing postscript",      (char *)" The PostScript language is a very complex language---far too complex to", 
        (char *)" describe in any detail in this document.  Nevertheless there are some things",      (char *)" in a PostScript file written by `gnuplot` that can be changed without risk of",      (char *)" introducing fatal errors into the file.",      (char *)"", 
        (char *)" For example, the PostScript statement \"/Color true def\" (written into the",      (char *)" file in response to the command `set terminal postscript color`), may be",      (char *)" altered in an obvious way to generate a black-and-white version of a plot.",      (char *)" Similarly line colors, text colors, line weights and symbol sizes can also be", 
        (char *)" altered in straight-forward ways.  Text (titles and labels) can be edited to",      (char *)" correct misspellings or to change fonts.  Anything can be repositioned, and",      (char *)" of course anything can be added or deleted, but modifications such as these",      (char *)" may require deeper knowledge of the PostScript language.", 
        (char *)"",      (char *)" The organization of a PostScript file written by `gnuplot` is discussed in",      (char *)" the text file \"ps_file.doc\" in the docs/ps subdirectory of the gnuplot",      (char *)" source distribution.", 
        (char *)"2 postscript fontfile",      (char *)"?commands set terminal postscript fontfile",      (char *)"?set terminal postscript fontfile",      (char *)"?set term postscript fontfile", 
        (char *)"?terminal postscript fontfile",      (char *)"?term postscript fontfile",      (char *)"?postscript fontfile",      (char *)"?fontfile", 
        (char *)" The `fontfile` or `fontfile add` option takes one file name as argument",      (char *)" and encapsulates this file into the postscript output in order to make",      (char *)" this font available for text elements (labels, tic marks, titles, etc.).",      (char *)" The `fontfile delete` option also takes one file name as argument. It", 
        (char *)" deletes this file name from the list of encapsulated files.",      (char *)"",      (char *)" The postscript terminal understands some",      (char *)" font file formats: Type 1 fonts in ASCII file format (extension \".pfa\"),", 
        (char *)" Type 1 fonts in binary file format (extension \".pfb\"), and TrueType",      (char *)" fonts (extension \".ttf\"). Pfa files are understood directly, pfb and ttf",      (char *)" files are converted on the fly if appropriate conversion tools are",      (char *)" installed (see below). You have to specify the full filename including the", 
        (char *)" extension. Each `fontfile` option takes exact one font file name. This",      (char *)" option can be used multiple times in order to include more than one font",      (char *)" file.",      (char *)"", 
        (char *)" The font file is searched in the working directory and in all directories",      (char *)" listed in the fontpath which is determined by `set fontpath`.",      (char *)" In addition, the fontpath can be set using the environment variable",      (char *)" GNUPLOT_FONTPATH. If this is not set a system dependent default search", 
        (char *)" list is used. See `set fontpath` for more details.",      (char *)"",      (char *)" For using the encapsulated font file you have to specify the font name",      (char *)" (which normally is not the same as the file name). When embedding a", 
        (char *)" font file by using the `fontfile` option in interactive mode, the ",      (char *)" font name is printed on the screen. E.g.",      (char *)"    Font file \'p052004l.pfb\' contains the font \'URWPalladioL-Bold\'. Location:",      (char *)"    /usr/lib/X11/fonts/URW/p052004l.pfb", 
        (char *)"",      (char *)" When using pfa or pfb fonts, you can also find it out by looking into the",      (char *)" font file. There is a line similar to \"/FontName /URWPalladioL-Bold def\".",      (char *)" The middle string without the slash is the fontname, here", 
        (char *)" \"URWPalladioL-Bold\".",      (char *)" For TrueType fonts, this is not so easy since the font name is stored in a",      (char *)" binary format. In addition, they often have spaces in the font names which",      (char *)" is not supported by Type 1 fonts (in which a TrueType is converted on the", 
        (char *)" fly). The font names are changed in order to eliminate the spaces in the",      (char *)" fontnames. The easiest way to find out which font name is generated for",      (char *)" use with gnuplot, start gnuplot in interactive mode and type in",      (char *)" \"set terminal postscript fontfile \'<filename.ttf>\'\".", 
        (char *)"",      (char *)" For converting font files (either ttf or pfb) to pfa format, the conversion",      (char *)" tool has to read the font from a file and write it to standard output. If",      (char *)" the output cannot be written to standard output, on-the-fly conversion is", 
        (char *)" not possible.",      (char *)"",      (char *)" For pfb files \"pfbtops\" is a tool which can do this. If this program",      (char *)" is installed on your system the on the fly conversion should work.", 
        (char *)" Just try to encapsulate a pfb file. If the compiled in program call does",      (char *)" not work correctly you can specify how this program is called by",      (char *)" defining the environment variable GNUPLOT_PFBTOPFA e.g. to",      (char *)" \"pfbtops %s\". The `%s` will be replaced by the font file name and thus", 
        (char *)" has to exist in the string.",      (char *)"",      (char *)" If you don\'t want to do the conversion on the fly but get a pfa file of",      (char *)" the font you can use the tool \"pfb2pfa\" which is written in simple c", 
        (char *)" and should compile with any c compiler.",      (char *)" It is available from many ftp servers, e.g.",      (char *)"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/\">",      (char *)"           ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/", 
        (char *)"^ </a>",      (char *)" In fact, \"pfbtopfa\" and \"pfb2ps\" do the same job. \"pfbtopfa\" puts",      (char *)" the resulting pfa code into a file, whereas \"pfbtops\" writes it to",      (char *)" standard output.", 
        (char *)"",      (char *)" TrueType fonts are converted into Type 1 pfa format, e.g.",      (char *)" by using the tool \"ttf2pt1\" which is available from",      (char *)"^ <a href=\"http://ttf2pt1.sourceforge.net/\">", 
        (char *)"           http://ttf2pt1.sourceforge.net/",      (char *)"^ </a>",      (char *)" If the builtin conversion does not",      (char *)" work, the conversion command can be changed by the environment variable", 
        (char *)" GNUPLOT_TTFTOPFA. For usage with ttf2pt1 it may be set to",      (char *)" \"ttf2pt1 -a -e -W 0 %s - \". Here again, `%s` stands for the",      (char *)" file name.",      (char *)"", 
        (char *)" For special purposes you also can use a pipe (if available for your",      (char *)" operating system). Therefore you start the file name definition with ",      (char *)" the character \"<\" and append a program call. This program has ",      (char *)" to write pfa data to standard output. Thus, a pfa file may be accessed", 
        (char *)" by `set fontfile \"< cat garamond.pfa\"`.",      (char *)"",      (char *)" For example, including Type 1 font files can be used for including the",      (char *)" postscript output in LaTeX documents. The \"european computer modern\"", 
        (char *)" font (which is a variant of the \"computer modern\" font) is available",      (char *)" in pfb format from any CTAN server, e.g.",      (char *)"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/\">",      (char *)"           ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/", 
        (char *)"^ </a>",      (char *)" For example, the file \"sfrm1000.pfb\" contains the normal upright fonts",      (char *)" with serifs in the design size 10pt (font name \"SFRM1000\").",      (char *)" The computer modern fonts, which are still necessary for mathematics,", 
        (char *)" are available from",      (char *)"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky\">",      (char *)"           ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky",      (char *)"^ </a>", 
        (char *)" With these you can use any character available in TeX. However, the",      (char *)" computer modern fonts have a strange encoding. (This is why you should not",      (char *)" use cmr10.pfb for text, but sfrm1000.pfb instead.)",      (char *)" The usage of TeX fonts is shown in one of the demos.", 
        (char *)" The file \"ps_fontfile_doc.tex\" in the /docs/psdoc subdirectory of the",      (char *)" `gnuplot` source distribution contains a table with glyphs of the TeX",      (char *)" mathfonts.",      (char *)"", 
        (char *)" If the font \"CMEX10\" is embedded (file \"cmex10.pfb\") gnuplot defines",      (char *)" the additional font \"CMEX10-Baseline\". It is shifted vertically in order",      (char *)" to fit better to the other glyphs (CMEX10 has its baseline at the top of",      (char *)" the symbols).", 
        (char *)"2 postscript prologue",      (char *)"?commands set terminal postscript prologue",      (char *)"?set terminal postscript prologue",      (char *)"?terminal postscript prologue", 
        (char *)"?postscript prologue",      (char *)"?prologue",      (char *)" Each PostScript output file includes a %%Prolog section and possibly some",      (char *)" additional user-defined sections containing, for example, character encodings.", 
        (char *)" These sections are copied from a set of PostScript prologue files that are",      (char *)" either compiled into the gnuplot executable or stored elsewhere on your",      (char *)" computer. A default directory where these files live is set at the time",      (char *)" gnuplot is built. However, you can override this default either by using the", 
        (char *)" gnuplot command `set psdir` or by defining an environment variable",      (char *)" GNUPLOT_PS_DIR. See `set psdir`.",      (char *)"2 postscript adobeglyphnames",      (char *)"?commands set terminal postscript adobeglyphnames", 
        (char *)"?set terminal postscript adobeglyphnames",      (char *)"?terminal postscript adobeglyphnames",      (char *)"?postscript adobeglyphnames",      (char *)"?adobeglyphnames", 
        (char *)"=UTF-8",      (char *)" This setting is only relevant to PostScript output with UTF-8 encoding.",      (char *)" It controls the names used to describe characters with Unicode entry points",      (char *)" higher than 0x00FF.  That is, all characters outside of the Latin1 set.", 
        (char *)" In general unicode characters do not have a unique name; they have only a",      (char *)" unicode identification code.  However, Adobe have a recommended scheme for",      (char *)" assigning names to certain ranges of characters (extended Latin, Greek, etc).",      (char *)" Some fonts use this scheme, others do not.  By default, gnuplot will use", 
        (char *)" the Adobe glyph names.  E.g. the lower case Greek letter alpha will be called",      (char *)" /alpha.  If you specific `noadobeglyphnames` then instead gnuplot will use",      (char *)" /uni03B1 to describe this character.  If you get this setting wrong, the",      (char *)" character may not be found even if it is present in the font.", 
        (char *)" It is probably always correct to use the default for Adobe fonts, but for",      (char *)" other fonts you may have to try both settings.  See also `fontfile`.",      (char *)"",      (char *)"", 
        (char *)"C#",      (char *)"C#qms",      (char *)"1 qms",      (char *)"?commands set terminal qms", 
        (char *)"?set terminal qms",      (char *)"?set term qms",      (char *)"?terminal qms",      (char *)"?term qms", 
        (char *)"?qms",      (char *)" The `qms` terminal driver supports the QMS/QUIC Laser printer, the Talaris",      (char *)" 1200 and others.  It has no options.",      (char *)"C#", 
        (char *)"C#svg",      (char *)"1 svg",      (char *)"?commands set terminal svg",      (char *)"?set terminal svg", 
        (char *)"?set term svg",      (char *)"?terminal svg",      (char *)"?term svg",      (char *)"?svg", 
        (char *)" This terminal produces files in the W3C Scalable Vector Graphics format.",      (char *)"",      (char *)" Syntax:",      (char *)"       set terminal svg {size <x>,<y> {|fixed|dynamic}}", 
        (char *)"                        {{no}enhanced}",      (char *)"                        {fname \"<font>\"} {fsize <fontsize>}",      (char *)"                        {mouse} {standalone | jsdir <dirname>}",      (char *)"                        {name <plotname>}", 
        (char *)"                        {font \"<fontname>{,<fontsize>}\"}",      (char *)"                        {fontfile <filename>}",      (char *)"                        {rounded|butt} {solid|dashed} {linewidth <lw>}",      (char *)"                        {background <rgb_color>}", 
        (char *)"",      (char *)" where <x> and <y> are the size of the SVG plot to generate,",      (char *)" `dynamic` allows a svg-viewer to resize plot, whereas the default",      (char *)" setting, `fixed`, will request an absolute size.", 
        (char *)"",      (char *)" `linewidth <w>` increases the width of all lines used in the figure",      (char *)" by a factor of <w>.",      (char *)"", 
        (char *)" <font> is the name of the default font to use (default Arial) and",      (char *)" <fontsize> is the font size (in points, default 12). SVG viewing",      (char *)" programs may substitute other fonts when the file is displayed.",      (char *)"", 
        (char *)" The svg terminal supports an enhanced text mode, which allows font",      (char *)" and other formatting commands to be embedded in labels and other text",      (char *)" strings. The enhanced text mode syntax is shared with other gnuplot",      (char *)" terminal types. See `enhanced` for more details.", 
        (char *)"",      (char *)" The `mouse` option tells gnuplot to add support for mouse tracking and for",      (char *)" toggling individual plots on/off by clicking on the corresponding key entry.",      (char *)" By default this is done by including a link that points to a script in a", 
        (char *)" local directory, usually /usr/local/share/gnuplot/<version>/js.",      (char *)" You can change this by using the `jsdir` option to specify either a",      (char *)" different local directory or a general URL. The latter is usually",      (char *)" appropriate if you are embedding the svg into a web page.", 
        (char *)" Alternatively, the `standalone` option embeds the mousing code in the",      (char *)" svg document itself rather than linking to an external resource.",      (char *)"",      (char *)" When an SVG file will be used in conjunction with external files,", 
        (char *)" e.g. if it embeds a PNG image or is referenced by javascript code",      (char *)" in a web page or embedding document, then a unique name is required",      (char *)" to avoid potential conflicting references to other SVG plots.",      (char *)" Use the `name` option to ensure uniqueness.", 
        (char *)"",      (char *)" SVG allows you to embed fonts directly into an SVG document, or to",      (char *)" provide a hypertext link to the desired font. The `fontfile` option",      (char *)" specifies a local file which is copied into the <defs> section of the", 
        (char *)" resulting SVG output file.  This file may either itself contain a font,",      (char *)" or may contain the records necessary to create a hypertext reference to",      (char *)" the desired font. Gnuplot will look for the requested file using the",      (char *)" directory list in the GNUPLOT_FONTPATH environmental variable.", 
        (char *)" NB: You must embed an svg font, not a TrueType or PostScript font.",      (char *)"C#",      (char *)"C#tgif",      (char *)"1 tgif", 
        (char *)"?commands set terminal tgif",      (char *)"?set terminal tgif",      (char *)"?set term tgif",      (char *)"?terminal tgif", 
        (char *)"?term tgif",      (char *)"?tgif",      (char *)" Tgif is an X11-based drawing tool---it has nothing to do with GIF.",      (char *)"", 
        (char *)" The `tgif` driver supports different pointsizes (with `set pointsize`),",      (char *)" different label fonts and font sizes (e.g. `set label \"Hallo\" at x,y font",      (char *)" \"Helvetica,34\"`) and multiple graphs on the page.  The proportions of the",      (char *)" axes are not changed.", 
        (char *)"",      (char *)" Syntax:",      (char *)"       set terminal tgif {portrait | landscape | default} {<[x,y]>}",      (char *)"                         {monochrome | color}", 
        (char *)"                         {{linewidth | lw} <LW>}",      (char *)"                         {solid | dashed}",      (char *)"                         {font \"<fontname>{,<fontsize>}\"}",      (char *)"", 
        (char *)" where <[x,y]> specifies the number of graphs in the x and y directions on the",      (char *)" page, `color` enables color, `linewidth` scales all linewidths by <LW>,",      (char *)" \"<fontname>\" is the name of a valid PostScript font, and <fontsize>",      (char *)" specifies the size of the PostScript font.", 
        (char *)" `defaults` sets all options to their defaults: `portrait`, `[1,1]`, `color`,",      (char *)" `linwidth 1.0`, `dashed`, `\"Helvetica,18\"`.",      (char *)"",      (char *)" The `solid` option is usually prefered if lines are colored, as they often", 
        (char *)" are in the editor.  Hardcopy will be black-and-white, so `dashed` should be",      (char *)" chosen for that.",      (char *)"",      (char *)" Multiplot is implemented in two different ways.", 
        (char *)"",      (char *)" The first multiplot implementation is the standard gnuplot multiplot feature:",      (char *)"",      (char *)"       set terminal tgif", 
        (char *)"       set output \"file.obj\"",      (char *)"       set multiplot",      (char *)"       set origin x01,y01",      (char *)"       set size  xs,ys", 
        (char *)"       plot ...",      (char *)"            ...",      (char *)"       set origin x02,y02",      (char *)"       plot ...", 
        (char *)"       unset multiplot",      (char *)"",      (char *)" See `set multiplot` for further information.",      (char *)"", 
        (char *)" The second version is the [x,y] option for the driver itself.  The advantage",      (char *)" of this implementation is that everything is scaled and placed automatically",      (char *)" without the need for setting origins and sizes; the graphs keep their natural",      (char *)" x/y proportions of 3/2 (or whatever is fixed by `set size`).", 
        (char *)"",      (char *)" If both multiplot methods are selected, the standard method is chosen and a",      (char *)" warning message is given.",      (char *)"", 
        (char *)" Examples of single plots (or standard multiplot):",      (char *)"       set terminal tgif                  # defaults",      (char *)"       set terminal tgif \"Times-Roman,24\"",      (char *)"       set terminal tgif landscape", 
        (char *)"       set terminal tgif landscape solid",      (char *)"",      (char *)" Examples using the built-in multiplot mechanism:",      (char *)"       set terminal tgif portrait [2,4]  # portrait; 2 plots in the x-", 
        (char *)"                                         # and 4 in the y-direction",      (char *)"       set terminal tgif [1,2]           # portrait; 1 plot in the x-",      (char *)"                                         # and 2 in the y-direction",      (char *)"       set terminal tgif landscape [3,3] # landscape; 3 plots in both", 
        (char *)"                                         # directions",      (char *)"C#",      (char *)"C#tkcanvas",      (char *)"1 tkcanvas", 
        (char *)"?commands set terminal tkcanvas",      (char *)"?set terminal tkcanvas",      (char *)"?set term tkcanvas",      (char *)"?terminal tkcanvas", 
        (char *)"?term tkcanvas",      (char *)"?tkcanvas",      (char *)" This terminal driver generates Tk canvas widget commands based on Tcl/Tk",      (char *)" (default) or Perl.  To use it, rebuild `gnuplot` (after uncommenting or", 
        (char *)" inserting the appropriate line in \"term.h\"), then",      (char *)"",      (char *)"  gnuplot> set term tkcanvas {perltk} {interactive}",      (char *)"  gnuplot> set output \'plot.file\'", 
        (char *)"",      (char *)" After invoking \"wish\", execute the following sequence of Tcl/Tk commands:",      (char *)"",      (char *)"  % source plot.file", 
        (char *)"  % canvas .c",      (char *)"  % pack .c",      (char *)"  % gnuplot .c",      (char *)"", 
        (char *)" Or, for Perl/Tk use a program like this:",      (char *)"",      (char *)"  use Tk;",      (char *)"  my $top = MainWindow->new;", 
        (char *)"  my $c = $top->Canvas->pack;",      (char *)"  my $gnuplot = do \"plot.pl\";",      (char *)"  $gnuplot->($c);",      (char *)"  MainLoop;", 
        (char *)"",      (char *)" The code generated by `gnuplot` creates a procedure called \"gnuplot\"",      (char *)" that takes the name of a canvas as its argument.  When the procedure is",      (char *)" called, it clears the canvas, finds the size of the canvas and draws the plot", 
        (char *)" in it, scaled to fit.",      (char *)"",      (char *)" For 2-dimensional plotting (`plot`) two additional procedures are defined:",      (char *)" \"gnuplot_plotarea\" will return a list containing the borders of the plotting", 
        (char *)" area \"xleft, xright, ytop, ybot\" in canvas screen coordinates, while the ranges",      (char *)" of the two axes \"x1min, x1max, y1min, y1max, x2min, x2max, y2min, y2max\" in plot",      (char *)" coordinates can be obtained calling \"gnuplot_axisranges\".",      (char *)" If the \"interactive\" option is specified, mouse clicking on a line segment", 
        (char *)" will print the coordinates of its midpoint to stdout. Advanced actions",      (char *)" can happen instead if the user supplies a procedure named",      (char *)" \"user_gnuplot_coordinates\", which takes the following arguments:",      (char *)" \"win id x1s y1s x2s y2s x1e y1e x2e y2e x1m y1m x2m y2m\",", 
        (char *)" the name of the canvas and the id of the line segment followed by the",      (char *)" coordinates of its start and end point in the two possible axis ranges; the",      (char *)" coordinates of the midpoint are only filled for logarithmic axes.",      (char *)"", 
        (char *)" The current version of `tkcanvas` supports neither `multiplot` nor `replot`.",      (char *)"C#",      (char *)"C#latex",      (char *)"1 latex", 
        (char *)"?commands set terminal emtex",      (char *)"?set terminal emtex",      (char *)"?set term emtex",      (char *)"?terminal emtex", 
        (char *)"?term emtex",      (char *)"?emtex",      (char *)"?commands set terminal latex",      (char *)"?set terminal latex", 
        (char *)"?set term latex",      (char *)"?terminal latex",      (char *)"?term latex",      (char *)"?latex", 
        (char *)" Syntax:",      (char *)"       set terminal {latex | emtex} {default | {courier|roman} {<fontsize>}}",      (char *)"                    {size <XX>{unit}, <YY>{unit}} {rotate | norotate}",      (char *)"", 
        (char *)" By default the plot will inherit font settings from the embedding document.",      (char *)" You have the option of forcing either Courier (cmtt) or Roman (cmr) fonts",      (char *)" instead. In this case you may also specify a fontsize.",      (char *)" Unless your driver is capable of building fonts at any size (e.g. dvips),", 
        (char *)" stick to the standard 10, 11 and 12 point sizes.",      (char *)"",      (char *)" METAFONT users beware: METAFONT does not like odd sizes.",      (char *)"", 
        (char *)" All drivers for LaTeX offer a special way of controlling text positioning:",      (char *)" If any text string begins with \'{\', you also need to include a \'}\' at the",      (char *)" end of the text, and the whole text will be centered both horizontally and",      (char *)" vertically.  If the text string begins with \'[\', you need to follow this with", 
        (char *)" a position specification (up to two out of t,b,l,r), \']{\', the text itself,",      (char *)" and finally \'}\'.  The text itself may be anything LaTeX can typeset as an",      (char *)" LR-box.  \'\\rule{}{}\'s may help for best positioning.",      (char *)"", 
        (char *)" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",      (char *)" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",      (char *)" in the latexsym package, which is part of the base distribution and thus part",      (char *)" of any LaTeX implementation.  Please do not forget to use this package.", 
        (char *)" Other point types use symbols from the amssymb package.",      (char *)"",      (char *)" The default size for the plot is 5 inches by 3 inches. The `size` option",      (char *)" changes this to whatever the user requests. By default the X and Y sizes", 
        (char *)" are taken to be in inches, but other units are possible (currently only cm).",      (char *)"",      (char *)" If \'rotate\' is specified, rotated text, especially a rotated y-axis label,",      (char *)" is possible (the packages graphics or graphicx are needed). The \'stacked\'", 
        (char *)" y-axis label mechanism is then deactivated.",      (char *)"",      (char *)" Examples:",      (char *)" About label positioning:", 
        (char *)" Use gnuplot defaults (mostly sensible, but sometimes not really best):",      (char *)"        set title \'\\LaTeX\\ -- $ \\gamma $\'",      (char *)" Force centering both horizontally and vertically:",      (char *)"        set label \'{\\LaTeX\\ -- $ \\gamma $}\' at 0,0", 
        (char *)" Specify own positioning (top here):",      (char *)"        set xlabel \'[t]{\\LaTeX\\ -- $ \\gamma $}\'",      (char *)" The other label -- account for long ticlabels:",      (char *)"        set ylabel \'[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}\'", 
        (char *)"C#",      (char *)"C#eepic",      (char *)"1 eepic",      (char *)"?commands set terminal eepic", 
        (char *)"?set terminal eepic",      (char *)"?set term eepic",      (char *)"?terminal eepic",      (char *)"?term eepic", 
        (char *)"?eepic",      (char *)" The `eepic` terminal driver supports the extended LaTeX picture environment.",      (char *)" It is an alternative to the `latex` driver.",      (char *)"", 
        (char *)" The output of this terminal is intended for use with the \"eepic.sty\" macro",      (char *)" package for LaTeX.  To use it, you need \"eepic.sty\", \"epic.sty\" and a",      (char *)" printer driver that supports the \"tpic\" \\specials.  If your printer driver",      (char *)" doesn\'t support those \\specials, \"eepicemu.sty\" will enable you to use some", 
        (char *)" of them.",      (char *)" dvips and dvipdfm do support the \"tpic\" \\specials.",      (char *)"",      (char *)" Syntax:", 
        (char *)"    set terminal eepic {default} {color|dashed} {rotate} {size XX,YY}",      (char *)"                       {small|tiny|<fontsize>}",      (char *)"",      (char *)" Options:", 
        (char *)" You can give options in any order you wish.",      (char *)" \'color\' causes gnuplot to produce \\color{...} commands so that the graphs are",      (char *)" colored. Using this option, you must include \\usepackage{color} in the preambel",      (char *)" of your latex document.", 
        (char *)" \'dashed\' will allow dashed line types; without this option, only solid lines",      (char *)" with varying thickness will be used.",      (char *)" \'dashed\' and \'color\' are mutually exclusive; if \'color\' is specified, then",      (char *)" \'dashed\' will be ignored.", 
        (char *)" \'rotate\' will enable true rotated text (by 90 degrees). Otherwise, rotated text",      (char *)" will be typeset with letters stacked above each other. If you use this option",      (char *)" you must include \\usepackage{graphicx} in the preamble.",      (char *)" \'small\' will use \\scriptsize symbols as point markers (Probably does not work", 
        (char *)" with TeX, only LaTeX2e). Default is to use the default math size.",      (char *)" \'tiny\' uses \\scriptscriptstyle symbols.",      (char *)" \'default\' resets all options to their defaults = no color, no dashed lines,",      (char *)" pseudo-rotated (stacked) text, large point symbols.", 
        (char *)" <fontsize> is a number which specifies the font size inside the picture",      (char *)" environment; the unit is pt (points), i.e., 10 pt equals approx. 3.5 mm.",      (char *)" If fontsize is not specified, then all text inside the picture will be set",      (char *)" in \\footnotesize.", 
        (char *)"",      (char *)" Notes:",      (char *)" Remember to escape the # character (or other chars meaningful to (La-)TeX)",      (char *)" by \\\\ (2 backslashes).", 
        (char *)" It seems that dashed lines become solid lines when the vertices of a plot",      (char *)" are too close. (I do not know if that is a general problem with the tpic",      (char *)" specials, or if it is caused by a bug in eepic.sty or dvips/dvipdfm.)",      (char *)" The default size of an eepic plot is 5x3 inches. You can change this using ", 
        (char *)" the `size` terminal option.",      (char *)" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\",",      (char *)" \"\\Box\", etc.  These commands no longer belong to the LaTeX2e core; they are",      (char *)" included in the latexsym package, which is part of the base distribution and", 
        (char *)" thus part of any LaTeX implementation. Please do not forget to use this package.",      (char *)" Instead of latexsym, you can also include the amssymb package.",      (char *)" All drivers for LaTeX offer a special way of controlling text positioning:",      (char *)" If any text string begins with \'{\', you also need to include a \'}\' at the", 
        (char *)" end of the text, and the whole text will be centered both horizontally and",      (char *)" vertically.  If the text string begins with \'[\', you need to follow this with",      (char *)" a position specification (up to two out of t,b,l,r), \']{\', the text itself,",      (char *)" and finally \'}\'.  The text itself may be anything LaTeX can typeset as an", 
        (char *)" LR-box.  \'\\rule{}{}\'s may help for best positioning.",      (char *)"",      (char *)" Examples:",      (char *)" set term eepic", 
        (char *)"   output graphs as eepic macros inside a picture environment;",      (char *)"   \\input the resulting file in your LaTeX document.",      (char *)" set term eepic color tiny rotate 8",      (char *)"   eepic macros with \\color macros, \\scripscriptsize point markers,", 
        (char *)"   true rotated text, and all text set with 8pt.",      (char *)"",      (char *)" About label positioning:",      (char *)" Use gnuplot defaults (mostly sensible, but sometimes not really best):", 
        (char *)"        set title \'\\LaTeX\\ -- $ \\gamma $\'",      (char *)" Force centering both horizontally and vertically:",      (char *)"        set label \'{\\LaTeX\\ -- $ \\gamma $}\' at 0,0",      (char *)" Specify own positioning (top here):", 
        (char *)"        set xlabel \'[t]{\\LaTeX\\ -- $ \\gamma $}\'",      (char *)" The other label -- account for long ticlabels:",      (char *)"        set ylabel \'[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}\'",      (char *)"C#", 
        (char *)"C#tpic",      (char *)"1 tpic",      (char *)"?commands set terminal tpic",      (char *)"?set terminal tpic", 
        (char *)"?set term tpic",      (char *)"?terminal tpic",      (char *)"?term tpic",      (char *)"?tpic", 
        (char *)" The `tpic` terminal driver supports the LaTeX picture environment with tpic",      (char *)" \\specials.  It is an alternative to the `latex` and `eepic` terminal drivers.",      (char *)" Options are the point size, line width, and dot-dash interval.",      (char *)"", 
        (char *)" Syntax:",      (char *)"       set terminal tpic <pointsize> <linewidth> <interval>",      (char *)"",      (char *)" where `pointsize` and `linewidth` are integers in milli-inches and `interval`", 
        (char *)" is a float in inches.  If a non-positive value is specified, the default is",      (char *)" chosen: pointsize = 40, linewidth = 6, interval = 0.1.",      (char *)"",      (char *)" All drivers for LaTeX offer a special way of controlling text positioning:", 
        (char *)" If any text string begins with \'{\', you also need to include a \'}\' at the",      (char *)" end of the text, and the whole text will be centered both horizontally",      (char *)" and vertically by LaTeX. --- If the text string begins with \'[\', you need",      (char *)" to continue it with: a position specification (up to two out of t,b,l,r),", 
        (char *)" \']{\', the text itself, and finally, \'}\'. The text itself may be anything",      (char *)" LaTeX can typeset as an LR-box. \\rule{}{}\'s may help for best positioning.",      (char *)"",      (char *)" Examples:", 
        (char *)" About label positioning:",      (char *)" Use gnuplot defaults (mostly sensible, but sometimes not really best):",      (char *)"        set title \'\\LaTeX\\ -- $ \\gamma $\'",      (char *)" Force centering both horizontally and vertically:", 
        (char *)"        set label \'{\\LaTeX\\ -- $ \\gamma $}\' at 0,0",      (char *)" Specify own positioning (top here):",      (char *)"        set xlabel \'[t]{\\LaTeX\\ -- $ \\gamma $}\'",      (char *)" The other label -- account for long ticlabels:", 
        (char *)"        set ylabel \'[r]{\\LaTeX\\ -- $ \\gamma $\\rule{7mm}{0pt}}\'",      (char *)"C#",      (char *)"C#pstricks",      (char *)"1 pstricks", 
        (char *)"?commands set terminal pstricks",      (char *)"?set terminal pstricks",      (char *)"?set term pstricks",      (char *)"?terminal pstricks", 
        (char *)"?term pstricks",      (char *)"?pstricks",      (char *)" The `pstricks` driver is intended for use with the \"pstricks.sty\" macro",      (char *)" package for LaTeX.  It is an alternative to the `eepic` and `latex` drivers.", 
        (char *)" You need \"pstricks.sty\", and, of course, a printer that understands",      (char *)" PostScript, or a converter such as Ghostscript.",      (char *)"",      (char *)" PSTricks is available via anonymous ftp from the /pub directory at", 
        (char *)" Princeton.edu.  This driver definitely does not come close to using the full",      (char *)" capability of the PSTricks package.",      (char *)"",      (char *)" Syntax:", 
        (char *)"       set terminal pstricks {hacktext | nohacktext} {unit | nounit}",      (char *)"",      (char *)" The first option invokes an ugly hack that gives nicer numbers; the second",      (char *)" has to do with plot scaling.  The defaults are `hacktext` and `nounit`.", 
        (char *)"C#",      (char *)"C#texdraw",      (char *)"1 texdraw",      (char *)"?commands set terminal texdraw", 
        (char *)"?set terminal texdraw",      (char *)"?set term texdraw",      (char *)"?terminal texdraw",      (char *)"?term texdraw", 
        (char *)"?texdraw",      (char *)" The `texdraw` terminal driver supports the LaTeX texdraw environment.  It is",      (char *)" intended for use with \"texdraw.sty\" and \"texdraw.tex\" in the texdraw package.",      (char *)"", 
        (char *)" Points, among other things, are drawn using the LaTeX commands \"\\Diamond\" and",      (char *)" \"\\Box\".  These commands no longer belong to the LaTeX2e core; they are included",      (char *)" in the latexsym package, which is part of the base distribution and thus part",      (char *)" of any LaTeX implementation.  Please do not forget to use this package.", 
        (char *)"",      (char *)" It has no options.",      (char *)"C#",      (char *)"C#mf", 
        (char *)"1 mf",      (char *)"?commands set terminal mf",      (char *)"?set terminal mf",      (char *)"?set term mf", 
        (char *)"?terminal mf",      (char *)"?term mf",      (char *)"?mf",      (char *)"?metafont", 
        (char *)" The `mf` terminal driver creates an input file to the METAFONT program.  Thus a",      (char *)" figure may be used in the TeX document in the same way as is a character.",      (char *)"",      (char *)" To use a picture in a document, the METAFONT program must be run with the", 
        (char *)" output file from `gnuplot` as input.  Thus, the user needs a basic knowledge",      (char *)" of the font creating process and the procedure for including a new font in a",      (char *)" document.  However, if the METAFONT program is set up properly at the local",      (char *)" site, an unexperienced user could perform the operation without much trouble.", 
        (char *)"",      (char *)" The text support is based on a METAFONT character set.  Currently the",      (char *)" Computer Modern Roman font set is input, but the user is in principal free to",      (char *)" choose whatever fonts he or she needs.  The METAFONT source files for the", 
        (char *)" chosen font must be available.  Each character is stored in a separate",      (char *)" picture variable in METAFONT.  These variables may be manipulated (rotated,",      (char *)" scaled etc.) when characters are needed.  The drawback is the interpretation",      (char *)" time in the METAFONT program.  On some machines (i.e. PC) the limited amount", 
        (char *)" of memory available may also cause problems if too many pictures are stored.",      (char *)"",      (char *)" The `mf` terminal has no options.",      (char *)"2 METAFONT Instructions", 
        (char *)"?commands set terminal mf detailed",      (char *)"?set terminal mf detailed",      (char *)"?set term mf detailed",      (char *)"?mf detailed", 
        (char *)"?metafont detailed",      (char *)"",      (char *)" - Set your terminal to METAFONT:",      (char *)"   set terminal mf", 
        (char *)" - Select an output-file, e.g.:",      (char *)"   set output \"myfigures.mf\"",      (char *)" - Create your pictures. Each picture will generate a separate character. Its",      (char *)" default size will be 5*3 inches. You can change the size by saying `set size", 
        (char *)" 0.5,0.5` or whatever fraction of the default size you want to have.",      (char *)"",      (char *)" - Quit `gnuplot`.",      (char *)"", 
        (char *)" - Generate a TFM and GF file by running METAFONT on the output of `gnuplot`.",      (char *)" Since the picture is quite large (5*3 in), you will have to use a version of",      (char *)" METAFONT that has a value of at least 150000 for memmax.  On Unix systems",      (char *)" these are conventionally installed under the name bigmf.  For the following", 
        (char *)" assume that the command virmf stands for a big version of METAFONT.  For",      (char *)" example:",      (char *)"",      (char *)" - Invoke METAFONT:", 
        (char *)"     virmf \'&plain\'",      (char *)" - Select the output device: At the METAFONT prompt (\'*\') type:",      (char *)"     \\mode:=CanonCX;     % or whatever printer you use",      (char *)" - Optionally select a magnification:", 
        (char *)"     mag:=1;             % or whatever you wish",      (char *)" - Input the `gnuplot`-file:",      (char *)"     input myfigures.mf",      (char *)" On a typical Unix machine there will usually be a script called \"mf\" that", 
        (char *)" executes virmf \'&plain\', so you probably can substitute mf for virmf &plain.",      (char *)" This will generate two files: mfput.tfm and mfput.$$$gf (where $$$ indicates",      (char *)" the resolution of your device).  The above can be conveniently achieved by",      (char *)" typing everything on the command line, e.g.:", 
        (char *)" virmf \'&plain\' \'\\mode:=CanonCX; mag:=1; input myfigures.mf\'",      (char *)" In this case the output files will be named myfigures.tfm and",      (char *)" myfigures.300gf.",      (char *)"", 
        (char *)" - Generate a PK file from the GF file using gftopk:",      (char *)"   gftopk myfigures.300gf myfigures.300pk",      (char *)" The name of the output file for gftopk depends on the DVI driver you use.",      (char *)" Ask your local TeX administrator about the naming conventions.  Next, either", 
        (char *)" install the TFM and PK files in the appropriate directories, or set your",      (char *)" environment variables properly.  Usually this involves setting TEXFONTS to",      (char *)" include the current directory and doing the same thing for the environment",      (char *)" variable that your DVI driver uses (no standard name here...).  This step is", 
        (char *)" necessary so that TeX will find the font metric file and your DVI driver will",      (char *)" find the PK file.",      (char *)"",      (char *)" - To include your pictures in your document you have to tell TeX the font:", 
        (char *)"   \\font\\gnufigs=myfigures",      (char *)" Each picture you made is stored in a single character.  The first picture is",      (char *)" character 0, the second is character 1, and so on...  After doing the above",      (char *)" step, you can use the pictures just like any other characters.  Therefore, to", 
        (char *)" place pictures 1 and 2 centered in your document, all you have to do is:",      (char *)"   \\centerline{\\gnufigs\\char0}",      (char *)"   \\centerline{\\gnufigs\\char1}",      (char *)" in plain TeX.  For LaTeX you can, of course, use the picture environment and", 
        (char *)" place the picture wherever you wish by using the \\makebox and \\put macros.",      (char *)"",      (char *)" This conversion saves you a lot of time once you have generated the font;",      (char *)" TeX handles the pictures as characters and uses minimal time to place them,", 
        (char *)" and the documents you make change more often than the pictures do.  It also",      (char *)" saves a lot of TeX memory.  One last advantage of using the METAFONT driver",      (char *)" is that the DVI file really remains device independent, because no \\special",      (char *)" commands are used as in the eepic and tpic drivers.", 
        (char *)"C#",      (char *)"C#mp",      (char *)"1 mp",      (char *)"?commands set terminal mpost", 
        (char *)"?set terminal mp",      (char *)"?set term mp",      (char *)"?terminal mp",      (char *)"?term mp", 
        (char *)"?mp",      (char *)"?metapost",      (char *)"",      (char *)" The `mp` driver produces output intended to be input to the Metapost program.", 
        (char *)" Running Metapost on the file creates EPS files containing the plots. By",      (char *)" default, Metapost passes all text through TeX.  This has the advantage of",      (char *)" allowing essentially  any TeX symbols in titles and labels.",      (char *)"", 
        (char *)" Syntax:",      (char *)"    set term mp {color | colour | monochrome}",      (char *)"                {solid | dashed}",      (char *)"                {notex | tex | latex}", 
        (char *)"                {magnification <magsize>}",      (char *)"                {psnfss | psnfss-version7 | nopsnfss}",      (char *)"                {prologues <value>}",      (char *)"                {a4paper}", 
        (char *)"                {amstex}",      (char *)"                {\"<fontname> {,<fontsize>}\"} ",      (char *)"",      (char *)" The option `color` causes lines to be drawn in color (on a printer or display", 
        (char *)" that supports it), `monochrome` (or nothing) selects black lines.  The option",      (char *)" `solid` draws solid lines, while `dashed` (or nothing) selects lines with",      (char *)" different patterns of dashes.  If `solid` is selected but `color` is not,",      (char *)" nearly all lines will be identical.  This may occasionally be useful, so it is", 
        (char *)" allowed.",      (char *)"",      (char *)" The option `notex` bypasses TeX entirely, therefore no TeX code can be used in",      (char *)" labels under this option.  This is intended for use on old plot files or files", 
        (char *)" that make frequent use of common characters like `$` and `%` that require",      (char *)" special handling in TeX.",      (char *)"",      (char *)" The option `tex` sets the terminal to output its text for TeX to process.", 
        (char *)"",      (char *)" The option `latex` sets the terminal to output its text for processing by",      (char *)" LaTeX. This allows things like \\frac for fractions which LaTeX knows about",      (char *)" but TeX does not.  Note that you must set the environment variable TEX to the", 
        (char *)" name of your LaTeX executable (normally latex) if you use this option or use",      (char *)" `mpost --tex=<name of LaTeX executable> ...`. Otherwise metapost will try and",      (char *)" use TeX to process the text and it won\'t work.",      (char *)"", 
        (char *)" Changing font sizes in TeX has no effect on the size of mathematics, and there",      (char *)" is no foolproof way to make such a change, except by globally  setting a",      (char *)" magnification factor. This is the purpose of the `magnification` option. It",      (char *)" must be followed by a scaling factor. All text (NOT the graphs) will be scaled", 
        (char *)" by this factor. Use this if you have math that you want at some size other",      (char *)" than the default 10pt. Unfortunately, all math will be the same size, but see",      (char *)" the discussion below on editing the MP output. `mag` will also work under",      (char *)" `notex` but there seems no point in using it as the font size option (below)", 
        (char *)" works as well.",      (char *)"",      (char *)" The option `psnfss` uses postscript fonts in combination with LaTeX. Since",      (char *)" this option only makes sense, if LaTeX is being used, the `latex` option is selected", 
        (char *)" automatically. This option includes the following packages for LaTeX:",      (char *)" inputenc(latin1), fontenc(T1), mathptmx, helvet(scaled=09.2), courier, latexsym ",      (char *)" and textcomp.",      (char *)"", 
        (char *)" The option `psnfss-version7` uses also postscript fonts in LaTeX (option `latex`",      (char *)" is also automatically selected), but uses the following packages with LaTeX:",      (char *)" inputenc(latin1), fontenc(T1), times, mathptmx, helvet and courier.",      (char *)"", 
        (char *)" The option `nopsnfss` is the default and uses the standard font (cmr10 if not",      (char *)" otherwise specified).",      (char *)"",      (char *)" The option `prologues` takes a value as an additional argument and adds the line", 
        (char *)" `prologues:=<value>` to the metapost file. If a value of `2` is specified metapost",      (char *)" uses postscript fonts to generate the eps-file, so that the result can be viewed",      (char *)" using e.g. ghostscript. Normally the output of metapost uses TeX fonts and therefore",      (char *)" has to be included in a (La)TeX file before you can look at it.", 
        (char *)"",      (char *)" The option `noprologues` is the default. No additional line specifying the prologue",      (char *)" will be added.",      (char *)"", 
        (char *)" The option `a4paper` adds a `[a4paper]` to the documentclass. Normally letter paper",      (char *)" is used (default). Since this option is only used in case of LaTeX, the `latex` option",      (char *)" is selected automatically.",      (char *)"", 
        (char *)" The option `amstex` automatically selects the `latex` option and includes the following",      (char *)" LaTeX packages: amsfonts, amsmath(intlimits). By default these packages are not",      (char *)" included.",      (char *)"", 
        (char *)" A name in quotes selects the font that will be used when no explicit font is",      (char *)" given in a `set label` or `set title`.  A name recognized by TeX (a TFM file",      (char *)" exists) must be used.  The default is \"cmr10\" unless `notex` is selected,",      (char *)" then it is \"pcrr8r\" (Courier).  Even under `notex`, a TFM file is needed by", 
        (char *)" Metapost. The file `pcrr8r.tfm` is the name given to Courier in LaTeX\'s psnfss",      (char *)" package.  If you change the font from the `notex` default, choose a font that",      (char *)" matches the ASCII encoding at least in the range 32-126.  `cmtt10` almost",      (char *)" works, but it has a nonblank character in position 32 (space).", 
        (char *)"",      (char *)" The size can be any number between 5.0 and 99.99.  If it is omitted, 10.0 is",      (char *)" used.  It is advisable to use `magstep` sizes: 10 times an integer or",      (char *)" half-integer power of 1.2, rounded to two decimals, because those are the most", 
        (char *)" available sizes of fonts in TeX systems.",      (char *)"",      (char *)" All the options are optional.  If font information is given, it must be at the",      (char *)" end, with size (if present) last.  The size is needed to select a size for the", 
        (char *)" font, even if the font name includes size information.  For example,",      (char *)" `set term mp \"cmtt12\"` selects cmtt12 shrunk to the default size 10.  This",      (char *)" is probably not what you want or you would have used cmtt10.",      (char *)"", 
        (char *)" The following common ascii characters need special treatment in TeX:",      (char *)"    $, &, #, %, _;  |, <, >;  ^, ~,  \\, {, and }",      (char *)" The five characters $, #, &, _, and % can simply be escaped, e.g., `\\$`.",      (char *)" The three characters <, >, and | can be wrapped in math mode, e.g., `$<$`.", 
        (char *)" The remainder require some TeX work-arounds.  Any good book on TeX will give",      (char *)" some guidance.",      (char *)"",      (char *)" If you type your labels inside double quotes, backslashes in TeX code need to", 
        (char *)" be escaped (doubled). Using single quotes will avoid having to do this, but",      (char *)" then you cannot use `\\n` for line breaks.  As of this writing, version 3.7 of",      (char *)" gnuplot processes titles given in a `plot` command differently than in other",      (char *)" places, and backslashes in TeX commands need to be doubled regardless of the", 
        (char *)" style of quotes.",      (char *)"",      (char *)" Metapost pictures are typically used in TeX documents.  Metapost deals with",      (char *)" fonts pretty much the same way TeX does, which is different from most other", 
        (char *)" document preparation programs.  If the picture is included in a LaTeX document",      (char *)" using the graphics package, or in a plainTeX document via epsf.tex, and then",      (char *)" converted to PostScript with dvips (or other dvi-to-ps converter), the text in",      (char *)" the plot will usually be handled correctly.  However, the text may not appear", 
        (char *)" if you send the Metapost output as-is to a PostScript interpreter.",      (char *)"",      (char *)"2 Metapost Instructions",      (char *)"?commands set terminal mp detailed", 
        (char *)"?set terminal mp detailed",      (char *)"?set term mp detailed",      (char *)"?mp detailed",      (char *)"?metapost detailed", 
        (char *)"",      (char *)" - Set your terminal to Metapost, e.g.:",      (char *)"    set terminal mp mono \"cmtt12\" 12",      (char *)"", 
        (char *)" - Select an output-file, e.g.:",      (char *)"    set output \"figure.mp\"",      (char *)"",      (char *)" - Create your pictures.  Each plot (or multiplot group) will generate a", 
        (char *)" separate Metapost beginfig...endfig group.  Its default size will be 5 by 3",      (char *)" inches.  You can change the size by saying `set size 0.5,0.5` or whatever",      (char *)" fraction of the default size you want to have.",      (char *)"", 
        (char *)" - Quit gnuplot.",      (char *)"",      (char *)" - Generate EPS files by running Metapost on the output of gnuplot:",      (char *)"    mpost figure.mp  OR  mp figure.mp", 
        (char *)" The name of the Metapost program depends on the system, typically `mpost` for",      (char *)" a Unix machine and `mp` on many others.  Metapost will generate one EPS file",      (char *)" for each picture.",      (char *)"", 
        (char *)" - To include your pictures in your document you can use the graphics package",      (char *)" in LaTeX or epsf.tex in plainTeX:",      (char *)"    \\usepackage{graphics} % LaTeX",      (char *)"    \\input epsf.tex       % plainTeX", 
        (char *)" If you use a driver other than dvips for converting TeX DVI output to PS, you",      (char *)" may need to add the following line in your LaTeX document:",      (char *)"    \\DeclareGraphicsRule{*}{eps}{*}{}",      (char *)" Each picture you made is in a separate file.  The first picture is in, e.g.,", 
        (char *)" figure.0, the second in figure.1, and so on....  To place the third picture in",      (char *)" your document, for example, all you have to do is:",      (char *)"    \\includegraphics{figure.2} % LaTeX",      (char *)"    \\epsfbox{figure.2}         % plainTeX", 
        (char *)"",      (char *)" The advantage, if any, of the mp terminal over a postscript terminal is",      (char *)" editable output.  Considerable effort went into making this output as clean as",      (char *)" possible.  For those knowledgeable in the Metapost language, the default line", 
        (char *)" types and colors can be changed by editing the arrays `lt[]` and `col[]`.",      (char *)" The choice of solid vs dashed lines, and color vs black lines can be change by",      (char *)" changing the values assigned to the booleans `dashedlines` and `colorlines`.",      (char *)" If the default `tex` option was in effect, global changes to the text of", 
        (char *)" labels can be achieved by editing the `vebatimtex...etex` block.  In",      (char *)" particular, a LaTeX preamble can be added if desired, and then LaTeX\'s",      (char *)" built-in size changing commands can be used for maximum flexibility. Be sure",      (char *)" to set the appropriate MP configuration variable to force Metapost to run", 
        (char *)" LaTeX instead of plainTeX.",      (char *)"C#",      (char *)"C#context",      (char *)"1 context", 
        (char *)"?commands set terminal context",      (char *)"?set terminal context",      (char *)"?terminal context",      (char *)"?set term context", 
        (char *)"?term context",      (char *)"?context",      (char *)" ConTeXt is a macro package for TeX, highly integrated with Metapost",      (char *)" (for drawing figures) and intended for creation of high-quality PDF documents.", 
        (char *)" The terminal outputs Metafun source, which can be edited manually,",      (char *)" but you should be able to configure most things from outside.",      (char *)"",      (char *)" For an average user of ConTeXt + gnuplot module it\'s recommended to refer to", 
        (char *)" `Using ConTeXt` rather than reading this page",      (char *)" or to read the manual of the gnuplot module for ConTeXt.",      (char *)"",      (char *)" The `context` terminal supports the following options:", 
        (char *)"",      (char *)" Syntax:",      (char *)"      set term context {default}",      (char *)"              {defaultsize | size <scale> | size <xsize>{in|cm}, <ysize>{in|cm}}", 
        (char *)"              {input | standalone}",      (char *)"              {timestamp | notimestamp}",      (char *)"              {noheader | header \"<header>\"}",      (char *)"              {color | colour | monochrome}", 
        (char *)"              {rounded | mitered | beveled} {round | butt | squared}",      (char *)"              {dashed | solid} {dashlength | dl <dl>}",      (char *)"              {linewidth | lw <lw>}",      (char *)"              {fontscale <fontscale>}", 
        (char *)"              {mppoints | texpoints}",      (char *)"              {inlineimages | externalimages}",      (char *)"              {defaultfont | font \"{<fontname>}{,<fontsize>}\"}",      (char *)"", 
        (char *)" In non-standalone (`input`) graphic only parameters `size` to select graphic",      (char *)" size, `fontscale` to scale all the labels for a factor <fontscale>",      (char *)" and font size, make sense, the rest is silently",      (char *)" ignored and should be configured in the .tex file which inputs the graphic.", 
        (char *)" It\'s highly recommended to set the proper fontsize if document font differs from",      (char *)" 12pt, so that gnuplot will know how much space to reserve for labels.",      (char *)"",      (char *)" `default` resets all the options to their default values.", 
        (char *)"",      (char *)" `defaultsize` sets the plot size to 5in,3in.",      (char *)" `size` <scale> sets the plot size to <scale> times <default value>.",      (char *)" If two arguments are given (separated with \',\'), the first one sets", 
        (char *)" the horizontal size and the second one the vertical size.",      (char *)" Size may be given without units (in which case it means relative to the default",      (char *)" value), with inches (\'in\') or centimeters (\'cm\').",      (char *)"", 
        (char *)" `input` (default) creates a graphic that can be included into another ConTeXt",      (char *)" document.",      (char *)" `standalone` adds some lines, so that the document might be compiled as-is.",      (char *)" You might also want to add `header` in that case.", 
        (char *)"",      (char *)" Use `header` for any additional settings/definitions/macros",      (char *)" that you might want to include in a standalone graphic. `noheader` is the default.",      (char *)"", 
        (char *)" `notimestamp` prevents printing creation time in comments",      (char *)" (if version control is used, one may prefer not to commit new version when only date changes).",      (char *)"",      (char *)" `color` to make color plots is the default, but `monochrome` doesn\'t do anything special yet.", 
        (char *)" If you have any good ideas how the behaviour should differ to suit the monochrome printers better,",      (char *)" your suggestions are welcome.",      (char *)"",      (char *)" `rounded` (default), `mitered` and `beveled` control the shape of line joins.", 
        (char *)" `round` (default), `butt` and `squared` control the shape of line caps.",      (char *)" See PostScript or PDF Reference Manual for explanation. For wild-behaving functions",      (char *)" and thick lines",      (char *)" it is better to use `rounded` and `round` to prevent sharp corners in line joins.", 
        (char *)" (Some general support for this should be added to Gnuplot, so that the same options",      (char *)" could be set for each line (style) separately).",      (char *)"",      (char *)" `dashed` (default) uses different dash patterns for different line types,", 
        (char *)" `solid` draws all plots with solid lines.",      (char *)"",      (char *)" `dashlength` or `dl` scales the length of the dashed-line segments by <dl>.",      (char *)" `linewidth` or `lw` scales all linewidths by <lw>.", 
        (char *)" (lw 1 stands for 0.5bp, which is the default line width when drawing with Metapost.)",      (char *)" `fontscale` scales text labels for factor <fontscale> relative to default document font.",      (char *)"",      (char *)" `mppoints` uses predefined point shapes, drawn in Metapost.", 
        (char *)" `texpoints` uses easily configurable set of symbols, defined with ConTeXt",      (char *)" in the following way:",      (char *)"      \\defineconversion[my own points][+,{\\ss x},\\mathematics{\\circ}]",      (char *)"      \\setupGNUPLOTterminal[context][points=tex,pointset=my own points]", 
        (char *)"",      (char *)" `inlineimages` writes binary images to a string and only works in ConTeXt MKIV.",      (char *)" `externalimages` writes PNG files to disk and also works with ConTeXt MKII.",      (char *)" Gnuplot needs to have support for PNG images built in for this to work.", 
        (char *)"",      (char *)" With `font` you can set font name and size in standalone graphics.",      (char *)" In non-standalone (`input`) mode only the font size is important",      (char *)" to reserve enough space for text labels.", 
        (char *)" The command",      (char *)"      set term context font \"myfont,ss,10\"",      (char *)" will result in",      (char *)"      \\setupbodyfont[myfont,ss,10pt]", 
        (char *)" If you additionaly set `fontscale` to 0.8 for example,",      (char *)" then the resulting font will be 8pt big and",      (char *)"      set label ... font \"myfont,12\"",      (char *)" will come out as 9.6pt.", 
        (char *)"",      (char *)" It is your own responsibility to provide proper typescripts (and header),",      (char *)" otherwise switching the font will have no effect.",      (char *)" For a standard font in ConTeXt MKII (pdfTeX) you could use:", 
        (char *)"      set terminal context standalone header \'\\usetypescript[iwona][ec]\' \\",      (char *)"          font \"iwona,ss,11\"",      (char *)" Please take a look into ConTeXt documentation, wiki or mailing list (archives)",      (char *)" for any up-to-date information about font usage.", 
        (char *)"",      (char *)" Examples:",      (char *)"      set terminal context size 10cm, 5cm     # 10cm, 5cm",      (char *)"      set terminal context size 4in, 3in      # 4in, 3in", 
        (char *)" For standalone (whole-page) plots with labels in UTF-8 encoding:",      (char *)"      set terminal context standalone header \'\\enableregime[utf-8]\'",      (char *)"",      (char *)"2 Requirements", 
        (char *)" You need gnuplot module for ConTeXt",      (char *)"^ <a href=\"http://ctan.org/pkg/context-gnuplot\">",      (char *)"      http://ctan.org/pkg/context-gnuplot",      (char *)"^ </a>", 
        (char *)" and a recent version of ConTeXt.",      (char *)" If you want to call gnuplot on-the-fly, you also need write18 enabled.",      (char *)" In most TeX distributions this can be set with shell_escape=t in texmf.cnf.",      (char *)"", 
        (char *)" See",      (char *)"^ <a href=\"http://wiki.contextgarden.net/Gnuplot\">",      (char *)"           http://wiki.contextgarden.net/Gnuplot",      (char *)"^ </a>", 
        (char *)" for details about this terminal and for more exhaustive help & examples.",      (char *)"",      (char *)"2 Calling gnuplot from ConTeXt",      (char *)" The easiest way to make plots in ConTeXt documents is", 
        (char *)"      \\usemodule[gnuplot]",      (char *)"      \\starttext",      (char *)"      \\title{How to draw nice plots with {\\sc gnuplot}?}",      (char *)"      \\startGNUPLOTscript[sin]", 
        (char *)"      set format y \"%.1f\"",      (char *)"      plot sin(x) t \'$\\sin(x)$\'",      (char *)"      \\stopGNUPLOTscript",      (char *)"      \\useGNUPLOTgraphic[sin]", 
        (char *)"      \\stoptext",      (char *)" This will run gnuplot automatically and include the resulting figure in the document.",      (char *)"C#",      (char *)((void *)0)};
#line 86
char *get_line(char *buffer , int max , FILE *fp ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2gih.c"
void convert(FILE *inf , FILE *outf ) ;
#line 60
void process_line(char *line___1 , FILE *b ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2gih.c"
static char line[1024]  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2gih.c"
void convert(FILE *inf , FILE *outf ) 
{ 
  char *tmp ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    tmp = get_line(line, (int )sizeof(line), inf);
    }
#line 101
    if (! tmp) {
#line 101
      goto while_break;
    }
    {
#line 102
    process_line(line, outf);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2gih.c"
static int line_count  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/doc2gih.c"
void process_line(char *line___1 , FILE *b ) 
{ 
  unsigned short const   **tmp ;

  {
#line 111
  line_count ++;
  {
#line 114
  if ((int )*(line___1 + 0) == 63) {
#line 114
    goto case_63;
  }
#line 118
  if ((int )*(line___1 + 0) == 64) {
#line 118
    goto case_64;
  }
#line 121
  if ((int )*(line___1 + 0) == 35) {
#line 121
    goto case_35;
  }
#line 124
  if ((int )*(line___1 + 0) == 61) {
#line 124
    goto case_61;
  }
#line 127
  if ((int )*(line___1 + 0) == 70) {
#line 127
    goto case_70;
  }
#line 130
  if ((int )*(line___1 + 0) == 37) {
#line 130
    goto case_37;
  }
#line 133
  if ((int )*(line___1 + 0) == 94) {
#line 133
    goto case_94;
  }
#line 137
  if ((int )*(line___1 + 0) == 32) {
#line 137
    goto case_32;
  }
#line 137
  if ((int )*(line___1 + 0) == 10) {
#line 137
    goto case_32;
  }
#line 141
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 115
  fputs((char const   */* __restrict  */)line___1, (FILE */* __restrict  */)b);
  }
#line 116
  goto switch_break;
  case_64: /* CIL Label */ 
#line 119
  goto switch_break;
  case_35: /* CIL Label */ 
#line 122
  goto switch_break;
  case_61: /* CIL Label */ 
#line 125
  goto switch_break;
  case_70: /* CIL Label */ 
#line 128
  goto switch_break;
  case_37: /* CIL Label */ 
#line 131
  goto switch_break;
  case_94: /* CIL Label */ 
#line 134
  goto switch_break;
  case_32: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 138
  fputs((char const   */* __restrict  */)line___1, (FILE */* __restrict  */)b);
  }
#line 139
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 142
  tmp = __ctype_b_loc();
  }
#line 142
  if (! ((int const   )*(*tmp + (int )*(line___1 + 0)) & 2048)) {
    {
#line 145
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown control code \'%c\' in column 1, line %d\n",
            (int )*(line___1 + 0), line_count);
    }
  }
#line 147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 580 "../src/stdfn.h"
char *safe_strncpy(char *d , char const   *s , size_t n ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
int termdoc_lineno  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
char termdoc_filename[80]  ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
_Bool single_top_level  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
static int line___0  =    -1;
#line 87 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
static int level  =    0;
#line 88 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
static int save_lineno  ;
#line 89 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
static int seen_a_one  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
char *get_line(char *buffer , int max , FILE *fp ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 91
  if (line___0 == -1) {
    read_another_line: 
    {
#line 98
    tmp = fgets((char */* __restrict  */)buffer, max, (FILE */* __restrict  */)fp);
    }
#line 98
    if (! tmp) {
#line 99
      return ((char *)((void *)0));
    }
#line 100
    termdoc_lineno ++;
#line 101
    if ((int )*(buffer + 0) == 67) {
#line 102
      if ((int )*(buffer + 1) == 35) {
        {
#line 104
        safe_strncpy(termdoc_filename, (char const   *)(buffer + 2), sizeof(termdoc_filename));
#line 105
        tmp___0 = strlen((char const   *)(termdoc_filename));
#line 105
        termdoc_filename[tmp___0 - 1UL] = (char )'\000';
#line 106
        termdoc_lineno = 0;
        }
      }
#line 108
      goto read_another_line;
    }
#line 112
    if ((int )single_top_level == 1) {
#line 113
      if ((int )*(buffer + 0) == 49) {
#line 114
        if (seen_a_one) {
#line 115
          *(buffer + 0) = (char )'2';
        }
#line 117
        seen_a_one = 1;
      }
    }
#line 120
    if ((int )*(buffer + 0) != 60) {
#line 121
      return (buffer);
    }
#line 124
    save_lineno = termdoc_lineno;
#line 125
    termdoc_lineno = -1;
#line 126
    level = (int )*(buffer + 1) - 49;
#line 127
    line___0 = 0;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int )*(termtext[line___0] + 0) == 67)) {
#line 135
      goto while_break;
    }
#line 136
    if ((int )*(termtext[line___0] + 1) == 35) {
      {
#line 137
      safe_strncpy(termdoc_filename, (char const   *)(termtext[line___0] + 2), sizeof(termdoc_filename));
#line 138
      termdoc_lineno = 0;
      }
    }
#line 140
    termdoc_lineno ++;
#line 142
    line___0 ++;
#line 142
    if (! termtext[line___0]) {
      {
#line 146
      termdoc_lineno = save_lineno;
#line 148
      line___0 = -1;
#line 149
      tmp___1 = get_line(buffer, max, fp);
      }
#line 149
      return (tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  termdoc_lineno ++;
#line 159
  safe_strncpy(buffer, (char const   *)termtext[line___0], (size_t )max);
#line 162
  tmp___2 = strlen((char const   *)buffer);
  }
#line 162
  if (tmp___2 == (size_t )(max - 1)) {
#line 163
    *(buffer + (max - 2)) = (char )'\n';
  } else {
    {
#line 165
    strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 167
  tmp___3 = __ctype_b_loc();
  }
#line 167
  if ((int const   )*(*tmp___3 + (int )*(buffer + 0)) & 2048) {
#line 168
    *(buffer + 0) = (char )((int )*(buffer + 0) + level);
  }
#line 170
  line___0 ++;
#line 170
  if (! termtext[line___0]) {
#line 175
    termdoc_lineno = save_lineno;
#line 177
    line___0 = -1;
  }
#line 179
  return (buffer);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/gnuplot-4.6.4/docs/termdoc.c"
char *safe_strncpy(char *d , char const   *s , size_t n ) 
{ 
  char *ret ;
  size_t tmp ;

  {
  {
#line 193
  ret = strncpy((char */* __restrict  */)d, (char const   */* __restrict  */)s, n);
#line 194
  tmp = strlen(s);
  }
#line 194
  if (tmp >= n) {
#line 195
    *(d + (n - 1UL)) = (char )'\000';
  }
#line 197
  return (ret);
}
}
