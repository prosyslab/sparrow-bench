/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 52 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.h"
struct avl_node_t {
   struct avl_node_t *next ;
   struct avl_node_t *prev ;
   struct avl_node_t *parent ;
   struct avl_node_t *left ;
   struct avl_node_t *right ;
   void *item ;
   unsigned int count ;
   unsigned char depth ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.h"
typedef struct avl_node_t avl_node_t;
#line 67 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.h"
struct avl_tree_t {
   avl_node_t *head ;
   avl_node_t *tail ;
   avl_node_t *top ;
   int (*cmp)(void const   * , void const   * ) ;
   void (*freeitem)(void * ) ;
};
#line 67 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.h"
typedef struct avl_tree_t avl_tree_t;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.h"
avl_tree_t *avl_init_tree(avl_tree_t *rc , int (*cmp)(void const   * , void const   * ) ,
                          void (*freeitem)(void * ) ) ;
#line 85
avl_tree_t *avl_alloc_tree(int (*cmp)(void const   * , void const   * ) , void (*freeitem)(void * ) ) ;
#line 90
void avl_free_tree(avl_tree_t *avltree ) ;
#line 95
void avl_clear_tree(avl_tree_t *avltree ) ;
#line 100
void avl_free_nodes(avl_tree_t *avltree ) ;
#line 104
avl_node_t *avl_init_node(avl_node_t *newnode , void *item ) ;
#line 110
avl_node_t *avl_insert(avl_tree_t *avltree , void *item ) ;
#line 115
avl_node_t *avl_insert_node(avl_tree_t *avltree , avl_node_t *newnode ) ;
#line 121
avl_node_t *avl_insert_top(avl_tree_t *avltree , avl_node_t *newnode ) ;
#line 126
avl_node_t *avl_insert_before(avl_tree_t *avltree , avl_node_t *node , avl_node_t *newnode ) ;
#line 131
avl_node_t *avl_insert_after(avl_tree_t *avltree , avl_node_t *node , avl_node_t *newnode ) ;
#line 137
void avl_unlink_node(avl_tree_t *avltree , avl_node_t *avlnode ) ;
#line 143
void *avl_delete_node(avl_tree_t *avltree , avl_node_t *avlnode ) ;
#line 149
void *avl_delete(avl_tree_t *avltree , void const   *item ) ;
#line 155
avl_node_t *avl_fixup_node(avl_tree_t *avltree , avl_node_t *newnode ) ;
#line 164
int avl_search_closest(avl_tree_t const   *avltree , void const   *item , avl_node_t **avlnode ) ;
#line 169
avl_node_t *avl_search(avl_tree_t const   *avltree , void const   *item ) ;
#line 174
unsigned int avl_count(avl_tree_t const   *avltree ) ;
#line 179
avl_node_t *avl_at(avl_tree_t const   *avltree , unsigned int index ) ;
#line 183
unsigned int avl_index(avl_node_t const   *avlnode ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
static void avl_rebalance(avl_tree_t *avltree , avl_node_t *avlnode ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
static int avl_check_balance(avl_node_t *avlnode ) 
{ 
  int d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 68
  if (avlnode->right) {
#line 68
    tmp = (int )(avlnode->right)->depth;
  } else {
#line 68
    tmp = 0;
  }
#line 68
  if (avlnode->left) {
#line 68
    tmp___0 = (int )(avlnode->left)->depth;
  } else {
#line 68
    tmp___0 = 0;
  }
#line 68
  d = tmp - tmp___0;
#line 69
  if (d < -1) {
#line 69
    tmp___2 = -1;
  } else {
#line 69
    if (d > 1) {
#line 69
      tmp___1 = 1;
    } else {
#line 69
      tmp___1 = 0;
    }
#line 69
    tmp___2 = tmp___1;
  }
#line 69
  return (tmp___2);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
unsigned int avl_count(avl_tree_t const   *avltree ) 
{ 
  unsigned int tmp ;

  {
#line 94
  if (avltree->top) {
#line 94
    tmp = (avltree->top)->count;
  } else {
#line 94
    tmp = 0U;
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_at(avl_tree_t const   *avltree , unsigned int index ) 
{ 
  avl_node_t *avlnode ;
  unsigned int c ;

  {
#line 101
  avlnode = (avl_node_t *)avltree->top;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! avlnode) {
#line 103
      goto while_break;
    }
#line 104
    if (avlnode->left) {
#line 104
      c = (avlnode->left)->count;
    } else {
#line 104
      c = 0U;
    }
#line 106
    if (index < c) {
#line 107
      avlnode = avlnode->left;
    } else
#line 108
    if (index > c) {
#line 109
      avlnode = avlnode->right;
#line 110
      index -= c + 1U;
    } else {
#line 112
      return (avlnode);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  return ((avl_node_t *)((void *)0));
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
unsigned int avl_index(avl_node_t const   *avlnode ) 
{ 
  avl_node_t *next ;
  unsigned int c ;
  unsigned int tmp ;

  {
#line 122
  if (avlnode->left) {
#line 122
    c = (avlnode->left)->count;
  } else {
#line 122
    c = 0U;
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    next = (avl_node_t *)avlnode->parent;
#line 124
    if (! next) {
#line 124
      goto while_break;
    }
#line 125
    if ((unsigned long )avlnode == (unsigned long )next->right) {
#line 126
      if (next->left) {
#line 126
        tmp = (next->left)->count;
      } else {
#line 126
        tmp = 0U;
      }
#line 126
      c += tmp + 1U;
    }
#line 127
    avlnode = (avl_node_t const   *)next;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (c);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
int avl_search_closest(avl_tree_t const   *avltree , void const   *item , avl_node_t **avlnode ) 
{ 
  avl_node_t *node ;
  int (*cmp)(void const   * , void const   * ) ;
  int c ;

  {
#line 139
  if (! avlnode) {
#line 140
    avlnode = & node;
  }
#line 142
  node = (avl_node_t *)avltree->top;
#line 144
  if (! node) {
#line 145
    *avlnode = (avl_node_t *)((void *)0);
#line 145
    return (0);
  }
#line 147
  cmp = (int (*)(void const   * , void const   * ))avltree->cmp;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    c = (*cmp)(item, (void const   *)node->item);
    }
#line 152
    if (c < 0) {
#line 153
      if (node->left) {
#line 154
        node = node->left;
      } else {
#line 156
        *avlnode = node;
#line 156
        return (-1);
      }
    } else
#line 157
    if (c > 0) {
#line 158
      if (node->right) {
#line 159
        node = node->right;
      } else {
#line 161
        *avlnode = node;
#line 161
        return (1);
      }
    } else {
#line 163
      *avlnode = node;
#line 163
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_search(avl_tree_t const   *avltree , void const   *item ) 
{ 
  avl_node_t *node ;
  avl_node_t *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 175
  tmp___1 = avl_search_closest(avltree, item, & node);
  }
#line 175
  if (tmp___1) {
#line 175
    tmp___0 = (avl_node_t *)((void *)0);
  } else {
#line 175
    tmp___0 = node;
  }
#line 175
  return (tmp___0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_tree_t *avl_init_tree(avl_tree_t *rc , int (*cmp)(void const   * , void const   * ) ,
                          void (*freeitem)(void * ) ) 
{ 


  {
#line 179
  if (rc) {
#line 180
    rc->head = (avl_node_t *)((void *)0);
#line 181
    rc->tail = (avl_node_t *)((void *)0);
#line 182
    rc->top = (avl_node_t *)((void *)0);
#line 183
    rc->cmp = cmp;
#line 184
    rc->freeitem = freeitem;
  }
#line 186
  return (rc);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_tree_t *avl_alloc_tree(int (*cmp)(void const   * , void const   * ) , void (*freeitem)(void * ) ) 
{ 
  void *tmp ;
  avl_tree_t *tmp___0 ;

  {
  {
#line 190
  tmp = malloc(sizeof(avl_tree_t ));
#line 190
  tmp___0 = avl_init_tree((avl_tree_t *)tmp, cmp, freeitem);
  }
#line 190
  return (tmp___0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void avl_clear_tree(avl_tree_t *avltree ) 
{ 
  avl_node_t *tmp ;
  avl_node_t *tmp___0 ;

  {
#line 194
  tmp___0 = (avl_node_t *)((void *)0);
#line 194
  avltree->tail = tmp___0;
#line 194
  tmp = tmp___0;
#line 194
  avltree->head = tmp;
#line 194
  avltree->top = tmp;
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void avl_free_nodes(avl_tree_t *avltree ) 
{ 
  avl_node_t *node ;
  avl_node_t *next ;
  void (*freeitem)(void * ) ;

  {
#line 201
  freeitem = avltree->freeitem;
#line 203
  node = avltree->head;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! node) {
#line 203
      goto while_break;
    }
#line 204
    next = node->next;
#line 205
    if (freeitem) {
      {
#line 206
      (*freeitem)(node->item);
      }
    }
    {
#line 207
    free((void *)node);
#line 203
    node = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  avl_clear_tree(avltree);
  }
#line 210
  return;
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void avl_free_tree(avl_tree_t *avltree ) 
{ 


  {
  {
#line 220
  avl_free_nodes(avltree);
#line 221
  free((void *)avltree);
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
static void avl_clear_node(avl_node_t *newnode ) 
{ 
  struct avl_node_t *tmp ;

  {
#line 225
  tmp = (struct avl_node_t *)((void *)0);
#line 225
  newnode->right = tmp;
#line 225
  newnode->left = tmp;
#line 227
  newnode->count = 1U;
#line 230
  newnode->depth = (unsigned char)1;
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_init_node(avl_node_t *newnode , void *item ) 
{ 


  {
#line 235
  if (newnode) {
#line 237
    newnode->item = item;
  }
#line 239
  return (newnode);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_insert_top(avl_tree_t *avltree , avl_node_t *newnode ) 
{ 
  struct avl_node_t *tmp ;
  struct avl_node_t *tmp___0 ;
  avl_node_t *tmp___1 ;
  avl_node_t *tmp___2 ;

  {
  {
#line 243
  avl_clear_node(newnode);
#line 244
  tmp___0 = (struct avl_node_t *)((void *)0);
#line 244
  newnode->parent = tmp___0;
#line 244
  tmp = tmp___0;
#line 244
  newnode->next = tmp;
#line 244
  newnode->prev = tmp;
#line 245
  tmp___2 = newnode;
#line 245
  avltree->top = tmp___2;
#line 245
  tmp___1 = tmp___2;
#line 245
  avltree->tail = tmp___1;
#line 245
  avltree->head = tmp___1;
  }
#line 246
  return (newnode);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_insert_before(avl_tree_t *avltree , avl_node_t *node , avl_node_t *newnode ) 
{ 
  avl_node_t *tmp ;
  avl_node_t *tmp___0 ;
  avl_node_t *tmp___1 ;
  avl_node_t *tmp___2 ;

  {
#line 250
  if (! node) {
#line 251
    if (avltree->tail) {
      {
#line 251
      tmp = avl_insert_after(avltree, avltree->tail, newnode);
#line 251
      tmp___1 = tmp;
      }
    } else {
      {
#line 251
      tmp___0 = avl_insert_top(avltree, newnode);
#line 251
      tmp___1 = tmp___0;
      }
    }
#line 251
    return (tmp___1);
  }
#line 255
  if (node->left) {
    {
#line 256
    tmp___2 = avl_insert_after(avltree, node->prev, newnode);
    }
#line 256
    return (tmp___2);
  }
  {
#line 258
  avl_clear_node(newnode);
#line 260
  newnode->next = node;
#line 261
  newnode->parent = node;
#line 263
  newnode->prev = node->prev;
  }
#line 264
  if (node->prev) {
#line 265
    (node->prev)->next = newnode;
  } else {
#line 267
    avltree->head = newnode;
  }
  {
#line 268
  node->prev = newnode;
#line 270
  node->left = newnode;
#line 271
  avl_rebalance(avltree, node);
  }
#line 272
  return (newnode);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_insert_after(avl_tree_t *avltree , avl_node_t *node , avl_node_t *newnode ) 
{ 
  avl_node_t *tmp ;
  avl_node_t *tmp___0 ;
  avl_node_t *tmp___1 ;
  avl_node_t *tmp___2 ;

  {
#line 276
  if (! node) {
#line 277
    if (avltree->head) {
      {
#line 277
      tmp = avl_insert_before(avltree, avltree->head, newnode);
#line 277
      tmp___1 = tmp;
      }
    } else {
      {
#line 277
      tmp___0 = avl_insert_top(avltree, newnode);
#line 277
      tmp___1 = tmp___0;
      }
    }
#line 277
    return (tmp___1);
  }
#line 281
  if (node->right) {
    {
#line 282
    tmp___2 = avl_insert_before(avltree, node->next, newnode);
    }
#line 282
    return (tmp___2);
  }
  {
#line 284
  avl_clear_node(newnode);
#line 286
  newnode->prev = node;
#line 287
  newnode->parent = node;
#line 289
  newnode->next = node->next;
  }
#line 290
  if (node->next) {
#line 291
    (node->next)->prev = newnode;
  } else {
#line 293
    avltree->tail = newnode;
  }
  {
#line 294
  node->next = newnode;
#line 296
  node->right = newnode;
#line 297
  avl_rebalance(avltree, node);
  }
#line 298
  return (newnode);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_insert_node(avl_tree_t *avltree , avl_node_t *newnode ) 
{ 
  avl_node_t *node ;
  avl_node_t *tmp ;
  int tmp___0 ;
  avl_node_t *tmp___1 ;
  avl_node_t *tmp___2 ;

  {
#line 304
  if (! avltree->top) {
    {
#line 305
    tmp = avl_insert_top(avltree, newnode);
    }
#line 305
    return (tmp);
  }
  {
#line 307
  tmp___0 = avl_search_closest((avl_tree_t const   *)avltree, (void const   *)newnode->item,
                               & node);
  }
  {
#line 308
  if (tmp___0 == -1) {
#line 308
    goto case_neg_1;
  }
#line 310
  if (tmp___0 == 1) {
#line 310
    goto case_1;
  }
#line 307
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 309
  tmp___1 = avl_insert_before(avltree, node, newnode);
  }
#line 309
  return (tmp___1);
  case_1: /* CIL Label */ 
  {
#line 311
  tmp___2 = avl_insert_after(avltree, node, newnode);
  }
#line 311
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
#line 314
  return ((avl_node_t *)((void *)0));
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_insert(avl_tree_t *avltree , void *item ) 
{ 
  avl_node_t *newnode ;
  void *tmp ;
  avl_node_t *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 325
  tmp = malloc(sizeof(avl_node_t ));
#line 325
  newnode = avl_init_node((avl_node_t *)tmp, item);
  }
#line 326
  if (newnode) {
    {
#line 327
    tmp___0 = avl_insert_node(avltree, newnode);
    }
#line 327
    if (tmp___0) {
#line 328
      return (newnode);
    }
    {
#line 329
    free((void *)newnode);
#line 330
    tmp___1 = __errno_location();
#line 330
    *tmp___1 = 17;
    }
  }
#line 332
  return ((avl_node_t *)((void *)0));
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void avl_unlink_node(avl_tree_t *avltree , avl_node_t *avlnode ) 
{ 
  avl_node_t *parent ;
  avl_node_t **superparent ;
  avl_node_t *subst ;
  avl_node_t *left ;
  avl_node_t *right ;
  avl_node_t *balnode ;
  struct avl_node_t **tmp ;

  {
#line 347
  if (avlnode->prev) {
#line 348
    (avlnode->prev)->next = avlnode->next;
  } else {
#line 350
    avltree->head = avlnode->next;
  }
#line 352
  if (avlnode->next) {
#line 353
    (avlnode->next)->prev = avlnode->prev;
  } else {
#line 355
    avltree->tail = avlnode->prev;
  }
#line 357
  parent = avlnode->parent;
#line 359
  if (parent) {
#line 359
    if ((unsigned long )avlnode == (unsigned long )parent->left) {
#line 359
      tmp = & parent->left;
    } else {
#line 359
      tmp = & parent->right;
    }
#line 359
    superparent = tmp;
  } else {
#line 359
    superparent = & avltree->top;
  }
#line 363
  left = avlnode->left;
#line 364
  right = avlnode->right;
#line 365
  if (! left) {
#line 366
    *superparent = right;
#line 367
    if (right) {
#line 368
      right->parent = parent;
    }
#line 369
    balnode = parent;
  } else
#line 370
  if (! right) {
#line 371
    *superparent = left;
#line 372
    left->parent = parent;
#line 373
    balnode = parent;
  } else {
#line 375
    subst = avlnode->prev;
#line 376
    if ((unsigned long )subst == (unsigned long )left) {
#line 377
      balnode = subst;
    } else {
#line 379
      balnode = subst->parent;
#line 380
      balnode->right = subst->left;
#line 381
      if (balnode->right) {
#line 382
        (balnode->right)->parent = balnode;
      }
#line 383
      subst->left = left;
#line 384
      left->parent = subst;
    }
#line 386
    subst->right = right;
#line 387
    subst->parent = parent;
#line 388
    right->parent = subst;
#line 389
    *superparent = subst;
  }
  {
#line 392
  avl_rebalance(avltree, balnode);
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void *avl_delete_node(avl_tree_t *avltree , avl_node_t *avlnode ) 
{ 
  void *item ;

  {
#line 396
  item = (void *)0;
#line 397
  if (avlnode) {
    {
#line 398
    item = avlnode->item;
#line 399
    avl_unlink_node(avltree, avlnode);
    }
#line 400
    if (avltree->freeitem) {
      {
#line 401
      (*(avltree->freeitem))(item);
      }
    }
    {
#line 402
    free((void *)avlnode);
    }
  }
#line 404
  return (item);
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
void *avl_delete(avl_tree_t *avltree , void const   *item ) 
{ 
  avl_node_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 408
  tmp = avl_search((avl_tree_t const   *)avltree, item);
#line 408
  tmp___0 = avl_delete_node(avltree, tmp);
  }
#line 408
  return (tmp___0);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
avl_node_t *avl_fixup_node(avl_tree_t *avltree , avl_node_t *newnode ) 
{ 
  avl_node_t *oldnode ;
  avl_node_t *node ;

  {
#line 412
  oldnode = (avl_node_t *)((void *)0);
#line 414
  if (! avltree) {
#line 415
    return ((avl_node_t *)((void *)0));
  } else
#line 414
  if (! newnode) {
#line 415
    return ((avl_node_t *)((void *)0));
  }
#line 417
  node = newnode->prev;
#line 418
  if (node) {
#line 419
    oldnode = node->next;
#line 420
    node->next = newnode;
  } else {
#line 422
    avltree->head = newnode;
  }
#line 425
  node = newnode->next;
#line 426
  if (node) {
#line 427
    oldnode = node->prev;
#line 428
    node->prev = newnode;
  } else {
#line 430
    avltree->tail = newnode;
  }
#line 433
  node = newnode->parent;
#line 434
  if (node) {
#line 435
    if ((unsigned long )node->left == (unsigned long )oldnode) {
#line 436
      node->left = newnode;
    } else {
#line 438
      node->right = newnode;
    }
  } else {
#line 440
    oldnode = avltree->top;
#line 441
    avltree->top = newnode;
  }
#line 444
  return (oldnode);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/libavl-0.3.5/avl.c"
static void avl_rebalance(avl_tree_t *avltree , avl_node_t *avlnode ) 
{ 
  avl_node_t *child ;
  avl_node_t *gchild ;
  avl_node_t *parent ;
  avl_node_t **superparent ;
  struct avl_node_t **tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned int tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  unsigned int tmp___95 ;
  unsigned int tmp___96 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;

  {
#line 462
  parent = avlnode;
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! avlnode) {
#line 464
      goto while_break;
    }
#line 465
    parent = avlnode->parent;
#line 467
    if (parent) {
#line 467
      if ((unsigned long )avlnode == (unsigned long )parent->left) {
#line 467
        tmp = & parent->left;
      } else {
#line 467
        tmp = & parent->right;
      }
#line 467
      superparent = tmp;
    } else {
#line 467
      superparent = & avltree->top;
    }
    {
#line 471
    tmp___0 = avl_check_balance(avlnode);
    }
    {
#line 472
    if (tmp___0 == -1) {
#line 472
      goto case_neg_1;
    }
#line 526
    if (tmp___0 == 1) {
#line 526
      goto case_1;
    }
#line 580
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 473
    child = avlnode->left;
#line 475
    if (child->left) {
#line 475
      tmp___46 = (int )(child->left)->depth;
    } else {
#line 475
      tmp___46 = 0;
    }
#line 475
    if (child->right) {
#line 475
      tmp___47 = (int )(child->right)->depth;
    } else {
#line 475
      tmp___47 = 0;
    }
#line 475
    if (tmp___46 >= tmp___47) {
#line 483
      avlnode->left = child->right;
#line 484
      if (avlnode->left) {
#line 485
        (avlnode->left)->parent = avlnode;
      }
#line 486
      child->right = avlnode;
#line 487
      avlnode->parent = child;
#line 488
      *superparent = child;
#line 489
      child->parent = parent;
#line 491
      if (avlnode->left) {
#line 491
        tmp___1 = (avlnode->left)->count;
      } else {
#line 491
        tmp___1 = 0U;
      }
#line 491
      if (avlnode->right) {
#line 491
        tmp___2 = (avlnode->right)->count;
      } else {
#line 491
        tmp___2 = 0U;
      }
#line 491
      avlnode->count = (tmp___1 + tmp___2) + 1U;
#line 492
      if (child->left) {
#line 492
        tmp___3 = (child->left)->count;
      } else {
#line 492
        tmp___3 = 0U;
      }
#line 492
      if (child->right) {
#line 492
        tmp___4 = (child->right)->count;
      } else {
#line 492
        tmp___4 = 0U;
      }
#line 492
      child->count = (tmp___3 + tmp___4) + 1U;
#line 495
      if (avlnode->left) {
#line 495
        tmp___10 = (int )(avlnode->left)->depth;
      } else {
#line 495
        tmp___10 = 0;
      }
#line 495
      if (avlnode->right) {
#line 495
        tmp___11 = (int )(avlnode->right)->depth;
      } else {
#line 495
        tmp___11 = 0;
      }
#line 495
      if (tmp___10 > tmp___11) {
#line 495
        if (avlnode->left) {
#line 495
          tmp___7 = (int )(avlnode->left)->depth;
        } else {
#line 495
          tmp___7 = 0;
        }
#line 495
        tmp___9 = tmp___7;
      } else {
#line 495
        if (avlnode->right) {
#line 495
          tmp___8 = (int )(avlnode->right)->depth;
        } else {
#line 495
          tmp___8 = 0;
        }
#line 495
        tmp___9 = tmp___8;
      }
#line 495
      avlnode->depth = (unsigned char )(tmp___9 + 1);
#line 496
      if (child->left) {
#line 496
        tmp___17 = (int )(child->left)->depth;
      } else {
#line 496
        tmp___17 = 0;
      }
#line 496
      if (child->right) {
#line 496
        tmp___18 = (int )(child->right)->depth;
      } else {
#line 496
        tmp___18 = 0;
      }
#line 496
      if (tmp___17 > tmp___18) {
#line 496
        if (child->left) {
#line 496
          tmp___14 = (int )(child->left)->depth;
        } else {
#line 496
          tmp___14 = 0;
        }
#line 496
        tmp___16 = tmp___14;
      } else {
#line 496
        if (child->right) {
#line 496
          tmp___15 = (int )(child->right)->depth;
        } else {
#line 496
          tmp___15 = 0;
        }
#line 496
        tmp___16 = tmp___15;
      }
#line 496
      child->depth = (unsigned char )(tmp___16 + 1);
    } else {
#line 499
      gchild = child->right;
#line 500
      avlnode->left = gchild->right;
#line 501
      if (avlnode->left) {
#line 502
        (avlnode->left)->parent = avlnode;
      }
#line 503
      child->right = gchild->left;
#line 504
      if (child->right) {
#line 505
        (child->right)->parent = child;
      }
#line 506
      gchild->right = avlnode;
#line 507
      if (gchild->right) {
#line 508
        (gchild->right)->parent = gchild;
      }
#line 509
      gchild->left = child;
#line 510
      if (gchild->left) {
#line 511
        (gchild->left)->parent = gchild;
      }
#line 512
      *superparent = gchild;
#line 513
      gchild->parent = parent;
#line 515
      if (avlnode->left) {
#line 515
        tmp___19 = (avlnode->left)->count;
      } else {
#line 515
        tmp___19 = 0U;
      }
#line 515
      if (avlnode->right) {
#line 515
        tmp___20 = (avlnode->right)->count;
      } else {
#line 515
        tmp___20 = 0U;
      }
#line 515
      avlnode->count = (tmp___19 + tmp___20) + 1U;
#line 516
      if (child->left) {
#line 516
        tmp___21 = (child->left)->count;
      } else {
#line 516
        tmp___21 = 0U;
      }
#line 516
      if (child->right) {
#line 516
        tmp___22 = (child->right)->count;
      } else {
#line 516
        tmp___22 = 0U;
      }
#line 516
      child->count = (tmp___21 + tmp___22) + 1U;
#line 517
      if (gchild->left) {
#line 517
        tmp___23 = (gchild->left)->count;
      } else {
#line 517
        tmp___23 = 0U;
      }
#line 517
      if (gchild->right) {
#line 517
        tmp___24 = (gchild->right)->count;
      } else {
#line 517
        tmp___24 = 0U;
      }
#line 517
      gchild->count = (tmp___23 + tmp___24) + 1U;
#line 520
      if (avlnode->left) {
#line 520
        tmp___30 = (int )(avlnode->left)->depth;
      } else {
#line 520
        tmp___30 = 0;
      }
#line 520
      if (avlnode->right) {
#line 520
        tmp___31 = (int )(avlnode->right)->depth;
      } else {
#line 520
        tmp___31 = 0;
      }
#line 520
      if (tmp___30 > tmp___31) {
#line 520
        if (avlnode->left) {
#line 520
          tmp___27 = (int )(avlnode->left)->depth;
        } else {
#line 520
          tmp___27 = 0;
        }
#line 520
        tmp___29 = tmp___27;
      } else {
#line 520
        if (avlnode->right) {
#line 520
          tmp___28 = (int )(avlnode->right)->depth;
        } else {
#line 520
          tmp___28 = 0;
        }
#line 520
        tmp___29 = tmp___28;
      }
#line 520
      avlnode->depth = (unsigned char )(tmp___29 + 1);
#line 521
      if (child->left) {
#line 521
        tmp___37 = (int )(child->left)->depth;
      } else {
#line 521
        tmp___37 = 0;
      }
#line 521
      if (child->right) {
#line 521
        tmp___38 = (int )(child->right)->depth;
      } else {
#line 521
        tmp___38 = 0;
      }
#line 521
      if (tmp___37 > tmp___38) {
#line 521
        if (child->left) {
#line 521
          tmp___34 = (int )(child->left)->depth;
        } else {
#line 521
          tmp___34 = 0;
        }
#line 521
        tmp___36 = tmp___34;
      } else {
#line 521
        if (child->right) {
#line 521
          tmp___35 = (int )(child->right)->depth;
        } else {
#line 521
          tmp___35 = 0;
        }
#line 521
        tmp___36 = tmp___35;
      }
#line 521
      child->depth = (unsigned char )(tmp___36 + 1);
#line 522
      if (gchild->left) {
#line 522
        tmp___44 = (int )(gchild->left)->depth;
      } else {
#line 522
        tmp___44 = 0;
      }
#line 522
      if (gchild->right) {
#line 522
        tmp___45 = (int )(gchild->right)->depth;
      } else {
#line 522
        tmp___45 = 0;
      }
#line 522
      if (tmp___44 > tmp___45) {
#line 522
        if (gchild->left) {
#line 522
          tmp___41 = (int )(gchild->left)->depth;
        } else {
#line 522
          tmp___41 = 0;
        }
#line 522
        tmp___43 = tmp___41;
      } else {
#line 522
        if (gchild->right) {
#line 522
          tmp___42 = (int )(gchild->right)->depth;
        } else {
#line 522
          tmp___42 = 0;
        }
#line 522
        tmp___43 = tmp___42;
      }
#line 522
      gchild->depth = (unsigned char )(tmp___43 + 1);
    }
#line 525
    goto switch_break;
    case_1: /* CIL Label */ 
#line 527
    child = avlnode->right;
#line 529
    if (child->right) {
#line 529
      tmp___93 = (int )(child->right)->depth;
    } else {
#line 529
      tmp___93 = 0;
    }
#line 529
    if (child->left) {
#line 529
      tmp___94 = (int )(child->left)->depth;
    } else {
#line 529
      tmp___94 = 0;
    }
#line 529
    if (tmp___93 >= tmp___94) {
#line 537
      avlnode->right = child->left;
#line 538
      if (avlnode->right) {
#line 539
        (avlnode->right)->parent = avlnode;
      }
#line 540
      child->left = avlnode;
#line 541
      avlnode->parent = child;
#line 542
      *superparent = child;
#line 543
      child->parent = parent;
#line 545
      if (avlnode->left) {
#line 545
        tmp___48 = (avlnode->left)->count;
      } else {
#line 545
        tmp___48 = 0U;
      }
#line 545
      if (avlnode->right) {
#line 545
        tmp___49 = (avlnode->right)->count;
      } else {
#line 545
        tmp___49 = 0U;
      }
#line 545
      avlnode->count = (tmp___48 + tmp___49) + 1U;
#line 546
      if (child->left) {
#line 546
        tmp___50 = (child->left)->count;
      } else {
#line 546
        tmp___50 = 0U;
      }
#line 546
      if (child->right) {
#line 546
        tmp___51 = (child->right)->count;
      } else {
#line 546
        tmp___51 = 0U;
      }
#line 546
      child->count = (tmp___50 + tmp___51) + 1U;
#line 549
      if (avlnode->left) {
#line 549
        tmp___57 = (int )(avlnode->left)->depth;
      } else {
#line 549
        tmp___57 = 0;
      }
#line 549
      if (avlnode->right) {
#line 549
        tmp___58 = (int )(avlnode->right)->depth;
      } else {
#line 549
        tmp___58 = 0;
      }
#line 549
      if (tmp___57 > tmp___58) {
#line 549
        if (avlnode->left) {
#line 549
          tmp___54 = (int )(avlnode->left)->depth;
        } else {
#line 549
          tmp___54 = 0;
        }
#line 549
        tmp___56 = tmp___54;
      } else {
#line 549
        if (avlnode->right) {
#line 549
          tmp___55 = (int )(avlnode->right)->depth;
        } else {
#line 549
          tmp___55 = 0;
        }
#line 549
        tmp___56 = tmp___55;
      }
#line 549
      avlnode->depth = (unsigned char )(tmp___56 + 1);
#line 550
      if (child->left) {
#line 550
        tmp___64 = (int )(child->left)->depth;
      } else {
#line 550
        tmp___64 = 0;
      }
#line 550
      if (child->right) {
#line 550
        tmp___65 = (int )(child->right)->depth;
      } else {
#line 550
        tmp___65 = 0;
      }
#line 550
      if (tmp___64 > tmp___65) {
#line 550
        if (child->left) {
#line 550
          tmp___61 = (int )(child->left)->depth;
        } else {
#line 550
          tmp___61 = 0;
        }
#line 550
        tmp___63 = tmp___61;
      } else {
#line 550
        if (child->right) {
#line 550
          tmp___62 = (int )(child->right)->depth;
        } else {
#line 550
          tmp___62 = 0;
        }
#line 550
        tmp___63 = tmp___62;
      }
#line 550
      child->depth = (unsigned char )(tmp___63 + 1);
    } else {
#line 553
      gchild = child->left;
#line 554
      avlnode->right = gchild->left;
#line 555
      if (avlnode->right) {
#line 556
        (avlnode->right)->parent = avlnode;
      }
#line 557
      child->left = gchild->right;
#line 558
      if (child->left) {
#line 559
        (child->left)->parent = child;
      }
#line 560
      gchild->left = avlnode;
#line 561
      if (gchild->left) {
#line 562
        (gchild->left)->parent = gchild;
      }
#line 563
      gchild->right = child;
#line 564
      if (gchild->right) {
#line 565
        (gchild->right)->parent = gchild;
      }
#line 566
      *superparent = gchild;
#line 567
      gchild->parent = parent;
#line 569
      if (avlnode->left) {
#line 569
        tmp___66 = (avlnode->left)->count;
      } else {
#line 569
        tmp___66 = 0U;
      }
#line 569
      if (avlnode->right) {
#line 569
        tmp___67 = (avlnode->right)->count;
      } else {
#line 569
        tmp___67 = 0U;
      }
#line 569
      avlnode->count = (tmp___66 + tmp___67) + 1U;
#line 570
      if (child->left) {
#line 570
        tmp___68 = (child->left)->count;
      } else {
#line 570
        tmp___68 = 0U;
      }
#line 570
      if (child->right) {
#line 570
        tmp___69 = (child->right)->count;
      } else {
#line 570
        tmp___69 = 0U;
      }
#line 570
      child->count = (tmp___68 + tmp___69) + 1U;
#line 571
      if (gchild->left) {
#line 571
        tmp___70 = (gchild->left)->count;
      } else {
#line 571
        tmp___70 = 0U;
      }
#line 571
      if (gchild->right) {
#line 571
        tmp___71 = (gchild->right)->count;
      } else {
#line 571
        tmp___71 = 0U;
      }
#line 571
      gchild->count = (tmp___70 + tmp___71) + 1U;
#line 574
      if (avlnode->left) {
#line 574
        tmp___77 = (int )(avlnode->left)->depth;
      } else {
#line 574
        tmp___77 = 0;
      }
#line 574
      if (avlnode->right) {
#line 574
        tmp___78 = (int )(avlnode->right)->depth;
      } else {
#line 574
        tmp___78 = 0;
      }
#line 574
      if (tmp___77 > tmp___78) {
#line 574
        if (avlnode->left) {
#line 574
          tmp___74 = (int )(avlnode->left)->depth;
        } else {
#line 574
          tmp___74 = 0;
        }
#line 574
        tmp___76 = tmp___74;
      } else {
#line 574
        if (avlnode->right) {
#line 574
          tmp___75 = (int )(avlnode->right)->depth;
        } else {
#line 574
          tmp___75 = 0;
        }
#line 574
        tmp___76 = tmp___75;
      }
#line 574
      avlnode->depth = (unsigned char )(tmp___76 + 1);
#line 575
      if (child->left) {
#line 575
        tmp___84 = (int )(child->left)->depth;
      } else {
#line 575
        tmp___84 = 0;
      }
#line 575
      if (child->right) {
#line 575
        tmp___85 = (int )(child->right)->depth;
      } else {
#line 575
        tmp___85 = 0;
      }
#line 575
      if (tmp___84 > tmp___85) {
#line 575
        if (child->left) {
#line 575
          tmp___81 = (int )(child->left)->depth;
        } else {
#line 575
          tmp___81 = 0;
        }
#line 575
        tmp___83 = tmp___81;
      } else {
#line 575
        if (child->right) {
#line 575
          tmp___82 = (int )(child->right)->depth;
        } else {
#line 575
          tmp___82 = 0;
        }
#line 575
        tmp___83 = tmp___82;
      }
#line 575
      child->depth = (unsigned char )(tmp___83 + 1);
#line 576
      if (gchild->left) {
#line 576
        tmp___91 = (int )(gchild->left)->depth;
      } else {
#line 576
        tmp___91 = 0;
      }
#line 576
      if (gchild->right) {
#line 576
        tmp___92 = (int )(gchild->right)->depth;
      } else {
#line 576
        tmp___92 = 0;
      }
#line 576
      if (tmp___91 > tmp___92) {
#line 576
        if (gchild->left) {
#line 576
          tmp___88 = (int )(gchild->left)->depth;
        } else {
#line 576
          tmp___88 = 0;
        }
#line 576
        tmp___90 = tmp___88;
      } else {
#line 576
        if (gchild->right) {
#line 576
          tmp___89 = (int )(gchild->right)->depth;
        } else {
#line 576
          tmp___89 = 0;
        }
#line 576
        tmp___90 = tmp___89;
      }
#line 576
      gchild->depth = (unsigned char )(tmp___90 + 1);
    }
#line 579
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 582
    if (avlnode->left) {
#line 582
      tmp___95 = (avlnode->left)->count;
    } else {
#line 582
      tmp___95 = 0U;
    }
#line 582
    if (avlnode->right) {
#line 582
      tmp___96 = (avlnode->right)->count;
    } else {
#line 582
      tmp___96 = 0U;
    }
#line 582
    avlnode->count = (tmp___95 + tmp___96) + 1U;
#line 585
    if (avlnode->left) {
#line 585
      tmp___102 = (int )(avlnode->left)->depth;
    } else {
#line 585
      tmp___102 = 0;
    }
#line 585
    if (avlnode->right) {
#line 585
      tmp___103 = (int )(avlnode->right)->depth;
    } else {
#line 585
      tmp___103 = 0;
    }
#line 585
    if (tmp___102 > tmp___103) {
#line 585
      if (avlnode->left) {
#line 585
        tmp___99 = (int )(avlnode->left)->depth;
      } else {
#line 585
        tmp___99 = 0;
      }
#line 585
      tmp___101 = tmp___99;
    } else {
#line 585
      if (avlnode->right) {
#line 585
        tmp___100 = (int )(avlnode->right)->depth;
      } else {
#line 585
        tmp___100 = 0;
      }
#line 585
      tmp___101 = tmp___100;
    }
#line 585
    avlnode->depth = (unsigned char )(tmp___101 + 1);
    switch_break: /* CIL Label */ ;
    }
#line 588
    avlnode = parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return;
}
}
