/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 25 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nbname {
   char ascii_name[16] ;
   uint16_t rr_flags ;
};
#line 46 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nbname_response_header {
   uint16_t transaction_id ;
   uint16_t flags ;
   uint16_t question_count ;
   uint16_t answer_count ;
   uint16_t name_service_count ;
   uint16_t additional_record_count ;
   char question_name[34] ;
   uint16_t question_type ;
   uint16_t question_class ;
   uint32_t ttl ;
   uint16_t rdata_length ;
   uint8_t number_of_names ;
};
#line 65 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nbname_response_footer {
   uint8_t adapter_address[6] ;
   uint8_t version_major ;
   uint8_t version_minor ;
   uint16_t duration ;
   uint16_t frmps_received ;
   uint16_t frmps_transmitted ;
   uint16_t iframe_receive_errors ;
   uint16_t transmit_aborts ;
   uint32_t transmitted ;
   uint32_t received ;
   uint16_t iframe_transmit_errors ;
   uint16_t no_receive_buffer ;
   uint16_t tl_timeouts ;
   uint16_t ti_timeouts ;
   uint16_t free_ncbs ;
   uint16_t ncbs ;
   uint16_t max_ncbs ;
   uint16_t no_transmit_buffers ;
   uint16_t max_datagram ;
   uint16_t pending_sessions ;
   uint16_t max_sessions ;
   uint16_t packet_sessions ;
};
#line 92 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nb_host_info {
   struct nbname_response_header *header ;
   struct nbname *names ;
   struct nbname_response_footer *footer ;
   int is_broken ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.h"
struct ip_range {
   unsigned long start_ip ;
   unsigned long end_ip ;
};
#line 3 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.h"
struct list_item {
   struct list_item *next ;
   struct list_item *prev ;
   unsigned long content ;
};
#line 9 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.h"
struct list {
   struct list_item *head ;
};
#line 30 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nbname_request {
   uint16_t transaction_id ;
   uint16_t flags ;
   uint16_t question_count ;
   uint16_t answer_count ;
   uint16_t name_service_count ;
   uint16_t additional_record_count ;
   char question_name[34] ;
   uint16_t question_type ;
   uint16_t question_class ;
};
#line 46 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
typedef struct nbname_response_header nbname_response_header_t;
#line 65 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
typedef struct nbname_response_footer nbname_response_footer_t;
#line 99 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
struct nb_service {
   char nb_name[16] ;
   uint8_t service_number ;
   int unique ;
   char *service_name ;
};
#line 99 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.h"
typedef struct nb_service nb_service_t;
#line 128 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
union __anonunion_x_33 {
   char bytes[4] ;
   uint32_t all ;
};
#line 138 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
union __anonunion_x_34 {
   char bytes[2] ;
   uint16_t all ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 73
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 19 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.h"
int is_ip(char *string , struct ip_range *range ) ;
#line 25
int is_range1(char *string , struct ip_range *range ) ;
#line 30
int next_address(struct ip_range  const  *range , struct in_addr  const  *prev_addr ,
                 struct in_addr *next_addr ) ;
#line 37
int is_range2(char *string , struct ip_range *range ) ;
#line 13 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.h"
struct list *new_list(void) ;
#line 17
void delete_list(struct list *list ) ;
#line 21
int insert(struct list *lst , unsigned long content ) ;
#line 19 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
int quiet  =    0;
#line 21
char *getnbservicename(uint8_t service , int unique , char *name ) ;
#line 22
struct nb_host_info *parse_response(char *buff , int buffsize ) ;
#line 23
int in_list(struct list *lst , unsigned long content ) ;
#line 24
void send_query(int sock , struct in_addr dest_addr , uint32_t rtt_base ) ;
#line 26 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
void print_banner(void) 
{ 


  {
  {
#line 27
  printf((char const   */* __restrict  */)"\nNBTscan version 1.5.1. Copyright (C) 1999-2003 Alla Bezroutchko.\n");
#line 28
  printf((char const   */* __restrict  */)"This is a free software and it comes with absolutely no warranty.\n");
#line 29
  printf((char const   */* __restrict  */)"You can use, distribute and modify it under terms of GNU GPL.\n\n");
  }
#line 30
  return;
}
}
#line 32 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
void usage(void) 
{ 


  {
  {
#line 33
  printf((char const   */* __restrict  */)"Usage:\nnbtscan [-v] [-d] [-e] [-l] [-t timeout] [-b bandwidth] [-r] [-q] [-s separator] [-m retransmits] (-f filename)|(<scan_range>) \n");
#line 34
  printf((char const   */* __restrict  */)"\t-v\t\tverbose output. Print all names received\n");
#line 35
  printf((char const   */* __restrict  */)"\t\t\tfrom each host\n");
#line 36
  printf((char const   */* __restrict  */)"\t-d\t\tdump packets. Print whole packet contents.\n");
#line 37
  printf((char const   */* __restrict  */)"\t-e\t\tFormat output in /etc/hosts format.\n");
#line 38
  printf((char const   */* __restrict  */)"\t-l\t\tFormat output in lmhosts format.\n");
#line 39
  printf((char const   */* __restrict  */)"\t\t\tCannot be used with -v, -s or -h options.\n");
#line 40
  printf((char const   */* __restrict  */)"\t-t timeout\twait timeout milliseconds for response.\n");
#line 41
  printf((char const   */* __restrict  */)"\t\t\tDefault 1000.\n");
#line 42
  printf((char const   */* __restrict  */)"\t-b bandwidth\tOutput throttling. Slow down output\n");
#line 43
  printf((char const   */* __restrict  */)"\t\t\tso that it uses no more that bandwidth bps.\n");
#line 44
  printf((char const   */* __restrict  */)"\t\t\tUseful on slow links, so that ougoing queries\n");
#line 45
  printf((char const   */* __restrict  */)"\t\t\tdon\'t get dropped.\n");
#line 46
  printf((char const   */* __restrict  */)"\t-r\t\tuse local port 137 for scans. Win95 boxes\n");
#line 47
  printf((char const   */* __restrict  */)"\t\t\trespond to this only.\n");
#line 48
  printf((char const   */* __restrict  */)"\t\t\tYou need to be root to use this option on Unix.\n");
#line 49
  printf((char const   */* __restrict  */)"\t-q\t\tSuppress banners and error messages,\n");
#line 50
  printf((char const   */* __restrict  */)"\t-s separator\tScript-friendly output. Don\'t print\n");
#line 51
  printf((char const   */* __restrict  */)"\t\t\tcolumn and record headers, separate fields with separator.\n");
#line 52
  printf((char const   */* __restrict  */)"\t-h\t\tPrint human-readable names for services.\n");
#line 53
  printf((char const   */* __restrict  */)"\t\t\tCan only be used with -v option.\n");
#line 54
  printf((char const   */* __restrict  */)"\t-m retransmits\tNumber of retransmits. Default 0.\n");
#line 55
  printf((char const   */* __restrict  */)"\t-f filename\tTake IP addresses to scan from file filename.\n");
#line 56
  printf((char const   */* __restrict  */)"\t\t\t-f - makes nbtscan take IP addresses from stdin.\n");
#line 57
  printf((char const   */* __restrict  */)"\t<scan_range>\twhat to scan. Can either be single IP\n");
#line 58
  printf((char const   */* __restrict  */)"\t\t\tlike 192.168.1.1 or\n");
#line 59
  printf((char const   */* __restrict  */)"\t\t\trange of addresses in one of two forms: \n");
#line 60
  printf((char const   */* __restrict  */)"\t\t\txxx.xxx.xxx.xxx/xx or xxx.xxx.xxx.xxx-xxx.\n");
#line 61
  printf((char const   */* __restrict  */)"Examples:\n");
#line 62
  printf((char const   */* __restrict  */)"\tnbtscan -r 192.168.1.0/24\n");
#line 63
  printf((char const   */* __restrict  */)"\t\tScans the whole C-class network.\n");
#line 64
  printf((char const   */* __restrict  */)"\tnbtscan 192.168.1.25-137\n");
#line 65
  printf((char const   */* __restrict  */)"\t\tScans a range from 192.168.1.25 to 192.168.1.137\n");
#line 66
  printf((char const   */* __restrict  */)"\tnbtscan -v -s : 192.168.1.0/24\n");
#line 67
  printf((char const   */* __restrict  */)"\t\tScans C-class network. Prints results in script-friendly\n");
#line 68
  printf((char const   */* __restrict  */)"\t\tformat using colon as field separator.\n");
#line 69
  printf((char const   */* __restrict  */)"\t\tProduces output like that:\n");
#line 70
  printf((char const   */* __restrict  */)"\t\t192.168.0.1:NT_SERVER:00U\n");
#line 71
  printf((char const   */* __restrict  */)"\t\t192.168.0.1:MY_DOMAIN:00G\n");
#line 72
  printf((char const   */* __restrict  */)"\t\t192.168.0.1:ADMINISTRATOR:03U\n");
#line 73
  printf((char const   */* __restrict  */)"\t\t192.168.0.2:OTHER_BOX:00U\n");
#line 74
  printf((char const   */* __restrict  */)"\t\t...\n");
#line 75
  printf((char const   */* __restrict  */)"\tnbtscan -f iplist\n");
#line 76
  printf((char const   */* __restrict  */)"\t\tScans IP addresses specified in file iplist.\n");
#line 77
  exit(2);
  }
}
}
#line 80 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
int set_range(char *range_str , struct ip_range *range_struct ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 81
  tmp = is_ip(range_str, range_struct);
  }
#line 81
  if (tmp) {
#line 81
    return (1);
  }
  {
#line 82
  tmp___0 = is_range1(range_str, range_struct);
  }
#line 82
  if (tmp___0) {
#line 82
    return (1);
  }
  {
#line 83
  tmp___1 = is_range2(range_str, range_struct);
  }
#line 83
  if (tmp___1) {
#line 83
    return (1);
  }
#line 84
  return (0);
}
}
#line 87 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
void print_header(void) 
{ 


  {
  {
#line 88
  printf((char const   */* __restrict  */)"%-17s%-17s%-10s%-17s%-17s\n", "IP address",
         "NetBIOS Name", "Server", "User", "MAC address");
#line 90
  printf((char const   */* __restrict  */)"------------------------------------------------------------------------------\n");
  }
#line 91
  return;
}
}
#line 93 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
void d_print_hostinfo(struct in_addr addr , struct nb_host_info  const  *hostinfo ) 
{ 
  int i ;
  unsigned char service ;
  char name[16] ;
  char *tmp ;

  {
  {
#line 98
  tmp = inet_ntoa(addr);
#line 98
  printf((char const   */* __restrict  */)"\nPacket dump for Host %s:\n\n", tmp);
  }
#line 99
  if (hostinfo->is_broken) {
    {
#line 99
    printf((char const   */* __restrict  */)"Incomplete packet, %d bytes long.\n",
           hostinfo->is_broken);
    }
  }
#line 101
  if (hostinfo->header) {
    {
#line 102
    printf((char const   */* __restrict  */)"Transaction ID: 0x%04x (%1$d)\n", (int )(hostinfo->header)->transaction_id);
#line 103
    printf((char const   */* __restrict  */)"Flags: 0x%04x (%1$d)\n", (int )(hostinfo->header)->flags);
#line 104
    printf((char const   */* __restrict  */)"Question count: 0x%04x (%1$d)\n", (int )(hostinfo->header)->question_count);
#line 105
    printf((char const   */* __restrict  */)"Answer count: 0x%04x (%1$d)\n", (int )(hostinfo->header)->answer_count);
#line 106
    printf((char const   */* __restrict  */)"Name service count: 0x%04x (%1$d)\n",
           (int )(hostinfo->header)->name_service_count);
#line 107
    printf((char const   */* __restrict  */)"Additional record count: 0x%04x (%1$d)\n",
           (int )(hostinfo->header)->additional_record_count);
#line 108
    printf((char const   */* __restrict  */)"Question name: %s\n", (hostinfo->header)->question_name);
#line 109
    printf((char const   */* __restrict  */)"Question type: 0x%04x (%1$d)\n", (int )(hostinfo->header)->question_type);
#line 110
    printf((char const   */* __restrict  */)"Question class: 0x%04x (%1$d)\n", (int )(hostinfo->header)->question_class);
#line 111
    printf((char const   */* __restrict  */)"Time to live: 0x%08x (%1$d)\n", (hostinfo->header)->ttl);
#line 112
    printf((char const   */* __restrict  */)"Rdata length: 0x%04x (%1$d)\n", (int )(hostinfo->header)->rdata_length);
#line 113
    printf((char const   */* __restrict  */)"Number of names: 0x%02x (%1$d)\n", (int )(hostinfo->header)->number_of_names);
    }
  }
#line 116
  if (hostinfo->names) {
    {
#line 117
    printf((char const   */* __restrict  */)"Names received:\n");
#line 118
    i = 0;
    }
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 118
      if (! (i < (int )(hostinfo->header)->number_of_names)) {
#line 118
        goto while_break;
      }
      {
#line 119
      service = (unsigned char )(hostinfo->names + i)->ascii_name[15];
#line 120
      strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)((hostinfo->names + i)->ascii_name),
              (size_t )15);
#line 121
      name[15] = (char)0;
#line 122
      printf((char const   */* __restrict  */)"%-17s Service: 0x%02x Flags: 0x%04x\n",
             name, (int )service, (int )(hostinfo->names + i)->rr_flags);
#line 118
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 126
  if (hostinfo->footer) {
    {
#line 127
    printf((char const   */* __restrict  */)"Adapter address: %02x:%02x:%02x:%02x:%02x:%02x\n",
           (int )(hostinfo->footer)->adapter_address[0], (int )(hostinfo->footer)->adapter_address[1],
           (int )(hostinfo->footer)->adapter_address[2], (int )(hostinfo->footer)->adapter_address[3],
           (int )(hostinfo->footer)->adapter_address[4], (int )(hostinfo->footer)->adapter_address[5]);
#line 131
    printf((char const   */* __restrict  */)"Version major: 0x%02x (%1$d)\n", (int )(hostinfo->footer)->version_major);
#line 132
    printf((char const   */* __restrict  */)"Version minor: 0x%02x (%1$d)\n", (int )(hostinfo->footer)->version_minor);
#line 133
    printf((char const   */* __restrict  */)"Duration: 0x%04x (%1$d)\n", (int )(hostinfo->footer)->duration);
#line 134
    printf((char const   */* __restrict  */)"FRMRs Received: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->frmps_received);
#line 135
    printf((char const   */* __restrict  */)"FRMRs Transmitted: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->frmps_transmitted);
#line 136
    printf((char const   */* __restrict  */)"IFrame Receive errors: 0x%04 (%1$d)\n",
           (int )(hostinfo->footer)->iframe_receive_errors);
#line 137
    printf((char const   */* __restrict  */)"Transmit aborts: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->transmit_aborts);
#line 138
    printf((char const   */* __restrict  */)"Transmitted: 0x%08 (%1$d)\n", (hostinfo->footer)->transmitted);
#line 139
    printf((char const   */* __restrict  */)"Received: 0x%08 (%1$d)\n", (hostinfo->footer)->received);
#line 140
    printf((char const   */* __restrict  */)"IFrame transmit errors: 0x%04 (%1$d)\n",
           (int )(hostinfo->footer)->iframe_transmit_errors);
#line 141
    printf((char const   */* __restrict  */)"No receive buffers: 0x%04 (%1$d)\n",
           (int )(hostinfo->footer)->no_receive_buffer);
#line 142
    printf((char const   */* __restrict  */)"tl timeouts: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->tl_timeouts);
#line 143
    printf((char const   */* __restrict  */)"ti timeouts: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->ti_timeouts);
#line 144
    printf((char const   */* __restrict  */)"Free NCBS: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->free_ncbs);
#line 145
    printf((char const   */* __restrict  */)"NCBS: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->ncbs);
#line 146
    printf((char const   */* __restrict  */)"Max NCBS: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->max_ncbs);
#line 147
    printf((char const   */* __restrict  */)"No transmit buffers: 0x%04 (%1$d)\n",
           (int )(hostinfo->footer)->no_transmit_buffers);
#line 148
    printf((char const   */* __restrict  */)"Max datagram: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->max_datagram);
#line 149
    printf((char const   */* __restrict  */)"Pending sessions: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->pending_sessions);
#line 150
    printf((char const   */* __restrict  */)"Max sessions: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->max_sessions);
#line 151
    printf((char const   */* __restrict  */)"Packet sessions: 0x%04 (%1$d)\n", (int )(hostinfo->footer)->packet_sessions);
    }
  }
#line 153
  return;
}
}
#line 156 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
int v_print_hostinfo(struct in_addr addr , struct nb_host_info  const  *hostinfo ,
                     char *sf , int hr ) 
{ 
  int i ;
  int unique ;
  uint8_t service ;
  char name[16] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 161
  if (! sf) {
    {
#line 162
    tmp = inet_ntoa(addr);
#line 162
    printf((char const   */* __restrict  */)"\nNetBIOS Name Table for Host %s:\n\n",
           tmp);
    }
#line 163
    if (hostinfo->is_broken) {
      {
#line 164
      printf((char const   */* __restrict  */)"Incomplete packet, %d bytes long.\n",
             hostinfo->is_broken);
      }
    }
    {
#line 166
    printf((char const   */* __restrict  */)"%-17s%-17s%-17s\n", "Name", "Service",
           "Type");
#line 167
    printf((char const   */* __restrict  */)"----------------------------------------\n");
    }
  }
#line 169
  if (hostinfo->header) {
#line 169
    if (hostinfo->names) {
#line 170
      i = 0;
      {
#line 170
      while (1) {
        while_continue: /* CIL Label */ ;
#line 170
        if (! (i < (int )(hostinfo->header)->number_of_names)) {
#line 170
          goto while_break;
        }
        {
#line 171
        service = (uint8_t )(hostinfo->names + i)->ascii_name[15];
#line 172
        strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)((hostinfo->names + i)->ascii_name),
                (size_t )15);
#line 173
        name[15] = (char)0;
#line 174
        unique = ! ((int )(hostinfo->names + i)->rr_flags & 128);
        }
#line 175
        if (sf) {
          {
#line 176
          tmp___0 = inet_ntoa(addr);
#line 176
          printf((char const   */* __restrict  */)"%s%s%s%s", tmp___0, sf, name, sf);
          }
#line 177
          if (hr) {
            {
#line 177
            tmp___1 = getnbservicename(service, unique, name);
#line 177
            printf((char const   */* __restrict  */)"%s\n", tmp___1);
            }
          } else {
            {
#line 179
            printf((char const   */* __restrict  */)"%02x", (int )service);
            }
#line 180
            if (unique) {
              {
#line 180
              printf((char const   */* __restrict  */)"U\n");
              }
            } else {
              {
#line 181
              printf((char const   */* __restrict  */)"G\n");
              }
            }
          }
        } else {
          {
#line 184
          printf((char const   */* __restrict  */)"%-17s", name);
          }
#line 185
          if (hr) {
            {
#line 185
            tmp___2 = getnbservicename(service, unique, name);
#line 185
            printf((char const   */* __restrict  */)"%s\n", tmp___2);
            }
          } else {
            {
#line 187
            printf((char const   */* __restrict  */)"<%02x>", (int )service);
            }
#line 188
            if (unique) {
              {
#line 188
              printf((char const   */* __restrict  */)"             UNIQUE\n");
              }
            } else {
              {
#line 189
              printf((char const   */* __restrict  */)"              GROUP\n");
              }
            }
          }
        }
#line 170
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 195
  if (hostinfo->footer) {
#line 196
    if (sf) {
      {
#line 196
      tmp___3 = inet_ntoa(addr);
#line 196
      printf((char const   */* __restrict  */)"%s%sMAC%s", tmp___3, sf, sf);
      }
    } else {
      {
#line 197
      printf((char const   */* __restrict  */)"\nAdapter address: ");
      }
    }
    {
#line 198
    printf((char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x\n", (int )(hostinfo->footer)->adapter_address[0],
           (int )(hostinfo->footer)->adapter_address[1], (int )(hostinfo->footer)->adapter_address[2],
           (int )(hostinfo->footer)->adapter_address[3], (int )(hostinfo->footer)->adapter_address[4],
           (int )(hostinfo->footer)->adapter_address[5]);
    }
  }
#line 203
  if (! sf) {
    {
#line 203
    printf((char const   */* __restrict  */)"----------------------------------------\n");
    }
  }
#line 204
  return (1);
}
}
#line 207 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
int print_hostinfo(struct in_addr addr , struct nb_host_info *hostinfo , char *sf ) 
{ 
  int i ;
  unsigned char service ;
  char comp_name[16] ;
  char user_name[16] ;
  int is_server ;
  int unique ;
  int first_name ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 211
  is_server = 0;
#line 213
  first_name = 1;
#line 215
  strncpy((char */* __restrict  */)(comp_name), (char const   */* __restrict  */)"<unknown>",
          (size_t )15);
#line 216
  strncpy((char */* __restrict  */)(user_name), (char const   */* __restrict  */)"<unknown>",
          (size_t )15);
  }
#line 217
  if (hostinfo->header) {
#line 217
    if (hostinfo->names) {
#line 218
      i = 0;
      {
#line 218
      while (1) {
        while_continue: /* CIL Label */ ;
#line 218
        if (! (i < (int )(hostinfo->header)->number_of_names)) {
#line 218
          goto while_break;
        }
#line 219
        service = (unsigned char )(hostinfo->names + i)->ascii_name[15];
#line 220
        unique = ! ((int )(hostinfo->names + i)->rr_flags & 128);
#line 221
        if ((int )service == 0) {
#line 221
          if (unique) {
#line 221
            if (first_name) {
              {
#line 223
              strncpy((char */* __restrict  */)(comp_name), (char const   */* __restrict  */)((hostinfo->names + i)->ascii_name),
                      (size_t )15);
#line 224
              comp_name[15] = (char)0;
#line 225
              first_name = 0;
              }
            }
          }
        }
#line 227
        if ((int )service == 32) {
#line 227
          if (unique) {
#line 228
            is_server = 1;
          }
        }
#line 230
        if ((int )service == 3) {
#line 230
          if (unique) {
            {
#line 231
            strncpy((char */* __restrict  */)(user_name), (char const   */* __restrict  */)((hostinfo->names + i)->ascii_name),
                    (size_t )15);
#line 232
            user_name[15] = (char)0;
            }
          }
        }
#line 218
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 237
  if (sf) {
    {
#line 238
    tmp = inet_ntoa(addr);
#line 238
    printf((char const   */* __restrict  */)"%s%s%s%s", tmp, sf, comp_name, sf);
    }
#line 239
    if (is_server) {
      {
#line 239
      printf((char const   */* __restrict  */)"<server>");
      }
    }
    {
#line 240
    printf((char const   */* __restrict  */)"%s%s%s", sf, user_name, sf);
    }
  } else {
    {
#line 242
    tmp___0 = inet_ntoa(addr);
#line 242
    printf((char const   */* __restrict  */)"%-17s%-17s", tmp___0, comp_name);
    }
#line 243
    if (is_server) {
      {
#line 243
      printf((char const   */* __restrict  */)"%-10s", "<server>");
      }
    } else {
      {
#line 243
      printf((char const   */* __restrict  */)"%-10s", "");
      }
    }
    {
#line 244
    printf((char const   */* __restrict  */)"%-17s", user_name);
    }
  }
#line 246
  if (hostinfo->footer) {
    {
#line 247
    printf((char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x\n", (int )(hostinfo->footer)->adapter_address[0],
           (int )(hostinfo->footer)->adapter_address[1], (int )(hostinfo->footer)->adapter_address[2],
           (int )(hostinfo->footer)->adapter_address[3], (int )(hostinfo->footer)->adapter_address[4],
           (int )(hostinfo->footer)->adapter_address[5]);
    }
  } else {
    {
#line 252
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 254
  return (1);
}
}
#line 260 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
void l_print_hostinfo(struct in_addr addr , struct nb_host_info *hostinfo , int l ) 
{ 
  int i ;
  unsigned char service ;
  char comp_name[16] ;
  int unique ;
  int first_name ;
  char *tmp ;

  {
  {
#line 265
  first_name = 1;
#line 267
  strncpy((char */* __restrict  */)(comp_name), (char const   */* __restrict  */)"<unknown>",
          (size_t )15);
  }
#line 269
  if (hostinfo->header) {
#line 269
    if (hostinfo->names) {
#line 270
      i = 0;
      {
#line 270
      while (1) {
        while_continue: /* CIL Label */ ;
#line 270
        if (! (i < (int )(hostinfo->header)->number_of_names)) {
#line 270
          goto while_break;
        }
#line 271
        service = (unsigned char )(hostinfo->names + i)->ascii_name[15];
#line 272
        unique = ! ((int )(hostinfo->names + i)->rr_flags & 128);
#line 273
        if ((int )service == 0) {
#line 273
          if (unique) {
#line 273
            if (first_name) {
              {
#line 275
              strncpy((char */* __restrict  */)(comp_name), (char const   */* __restrict  */)((hostinfo->names + i)->ascii_name),
                      (size_t )15);
#line 276
              comp_name[15] = (char)0;
#line 277
              first_name = 0;
              }
            }
          }
        }
#line 270
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 281
  tmp = inet_ntoa(addr);
#line 281
  printf((char const   */* __restrict  */)"%s\t%s", tmp, comp_name);
  }
#line 282
  if (l) {
    {
#line 282
    printf((char const   */* __restrict  */)"\t#PRE");
    }
  }
  {
#line 283
  printf((char const   */* __restrict  */)"\n");
  }
#line 284
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/nbtscan-1.5.1/nbtscan.c"
int main(int argc , char **argv ) 
{ 
  int timeout ;
  int verbose ;
  int use137 ;
  int ch ;
  int dump ;
  int bandwidth ;
  int send_ok ;
  int hr ;
  int etc_hosts ;
  int lmhosts ;
  char *target_string ;
  char *sf ;
  char *filename ;
  struct ip_range range ;
  void *buff ;
  int sock ;
  int addr_size ;
  struct sockaddr_in src_sockaddr ;
  struct sockaddr_in dest_sockaddr ;
  struct in_addr *prev_in_addr ;
  struct in_addr *next_in_addr ;
  struct timeval select_timeout ;
  struct timeval last_send_time ;
  struct timeval current_time ;
  struct timeval diff_time ;
  struct timeval send_interval ;
  struct timeval transmit_started ;
  struct timeval now ;
  struct timeval recv_time ;
  struct nb_host_info *hostinfo ;
  fd_set *fdsr ;
  fd_set *fdsw ;
  int size ;
  struct list *scanned ;
  uint32_t rtt_base ;
  float rtt ;
  float srtt ;
  float rttvar ;
  double delta ;
  int rto ;
  int retransmits ;
  int more_to_send ;
  int i ;
  char errmsg[80] ;
  char str[80] ;
  FILE *targetlist ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int __d0 ;
  int __d1 ;
  void *tmp___3 ;
  int __d0___0 ;
  int __d1___0 ;
  void *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  struct nb_host_info *tmp___7 ;
  uint32_t tmp___8 ;
  int tmp___9 ;
  int __d0___1 ;
  int __d1___1 ;
  uint32_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int __d0___2 ;
  int __d1___2 ;
  int tmp___13 ;
  char *tmp___14 ;
  uint32_t tmp___15 ;
  int tmp___16 ;
  int __d0___3 ;
  int __d1___3 ;
  int tmp___17 ;
  int __d0___4 ;
  int __d1___4 ;
  int tmp___18 ;
  int __d0___5 ;
  int __d1___5 ;
  int __d0___6 ;
  int __d1___6 ;

  {
#line 290
  timeout = 1000;
#line 290
  verbose = 0;
#line 290
  use137 = 0;
#line 290
  dump = 0;
#line 290
  bandwidth = 0;
#line 290
  send_ok = 0;
#line 290
  hr = 0;
#line 290
  etc_hosts = 0;
#line 290
  lmhosts = 0;
#line 294
  sf = (char *)((void *)0);
#line 295
  filename = (char *)((void *)0);
#line 300
  prev_in_addr = (struct in_addr *)((void *)0);
#line 311
  srtt = (float )0;
#line 312
  rttvar = (float )0.75;
#line 314
  retransmits = 0;
#line 314
  more_to_send = 1;
#line 317
  targetlist = (FILE *)((void *)0);
#line 321
  if (argc < 2) {
    {
#line 322
    print_banner();
#line 323
    usage();
    }
  }
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 326
    ch = getopt(argc, (char * const  *)argv, "vrdelqhm:s:t:b:f:");
    }
#line 326
    if (! (ch != -1)) {
#line 326
      goto while_break;
    }
    {
#line 328
    if (ch == 118) {
#line 328
      goto case_118;
    }
#line 331
    if (ch == 116) {
#line 331
      goto case_116;
    }
#line 338
    if (ch == 114) {
#line 338
      goto case_114;
    }
#line 345
    if (ch == 100) {
#line 345
      goto case_100;
    }
#line 348
    if (ch == 101) {
#line 348
      goto case_101;
    }
#line 351
    if (ch == 108) {
#line 351
      goto case_108;
    }
#line 354
    if (ch == 113) {
#line 354
      goto case_113;
    }
#line 357
    if (ch == 98) {
#line 357
      goto case_98;
    }
#line 361
    if (ch == 104) {
#line 361
      goto case_104;
    }
#line 364
    if (ch == 115) {
#line 364
      goto case_115;
    }
#line 367
    if (ch == 109) {
#line 367
      goto case_109;
    }
#line 374
    if (ch == 102) {
#line 374
      goto case_102;
    }
#line 377
    goto switch_default;
    case_118: /* CIL Label */ 
#line 329
    verbose = 1;
#line 330
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 332
    timeout = atoi((char const   *)optarg);
    }
#line 333
    if (timeout == 0) {
      {
#line 334
      printf((char const   */* __restrict  */)"Bad timeout value: %s\n", optarg);
#line 335
      usage();
      }
    }
#line 337
    goto switch_break;
    case_114: /* CIL Label */ 
#line 342
    use137 = 1;
#line 344
    goto switch_break;
    case_100: /* CIL Label */ 
#line 346
    dump = 1;
#line 347
    goto switch_break;
    case_101: /* CIL Label */ 
#line 349
    etc_hosts = 1;
#line 350
    goto switch_break;
    case_108: /* CIL Label */ 
#line 352
    lmhosts = 1;
#line 353
    goto switch_break;
    case_113: /* CIL Label */ 
#line 355
    quiet = 1;
#line 356
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 358
    bandwidth = atoi((char const   *)optarg);
    }
#line 359
    if (bandwidth == 0) {
#line 359
      if (! quiet) {
        {
#line 359
        perror("Bad bandwidth value, ignoring it");
        }
      }
    }
#line 360
    goto switch_break;
    case_104: /* CIL Label */ 
#line 362
    hr = 1;
#line 363
    goto switch_break;
    case_115: /* CIL Label */ 
#line 365
    sf = optarg;
#line 366
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 368
    retransmits = atoi((char const   *)optarg);
    }
#line 369
    if (retransmits == 0) {
      {
#line 370
      printf((char const   */* __restrict  */)"Bad number of retransmits: %s\n", optarg);
#line 371
      usage();
      }
    }
#line 373
    goto switch_break;
    case_102: /* CIL Label */ 
#line 375
    filename = optarg;
#line 376
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 378
    print_banner();
#line 379
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  if (dump) {
#line 382
    if (verbose) {
      {
#line 383
      printf((char const   */* __restrict  */)"Cannot be used with both dump (-d) and verbose (-v) options.\n");
#line 384
      usage();
      }
    }
  }
#line 387
  if (dump) {
#line 387
    if (sf) {
      {
#line 388
      printf((char const   */* __restrict  */)"Cannot be used with both dump (-d) and script-friendly (-s) options.\n");
#line 389
      usage();
      }
    }
  }
#line 392
  if (dump) {
#line 392
    if (lmhosts) {
      {
#line 393
      printf((char const   */* __restrict  */)"Cannot be used with both dump (-d) and lmhosts (-l) options.\n");
#line 394
      usage();
      }
    }
  }
#line 397
  if (dump) {
#line 397
    if (etc_hosts) {
      {
#line 398
      printf((char const   */* __restrict  */)"Cannot be used with both dump (-d) and /etc/hosts (-e) options.\n");
#line 399
      usage();
      }
    }
  }
#line 402
  if (verbose) {
#line 402
    if (lmhosts) {
      {
#line 403
      printf((char const   */* __restrict  */)"Cannot be used with both verbose (-v) and lmhosts (-l) options.\n");
#line 404
      usage();
      }
    }
  }
#line 407
  if (verbose) {
#line 407
    if (etc_hosts) {
      {
#line 408
      printf((char const   */* __restrict  */)"Cannot be used with both verbose (-v) and /etc/hosts (-e) options.\n");
#line 409
      usage();
      }
    }
  }
#line 412
  if (lmhosts) {
#line 412
    if (etc_hosts) {
      {
#line 413
      printf((char const   */* __restrict  */)"Cannot be used with both lmhosts (-l) and /etc/hosts (-e) options.\n");
#line 414
      usage();
      }
    }
  }
#line 418
  if (dump) {
#line 418
    if (hr) {
      {
#line 419
      printf((char const   */* __restrict  */)"Cannot be used with both dump (-d) and \"human-readable service names\" (-h) options.\n");
#line 420
      usage();
      }
    }
  }
#line 423
  if (hr) {
#line 423
    if (! verbose) {
      {
#line 424
      printf((char const   */* __restrict  */)"\"Human-readable service names\" (-h) option cannot be used without verbose (-v) option.\n");
#line 425
      usage();
      }
    }
  }
#line 428
  if (filename) {
    {
#line 429
    tmp = strcmp((char const   *)filename, "-");
    }
#line 429
    if (tmp == 0) {
#line 430
      targetlist = stdin;
#line 431
      target_string = (char *)"STDIN";
    } else {
      {
#line 433
      targetlist = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
#line 434
      target_string = filename;
      }
    }
#line 436
    if (! targetlist) {
      {
#line 437
      snprintf((char */* __restrict  */)(errmsg), (size_t )80, (char const   */* __restrict  */)"Cannot open file %s",
               filename);
      }
#line 438
      if (! quiet) {
        {
#line 438
        perror((char const   *)(errmsg));
#line 438
        exit(1);
        }
      }
    }
  } else {
#line 441
    argc -= optind;
#line 442
    argv += optind;
#line 443
    if (argc != 1) {
      {
#line 443
      usage();
      }
    }
    {
#line 445
    target_string = strdup((char const   *)*(argv + 0));
    }
#line 445
    if ((unsigned long )target_string == (unsigned long )((void *)0)) {
#line 446
      if (! quiet) {
        {
#line 446
        perror("Malloc failed.\n");
#line 446
        exit(1);
        }
      }
    }
    {
#line 448
    tmp___0 = set_range(target_string, & range);
    }
#line 448
    if (! tmp___0) {
      {
#line 449
      printf((char const   */* __restrict  */)"Error: %s is not an IP address or address range.\n",
             target_string);
#line 450
      free((void *)target_string);
#line 451
      usage();
      }
    }
  }
#line 456
  if (! quiet) {
#line 456
    if (! sf) {
#line 456
      if (! lmhosts) {
#line 456
        if (! etc_hosts) {
          {
#line 456
          printf((char const   */* __restrict  */)"Doing NBT name scan for addresses from %s\n\n",
                 target_string);
          }
        }
      }
    }
  }
  {
#line 463
  sock = socket(2, 2, 17);
  }
#line 464
  if (sock < 0) {
#line 465
    if (! quiet) {
      {
#line 465
      perror("Failed to create socket");
#line 465
      exit(1);
      }
    }
  }
  {
#line 467
  bzero((void *)(& src_sockaddr), sizeof(src_sockaddr));
#line 468
  src_sockaddr.sin_family = (sa_family_t )2;
  }
#line 469
  if (use137) {
    {
#line 469
    src_sockaddr.sin_port = htons((uint16_t )137);
    }
  }
  {
#line 470
  tmp___1 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& src_sockaddr)),
                 (socklen_t )sizeof(src_sockaddr));
  }
#line 470
  if (tmp___1 == -1) {
#line 471
    if (! quiet) {
      {
#line 471
      perror("Failed to bind");
#line 471
      exit(1);
      }
    }
  }
  {
#line 473
  tmp___2 = malloc(sizeof(fd_set ));
#line 473
  fdsr = (fd_set *)tmp___2;
  }
#line 474
  if (! fdsr) {
#line 474
    if (! quiet) {
      {
#line 474
      perror("Malloc failed");
#line 474
      exit(1);
      }
    }
  }
  {
#line 475
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 475
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdsr->__fds_bits[0]): "memory");
#line 475
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 476
  fdsr->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
#line 478
  tmp___3 = malloc(sizeof(fd_set ));
#line 478
  fdsw = (fd_set *)tmp___3;
  }
#line 479
  if (! fdsw) {
#line 479
    if (! quiet) {
      {
#line 479
      perror("Malloc failed");
#line 479
      exit(1);
      }
    }
  }
  {
#line 480
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 480
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fdsw->__fds_bits[0]): "memory");
#line 480
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 481
  fdsw->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
#line 484
  select_timeout.tv_sec = (__time_t )60;
#line 485
  select_timeout.tv_usec = (__suseconds_t )0;
#line 487
  addr_size = (int )sizeof(struct sockaddr_in );
#line 489
  tmp___4 = malloc(sizeof(struct in_addr ));
#line 489
  next_in_addr = (struct in_addr *)tmp___4;
  }
#line 490
  if (! next_in_addr) {
#line 490
    if (! quiet) {
      {
#line 490
      perror("Malloc failed");
#line 490
      exit(1);
      }
    }
  }
  {
#line 492
  buff = malloc((size_t )1024);
  }
#line 493
  if (! buff) {
#line 493
    if (! quiet) {
      {
#line 493
      perror("Malloc failed");
#line 493
      exit(1);
      }
    }
  }
#line 497
  send_interval.tv_usec = (__suseconds_t )0;
#line 497
  send_interval.tv_sec = send_interval.tv_usec;
#line 498
  if (bandwidth) {
#line 498
    send_interval.tv_usec = (__suseconds_t )(624000000 / bandwidth);
  } else {
#line 502
    send_interval.tv_usec = (__suseconds_t )1;
  }
#line 503
  if (send_interval.tv_usec >= 1000000L) {
#line 504
    send_interval.tv_sec = send_interval.tv_usec / 1000000L;
#line 505
    send_interval.tv_usec %= 1000000L;
  }
  {
#line 508
  gettimeofday((struct timeval */* __restrict  */)(& last_send_time), (__timezone_ptr_t )((void *)0));
#line 510
  rtt_base = (uint32_t )last_send_time.tv_sec;
#line 515
  scanned = new_list();
  }
#line 517
  if (! quiet) {
#line 517
    if (! verbose) {
#line 517
      if (! dump) {
#line 517
        if (! sf) {
#line 517
          if (! lmhosts) {
#line 517
            if (! etc_hosts) {
              {
#line 517
              print_header();
              }
            }
          }
        }
      }
    }
  }
#line 519
  i = 0;
  {
#line 519
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 519
    if (! (i <= retransmits)) {
#line 519
      goto while_break___2;
    }
    {
#line 520
    gettimeofday((struct timeval */* __restrict  */)(& transmit_started), (__timezone_ptr_t )((void *)0));
    }
    {
#line 521
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 521
      tmp___18 = select(sock + 1, (fd_set */* __restrict  */)fdsr, (fd_set */* __restrict  */)fdsw,
                        (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& select_timeout));
      }
#line 521
      if (! (tmp___18 > 0)) {
#line 521
        goto while_break___3;
      }
#line 522
      if ((fdsr->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] & (1L << sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 523
        tmp___6 = recvfrom(sock, (void */* __restrict  */)buff, (size_t )1024, 0,
                           (struct sockaddr */* __restrict  */)((struct sockaddr *)(& dest_sockaddr)),
                           (socklen_t */* __restrict  */)(& addr_size));
#line 523
        size = (int )tmp___6;
        }
#line 523
        if (size <= 0) {
          {
#line 525
          tmp___5 = inet_ntoa(dest_sockaddr.sin_addr);
#line 525
          snprintf((char */* __restrict  */)(errmsg), (size_t )80, (char const   */* __restrict  */)"%s\tRecvfrom failed",
                   tmp___5);
          }
#line 526
          if (! quiet) {
            {
#line 526
            perror((char const   *)(errmsg));
            }
          }
#line 527
          goto while_continue___3;
        }
        {
#line 529
        gettimeofday((struct timeval */* __restrict  */)(& recv_time), (__timezone_ptr_t )((void *)0));
#line 530
        tmp___7 = parse_response((char *)buff, size);
#line 530
        hostinfo = tmp___7;
        }
#line 531
        if (! hostinfo) {
#line 532
          if (! quiet) {
            {
#line 532
            perror("parse_response returned NULL");
            }
          }
#line 533
          goto while_continue___3;
        }
        {
#line 536
        tmp___8 = ntohl(dest_sockaddr.sin_addr.s_addr);
#line 536
        tmp___9 = insert(scanned, (unsigned long )tmp___8);
        }
#line 536
        if (tmp___9) {
#line 537
          rtt = (float )(((recv_time.tv_sec + recv_time.tv_usec / 1000000L) - (__time_t )rtt_base) - (__time_t )((int )(hostinfo->header)->transaction_id / 1000));
#line 542
          delta = (double )(rtt - srtt);
#line 543
          srtt = (float )((double )srtt + delta / (double )8);
#line 544
          if (delta < 0.0) {
#line 544
            delta = - delta;
          }
#line 545
          rttvar = (float )((double )rttvar + (delta - (double )rttvar) / (double )4);
#line 547
          if (verbose) {
            {
#line 548
            v_print_hostinfo(dest_sockaddr.sin_addr, (struct nb_host_info  const  *)hostinfo,
                             sf, hr);
            }
          } else
#line 549
          if (dump) {
            {
#line 550
            d_print_hostinfo(dest_sockaddr.sin_addr, (struct nb_host_info  const  *)hostinfo);
            }
          } else
#line 551
          if (etc_hosts) {
            {
#line 552
            l_print_hostinfo(dest_sockaddr.sin_addr, hostinfo, 0);
            }
          } else
#line 553
          if (lmhosts) {
            {
#line 554
            l_print_hostinfo(dest_sockaddr.sin_addr, hostinfo, 1);
            }
          } else {
            {
#line 556
            print_hostinfo(dest_sockaddr.sin_addr, hostinfo, sf);
            }
          }
        }
        {
#line 558
        free((void *)hostinfo);
        }
      }
      {
#line 561
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 561
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& fdsr->__fds_bits[0]): "memory");
#line 561
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 562
      fdsr->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
#line 565
      gettimeofday((struct timeval */* __restrict  */)(& current_time), (__timezone_ptr_t )((void *)0));
      }
      {
#line 566
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 566
        diff_time.tv_sec = current_time.tv_sec - last_send_time.tv_sec;
#line 566
        diff_time.tv_usec = current_time.tv_usec - last_send_time.tv_usec;
#line 566
        if (diff_time.tv_usec < 0L) {
#line 566
          (diff_time.tv_sec) --;
#line 566
          diff_time.tv_usec += 1000000L;
        }
#line 566
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 567
      if (diff_time.tv_sec == send_interval.tv_sec) {
#line 567
        send_ok = diff_time.tv_usec >= send_interval.tv_usec;
      } else {
#line 567
        send_ok = diff_time.tv_sec >= send_interval.tv_sec;
      }
#line 570
      if (more_to_send) {
#line 570
        if ((fdsw->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] & (1L << sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 570
          if (send_ok) {
#line 571
            if (targetlist) {
              {
#line 572
              tmp___14 = fgets((char */* __restrict  */)(str), 80, (FILE */* __restrict  */)targetlist);
              }
#line 572
              if (tmp___14) {
                {
#line 573
                tmp___12 = inet_aton((char const   *)(str), next_in_addr);
                }
#line 573
                if (tmp___12) {
                  {
#line 577
                  tmp___10 = ntohl(next_in_addr->s_addr);
#line 577
                  tmp___11 = in_list(scanned, (unsigned long )tmp___10);
                  }
#line 577
                  if (! tmp___11) {
                    {
#line 578
                    send_query(sock, *next_in_addr, rtt_base);
                    }
                  }
                } else {
                  {
#line 575
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s - bad IP address\n",
                          str);
                  }
                }
              } else {
                {
#line 581
                tmp___13 = feof(targetlist);
                }
#line 581
                if (tmp___13) {
#line 582
                  more_to_send = 0;
                  {
#line 583
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 583
                    __asm__  volatile   ("cld; rep; "
                                         "stosq": "=c" (__d0___2), "=D" (__d1___2): "a" (0),
                                         "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                                         "1" (& fdsw->__fds_bits[0]): "memory");
#line 583
                    goto while_break___6;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
#line 585
                  select_timeout.tv_sec = (__time_t )(timeout / 1000);
#line 586
                  select_timeout.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 587
                  goto while_continue___3;
                } else {
                  {
#line 589
                  snprintf((char */* __restrict  */)(errmsg), (size_t )80, (char const   */* __restrict  */)"Read failed from file %s",
                           filename);
                  }
#line 590
                  if (! quiet) {
                    {
#line 590
                    perror((char const   *)(errmsg));
#line 590
                    exit(1);
                    }
                  }
                }
              }
            } else {
              {
#line 593
              tmp___17 = next_address((struct ip_range  const  *)(& range), (struct in_addr  const  *)prev_in_addr,
                                      next_in_addr);
              }
#line 593
              if (tmp___17) {
                {
#line 594
                tmp___15 = ntohl(next_in_addr->s_addr);
#line 594
                tmp___16 = in_list(scanned, (unsigned long )tmp___15);
                }
#line 594
                if (! tmp___16) {
                  {
#line 595
                  send_query(sock, *next_in_addr, rtt_base);
                  }
                }
                {
#line 596
                prev_in_addr = next_in_addr;
#line 598
                gettimeofday((struct timeval */* __restrict  */)(& last_send_time),
                             (__timezone_ptr_t )((void *)0));
                }
              } else {
#line 600
                more_to_send = 0;
                {
#line 601
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 601
                  __asm__  volatile   ("cld; rep; "
                                       "stosq": "=c" (__d0___3), "=D" (__d1___3): "a" (0),
                                       "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                                       "1" (& fdsw->__fds_bits[0]): "memory");
#line 601
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 603
                select_timeout.tv_sec = (__time_t )(timeout / 1000);
#line 604
                select_timeout.tv_usec = (__suseconds_t )((timeout % 1000) * 1000);
#line 605
                goto while_continue___3;
              }
            }
          }
        }
      }
#line 608
      if (more_to_send) {
        {
#line 609
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 609
          __asm__  volatile   ("cld; rep; "
                               "stosq": "=c" (__d0___4), "=D" (__d1___4): "a" (0),
                               "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& fdsw->__fds_bits[0]): "memory");
#line 609
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 610
        fdsw->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 614
    if (i >= retransmits) {
#line 614
      goto while_break___2;
    }
#line 617
    rto = (int )((srtt + (float )4 * rttvar) * (float )(i + 1));
#line 619
    if ((double )rto < 2.0) {
#line 619
      rto = (int )2.0;
    }
#line 620
    if ((double )rto > 60.0) {
#line 620
      rto = (int )60.0;
    }
    {
#line 621
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 623
    if (now.tv_sec < transmit_started.tv_sec + (__time_t )rto) {
      {
#line 624
      sleep((unsigned int )((transmit_started.tv_sec + (__time_t )rto) - now.tv_sec));
      }
    }
#line 625
    prev_in_addr = (struct in_addr *)((void *)0);
#line 626
    more_to_send = 1;
    {
#line 627
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 627
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___5), "=D" (__d1___5): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdsw->__fds_bits[0]): "memory");
#line 627
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 628
    fdsw->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
    {
#line 629
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 629
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___6), "=D" (__d1___6): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdsr->__fds_bits[0]): "memory");
#line 629
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 630
    fdsr->__fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (8 * (int )sizeof(__fd_mask ));
#line 519
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 633
  delete_list(scanned);
#line 634
  exit(0);
  }
}
}
#line 15 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.h"
struct list_item *new_list_item(unsigned long content ) ;
#line 19
int compare(struct list_item *item1 , struct list_item *item2 ) ;
#line 8 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
struct list *new_list(void) 
{ 
  struct list *lst ;
  void *tmp ;

  {
  {
#line 11
  tmp = malloc(sizeof(struct list ));
#line 11
  lst = (struct list *)tmp;
  }
#line 11
  if ((unsigned long )lst == (unsigned long )((void *)0)) {
#line 12
    if (! quiet) {
      {
#line 12
      perror("Malloc failed");
#line 12
      exit(1);
      }
    }
  }
#line 13
  lst->head = (struct list_item *)((void *)0);
#line 14
  return (lst);
}
}
#line 17 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
struct list_item *new_list_item(unsigned long content ) 
{ 
  struct list_item *lst_item ;
  void *tmp ;

  {
  {
#line 20
  tmp = malloc(sizeof(struct list_item ));
#line 20
  lst_item = (struct list_item *)tmp;
  }
#line 20
  if ((unsigned long )lst_item == (unsigned long )((void *)0)) {
#line 21
    if (! quiet) {
      {
#line 21
      perror("Malloc failed");
#line 21
      exit(1);
      }
    }
  }
#line 23
  lst_item->next = (struct list_item *)((void *)0);
#line 24
  lst_item->prev = (struct list_item *)((void *)0);
#line 25
  lst_item->content = content;
#line 26
  return (lst_item);
}
}
#line 29 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
void delete_list(struct list *list ) 
{ 
  struct list_item *pointer ;

  {
#line 32
  pointer = list->head;
#line 34
  if (pointer) {
    {
#line 35
    while (1) {
      while_continue: /* CIL Label */ ;
#line 35
      if (! pointer->next) {
#line 35
        goto while_break;
      }
#line 35
      pointer = pointer->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 38
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 38
      if (! pointer->prev) {
#line 38
        goto while_break___0;
      }
      {
#line 39
      pointer = pointer->prev;
#line 40
      free((void *)pointer->next);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 42
    free((void *)pointer);
    }
  }
  {
#line 44
  free((void *)list);
  }
#line 45
  return;
}
}
#line 47 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
int compare(struct list_item *item1 , struct list_item *item2 ) 
{ 


  {
#line 48
  if ((unsigned long )item2 == (unsigned long )((void *)0)) {
#line 48
    return (12345);
  }
#line 49
  if ((unsigned long )item1 == (unsigned long )((void *)0)) {
#line 49
    return (1);
  }
#line 50
  if (item1->content == item2->content) {
#line 50
    return (0);
  }
#line 51
  if (item1->content > item2->content) {
#line 51
    return (1);
  }
#line 52
  return (-1);
}
}
#line 55 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
int insert(struct list *lst , unsigned long content ) 
{ 
  struct list_item *temp_item ;
  struct list_item *item ;
  int cmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 60
  item = new_list_item(content);
#line 62
  cmp = compare(lst->head, item);
  }
#line 63
  if ((unsigned long )lst->head == (unsigned long )((void *)0)) {
#line 64
    lst->head = item;
#line 65
    return (1);
  } else
#line 66
  if (cmp == 1) {
#line 67
    item->next = lst->head;
#line 68
    lst->head = item;
#line 69
    item->prev = (struct list_item *)((void *)0);
#line 70
    return (1);
  } else
#line 71
  if (cmp == 0) {
    {
#line 72
    free((void *)item);
    }
#line 73
    return (0);
  } else
#line 74
  if (cmp == -1) {
#line 75
    temp_item = lst->head;
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 76
      tmp = compare(temp_item->next, item);
      }
#line 76
      if (! (tmp == -1)) {
#line 76
        goto while_break;
      }
#line 77
      temp_item = temp_item->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 81
    tmp___2 = compare(temp_item->next, item);
    }
#line 81
    if (tmp___2 == 0) {
      {
#line 82
      free((void *)item);
      }
#line 83
      return (0);
    } else {
      {
#line 84
      tmp___1 = compare(temp_item->next, item);
      }
#line 84
      if (tmp___1 == 12345) {
        {
#line 85
        free((void *)item);
        }
#line 86
        return (12345);
      } else {
        {
#line 87
        tmp___0 = compare(temp_item->next, item);
        }
#line 87
        if (tmp___0 == 1) {
#line 88
          item->next = temp_item->next;
#line 89
          item->prev = temp_item;
#line 90
          if (temp_item->next) {
#line 90
            (temp_item->next)->prev = item;
          }
#line 91
          temp_item->next = item;
#line 92
          return (1);
        }
      }
    }
  } else {
    {
#line 94
    tmp___3 = compare(lst->head, item);
    }
#line 94
    if (tmp___3 == 12345) {
      {
#line 95
      free((void *)item);
      }
#line 96
      return (12345);
    }
  }
#line 98
  return (0);
}
}
#line 101 "/home/wheatley/newnew/temp/nbtscan-1.5.1/list.c"
int in_list(struct list *lst , unsigned long content ) 
{ 
  struct list_item *temp_item ;
  struct list_item *item ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 104
  item = new_list_item(content);
  }
#line 105
  if ((unsigned long )lst->head == (unsigned long )((void *)0)) {
#line 105
    return (0);
  }
#line 106
  temp_item = lst->head;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp = compare(temp_item, item);
    }
#line 108
    if (! (tmp < 0)) {
#line 108
      goto while_break;
    }
#line 108
    temp_item = temp_item->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 109
  tmp___0 = compare(temp_item, item);
  }
#line 109
  if (tmp___0 == 0) {
#line 109
    return (1);
  }
#line 110
  return (0);
}
}
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 39 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.h"
void print_range(struct ip_range  const  *range ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 21 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.c"
int is_ip(char *string , struct ip_range *range ) 
{ 
  unsigned long addr ;
  in_addr_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 24
  tmp = inet_addr((char const   *)string);
#line 24
  addr = (unsigned long )tmp;
  }
#line 25
  if (addr != 4294967295UL) {
    {
#line 26
    tmp___0 = ntohl((uint32_t )addr);
#line 26
    range->start_ip = (unsigned long )tmp___0;
#line 27
    tmp___1 = ntohl((uint32_t )addr);
#line 27
    range->end_ip = (unsigned long )tmp___1;
    }
#line 28
    return (1);
  } else {
#line 29
    return (0);
  }
}
}
#line 36 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.c"
int is_range1(char *string , struct ip_range *range ) 
{ 
  char *separator ;
  unsigned int mask ;
  char *ip ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  in_addr_t tmp___5 ;
  uint32_t tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 41
  tmp = strlen((char const   *)string);
#line 41
  tmp___0 = malloc(tmp + 1UL);
#line 41
  ip = (char *)tmp___0;
  }
#line 41
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 42
    if (! quiet) {
      {
#line 42
      perror("Malloc failed");
#line 42
      exit(1);
      }
    }
  }
  {
#line 44
  tmp___1 = strlen((char const   *)string);
  }
#line 44
  if (tmp___1 > 19UL) {
#line 44
    return (0);
  }
  {
#line 45
  tmp___7 = strchr((char const   *)string, '/');
#line 45
  separator = tmp___7;
  }
#line 45
  if (separator) {
    {
#line 46
    separator ++;
#line 47
    tmp___2 = atoi((char const   *)separator);
#line 47
    mask = (unsigned int )tmp___2;
    }
#line 48
    if (mask <= 0U) {
#line 48
      return (0);
    } else
#line 48
    if (mask > 32U) {
#line 48
      return (0);
    }
    {
#line 49
    strcpy((char */* __restrict  */)ip, (char const   */* __restrict  */)string);
#line 50
    tmp___3 = abs((int )(string - separator));
#line 50
    *(ip + (tmp___3 - 1)) = (char)0;
#line 51
    tmp___5 = inet_addr((char const   *)ip);
#line 51
    tmp___4 = (unsigned long )tmp___5;
#line 51
    range->start_ip = tmp___4;
    }
#line 51
    if (tmp___4 == 4294967295UL) {
#line 51
      return (0);
    }
#line 53
    if (mask == 32U) {
#line 54
      mask = (unsigned int )(~ 0);
    } else {
#line 56
      mask = (unsigned int )(((1 << mask) - 1) << (sizeof(mask) * 8UL - (unsigned long )mask));
    }
    {
#line 58
    tmp___6 = ntohl((uint32_t )range->start_ip);
#line 58
    range->start_ip = (unsigned long )tmp___6;
#line 59
    range->start_ip &= (unsigned long )mask;
#line 60
    range->end_ip = range->start_ip | (unsigned long )(~ mask);
#line 61
    free((void *)ip);
    }
#line 62
    return (1);
  }
  {
#line 64
  free((void *)ip);
  }
#line 65
  return (0);
}
}
#line 71 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.c"
int next_address(struct ip_range  const  *range , struct in_addr  const  *prev_addr ,
                 struct in_addr *next_addr ) 
{ 
  unsigned long pa ;
  uint32_t tmp ;

  {
#line 75
  if (prev_addr) {
    {
#line 76
    tmp = ntohl((uint32_t )prev_addr->s_addr);
#line 76
    pa = (unsigned long )tmp;
    }
#line 77
    if (pa < (unsigned long )range->end_ip) {
      {
#line 78
      pa ++;
#line 78
      next_addr->s_addr = htonl((uint32_t )pa);
      }
#line 79
      return (1);
    } else {
#line 80
      return (0);
    }
  } else {
    {
#line 82
    next_addr->s_addr = htonl((uint32_t )range->start_ip);
    }
#line 83
    return (1);
  }
}
}
#line 91 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.c"
int is_range2(char *string , struct ip_range *range ) 
{ 
  unsigned long last_octet ;
  char *separator ;
  unsigned long addr ;
  char *ip ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  in_addr_t tmp___2 ;
  uint32_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 97
  tmp = strlen((char const   *)string);
#line 97
  tmp___0 = malloc(tmp + 1UL);
#line 97
  ip = (char *)tmp___0;
  }
#line 97
  if ((unsigned long )ip == (unsigned long )((void *)0)) {
#line 98
    if (! quiet) {
      {
#line 98
      perror("Malloc failed");
#line 98
      exit(1);
      }
    }
  }
  {
#line 99
  strcpy((char */* __restrict  */)ip, (char const   */* __restrict  */)string);
#line 101
  tmp___4 = strchr((char const   *)ip, '-');
#line 101
  separator = tmp___4;
  }
#line 101
  if (separator) {
    {
#line 102
    *separator = (char)0;
#line 103
    separator ++;
#line 104
    tmp___1 = atoi((char const   *)separator);
#line 104
    last_octet = (unsigned long )tmp___1;
    }
#line 105
    if (last_octet < 0UL) {
      {
#line 106
      free((void *)ip);
      }
#line 107
      return (0);
    } else
#line 105
    if (last_octet > 255UL) {
      {
#line 106
      free((void *)ip);
      }
#line 107
      return (0);
    }
    {
#line 109
    tmp___2 = inet_addr((char const   *)ip);
#line 109
    addr = (unsigned long )tmp___2;
    }
#line 110
    if (addr == 4294967295UL) {
      {
#line 111
      free((void *)ip);
      }
#line 112
      return (0);
    }
    {
#line 114
    tmp___3 = ntohl((uint32_t )addr);
#line 114
    range->start_ip = (unsigned long )tmp___3;
#line 115
    range->end_ip = (range->start_ip & 4294967040UL) | last_octet;
    }
#line 116
    if (range->end_ip < range->start_ip) {
      {
#line 117
      free((void *)ip);
      }
#line 118
      return (0);
    }
    {
#line 120
    free((void *)ip);
    }
#line 121
    return (1);
  }
  {
#line 123
  free((void *)ip);
  }
#line 124
  return (0);
}
}
#line 127 "/home/wheatley/newnew/temp/nbtscan-1.5.1/range.c"
void print_range(struct ip_range  const  *range ) 
{ 
  struct in_addr *addr ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 130
  tmp = malloc(sizeof(struct in_addr ));
#line 130
  addr = (struct in_addr *)tmp;
  }
#line 130
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 131
    if (! quiet) {
      {
#line 131
      perror("Malloc failed");
#line 131
      exit(1);
      }
    }
  }
  {
#line 133
  next_address(range, (struct in_addr  const  *)0, addr);
#line 134
  tmp___0 = inet_ntoa(*addr);
#line 134
  printf((char const   */* __restrict  */)"%s\n", tmp___0);
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 136
    tmp___2 = next_address(range, (struct in_addr  const  *)addr, addr);
    }
#line 136
    if (! tmp___2) {
#line 136
      goto while_break;
    }
    {
#line 137
    tmp___1 = inet_ntoa(*addr);
#line 137
    printf((char const   */* __restrict  */)"%s\n", tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 139
  free((void *)addr);
  }
#line 140
  return;
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 40 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
int name_mangle(char *In , char *Out , char name_type ) 
{ 
  int i ;
  int c ;
  int len ;
  char buf[20] ;
  char *p ;
  char *scope ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 45
  p = Out;
#line 46
  scope = (char *)"";
#line 49
  memset((void *)(buf), 0, (size_t )20);
#line 50
  tmp = strcmp((char const   *)In, "*");
  }
#line 50
  if (tmp == 0) {
#line 50
    buf[0] = (char )'*';
  } else {
    {
#line 53
    snprintf((char */* __restrict  */)(buf), sizeof(buf) - 1UL, (char const   */* __restrict  */)"%-15.15s%c",
             In, (int )name_type);
    }
  }
#line 59
  *(p + 0) = (char)32;
#line 60
  p ++;
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < 16)) {
#line 63
      goto while_break;
    }
    {
#line 64
    c = toupper((int )buf[i]);
#line 65
    *(p + i * 2) = (char )(((c >> 4) & 15) + 65);
#line 66
    *(p + (i * 2 + 1)) = (char )((c & 15) + 65);
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  p += 32;
#line 69
  *(p + 0) = (char )'\000';
#line 72
  i = 0;
#line 72
  len = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )((void *)0) != (unsigned long )scope)) {
#line 72
      goto while_break___0;
    }
    {
#line 74
    if ((int )*(scope + i) == 0) {
#line 74
      goto case_0;
    }
#line 78
    if ((int )*(scope + i) == 46) {
#line 78
      goto case_46;
    }
#line 83
    goto switch_default;
    case_0: /* CIL Label */ 
#line 75
    *(p + 0) = (char )len;
#line 76
    if (len > 0) {
#line 76
      *(p + (len + 1)) = (char)0;
    }
    {
#line 77
    tmp___0 = strlen((char const   *)Out);
    }
#line 77
    return ((int )tmp___0);
    case_46: /* CIL Label */ 
#line 79
    *(p + 0) = (char )len;
#line 80
    p += len + 1;
#line 81
    len = 0;
#line 82
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 84
    *(p + (len + 1)) = *(scope + i);
#line 85
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 72
    i ++;
#line 72
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  tmp___1 = strlen((char const   *)Out);
  }
#line 88
  return ((int )tmp___1);
}
}
#line 93 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
void send_query(int sock , struct in_addr dest_addr , uint32_t rtt_base ) 
{ 
  struct nbname_request request ;
  struct sockaddr_in dest_sockaddr ;
  int status ;
  struct timeval tv ;
  char errmsg[80] ;
  ssize_t tmp ;
  char *tmp___0 ;

  {
  {
#line 100
  bzero((void *)(& dest_sockaddr), sizeof(dest_sockaddr));
#line 101
  dest_sockaddr.sin_family = (sa_family_t )2;
#line 102
  dest_sockaddr.sin_port = htons((uint16_t )137);
#line 103
  dest_sockaddr.sin_addr = dest_addr;
#line 105
  request.flags = htons((uint16_t )16);
#line 106
  request.question_count = htons((uint16_t )1);
#line 107
  request.answer_count = (uint16_t )0;
#line 108
  request.name_service_count = (uint16_t )0;
#line 109
  request.additional_record_count = (uint16_t )0;
#line 110
  name_mangle((char *)"*", request.question_name, (char)0);
#line 111
  request.question_type = htons((uint16_t )33);
#line 112
  request.question_class = htons((uint16_t )1);
#line 114
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 116
  request.transaction_id = htons((uint16_t )((tv.tv_sec - (__time_t )rtt_base) * 1000L + tv.tv_usec / 1000L));
#line 119
  tmp = sendto(sock, (void const   *)((char *)(& request)), sizeof(request), 0, (struct sockaddr  const  *)((struct sockaddr *)(& dest_sockaddr)),
               (socklen_t )sizeof(dest_sockaddr));
#line 119
  status = (int )tmp;
  }
#line 121
  if (status == -1) {
    {
#line 122
    tmp___0 = inet_ntoa(dest_addr);
#line 122
    snprintf((char */* __restrict  */)(errmsg), (size_t )80, (char const   */* __restrict  */)"%s\tSendto failed",
             tmp___0);
    }
#line 123
    if (! quiet) {
      {
#line 123
      perror((char const   *)(errmsg));
      }
    }
  }
#line 125
  return;
}
}
#line 127 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
uint32_t get32(void *data ) 
{ 
  union __anonunion_x_33 x ;
  uint32_t tmp ;

  {
  {
#line 133
  memcpy((void */* __restrict  */)(x.bytes), (void const   */* __restrict  */)data,
         (size_t )4);
#line 134
  tmp = ntohl(x.all);
  }
#line 134
  return (tmp);
}
}
#line 137 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
uint16_t get16(void *data ) 
{ 
  union __anonunion_x_34 x ;
  uint16_t tmp ;

  {
  {
#line 143
  memcpy((void */* __restrict  */)(x.bytes), (void const   */* __restrict  */)data,
         (size_t )2);
#line 144
  tmp = ntohs(x.all);
  }
#line 144
  return (tmp);
}
}
#line 147 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
struct nb_host_info *parse_response(char *buff , int buffsize ) 
{ 
  struct nb_host_info *hostinfo ;
  nbname_response_footer_t *response_footer ;
  nbname_response_header_t *response_header ;
  int name_table_size ;
  int offset ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct nbname *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 148
  hostinfo = (struct nb_host_info *)((void *)0);
#line 152
  offset = 0;
#line 154
  tmp = malloc(sizeof(nbname_response_header_t ));
#line 154
  response_header = (nbname_response_header_t *)tmp;
  }
#line 154
  if ((unsigned long )response_header == (unsigned long )((void *)0)) {
#line 154
    return ((struct nb_host_info *)((void *)0));
  }
  {
#line 155
  tmp___0 = malloc(sizeof(nbname_response_footer_t ));
#line 155
  response_footer = (nbname_response_footer_t *)tmp___0;
  }
#line 155
  if ((unsigned long )response_footer == (unsigned long )((void *)0)) {
#line 155
    return ((struct nb_host_info *)((void *)0));
  }
  {
#line 156
  bzero((void *)response_header, sizeof(nbname_response_header_t ));
#line 157
  bzero((void *)response_footer, sizeof(nbname_response_footer_t ));
#line 159
  tmp___1 = malloc(sizeof(struct nb_host_info ));
#line 159
  hostinfo = (struct nb_host_info *)tmp___1;
  }
#line 159
  if ((unsigned long )hostinfo == (unsigned long )((void *)0)) {
#line 159
    return ((struct nb_host_info *)((void *)0));
  }
#line 160
  hostinfo->header = (struct nbname_response_header *)((void *)0);
#line 161
  hostinfo->names = (struct nbname *)((void *)0);
#line 162
  hostinfo->footer = (struct nbname_response_footer *)((void *)0);
#line 166
  if ((unsigned long )offset + sizeof(response_header->transaction_id) >= (unsigned long )buffsize) {
#line 166
    goto broken_packet;
  }
  {
#line 167
  response_header->transaction_id = get16((void *)(buff + offset));
#line 169
  offset = (int )((unsigned long )offset + sizeof(response_header->transaction_id));
#line 170
  hostinfo->header = response_header;
  }
#line 173
  if ((unsigned long )offset + sizeof(response_header->flags) >= (unsigned long )buffsize) {
#line 173
    goto broken_packet;
  }
  {
#line 174
  response_header->flags = get16((void *)(buff + offset));
#line 175
  offset = (int )((unsigned long )offset + sizeof(response_header->flags));
  }
#line 177
  if ((unsigned long )offset + sizeof(response_header->question_count) >= (unsigned long )buffsize) {
#line 177
    goto broken_packet;
  }
  {
#line 178
  response_header->question_count = get16((void *)(buff + offset));
#line 179
  offset = (int )((unsigned long )offset + sizeof(response_header->question_count));
  }
#line 181
  if ((unsigned long )offset + sizeof(response_header->answer_count) >= (unsigned long )buffsize) {
#line 181
    goto broken_packet;
  }
  {
#line 182
  response_header->answer_count = get16((void *)(buff + offset));
#line 183
  offset = (int )((unsigned long )offset + sizeof(response_header->answer_count));
  }
#line 185
  if ((unsigned long )offset + sizeof(response_header->name_service_count) >= (unsigned long )buffsize) {
#line 185
    goto broken_packet;
  }
  {
#line 186
  response_header->name_service_count = get16((void *)(buff + offset));
#line 187
  offset = (int )((unsigned long )offset + sizeof(response_header->name_service_count));
  }
#line 189
  if ((unsigned long )offset + sizeof(response_header->additional_record_count) >= (unsigned long )buffsize) {
#line 189
    goto broken_packet;
  }
  {
#line 190
  response_header->additional_record_count = get16((void *)(buff + offset));
#line 191
  offset = (int )((unsigned long )offset + sizeof(response_header->additional_record_count));
  }
#line 193
  if ((unsigned long )offset + sizeof(response_header->question_name) >= (unsigned long )buffsize) {
#line 193
    goto broken_packet;
  }
  {
#line 194
  strncpy((char */* __restrict  */)(response_header->question_name), (char const   */* __restrict  */)(buff + offset),
          sizeof(response_header->question_name));
#line 195
  offset = (int )((unsigned long )offset + sizeof(response_header->question_name));
  }
#line 197
  if ((unsigned long )offset + sizeof(response_header->question_type) >= (unsigned long )buffsize) {
#line 197
    goto broken_packet;
  }
  {
#line 198
  response_header->question_type = get16((void *)(buff + offset));
#line 199
  offset = (int )((unsigned long )offset + sizeof(response_header->question_type));
  }
#line 201
  if ((unsigned long )offset + sizeof(response_header->question_class) >= (unsigned long )buffsize) {
#line 201
    goto broken_packet;
  }
  {
#line 202
  response_header->question_class = get16((void *)(buff + offset));
#line 203
  offset = (int )((unsigned long )offset + sizeof(response_header->question_class));
  }
#line 205
  if ((unsigned long )offset + sizeof(response_header->ttl) >= (unsigned long )buffsize) {
#line 205
    goto broken_packet;
  }
  {
#line 206
  response_header->ttl = get32((void *)(buff + offset));
#line 207
  offset = (int )((unsigned long )offset + sizeof(response_header->ttl));
  }
#line 209
  if ((unsigned long )offset + sizeof(response_header->rdata_length) >= (unsigned long )buffsize) {
#line 209
    goto broken_packet;
  }
  {
#line 210
  response_header->rdata_length = get16((void *)(buff + offset));
#line 211
  offset = (int )((unsigned long )offset + sizeof(response_header->rdata_length));
  }
#line 213
  if ((unsigned long )offset + sizeof(response_header->number_of_names) >= (unsigned long )buffsize) {
#line 213
    goto broken_packet;
  }
#line 214
  response_header->number_of_names = *((uint8_t *)(buff + offset));
#line 215
  offset = (int )((unsigned long )offset + sizeof(response_header->number_of_names));
#line 219
  name_table_size = (int )((unsigned long )response_header->number_of_names * sizeof(struct nbname ));
#line 220
  if (offset + name_table_size >= buffsize) {
#line 220
    goto broken_packet;
  }
  {
#line 222
  tmp___3 = malloc((size_t )name_table_size);
#line 222
  tmp___2 = (struct nbname *)tmp___3;
#line 222
  hostinfo->names = tmp___2;
  }
#line 222
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 222
    return ((struct nb_host_info *)((void *)0));
  }
  {
#line 223
  memcpy((void */* __restrict  */)hostinfo->names, (void const   */* __restrict  */)(buff + offset),
         (size_t )name_table_size);
#line 225
  offset += name_table_size;
  }
#line 231
  if ((unsigned long )offset + sizeof(response_footer->adapter_address) >= (unsigned long )buffsize) {
#line 231
    goto broken_packet;
  }
  {
#line 232
  memcpy((void */* __restrict  */)(response_footer->adapter_address), (void const   */* __restrict  */)(buff + offset),
         sizeof(response_footer->adapter_address));
#line 235
  offset = (int )((unsigned long )offset + sizeof(response_footer->adapter_address));
#line 237
  hostinfo->footer = response_footer;
  }
#line 239
  if ((unsigned long )offset + sizeof(response_footer->version_major) >= (unsigned long )buffsize) {
#line 239
    goto broken_packet;
  }
#line 240
  response_footer->version_major = *((uint8_t *)(buff + offset));
#line 241
  offset = (int )((unsigned long )offset + sizeof(response_footer->version_major));
#line 243
  if ((unsigned long )offset + sizeof(response_footer->version_minor) >= (unsigned long )buffsize) {
#line 243
    goto broken_packet;
  }
#line 244
  response_footer->version_minor = *((uint8_t *)(buff + offset));
#line 245
  offset = (int )((unsigned long )offset + sizeof(response_footer->version_minor));
#line 247
  if ((unsigned long )offset + sizeof(response_footer->duration) >= (unsigned long )buffsize) {
#line 247
    goto broken_packet;
  }
  {
#line 248
  response_footer->duration = get16((void *)(buff + offset));
#line 249
  offset = (int )((unsigned long )offset + sizeof(response_footer->duration));
  }
#line 251
  if ((unsigned long )offset + sizeof(response_footer->frmps_received) >= (unsigned long )buffsize) {
#line 251
    goto broken_packet;
  }
  {
#line 252
  response_footer->frmps_received = get16((void *)(buff + offset));
#line 253
  offset = (int )((unsigned long )offset + sizeof(response_footer->frmps_received));
  }
#line 255
  if ((unsigned long )offset + sizeof(response_footer->frmps_transmitted) >= (unsigned long )buffsize) {
#line 255
    goto broken_packet;
  }
  {
#line 256
  response_footer->frmps_transmitted = get16((void *)(buff + offset));
#line 257
  offset = (int )((unsigned long )offset + sizeof(response_footer->frmps_transmitted));
  }
#line 259
  if ((unsigned long )offset + sizeof(response_footer->iframe_receive_errors) >= (unsigned long )buffsize) {
#line 259
    goto broken_packet;
  }
  {
#line 260
  response_footer->iframe_receive_errors = get16((void *)(buff + offset));
#line 261
  offset = (int )((unsigned long )offset + sizeof(response_footer->iframe_receive_errors));
  }
#line 263
  if ((unsigned long )offset + sizeof(response_footer->transmit_aborts) >= (unsigned long )buffsize) {
#line 263
    goto broken_packet;
  }
  {
#line 264
  response_footer->transmit_aborts = get16((void *)(buff + offset));
#line 265
  offset = (int )((unsigned long )offset + sizeof(response_footer->transmit_aborts));
  }
#line 267
  if ((unsigned long )offset + sizeof(response_footer->transmitted) >= (unsigned long )buffsize) {
#line 267
    goto broken_packet;
  }
  {
#line 268
  response_footer->transmitted = get32((void *)(buff + offset));
#line 269
  offset = (int )((unsigned long )offset + sizeof(response_footer->transmitted));
  }
#line 271
  if ((unsigned long )offset + sizeof(response_footer->received) >= (unsigned long )buffsize) {
#line 271
    goto broken_packet;
  }
  {
#line 272
  response_footer->received = get32((void *)(buff + offset));
#line 273
  offset = (int )((unsigned long )offset + sizeof(response_footer->received));
  }
#line 275
  if ((unsigned long )offset + sizeof(response_footer->iframe_transmit_errors) >= (unsigned long )buffsize) {
#line 275
    goto broken_packet;
  }
  {
#line 276
  response_footer->iframe_transmit_errors = get16((void *)(buff + offset));
#line 277
  offset = (int )((unsigned long )offset + sizeof(response_footer->iframe_transmit_errors));
  }
#line 279
  if ((unsigned long )offset + sizeof(response_footer->no_receive_buffer) >= (unsigned long )buffsize) {
#line 279
    goto broken_packet;
  }
  {
#line 280
  response_footer->no_receive_buffer = get16((void *)(buff + offset));
#line 281
  offset = (int )((unsigned long )offset + sizeof(response_footer->no_receive_buffer));
  }
#line 283
  if ((unsigned long )offset + sizeof(response_footer->tl_timeouts) >= (unsigned long )buffsize) {
#line 283
    goto broken_packet;
  }
  {
#line 284
  response_footer->tl_timeouts = get16((void *)(buff + offset));
#line 285
  offset = (int )((unsigned long )offset + sizeof(response_footer->tl_timeouts));
  }
#line 287
  if ((unsigned long )offset + sizeof(response_footer->ti_timeouts) >= (unsigned long )buffsize) {
#line 287
    goto broken_packet;
  }
  {
#line 288
  response_footer->ti_timeouts = get16((void *)(buff + offset));
#line 289
  offset = (int )((unsigned long )offset + sizeof(response_footer->ti_timeouts));
  }
#line 291
  if ((unsigned long )offset + sizeof(response_footer->free_ncbs) >= (unsigned long )buffsize) {
#line 291
    goto broken_packet;
  }
  {
#line 292
  response_footer->free_ncbs = get16((void *)(buff + offset));
#line 293
  offset = (int )((unsigned long )offset + sizeof(response_footer->free_ncbs));
  }
#line 295
  if ((unsigned long )offset + sizeof(response_footer->ncbs) >= (unsigned long )buffsize) {
#line 295
    goto broken_packet;
  }
  {
#line 296
  response_footer->ncbs = get16((void *)(buff + offset));
#line 297
  offset = (int )((unsigned long )offset + sizeof(response_footer->ncbs));
  }
#line 299
  if ((unsigned long )offset + sizeof(response_footer->max_ncbs) >= (unsigned long )buffsize) {
#line 299
    goto broken_packet;
  }
  {
#line 300
  response_footer->max_ncbs = get16((void *)(buff + offset));
#line 301
  offset = (int )((unsigned long )offset + sizeof(response_footer->max_ncbs));
  }
#line 303
  if ((unsigned long )offset + sizeof(response_footer->no_transmit_buffers) >= (unsigned long )buffsize) {
#line 303
    goto broken_packet;
  }
  {
#line 304
  response_footer->no_transmit_buffers = get16((void *)(buff + offset));
#line 305
  offset = (int )((unsigned long )offset + sizeof(response_footer->no_transmit_buffers));
  }
#line 307
  if ((unsigned long )offset + sizeof(response_footer->max_datagram) >= (unsigned long )buffsize) {
#line 307
    goto broken_packet;
  }
  {
#line 308
  response_footer->max_datagram = get16((void *)(buff + offset));
#line 309
  offset = (int )((unsigned long )offset + sizeof(response_footer->max_datagram));
  }
#line 311
  if ((unsigned long )offset + sizeof(response_footer->pending_sessions) >= (unsigned long )buffsize) {
#line 311
    goto broken_packet;
  }
  {
#line 312
  response_footer->pending_sessions = get16((void *)(buff + offset));
#line 313
  offset = (int )((unsigned long )offset + sizeof(response_footer->pending_sessions));
  }
#line 315
  if ((unsigned long )offset + sizeof(response_footer->max_sessions) >= (unsigned long )buffsize) {
#line 315
    goto broken_packet;
  }
  {
#line 316
  response_footer->max_sessions = get16((void *)(buff + offset));
#line 317
  offset = (int )((unsigned long )offset + sizeof(response_footer->max_sessions));
  }
#line 319
  if ((unsigned long )offset + sizeof(response_footer->packet_sessions) >= (unsigned long )buffsize) {
#line 319
    goto broken_packet;
  }
  {
#line 320
  response_footer->packet_sessions = get16((void *)(buff + offset));
#line 321
  offset = (int )((unsigned long )offset + sizeof(response_footer->packet_sessions));
  }
#line 325
  return (hostinfo);
  broken_packet: 
#line 328
  hostinfo->is_broken = offset;
#line 329
  return (hostinfo);
}
}
#line 332 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
nb_service_t services[35]  = 
#line 332
  {      {{(char )'_', (char )'_', (char )'M', (char )'S', (char )'B', (char )'R', (char )'O',
       (char )'W', (char )'S', (char )'E', (char )'_', (char )'_', (char )'\000'},
      (uint8_t )1, 0, (char *)"Master Browser"}, 
        {{(char )'I', (char )'N', (char )'e', (char )'t', (char )'~', (char )'S', (char )'e',
       (char )'r', (char )'v', (char )'i', (char )'c', (char )'e', (char )'s', (char )'\000'},
      (uint8_t )28, 0, (char *)"IIS"}, 
        {{(char )'I', (char )'S', (char )'~', (char )'\000'}, (uint8_t )0, 1, (char *)"IIS"}, 
        {{(char )'\000'},
      (uint8_t )0, 1, (char *)"Workstation Service"}, 
        {{(char )'\000'}, (uint8_t )1, 1, (char *)"Messenger Service"}, 
        {{(char )'\000'}, (uint8_t )3, 1, (char *)"Messenger Service"}, 
        {{(char )'\000'}, (uint8_t )6, 1, (char *)"RAS Server Service"}, 
        {{(char )'\000'}, (uint8_t )31, 1, (char *)"NetDDE Service"}, 
        {{(char )'\000'}, (uint8_t )32, 1, (char *)"File Server Service"}, 
        {{(char )'\000'}, (uint8_t )33, 1, (char *)"RAS Client Service"}, 
        {{(char )'\000'}, (uint8_t )34, 1, (char *)"Microsoft Exchange Interchange(MSMail Connector)"}, 
        {{(char )'\000'},
      (uint8_t )35, 1, (char *)"Microsoft Exchange Store"}, 
        {{(char )'\000'}, (uint8_t )36, 1, (char *)"Microsoft Exchange Directory"}, 
        {{(char )'\000'}, (uint8_t )48, 1, (char *)"Modem Sharing Server Service"}, 
        {{(char )'\000'}, (uint8_t )49, 1, (char *)"Modem Sharing Client Service"}, 
        {{(char )'\000'}, (uint8_t )67, 1, (char *)"SMS Clients Remote Control"}, 
        {{(char )'\000'}, (uint8_t )68, 1, (char *)"SMS Administrators Remote Control Tool"}, 
        {{(char )'\000'},
      (uint8_t )69, 1, (char *)"SMS Clients Remote Chat"}, 
        {{(char )'\000'}, (uint8_t )70, 1, (char *)"SMS Clients Remote Transfer"}, 
        {{(char )'\000'}, (uint8_t )76, 1, (char *)"DEC Pathworks TCPIP service on Windows NT"}, 
        {{(char )'\000'},
      (uint8_t )82, 1, (char *)"DEC Pathworks TCPIP service on Windows NT"}, 
        {{(char )'\000'}, (uint8_t )135, 1, (char *)"Microsoft Exchange MTA"}, 
        {{(char )'\000'}, (uint8_t )106, 1, (char *)"Microsoft Exchange IMC"}, 
        {{(char )'\000'}, (uint8_t )190, 1, (char *)"Network Monitor Agent"}, 
        {{(char )'\000'}, (uint8_t )191, 1, (char *)"Network Monitor Application"}, 
        {{(char )'\000'}, (uint8_t )3, 1, (char *)"Messenger Service"}, 
        {{(char )'\000'}, (uint8_t )0, 0, (char *)"Domain Name"}, 
        {{(char )'\000'}, (uint8_t )27, 1, (char *)"Domain Master Browser"}, 
        {{(char )'\000'}, (uint8_t )28, 0, (char *)"Domain Controllers"}, 
        {{(char )'\000'}, (uint8_t )29, 1, (char *)"Master Browser"}, 
        {{(char )'\000'}, (uint8_t )30, 0, (char *)"Browser Service Elections"}, 
        {{(char )'\000'}, (uint8_t )43, 1, (char *)"Lotus Notes Server Service"}, 
        {{(char )'I', (char )'R', (char )'I', (char )'S', (char )'M', (char )'U', (char )'L',
       (char )'T', (char )'I', (char )'C', (char )'A', (char )'S', (char )'T', (char )'\000'},
      (uint8_t )47, 0, (char *)"Lotus Notes"}, 
        {{(char )'I', (char )'R', (char )'I', (char )'S', (char )'N', (char )'A', (char )'M',
       (char )'E', (char )'S', (char )'E', (char )'R', (char )'V', (char )'E', (char )'R',
       (char )'\000'}, (uint8_t )51, 0, (char *)"Lotus Notes"}, 
        {{(char )'F', (char )'o', (char )'r', (char )'t', (char )'e', (char )'_', (char )'$',
       (char )'N', (char )'D', (char )'8', (char )'0', (char )'0', (char )'Z', (char )'A',
       (char )'\000'}, (uint8_t )32, 1, (char *)"DCA IrmaLan Gateway Server Service"}};
#line 370 "/home/wheatley/newnew/temp/nbtscan-1.5.1/statusq.c"
char *getnbservicename(uint8_t service , int unique , char *name ) 
{ 
  int i ;
  char *unknown ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 374
  tmp = malloc((size_t )100);
#line 374
  unknown = (char *)tmp;
  }
#line 376
  if (! unknown) {
    {
#line 376
    perror("Malloc failed.\n");
#line 376
    exit(1);
    }
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! (i < 35)) {
#line 378
      goto while_break;
    }
    {
#line 379
    tmp___0 = strstr((char const   *)name, (char const   *)(services[i].nb_name));
    }
#line 379
    if (tmp___0) {
#line 379
      if ((int )service == (int )services[i].service_number) {
#line 379
        if (unique == services[i].unique) {
#line 382
          return (services[i].service_name);
        }
      }
    }
#line 378
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  snprintf((char */* __restrict  */)unknown, (size_t )100, (char const   */* __restrict  */)"Unknown service (code %x)",
           (int )service);
  }
#line 386
  return (unknown);
}
}
