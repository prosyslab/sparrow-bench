/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 46 "/usr/include/err.h"
extern  __attribute__((__noreturn__)) void ( /* format attribute */  err)(int __status ,
                                                                          char const   *__format 
                                                                          , ...) ;
#line 50
extern  __attribute__((__noreturn__)) void ( /* format attribute */  errx)(int __status ,
                                                                           char const   *__format 
                                                                           , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 61 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetspeed)(struct termios *__termios_p ,
                                                                                 speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 90
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcflush)(int __fd ,
                                                                              int __queue_selector ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapimkt/ctapi.h"
char CT_init(unsigned short ctn , unsigned short pn ) ;
#line 59
char CT_data(unsigned short ctn , unsigned char *dad , unsigned char *sad , unsigned short lenc ,
             unsigned char *command , unsigned short *lenr , unsigned char *response ) ;
#line 67
char CT_close(unsigned short ctn ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
unsigned char ask_resync[4]  = {      (unsigned char)18,      (unsigned char)192,      (unsigned char)0,      (unsigned char)210};
#line 62 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
unsigned char ask_resync_medMobile[9]  = 
#line 62
  {      (unsigned char)22,      (unsigned char)0,      (unsigned char)5,      (unsigned char)32, 
        (unsigned char)17,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)34};
#line 63 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
unsigned char frage[300]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
struct termios tios  ;
#line 65 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int wtx  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int pcb  =    0;
#line 67 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int maxbytes[255]  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int ctn2fd[255]  = 
#line 69
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0};
#line 80 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
unsigned char fxor(unsigned char const   *s , int l ) 
{ 
  unsigned char r ;
  int tmp ;

  {
#line 81
  r = (unsigned char)0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    tmp = l;
#line 82
    l --;
#line 82
    if (! tmp) {
#line 82
      goto while_break;
    }
#line 82
    r = (unsigned char )((int )r ^ (int )*(s + l));
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return (r);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int sendblock(int port , unsigned char *block , unsigned short lenc ) 
{ 
  int retval ;
  ssize_t tmp ;

  {
  {
#line 98
  tmp = write(port, (void const   *)block, (size_t )lenc);
#line 98
  retval = (int )tmp;
  }
#line 99
  if (retval < 0) {
#line 99
    return (retval);
  }
#line 100
  if (retval != (int )lenc) {
#line 100
    return (-1);
  }
#line 101
  return (retval);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
int readblock(int port , unsigned short len ) 
{ 
  int retval ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
  {
#line 107
  memset((void *)(frage), 0, sizeof(frage));
#line 108
  tmp = tcgetattr(port, & tios);
  }
#line 108
  if (tmp == -1) {
    {
#line 108
    err(1, (char const   *)((void *)0));
    }
  }
  {
#line 109
  tios.c_cc[6] = (cc_t )len;
#line 110
  tmp___0 = tcsetattr(port, 0, (struct termios  const  *)(& tios));
  }
#line 110
  if (tmp___0 == -1) {
    {
#line 110
    err(1, (char const   *)((void *)0));
    }
  }
  {
#line 111
  tmp___1 = read(port, (void *)(frage), (size_t )len);
#line 111
  retval = (int )tmp___1;
  }
#line 112
  if (retval < 0) {
#line 112
    return (retval);
  }
#line 121
  return (retval);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
char CT_init(unsigned short ctn , unsigned short pn ) 
{ 
  int port ;
  int flags ;
  int retval ;
  int lenc ;
  unsigned char apdu[1250] ;
  unsigned char device[20] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;

  {
#line 130
  maxbytes[ctn] = 32;
  {
#line 133
  if ((int )ctn == 0) {
#line 133
    goto case_0;
  }
#line 134
  if ((int )ctn == 1) {
#line 134
    goto case_1;
  }
#line 135
  if ((int )ctn == 2) {
#line 135
    goto case_2;
  }
#line 136
  if ((int )ctn == 3) {
#line 136
    goto case_3;
  }
#line 137
  if ((int )ctn == 4) {
#line 137
    goto case_4;
  }
#line 138
  if ((int )ctn == 5) {
#line 138
    goto case_5;
  }
#line 139
  if ((int )ctn == 6) {
#line 139
    goto case_6;
  }
#line 140
  if ((int )ctn == 7) {
#line 140
    goto case_7;
  }
#line 141
  if ((int )ctn == 8) {
#line 141
    goto case_8;
  }
#line 142
  if ((int )ctn == 9) {
#line 142
    goto case_9;
  }
#line 143
  if ((int )ctn == 10) {
#line 143
    goto case_10;
  }
#line 144
  if ((int )ctn == 11) {
#line 144
    goto case_11;
  }
#line 145
  if ((int )ctn == 12) {
#line 145
    goto case_12;
  }
#line 146
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 133
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS0");
  }
#line 133
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 134
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS0");
  }
#line 134
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 135
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS1");
  }
#line 135
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 136
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS2");
  }
#line 136
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 137
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS0");
  }
#line 137
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 138
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS1");
  }
#line 138
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 139
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyACM0");
  }
#line 139
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 140
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyACM1");
  }
#line 140
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 141
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS0");
  }
#line 141
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 142
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyUSB0");
  }
#line 142
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 143
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyUSB0");
  }
#line 143
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 144
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyACM0");
  }
#line 144
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 145
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyACM1");
  }
#line 145
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 146
  strcpy((char */* __restrict  */)(device), (char const   */* __restrict  */)"/dev/ttyS0");
  }
#line 146
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 149
  if (ctn2fd[ctn] == 0) {
    {
#line 150
    port = open((char const   *)(device), 2306);
    }
#line 151
    if (port < 0) {
#line 151
      return ((char)-1);
    }
    {
#line 152
    tmp = tcgetattr(port, & tios);
    }
#line 152
    if (tmp == -1) {
      {
#line 152
      err(1, (char const   *)((void *)0));
      }
    }
#line 153
    tios.c_iflag &= 4294950912U;
#line 154
    tios.c_oflag &= 4294967294U;
#line 155
    tios.c_cflag &= 2147483071U;
#line 156
    tios.c_cflag |= 2304U;
#line 157
    tios.c_lflag &= 4294967280U;
#line 158
    tios.c_cc[5] = (cc_t )0;
#line 159
    if ((int )ctn == 4) {
      {
#line 160
      cfsetspeed(& tios, (speed_t )4098);
      }
    } else
#line 159
    if ((int )ctn == 5) {
      {
#line 160
      cfsetspeed(& tios, (speed_t )4098);
      }
    } else
#line 159
    if ((int )ctn == 10) {
      {
#line 160
      cfsetspeed(& tios, (speed_t )4098);
      }
    } else {
      {
#line 163
      cfsetspeed(& tios, (speed_t )13);
      }
    }
    {
#line 165
    tmp___0 = tcsetattr(port, 0, (struct termios  const  *)(& tios));
    }
#line 165
    if (tmp___0 == -1) {
      {
#line 165
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 166
    tmp___1 = tcflush(port, 2);
    }
#line 166
    if (tmp___1 == -1) {
      {
#line 166
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 167
    flags = fcntl(port, 3);
    }
#line 168
    if (flags == -1) {
      {
#line 168
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 169
    tmp___2 = fcntl(port, 4, flags & -2049);
    }
#line 169
    if (tmp___2 == -1) {
      {
#line 169
      err(1, (char const   *)((void *)0));
      }
    }
#line 170
    if (flags == -1) {
      {
#line 170
      err(1, (char const   *)((void *)0));
      }
    }
  }
#line 173
  if ((int )ctn == 8) {
    {
#line 174
    usleep((__useconds_t )50000);
    }
  }
#line 176
  if ((int )ctn == 11) {
#line 176
    goto _L;
  } else
#line 176
  if ((int )ctn == 12) {
    _L: /* CIL Label */ 
    {
#line 177
    lenc = (int )sizeof(ask_resync_medMobile);
#line 185
    tmp___3 = write(port, (void const   *)(ask_resync_medMobile), (size_t )lenc);
#line 185
    retval = (int )tmp___3;
    }
#line 186
    if (retval < 0) {
#line 186
      return ((char )retval);
    }
    {
#line 187
    tmp___4 = tcgetattr(port, & tios);
    }
#line 187
    if (tmp___4 == -1) {
      {
#line 187
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 188
    tios.c_cc[6] = (cc_t )6;
#line 189
    tmp___5 = tcsetattr(port, 0, (struct termios  const  *)(& tios));
    }
#line 189
    if (tmp___5 == -1) {
      {
#line 189
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 190
    tmp___6 = read(port, (void *)(apdu), (size_t )6);
#line 190
    retval = (int )tmp___6;
    }
#line 199
    if (retval < 0) {
#line 199
      return ((char)-1);
    }
#line 200
    if ((int )apdu[0] != 97) {
#line 200
      return ((char)-1);
    } else
#line 200
    if ((int )apdu[1] != 0) {
#line 200
      return ((char)-1);
    }
  } else {
    {
#line 203
    lenc = (int )sizeof(ask_resync);
#line 211
    tmp___7 = write(port, (void const   *)(ask_resync), (size_t )lenc);
#line 211
    retval = (int )tmp___7;
    }
#line 212
    if (retval < 0) {
#line 212
      return ((char)-1);
    }
    {
#line 213
    tmp___8 = tcgetattr(port, & tios);
    }
#line 213
    if (tmp___8 == -1) {
      {
#line 213
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 214
    tios.c_cc[6] = (cc_t )4;
#line 215
    tmp___9 = tcsetattr(port, 0, (struct termios  const  *)(& tios));
    }
#line 215
    if (tmp___9 == -1) {
      {
#line 215
      err(1, (char const   *)((void *)0));
      }
    }
    {
#line 217
    tmp___10 = read(port, (void *)(apdu), (size_t )4);
#line 217
    retval = (int )tmp___10;
    }
#line 226
    if (retval < 0) {
#line 226
      return ((char )retval);
    }
#line 227
    if ((int )apdu[0] != 33) {
#line 227
      return ((char)-1);
    } else
#line 227
    if ((int )apdu[1] != 224) {
#line 227
      return ((char)-1);
    }
  }
#line 229
  pcb = 0;
#line 230
  ctn2fd[ctn] = port;
#line 231
  return ((char)0);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
char CT_data(unsigned short ctn , unsigned char *dad , unsigned char *sad , unsigned short lenc ,
             unsigned char *command , unsigned short *lenr , unsigned char *response ) 
{ 
  int port ;
  int retval ;
  int i ;
  int j ;
  int lenblock ;
  int lenresp ;
  int fehler ;
  unsigned char block[300] ;
  unsigned char len ;
  unsigned char apdu[300] ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;

  {
#line 250
  port = ctn2fd[ctn];
#line 250
  if (port < 1) {
#line 251
    *lenr = (unsigned short)0;
#line 252
    return ((char)-8);
  }
#line 254
  len = (unsigned char )*lenr;
#line 255
  lenresp = 0;
#line 256
  fehler = 0;
#line 258
  block[0] = (unsigned char )(((int )*dad << 4) | (int )*sad);
#line 260
  if ((int )lenc == 0) {
#line 261
    if (wtx == 0) {
#line 262
      block[1] = (unsigned char)128;
#line 263
      wtx = 1;
    } else {
#line 266
      block[1] = (unsigned char)144;
#line 267
      wtx = 0;
    }
  } else
#line 271
  if (pcb == 0) {
#line 272
    block[1] = (unsigned char)0;
#line 273
    pcb = 1;
#line 274
    wtx = 0;
  } else {
#line 277
    block[1] = (unsigned char)64;
#line 278
    pcb = 0;
#line 279
    wtx = 0;
  }
  {
#line 283
  block[2] = (unsigned char )lenc;
#line 284
  memcpy((void */* __restrict  */)(& block[3]), (void const   */* __restrict  */)command,
         (size_t )lenc);
#line 286
  block[(int )lenc + 3] = fxor((unsigned char const   *)(block), (int )lenc + 3);
#line 287
  lenc = (unsigned short )((int )lenc + 4);
#line 289
  j = 0;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (j < 10)) {
#line 290
      goto while_break;
    }
    {
#line 291
    retval = sendblock(port, block, lenc);
    }
#line 292
    if (retval < 0) {
#line 292
      return ((char )retval);
    }
    {
#line 294
    retval = readblock(port, (unsigned short)3);
    }
#line 295
    if (retval < 0) {
#line 295
      return ((char )retval);
    }
    {
#line 297
    memset((void *)(apdu), 0, sizeof(apdu));
#line 298
    i = 0;
    }
    {
#line 298
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 298
      if (! (i < 3)) {
#line 298
        goto while_break___0;
      }
#line 299
      apdu[i] = frage[i];
#line 298
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 301
    len = (unsigned char )((int )frage[retval - 1] + 1);
#line 303
    if ((int )frage[1] == 129) {
#line 303
      goto _L___0;
    } else
#line 303
    if ((int )frage[1] == 145) {
#line 303
      goto _L___0;
    } else
#line 303
    if ((int )frage[1] == 130) {
#line 303
      goto _L___0;
    } else
#line 303
    if ((int )frage[1] == 146) {
      _L___0: /* CIL Label */ 
      {
#line 308
      retval = readblock(port, (unsigned short)1);
      }
#line 309
      if (retval < 0) {
#line 309
        return ((char )retval);
      }
      {
#line 311
      apdu[3] = frage[0];
#line 312
      tmp = fxor((unsigned char const   *)(apdu), 3);
      }
#line 312
      if ((int )apdu[3] != (int )tmp) {
#line 312
        return ((char)-1);
      }
#line 313
      fehler ++;
#line 314
      if (fehler == 2) {
        {
#line 315
        retval = sendblock(port, ask_resync, (unsigned short )sizeof(ask_resync));
        }
#line 316
        if (retval < 0) {
#line 316
          return ((char )retval);
        }
        {
#line 318
        retval = readblock(port, (unsigned short)4);
        }
#line 319
        if (retval < 0) {
#line 319
          return ((char )retval);
        }
        {
#line 320
        tmp___0 = fxor((unsigned char const   *)(frage), 3);
        }
#line 320
        if ((int )frage[3] != (int )tmp___0) {
#line 320
          return ((char)-1);
        }
#line 321
        if ((int )frage[1] != 224) {
#line 321
          return ((char)-1);
        }
#line 322
        block[1] = (unsigned char)0;
#line 323
        pcb = 1;
#line 324
        wtx = 0;
      }
    } else
#line 327
    if ((int )frage[1] == 192) {
      {
#line 332
      retval = readblock(port, (unsigned short)1);
      }
#line 333
      if (retval < 0) {
#line 333
        return ((char )retval);
      }
      {
#line 335
      apdu[3] = frage[0];
#line 336
      tmp___1 = fxor((unsigned char const   *)(apdu), 3);
      }
#line 336
      if ((int )apdu[3] != (int )tmp___1) {
#line 336
        return ((char)-1);
      }
      {
#line 337
      fehler = 0;
#line 338
      apdu[1] = (unsigned char)224;
#line 339
      apdu[3] = fxor((unsigned char const   *)(apdu), 3);
#line 340
      retval = sendblock(port, apdu, (unsigned short)4);
      }
#line 341
      if (retval < 0) {
#line 341
        return ((char )retval);
      }
#line 342
      block[1] = (unsigned char)0;
#line 343
      pcb = 1;
#line 344
      wtx = 0;
    } else
#line 346
    if ((int )frage[1] == 195) {
#line 350
      if (j == 10) {
        {
#line 350
        errx(1, "WTX-Fehler\n");
        }
      }
      {
#line 351
      retval = readblock(port, (unsigned short )len);
      }
#line 352
      if (retval < 0) {
#line 352
        return ((char )retval);
      }
#line 354
      lenblock = (int )len + 3;
#line 355
      i = 0;
      {
#line 355
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 355
        if (! (i < lenblock)) {
#line 355
          goto while_break___1;
        }
#line 356
        apdu[i + 3] = frage[i];
#line 355
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 358
      tmp___2 = fxor((unsigned char const   *)(apdu), lenblock - 1);
      }
#line 358
      if ((int )apdu[lenblock - 1] != (int )tmp___2) {
#line 358
        return ((char)-1);
      }
#line 359
      i = 0;
      {
#line 359
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 359
        if (! (i < lenblock)) {
#line 359
          goto while_break___2;
        }
#line 360
        block[i] = apdu[i];
#line 359
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 362
      block[0] = (unsigned char )(((int )block[0] << 4) | (int )*sad);
#line 363
      block[1] = (unsigned char)227;
#line 364
      block[lenblock - 1] = fxor((unsigned char const   *)(block), lenblock - 1);
#line 365
      lenc = (unsigned short )lenblock;
#line 366
      j ++;
      }
    } else {
      {
#line 369
      retval = readblock(port, (unsigned short )len);
      }
#line 370
      if (retval < 0) {
#line 370
        return ((char )retval);
      }
#line 372
      lenblock = (int )len + 3;
#line 373
      i = 0;
      {
#line 373
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 373
        if (! (i < lenblock)) {
#line 373
          goto while_break___3;
        }
#line 374
        apdu[i + 3] = frage[i];
#line 375
        *(response + (lenresp + i)) = frage[i];
#line 373
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 377
      tmp___3 = fxor((unsigned char const   *)(apdu), lenblock - 1);
      }
#line 377
      if ((int )apdu[lenblock - 1] != (int )tmp___3) {
#line 377
        return ((char)-1);
      }
      {
#line 379
      lenblock = (int )len + 3;
#line 380
      lenresp = (lenresp + (int )len) - 1;
#line 381
      *lenr = (unsigned short )lenresp;
#line 387
      tmp___4 = fxor((unsigned char const   *)(apdu), lenblock - 1);
      }
#line 387
      if ((int )apdu[lenblock - 1] != (int )tmp___4) {
#line 388
        i = 0;
        {
#line 388
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 388
          if (! (i < lenblock + 1)) {
#line 388
            goto while_break___4;
          }
#line 388
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 393
        errx(1, "transmission error: fxor");
        }
      }
#line 395
      if ((int )apdu[1] == 96) {
#line 395
        goto _L;
      } else
#line 395
      if ((int )apdu[1] == 32) {
        _L: /* CIL Label */ 
#line 399
        if (j == 10) {
          {
#line 399
          errx(1, "Subsequent block-Fehler\n");
          }
        }
#line 400
        block[0] = (unsigned char)2;
#line 401
        if ((int )apdu[1] == 96) {
#line 402
          block[1] = (unsigned char)128;
        } else {
#line 405
          block[1] = (unsigned char)144;
        }
        {
#line 407
        block[2] = (unsigned char)0;
#line 408
        lenblock = 4;
#line 409
        block[lenblock - 1] = fxor((unsigned char const   *)(block), lenblock - 1);
#line 410
        lenc = (unsigned short )lenblock;
#line 411
        j ++;
        }
      } else {
#line 414
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return ((char)0);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/libctapimkt-1.0.5~rc1/ctapi.c"
char CT_close(unsigned short ctn ) 
{ 
  int port ;

  {
#line 424
  port = ctn2fd[ctn];
#line 424
  if (port < 1) {
#line 424
    return ((char)-1);
  }
  {
#line 425
  close(port);
#line 426
  ctn2fd[ctn] = 0;
  }
#line 427
  return ((char)0);
}
}
