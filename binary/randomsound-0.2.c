/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.h"
struct bitbuffer_s;
#line 15 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.h"
typedef struct bitbuffer_s *BitBuffer;
#line 17 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.h"
typedef unsigned char BitField;
#line 15 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
struct bitbuffer_s {
   int size ;
   int firstused ;
   int nextfree ;
   int bitsused ;
   BitField bits[0] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
union __anonunion_value_54 {
   int ints[128] ;
   BitField bitfield[512] ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
struct injector {
   int ent_count ;
   int size ;
   union __anonunion_value_54 value ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.h"
BitBuffer bitbuffer_new(int const   size ) ;
#line 35
void bitbuffer_free(BitBuffer buf ) ;
#line 44
int bitbuffer_free_space(BitBuffer const   buf ) ;
#line 54
int bitbuffer_available_bits(BitBuffer const   buf ) ;
#line 68
int bitbuffer_add_bits(BitBuffer buf , BitField const   bits , int count ) ;
#line 82
int bitbuffer_extract_bits(BitBuffer buf , BitField *bits , int count ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
BitBuffer bitbuffer_new(int const   size ) 
{ 
  int bytesize ;
  BitBuffer ret ;
  void *tmp ;

  {
  {
#line 29
  bytesize = (int )(((size + 7) & -8) >> 3);
#line 30
  tmp = malloc(sizeof(struct bitbuffer_s ) + (unsigned long )bytesize);
#line 30
  ret = (BitBuffer )tmp;
#line 31
  ret->size = (int )size;
#line 32
  ret->firstused = 0;
#line 33
  ret->nextfree = 0;
#line 34
  ret->bitsused = 0;
  }
#line 35
  return (ret);
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
void bitbuffer_free(BitBuffer buf ) 
{ 


  {
  {
#line 41
  free((void *)buf);
  }
#line 42
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
int bitbuffer_free_space(BitBuffer const   buf ) 
{ 


  {
#line 47
  return (buf->size - buf->bitsused);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
int bitbuffer_available_bits(BitBuffer const   buf ) 
{ 


  {
#line 53
  return (buf->bitsused);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
int bitbuffer_add_bits(BitBuffer buf , BitField const   bits , int count ) 
{ 
  int bits_to_add ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int i ;
  BitField subfield ;
  int tmp___6 ;

  {
#line 59
  if (8 < count) {
#line 59
    tmp___4 = 8;
  } else {
#line 59
    tmp___4 = count;
  }
  {
#line 59
  tmp___5 = bitbuffer_free_space((BitBuffer const   )buf);
  }
#line 59
  if (tmp___4 < tmp___5) {
#line 59
    if (8 < count) {
#line 59
      tmp___1 = 8;
    } else {
#line 59
      tmp___1 = count;
    }
#line 59
    tmp___3 = tmp___1;
  } else {
    {
#line 59
    tmp___2 = bitbuffer_free_space((BitBuffer const   )buf);
#line 59
    tmp___3 = tmp___2;
    }
  }
#line 59
  bits_to_add = tmp___3;
#line 61
  i = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < bits_to_add)) {
#line 61
      goto while_break;
    }
#line 62
    subfield = buf->bits[buf->nextfree >> 3];
#line 63
    if ((int const   )bits & (int const   )(1 << (i & 7))) {
#line 64
      subfield = (BitField )((int )subfield | (1 << (buf->nextfree & 7)));
    } else {
#line 66
      subfield = (BitField )((int )subfield & ~ (1 << (buf->nextfree & 7)));
    }
#line 67
    tmp___6 = buf->nextfree;
#line 67
    (buf->nextfree) ++;
#line 67
    buf->bits[tmp___6 >> 3] = subfield;
#line 68
    if (buf->nextfree == buf->size) {
#line 69
      buf->nextfree = 0;
    }
#line 61
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 71
  buf->bitsused += bits_to_add;
#line 72
  return (bits_to_add);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/bitbuffer.c"
int bitbuffer_extract_bits(BitBuffer buf , BitField *bits , int count ) 
{ 
  int bits_to_extract ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int i ;
  BitField subfield ;
  int tmp___6 ;

  {
#line 78
  if (8 < count) {
#line 78
    tmp___4 = 8;
  } else {
#line 78
    tmp___4 = count;
  }
  {
#line 78
  tmp___5 = bitbuffer_available_bits((BitBuffer const   )buf);
  }
#line 78
  if (tmp___4 < tmp___5) {
#line 78
    if (8 < count) {
#line 78
      tmp___1 = 8;
    } else {
#line 78
      tmp___1 = count;
    }
#line 78
    tmp___3 = tmp___1;
  } else {
    {
#line 78
    tmp___2 = bitbuffer_available_bits((BitBuffer const   )buf);
#line 78
    tmp___3 = tmp___2;
    }
  }
#line 78
  bits_to_extract = tmp___3;
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < bits_to_extract)) {
#line 80
      goto while_break;
    }
#line 81
    subfield = buf->bits[buf->firstused >> 3];
#line 82
    tmp___6 = buf->firstused;
#line 82
    (buf->firstused) ++;
#line 82
    if ((int )subfield & (1 << (tmp___6 & 7))) {
#line 83
      *bits = (BitField )((int )*bits | (1 << (i & 7)));
    } else {
#line 85
      *bits = (BitField )((int )*bits & ~ (1 << (i & 7)));
    }
#line 86
    if (buf->firstused == buf->size) {
#line 87
      buf->firstused = 0;
    }
#line 80
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  buf->bitsused -= bits_to_extract;
#line 90
  return (bits_to_extract);
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 660
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgrp)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/debias.h"
int transfer_bits_and_debias(BitBuffer from , BitBuffer to ) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.h"
int arecord_read_fd ;
#line 7
int restart_arecord ;
#line 9
int start_arecord(BitBuffer read_into ) ;
#line 11
void asound_do_read(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
static char *version_number  =    (char *)"0.2";
#line 20 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
static char const   *pidfile  =    (char const   *)((void *)0);
#line 21 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int daemonise  =    0;
#line 22 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int verbose  =    0;
#line 23 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int minwatermark  =    256;
#line 24 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int maxwatermark  =    3840;
#line 25 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int depositsize  =    64;
#line 26 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int buffersize  =    1024;
#line 27 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int time_to_quit  =    0;
#line 29 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
BitBuffer incoming_bits  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
BitBuffer buffered_bits  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int randomfd  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
struct injector random_injector  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int bits_in_pool(void) 
{ 
  int ret ;

  {
  {
#line 47
  ioctl(randomfd, (unsigned long )((2U << 30) | (unsigned int )(82 << 8)) | (sizeof(int ) << 16),
        & ret);
  }
#line 48
  return (ret);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
void do_mixin_bits(void) 
{ 
  int i ;
  int bits_before ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 55
  tmp = bits_in_pool();
#line 55
  bits_before = tmp;
  }
#line 56
  if (verbose > 3) {
    {
#line 57
    printf((char const   */* __restrict  */)"Injecting %d bits of entropy into the kernel\n",
           depositsize * 8);
    }
  }
#line 58
  random_injector.ent_count = depositsize * 8;
#line 59
  random_injector.size = depositsize;
#line 60
  i = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < depositsize)) {
#line 60
      goto while_break;
    }
    {
#line 61
    bitbuffer_extract_bits(buffered_bits, random_injector.value.bitfield + i, 8);
#line 60
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 63
  tmp___0 = ioctl(randomfd, (unsigned long )(((1U << 30) | (unsigned int )(82 << 8)) | 3U) | (sizeof(int [2]) << 16),
                  & random_injector);
  }
#line 63
  if (tmp___0 == -1) {
    {
#line 64
    perror("ioctl");
    }
  }
#line 66
  if (verbose > 3) {
    {
#line 67
    tmp___1 = bits_in_pool();
#line 67
    printf((char const   */* __restrict  */)"Kernel now at %d bits of entropy\n",
           tmp___1);
    }
  }
  {
#line 68
  tmp___2 = bits_in_pool();
  }
#line 68
  if (bits_before == tmp___2) {
    {
#line 69
    printf((char const   */* __restrict  */)"Did it fail?!?!\n");
    }
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
void main_loop(void) 
{ 
  fd_set readfds ;
  fd_set writefds ;
  fd_set errfds ;
  int ret ;
  int adding ;
  int __d0 ;
  int __d1 ;
  int pid ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 79
  adding = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 81
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! (! time_to_quit)) {
#line 83
      goto while_break___0;
    }
#line 84
    if (restart_arecord == 1) {
#line 86
      if (verbose > 1) {
        {
#line 87
        printf((char const   */* __restrict  */)"Need to restart arecord.\n");
        }
      }
      {
#line 88
      pid = start_arecord(incoming_bits);
      }
#line 89
      if (pid == -1) {
#line 90
        return;
      }
#line 91
      if (verbose > 1) {
        {
#line 92
        printf((char const   */* __restrict  */)"Started arecord with pid %d\n", pid);
        }
      }
      {
#line 93
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 93
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.__fds_bits[0]): "memory");
#line 93
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 94
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 94
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& errfds.__fds_bits[0]): "memory");
#line 94
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 95
      if (restart_arecord) {
        {
#line 96
        printf((char const   */* __restrict  */)"Arecord already died.\n");
        }
#line 97
        return;
      }
    }
    {
#line 100
    readfds.__fds_bits[arecord_read_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << arecord_read_fd % (8 * (int )sizeof(__fd_mask ));
#line 101
    errfds.__fds_bits[arecord_read_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << arecord_read_fd % (8 * (int )sizeof(__fd_mask ));
#line 102
    ret = select(arecord_read_fd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                 (fd_set */* __restrict  */)(& errfds), (struct timeval */* __restrict  */)((void *)0));
    }
#line 103
    if (ret == -1) {
#line 104
      if (! time_to_quit) {
        {
#line 105
        perror("select");
        }
      }
#line 106
      return;
    }
#line 108
    if ((readfds.__fds_bits[arecord_read_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << arecord_read_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 109
      asound_do_read();
      }
    }
#line 110
    if ((errfds.__fds_bits[arecord_read_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << arecord_read_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 111
      printf((char const   */* __restrict  */)"Error on arecord fd, gotta restart.\n");
#line 112
      restart_arecord = 1;
      }
    }
    {
#line 114
    ret = transfer_bits_and_debias(incoming_bits, buffered_bits);
    }
#line 115
    if (verbose > 3) {
#line 115
      if (ret > 0) {
        {
#line 116
        tmp = bitbuffer_available_bits((BitBuffer const   )buffered_bits);
#line 116
        printf((char const   */* __restrict  */)"Added %d bits to cache. Now at %d/%d bits in it\n",
               ret, tmp, buffersize * 8);
        }
      }
    }
    {
#line 117
    tmp___1 = bits_in_pool();
    }
#line 117
    if (tmp___1 <= minwatermark) {
#line 117
      if (adding == 0) {
#line 118
        if (verbose > 2) {
          {
#line 119
          tmp___0 = bits_in_pool();
#line 119
          printf((char const   */* __restrict  */)"Transition to inserting entropy. Kernel pool at %d\n",
                 tmp___0);
          }
        }
#line 120
        adding = 1;
      }
    }
    {
#line 122
    tmp___3 = bits_in_pool();
    }
#line 122
    if (tmp___3 >= maxwatermark) {
#line 122
      if (adding == 1) {
#line 123
        if (verbose > 2) {
          {
#line 124
          tmp___2 = bits_in_pool();
#line 124
          printf((char const   */* __restrict  */)"Transition to waiting. Kernel pool at %d\n",
                 tmp___2);
          }
        }
#line 125
        adding = 0;
      }
    }
#line 127
    if (adding == 1) {
      {
#line 128
      tmp___5 = bitbuffer_available_bits((BitBuffer const   )buffered_bits);
      }
#line 128
      if (tmp___5 >= depositsize * 8) {
        {
#line 129
        do_mixin_bits();
        }
#line 130
        if (verbose > 3) {
          {
#line 131
          tmp___4 = bits_in_pool();
#line 131
          printf((char const   */* __restrict  */)"Kernel entropy pool now sits at %d bits\n",
                 tmp___4);
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
void usage(char const   *prog , FILE *output ) 
{ 


  {
  {
#line 140
  fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%s: Usage:\n\nArgument: h - display this help message\n          V - display version information.\n          D - Daemonize\n          p - pidfile\n          v - Increase verbosity. Can be used more than once.\n          m - specify minimum number of bits of entropy in the pool.\n          M - specify max number of bits in the pool.\n          b - specify number of bytes of randomness to buffer for use.\n          d - specify number of bytes to deposit into the pool each time.\n",
          prog);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
void version(char const   *prog , FILE *output ) 
{ 


  {
  {
#line 157
  fprintf((FILE */* __restrict  */)output, (char const   */* __restrict  */)"%s: %s\nCopyright 2007 Daniel Silverstone\n",
          prog, version_number);
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
void cleanup(void) 
{ 
  int tmp ;

  {
#line 165
  if (pidfile) {
    {
#line 166
    tmp = unlink(pidfile);
    }
#line 166
    if (tmp < 0) {
      {
#line 167
      perror(pidfile);
      }
    }
  }
  {
#line 168
  exit(0);
  }
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
static void caught_signal(int sig ) 
{ 


  {
#line 174
  time_to_quit ++;
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/randomsound.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int oldpid ;
  FILE *file ;
  struct sigaction sigact ;
  int fd ;
  __pid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;

  {
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    opt = getopt(argc, (char * const  *)argv, ":hDp:vVm:M:b:d:");
    }
#line 184
    if (! (opt != -1)) {
#line 184
      goto while_break;
    }
    {
#line 186
    if (opt == 104) {
#line 186
      goto case_104;
    }
#line 189
    if (opt == 86) {
#line 189
      goto case_86;
    }
#line 192
    if (opt == 68) {
#line 192
      goto case_68;
    }
#line 195
    if (opt == 112) {
#line 195
      goto case_112;
    }
#line 198
    if (opt == 118) {
#line 198
      goto case_118;
    }
#line 201
    if (opt == 109) {
#line 201
      goto case_109;
    }
#line 204
    if (opt == 77) {
#line 204
      goto case_77;
    }
#line 207
    if (opt == 98) {
#line 207
      goto case_98;
    }
#line 210
    if (opt == 100) {
#line 210
      goto case_100;
    }
#line 213
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 187
    usage((char const   *)*(argv + 0), stdout);
    }
#line 188
    return (0);
    case_86: /* CIL Label */ 
    {
#line 190
    version((char const   *)*(argv + 0), stdout);
    }
#line 191
    return (0);
    case_68: /* CIL Label */ 
#line 193
    daemonise = 1;
#line 194
    goto switch_break;
    case_112: /* CIL Label */ 
#line 196
    pidfile = (char const   *)optarg;
#line 197
    goto switch_break;
    case_118: /* CIL Label */ 
#line 199
    verbose ++;
#line 200
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 202
    minwatermark = atoi((char const   *)optarg);
    }
#line 203
    goto switch_break;
    case_77: /* CIL Label */ 
    {
#line 205
    maxwatermark = atoi((char const   *)optarg);
    }
#line 206
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 208
    buffersize = atoi((char const   *)optarg);
    }
#line 209
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 211
    depositsize = atoi((char const   *)optarg);
    }
#line 212
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 214
    usage((char const   *)*(argv + 0), stderr);
    }
#line 215
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (minwatermark < 64) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Minimum watermark is below 64 bits. This is silly.\n");
    }
#line 222
    return (2);
  }
#line 224
  if (maxwatermark > 4096) {
    {
#line 225
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Maxmimum watermark is above 4096. This is not possible.\n");
    }
#line 226
    return (2);
  }
#line 228
  if (buffersize < depositsize) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Buffer size smaller than deposit size or greater than one megabyte.\n");
    }
#line 230
    return (2);
  } else
#line 228
  if (buffersize > 1048576) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Buffer size smaller than deposit size or greater than one megabyte.\n");
    }
#line 230
    return (2);
  }
#line 232
  if (depositsize < 4) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Deposit size must be a multiple of four, between 4 and 512 inclusive.\n");
    }
#line 234
    return (2);
  } else
#line 232
  if (depositsize > 512) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Deposit size must be a multiple of four, between 4 and 512 inclusive.\n");
    }
#line 234
    return (2);
  } else
#line 232
  if ((depositsize & 3) != 0) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Deposit size must be a multiple of four, between 4 and 512 inclusive.\n");
    }
#line 234
    return (2);
  }
#line 237
  if (daemonise) {
#line 237
    if (! pidfile) {
#line 238
      pidfile = "/var/run/randomsound.pid";
    }
  }
#line 240
  if (verbose > 0) {
    {
#line 241
    printf((char const   */* __restrict  */)"Random sound daemon. Copyright 2007 Daniel Silverstone.\n\n");
#line 242
    printf((char const   */* __restrict  */)"Will keep random pool between %d and %d bits of entropy.\n",
           minwatermark, maxwatermark);
#line 243
    printf((char const   */* __restrict  */)"Will retain a buffer of %d bytes, making entropy deposits of %d bytes at a time.\n",
           buffersize, depositsize);
    }
#line 244
    if (daemonise == 1) {
      {
#line 245
      printf((char const   */* __restrict  */)"Will daemonise.\n");
      }
    }
  }
#line 249
  if (verbose > 1) {
    {
#line 250
    printf((char const   */* __restrict  */)"Allocating a %d bit buffer for the incoming bits.\n",
           (buffersize * 8) * 4);
    }
  }
  {
#line 253
  incoming_bits = bitbuffer_new((int const   )((buffersize * 8) * 4));
#line 254
  buffered_bits = bitbuffer_new((int const   )(buffersize * 8));
  }
#line 255
  if ((unsigned long )incoming_bits == (unsigned long )((void *)0)) {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate buffers.\n");
    }
#line 257
    return (3);
  } else
#line 255
  if ((unsigned long )buffered_bits == (unsigned long )((void *)0)) {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate buffers.\n");
    }
#line 257
    return (3);
  }
  {
#line 260
  randomfd = open("/dev/random", 2);
  }
#line 262
  if (randomfd == -1) {
    {
#line 263
    perror("Opening /dev/random\n");
    }
#line 264
    return (3);
  }
#line 267
  if (daemonise == 1) {
    {
#line 268
    printf((char const   */* __restrict  */)"Daemonising\n");
#line 269
    fflush(stdout);
#line 270
    tmp = fork();
#line 270
    fd = tmp;
    }
#line 271
    if (fd == -1) {
      {
#line 272
      perror("forking daemon.\n");
      }
#line 273
      return (4);
    }
#line 275
    if (fd != 0) {
#line 275
      return (0);
    }
    {
#line 277
    memset((void *)(& sigact), 0, sizeof(struct sigaction ));
#line 278
    sigact.__sigaction_handler.sa_handler = & caught_signal;
#line 279
    sigaction(15, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)((void *)0));
#line 280
    sigaction(1, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)((void *)0));
#line 281
    sigaction(2, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)((void *)0));
#line 283
    file = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"r");
    }
#line 283
    if ((unsigned long )file != (unsigned long )((void *)0)) {
      {
#line 284
      tmp___1 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d",
                       & oldpid);
      }
#line 284
      if (tmp___1 > 0) {
        {
#line 285
        tmp___0 = kill(oldpid, 0);
        }
#line 285
        if (tmp___0 == 0) {
          {
#line 286
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"another randomsound is already running with pid %d\n",
                  oldpid);
#line 287
          exit(0);
          }
        }
      }
      {
#line 290
      fclose(file);
      }
    }
    {
#line 293
    file = fopen((char const   */* __restrict  */)pidfile, (char const   */* __restrict  */)"w");
    }
#line 293
    if ((unsigned long )file == (unsigned long )((void *)0)) {
      {
#line 294
      perror("Can\'t open pidfile\n");
#line 295
      exit(1);
      }
    }
    {
#line 298
    tmp___2 = getpid();
#line 298
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d\n",
            tmp___2);
#line 299
    fclose(file);
#line 300
    setpgrp();
#line 301
    setsid();
#line 302
    atexit(& cleanup);
    }
  }
  {
#line 305
  main_loop();
  }
#line 307
  return (-1);
}
}
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
int arecord_read_fd  =    -1;
#line 17 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
int restart_arecord  =    1;
#line 19 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
static BitBuffer read_into_here  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
static int signal_handler_installed  =    0;
#line 22 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
void child_handler(int _ignored ) 
{ 
  int status ;
  __pid_t tmp ;

  {
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 26
    tmp = waitpid(-1, & status, 1);
    }
#line 26
    if (! (tmp != -1)) {
#line 26
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 27
  restart_arecord = 1;
#line 28
  return;
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
int start_arecord(BitBuffer read_into ) 
{ 
  pid_t child ;
  int pipefd[2] ;
  int sparefd ;
  int tmp ;

  {
#line 36
  read_into_here = read_into;
#line 37
  if (signal_handler_installed == 0) {
    {
#line 38
    signal(17, & child_handler);
#line 39
    signal_handler_installed = 1;
    }
  }
#line 41
  if (arecord_read_fd != -1) {
    {
#line 42
    close(arecord_read_fd);
#line 43
    arecord_read_fd = -1;
    }
  }
  {
#line 45
  tmp = socketpair(1, 1, 1, (int *)(pipefd));
  }
#line 45
  if (tmp == -1) {
#line 46
    return (-1);
  }
  {
#line 47
  restart_arecord = 0;
#line 48
  child = fork();
  }
  {
#line 50
  if (child == -1) {
#line 50
    goto case_neg_1;
  }
#line 52
  if (child == 0) {
#line 52
    goto case_0;
  }
#line 65
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 51
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 53
  sparefd = open("/dev/null", 2);
#line 54
  close(0);
#line 55
  close(1);
#line 56
  close(2);
#line 57
  close(pipefd[0]);
#line 58
  dup2(pipefd[1], 1);
#line 59
  close(pipefd[1]);
#line 60
  dup2(sparefd, 0);
#line 61
  dup2(sparefd, 2);
#line 62
  close(sparefd);
#line 63
  execlp("arecord", "arecord", "-c", "1", "-f", "S16_LE", "-r", "8000", "-t", "raw",
         (void *)0);
#line 64
  exit(1);
  }
  switch_default: /* CIL Label */ 
  {
#line 66
  close(pipefd[1]);
#line 67
  arecord_read_fd = pipefd[0];
  }
  switch_break: /* CIL Label */ ;
  }
#line 69
  return (child);
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/asoundrunner.c"
void asound_do_read(void) 
{ 
  BitField buffer[40000] ;
  int xfered ;
  int readbytes ;
  ssize_t tmp ;
  BitField thisbit ;
  int tmp___0 ;

  {
  {
#line 77
  xfered = 0;
#line 78
  tmp = read(arecord_read_fd, (void *)(buffer), (size_t )40000);
#line 78
  readbytes = (int )tmp;
  }
#line 79
  if (readbytes < 0) {
    {
#line 80
    perror("read");
#line 81
    restart_arecord = 1;
    }
#line 82
    return;
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (xfered < readbytes >> 1) {
      {
#line 84
      tmp___0 = bitbuffer_free_space((BitBuffer const   )read_into_here);
      }
#line 84
      if (! (tmp___0 > 0)) {
#line 84
        goto while_break;
      }
    } else {
#line 84
      goto while_break;
    }
    {
#line 85
    thisbit = buffer[xfered];
#line 86
    bitbuffer_add_bits(read_into_here, (BitField const   )thisbit, 8);
#line 87
    xfered += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/randomsound-0.2/debias.c"
int transfer_bits_and_debias(BitBuffer from , BitBuffer to ) 
{ 
  BitField bits ;
  int bits_xfered ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 12
  bits_xfered = 0;
  {
#line 13
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 13
    tmp___1 = bitbuffer_available_bits((BitBuffer const   )from);
    }
#line 13
    if (! (tmp___1 >= 2)) {
#line 13
      goto while_break;
    }
    {
#line 14
    tmp = bitbuffer_extract_bits(from, & bits, 2);
    }
#line 14
    if (tmp != 2) {
#line 15
      return (bits_xfered);
    }
#line 16
    if (((int )bits & 3) == 1) {
#line 16
      goto _L;
    } else
#line 16
    if (((int )bits & 3) == 2) {
      _L: /* CIL Label */ 
      {
#line 17
      tmp___0 = bitbuffer_add_bits(to, (BitField const   )bits, 1);
      }
#line 17
      if (tmp___0 != 1) {
#line 18
        return (bits_xfered);
      }
#line 19
      bits_xfered ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 22
  return (bits_xfered);
}
}
