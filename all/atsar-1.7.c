/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_50 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_50 regmatch_t;
#line 6 "../include/linuxstat.h"
typedef long long count_t;
#line 11 "../include/linuxstat.h"
struct ip_mib {
   count_t IpForwarding ;
   count_t IpDefaultTTL ;
   count_t IpInReceives ;
   count_t IpInHdrErrors ;
   count_t IpInAddrErrors ;
   count_t IpForwDatagrams ;
   count_t IpInUnknownProtos ;
   count_t IpInDiscards ;
   count_t IpInDelivers ;
   count_t IpOutRequests ;
   count_t IpOutDiscards ;
   count_t IpOutNoRoutes ;
   count_t IpReasmTimeout ;
   count_t IpReasmReqds ;
   count_t IpReasmOKs ;
   count_t IpReasmFails ;
   count_t IpFragOKs ;
   count_t IpFragFails ;
   count_t IpFragCreates ;
};
#line 33 "../include/linuxstat.h"
struct ipv6_mib {
   count_t Ip6InReceives ;
   count_t Ip6InHdrErrors ;
   count_t Ip6InTooBigErrors ;
   count_t Ip6InNoRoutes ;
   count_t Ip6InAddrErrors ;
   count_t Ip6InUnknownProtos ;
   count_t Ip6InTruncatedPkts ;
   count_t Ip6InDiscards ;
   count_t Ip6InDelivers ;
   count_t Ip6OutForwDatagrams ;
   count_t Ip6OutRequests ;
   count_t Ip6OutDiscards ;
   count_t Ip6OutNoRoutes ;
   count_t Ip6ReasmTimeout ;
   count_t Ip6ReasmReqds ;
   count_t Ip6ReasmOKs ;
   count_t Ip6ReasmFails ;
   count_t Ip6FragOKs ;
   count_t Ip6FragFails ;
   count_t Ip6FragCreates ;
   count_t Ip6InMcastPkts ;
   count_t Ip6OutMcastPkts ;
};
#line 58 "../include/linuxstat.h"
struct icmp_mib {
   count_t IcmpInMsgs ;
   count_t IcmpInErrors ;
   count_t IcmpInDestUnreachs ;
   count_t IcmpInTimeExcds ;
   count_t IcmpInParmProbs ;
   count_t IcmpInSrcQuenchs ;
   count_t IcmpInRedirects ;
   count_t IcmpInEchos ;
   count_t IcmpInEchoReps ;
   count_t IcmpInTimestamps ;
   count_t IcmpInTimestampReps ;
   count_t IcmpInAddrMasks ;
   count_t IcmpInAddrMaskReps ;
   count_t IcmpOutMsgs ;
   count_t IcmpOutErrors ;
   count_t IcmpOutDestUnreachs ;
   count_t IcmpOutTimeExcds ;
   count_t IcmpOutParmProbs ;
   count_t IcmpOutSrcQuenchs ;
   count_t IcmpOutRedirects ;
   count_t IcmpOutEchos ;
   count_t IcmpOutEchoReps ;
   count_t IcmpOutTimestamps ;
   count_t IcmpOutTimestampReps ;
   count_t IcmpOutAddrMasks ;
   count_t IcmpOutAddrMaskReps ;
};
#line 87 "../include/linuxstat.h"
struct icmpv6_mib {
   count_t Icmp6InMsgs ;
   count_t Icmp6InErrors ;
   count_t Icmp6InDestUnreachs ;
   count_t Icmp6InPktTooBigs ;
   count_t Icmp6InTimeExcds ;
   count_t Icmp6InParmProblems ;
   count_t Icmp6InEchos ;
   count_t Icmp6InEchoReplies ;
   count_t Icmp6InGroupMembQueries ;
   count_t Icmp6InGroupMembResponses ;
   count_t Icmp6InGroupMembReductions ;
   count_t Icmp6InRouterSolicits ;
   count_t Icmp6InRouterAdvertisements ;
   count_t Icmp6InNeighborSolicits ;
   count_t Icmp6InNeighborAdvertisements ;
   count_t Icmp6InRedirects ;
   count_t Icmp6OutMsgs ;
   count_t Icmp6OutDestUnreachs ;
   count_t Icmp6OutPktTooBigs ;
   count_t Icmp6OutTimeExcds ;
   count_t Icmp6OutParmProblems ;
   count_t Icmp6OutEchoReplies ;
   count_t Icmp6OutRouterSolicits ;
   count_t Icmp6OutNeighborSolicits ;
   count_t Icmp6OutNeighborAdvertisements ;
   count_t Icmp6OutRedirects ;
   count_t Icmp6OutGroupMembResponses ;
   count_t Icmp6OutGroupMembReductions ;
};
#line 123 "../include/linuxstat.h"
struct tcp_mib {
   count_t TcpRtoAlgorithm ;
   count_t TcpRtoMin ;
   count_t TcpRtoMax ;
   count_t TcpMaxConn ;
   count_t TcpActiveOpens ;
   count_t TcpPassiveOpens ;
   count_t TcpAttemptFails ;
   count_t TcpEstabResets ;
   count_t TcpCurrEstab ;
   count_t TcpInSegs ;
   count_t TcpOutSegs ;
   count_t TcpRetransSegs ;
   count_t TcpInErrs ;
   count_t TcpOutRsts ;
};
#line 140 "../include/linuxstat.h"
struct udp_mib {
   count_t UdpInDatagrams ;
   count_t UdpNoPorts ;
   count_t UdpInErrors ;
   count_t UdpOutDatagrams ;
};
#line 162 "../include/linuxstat.h"
struct osrel {
   int rel ;
   int vers ;
   int sub ;
};
#line 173 "../include/linuxstat.h"
struct netstat {
   struct ip_mib ip ;
   struct icmp_mib icmp ;
   struct tcp_mib tcp ;
   struct udp_mib udp ;
   struct ipv6_mib ip6 ;
   struct icmpv6_mib icmp6 ;
   struct udp_mib udp6 ;
};
#line 188 "../include/linuxstat.h"
struct nfsstat {
   count_t cl_netcnt ;
   count_t cl_netudpcnt ;
   count_t cl_nettcpcnt ;
   count_t cl_nettcpconn ;
   count_t cl_rpccnt ;
   count_t cl_rpcretrans ;
   count_t cl_rpcauthrefresh ;
   count_t cl_proc2[20] ;
   count_t cl_proc3[20] ;
   count_t sv_netcnt ;
   count_t sv_netudpcnt ;
   count_t sv_nettcpcnt ;
   count_t sv_nettcpconn ;
   count_t sv_rpccnt ;
   count_t sv_rpcbadtot ;
   count_t sv_rpcbadfmt ;
   count_t sv_rpcbadauth ;
   count_t sv_rpcbadclnt ;
   count_t sv_proc2[20] ;
   count_t sv_proc3[20] ;
   count_t sv_rchits ;
   count_t sv_rcmisses ;
   count_t sv_rcnocache ;
   count_t sv_fhstale ;
   count_t sv_fhlookup ;
   count_t sv_fhanon ;
   count_t sv_fhnocachedir ;
   count_t sv_fhnocachenondir ;
   count_t sv_ioread ;
   count_t sv_iowrite ;
   count_t sv_thcount ;
   count_t sv_thlastcnt ;
   count_t sv_rasize ;
};
#line 254 "../include/linuxstat.h"
struct ifstat {
   char name[16] ;
   count_t rbyte ;
   count_t rpack ;
   count_t rerrs ;
   count_t rdrop ;
   count_t rfifo ;
   count_t rframe ;
   count_t rcompr ;
   count_t rmultic ;
   count_t sbyte ;
   count_t spack ;
   count_t serrs ;
   count_t sdrop ;
   count_t sfifo ;
   count_t scollis ;
   count_t scarrier ;
   count_t scompr ;
};
#line 278 "../include/linuxstat.h"
struct tabstat {
   count_t totforks ;
   count_t curlocks ;
   count_t maxlocks ;
   count_t maxdquot ;
   count_t curdquot ;
   count_t maxfiles ;
   count_t curfiles ;
   count_t maxinode ;
   count_t curinode ;
   count_t maxsuper ;
   count_t cursuper ;
};
#line 300 "../include/linuxstat.h"
struct memstat {
   count_t memtot ;
   count_t memfree ;
   count_t membuf ;
   count_t memcache ;
   count_t memslab ;
   count_t swptot ;
   count_t swpfree ;
};
#line 316 "../include/linuxstat.h"
struct dkstat {
   unsigned short major ;
   unsigned short minor ;
   char name[16] ;
   count_t totsize ;
   count_t readblocks ;
   count_t readmerges ;
   count_t readsectors ;
   count_t read_msecs ;
   count_t writblocks ;
   count_t writmerges ;
   count_t writsectors ;
   count_t writ_msecs ;
   count_t reqpending ;
   count_t rdwr_msecs ;
   count_t avq ;
};
#line 341 "../include/linuxstat.h"
struct serialstat {
   count_t port ;
   count_t tx ;
   count_t rx ;
   count_t fe ;
   count_t pe ;
   count_t br ;
   count_t oe ;
};
#line 360 "../include/linuxstat.h"
struct genstat {
   count_t cpu_user ;
   count_t cpu_nice ;
   count_t cpu_system ;
   count_t cpu_idle ;
   count_t cpu_wait ;
   count_t cpu_irq ;
   count_t cpu_sirq ;
   count_t per_cpu_user[32] ;
   count_t per_cpu_nice[32] ;
   count_t per_cpu_system[32] ;
   count_t per_cpu_idle[32] ;
   count_t per_cpu_wait[32] ;
   count_t per_cpu_irq[32] ;
   count_t per_cpu_sirq[32] ;
   count_t irqs[64] ;
   count_t per_irqs[32][64] ;
   count_t context_swtch ;
   float loadavg1 ;
   float loadavg5 ;
   float loadavg15 ;
   count_t nrrun ;
   count_t nrproc ;
   count_t dk_drive_maj[65] ;
   count_t dk_drive_min[65] ;
   count_t dk_drive_tot[65] ;
   count_t dk_drive_rio[65] ;
   count_t dk_drive_wio[65] ;
   count_t dk_drive_rblk[65] ;
   count_t dk_drive_wblk[65] ;
   count_t pgpgin ;
   count_t pgpgout ;
   count_t pswpin ;
   count_t pswpout ;
};
#line 407 "../include/linuxstat.h"
struct sockstat {
   count_t tcpnow ;
   count_t tcpmax ;
   count_t udpnow ;
   count_t udpmax ;
   count_t tcp6now ;
   count_t tcp6max ;
   count_t udp6now ;
   count_t udp6max ;
};
#line 28 "../include/atsar.h"
struct countdef {
   char *kname ;
   unsigned short ksize ;
   unsigned short kinst ;
};
#line 34 "../include/atsar.h"
struct fetchdef {
   struct countdef cdef ;
   void (*initcnt)() ;
   void (*getcnt)() ;
};
#line 665 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct v6tab {
   char *nam ;
   count_t *val ;
};
#line 1428 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct __anonstruct_validdisk_58 {
   char *regexp ;
   regex_t compreg ;
   void (*modname)(char * , char * , int  ) ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 52 "../include/atsar.h"
struct filehdr {
   long magic ;
   int hdrsize ;
   int oncecnt ;
   int oncenames ;
   int oncevars ;
   int sampcnt ;
   int sampnames ;
   int sampvars ;
   int hertz ;
   int numcpu ;
   struct utsname utsinfo ;
};
#line 69 "../include/atsar.h"
struct samphdr {
   time_t curtim ;
   clock_t curlbolt ;
   int cntsize ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 40 "../include/atsar.h"
struct funcdef {
   char active ;
   char flag ;
   void (*prihead)() ;
   int (*priline)() ;
   char *about ;
};
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 105 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static int isrealdisk(char *curname , char *newname , int maxlen ) ;
#line 117 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void genget(struct fetchdef *fdef , struct osrel *osrel___0 , struct genstat *gs ) 
{ 
  register int nr ;
  register int i ;
  FILE *fp ;
  char linebuf[8192] ;
  char nam[64] ;
  count_t cnts[64] ;
  int tmp ;
  int cpunr ;
  int tmp___0 ;
  int tmp___1 ;
  int max ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *p ;
  count_t major ;
  count_t minor ;
  count_t tot ;
  count_t rio ;
  count_t rblk ;
  count_t wio ;
  count_t wblk ;
  int dkix ;
  int tmp___6 ;
  int max___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int max___1 ;
  int tmp___9 ;
  int tmp___10 ;
  int max___2 ;
  int tmp___11 ;
  int tmp___12 ;
  int max___3 ;
  int tmp___13 ;
  int tmp___14 ;
  int max___4 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int irq ;
  int max___5 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int nrfields ;
  count_t cnt ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 125
  memset((void *)gs, 0, sizeof(struct genstat ));
#line 131
  fp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 131
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 133
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 133
      tmp___17 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)fp);
      }
#line 133
      if (! ((unsigned long )tmp___17 != (unsigned long )((void *)0))) {
#line 133
        goto while_break;
      }
      {
#line 135
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  nam, & cnts[0], & cnts[1], & cnts[2], & cnts[3], & cnts[4], & cnts[5],
                  & cnts[6], & cnts[7], & cnts[8], & cnts[9], & cnts[10], & cnts[11],
                  & cnts[12], & cnts[13], & cnts[14], & cnts[15], & cnts[16], & cnts[17],
                  & cnts[18], & cnts[19], & cnts[20], & cnts[21], & cnts[22], & cnts[23],
                  & cnts[24], & cnts[25], & cnts[26], & cnts[27], & cnts[28], & cnts[29],
                  & cnts[30], & cnts[31], & cnts[32], & cnts[33], & cnts[34], & cnts[35],
                  & cnts[36], & cnts[37], & cnts[38], & cnts[39], & cnts[40], & cnts[41],
                  & cnts[42], & cnts[43], & cnts[44], & cnts[45], & cnts[46], & cnts[47],
                  & cnts[48], & cnts[49], & cnts[50], & cnts[51], & cnts[52], & cnts[53],
                  & cnts[54], & cnts[55], & cnts[56], & cnts[57], & cnts[58], & cnts[59],
                  & cnts[60], & cnts[61], & cnts[62], & cnts[63]);
      }
#line 164
      if (nr < 1) {
#line 165
        goto while_continue;
      }
      {
#line 167
      tmp = strcmp("cpu", (char const   *)(nam));
      }
#line 167
      if (tmp == 0) {
#line 169
        gs->cpu_user = cnts[0];
#line 170
        gs->cpu_nice = cnts[1];
#line 171
        gs->cpu_system = cnts[2];
#line 172
        gs->cpu_idle = cnts[3];
#line 174
        if (osrel___0->rel >= 2) {
#line 174
          if (osrel___0->vers >= 6) {
#line 176
            gs->cpu_wait = cnts[4];
#line 177
            gs->cpu_irq = cnts[5];
#line 178
            gs->cpu_sirq = cnts[6];
          }
        }
#line 181
        goto while_continue;
      }
#line 184
      if ((int )nam[0] == 99) {
#line 184
        if ((int )nam[1] == 112) {
#line 184
          if ((int )nam[2] == 117) {
            {
#line 186
            tmp___0 = atoi((char const   *)(& nam[3]));
#line 186
            cpunr = tmp___0;
            }
#line 188
            if (cpunr < 32) {
#line 188
              if (cpunr >= 0) {
#line 190
                gs->per_cpu_user[cpunr] = cnts[0];
#line 191
                gs->per_cpu_nice[cpunr] = cnts[1];
#line 192
                gs->per_cpu_system[cpunr] = cnts[2];
#line 193
                gs->per_cpu_idle[cpunr] = cnts[3];
#line 195
                if (osrel___0->rel >= 2) {
#line 195
                  if (osrel___0->vers >= 6) {
#line 198
                    gs->per_cpu_wait[cpunr] = cnts[4];
#line 199
                    gs->per_cpu_irq[cpunr] = cnts[5];
#line 200
                    gs->per_cpu_sirq[cpunr] = cnts[6];
                  }
                }
              }
            }
#line 204
            goto while_continue;
          }
        }
      }
      {
#line 207
      tmp___1 = strcmp("ctxt", (char const   *)(nam));
      }
#line 207
      if (tmp___1 == 0) {
#line 209
        gs->context_swtch = cnts[0];
#line 211
        goto while_continue;
      }
      {
#line 214
      tmp___3 = strcmp("intr", (char const   *)(nam));
      }
#line 214
      if (tmp___3 == 0) {
#line 216
        if (nr - 2 < 64) {
#line 216
          tmp___2 = nr - 2;
        } else {
#line 216
          tmp___2 = 64;
        }
#line 216
        max = tmp___2;
#line 219
        i = 1;
        {
#line 219
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 219
          if (! (i < max)) {
#line 219
            goto while_break___0;
          }
#line 220
          gs->irqs[i - 1] = cnts[i];
#line 219
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 222
        goto while_continue;
      }
      {
#line 225
      tmp___4 = strcmp("page", (char const   *)(nam));
      }
#line 225
      if (tmp___4 == 0) {
#line 227
        gs->pgpgin = cnts[0];
#line 228
        gs->pgpgout = cnts[1];
#line 229
        goto while_continue;
      }
      {
#line 232
      tmp___5 = strcmp("swap", (char const   *)(nam));
      }
#line 232
      if (tmp___5 == 0) {
#line 234
        gs->pswpin = cnts[0];
#line 235
        gs->pswpout = cnts[1];
#line 236
        goto while_continue;
      }
      {
#line 243
      tmp___6 = memcmp((void const   *)"disk_io", (void const   *)(nam), (size_t )7);
      }
#line 243
      if (tmp___6 == 0) {
        {
#line 255
        p = strchr((char const   *)(linebuf), ' ');
        }
#line 255
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 256
          goto while_continue;
        }
        {
#line 258
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 258
          p ++;
#line 258
          if (! ((int )*p == 32)) {
#line 258
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 260
        dkix = 0;
        {
#line 262
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 262
          nr = sscanf((char const   */* __restrict  */)p, (char const   */* __restrict  */)"(%lld,%lld):(%lld,%lld,%lld,%lld,%lld) ",
                      & major, & minor, & tot, & rio, & rblk, & wio, & wblk);
          }
#line 262
          if (! (nr == 7)) {
#line 262
            goto while_break___2;
          }
#line 268
          gs->dk_drive_maj[dkix] = major;
#line 269
          gs->dk_drive_min[dkix] = minor;
#line 270
          gs->dk_drive_tot[dkix] = tot;
#line 271
          gs->dk_drive_rio[dkix] = rio;
#line 272
          gs->dk_drive_wio[dkix] = wio;
#line 273
          gs->dk_drive_rblk[dkix] = rblk;
#line 274
          gs->dk_drive_wblk[dkix] = wblk;
#line 276
          dkix ++;
#line 278
          if (dkix >= 64) {
#line 279
            goto while_break___2;
          }
          {
#line 281
          p = strchr((char const   *)p, ' ');
          }
#line 281
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 282
            goto while_break___2;
          }
          {
#line 284
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 284
            p ++;
#line 284
            if (! ((int )*p == 32)) {
#line 284
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 287
        goto while_continue;
      }
      {
#line 293
      tmp___8 = strcmp("disk", (char const   *)(nam));
      }
#line 293
      if (tmp___8 == 0) {
#line 295
        if (nr - 1 < 64) {
#line 295
          tmp___7 = nr - 1;
        } else {
#line 295
          tmp___7 = 64;
        }
#line 295
        max___0 = tmp___7;
#line 297
        i = 0;
        {
#line 297
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 297
          if (! (i < max___0)) {
#line 297
            goto while_break___4;
          }
#line 299
          gs->dk_drive_min[i] = (count_t )(i + 1);
#line 300
          gs->dk_drive_tot[i] = cnts[i];
#line 297
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 303
        goto while_continue;
      }
      {
#line 306
      tmp___10 = strcmp("disk_rio", (char const   *)(nam));
      }
#line 306
      if (tmp___10 == 0) {
#line 308
        if (nr - 1 < 64) {
#line 308
          tmp___9 = nr - 1;
        } else {
#line 308
          tmp___9 = 64;
        }
#line 308
        max___1 = tmp___9;
#line 310
        i = 0;
        {
#line 310
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 310
          if (! (i < max___1)) {
#line 310
            goto while_break___5;
          }
#line 311
          gs->dk_drive_rio[i] = cnts[i];
#line 310
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 313
        goto while_continue;
      }
      {
#line 316
      tmp___12 = strcmp("disk_wio", (char const   *)(nam));
      }
#line 316
      if (tmp___12 == 0) {
#line 318
        if (nr - 1 < 64) {
#line 318
          tmp___11 = nr - 1;
        } else {
#line 318
          tmp___11 = 64;
        }
#line 318
        max___2 = tmp___11;
#line 320
        i = 0;
        {
#line 320
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 320
          if (! (i < max___2)) {
#line 320
            goto while_break___6;
          }
#line 321
          gs->dk_drive_wio[i] = cnts[i];
#line 320
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 323
        goto while_continue;
      }
      {
#line 326
      tmp___14 = strcmp("disk_rblk", (char const   *)(nam));
      }
#line 326
      if (tmp___14 == 0) {
#line 328
        if (nr - 1 < 64) {
#line 328
          tmp___13 = nr - 1;
        } else {
#line 328
          tmp___13 = 64;
        }
#line 328
        max___3 = tmp___13;
#line 330
        i = 0;
        {
#line 330
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 330
          if (! (i < max___3)) {
#line 330
            goto while_break___7;
          }
#line 331
          gs->dk_drive_rblk[i] = cnts[i];
#line 330
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 333
        goto while_continue;
      }
      {
#line 336
      tmp___16 = strcmp("disk_wblk", (char const   *)(nam));
      }
#line 336
      if (tmp___16 == 0) {
#line 338
        if (nr - 1 < 64) {
#line 338
          tmp___15 = nr - 1;
        } else {
#line 338
          tmp___15 = 64;
        }
#line 338
        max___4 = tmp___15;
#line 340
        i = 0;
        {
#line 340
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 340
          if (! (i < max___4)) {
#line 340
            goto while_break___8;
          }
#line 341
          gs->dk_drive_wblk[i] = cnts[i];
#line 340
          i ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 343
        goto while_continue;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 347
    fclose(fp);
    }
  }
  {
#line 353
  fp = fopen((char const   */* __restrict  */)"/proc/interrupts", (char const   */* __restrict  */)"r");
  }
#line 353
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 356
    fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
    {
#line 359
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 359
      tmp___18 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)fp);
      }
#line 359
      if (! ((unsigned long )tmp___18 != (unsigned long )((void *)0))) {
#line 359
        goto while_break___9;
      }
      {
#line 363
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%d:  %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  & irq, & cnts[0], & cnts[1], & cnts[2], & cnts[3], & cnts[4], & cnts[5],
                  & cnts[6], & cnts[7], & cnts[8], & cnts[9], & cnts[10], & cnts[11],
                  & cnts[12], & cnts[13], & cnts[14], & cnts[15], & cnts[16], & cnts[17],
                  & cnts[18], & cnts[19], & cnts[20], & cnts[21], & cnts[22], & cnts[23],
                  & cnts[24], & cnts[25], & cnts[26], & cnts[27], & cnts[28], & cnts[29],
                  & cnts[30], & cnts[31], & cnts[32], & cnts[33], & cnts[34], & cnts[35],
                  & cnts[36], & cnts[37], & cnts[38], & cnts[39], & cnts[40], & cnts[41],
                  & cnts[42], & cnts[43], & cnts[44], & cnts[45], & cnts[46], & cnts[47],
                  & cnts[48], & cnts[49], & cnts[50], & cnts[51], & cnts[52], & cnts[53],
                  & cnts[54], & cnts[55], & cnts[56], & cnts[57], & cnts[58], & cnts[59],
                  & cnts[60], & cnts[61], & cnts[62], & cnts[63]);
      }
#line 392
      if (nr < 2) {
#line 393
        goto while_continue___9;
      }
#line 395
      if (nr - 1 < 32) {
#line 395
        max___5 = nr - 1;
      } else {
#line 395
        max___5 = 32;
      }
#line 397
      i = 0;
      {
#line 397
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 397
        if (! (i < max___5)) {
#line 397
          goto while_break___10;
        }
#line 398
        gs->per_irqs[i][irq] = cnts[i];
#line 397
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 401
    fclose(fp);
    }
  }
  {
#line 407
  fp = fopen((char const   */* __restrict  */)"/proc/loadavg", (char const   */* __restrict  */)"r");
  }
#line 407
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 409
    tmp___19 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
#line 409
    if ((unsigned long )tmp___19 != (unsigned long )((void *)0)) {
      {
#line 411
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%f %f %f %lld/%lld",
                  & gs->loadavg1, & gs->loadavg5, & gs->loadavg15, & gs->nrrun, & gs->nrproc);
      }
    }
    {
#line 419
    fclose(fp);
    }
  }
  {
#line 425
  fp = fopen((char const   */* __restrict  */)"/proc/vmstat", (char const   */* __restrict  */)"r");
  }
#line 425
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
#line 427
    nrfields = 4;
    {
#line 430
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 430
      tmp___24 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)fp);
      }
#line 430
      if ((unsigned long )tmp___24 != (unsigned long )((void *)0)) {
#line 430
        if (! (nrfields > 0)) {
#line 430
          goto while_break___11;
        }
      } else {
#line 430
        goto while_break___11;
      }
      {
#line 433
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s %lld",
                  nam, & cnt);
      }
#line 435
      if (nr < 2) {
#line 436
        goto while_continue___11;
      }
      {
#line 438
      tmp___20 = strcmp("pgpgin", (char const   *)(nam));
      }
#line 438
      if (tmp___20 == 0) {
#line 440
        gs->pgpgin = cnt;
#line 441
        nrfields --;
      }
      {
#line 444
      tmp___21 = strcmp("pgpgout", (char const   *)(nam));
      }
#line 444
      if (tmp___21 == 0) {
#line 446
        gs->pgpgout = cnt;
#line 447
        nrfields --;
      }
      {
#line 450
      tmp___22 = strcmp("pswpin", (char const   *)(nam));
      }
#line 450
      if (tmp___22 == 0) {
#line 452
        gs->pswpin = cnt;
#line 453
        nrfields --;
      }
      {
#line 456
      tmp___23 = strcmp("pswpout", (char const   *)(nam));
      }
#line 456
      if (tmp___23 == 0) {
#line 458
        gs->pswpout = cnt;
#line 459
        nrfields --;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 463
    fclose(fp);
    }
  }
#line 465
  return;
}
}
#line 470 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void memget(struct fetchdef *fdef , struct osrel *osrel___0 , struct memstat *mi ) 
{ 
  register int nr ;
  register int nrfields ;
  FILE *fp ;
  char linebuf[1024] ;
  char itsname[32] ;
  count_t cnt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 473
  nrfields = 7;
#line 479
  memset((void *)mi, 0, sizeof(struct memstat ));
#line 481
  fp = fopen((char const   */* __restrict  */)"/proc/meminfo", (char const   */* __restrict  */)"r");
  }
#line 481
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 482
    return;
  }
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 484
    tmp___6 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
#line 484
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 484
      if (! (nrfields > 0)) {
#line 484
        goto while_break;
      }
    } else {
#line 484
      goto while_break;
    }
    {
#line 486
    nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s %lld",
                itsname, & cnt);
    }
#line 488
    if (nr < 2) {
#line 489
      goto while_continue;
    }
    {
#line 491
    tmp = strcmp("MemTotal:", (char const   *)(itsname));
    }
#line 491
    if (tmp == 0) {
#line 493
      mi->memtot = cnt;
#line 494
      nrfields --;
    }
    {
#line 497
    tmp___0 = strcmp("MemFree:", (char const   *)(itsname));
    }
#line 497
    if (tmp___0 == 0) {
#line 499
      mi->memfree = cnt;
#line 500
      nrfields --;
    }
    {
#line 503
    tmp___1 = strcmp("Buffers:", (char const   *)(itsname));
    }
#line 503
    if (tmp___1 == 0) {
#line 505
      mi->membuf = cnt;
#line 506
      nrfields --;
    }
    {
#line 509
    tmp___2 = strcmp("Cached:", (char const   *)(itsname));
    }
#line 509
    if (tmp___2 == 0) {
#line 511
      mi->memcache = cnt;
#line 512
      nrfields --;
    }
    {
#line 515
    tmp___3 = strcmp("Slab:", (char const   *)(itsname));
    }
#line 515
    if (tmp___3 == 0) {
#line 517
      mi->memslab = cnt;
#line 518
      nrfields --;
    }
    {
#line 521
    tmp___4 = strcmp("SwapTotal:", (char const   *)(itsname));
    }
#line 521
    if (tmp___4 == 0) {
#line 523
      mi->swptot = cnt;
#line 524
      nrfields --;
    }
    {
#line 527
    tmp___5 = strcmp("SwapFree:", (char const   *)(itsname));
    }
#line 527
    if (tmp___5 == 0) {
#line 529
      mi->swpfree = cnt;
#line 530
      nrfields --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 534
  fclose(fp);
  }
#line 535
  return;
}
}
#line 541
int getifstats(struct osrel *osrel___0 , struct ifstat *ifsp , int maxif ) ;
#line 543 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void ifinit(struct fetchdef *fdef , struct osrel *osrel___0 ) 
{ 
  int numnet ;
  struct ifstat ifs[32] ;

  {
  {
#line 546
  numnet = 0;
#line 549
  numnet = getifstats(osrel___0, ifs, 32);
#line 558
  fdef->cdef.kinst = (unsigned short )(((numnet >> 3) + 1) << 3);
  }
#line 560
  if ((int )fdef->cdef.kinst > 32) {
#line 561
    fdef->cdef.kinst = (unsigned short)32;
  }
#line 562
  return;
}
}
#line 564 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void ifget(struct fetchdef *fdef , struct osrel *osrel___0 , struct ifstat *ifsbuf ) 
{ 


  {
  {
#line 567
  memset((void *)ifsbuf, 0, sizeof(struct ifstat ) * (unsigned long )fdef->cdef.kinst);
#line 569
  getifstats(osrel___0, ifsbuf, (int )fdef->cdef.kinst);
  }
#line 570
  return;
}
}
#line 572 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
int getifstats(struct osrel *osrel___0 , struct ifstat *ifsp , int maxif ) 
{ 
  register int i ;
  register int nr ;
  FILE *fp ;
  char linebuf[1024] ;
  char *cp ;
  char *tmp ;

  {
  {
#line 575
  i = 0;
#line 579
  fp = fopen((char const   */* __restrict  */)"/proc/net/dev", (char const   */* __restrict  */)"r");
  }
#line 579
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 580
    return (0);
  }
  {
#line 582
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 582
    tmp = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
#line 582
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 582
      goto while_break;
    }
#line 584
    if (i >= maxif) {
#line 585
      goto while_break;
    }
    {
#line 588
    cp = strchr((char const   *)(linebuf), ':');
    }
#line 588
    if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 589
      *cp = (char )' ';
    }
#line 591
    if (osrel___0->rel == 2) {
#line 591
      if (osrel___0->vers < 2) {
        {
#line 593
        memset((void *)ifsp, 0, sizeof(struct ifstat ));
#line 595
        nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                    ifsp->name, & ifsp->rpack, & ifsp->rerrs, & ifsp->rdrop, & ifsp->rfifo,
                    & ifsp->rframe, & ifsp->spack, & ifsp->serrs, & ifsp->sdrop, & ifsp->sfifo,
                    & ifsp->scollis, & ifsp->scarrier);
        }
#line 611
        if (nr < 12) {
#line 613
          ifsp->name[0] = (char)0;
#line 614
          goto while_continue;
        }
      } else {
#line 591
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 619
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  ifsp->name, & ifsp->rbyte, & ifsp->rpack, & ifsp->rerrs, & ifsp->rdrop,
                  & ifsp->rfifo, & ifsp->rframe, & ifsp->rcompr, & ifsp->rmultic,
                  & ifsp->sbyte, & ifsp->spack, & ifsp->serrs, & ifsp->sdrop, & ifsp->sfifo,
                  & ifsp->scollis, & ifsp->scarrier, & ifsp->scompr);
      }
#line 641
      if (nr < 16) {
#line 643
        ifsp->name[0] = (char)0;
#line 644
        goto while_continue;
      }
    }
#line 648
    i ++;
#line 649
    ifsp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 652
  fclose(fp);
  }
#line 654
  return (i);
}
}
#line 661 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct ipv6_mib ipv6_tmp  ;
#line 662 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct icmpv6_mib icmpv6_tmp  ;
#line 663 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct udp_mib udpv6_tmp  ;
#line 665 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct v6tab v6tab[54]  = 
#line 665
  {      {(char *)"Ip6InReceives", & ipv6_tmp.Ip6InReceives}, 
        {(char *)"Ip6InHdrErrors", & ipv6_tmp.Ip6InHdrErrors}, 
        {(char *)"Ip6InTooBigErrors", & ipv6_tmp.Ip6InTooBigErrors}, 
        {(char *)"Ip6InNoRoutes", & ipv6_tmp.Ip6InNoRoutes}, 
        {(char *)"Ip6InAddrErrors", & ipv6_tmp.Ip6InAddrErrors}, 
        {(char *)"Ip6InUnknownProtos", & ipv6_tmp.Ip6InUnknownProtos}, 
        {(char *)"Ip6InTruncatedPkts", & ipv6_tmp.Ip6InTruncatedPkts}, 
        {(char *)"Ip6InDiscards", & ipv6_tmp.Ip6InDiscards}, 
        {(char *)"Ip6InDelivers", & ipv6_tmp.Ip6InDelivers}, 
        {(char *)"Ip6OutForwDatagrams", & ipv6_tmp.Ip6OutForwDatagrams}, 
        {(char *)"Ip6OutRequests", & ipv6_tmp.Ip6OutRequests}, 
        {(char *)"Ip6OutDiscards", & ipv6_tmp.Ip6OutDiscards}, 
        {(char *)"Ip6OutNoRoutes", & ipv6_tmp.Ip6OutNoRoutes}, 
        {(char *)"Ip6ReasmTimeout", & ipv6_tmp.Ip6ReasmTimeout}, 
        {(char *)"Ip6ReasmReqds", & ipv6_tmp.Ip6ReasmReqds}, 
        {(char *)"Ip6ReasmOKs", & ipv6_tmp.Ip6ReasmOKs}, 
        {(char *)"Ip6ReasmFails", & ipv6_tmp.Ip6ReasmFails}, 
        {(char *)"Ip6FragOKs", & ipv6_tmp.Ip6FragOKs}, 
        {(char *)"Ip6FragFails", & ipv6_tmp.Ip6FragFails}, 
        {(char *)"Ip6FragCreates", & ipv6_tmp.Ip6FragCreates}, 
        {(char *)"Ip6InMcastPkts", & ipv6_tmp.Ip6InMcastPkts}, 
        {(char *)"Ip6OutMcastPkts", & ipv6_tmp.Ip6OutMcastPkts}, 
        {(char *)"Icmp6InMsgs", & icmpv6_tmp.Icmp6InMsgs}, 
        {(char *)"Icmp6InErrors", & icmpv6_tmp.Icmp6InErrors}, 
        {(char *)"Icmp6InDestUnreachs", & icmpv6_tmp.Icmp6InDestUnreachs}, 
        {(char *)"Icmp6InPktTooBigs", & icmpv6_tmp.Icmp6InPktTooBigs}, 
        {(char *)"Icmp6InTimeExcds", & icmpv6_tmp.Icmp6InTimeExcds}, 
        {(char *)"Icmp6InParmProblems", & icmpv6_tmp.Icmp6InParmProblems}, 
        {(char *)"Icmp6InEchos", & icmpv6_tmp.Icmp6InEchos}, 
        {(char *)"Icmp6InEchoReplies", & icmpv6_tmp.Icmp6InEchoReplies}, 
        {(char *)"Icmp6InGroupMembQueries", & icmpv6_tmp.Icmp6InGroupMembQueries}, 
        {(char *)"Icmp6InGroupMembResponses", & icmpv6_tmp.Icmp6InGroupMembResponses}, 
        {(char *)"Icmp6InGroupMembReductions",
      & icmpv6_tmp.Icmp6InGroupMembReductions}, 
        {(char *)"Icmp6InRouterSolicits", & icmpv6_tmp.Icmp6InRouterSolicits}, 
        {(char *)"Icmp6InRouterAdvertisements", & icmpv6_tmp.Icmp6InRouterAdvertisements}, 
        {(char *)"Icmp6InNeighborSolicits",
      & icmpv6_tmp.Icmp6InNeighborSolicits}, 
        {(char *)"Icmp6InNeighborAdvertisements", & icmpv6_tmp.Icmp6InNeighborAdvertisements}, 
        {(char *)"Icmp6InRedirects",
      & icmpv6_tmp.Icmp6InRedirects}, 
        {(char *)"Icmp6OutMsgs", & icmpv6_tmp.Icmp6OutMsgs}, 
        {(char *)"Icmp6OutDestUnreachs", & icmpv6_tmp.Icmp6OutDestUnreachs}, 
        {(char *)"Icmp6OutPktTooBigs", & icmpv6_tmp.Icmp6OutPktTooBigs}, 
        {(char *)"Icmp6OutTimeExcds", & icmpv6_tmp.Icmp6OutTimeExcds}, 
        {(char *)"Icmp6OutParmProblems", & icmpv6_tmp.Icmp6OutParmProblems}, 
        {(char *)"Icmp6OutEchoReplies", & icmpv6_tmp.Icmp6OutEchoReplies}, 
        {(char *)"Icmp6OutRouterSolicits", & icmpv6_tmp.Icmp6OutRouterSolicits}, 
        {(char *)"Icmp6OutNeighborSolicits", & icmpv6_tmp.Icmp6OutNeighborSolicits}, 
        {(char *)"Icmp6OutNeighborAdvertisements", & icmpv6_tmp.Icmp6OutNeighborAdvertisements}, 
        {(char *)"Icmp6OutRedirects",
      & icmpv6_tmp.Icmp6OutRedirects}, 
        {(char *)"Icmp6OutGroupMembResponses", & icmpv6_tmp.Icmp6OutGroupMembResponses}, 
        {(char *)"Icmp6OutGroupMembReductions",
      & icmpv6_tmp.Icmp6OutGroupMembReductions}, 
        {(char *)"Udp6InDatagrams", & udpv6_tmp.UdpInDatagrams}, 
        {(char *)"Udp6NoPorts", & udpv6_tmp.UdpNoPorts}, 
        {(char *)"Udp6InErrors", & udpv6_tmp.UdpInErrors}, 
        {(char *)"Udp6OutDatagrams", & udpv6_tmp.UdpOutDatagrams}};
#line 734 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
int v6tab_entries  =    (int )(sizeof(v6tab) / sizeof(struct v6tab ));
#line 736 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void netget(struct fetchdef *fdef , struct osrel *osrel___0 , struct netstat *ns ) 
{ 
  register int nr ;
  register int cur ;
  FILE *fp ;
  char linebuf[1024] ;
  char itsname[32] ;
  count_t cnts[40] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 739
  cur = 0;
#line 745
  memset((void *)ns, 0, sizeof(struct netstat ));
#line 750
  fp = fopen((char const   */* __restrict  */)"/proc/net/snmp", (char const   */* __restrict  */)"r");
  }
#line 750
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 752
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 752
      tmp___3 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 752
      if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 752
        goto while_break;
      }
      {
#line 754
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  itsname, & cnts[0], & cnts[1], & cnts[2], & cnts[3], & cnts[4],
                  & cnts[5], & cnts[6], & cnts[7], & cnts[8], & cnts[9], & cnts[10],
                  & cnts[11], & cnts[12], & cnts[13], & cnts[14], & cnts[15], & cnts[16],
                  & cnts[17], & cnts[18], & cnts[19], & cnts[20], & cnts[21], & cnts[22],
                  & cnts[23], & cnts[24], & cnts[25], & cnts[26], & cnts[27], & cnts[28],
                  & cnts[29], & cnts[30], & cnts[31], & cnts[32], & cnts[33], & cnts[34],
                  & cnts[35], & cnts[36], & cnts[37], & cnts[38], & cnts[39]);
      }
#line 772
      if (nr < 2) {
#line 773
        goto while_continue;
      }
      {
#line 775
      tmp = strcmp("Ip:", (char const   *)(itsname));
      }
#line 775
      if (tmp == 0) {
        {
#line 777
        memcpy((void */* __restrict  */)(& ns->ip), (void const   */* __restrict  */)(cnts),
               sizeof(struct ip_mib ));
        }
#line 778
        goto while_continue;
      }
      {
#line 781
      tmp___0 = strcmp("Icmp:", (char const   *)(itsname));
      }
#line 781
      if (tmp___0 == 0) {
        {
#line 783
        memcpy((void */* __restrict  */)(& ns->icmp), (void const   */* __restrict  */)(cnts),
               sizeof(struct icmp_mib ));
        }
#line 784
        goto while_continue;
      }
      {
#line 787
      tmp___1 = strcmp("Tcp:", (char const   *)(itsname));
      }
#line 787
      if (tmp___1 == 0) {
        {
#line 789
        memcpy((void */* __restrict  */)(& ns->tcp), (void const   */* __restrict  */)(cnts),
               sizeof(struct tcp_mib ));
        }
#line 790
        goto while_continue;
      }
      {
#line 793
      tmp___2 = strcmp("Udp:", (char const   *)(itsname));
      }
#line 793
      if (tmp___2 == 0) {
        {
#line 795
        memcpy((void */* __restrict  */)(& ns->udp), (void const   */* __restrict  */)(cnts),
               sizeof(struct udp_mib ));
        }
#line 796
        goto while_continue;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 800
    fclose(fp);
    }
  }
  {
#line 807
  fp = fopen((char const   */* __restrict  */)"/proc/net/snmp6", (char const   */* __restrict  */)"r");
  }
#line 807
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 809
    cur = 0;
#line 811
    memset((void *)(& ipv6_tmp), 0, sizeof(ipv6_tmp));
#line 812
    memset((void *)(& icmpv6_tmp), 0, sizeof(icmpv6_tmp));
#line 813
    memset((void *)(& udpv6_tmp), 0, sizeof(udpv6_tmp));
    }
    {
#line 815
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 815
      tmp___6 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 815
      if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 815
        goto while_break___0;
      }
      {
#line 817
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s %lld",
                  itsname, & cnts[0]);
#line 819
      tmp___5 = strcmp((char const   *)v6tab[cur].nam, (char const   *)(itsname));
      }
#line 819
      if (tmp___5 == 0) {
#line 821
        *(v6tab[cur].val) = cnts[0];
      } else {
#line 825
        cur = 0;
        {
#line 825
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 825
          if (! (cur < v6tab_entries)) {
#line 825
            goto while_break___1;
          }
          {
#line 826
          tmp___4 = strcmp((char const   *)v6tab[cur].nam, (char const   *)(itsname));
          }
#line 826
          if (tmp___4 == 0) {
#line 828
            goto while_break___1;
          }
#line 825
          cur ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 830
        if (cur < v6tab_entries) {
#line 831
          *(v6tab[cur].val) = cnts[0];
        }
      }
#line 834
      cur ++;
#line 834
      if (cur >= v6tab_entries) {
#line 835
        cur = 0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 838
    memcpy((void */* __restrict  */)(& ns->ip6), (void const   */* __restrict  */)(& ipv6_tmp),
           sizeof(ipv6_tmp));
#line 839
    memcpy((void */* __restrict  */)(& ns->icmp6), (void const   */* __restrict  */)(& icmpv6_tmp),
           sizeof(icmpv6_tmp));
#line 840
    memcpy((void */* __restrict  */)(& ns->udp6), (void const   */* __restrict  */)(& udpv6_tmp),
           sizeof(udpv6_tmp));
#line 842
    fclose(fp);
    }
  }
#line 844
  return;
}
}
#line 858
void nfsfill(char *nam , count_t *cnts , int nc , struct nfsstat *ns , int isclient ) ;
#line 850 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void nfsget(struct fetchdef *fdef , struct osrel *osrel___0 , struct nfsstat *ns ) 
{ 
  register int nr ;
  FILE *fp ;
  char linebuf[1024] ;
  char itsname[32] ;
  count_t cnts[32] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 861
  memset((void *)ns, 0, sizeof(struct nfsstat ));
#line 866
  fp = fopen((char const   */* __restrict  */)"/proc/net/rpc/nfs", (char const   */* __restrict  */)"r");
  }
#line 866
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 868
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 868
      tmp = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 868
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 868
        goto while_break;
      }
      {
#line 870
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  itsname, & cnts[0], & cnts[1], & cnts[2], & cnts[3], & cnts[4],
                  & cnts[5], & cnts[6], & cnts[7], & cnts[8], & cnts[9], & cnts[10],
                  & cnts[11], & cnts[12], & cnts[13], & cnts[14], & cnts[15], & cnts[16],
                  & cnts[17], & cnts[18], & cnts[19], & cnts[20], & cnts[21], & cnts[22],
                  & cnts[23], & cnts[24], & cnts[25], & cnts[26], & cnts[27], & cnts[28],
                  & cnts[29], & cnts[30], & cnts[31]);
      }
#line 885
      if (nr < 2) {
#line 886
        goto while_continue;
      }
      {
#line 888
      nfsfill(itsname, cnts, nr - 1, ns, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 891
    fclose(fp);
    }
  }
  {
#line 898
  fp = fopen((char const   */* __restrict  */)"/proc/net/rpc/nfsd", (char const   */* __restrict  */)"r");
  }
#line 898
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 900
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 900
      tmp___0 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 900
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 900
        goto while_break___0;
      }
      {
#line 902
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s   %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld\n",
                  itsname, & cnts[0], & cnts[1], & cnts[2], & cnts[3], & cnts[4],
                  & cnts[5], & cnts[6], & cnts[7], & cnts[8], & cnts[9], & cnts[10],
                  & cnts[11], & cnts[12], & cnts[13], & cnts[14], & cnts[15], & cnts[16],
                  & cnts[17], & cnts[18], & cnts[19], & cnts[20], & cnts[21], & cnts[22],
                  & cnts[23], & cnts[24], & cnts[25], & cnts[26], & cnts[27], & cnts[28],
                  & cnts[29], & cnts[30], & cnts[31]);
      }
#line 917
      if (nr < 2) {
#line 918
        goto while_continue___0;
      }
      {
#line 920
      nfsfill(itsname, cnts, nr - 1, ns, 0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 923
    fclose(fp);
    }
  }
#line 925
  return;
}
}
#line 927 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void nfsfill(char *nam , count_t *cnts , int nc , struct nfsstat *ns , int isclient ) 
{ 
  int tmp ;
  int tmp___0 ;
  int version ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 931
  tmp = strcmp("net", (char const   *)nam);
  }
#line 931
  if (tmp == 0) {
#line 933
    if (isclient) {
#line 935
      ns->cl_netcnt = *(cnts + 0);
#line 936
      ns->cl_netudpcnt = *(cnts + 1);
#line 937
      ns->cl_nettcpcnt = *(cnts + 2);
#line 938
      ns->cl_nettcpconn = *(cnts + 3);
    } else {
#line 942
      ns->sv_netcnt = *(cnts + 0);
#line 943
      ns->sv_netudpcnt = *(cnts + 1);
#line 944
      ns->sv_nettcpcnt = *(cnts + 2);
#line 945
      ns->sv_nettcpconn = *(cnts + 3);
    }
#line 948
    return;
  }
  {
#line 951
  tmp___0 = strcmp("rpc", (char const   *)nam);
  }
#line 951
  if (tmp___0 == 0) {
#line 953
    if (isclient) {
#line 955
      ns->cl_rpccnt = *(cnts + 0);
#line 956
      ns->cl_rpcretrans = *(cnts + 1);
#line 957
      ns->cl_rpcauthrefresh = *(cnts + 2);
    } else {
#line 961
      ns->sv_rpccnt = *(cnts + 0);
#line 962
      ns->sv_rpcbadtot = *(cnts + 1);
#line 963
      ns->sv_rpcbadfmt = *(cnts + 2);
#line 964
      ns->sv_rpcbadauth = *(cnts + 3);
#line 965
      ns->sv_rpcbadclnt = *(cnts + 4);
    }
#line 968
    return;
  }
#line 971
  if ((int )*(nam + 0) == 112) {
#line 971
    if ((int )*(nam + 1) == 114) {
#line 971
      if ((int )*(nam + 2) == 111) {
#line 971
        if ((int )*(nam + 3) == 99) {
          {
#line 974
          tmp___1 = atoi((char const   *)(nam + 4));
#line 974
          version = tmp___1;
          }
          {
#line 977
          if (version == 2) {
#line 977
            goto case_2;
          }
#line 986
          if (version == 3) {
#line 986
            goto case_3;
          }
#line 976
          goto switch_break;
          case_2: /* CIL Label */ 
#line 978
          if (isclient) {
            {
#line 979
            memcpy((void */* __restrict  */)(& ns->cl_proc2), (void const   */* __restrict  */)(cnts + 1),
                   sizeof(ns->cl_proc2));
            }
          } else {
            {
#line 982
            memcpy((void */* __restrict  */)(& ns->sv_proc2), (void const   */* __restrict  */)(cnts + 1),
                   sizeof(ns->sv_proc2));
            }
          }
#line 984
          goto switch_break;
          case_3: /* CIL Label */ 
#line 987
          if (isclient) {
            {
#line 988
            memcpy((void */* __restrict  */)(& ns->cl_proc3), (void const   */* __restrict  */)(cnts + 1),
                   sizeof(ns->cl_proc3));
            }
          } else {
            {
#line 991
            memcpy((void */* __restrict  */)(& ns->sv_proc3), (void const   */* __restrict  */)(cnts + 1),
                   sizeof(ns->sv_proc3));
            }
          }
#line 993
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 996
          return;
        }
      }
    }
  }
  {
#line 999
  tmp___2 = strcmp("rc", (char const   *)nam);
  }
#line 999
  if (tmp___2 == 0) {
#line 1001
    if (isclient) {
#line 1002
      return;
    }
#line 1004
    ns->sv_rchits = *(cnts + 0);
#line 1005
    ns->sv_rcmisses = *(cnts + 1);
#line 1006
    ns->sv_rcnocache = *(cnts + 2);
#line 1008
    if (nc == 9) {
#line 1010
      ns->sv_fhstale = *(cnts + 7);
#line 1011
      ns->sv_fhlookup = *(cnts + 6);
#line 1012
      ns->sv_fhanon = *(cnts + 5);
    }
#line 1014
    return;
  }
  {
#line 1017
  tmp___3 = strcmp("fh", (char const   *)nam);
  }
#line 1017
  if (tmp___3 == 0) {
#line 1019
    if (isclient) {
#line 1020
      return;
    }
#line 1022
    ns->sv_fhstale = *(cnts + 0);
#line 1023
    ns->sv_fhlookup = *(cnts + 1);
#line 1024
    ns->sv_fhanon = *(cnts + 2);
#line 1025
    ns->sv_fhnocachedir = *(cnts + 3);
#line 1026
    ns->sv_fhnocachenondir = *(cnts + 4);
#line 1028
    return;
  }
  {
#line 1031
  tmp___4 = strcmp("io", (char const   *)nam);
  }
#line 1031
  if (tmp___4 == 0) {
#line 1033
    if (isclient) {
#line 1034
      return;
    }
#line 1036
    ns->sv_ioread = *(cnts + 0);
#line 1037
    ns->sv_iowrite = *(cnts + 1);
#line 1039
    return;
  }
  {
#line 1042
  tmp___5 = strcmp("th", (char const   *)nam);
  }
#line 1042
  if (tmp___5 == 0) {
#line 1044
    if (isclient) {
#line 1045
      return;
    }
#line 1047
    ns->sv_thcount = *(cnts + 0);
#line 1048
    ns->sv_thlastcnt = *(cnts + 1);
#line 1050
    return;
  }
  {
#line 1053
  tmp___6 = strcmp("ra", (char const   *)nam);
  }
#line 1053
  if (tmp___6 == 0) {
#line 1055
    if (isclient) {
#line 1056
      return;
    }
#line 1058
    ns->sv_rasize = *(cnts + 0);
#line 1060
    return;
  }
#line 1063
  return;
}
}
#line 1069 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void tabget(struct fetchdef *fdef , struct osrel *osrel___0 , struct tabstat *ps ) 
{ 
  register int baselen ;
  FILE *fp ;
  char linebuf[1024] ;
  char firstword[80] ;
  char basepath[132] ;
  count_t cnt ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  count_t alloctot ;
  count_t allocfree ;

  {
  {
#line 1077
  memset((void *)ps, 0, sizeof(struct tabstat ));
#line 1082
  fp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 1082
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1084
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1084
      tmp___0 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 1084
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 1084
        goto while_break;
      }
      {
#line 1086
      sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s %lld",
             firstword, & cnt);
#line 1088
      tmp = strcmp((char const   *)(firstword), "processes");
      }
#line 1088
      if (tmp == 0) {
#line 1090
        ps->totforks = cnt;
#line 1091
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1094
    fclose(fp);
    }
  }
  {
#line 1100
  cnt = (count_t )0;
#line 1102
  fp = fopen((char const   */* __restrict  */)"/proc/locks", (char const   */* __restrict  */)"r");
  }
#line 1102
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1105
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1105
      tmp___1 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 1105
      if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 1105
        goto while_break___0;
      }
#line 1106
      cnt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1108
    fclose(fp);
    }
  }
  {
#line 1111
  ps->curlocks = cnt;
#line 1116
  fp = fopen((char const   */* __restrict  */)"/proc/sys/fs/dquot-max", (char const   */* __restrict  */)"r");
  }
#line 1116
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1118
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->maxdquot);
#line 1119
    fclose(fp);
    }
  }
  {
#line 1122
  fp = fopen((char const   */* __restrict  */)"/proc/sys/fs/dquot-nr", (char const   */* __restrict  */)"r");
  }
#line 1122
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1124
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->curdquot);
#line 1125
    fclose(fp);
    }
  }
  {
#line 1131
  fp = fopen((char const   */* __restrict  */)"/proc/sys/fs/super-max", (char const   */* __restrict  */)"r");
  }
#line 1131
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1133
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->maxsuper);
#line 1134
    fclose(fp);
    }
  }
  {
#line 1137
  fp = fopen((char const   */* __restrict  */)"/proc/sys/fs/super-nr", (char const   */* __restrict  */)"r");
  }
#line 1137
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1139
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->cursuper);
#line 1140
    fclose(fp);
    }
  }
#line 1148
  if (osrel___0->rel == 2) {
#line 1148
    if (osrel___0->vers < 2) {
      {
#line 1149
      strcpy((char */* __restrict  */)(basepath), (char const   */* __restrict  */)"/proc/sys/kernel/");
      }
    } else {
      {
#line 1151
      strcpy((char */* __restrict  */)(basepath), (char const   */* __restrict  */)"/proc/sys/fs/");
      }
    }
  } else {
    {
#line 1151
    strcpy((char */* __restrict  */)(basepath), (char const   */* __restrict  */)"/proc/sys/fs/");
    }
  }
  {
#line 1153
  tmp___2 = strlen((char const   *)(basepath));
#line 1153
  baselen = (int )tmp___2;
#line 1158
  strcpy((char */* __restrict  */)(& basepath[baselen]), (char const   */* __restrict  */)"file-max");
#line 1160
  fp = fopen((char const   */* __restrict  */)(basepath), (char const   */* __restrict  */)"r");
  }
#line 1160
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1162
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->maxfiles);
#line 1163
    fclose(fp);
    }
  }
  {
#line 1166
  strcpy((char */* __restrict  */)(& basepath[baselen]), (char const   */* __restrict  */)"file-nr");
#line 1168
  fp = fopen((char const   */* __restrict  */)(basepath), (char const   */* __restrict  */)"r");
  }
#line 1168
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1172
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld %lld",
           & alloctot, & allocfree);
#line 1173
    fclose(fp);
#line 1175
    ps->curfiles = alloctot - allocfree;
    }
  }
  {
#line 1181
  strcpy((char */* __restrict  */)(& basepath[baselen]), (char const   */* __restrict  */)"inode-max");
#line 1183
  fp = fopen((char const   */* __restrict  */)(basepath), (char const   */* __restrict  */)"r");
  }
#line 1183
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1185
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld", & ps->maxinode);
#line 1186
    fclose(fp);
    }
  }
  {
#line 1189
  strcpy((char */* __restrict  */)(& basepath[baselen]), (char const   */* __restrict  */)"inode-nr");
#line 1191
  fp = fopen((char const   */* __restrict  */)(basepath), (char const   */* __restrict  */)"r");
  }
#line 1191
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1193
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%lld %lld",
           & ps->curinode, & ps->maxinode);
#line 1194
    fclose(fp);
    }
  }
#line 1196
  return;
}
}
#line 1206 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static char usediskstats  ;
#line 1208 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void dkinit(struct fetchdef *fdef , struct osrel *osrel___0 ) 
{ 
  int numpart ;
  int nr ;
  FILE *fp ;
  struct dkstat dkstat ;
  char buf[256] ;
  char diskname[256] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1211
  numpart = 0;
#line 1211
  nr = 0;
#line 1220
  fp = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
  }
#line 1220
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1222
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1222
      tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 1222
      if (! tmp___0) {
#line 1222
        goto while_break;
      }
      {
#line 1224
      nr = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%hu %hu %lld %255s %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld",
                  & dkstat.major, & dkstat.minor, & dkstat.totsize, diskname, & dkstat.readblocks,
                  & dkstat.readmerges, & dkstat.readsectors, & dkstat.read_msecs,
                  & dkstat.writblocks, & dkstat.writmerges, & dkstat.writsectors,
                  & dkstat.writ_msecs, & dkstat.reqpending, & dkstat.rdwr_msecs, & dkstat.avq);
      }
#line 1244
      if (nr >= 8) {
        {
#line 1244
        tmp = isrealdisk(diskname, dkstat.name, 16);
        }
#line 1244
        if (tmp) {
#line 1246
          numpart ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1249
    fclose(fp);
    }
  }
#line 1252
  if (numpart > 0) {
#line 1254
    fdef->cdef.kinst = (unsigned short )numpart;
#line 1255
    return;
  }
  {
#line 1261
  fp = fopen((char const   */* __restrict  */)"/proc/diskstats", (char const   */* __restrict  */)"r");
  }
#line 1261
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1263
      tmp___2 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 1263
      if (! tmp___2) {
#line 1263
        goto while_break___0;
      }
      {
#line 1265
      nr = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%hu %hu %255s %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld",
                  & dkstat.major, & dkstat.minor, diskname, & dkstat.readblocks, & dkstat.readmerges,
                  & dkstat.readsectors, & dkstat.read_msecs, & dkstat.writblocks,
                  & dkstat.writmerges, & dkstat.writsectors, & dkstat.writ_msecs,
                  & dkstat.reqpending, & dkstat.rdwr_msecs, & dkstat.avq);
      }
#line 1284
      if (nr >= 7) {
        {
#line 1284
        tmp___1 = isrealdisk(diskname, dkstat.name, 16);
        }
#line 1284
        if (tmp___1) {
#line 1286
          numpart ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1289
    if (numpart > 0) {
#line 1290
      usediskstats = (char )((int )usediskstats + 1);
    }
    {
#line 1292
    fclose(fp);
    }
  }
#line 1295
  fdef->cdef.kinst = (unsigned short )numpart;
#line 1296
  return;
}
}
#line 1298 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void dkget(struct fetchdef *fdef , struct osrel *osrel___0 , struct dkstat *ds ) 
{ 
  FILE *fp ;
  int numpart ;
  int nr ;
  char buf[1024] ;
  char diskname[256] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 1302
  numpart = 0;
#line 1302
  nr = 0;
#line 1305
  if ((int )fdef->cdef.kinst == 0) {
#line 1306
    return;
  }
  {
#line 1308
  memset((void *)ds, 0, sizeof(struct dkstat ) * (unsigned long )fdef->cdef.kinst);
  }
#line 1310
  if (usediskstats) {
    {
#line 1312
    fp = fopen((char const   */* __restrict  */)"/proc/diskstats", (char const   */* __restrict  */)"r");
    }
    {
#line 1314
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1314
      tmp___0 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 1314
      if (tmp___0) {
#line 1314
        if (! (numpart < (int )fdef->cdef.kinst)) {
#line 1314
          goto while_break;
        }
      } else {
#line 1314
        goto while_break;
      }
      {
#line 1316
      nr = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%hu %hu %255s %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld",
                  & ds->major, & ds->minor, diskname, & ds->readblocks, & ds->readmerges,
                  & ds->readsectors, & ds->read_msecs, & ds->writblocks, & ds->writmerges,
                  & ds->writsectors, & ds->writ_msecs, & ds->reqpending, & ds->rdwr_msecs,
                  & ds->avq);
      }
#line 1335
      if (nr < 7) {
#line 1337
        goto while_continue;
      } else {
        {
#line 1335
        tmp = isrealdisk(diskname, ds->name, 16);
        }
#line 1335
        if (! tmp) {
#line 1337
          goto while_continue;
        }
      }
#line 1339
      if (nr == 7) {
#line 1341
        ds->writblocks = ds->readsectors;
#line 1342
        ds->writsectors = ds->read_msecs;
#line 1343
        ds->readsectors = ds->readmerges;
#line 1344
        ds->readmerges = (count_t )0;
#line 1345
        ds->read_msecs = (count_t )0;
#line 1346
        ds->writmerges = (count_t )0;
#line 1347
        ds->writ_msecs = (count_t )0;
#line 1348
        ds->reqpending = (count_t )0;
#line 1349
        ds->rdwr_msecs = (count_t )0;
#line 1350
        ds->avq = (count_t )0;
      }
#line 1353
      numpart ++;
#line 1354
      ds ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1359
    fp = fopen((char const   */* __restrict  */)"/proc/partitions", (char const   */* __restrict  */)"r");
    }
    {
#line 1361
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1361
      tmp___2 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 1361
      if (tmp___2) {
#line 1361
        if (! (numpart < (int )fdef->cdef.kinst)) {
#line 1361
          goto while_break___0;
        }
      } else {
#line 1361
        goto while_break___0;
      }
      {
#line 1363
      nr = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%hu %hu %lld %255s %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld %lld",
                  & ds->major, & ds->minor, & ds->totsize, diskname, & ds->readblocks,
                  & ds->readmerges, & ds->readsectors, & ds->read_msecs, & ds->writblocks,
                  & ds->writmerges, & ds->writsectors, & ds->writ_msecs, & ds->reqpending,
                  & ds->rdwr_msecs, & ds->avq);
      }
#line 1382
      if (nr >= 8) {
        {
#line 1382
        tmp___1 = isrealdisk(diskname, ds->name, 16);
        }
#line 1382
        if (tmp___1) {
#line 1384
          numpart ++;
#line 1385
          ds ++;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1390
  fclose(fp);
  }
#line 1391
  return;
}
}
#line 1397 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static void nullmodname(char *curname , char *newname , int maxlen ) 
{ 


  {
  {
#line 1400
  strncpy((char */* __restrict  */)newname, (char const   */* __restrict  */)curname,
          (size_t )(maxlen - 1));
#line 1401
  *((newname + maxlen) - 1) = (char)0;
  }
#line 1402
  return;
}
}
#line 1404 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static void abbrevname1(char *curname , char *newname , int maxlen ) 
{ 
  char cutype[128] ;
  int hostnum ;
  int busnum ;
  int targetnum ;
  int lunnum ;
  int partnum ;
  int nr ;

  {
  {
#line 1410
  nr = sscanf((char const   */* __restrict  */)curname, (char const   */* __restrict  */)"%[^/]/host%d/bus%d/target%d/lun%d/part%d",
              cutype, & hostnum, & busnum, & targetnum, & lunnum, & partnum);
  }
#line 1414
  if (nr == 5) {
    {
#line 1415
    snprintf((char */* __restrict  */)newname, (size_t )maxlen, (char const   */* __restrict  */)"%c-h%db%dt%d",
             (int )cutype[0], hostnum, busnum, targetnum);
    }
  } else {
    {
#line 1418
    snprintf((char */* __restrict  */)newname, (size_t )maxlen, (char const   */* __restrict  */)"%c-h%db%dt%d.%d",
             (int )cutype[0], hostnum, busnum, targetnum, partnum);
    }
  }
#line 1420
  return;
}
}
#line 1428 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static struct __anonstruct_validdisk_58 validdisk[5]  = {      {(char *)"^sd[a-z][a-z]*", {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0,
                                 0UL, 0U, 0U, 0U, 0U, 0U, 0U, 0U}, & nullmodname}, 
        {(char *)"^hd[a-z]",
      {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0, 0UL, 0U,
       0U, 0U, 0U, 0U, 0U, 0U}, & nullmodname}, 
        {(char *)"^rd/c[0-9][0-9]*d[0-9][0-9]*", {(unsigned char *)0, 0UL, 0UL, 0UL,
                                               (char *)0, (unsigned char *)0, 0UL,
                                               0U, 0U, 0U, 0U, 0U, 0U, 0U}, & nullmodname}, 
        {(char *)"^cciss/c[0-9][0-9]*d[0-9][0-9]*",
      {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0, (unsigned char *)0, 0UL, 0U,
       0U, 0U, 0U, 0U, 0U, 0U}, & nullmodname}, 
        {(char *)"/host.*/bus.*/target.*/lun", {(unsigned char *)0, 0UL, 0UL, 0UL, (char *)0,
                                             (unsigned char *)0, 0UL, 0U, 0U, 0U,
                                             0U, 0U, 0U, 0U}, & abbrevname1}};
#line 1443 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static int firstcall  =    1;
#line 1440 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
static int isrealdisk(char *curname , char *newname , int maxlen ) 
{ 
  register int i ;
  int tmp ;

  {
#line 1446
  if (firstcall) {
#line 1448
    i = 0;
    {
#line 1448
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1448
      if (! ((unsigned long )i < sizeof(validdisk) / sizeof(validdisk[0]))) {
#line 1448
        goto while_break;
      }
      {
#line 1449
      regcomp((regex_t */* __restrict  */)(& validdisk[i].compreg), (char const   */* __restrict  */)validdisk[i].regexp,
              ((1 << 1) << 1) << 1);
#line 1448
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1451
    firstcall = 0;
  }
#line 1457
  i = 0;
  {
#line 1457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1457
    if (! ((unsigned long )i < sizeof(validdisk) / sizeof(validdisk[0]))) {
#line 1457
      goto while_break___0;
    }
    {
#line 1459
    tmp = regexec((regex_t const   */* __restrict  */)(& validdisk[i].compreg), (char const   */* __restrict  */)curname,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 1459
    if (tmp == 0) {
      {
#line 1464
      (*(validdisk[i].modname))(curname, newname, maxlen);
      }
#line 1466
      return (1);
    }
#line 1457
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1470
  return (0);
}
}
#line 1478 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void sockget(struct fetchdef *fdef , struct osrel *osrel___0 , struct sockstat *ss ) 
{ 
  FILE *fp ;
  char linebuf[1024] ;
  char itsname[32] ;
  char notused[64] ;
  count_t nowuse ;
  count_t maxuse ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 1486
  memset((void *)ss, 0, sizeof(struct sockstat ));
#line 1488
  fp = fopen((char const   */* __restrict  */)"/proc/net/sockstat", (char const   */* __restrict  */)"r");
  }
#line 1488
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1490
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1490
      tmp___2 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 1490
      if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 1490
        goto while_break;
      }
      {
#line 1492
      maxuse = (count_t )0;
#line 1494
      tmp = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s  %s %lld %s %lld\n",
                   itsname, notused, & nowuse, notused, & maxuse);
      }
#line 1494
      if (tmp < 3) {
#line 1496
        goto while_continue;
      }
      {
#line 1498
      tmp___0 = strcmp("TCP:", (char const   *)(itsname));
      }
#line 1498
      if (tmp___0 == 0) {
#line 1500
        ss->tcpnow = nowuse;
#line 1501
        ss->tcpmax = maxuse;
#line 1502
        goto while_continue;
      }
      {
#line 1505
      tmp___1 = strcmp("UDP:", (char const   *)(itsname));
      }
#line 1505
      if (tmp___1 == 0) {
#line 1507
        ss->udpnow = nowuse;
#line 1508
        ss->udpmax = maxuse;
#line 1509
        goto while_continue;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1513
    fclose(fp);
    }
  }
  {
#line 1516
  fp = fopen((char const   */* __restrict  */)"/proc/net/sockstat6", (char const   */* __restrict  */)"r");
  }
#line 1516
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1518
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1518
      tmp___6 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
      }
#line 1518
      if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 1518
        goto while_break___0;
      }
      {
#line 1520
      maxuse = (count_t )0;
#line 1522
      tmp___3 = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s  %s %lld %s %lld\n",
                       itsname, notused, & nowuse, notused, & maxuse);
      }
#line 1522
      if (tmp___3 < 3) {
#line 1524
        goto while_continue___0;
      }
      {
#line 1526
      tmp___4 = strcmp("TCP6:", (char const   *)(itsname));
      }
#line 1526
      if (tmp___4 == 0) {
#line 1528
        ss->tcp6now = nowuse;
#line 1529
        ss->tcp6max = maxuse;
#line 1530
        goto while_continue___0;
      }
      {
#line 1533
      tmp___5 = strcmp("UDP6:", (char const   *)(itsname));
      }
#line 1533
      if (tmp___5 == 0) {
#line 1535
        ss->udp6now = nowuse;
#line 1536
        ss->udp6max = maxuse;
#line 1537
        goto while_continue___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1541
    fclose(fp);
    }
  }
#line 1543
  return;
}
}
#line 1550 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
void ttyget(struct fetchdef *fdef , struct osrel *osrel___0 , struct serialstat *ts ) 
{ 
  register char *p ;
  FILE *fp ;
  char linebuf[1024] ;
  char nam[9][16] ;
  char par[9][16] ;
  int ttynum ;
  int nr ;
  int i ;
  int t ;
  int colons ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 1557
  t = 0;
#line 1559
  memset((void *)ts, 0, sizeof(struct serialstat ) * (unsigned long )fdef->cdef.kinst);
#line 1561
  fp = fopen((char const   */* __restrict  */)"/proc/tty/driver/serial", (char const   */* __restrict  */)"r");
  }
#line 1561
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1563
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1563
      tmp___13 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                       (FILE */* __restrict  */)fp);
      }
#line 1563
      if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 1563
        goto while_break;
      }
#line 1569
      p = linebuf;
#line 1569
      colons = 0;
      {
#line 1569
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1569
        if (! *p) {
#line 1569
          goto while_break___0;
        }
#line 1571
        if ((int )*p != 58) {
#line 1572
          goto __Cont;
        }
#line 1574
        *p = (char )' ';
#line 1575
        colons ++;
        __Cont: /* CIL Label */ 
#line 1569
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1578
      if (colons < 5) {
#line 1579
        goto while_continue;
      }
      {
#line 1584
      nr = sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%d %s %s %s %s %s %s %s %s   %s %s %s %s %s %s %s %s   %s %s\n",
                  & ttynum, nam[0], par[0], nam[1], par[1], nam[2], par[2], nam[3],
                  par[3], nam[4], par[4], nam[5], par[5], nam[6], par[6], nam[7],
                  par[7], nam[8], par[8]);
#line 1594
      nr = (nr - 1) / 2;
#line 1596
      i = 1;
      }
      {
#line 1596
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1596
        if (! (i < nr)) {
#line 1596
          goto while_break___1;
        }
        {
#line 1598
        tmp___0 = strcmp("port", (char const   *)(nam[i]));
        }
#line 1598
        if (tmp___0 == 0) {
          {
#line 1600
          tmp = strtol((char const   */* __restrict  */)(par[i]), (char **/* __restrict  */)((void *)0),
                       16);
#line 1600
          ts->port = (count_t )tmp;
          }
#line 1601
          goto __Cont___0;
        }
        {
#line 1604
        tmp___2 = strcmp("tx", (char const   *)(nam[i]));
        }
#line 1604
        if (tmp___2 == 0) {
          {
#line 1606
          tmp___1 = atoi((char const   *)(par[i]));
#line 1606
          ts->tx = (count_t )tmp___1;
          }
#line 1607
          goto __Cont___0;
        }
        {
#line 1610
        tmp___4 = strcmp("rx", (char const   *)(nam[i]));
        }
#line 1610
        if (tmp___4 == 0) {
          {
#line 1612
          tmp___3 = atoi((char const   *)(par[i]));
#line 1612
          ts->rx = (count_t )tmp___3;
          }
#line 1613
          goto __Cont___0;
        }
        {
#line 1616
        tmp___6 = strcmp("fe", (char const   *)(nam[i]));
        }
#line 1616
        if (tmp___6 == 0) {
          {
#line 1618
          tmp___5 = atoi((char const   *)(par[i]));
#line 1618
          ts->fe = (count_t )tmp___5;
          }
#line 1619
          goto __Cont___0;
        }
        {
#line 1622
        tmp___8 = strcmp("brk", (char const   *)(nam[i]));
        }
#line 1622
        if (tmp___8 == 0) {
          {
#line 1624
          tmp___7 = atoi((char const   *)(par[i]));
#line 1624
          ts->br = (count_t )tmp___7;
          }
#line 1625
          goto __Cont___0;
        }
        {
#line 1628
        tmp___10 = strcmp("pe", (char const   *)(nam[i]));
        }
#line 1628
        if (tmp___10 == 0) {
          {
#line 1630
          tmp___9 = atoi((char const   *)(par[i]));
#line 1630
          ts->pe = (count_t )tmp___9;
          }
#line 1631
          goto __Cont___0;
        }
        {
#line 1634
        tmp___12 = strcmp("oe", (char const   *)(nam[i]));
        }
#line 1634
        if (tmp___12 == 0) {
          {
#line 1636
          tmp___11 = atoi((char const   *)(par[i]));
#line 1636
          ts->oe = (count_t )tmp___11;
          }
#line 1637
          goto __Cont___0;
        }
        __Cont___0: /* CIL Label */ 
#line 1596
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1641
      if (ts->port == 0LL) {
#line 1642
        goto while_continue;
      }
#line 1644
      t ++;
#line 1644
      if (t >= (int )fdef->cdef.kinst) {
#line 1645
        goto while_break;
      }
#line 1647
      ts ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1650
    fclose(fp);
    }
  }
#line 1652
  return;
}
}
#line 1803 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct fetchdef oncedef[]  = { };
#line 1808 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
int oncecnt  =    (int )(sizeof(oncedef) / sizeof(struct fetchdef ));
#line 1814 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
struct fetchdef sampdef[9]  = 
#line 1814
  {      {{(char *)"genstat", (unsigned short )sizeof(struct genstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& genget)}, 
        {{(char *)"memstat", (unsigned short )sizeof(struct memstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& memget)}, 
        {{(char *)"ifstat", (unsigned short )sizeof(struct ifstat ), (unsigned short)1},
      (void (*)())(& ifinit), (void (*)())(& ifget)}, 
        {{(char *)"netstat", (unsigned short )sizeof(struct netstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& netget)}, 
        {{(char *)"nfsstat", (unsigned short )sizeof(struct nfsstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& nfsget)}, 
        {{(char *)"tabstat", (unsigned short )sizeof(struct tabstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& tabget)}, 
        {{(char *)"partstat", (unsigned short )sizeof(struct dkstat ), (unsigned short)1},
      (void (*)())(& dkinit), (void (*)())(& dkget)}, 
        {{(char *)"sockstat", (unsigned short )sizeof(struct sockstat ), (unsigned short)1},
      (void (*)())0, (void (*)())(& sockget)}, 
        {{(char *)"ttystat", (unsigned short )sizeof(struct serialstat ), (unsigned short)32},
      (void (*)())0, (void (*)())(& ttyget)}};
#line 1832 "/home/june/collector/temp/atsar-1.7/atsadc/fetchdef.c"
int sampcnt  =    (int )(sizeof(sampdef) / sizeof(struct fetchdef ));
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 48 "/usr/include/x86_64-linux-gnu/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) times)(struct tms *__buffer ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 38 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 53
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 334
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 65 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
struct osrel osrel  ;
#line 70 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
char *outfile  ;
#line 71 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
int interval  =    0;
#line 72 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
int nsamples  =    0;
#line 77
void writehdr(int ofd , int namosz , int namssz , int varosz , int varssz ) ;
#line 78
void prusage(char *pname ) ;
#line 79
int numcpus(void) ;
#line 83 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
int main(int argc , char **argv ) 
{ 
  register int i ;
  char newfile ;
  int ofd ;
  int cycle ;
  struct filehdr filehdr___0 ;
  struct samphdr samphdr ;
  struct tms timbuf ;
  int namosize ;
  int namssize ;
  int varosize ;
  int varssize ;
  register unsigned long tmpoff ;
  register char *tmpcnt ;
  struct utsname utsname ;
  struct timeval tval ;
  long intervalnano ;
  long secsnext ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;

  {
#line 109
  if (argc > 1) {
    {
#line 111
    tmp___0 = __ctype_b_loc();
    }
#line 111
    if ((int const   )*(*tmp___0 + (int )*(*(argv + 1))) & 2048) {
      {
#line 113
      interval = atoi((char const   *)*(argv + 1));
      }
#line 115
      if (interval <= 0) {
        {
#line 116
        prusage(*(argv + 0));
        }
      }
#line 118
      if (argc < 3) {
        {
#line 119
        prusage(*(argv + 0));
        }
      } else {
        {
#line 118
        tmp = __ctype_b_loc();
        }
#line 118
        if (! ((int const   )*(*tmp + (int )*(*(argv + 2))) & 2048)) {
          {
#line 119
          prusage(*(argv + 0));
          }
        }
      }
      {
#line 121
      nsamples = atoi((char const   *)*(argv + 2));
      }
#line 123
      if (argc > 3) {
#line 124
        outfile = *(argv + 3);
      }
    } else {
#line 128
      outfile = *(argv + 1);
    }
  }
#line 135
  if (! outfile) {
    {
#line 137
    ofd = dup(1);
#line 138
    newfile = (char)1;
    }
  } else {
    {
#line 142
    tmp___3 = access((char const   *)outfile, 2);
    }
#line 142
    if (tmp___3 == -1) {
#line 148
      if (! interval) {
        {
#line 149
        exit(0);
        }
      }
      {
#line 154
      ofd = open((char const   *)outfile, 65, 436);
      }
#line 154
      if (ofd == -1) {
        {
#line 156
        perror("create output file");
#line 157
        exit(1);
        }
      }
#line 160
      newfile = (char)1;
    } else {
      {
#line 168
      ofd = open((char const   *)outfile, 2);
      }
#line 168
      if (ofd == -1) {
        {
#line 170
        perror("open output file");
#line 171
        exit(1);
        }
      }
      {
#line 174
      tmp___1 = read(ofd, (void *)(& filehdr___0), sizeof(filehdr___0));
      }
#line 174
      if (tmp___1 == -1L) {
        {
#line 176
        perror("verify output file");
#line 177
        exit(1);
        }
      }
#line 180
      if (filehdr___0.magic != 4276992702L) {
        {
#line 182
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"existing file %s has wrong format\n",
                outfile);
#line 185
        exit(6);
        }
      }
      {
#line 188
      lseek(ofd, (__off_t )0, 2);
#line 190
      newfile = (char)0;
      }
#line 196
      if (! interval) {
        {
#line 198
        samphdr.curtim = time((time_t *)0);
#line 199
        samphdr.curlbolt = times(& timbuf);
#line 200
        samphdr.cntsize = 0;
#line 202
        tmp___2 = write(ofd, (void const   *)(& samphdr), sizeof(samphdr));
        }
#line 202
        if (tmp___2 == -1L) {
          {
#line 204
          perror("write restart");
#line 205
          exit(1);
          }
        }
        {
#line 208
        close(ofd);
#line 209
        exit(0);
        }
      }
    }
  }
  {
#line 217
  uname(& utsname);
#line 219
  sscanf((char const   */* __restrict  */)(utsname.release), (char const   */* __restrict  */)"%d.%d.%d",
         & osrel.rel, & osrel.vers, & osrel.sub);
  }
#line 222
  if (osrel.rel < 2) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nLINUX-version %d.%d not supported!\n",
            osrel.rel, osrel.vers);
#line 226
    exit(5);
    }
  }
#line 236
  i = 0;
#line 236
  namosize = 0;
#line 236
  varosize = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (i < oncecnt)) {
#line 236
      goto while_break;
    }
#line 238
    if (oncedef[i].initcnt) {
      {
#line 239
      (*(oncedef[i].initcnt))(& oncedef[i], & osrel);
      }
    }
#line 241
    if ((int )oncedef[i].cdef.ksize & 7) {
#line 242
      oncedef[i].cdef.ksize = (unsigned short )((((int )oncedef[i].cdef.ksize >> 3) + 1) << 3);
    }
    {
#line 245
    varosize += (int )oncedef[i].cdef.ksize * (int )oncedef[i].cdef.kinst;
#line 246
    tmp___4 = strlen((char const   *)oncedef[i].cdef.kname);
#line 246
    namosize = (int )((size_t )namosize + (tmp___4 + 1UL));
#line 236
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if (namosize & 15) {
#line 250
    namosize = ((namosize >> 4) + 1) << 4;
  }
#line 252
  i = 0;
#line 252
  namssize = 0;
#line 252
  varssize = 0;
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (! (i < sampcnt)) {
#line 252
      goto while_break___0;
    }
#line 254
    if (sampdef[i].initcnt) {
      {
#line 255
      (*(sampdef[i].initcnt))(& sampdef[i], & osrel);
      }
    }
#line 257
    if ((int )sampdef[i].cdef.ksize & 7) {
#line 258
      sampdef[i].cdef.ksize = (unsigned short )((((int )sampdef[i].cdef.ksize >> 3) + 1) << 3);
    }
    {
#line 261
    varssize += (int )sampdef[i].cdef.ksize * (int )sampdef[i].cdef.kinst;
#line 262
    tmp___5 = strlen((char const   *)sampdef[i].cdef.kname);
#line 262
    namssize = (int )((size_t )namssize + (tmp___5 + 1UL));
#line 252
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  if (namssize & 15) {
#line 266
    namssize = ((namssize >> 4) + 1) << 4;
  }
#line 273
  if (newfile) {
    {
#line 275
    writehdr(ofd, namosize, namssize, varosize, varssize);
    }
  } else
#line 279
  if (filehdr___0.oncecnt != oncecnt) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else
#line 279
  if (filehdr___0.oncenames != namosize) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else
#line 279
  if (filehdr___0.oncevars != varosize) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else
#line 279
  if (filehdr___0.sampcnt != sampcnt) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else
#line 279
  if (filehdr___0.sampnames != namssize) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else
#line 279
  if (filehdr___0.sampvars != varssize) {
    {
#line 287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
    exit(7);
    }
  } else {
    {
#line 279
    tmp___6 = strcmp((char const   *)(filehdr___0.utsinfo.release), (char const   *)(utsname.release));
    }
#line 279
    if (tmp___6) {
      {
#line 287
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This existing file cannot be appended\n");
#line 289
      exit(7);
      }
    }
  }
  {
#line 297
  tmp___7 = malloc((size_t )varssize);
#line 297
  tmpcnt = (char *)tmp___7;
  }
#line 297
  if ((unsigned long )tmpcnt == (unsigned long )((void *)0)) {
    {
#line 299
    perror("cannot malloc");
#line 300
    exit(5);
    }
  }
  {
#line 308
  gettimeofday((struct timeval */* __restrict  */)(& tval), (__timezone_ptr_t )((struct timezone *)0));
#line 309
  secsnext = tval.tv_sec;
#line 310
  intervalnano = (long )(interval * 1000000);
#line 312
  cycle = 0;
  }
  {
#line 312
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 312
    if (! (cycle < nsamples)) {
#line 312
      goto while_break___1;
    }
#line 318
    if (cycle) {
      {
#line 322
      gettimeofday((struct timeval */* __restrict  */)(& tval), (__timezone_ptr_t )((struct timezone *)0));
      }
#line 324
      if (tval.tv_sec >= secsnext) {
        {
#line 325
        usleep((__useconds_t )(intervalnano - tval.tv_usec));
        }
      } else {
        {
#line 327
        usleep((__useconds_t )((intervalnano - tval.tv_usec) + 1000000L));
        }
      }
#line 329
      secsnext += (long )interval;
    }
    {
#line 336
    samphdr.curtim = time((time_t *)0);
#line 337
    samphdr.curlbolt = times(& timbuf);
#line 338
    samphdr.cntsize = varssize;
#line 340
    i = 0;
#line 340
    tmpoff = 0UL;
    }
    {
#line 340
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 340
      if (! (i < sampcnt)) {
#line 340
        goto while_break___2;
      }
      {
#line 342
      (*(sampdef[i].getcnt))(& sampdef[i], & osrel, tmpcnt + tmpoff);
#line 344
      tmpoff += (unsigned long )((int )sampdef[i].cdef.ksize * (int )sampdef[i].cdef.kinst);
#line 340
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 350
    tmp___8 = write(ofd, (void const   *)(& samphdr), sizeof(samphdr));
    }
#line 350
    if (tmp___8 < 0L) {
      {
#line 352
      perror("write of sample header");
#line 353
      exit(1);
      }
    }
    {
#line 356
    tmp___9 = write(ofd, (void const   *)tmpcnt, (size_t )varssize);
    }
#line 356
    if (tmp___9 < 0L) {
      {
#line 358
      perror("write of sample counters");
#line 359
      exit(1);
      }
    }
#line 312
    cycle ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 363
  close(ofd);
  }
#line 364
  return (0);
}
}
#line 375 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
void writehdr(int ofd , int namosz , int namssz , int varosz , int varssz ) 
{ 
  register int i ;
  struct filehdr filehdr___0 ;
  char *tmpname ;
  struct countdef *tmpdef ;
  register unsigned long tmpoff ;
  register char *tmpcnt ;
  int oncetot ;
  int samptot ;
  ssize_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  register int len ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  register int len___0 ;
  size_t tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  void *tmp___10 ;
  ssize_t tmp___11 ;

  {
  {
#line 390
  oncetot = (int )((unsigned long )oncecnt * sizeof(struct countdef ));
#line 391
  samptot = (int )((unsigned long )sampcnt * sizeof(struct countdef ));
#line 393
  filehdr___0.magic = 4276992702L;
#line 394
  filehdr___0.hdrsize = (int )sizeof(struct filehdr );
#line 395
  filehdr___0.oncecnt = oncecnt;
#line 396
  filehdr___0.oncenames = namosz;
#line 397
  filehdr___0.oncevars = varosz;
#line 398
  filehdr___0.sampcnt = sampcnt;
#line 399
  filehdr___0.sampnames = namssz;
#line 400
  filehdr___0.sampvars = varssz;
#line 401
  filehdr___0.hertz = 100;
#line 402
  filehdr___0.numcpu = numcpus();
#line 404
  uname(& filehdr___0.utsinfo);
#line 406
  tmp = write(ofd, (void const   *)(& filehdr___0), sizeof(filehdr___0));
  }
#line 406
  if (tmp < 0L) {
    {
#line 408
    perror("write of header data");
#line 409
    exit(1);
    }
  }
  {
#line 415
  tmp___0 = malloc((size_t )oncetot);
#line 415
  tmpdef = (struct countdef *)tmp___0;
  }
#line 415
  if ((unsigned long )tmpdef == (unsigned long )((void *)0)) {
    {
#line 417
    perror("cannot malloc");
#line 418
    exit(5);
    }
  }
  {
#line 421
  tmp___1 = malloc((size_t )namosz);
#line 421
  tmpname = (char *)tmp___1;
  }
#line 421
  if ((unsigned long )tmpname == (unsigned long )((void *)0)) {
    {
#line 423
    perror("cannot malloc");
#line 424
    exit(5);
    }
  }
#line 427
  i = 0;
#line 427
  tmpoff = 0UL;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < oncecnt)) {
#line 427
      goto while_break;
    }
    {
#line 431
    tmp___2 = strlen((char const   *)oncedef[i].cdef.kname);
#line 431
    len = (int )(tmp___2 + 1UL);
#line 433
    memcpy((void */* __restrict  */)(tmpname + tmpoff), (void const   */* __restrict  */)oncedef[i].cdef.kname,
           (size_t )len);
#line 435
    (tmpdef + i)->kname = (char *)tmpoff;
#line 436
    (tmpdef + i)->ksize = oncedef[i].cdef.ksize;
#line 437
    (tmpdef + i)->kinst = oncedef[i].cdef.kinst;
#line 439
    tmpoff += (unsigned long )len;
#line 427
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 442
  tmp___3 = write(ofd, (void const   *)tmpdef, (size_t )oncetot);
  }
#line 442
  if (tmp___3 < 0L) {
    {
#line 444
    perror("write of counter definition data");
#line 445
    exit(1);
    }
  }
  {
#line 448
  tmp___4 = write(ofd, (void const   *)tmpname, (size_t )namosz);
  }
#line 448
  if (tmp___4 < 0L) {
    {
#line 450
    perror("write of counter names");
#line 451
    exit(1);
    }
  }
  {
#line 454
  free((void *)tmpname);
#line 455
  free((void *)tmpdef);
#line 460
  tmp___5 = malloc((size_t )samptot);
#line 460
  tmpdef = (struct countdef *)tmp___5;
  }
#line 460
  if ((unsigned long )tmpdef == (unsigned long )((void *)0)) {
    {
#line 462
    perror("cannot malloc");
#line 463
    exit(5);
    }
  }
  {
#line 466
  tmp___6 = malloc((size_t )namssz);
#line 466
  tmpname = (char *)tmp___6;
  }
#line 466
  if ((unsigned long )tmpname == (unsigned long )((void *)0)) {
    {
#line 468
    perror("cannot malloc");
#line 469
    exit(5);
    }
  }
#line 472
  i = 0;
#line 472
  tmpoff = 0UL;
  {
#line 472
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 472
    if (! (i < sampcnt)) {
#line 472
      goto while_break___0;
    }
    {
#line 476
    tmp___7 = strlen((char const   *)sampdef[i].cdef.kname);
#line 476
    len___0 = (int )(tmp___7 + 1UL);
#line 478
    memcpy((void */* __restrict  */)(tmpname + tmpoff), (void const   */* __restrict  */)sampdef[i].cdef.kname,
           (size_t )len___0);
#line 480
    (tmpdef + i)->kname = (char *)tmpoff;
#line 481
    (tmpdef + i)->ksize = sampdef[i].cdef.ksize;
#line 482
    (tmpdef + i)->kinst = sampdef[i].cdef.kinst;
#line 484
    tmpoff += (unsigned long )len___0;
#line 472
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  tmp___8 = write(ofd, (void const   *)tmpdef, (size_t )samptot);
  }
#line 487
  if (tmp___8 < 0L) {
    {
#line 489
    perror("write of counter definition data");
#line 490
    exit(1);
    }
  }
  {
#line 493
  tmp___9 = write(ofd, (void const   *)tmpname, (size_t )namssz);
  }
#line 493
  if (tmp___9 < 0L) {
    {
#line 495
    perror("write of counter names");
#line 496
    exit(1);
    }
  }
  {
#line 499
  free((void *)tmpname);
#line 500
  free((void *)tmpdef);
#line 506
  tmp___10 = malloc((size_t )varosz);
#line 506
  tmpcnt = (char *)tmp___10;
  }
#line 506
  if ((unsigned long )tmpcnt == (unsigned long )((void *)0)) {
    {
#line 508
    perror("cannot malloc");
#line 509
    exit(5);
    }
  }
#line 512
  i = 0;
#line 512
  tmpoff = 0UL;
  {
#line 512
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 512
    if (! (i < oncecnt)) {
#line 512
      goto while_break___1;
    }
    {
#line 514
    (*(oncedef[i].getcnt))(& oncedef[i], & osrel, tmpcnt + tmpoff);
#line 516
    tmpoff += (unsigned long )((int )oncedef[i].cdef.ksize * (int )oncedef[i].cdef.kinst);
#line 512
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 519
  tmp___11 = write(ofd, (void const   *)tmpcnt, (size_t )varosz);
  }
#line 519
  if (tmp___11 < 0L) {
    {
#line 521
    perror("write of counters");
#line 522
    exit(1);
    }
  }
  {
#line 525
  free((void *)tmpcnt);
  }
#line 526
  return;
}
}
#line 531 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
void prusage(char *pname ) 
{ 


  {
  {
#line 534
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [t n] [ofile]\n",
          pname);
#line 535
  exit(1);
  }
}
}
#line 541 "/home/june/collector/temp/atsar-1.7/atsadc/atsadc.c"
int numcpus(void) 
{ 
  FILE *fp ;
  int cnt ;
  char linebuf[1024] ;
  char fw[80] ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 545
  cnt = 0;
#line 554
  fp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 554
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 555
    return (1);
  }
  {
#line 557
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    tmp = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf), (FILE */* __restrict  */)fp);
    }
#line 557
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 557
      goto while_break;
    }
    {
#line 559
    sscanf((char const   */* __restrict  */)(linebuf), (char const   */* __restrict  */)"%s ",
           fw);
    }
#line 561
    if ((int )fw[0] == 99) {
#line 561
      if ((int )fw[1] == 112) {
#line 561
        if ((int )fw[2] == 117) {
#line 561
          if ((int )fw[3] != 0) {
#line 562
            cnt ++;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 565
  fclose(fp);
  }
#line 567
  if (cnt > 0) {
#line 567
    tmp___0 = cnt;
  } else {
#line 567
    tmp___0 = 1;
  }
#line 567
  return (tmp___0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 332
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 67 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
struct funcdef funcdef[28] ;
#line 68
int funcnt ;
#line 73 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char *infile  ;
#line 74 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int ifd  ;
#line 78 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char numsamp[32]  ;
#line 79 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int nflags  ;
#line 80 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int newinterval  ;
#line 81 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int daynumber  ;
#line 82 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char Sflag  ;
#line 90 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
struct filehdr filehdr  ;
#line 93 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
struct countdef *oncelist  ;
#line 94 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char *ponce  ;
#line 94 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char *conce  ;
#line 96 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
struct countdef *samplist  ;
#line 97 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char *psamp  ;
#line 97 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
char *csamp  ;
#line 102
int readset(struct samphdr *hdr , void *cnt ) ;
#line 103
int readin(int fd , char *buf , int sz ) ;
#line 105
void printhead(struct utsname *uname___0 , time_t mtime ) ;
#line 106
void mktim(time_t itime , char *otime ) ;
#line 107
void mkdat(time_t idate , char *odate ) ;
#line 108
int convtim(char *itim , unsigned int *otim ) ;
#line 109
int daysecs(time_t itime ) ;
#line 782 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int readset(struct samphdr *hdr , void *cnt ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 788
  tmp = readin(ifd, (char *)hdr, (int )sizeof(struct samphdr ));
  }
#line 788
  if (tmp == 0) {
#line 789
    return (0);
  }
#line 791
  if (hdr->cntsize == 0) {
#line 792
    return (1);
  }
  {
#line 797
  tmp___0 = readin(ifd, (char *)cnt, hdr->cntsize);
  }
#line 797
  if (tmp___0 == 0) {
#line 798
    return (0);
  }
#line 800
  return (1);
}
}
#line 814 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int readin(int fd , char *buf , int sz ) 
{ 
  register int n ;
  ssize_t tmp ;

  {
  {
#line 819
  while (1) {
    while_continue: /* CIL Label */ ;
#line 819
    if (! sz) {
#line 819
      goto while_break;
    }
    {
#line 821
    tmp = read(fd, (void *)buf, (size_t )sz);
#line 821
    n = (int )tmp;
    }
#line 821
    if (n == -1) {
      {
#line 823
      perror("read input-file");
#line 824
      exit(1);
      }
    }
#line 827
    if (n == 0) {
#line 828
      return (0);
    }
#line 830
    sz -= n;
#line 831
    buf += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  return (1);
}
}
#line 872 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
void printhead(struct utsname *uname___0 , time_t mtime ) 
{ 
  char datstring[16] ;

  {
  {
#line 877
  mkdat(mtime, datstring);
#line 879
  printf((char const   */* __restrict  */)"\n%s  %s  %s  %s  %s  %s\n\n", uname___0->sysname,
         uname___0->nodename, uname___0->release, uname___0->version, uname___0->machine,
         datstring);
  }
#line 886
  return;
}
}
#line 891 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
void mktim(time_t itime , char *otime ) 
{ 
  struct tm *tt ;

  {
  {
#line 896
  tt = localtime((time_t const   *)(& itime));
#line 898
  sprintf((char */* __restrict  */)otime, (char const   */* __restrict  */)"%02d:%02d:%02d",
          tt->tm_hour, tt->tm_min, tt->tm_sec);
  }
#line 899
  return;
}
}
#line 904 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
void mkdat(time_t idate , char *odate ) 
{ 
  struct tm *tt ;

  {
  {
#line 909
  tt = localtime((time_t const   *)(& idate));
#line 911
  sprintf((char */* __restrict  */)odate, (char const   */* __restrict  */)"%02d/%02d/%04d",
          tt->tm_mon + 1, tt->tm_mday, tt->tm_year + 1900);
  }
#line 913
  return;
}
}
#line 921 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int convtim(char *itim , unsigned int *otim ) 
{ 
  register int i ;
  int hours ;
  int minutes ;
  unsigned short const   **tmp ;

  {
#line 930
  i = 0;
  {
#line 930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 930
    if (! ((int )*(itim + i) != 0)) {
#line 930
      goto while_break;
    }
    {
#line 931
    tmp = __ctype_b_loc();
    }
#line 931
    if (! ((int const   )*(*tmp + (int )*(itim + i)) & 2048)) {
#line 931
      if ((int )*(itim + i) != 58) {
#line 932
        return (0);
      }
    }
#line 930
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 934
  sscanf((char const   */* __restrict  */)itim, (char const   */* __restrict  */)"%d:%d",
         & hours, & minutes);
  }
#line 936
  if (hours < 0) {
#line 937
    return (0);
  } else
#line 936
  if (hours > 24) {
#line 937
    return (0);
  } else
#line 936
  if (minutes < 0) {
#line 937
    return (0);
  } else
#line 936
  if (minutes > 60) {
#line 937
    return (0);
  }
#line 939
  *otim = (unsigned int )(hours * 3600 + minutes * 60);
#line 941
  if (*otim >= 86400U) {
#line 942
    *otim = 86399U;
  }
#line 944
  return (1);
}
}
#line 952 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int daysecs(time_t itime ) 
{ 
  struct tm *tt ;

  {
  {
#line 957
  tt = localtime((time_t const   *)(& itime));
  }
#line 959
  return (tt->tm_hour * 3600 + tt->tm_min * 60);
}
}
#line 985 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
static int lastused  ;
#line 981 "/home/june/collector/temp/atsar-1.7/atsar/atsar.c"
int getcset(char *name , void **curptr , void **preptr ) 
{ 
  register int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 990
  tmp = strcmp((char const   *)name, (char const   *)(samplist + lastused)->kname);
  }
#line 990
  if (tmp == 0) {
#line 992
    *curptr = (void *)(csamp + (int )(samplist + lastused)->ksize);
#line 993
    *preptr = (void *)(psamp + (int )(samplist + lastused)->ksize);
#line 994
    return ((int )(samplist + lastused)->kinst);
  }
#line 1005
  i = 0;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! (i < filehdr.sampcnt)) {
#line 1005
      goto while_break;
    }
    {
#line 1007
    tmp___0 = strcmp((char const   *)name, (char const   *)(samplist + i)->kname);
    }
#line 1007
    if (tmp___0 == 0) {
#line 1009
      *curptr = (void *)(csamp + (int )(samplist + i)->ksize);
#line 1010
      *preptr = (void *)(psamp + (int )(samplist + i)->ksize);
#line 1012
      lastused = i;
#line 1013
      return ((int )(samplist + i)->kinst);
    }
#line 1005
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1025
  i = 0;
  {
#line 1025
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1025
    if (! (i < filehdr.oncecnt)) {
#line 1025
      goto while_break___0;
    }
    {
#line 1027
    tmp___1 = strcmp((char const   *)name, (char const   *)(oncelist + i)->kname);
    }
#line 1027
    if (tmp___1 == 0) {
#line 1029
      *curptr = (void *)(conce + (int )(oncelist + i)->ksize);
#line 1030
      *preptr = (void *)ponce;
#line 1031
      return ((int )(oncelist + i)->kinst);
    }
#line 1025
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1035
  return (0);
}
}
#line 146 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
double subtract(count_t newval , count_t oldval ) ;
#line 147
int prirpcs(count_t *rpccur , count_t *rpcpre , double tot , char *txt , int lines ,
            char *tstamp ) ;
#line 153 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void cpuhead(struct osrel *osr ) 
{ 


  {
#line 156
  if (osr->rel < 2) {
    {
#line 157
    printf((char const   */* __restrict  */)"cpu %%usr  %%sys  %%nice  %%idle                                    _cpu_\n");
    }
  } else
#line 156
  if (osr->vers < 6) {
    {
#line 157
    printf((char const   */* __restrict  */)"cpu %%usr  %%sys  %%nice  %%idle                                    _cpu_\n");
    }
  } else {
    {
#line 160
    printf((char const   */* __restrict  */)"cpu %%usr %%nice   %%sys %%irq %%softirq    %%wait %%idle             _cpu_\n");
    }
  }
#line 162
  return;
}
}
#line 164 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int cpuline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  register int i ;
  double usrdelta ;
  double sysdelta ;
  double nicdelta ;
  double idldelta ;
  double waidelta ;
  double irqdelta ;
  double sirdelta ;
  struct genstat *cur ;
  struct genstat *pre ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  {
#line 176
  tmp = getcset((char *)"genstat", (void **)(& cur), (void **)(& pre));
  }
#line 176
  if (! tmp) {
#line 177
    return (0);
  }
  {
#line 182
  tmp___0 = subtract(cur->cpu_user, pre->cpu_user);
#line 182
  usrdelta = tmp___0 / (double )ncpu;
#line 183
  tmp___1 = subtract(cur->cpu_system, pre->cpu_system);
#line 183
  sysdelta = tmp___1 / (double )ncpu;
#line 184
  tmp___2 = subtract(cur->cpu_nice, pre->cpu_nice);
#line 184
  nicdelta = tmp___2 / (double )ncpu;
#line 185
  tmp___3 = subtract(cur->cpu_wait, pre->cpu_wait);
#line 185
  waidelta = tmp___3 / (double )ncpu;
#line 186
  tmp___4 = subtract(cur->cpu_irq, pre->cpu_irq);
#line 186
  irqdelta = tmp___4 / (double )ncpu;
#line 187
  tmp___5 = subtract(cur->cpu_sirq, pre->cpu_sirq);
#line 187
  sirdelta = tmp___5 / (double )ncpu;
#line 188
  idldelta = (double )deltatic - (((((usrdelta + sysdelta) + nicdelta) + waidelta) + irqdelta) + sirdelta);
  }
#line 191
  if (idldelta < 0.0) {
#line 192
    idldelta = 0.0;
  }
#line 194
  if (osr->rel < 2) {
    {
#line 195
    printf((char const   */* __restrict  */)"all %4.0lf  %4.0lf  %5.0lf  %5.0lf\n",
           (usrdelta * 100.0) / (double )deltatic, (sysdelta * 100.0) / (double )deltatic,
           (nicdelta * 100.0) / (double )deltatic, (idldelta * 100.0) / (double )deltatic);
    }
  } else
#line 194
  if (osr->vers < 6) {
    {
#line 195
    printf((char const   */* __restrict  */)"all %4.0lf  %4.0lf  %5.0lf  %5.0lf\n",
           (usrdelta * 100.0) / (double )deltatic, (sysdelta * 100.0) / (double )deltatic,
           (nicdelta * 100.0) / (double )deltatic, (idldelta * 100.0) / (double )deltatic);
    }
  } else {
    {
#line 201
    printf((char const   */* __restrict  */)"all %4.0lf %5.0lf %6.0lf %4.0lf %8.0lf %8.0lf %5.0lf\n",
           (usrdelta * 100.0) / (double )deltatic, (nicdelta * 100.0) / (double )deltatic,
           (sysdelta * 100.0) / (double )deltatic, (irqdelta * 100.0) / (double )deltatic,
           (sirdelta * 100.0) / (double )deltatic, (waidelta * 100.0) / (double )deltatic,
           (idldelta * 100.0) / (double )deltatic);
    }
  }
#line 213
  if (ncpu > 1) {
#line 215
    i = 0;
    {
#line 215
    while (1) {
      while_continue: /* CIL Label */ ;
#line 215
      if (! (i < ncpu)) {
#line 215
        goto while_break;
      }
      {
#line 217
      usrdelta = subtract(cur->per_cpu_user[i], pre->per_cpu_user[i]);
#line 219
      sysdelta = subtract(cur->per_cpu_system[i], pre->per_cpu_system[i]);
#line 221
      nicdelta = subtract(cur->per_cpu_nice[i], pre->per_cpu_nice[i]);
#line 223
      waidelta = subtract(cur->per_cpu_wait[i], pre->per_cpu_wait[i]);
#line 225
      irqdelta = subtract(cur->per_cpu_irq[i], pre->per_cpu_irq[i]);
#line 227
      sirdelta = subtract(cur->per_cpu_sirq[i], pre->per_cpu_sirq[i]);
#line 229
      idldelta = (double )deltatic - (((((usrdelta + sysdelta) + nicdelta) + waidelta) + irqdelta) + sirdelta);
      }
#line 232
      if (idldelta < 0.0) {
#line 233
        idldelta = 0.0;
      }
#line 235
      if (osr->rel < 2) {
        {
#line 236
        printf((char const   */* __restrict  */)"%s  %3d %5.0lf %5.0lf %6.0lf %6.0lf\n",
               tstamp, i, (usrdelta * 100.0) / (double )deltatic, (sysdelta * 100.0) / (double )deltatic,
               (nicdelta * 100.0) / (double )deltatic, (idldelta * 100.0) / (double )deltatic);
        }
      } else
#line 235
      if (osr->vers < 6) {
        {
#line 236
        printf((char const   */* __restrict  */)"%s  %3d %5.0lf %5.0lf %6.0lf %6.0lf\n",
               tstamp, i, (usrdelta * 100.0) / (double )deltatic, (sysdelta * 100.0) / (double )deltatic,
               (nicdelta * 100.0) / (double )deltatic, (idldelta * 100.0) / (double )deltatic);
        }
      } else {
        {
#line 243
        printf((char const   */* __restrict  */)"%s  %3d %4.0lf %5.0lf %6.0lf %4.0lf %8.0lf %8.0lf %5.0lf\n",
               tstamp, i, (usrdelta * 100.0) / (double )deltatic, (nicdelta * 100.0) / (double )deltatic,
               (sysdelta * 100.0) / (double )deltatic, (irqdelta * 100.0) / (double )deltatic,
               (sirdelta * 100.0) / (double )deltatic, (waidelta * 100.0) / (double )deltatic,
               (idldelta * 100.0) / (double )deltatic);
        }
      }
#line 215
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 256
  return (1);
}
}
#line 262 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void prchead(struct osrel *osr ) 
{ 


  {
  {
#line 265
  printf((char const   */* __restrict  */)"pswch/s runq nrproc lavg1 lavg5 avg15                      _procload_\n");
  }
#line 267
  return;
}
}
#line 269 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int prcline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  struct genstat *cur ;
  struct genstat *pre ;
  int tmp ;
  double tmp___0 ;

  {
  {
#line 279
  tmp = getcset((char *)"genstat", (void **)(& cur), (void **)(& pre));
  }
#line 279
  if (! tmp) {
#line 280
    return (0);
  }
  {
#line 285
  tmp___0 = subtract(cur->context_swtch, pre->context_swtch);
#line 285
  printf((char const   */* __restrict  */)"%7.0lf %4lld %6lld %5.2lf %5.2lf %5.2lf\n",
         tmp___0 / (double )deltasec, cur->nrrun, cur->nrproc, (double )cur->loadavg1,
         (double )cur->loadavg5, (double )cur->loadavg15);
  }
#line 290
  return (1);
}
}
#line 297 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void memhead(struct osrel *osr ) 
{ 


  {
  {
#line 300
  printf((char const   */* __restrict  */)"memtot memfree buffers   cached  slabmem      swptot swpfree  _mem_\n");
  }
#line 302
  return;
}
}
#line 304 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int memline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  struct memstat *mcur ;
  struct memstat *mpre ;
  int tmp ;

  {
  {
#line 310
  tmp = getcset((char *)"memstat", (void **)(& mcur), (void **)(& mpre));
  }
#line 310
  if (! tmp) {
#line 311
    return (0);
  }
  {
#line 313
  printf((char const   */* __restrict  */)"%5lldM %6lldM %6lldM %7lldM %7lldM      %5lldM %6lldM\n",
         mcur->memtot / 1024LL, mcur->memfree / 1024LL, mcur->membuf / 1024LL, mcur->memcache / 1024LL,
         mcur->memslab / 1024LL, mcur->swptot / 1024LL, mcur->swpfree / 1024LL);
  }
#line 322
  return (1);
}
}
#line 328 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void pagehead(struct osrel *osr ) 
{ 


  {
  {
#line 331
  printf((char const   */* __restrict  */)" pagein/s pageout/s     swapin/s swapout/s         fork/s      _page_\n");
  }
#line 333
  return;
}
}
#line 335 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int pageline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  double si ;
  double so ;
  double pi ;
  double po ;
  double fo ;
  struct genstat *scur ;
  struct genstat *spre ;
  struct tabstat *pcur ;
  struct tabstat *ppre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 346
  tmp = getcset((char *)"genstat", (void **)(& scur), (void **)(& spre));
  }
#line 346
  if (! tmp) {
#line 347
    return (0);
  }
  {
#line 349
  pi = subtract(scur->pgpgin, spre->pgpgin);
#line 350
  po = subtract(scur->pgpgout, spre->pgpgout);
#line 351
  si = subtract(scur->pswpin, spre->pswpin);
#line 352
  so = subtract(scur->pswpout, spre->pswpout);
#line 354
  tmp___0 = getcset((char *)"tabstat", (void **)(& pcur), (void **)(& ppre));
  }
#line 354
  if (tmp___0) {
    {
#line 355
    fo = subtract(pcur->totforks, ppre->totforks);
    }
  } else {
#line 357
    fo = (double )0;
  }
  {
#line 359
  printf((char const   */* __restrict  */)"%9.2lf %9.2lf    %9.2lf %9.2lf        %7.2lf\n",
         pi / (double )deltasec, po / (double )deltasec, si / (double )deltasec, so / (double )deltasec,
         fo / (double )deltasec);
  }
#line 366
  return (1);
}
}
#line 373 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static char usedirq[16]  ;
#line 374 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static int usedmax  ;
#line 380
void inthead(struct osrel *osr ) ;
#line 380 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static char firstcall___0  =    (char)1;
#line 380 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static char headerline[128]  ;
#line 376 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void inthead(struct osrel *osr ) 
{ 
  register unsigned long i ;
  struct genstat *cur ;
  struct genstat *pre ;
  int tmp ;
  char tmpbuf[16] ;

  {
#line 387
  if (firstcall___0) {
    {
#line 392
    tmp = getcset((char *)"genstat", (void **)(& cur), (void **)(& pre));
    }
#line 392
    if (! tmp) {
      {
#line 394
      memcpy((void */* __restrict  */)(headerline), (void const   */* __restrict  */)"\n",
             (size_t )2);
#line 395
      printf((char const   */* __restrict  */)(headerline));
#line 396
      firstcall___0 = (char)0;
      }
#line 397
      return;
    }
#line 400
    i = 0UL;
    {
#line 400
    while (1) {
      while_continue: /* CIL Label */ ;
#line 400
      if (! (i < 64UL)) {
#line 400
        goto while_break;
      }
#line 402
      if (pre->irqs[i]) {
#line 404
        usedirq[usedmax] = (char )i;
#line 405
        usedmax ++;
#line 405
        if (usedmax >= 16) {
#line 406
          goto while_break;
        }
      }
#line 400
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 410
    memcpy((void */* __restrict  */)(headerline), (void const   */* __restrict  */)"cpu  ",
           (size_t )5);
#line 412
    i = 0UL;
    }
    {
#line 412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 412
      if (! (i < (unsigned long )usedmax)) {
#line 412
        goto while_break___0;
      }
      {
#line 416
      sprintf((char */* __restrict  */)(tmpbuf), (char const   */* __restrict  */)"iq%02d ",
              (int )usedirq[i]);
#line 417
      strcat((char */* __restrict  */)(headerline), (char const   */* __restrict  */)(tmpbuf));
#line 412
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 423
    i = strlen((char const   *)(headerline));
    }
#line 425
    if (i < 61UL) {
      {
#line 427
      memset((void *)(& headerline[i]), ' ', 61UL - i);
#line 428
      strcat((char */* __restrict  */)(headerline), (char const   */* __restrict  */)"_intr/s_");
      }
    }
    {
#line 430
    strcat((char */* __restrict  */)(headerline), (char const   */* __restrict  */)"\n");
#line 432
    firstcall___0 = (char)0;
    }
  }
  {
#line 435
  printf((char const   */* __restrict  */)(headerline));
  }
#line 436
  return;
}
}
#line 438 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int intline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  register unsigned long i ;
  register unsigned long j ;
  struct genstat *cur ;
  struct genstat *pre ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 448
  tmp = getcset((char *)"genstat", (void **)(& cur), (void **)(& pre));
  }
#line 448
  if (! tmp) {
#line 449
    return (0);
  }
  {
#line 454
  printf((char const   */* __restrict  */)"all  ");
#line 456
  i = 0UL;
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! (i < (unsigned long )usedmax)) {
#line 456
      goto while_break;
    }
    {
#line 458
    tmp___0 = subtract(cur->irqs[(int )usedirq[i]], pre->irqs[(int )usedirq[i]]);
#line 458
    printf((char const   */* __restrict  */)"%4.0lf ", tmp___0 / (double )deltasec);
#line 456
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 462
  printf((char const   */* __restrict  */)"\n");
  }
#line 467
  if (ncpu > 1) {
#line 469
    i = 0UL;
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (! (i < (unsigned long )ncpu)) {
#line 469
        goto while_break___0;
      }
      {
#line 471
      printf((char const   */* __restrict  */)"%s  %3lu  ", tstamp, i);
#line 473
      j = 0UL;
      }
      {
#line 473
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 473
        if (! (j < (unsigned long )usedmax)) {
#line 473
          goto while_break___1;
        }
        {
#line 475
        tmp___1 = subtract(cur->per_irqs[i][(int )usedirq[j]], pre->per_irqs[i][(int )usedirq[j]]);
#line 475
        printf((char const   */* __restrict  */)"%4.0lf ", tmp___1 / (double )deltasec);
#line 473
        j ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 481
      printf((char const   */* __restrict  */)"\n");
#line 469
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 486
  return (1);
}
}
#line 492 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void tabhead(struct osrel *osr ) 
{ 


  {
  {
#line 495
  printf((char const   */* __restrict  */)"superb-sz inode-sz     file-sz    dquota-sz    flock-sz      _curmax_\n");
  }
#line 497
  return;
}
}
#line 499 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int tabline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  struct tabstat *pcur ;
  struct tabstat *ppre ;
  int tmp ;

  {
  {
#line 505
  tmp = getcset((char *)"tabstat", (void **)(& pcur), (void **)(& ppre));
  }
#line 505
  if (! tmp) {
#line 506
    return (0);
  }
  {
#line 508
  printf((char const   */* __restrict  */)"%4lld/%-4lld  %5lld/%-5lld  %4lld/%-4lld  %5lld/%-5lld  %4lld/%-4lld\n",
         pcur->cursuper, pcur->maxsuper, pcur->curinode, pcur->maxinode, pcur->curfiles,
         pcur->maxfiles, pcur->curdquot, pcur->maxdquot, pcur->curlocks, pcur->maxlocks);
  }
#line 516
  return (1);
}
}
#line 522 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ttyhead(struct osrel *osr ) 
{ 


  {
  {
#line 525
  printf((char const   */* __restrict  */)"port   xmit/s   recv/s   frer/s  parer/s  ovrun/s    brk/s      _tty_\n");
  }
#line 527
  return;
}
}
#line 533
int ttyline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) ;
#line 533 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static int sampcnt___0  =    0;
#line 529 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ttyline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  register int nr ;
  register int i ;
  register int j ;
  register int lines ;
  struct serialstat *tcur ;
  struct serialstat *tpre ;
  double tx ;
  double rx ;
  double fe ;
  double pe ;
  double br ;
  double oe ;

  {
  {
#line 538
  nr = getcset((char *)"ttystat", (void **)(& tcur), (void **)(& tpre));
  }
#line 538
  if (! nr) {
#line 539
    return (0);
  }
#line 541
  sampcnt___0 ++;
#line 543
  lines = 0;
#line 543
  j = lines;
#line 543
  i = j;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (i < nr) {
#line 543
      if (j < nr) {
#line 543
        if (! (tcur + i)->port) {
#line 543
          goto while_break;
        }
      } else {
#line 543
        goto while_break;
      }
    } else {
#line 543
      goto while_break;
    }
#line 552
    if ((tcur + i)->port != (tpre + j)->port) {
#line 555
      j = 0;
      {
#line 555
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 555
        if (j < nr) {
#line 555
          if (! (tpre + j)->port) {
#line 555
            goto while_break___0;
          }
        } else {
#line 555
          goto while_break___0;
        }
#line 557
        if ((tcur + i)->port == (tpre + j)->port) {
#line 558
          goto while_break___0;
        }
#line 555
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 562
    tx = subtract((tcur + i)->tx, (tpre + j)->tx);
#line 563
    rx = subtract((tcur + i)->rx, (tpre + j)->rx);
#line 564
    fe = subtract((tcur + i)->fe, (tpre + j)->fe);
#line 565
    pe = subtract((tcur + i)->pe, (tpre + j)->pe);
#line 566
    oe = subtract((tcur + i)->oe, (tpre + j)->oe);
#line 567
    br = subtract((tcur + i)->br, (tpre + j)->br);
    }
#line 569
    if (sampcnt___0 > 1) {
#line 569
      if (((((tx + rx) + fe) + pe) + oe) + br == 0.0) {
#line 570
        goto __Cont;
      }
    }
#line 572
    lines ++;
#line 574
    if (lines > 1) {
      {
#line 575
      printf((char const   */* __restrict  */)"%s  ", tstamp);
      }
    }
    {
#line 577
    printf((char const   */* __restrict  */)"%4X %8.2lf %8.2lf %8.3lf %8.3lf %8.3lf %8.3lf\n",
           (int )(tcur + i)->port, tx / (double )deltasec, rx / (double )deltasec,
           fe / (double )deltasec, pe / (double )deltasec, oe / (double )deltasec,
           br / (double )deltasec);
    }
    __Cont: /* CIL Label */ 
#line 543
    i ++;
#line 543
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  if (lines == 0) {
    {
#line 588
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 590
  return (1);
}
}
#line 597 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ifhead(struct osrel *osr ) 
{ 


  {
  {
#line 600
  printf((char const   */* __restrict  */)"inpck/s otpck/s inbyt/s otbyt/s incmpr/s otcmpr/s inmcst/s iface _if_\n");
  }
#line 602
  return;
}
}
#line 608
int ifline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
           char *tstamp ) ;
#line 608 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static int sampcnt___1  =    0;
#line 604 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ifline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
           char *tstamp ) 
{ 
  register int i ;
  register int j ;
  register int nvalid ;
  register int nrif ;
  double ip ;
  double op ;
  double ib ;
  double ob ;
  double ic ;
  double oc ;
  double im ;
  struct ifstat *cur ;
  struct ifstat *pre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 613
  nrif = getcset((char *)"ifstat", (void **)(& cur), (void **)(& pre));
  }
#line 613
  if (! nrif) {
#line 614
    return (0);
  }
#line 616
  sampcnt___1 ++;
#line 618
  i = 0;
#line 618
  j = 0;
#line 618
  nvalid = 0;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i < nrif)) {
#line 618
      goto while_break;
    }
#line 620
    if ((int )(cur + i)->name[0] == 0) {
#line 621
      goto while_break;
    }
    {
#line 631
    tmp___0 = strcmp((char const   *)((cur + i)->name), (char const   *)((pre + j)->name));
    }
#line 631
    if (tmp___0 != 0) {
#line 634
      j = 0;
      {
#line 634
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 634
        if (! (j < nrif)) {
#line 634
          goto while_break___0;
        }
#line 636
        if ((int )(pre + j)->name[0] == 0) {
#line 637
          goto while_break___0;
        }
        {
#line 639
        tmp = strcmp((char const   *)((cur + i)->name), (char const   *)((pre + j)->name));
        }
#line 639
        if (tmp == 0) {
#line 640
          goto while_break___0;
        }
#line 634
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 643
      sampcnt___1 = 1;
    }
    {
#line 646
    ip = subtract((cur + i)->rpack, (pre + j)->rpack);
#line 647
    op = subtract((cur + i)->spack, (pre + j)->spack);
#line 648
    ib = subtract((cur + i)->rbyte, (pre + j)->rbyte);
#line 649
    ob = subtract((cur + i)->sbyte, (pre + j)->sbyte);
#line 650
    ic = subtract((cur + i)->rcompr, (pre + j)->rcompr);
#line 651
    oc = subtract((cur + i)->scompr, (pre + j)->scompr);
#line 652
    im = subtract((cur + i)->rmultic, (pre + j)->rmultic);
    }
#line 659
    if (sampcnt___1 > 1) {
#line 659
      if (! ip) {
#line 659
        if (! op) {
#line 660
          goto __Cont;
        }
      }
    }
#line 662
    if (nvalid) {
      {
#line 662
      printf((char const   */* __restrict  */)"%s  ", tstamp);
      }
    }
    {
#line 664
    nvalid ++;
#line 666
    printf((char const   */* __restrict  */)"%7.1lf %7.1lf %7.0lf %7.0lf %8.2lf %8.2lf %8.2lf %s\n",
           ip / (double )deltasec, op / (double )deltasec, ib / (double )deltasec,
           ob / (double )deltasec, ic / (double )deltasec, oc / (double )deltasec,
           im / (double )deltasec, (cur + i)->name);
    }
    __Cont: /* CIL Label */ 
#line 618
    i ++;
#line 618
    j = i;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  if (nvalid == 0) {
    {
#line 678
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 680
  return (1);
}
}
#line 683 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void IFhead(struct osrel *osr ) 
{ 


  {
  {
#line 686
  printf((char const   */* __restrict  */)"inerr/s oterr/s coll/s indrop/s otdrop/s infram/s otcarr/s iface _if_\n");
  }
#line 688
  return;
}
}
#line 694
int IFline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
           char *tstamp ) ;
#line 694 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
static int sampcnt___2  =    0;
#line 690 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int IFline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
           char *tstamp ) 
{ 
  register int i ;
  register int j ;
  register int nvalid ;
  register int nrif ;
  double ip ;
  double op ;
  double ie ;
  double oe ;
  double co ;
  double id ;
  double od ;
  double ifi ;
  double ofi ;
  double ifr ;
  double oca ;
  struct ifstat *cur ;
  struct ifstat *pre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 699
  nrif = getcset((char *)"ifstat", (void **)(& cur), (void **)(& pre));
  }
#line 699
  if (! nrif) {
#line 700
    return (0);
  }
#line 702
  sampcnt___2 ++;
#line 704
  i = 0;
#line 704
  j = 0;
#line 704
  nvalid = 0;
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (i < nrif)) {
#line 704
      goto while_break;
    }
#line 706
    if ((int )(cur + i)->name[0] == 0) {
#line 707
      goto while_break;
    }
    {
#line 717
    tmp___0 = strcmp((char const   *)((cur + i)->name), (char const   *)((pre + j)->name));
    }
#line 717
    if (tmp___0 != 0) {
#line 720
      j = 0;
      {
#line 720
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 720
        if (! (j < nrif)) {
#line 720
          goto while_break___0;
        }
#line 722
        if ((int )(pre + j)->name[0] == 0) {
#line 723
          goto while_break___0;
        }
        {
#line 725
        tmp = strcmp((char const   *)((cur + i)->name), (char const   *)((pre + j)->name));
        }
#line 725
        if (tmp == 0) {
#line 726
          goto while_break___0;
        }
#line 720
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 729
      sampcnt___2 = 1;
    }
    {
#line 732
    ip = subtract((cur + i)->rpack, (pre + j)->rpack);
#line 733
    op = subtract((cur + i)->spack, (pre + j)->spack);
#line 734
    ie = subtract((cur + i)->rerrs, (pre + j)->rerrs);
#line 735
    oe = subtract((cur + i)->serrs, (pre + j)->serrs);
#line 736
    co = subtract((cur + i)->scollis, (pre + j)->scollis);
#line 737
    id = subtract((cur + i)->rdrop, (pre + j)->rdrop);
#line 738
    od = subtract((cur + i)->sdrop, (pre + j)->sdrop);
#line 739
    ifi = subtract((cur + i)->rfifo, (pre + j)->rfifo);
#line 740
    ofi = subtract((cur + i)->sfifo, (pre + j)->sfifo);
#line 741
    ifr = subtract((cur + i)->rframe, (pre + j)->rframe);
#line 742
    oca = subtract((cur + i)->scarrier, (pre + j)->scarrier);
    }
#line 749
    if (sampcnt___2 > 1) {
#line 749
      if (! ip) {
#line 749
        if (! op) {
#line 750
          goto __Cont;
        }
      }
    }
#line 752
    if (nvalid) {
      {
#line 752
      printf((char const   */* __restrict  */)"%s  ", tstamp);
      }
    }
    {
#line 754
    nvalid ++;
#line 756
    printf((char const   */* __restrict  */)"%7.2lf %7.2lf %6.2lf %8.2lf %8.2lf %8.2lf %8.2lf %s\n",
           ie / (double )deltasec, oe / (double )deltasec, co / (double )deltasec,
           id / (double )deltasec, od / (double )deltasec, ifr / (double )deltasec,
           oca / (double )deltasec, (cur + i)->name);
    }
    __Cont: /* CIL Label */ 
#line 704
    i ++;
#line 704
    j = i;
  }
  while_break: /* CIL Label */ ;
  }
#line 767
  if (nvalid == 0) {
    {
#line 768
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 770
  return (1);
}
}
#line 776 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ipv4head(struct osrel *osr ) 
{ 


  {
  {
#line 779
  printf((char const   */* __restrict  */)"inrecv/s outreq/s indeliver/s forward/s reasmok/s fragcreat/s    _ip_\n");
  }
#line 781
  return;
}
}
#line 783 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ipv4line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  double ir ;
  double or ;
  double id ;
  double fw ;
  double ro ;
  double fc ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 790
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 790
  if (! tmp) {
#line 791
    return (0);
  }
  {
#line 793
  ir = subtract(cur->ip.IpInReceives, pre->ip.IpInReceives);
#line 794
  or = subtract(cur->ip.IpOutRequests, pre->ip.IpOutRequests);
#line 795
  id = subtract(cur->ip.IpInDelivers, pre->ip.IpInDelivers);
#line 796
  fw = subtract(cur->ip.IpForwarding, pre->ip.IpForwarding);
#line 797
  ro = subtract(cur->ip.IpReasmOKs, pre->ip.IpReasmOKs);
#line 798
  fc = subtract(cur->ip.IpFragCreates, pre->ip.IpFragCreates);
#line 800
  printf((char const   */* __restrict  */)"%8.1lf %8.1lf %11.1lf %9.1lf %9.1lf %11.1lf\n",
         ir / (double )deltasec, or / (double )deltasec, id / (double )deltasec, fw / (double )deltasec,
         ro / (double )deltasec, fc / (double )deltasec);
  }
#line 808
  return (1);
}
}
#line 811 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void IPv4head(struct osrel *osr ) 
{ 


  {
  {
#line 814
  printf((char const   */* __restrict  */)"in: dsc/s hder/s ader/s unkp/s ratim/s rfail/s ot: dsc/s nort/s  _ip_\n");
  }
#line 816
  return;
}
}
#line 818 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int IPv4line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  double ihe ;
  double iae ;
  double iup ;
  double ids ;
  double ods ;
  double onr ;
  double rto ;
  double rfl ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 825
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 825
  if (! tmp) {
#line 826
    return (0);
  }
  {
#line 828
  ids = subtract(cur->ip.IpInDiscards, pre->ip.IpInDiscards);
#line 829
  ihe = subtract(cur->ip.IpInHdrErrors, pre->ip.IpInHdrErrors);
#line 830
  iae = subtract(cur->ip.IpInAddrErrors, pre->ip.IpInAddrErrors);
#line 831
  iup = subtract(cur->ip.IpInUnknownProtos, pre->ip.IpInUnknownProtos);
#line 832
  rto = subtract(cur->ip.IpReasmTimeout, pre->ip.IpReasmTimeout);
#line 833
  rfl = subtract(cur->ip.IpReasmFails, pre->ip.IpReasmFails);
#line 834
  ods = subtract(cur->ip.IpOutDiscards, pre->ip.IpOutDiscards);
#line 835
  onr = subtract(cur->ip.IpOutNoRoutes, pre->ip.IpOutNoRoutes);
#line 837
  printf((char const   */* __restrict  */)"    %5.1lf %6.1lf %6.1lf %6.1lf %7.1lf %7.1lf     %5.1lf %6.1lf\n",
         ids / (double )deltasec, ihe / (double )deltasec, iae / (double )deltasec,
         iup / (double )deltasec, rto / (double )deltasec, rfl / (double )deltasec,
         ods / (double )deltasec, onr / (double )deltasec);
  }
#line 848
  return (1);
}
}
#line 855 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void tcphead(struct osrel *osr ) 
{ 


  {
  {
#line 858
  printf((char const   */* __restrict  */)"insegs/s otsegs/s actopen/s pasopen/s  nowopen  socknow sockmax _tcp_\n");
  }
#line 860
  return;
}
}
#line 862 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int tcpline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  double is ;
  double os ;
  double ao ;
  double po ;
  unsigned long sn ;
  unsigned long sm ;
  struct netstat *cur ;
  struct netstat *pre ;
  struct sockstat *scur ;
  struct sockstat *spre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 867
  sn = 0UL;
#line 867
  sm = 0UL;
#line 871
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 871
  if (! tmp) {
#line 872
    return (0);
  }
  {
#line 874
  tmp___0 = getcset((char *)"sockstat", (void **)(& scur), (void **)(& spre));
  }
#line 874
  if (tmp___0) {
#line 876
    sn = (unsigned long )scur->tcpnow;
#line 877
    sm = (unsigned long )scur->tcpmax;
  }
  {
#line 880
  is = subtract(cur->tcp.TcpInSegs, pre->tcp.TcpInSegs);
#line 881
  os = subtract(cur->tcp.TcpOutSegs, pre->tcp.TcpOutSegs);
#line 882
  ao = subtract(cur->tcp.TcpActiveOpens, pre->tcp.TcpActiveOpens);
#line 883
  po = subtract(cur->tcp.TcpPassiveOpens, pre->tcp.TcpPassiveOpens);
#line 885
  printf((char const   */* __restrict  */)"%8.1lf %8.1lf %9.1lf %9.1lf  %7lld  %7ld %7ld\n",
         is / (double )deltasec, os / (double )deltasec, ao / (double )deltasec, po / (double )deltasec,
         cur->tcp.TcpCurrEstab, sn, sm);
  }
#line 893
  return (1);
}
}
#line 896 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void TCPhead(struct osrel *osr ) 
{ 


  {
  {
#line 899
  printf((char const   */* __restrict  */)"inerr/s  retrans/s  attfail/s  estabreset/s  outreset/s         _tcp_\n");
  }
#line 901
  return;
}
}
#line 903 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int TCPline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  double ie ;
  double rs ;
  double af ;
  double er ;
  double or ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 910
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 910
  if (! tmp) {
#line 911
    return (0);
  }
  {
#line 913
  ie = subtract(cur->tcp.TcpInErrs, pre->tcp.TcpInErrs);
#line 914
  rs = subtract(cur->tcp.TcpRetransSegs, pre->tcp.TcpRetransSegs);
#line 915
  af = subtract(cur->tcp.TcpAttemptFails, pre->tcp.TcpAttemptFails);
#line 916
  er = subtract(cur->tcp.TcpEstabResets, pre->tcp.TcpEstabResets);
#line 917
  or = subtract(cur->tcp.TcpOutRsts, pre->tcp.TcpOutRsts);
#line 919
  printf((char const   */* __restrict  */)"%7.1lf  %9.1lf  %9.1lf  %12.1lf  %10.1lf\n",
         ie / (double )deltasec, rs / (double )deltasec, af / (double )deltasec, er / (double )deltasec,
         or / (double )deltasec);
  }
#line 926
  return (1);
}
}
#line 933 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void udpv4head(struct osrel *osr ) 
{ 


  {
  {
#line 936
  printf((char const   */* __restrict  */)"indgram/s otdgram/s   inerr/s  noport/s         socknow sockmax _udp_\n");
  }
#line 938
  return;
}
}
#line 940 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int udpv4line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
              char *tstamp ) 
{ 
  double id ;
  double ot ;
  double ie ;
  double np ;
  unsigned long sn ;
  unsigned long sm ;
  struct netstat *cur ;
  struct netstat *pre ;
  struct sockstat *scur ;
  struct sockstat *spre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 945
  sn = 0UL;
#line 945
  sm = 0UL;
#line 949
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 949
  if (! tmp) {
#line 950
    return (0);
  }
  {
#line 952
  tmp___0 = getcset((char *)"sockstat", (void **)(& scur), (void **)(& spre));
  }
#line 952
  if (tmp___0) {
#line 954
    sn = (unsigned long )scur->udpnow;
#line 955
    sm = (unsigned long )scur->udpmax;
  }
  {
#line 958
  id = subtract(cur->udp.UdpInDatagrams, pre->udp.UdpInDatagrams);
#line 959
  ot = subtract(cur->udp.UdpOutDatagrams, pre->udp.UdpOutDatagrams);
#line 960
  ie = subtract(cur->udp.UdpInErrors, pre->udp.UdpInErrors);
#line 961
  np = subtract(cur->udp.UdpNoPorts, pre->udp.UdpNoPorts);
#line 964
  printf((char const   */* __restrict  */)"%9.1lf %9.1lf   %7.2lf %9.2lf         %7ld %7ld\n",
         id / (double )deltasec, ot / (double )deltasec, ie / (double )deltasec, np / (double )deltasec,
         sn, sm);
  }
#line 971
  return (1);
}
}
#line 977 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void icmpv4head(struct osrel *osr ) 
{ 


  {
  {
#line 980
  printf((char const   */* __restrict  */)"intot/s outtot/s  inecho/s inerep/s  otecho/s oterep/s         _icmp_\n");
  }
#line 982
  return;
}
}
#line 985 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int icmpv4line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
               char *tstamp ) 
{ 
  double it ;
  double ot ;
  double ie ;
  double oe ;
  double ir ;
  double or ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 992
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 992
  if (! tmp) {
#line 993
    return (0);
  }
  {
#line 995
  it = subtract(cur->icmp.IcmpInMsgs, pre->icmp.IcmpInMsgs);
#line 996
  ot = subtract(cur->icmp.IcmpOutMsgs, pre->icmp.IcmpOutMsgs);
#line 997
  ie = subtract(cur->icmp.IcmpInEchos, pre->icmp.IcmpInEchos);
#line 998
  oe = subtract(cur->icmp.IcmpOutEchos, pre->icmp.IcmpOutEchos);
#line 999
  ir = subtract(cur->icmp.IcmpInEchoReps, pre->icmp.IcmpInEchoReps);
#line 1000
  or = subtract(cur->icmp.IcmpOutEchoReps, pre->icmp.IcmpOutEchoReps);
#line 1002
  printf((char const   */* __restrict  */)"%7.1lf %8.1lf  %8.2lf %8.2lf  %8.2lf %8.2lf\n",
         it / (double )deltasec, ot / (double )deltasec, ie / (double )deltasec, ir / (double )deltasec,
         oe / (double )deltasec, or / (double )deltasec);
  }
#line 1010
  return (1);
}
}
#line 1014 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ICMPv4head(struct osrel *osr ) 
{ 


  {
  {
#line 1017
  printf((char const   */* __restrict  */)"ierr/s isq/s ird/s idu/s ite/s oerr/s osq/s ord/s odu/s ote/s  _icmp_\n");
  }
#line 1019
  return;
}
}
#line 1021 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ICMPv4line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
               char *tstamp ) 
{ 
  double ier ;
  double oer ;
  double idu ;
  double odu ;
  double ite ;
  double ote ;
  double isq ;
  double osq ;
  double ird ;
  double ord ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 1028
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1028
  if (! tmp) {
#line 1029
    return (0);
  }
  {
#line 1031
  ier = subtract(cur->icmp.IcmpInErrors, pre->icmp.IcmpInErrors);
#line 1033
  idu = subtract(cur->icmp.IcmpInDestUnreachs, pre->icmp.IcmpInDestUnreachs);
#line 1035
  ite = subtract(cur->icmp.IcmpInTimeExcds, pre->icmp.IcmpInTimeExcds);
#line 1037
  isq = subtract(cur->icmp.IcmpInSrcQuenchs, pre->icmp.IcmpInSrcQuenchs);
#line 1039
  ird = subtract(cur->icmp.IcmpInRedirects, pre->icmp.IcmpInRedirects);
#line 1041
  oer = subtract(cur->icmp.IcmpOutErrors, pre->icmp.IcmpOutErrors);
#line 1043
  odu = subtract(cur->icmp.IcmpOutDestUnreachs, pre->icmp.IcmpOutDestUnreachs);
#line 1045
  ote = subtract(cur->icmp.IcmpOutTimeExcds, pre->icmp.IcmpOutTimeExcds);
#line 1047
  osq = subtract(cur->icmp.IcmpOutSrcQuenchs, pre->icmp.IcmpOutSrcQuenchs);
#line 1049
  ord = subtract(cur->icmp.IcmpOutRedirects, pre->icmp.IcmpOutRedirects);
#line 1052
  printf((char const   */* __restrict  */)"%6.2lf %5.2lf %5.2lf %5.2lf %5.2lf %6.2lf %5.2lf %5.2lf %5.2lf %5.2lf\n",
         ier / (double )deltasec, isq / (double )deltasec, ird / (double )deltasec,
         idu / (double )deltasec, ite / (double )deltasec, oer / (double )deltasec,
         osq / (double )deltasec, ord / (double )deltasec, odu / (double )deltasec,
         ote / (double )deltasec);
  }
#line 1065
  return (1);
}
}
#line 1072 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ipv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1075
  printf((char const   */* __restrict  */)"inrecv/s outreq/s inmc/s outmc/s indeliv/s reasmok/s fragcre/s  _ip6_\n");
  }
#line 1077
  return;
}
}
#line 1079 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ipv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  double ir ;
  double or ;
  double im ;
  double om ;
  double id ;
  double ro ;
  double fc ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 1086
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1086
  if (! tmp) {
#line 1087
    return (0);
  }
  {
#line 1089
  ir = subtract(cur->ip6.Ip6InReceives, pre->ip6.Ip6InReceives);
#line 1090
  or = subtract(cur->ip6.Ip6OutRequests, pre->ip6.Ip6OutRequests);
#line 1091
  im = subtract(cur->ip6.Ip6InMcastPkts, pre->ip6.Ip6InMcastPkts);
#line 1092
  om = subtract(cur->ip6.Ip6OutMcastPkts, pre->ip6.Ip6OutMcastPkts);
#line 1093
  id = subtract(cur->ip6.Ip6InDelivers, pre->ip6.Ip6InDelivers);
#line 1094
  ro = subtract(cur->ip6.Ip6ReasmOKs, pre->ip6.Ip6ReasmOKs);
#line 1095
  fc = subtract(cur->ip6.Ip6FragCreates, pre->ip6.Ip6FragCreates);
#line 1097
  printf((char const   */* __restrict  */)"%8.1lf %8.1lf %6.1lf %7.1lf %9.1lf %9.1lf %9.1lf\n",
         ir / (double )deltasec, or / (double )deltasec, im / (double )deltasec, om / (double )deltasec,
         id / (double )deltasec, ro / (double )deltasec, fc / (double )deltasec);
  }
#line 1106
  return (1);
}
}
#line 1109 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void IPv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1112
  printf((char const   */* __restrict  */)"in: dsc/s hder/s ader/s unkp/s ratim/s rfail/s ot: dsc/s nort/s _ip6_\n");
  }
#line 1114
  return;
}
}
#line 1116 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int IPv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  double ihe ;
  double iae ;
  double iup ;
  double ids ;
  double ods ;
  double onr ;
  double rto ;
  double rfl ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 1123
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1123
  if (! tmp) {
#line 1124
    return (0);
  }
  {
#line 1126
  ids = subtract(cur->ip6.Ip6InDiscards, pre->ip6.Ip6InDiscards);
#line 1127
  ihe = subtract(cur->ip6.Ip6InHdrErrors, pre->ip6.Ip6InHdrErrors);
#line 1128
  iae = subtract(cur->ip6.Ip6InAddrErrors, pre->ip6.Ip6InAddrErrors);
#line 1129
  iup = subtract(cur->ip6.Ip6InUnknownProtos, pre->ip6.Ip6InUnknownProtos);
#line 1130
  rto = subtract(cur->ip6.Ip6ReasmTimeout, pre->ip6.Ip6ReasmTimeout);
#line 1131
  rfl = subtract(cur->ip6.Ip6ReasmFails, pre->ip6.Ip6ReasmFails);
#line 1132
  ods = subtract(cur->ip6.Ip6OutDiscards, pre->ip6.Ip6OutDiscards);
#line 1133
  onr = subtract(cur->ip6.Ip6OutNoRoutes, pre->ip6.Ip6OutNoRoutes);
#line 1135
  printf((char const   */* __restrict  */)"    %5.1lf %6.1lf %6.1lf %6.1lf %7.1lf %7.1lf     %5.1lf %6.1lf\n",
         ids / (double )deltasec, ihe / (double )deltasec, iae / (double )deltasec,
         iup / (double )deltasec, rto / (double )deltasec, rfl / (double )deltasec,
         ods / (double )deltasec, onr / (double )deltasec);
  }
#line 1146
  return (1);
}
}
#line 1153 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void tcpv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1156
  printf((char const   */* __restrict  */)"                                              socknow sockmax  _tcp6_\n");
  }
#line 1158
  return;
}
}
#line 1160 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int tcpv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
              char *tstamp ) 
{ 
  unsigned long sn ;
  unsigned long sm ;
  struct sockstat *scur ;
  struct sockstat *spre ;
  int tmp ;

  {
  {
#line 1164
  sn = 0UL;
#line 1164
  sm = 0UL;
#line 1167
  tmp = getcset((char *)"sockstat", (void **)(& scur), (void **)(& spre));
  }
#line 1167
  if (tmp) {
#line 1169
    sn = (unsigned long )scur->tcp6now;
#line 1170
    sm = (unsigned long )scur->tcp6max;
  }
  {
#line 1173
  printf((char const   */* __restrict  */)"                                              %7ld %7ld\n",
         sn, sm);
  }
#line 1176
  return (1);
}
}
#line 1182 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void udpv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1185
  printf((char const   */* __restrict  */)"indgram/s otdgram/s   inerr/s  noport/s       socknow sockmax  _udp6_\n");
  }
#line 1187
  return;
}
}
#line 1189 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int udpv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
              char *tstamp ) 
{ 
  double id ;
  double ot ;
  double ie ;
  double np ;
  unsigned long sn ;
  unsigned long sm ;
  struct netstat *cur ;
  struct netstat *pre ;
  struct sockstat *scur ;
  struct sockstat *spre ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1194
  sn = 0UL;
#line 1194
  sm = 0UL;
#line 1198
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1198
  if (! tmp) {
#line 1199
    return (0);
  }
  {
#line 1201
  tmp___0 = getcset((char *)"sockstat", (void **)(& scur), (void **)(& spre));
  }
#line 1201
  if (tmp___0) {
#line 1203
    sn = (unsigned long )scur->udp6now;
#line 1204
    sm = (unsigned long )scur->udp6max;
  }
  {
#line 1207
  id = subtract(cur->udp6.UdpInDatagrams, pre->udp6.UdpInDatagrams);
#line 1208
  ot = subtract(cur->udp6.UdpOutDatagrams, pre->udp6.UdpOutDatagrams);
#line 1209
  ie = subtract(cur->udp6.UdpInErrors, pre->udp6.UdpInErrors);
#line 1210
  np = subtract(cur->udp6.UdpNoPorts, pre->udp6.UdpNoPorts);
#line 1212
  printf((char const   */* __restrict  */)"%9.1lf %9.1lf   %7.2lf %9.2lf       %7ld %7ld\n",
         id / (double )deltasec, ot / (double )deltasec, ie / (double )deltasec, np / (double )deltasec,
         sn, sm);
  }
#line 1219
  return (1);
}
}
#line 1225 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void icmpv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1228
  printf((char const   */* __restrict  */)"intot/s outtot/s inerr/s innsol/s innadv/s otnsol/s otnadv/s  _icmp6_\n");
  }
#line 1230
  return;
}
}
#line 1232 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int icmpv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
               char *tstamp ) 
{ 
  double it ;
  double ot ;
  double ier ;
  double ins ;
  double ina ;
  double ons ;
  double ona ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 1239
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1239
  if (! tmp) {
#line 1240
    return (0);
  }
  {
#line 1242
  it = subtract(cur->icmp6.Icmp6InMsgs, pre->icmp6.Icmp6InMsgs);
#line 1243
  ot = subtract(cur->icmp6.Icmp6OutMsgs, pre->icmp6.Icmp6OutMsgs);
#line 1244
  ier = subtract(cur->icmp6.Icmp6InErrors, pre->icmp6.Icmp6InErrors);
#line 1245
  ins = subtract(cur->icmp6.Icmp6InNeighborSolicits, pre->icmp6.Icmp6InNeighborSolicits);
#line 1247
  ina = subtract(cur->icmp6.Icmp6InNeighborAdvertisements, pre->icmp6.Icmp6InNeighborAdvertisements);
#line 1249
  ons = subtract(cur->icmp6.Icmp6OutNeighborSolicits, pre->icmp6.Icmp6OutNeighborSolicits);
#line 1251
  ona = subtract(cur->icmp6.Icmp6OutNeighborAdvertisements, pre->icmp6.Icmp6OutNeighborAdvertisements);
#line 1254
  printf((char const   */* __restrict  */)"%7.1lf %8.1lf %7.2lf %8.2lf %8.2lf %8.2lf %8.2lf\n",
         it / (double )deltasec, ot / (double )deltasec, ier / (double )deltasec,
         ins / (double )deltasec, ina / (double )deltasec, ons / (double )deltasec,
         ona / (double )deltasec);
  }
#line 1263
  return (1);
}
}
#line 1267 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void ICMPv6head(struct osrel *osr ) 
{ 


  {
  {
#line 1270
  printf((char const   */* __restrict  */)"iecho/s ierep/s oerep/s idu/s odu/s ird/s ord/s ite/s ote/s   _icmp6_\n");
  }
#line 1272
  return;
}
}
#line 1274 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int ICMPv6line(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
               char *tstamp ) 
{ 
  double iec ;
  double ier ;
  double oer ;
  double idu ;
  double odu ;
  double ird ;
  double ord ;
  double ite ;
  double ote ;
  struct netstat *cur ;
  struct netstat *pre ;
  int tmp ;

  {
  {
#line 1281
  tmp = getcset((char *)"netstat", (void **)(& cur), (void **)(& pre));
  }
#line 1281
  if (! tmp) {
#line 1282
    return (0);
  }
  {
#line 1284
  iec = subtract(cur->icmp6.Icmp6InEchos, pre->icmp6.Icmp6InEchos);
#line 1286
  ier = subtract(cur->icmp6.Icmp6InEchoReplies, pre->icmp6.Icmp6InEchoReplies);
#line 1288
  oer = subtract(cur->icmp6.Icmp6OutEchoReplies, pre->icmp6.Icmp6OutEchoReplies);
#line 1290
  idu = subtract(cur->icmp6.Icmp6InDestUnreachs, pre->icmp6.Icmp6InDestUnreachs);
#line 1292
  odu = subtract(cur->icmp6.Icmp6OutDestUnreachs, pre->icmp6.Icmp6OutDestUnreachs);
#line 1294
  ird = subtract(cur->icmp6.Icmp6InRedirects, pre->icmp6.Icmp6InRedirects);
#line 1296
  ord = subtract(cur->icmp6.Icmp6OutRedirects, pre->icmp6.Icmp6OutRedirects);
#line 1298
  ite = subtract(cur->icmp6.Icmp6InTimeExcds, pre->icmp6.Icmp6InTimeExcds);
#line 1300
  ote = subtract(cur->icmp6.Icmp6OutTimeExcds, pre->icmp6.Icmp6OutTimeExcds);
#line 1303
  printf((char const   */* __restrict  */)"%7.2lf %7.2lf %7.2lf %5.2lf %5.2lf %5.2lf %5.2lf %5.2lf %5.2lf\n",
         iec / (double )deltasec, ier / (double )deltasec, oer / (double )deltasec,
         idu / (double )deltasec, odu / (double )deltasec, ird / (double )deltasec,
         ord / (double )deltasec, ite / (double )deltasec, ote / (double )deltasec);
  }
#line 1315
  return (1);
}
}
#line 1323 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void dkhead(struct osrel *osr ) 
{ 


  {
  {
#line 1326
  printf((char const   */* __restrict  */)"device            read/s rdKb/s   write/s wrKb/s        rdwr/s _disk_\n");
  }
#line 1328
  return;
}
}
#line 1330 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int dkline_26(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
              char *tstamp ) 
{ 
  register int i ;
  register int nr ;
  register int lines ;
  double rd ;
  double wr ;
  double rs ;
  double ws ;
  char lastchar ;
  unsigned long deltams ;
  struct dkstat *cur ;
  struct dkstat *pre ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1337
  deltams = (unsigned long )((deltatic * 1000L) / hz);
#line 1341
  nr = getcset((char *)"partstat", (void **)(& cur), (void **)(& pre));
  }
#line 1341
  if (nr == 0) {
#line 1342
    return (0);
  }
#line 1344
  i = 0;
#line 1344
  lines = 0;
  {
#line 1344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1344
    if (! (i < nr)) {
#line 1344
      goto while_break;
    }
#line 1346
    if (cur->readblocks == pre->readblocks) {
#line 1346
      if (cur->writblocks == pre->writblocks) {
#line 1348
        goto __Cont;
      }
    }
#line 1353
    if ((int )cur->major != (int )pre->major) {
#line 1353
      goto _L;
    } else
#line 1353
    if ((int )cur->minor != (int )pre->minor) {
      _L: /* CIL Label */ 
#line 1353
      if ((int )pre->major != 0) {
#line 1355
        goto __Cont;
      } else
#line 1353
      if ((int )pre->minor != 0) {
#line 1355
        goto __Cont;
      }
    }
    {
#line 1357
    rd = subtract(cur->readblocks, pre->readblocks);
#line 1358
    wr = subtract(cur->writblocks, pre->writblocks);
#line 1359
    rs = subtract(cur->readsectors, pre->readsectors);
#line 1360
    ws = subtract(cur->writsectors, pre->writsectors);
#line 1362
    tmp = strlen((char const   *)(cur->name));
#line 1362
    lastchar = cur->name[tmp - 1UL];
#line 1367
    tmp___0 = __ctype_b_loc();
    }
#line 1367
    if (! ((int const   )*(*tmp___0 + (int )lastchar) & 2048)) {
#line 1369
      if (lines > 0) {
        {
#line 1370
        printf((char const   */* __restrict  */)"%s  ", tstamp);
        }
      }
      {
#line 1372
      printf((char const   */* __restrict  */)"disk%03d-%03d   %10.2lf %6.2lf   %7.2lf %6.2lf    %10.2lf\n",
             (int )cur->major, (int )cur->minor, (rd * 1000.0) / (double )deltams,
             ((rs * 1000.0) / (double )2) / (double )deltams, (wr * 1000.0) / (double )deltams,
             ((ws * 1000.0) / (double )2) / (double )deltams, ((rd + wr) * 1000.0) / (double )deltams);
#line 1380
      lines ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 1344
    i ++;
#line 1344
    cur ++;
#line 1344
    pre ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1384
  if (lines == 0) {
    {
#line 1385
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1387
  return (1);
}
}
#line 1391 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int dkline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
           char *tstamp ) 
{ 
  register int i ;
  register int j ;
  register int lines ;
  double rw ;
  double rn ;
  double rb ;
  double wn ;
  double wb ;
  struct genstat *cur ;
  struct genstat *pre ;
  int tmp ;
  int tmp___0 ;

  {
#line 1402
  if (osr->rel >= 2) {
#line 1402
    if (osr->vers >= 6) {
      {
#line 1404
      tmp = dkline_26(deltasec, deltatic, hz, ncpu, osr, tstamp);
      }
#line 1404
      return (tmp);
    }
  }
  {
#line 1407
  tmp___0 = getcset((char *)"genstat", (void **)(& cur), (void **)(& pre));
  }
#line 1407
  if (! tmp___0) {
#line 1408
    return (0);
  }
#line 1410
  lines = 0;
#line 1410
  j = lines;
#line 1410
  i = j;
  {
#line 1410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1410
    if (i < 64) {
#line 1410
      if (! cur->dk_drive_maj[i]) {
#line 1410
        if (! cur->dk_drive_min[i]) {
#line 1410
          goto while_break;
        }
      }
    } else {
#line 1410
      goto while_break;
    }
#line 1413
    if (cur->dk_drive_tot[i] == 0LL) {
#line 1414
      goto __Cont;
    }
#line 1423
    if (cur->dk_drive_maj[i] != pre->dk_drive_maj[j]) {
#line 1423
      goto _L;
    } else
#line 1423
    if (cur->dk_drive_min[i] != pre->dk_drive_min[j]) {
      _L: /* CIL Label */ 
#line 1427
      j = 0;
      {
#line 1427
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1427
        if (! (j < 64)) {
#line 1427
          goto while_break___0;
        }
#line 1429
        if (cur->dk_drive_maj[i] == pre->dk_drive_maj[j]) {
#line 1429
          if (cur->dk_drive_min[i] == pre->dk_drive_min[j]) {
#line 1433
            goto while_break___0;
          }
        }
#line 1427
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1437
    rw = subtract(cur->dk_drive_tot[i], pre->dk_drive_tot[j]);
    }
#line 1439
    if (rw == 0.0) {
#line 1440
      goto __Cont;
    }
    {
#line 1442
    rn = subtract(cur->dk_drive_rio[i], pre->dk_drive_rio[j]);
#line 1443
    wn = subtract(cur->dk_drive_wio[i], pre->dk_drive_wio[j]);
#line 1444
    rb = subtract(cur->dk_drive_rblk[i], pre->dk_drive_rblk[j]);
#line 1445
    wb = subtract(cur->dk_drive_wblk[i], pre->dk_drive_wblk[j]);
    }
#line 1447
    if (lines > 0) {
      {
#line 1448
      printf((char const   */* __restrict  */)"%s  ", tstamp);
      }
    }
    {
#line 1450
    printf((char const   */* __restrict  */)"disk%03lld-%03lld   %10.2lf %6.2lf   %7.2lf %6.2lf    %10.2lf\n",
           cur->dk_drive_maj[i], cur->dk_drive_min[i], rn / (double )deltasec, (rb / (double )deltasec) / 2.0,
           wn / (double )deltasec, (wb / (double )deltasec) / 2.0, rw / (double )deltasec);
#line 1459
    lines ++;
    }
    __Cont: /* CIL Label */ 
#line 1410
    i ++;
#line 1410
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1462
  if (lines == 0) {
    {
#line 1463
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1465
  return (1);
}
}
#line 1471 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void parthead(struct osrel *osr ) 
{ 


  {
  {
#line 1474
  printf((char const   */* __restrict  */)"partition   busy  read/s Kbyt/r   write/s Kbyt/w  avque avserv _part_\n");
  }
#line 1476
  return;
}
}
#line 1478 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int partline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  register int i ;
  register int nr ;
  register int lines ;
  double busy ;
  double avq ;
  double avs ;
  double avkr ;
  double avkw ;
  double rd ;
  double wr ;
  double rs ;
  double ws ;
  double io_msecs ;
  char lastchar ;
  char dskname[32] ;
  unsigned long deltams ;
  struct dkstat *cur ;
  struct dkstat *pre ;
  size_t tmp ;
  double tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 1485
  deltams = (unsigned long )((deltatic * 1000L) / hz);
#line 1489
  nr = getcset((char *)"partstat", (void **)(& cur), (void **)(& pre));
  }
#line 1489
  if (nr == 0) {
#line 1490
    return (0);
  }
#line 1492
  i = 0;
#line 1492
  lines = 0;
  {
#line 1492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1492
    if (! (i < nr)) {
#line 1492
      goto while_break;
    }
#line 1494
    if (cur->readblocks == pre->readblocks) {
#line 1494
      if (cur->writblocks == pre->writblocks) {
#line 1496
        goto __Cont;
      }
    }
#line 1501
    if ((int )cur->major != (int )pre->major) {
#line 1501
      goto _L;
    } else
#line 1501
    if ((int )cur->minor != (int )pre->minor) {
      _L: /* CIL Label */ 
#line 1501
      if ((int )pre->major != 0) {
#line 1503
        goto __Cont;
      } else
#line 1501
      if ((int )pre->minor != 0) {
#line 1503
        goto __Cont;
      }
    }
#line 1508
    if (lines > 0) {
      {
#line 1509
      printf((char const   */* __restrict  */)"%s  ", tstamp);
      }
    }
    {
#line 1511
    rd = subtract(cur->readblocks, pre->readblocks);
#line 1512
    wr = subtract(cur->writblocks, pre->writblocks);
#line 1513
    rs = subtract(cur->readsectors, pre->readsectors);
#line 1514
    ws = subtract(cur->writsectors, pre->writsectors);
    }
#line 1516
    if (rd > (double )0) {
#line 1517
      avkr = (rs / rd) / 2.0;
    } else {
#line 1519
      avkr = 0.0;
    }
#line 1521
    if (wr > (double )0) {
#line 1522
      avkw = (ws / wr) / 2.0;
    } else {
#line 1524
      avkw = 0.0;
    }
    {
#line 1526
    tmp = strlen((char const   *)(cur->name));
#line 1526
    lastchar = cur->name[tmp - 1UL];
#line 1531
    tmp___1 = __ctype_b_loc();
    }
#line 1531
    if ((int const   )*(*tmp___1 + (int )lastchar) & 2048) {
      {
#line 1564
      printf((char const   */* __restrict  */)"%-11s      %7.2lf %6.1lf %9.2lf %6.1lf\n",
             cur->name, (rd * 1000.0) / (double )deltams, avkr, (wr * 1000.0) / (double )deltams,
             avkw);
      }
    } else {
      {
#line 1533
      io_msecs = subtract(cur->rdwr_msecs, pre->rdwr_msecs);
#line 1535
      busy = (io_msecs * 100.0) / (double )deltams;
      }
#line 1535
      if (busy > 100.0) {
#line 1536
        busy = 100.0;
      }
#line 1538
      avs = io_msecs / (rd + wr);
#line 1540
      if (io_msecs > (double )0) {
        {
#line 1541
        tmp___0 = subtract(cur->avq, pre->avq);
#line 1541
        avq = tmp___0 / io_msecs;
        }
      } else {
#line 1543
        avq = 0.0;
      }
      {
#line 1545
      sprintf((char */* __restrict  */)(dskname), (char const   */* __restrict  */)"%s (%d-%d)",
              cur->name, (int )cur->major, (int )cur->minor);
#line 1548
      printf((char const   */* __restrict  */)"%-11s %3.0lf%% %7.2lf %6.1lf %9.2lf %6.1lf %6.2lf %6.2lf ms\n",
             dskname, busy, (rd * 1000.0) / (double )deltams, avkr, (wr * 1000.0) / (double )deltams,
             avkw, avq, avs);
      }
    }
#line 1572
    lines ++;
    __Cont: /* CIL Label */ 
#line 1492
    i ++;
#line 1492
    cur ++;
#line 1492
    pre ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1575
  if (lines == 0) {
    {
#line 1576
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1578
  return (1);
}
}
#line 1584 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void nfshead(struct osrel *osr ) 
{ 


  {
  {
#line 1587
  printf((char const   */* __restrict  */)"svrpc/s clrpc/s   sudp/s stcp/s stcon/s   cudp/s ctcp/s ctcon/s _nfs_\n");
  }
#line 1589
  return;
}
}
#line 1591 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int nfsline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  struct nfsstat *cur ;
  struct nfsstat *pre ;
  double sr ;
  double sn ;
  double su ;
  double st ;
  double sc ;
  double cr ;
  double cn ;
  double cu ;
  double ct ;
  double cc ;
  int tmp ;

  {
  {
#line 1598
  tmp = getcset((char *)"nfsstat", (void **)(& cur), (void **)(& pre));
  }
#line 1598
  if (! tmp) {
#line 1599
    return (0);
  }
  {
#line 1601
  sr = subtract(cur->sv_rpccnt, pre->sv_rpccnt);
#line 1602
  sn = subtract(cur->sv_netcnt, pre->sv_netcnt);
#line 1603
  su = subtract(cur->sv_netudpcnt, pre->sv_netudpcnt);
#line 1604
  st = subtract(cur->sv_nettcpcnt, pre->sv_nettcpcnt);
#line 1605
  sc = subtract(cur->sv_nettcpconn, pre->sv_nettcpconn);
#line 1606
  cr = subtract(cur->cl_rpccnt, pre->cl_rpccnt);
#line 1607
  cn = subtract(cur->cl_netcnt, pre->cl_netcnt);
#line 1608
  cu = subtract(cur->cl_netudpcnt, pre->cl_netudpcnt);
#line 1609
  ct = subtract(cur->cl_nettcpcnt, pre->cl_nettcpcnt);
#line 1610
  cc = subtract(cur->cl_nettcpconn, pre->cl_nettcpconn);
#line 1612
  printf((char const   */* __restrict  */)"%7.2lf %7.2lf %8.2lf %6.2lf %7.3lf %8.2lf %6.2lf %7.3lf\n",
         sr / (double )deltasec, cr / (double )deltasec, su / (double )deltasec, st / (double )deltasec,
         sc / (double )deltasec, cu / (double )deltasec, ct / (double )deltasec, cc / (double )deltasec);
  }
#line 1622
  return (1);
}
}
#line 1628 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void NFShead(struct osrel *osr ) 
{ 


  {
  {
#line 1631
  printf((char const   */* __restrict  */)"svbadfmt/s svbadauth/s svbadclnt/s  clretrans/s clauthrefresh/s _nfs_\n");
  }
#line 1633
  return;
}
}
#line 1635 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int NFSline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  struct nfsstat *cur ;
  struct nfsstat *pre ;
  double sf ;
  double sa ;
  double sc ;
  double cr ;
  double ca ;
  int tmp ;

  {
  {
#line 1642
  tmp = getcset((char *)"nfsstat", (void **)(& cur), (void **)(& pre));
  }
#line 1642
  if (! tmp) {
#line 1643
    return (0);
  }
  {
#line 1645
  sf = subtract(cur->sv_rpcbadfmt, pre->sv_rpcbadfmt);
#line 1646
  sa = subtract(cur->sv_rpcbadauth, pre->sv_rpcbadauth);
#line 1647
  sc = subtract(cur->sv_rpcbadclnt, pre->sv_rpcbadclnt);
#line 1648
  cr = subtract(cur->cl_rpcretrans, pre->cl_rpcretrans);
#line 1649
  ca = subtract(cur->cl_rpcauthrefresh, pre->cl_rpcauthrefresh);
#line 1651
  printf((char const   */* __restrict  */)"%10.3lf %11.3lf %11.3lf  %11.3lf %15.3lf\n",
         sf / (double )deltasec, sa / (double )deltasec, sc / (double )deltasec, cr / (double )deltasec,
         ca / (double )deltasec);
  }
#line 1658
  return (1);
}
}
#line 1664 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void nfsshead(struct osrel *osr ) 
{ 


  {
  {
#line 1667
  printf((char const   */* __restrict  */)"rchit/s rcmiss/s %%hit fhstal/s iord/s iowr/s racach thr tlast/s _nfs_\n");
  }
#line 1669
  return;
}
}
#line 1671 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int nfssline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
             char *tstamp ) 
{ 
  struct nfsstat *cur ;
  struct nfsstat *pre ;
  double rch ;
  double rcm ;
  double rcn ;
  double fst ;
  double flu ;
  double fan ;
  double fnd ;
  double fnn ;
  double ior ;
  double iow ;
  double thl ;
  double perc ;
  int tmp ;

  {
  {
#line 1679
  tmp = getcset((char *)"nfsstat", (void **)(& cur), (void **)(& pre));
  }
#line 1679
  if (! tmp) {
#line 1680
    return (0);
  }
  {
#line 1682
  rch = subtract(cur->sv_rchits, pre->sv_rchits);
#line 1683
  rcm = subtract(cur->sv_rcmisses, pre->sv_rcmisses);
#line 1684
  rcn = subtract(cur->sv_rcnocache, pre->sv_rcnocache);
#line 1685
  fst = subtract(cur->sv_fhstale, pre->sv_fhstale);
#line 1686
  flu = subtract(cur->sv_fhlookup, pre->sv_fhlookup);
#line 1687
  fan = subtract(cur->sv_fhanon, pre->sv_fhanon);
#line 1688
  fnd = subtract(cur->sv_fhnocachedir, pre->sv_fhnocachedir);
#line 1689
  fnn = subtract(cur->sv_fhnocachenondir, pre->sv_fhnocachenondir);
#line 1690
  ior = subtract(cur->sv_ioread, pre->sv_ioread);
#line 1691
  iow = subtract(cur->sv_iowrite, pre->sv_iowrite);
#line 1692
  thl = subtract(cur->sv_thlastcnt, pre->sv_thlastcnt);
  }
#line 1694
  if (rch + rcm > (double )0) {
#line 1695
    perc = (rch * 100.0) / (rch + rcm);
  } else {
#line 1697
    perc = 0.0;
  }
  {
#line 1699
  printf((char const   */* __restrict  */)"%7.2lf %8.2lf %4.0lf %8.3lf %5.1lfK %5.1lfK %5lldK %3lld %7.3lf\n",
         rch / (double )deltasec, rcm / (double )deltasec, perc, fst / (double )deltasec,
         (ior / (double )deltasec) / 1024.0, (iow / (double )deltasec) / 1024.0, cur->sv_rasize / 1024LL,
         cur->sv_thcount, thl / (double )deltasec);
  }
#line 1711
  return (1);
}
}
#line 1718 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
void rpchead(struct osrel *osr ) 
{ 


  {
  {
#line 1721
  printf((char const   */* __restrict  */)"gat sat lku rln  rd wrc  wr cre  rm rnm lnk sln mkd rmd rdd fst _rpc_\n");
  }
#line 1723
  return;
}
}
#line 1725 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int rpcline(time_t deltasec , time_t deltatic , time_t hz , int ncpu , struct osrel *osr ,
            char *tstamp ) 
{ 
  register int lines ;
  struct nfsstat *cur ;
  struct nfsstat *pre ;
  double stot ;
  double ctot ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1729
  lines = 0;
#line 1733
  tmp = getcset((char *)"nfsstat", (void **)(& cur), (void **)(& pre));
  }
#line 1733
  if (! tmp) {
#line 1734
    return (0);
  }
  {
#line 1736
  stot = subtract(cur->sv_rpccnt, pre->sv_rpccnt);
#line 1737
  ctot = subtract(cur->cl_rpccnt, pre->cl_rpccnt);
  }
#line 1742
  if (stot > 0.0) {
    {
#line 1744
    tmp___0 = prirpcs(cur->sv_proc2, pre->sv_proc2, stot, (char *)"%srv2", lines,
                      tstamp);
#line 1744
    lines += tmp___0;
#line 1747
    tmp___1 = prirpcs(cur->sv_proc3, pre->sv_proc3, stot, (char *)"%srv3", lines,
                      tstamp);
#line 1747
    lines += tmp___1;
    }
  }
#line 1754
  if (ctot > 0.0) {
    {
#line 1756
    tmp___2 = prirpcs(cur->cl_proc2, pre->cl_proc2, ctot, (char *)"%cln2", lines,
                      tstamp);
#line 1756
    lines += tmp___2;
#line 1759
    tmp___3 = prirpcs(cur->cl_proc3, pre->cl_proc3, ctot, (char *)"%cln3", lines,
                      tstamp);
#line 1759
    lines += tmp___3;
    }
  }
#line 1763
  if (lines == 0) {
    {
#line 1764
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1766
  return (1);
}
}
#line 1792 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int prirpcs(count_t *rpccur , count_t *rpcpre , double tot , char *txt , int lines ,
            char *tstamp ) 
{ 
  register int i ;
  double sub ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;

  {
#line 1799
  i = 0;
#line 1799
  sub = 0.0;
  {
#line 1799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1799
    if (! (i < 18)) {
#line 1799
      goto while_break;
    }
    {
#line 1800
    tmp = subtract(*(rpccur + i), *(rpcpre + i));
#line 1800
    sub += tmp;
#line 1799
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1802
  if (sub == 0.0) {
#line 1803
    return (0);
  }
#line 1805
  if (lines) {
    {
#line 1806
    printf((char const   */* __restrict  */)"%s  ", tstamp);
    }
  }
  {
#line 1808
  tmp___0 = subtract(*(rpccur + 17), *(rpcpre + 17));
#line 1808
  tmp___1 = subtract(*(rpccur + 16), *(rpcpre + 16));
#line 1808
  tmp___2 = subtract(*(rpccur + 15), *(rpcpre + 15));
#line 1808
  tmp___3 = subtract(*(rpccur + 14), *(rpcpre + 14));
#line 1808
  tmp___4 = subtract(*(rpccur + 13), *(rpcpre + 13));
#line 1808
  tmp___5 = subtract(*(rpccur + 12), *(rpcpre + 12));
#line 1808
  tmp___6 = subtract(*(rpccur + 11), *(rpcpre + 11));
#line 1808
  tmp___7 = subtract(*(rpccur + 10), *(rpcpre + 10));
#line 1808
  tmp___8 = subtract(*(rpccur + 9), *(rpcpre + 9));
#line 1808
  tmp___9 = subtract(*(rpccur + 8), *(rpcpre + 8));
#line 1808
  tmp___10 = subtract(*(rpccur + 7), *(rpcpre + 7));
#line 1808
  tmp___11 = subtract(*(rpccur + 6), *(rpcpre + 6));
#line 1808
  tmp___12 = subtract(*(rpccur + 5), *(rpcpre + 5));
#line 1808
  tmp___13 = subtract(*(rpccur + 4), *(rpcpre + 4));
#line 1808
  tmp___14 = subtract(*(rpccur + 2), *(rpcpre + 2));
#line 1808
  tmp___15 = subtract(*(rpccur + 1), *(rpcpre + 1));
#line 1808
  printf((char const   */* __restrict  */)"%3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %3.0lf %s\n",
         (tmp___15 * 100.0) / sub, (tmp___14 * 100.0) / sub, (tmp___13 * 100.0) / sub,
         (tmp___12 * 100.0) / sub, (tmp___11 * 100.0) / sub, (tmp___10 * 100.0) / sub,
         (tmp___9 * 100.0) / sub, (tmp___8 * 100.0) / sub, (tmp___7 * 100.0) / sub,
         (tmp___6 * 100.0) / sub, (tmp___5 * 100.0) / sub, (tmp___4 * 100.0) / sub,
         (tmp___3 * 100.0) / sub, (tmp___2 * 100.0) / sub, (tmp___1 * 100.0) / sub,
         (tmp___0 * 100.0) / sub, txt);
  }
#line 1828
  return (1);
}
}
#line 1989 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
double subtract(count_t newval , count_t oldval ) 
{ 


  {
#line 1992
  if (newval >= oldval) {
#line 1993
    return ((double )newval - (double )oldval);
  } else {
#line 1995
    return ((((double )0xffffffffffffffffUL + 1.0) + (double )newval) - (double )oldval);
  }
}
}
#line 2029 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
struct funcdef funcdef[28]  = 
#line 2029
  {      {(char)0, (char )'u', (void (*)())(& cpuhead), (int (*)())(& cpuline), (char *)"cpu"}, 
        {(char)0,
      (char )'P', (void (*)())(& prchead), (int (*)())(& prcline), (char *)"process load"}, 
        {(char)0,
      (char )'d', (void (*)())(& dkhead), (int (*)())(& dkline), (char *)"disk"}, 
        {(char)0, (char )'D', (void (*)())(& parthead), (int (*)())(& partline), (char *)"disk-partition"}, 
        {(char)0,
      (char )'r', (void (*)())(& memhead), (int (*)())(& memline), (char *)"memory & swap"}, 
        {(char)0,
      (char )'p', (void (*)())(& pagehead), (int (*)())(& pageline), (char *)"paging & swapping"}, 
        {(char)0,
      (char )'I', (void (*)())(& inthead), (int (*)())(& intline), (char *)"interrupts"}, 
        {(char)0,
      (char )'v', (void (*)())(& tabhead), (int (*)())(& tabline), (char *)"kernel-resources"}, 
        {(char)0,
      (char )'y', (void (*)())(& ttyhead), (int (*)())(& ttyline), (char *)"tty activity"}, 
        {(char)0,
      (char )'l', (void (*)())(& ifhead), (int (*)())(& ifline), (char *)"net-interf (general)"}, 
        {(char)0,
      (char )'L', (void (*)())(& IFhead), (int (*)())(& IFline), (char *)"net-interf (errors)"}, 
        {(char)0,
      (char )'w', (void (*)())(& ipv4head), (int (*)())(& ipv4line), (char *)"ip   v4    (general)"}, 
        {(char)0,
      (char )'W', (void (*)())(& IPv4head), (int (*)())(& IPv4line), (char *)"ip   v4    (errors)"}, 
        {(char)0,
      (char )'t', (void (*)())(& tcphead), (int (*)())(& tcpline), (char *)"tcp  v4    (general)"}, 
        {(char)0,
      (char )'T', (void (*)())(& TCPhead), (int (*)())(& TCPline), (char *)"tcp  v4    (errors)"}, 
        {(char)0,
      (char )'U', (void (*)())(& udpv4head), (int (*)())(& udpv4line), (char *)"udp  v4"}, 
        {(char)0,
      (char )'m', (void (*)())(& icmpv4head), (int (*)())(& icmpv4line), (char *)"icmp v4    (general)"}, 
        {(char)0,
      (char )'M', (void (*)())(& ICMPv4head), (int (*)())(& ICMPv4line), (char *)"icmp v4    (per type)"}, 
        {(char)0,
      (char )'g', (void (*)())(& ipv6head), (int (*)())(& ipv6line), (char *)"ip   v6    (general)"}, 
        {(char)0,
      (char )'G', (void (*)())(& IPv6head), (int (*)())(& IPv6line), (char *)"ip   v6    (errors)"}, 
        {(char)0,
      (char )'j', (void (*)())(& tcpv6head), (int (*)())(& tcpv6line), (char *)"tcp  v6    (general)"}, 
        {(char)0,
      (char )'h', (void (*)())(& udpv6head), (int (*)())(& udpv6line), (char *)"udp  v6"}, 
        {(char)0,
      (char )'k', (void (*)())(& icmpv6head), (int (*)())(& icmpv6line), (char *)"icmp v6    (general)"}, 
        {(char)0,
      (char )'K', (void (*)())(& ICMPv6head), (int (*)())(& ICMPv6line), (char *)"icmp v6    (per type)"}, 
        {(char)0,
      (char )'N', (void (*)())(& nfshead), (int (*)())(& nfsline), (char *)"nfs        (general)"}, 
        {(char)0,
      (char )'E', (void (*)())(& NFShead), (int (*)())(& NFSline), (char *)"nfs        (errors)"}, 
        {(char)0,
      (char )'V', (void (*)())(& nfsshead), (int (*)())(& nfssline), (char *)"nfs        (server)"}, 
        {(char)0,
      (char )'R', (void (*)())(& rpchead), (int (*)())(& rpcline), (char *)"nfs-rpc    (%calls)"}};
#line 2066 "/home/june/collector/temp/atsar-1.7/atsar/funcdef.c"
int funcnt  =    (int )(sizeof(funcdef) / sizeof(struct funcdef ));
