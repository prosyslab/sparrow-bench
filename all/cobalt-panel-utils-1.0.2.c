/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 43 "../lcd.h"
struct lcd_display {
   unsigned long buttons ;
   int size1 ;
   int size2 ;
   unsigned char line1[40] ;
   unsigned char line2[40] ;
   unsigned char cursor_address ;
   unsigned char character ;
   unsigned char leds ;
   unsigned char *RomImage ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcd_private.h"
struct lcd_private {
   struct lcd_display display ;
   int fd ;
   int button_debounce ;
   int button_sense ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef int __itimer_which_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 47 "../lcdutils.h"
void *lcd_open(int const   flags ) ;
#line 48
int lcd_write(void *lcd_private___0 , char const   *line1 , char const   *line2 ) ;
#line 50
void lcd_blink_invalid(void *lcd_private___0 ) ;
#line 51
void lcd_spin(void *lcd , char const   *line1 , char const   *line2 ) ;
#line 52
void lcd_close(void *lcd_private___0 ) ;
#line 53
int lcd_setleds(void *lcd_private___0 , int const   pattern ) ;
#line 54
void lcd_reset(void *lcd_private___0 ) ;
#line 55
void lcd_set(void *lcd_private___0 , int const   value ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcd_private.h"
struct lcd_private lcd_private  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void lcd_set(void *lcd_private___0 , int const   value ) 
{ 
  struct lcd_private *lcd ;

  {
#line 46
  lcd = (struct lcd_private *)lcd_private___0;
#line 48
  if (! lcd) {
#line 49
    return;
  } else
#line 48
  if (lcd->fd < 0) {
#line 49
    return;
  }
  {
#line 51
  ioctl(lcd->fd, (unsigned long )value);
  }
#line 52
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void lcd_blink_invalid(void *lcd_private___0 ) 
{ 
  struct lcd_private *save ;
  struct lcd_display lcd ;
  struct lcd_display lcdblank ;
  struct timeval tv ;
  struct timeval savetv ;

  {
#line 57
  save = (struct lcd_private *)lcd_private___0;
#line 61
  if (! save) {
#line 62
    return;
  } else
#line 61
  if (save->fd < 0) {
#line 62
    return;
  }
  {
#line 64
  ioctl(save->fd, 12UL, & lcd);
#line 67
  memcpy((void */* __restrict  */)(& lcdblank), (void const   */* __restrict  */)(& lcd),
         sizeof(lcd));
#line 68
  memset((void *)(lcdblank.line2), ' ', sizeof(lcdblank.line2));
#line 69
  lcd.size2 = 16;
#line 69
  lcd.size1 = lcd.size2;
#line 70
  lcdblank.size2 = 16;
#line 70
  lcdblank.size1 = lcdblank.size2;
#line 72
  ioctl(save->fd, 50UL, & save->display);
#line 73
  save->display.buttons &= 255UL;
#line 75
  memset((void *)(& savetv), 0, sizeof(savetv));
#line 76
  savetv.tv_usec = (__suseconds_t )300000;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    if (! (save->display.buttons == 63UL)) {
#line 77
      if (! (save->display.buttons == 254UL)) {
#line 77
        goto while_break;
      }
    }
    {
#line 78
    ioctl(save->fd, 13UL, & lcdblank);
#line 79
    memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& savetv),
           sizeof(tv));
#line 80
    select(1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 82
    ioctl(save->fd, 13UL, & lcd);
#line 83
    memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& savetv),
           sizeof(tv));
#line 84
    select(1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 86
    ioctl(save->fd, 50UL, & save->display);
#line 87
    save->display.buttons &= 255UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  ioctl(save->fd, 13UL, & lcd);
  }
#line 90
  return;
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void lcd_spin(void *lcd , char const   *line1 , char const   *line2 ) 
{ 
  char star[16] ;
  struct timeval tv ;
  struct timeval save ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 97
  memset((void *)(star), ' ', sizeof(star));
  }
#line 98
  if (line2) {
    {
#line 99
    tmp___2 = strlen(line2);
    }
#line 99
    if (tmp___2 < sizeof(star)) {
      {
#line 99
      tmp___0 = strlen(line2);
#line 99
      tmp___1 = tmp___0;
      }
    } else {
#line 99
      tmp___1 = sizeof(star);
    }
    {
#line 99
    memcpy((void */* __restrict  */)(star), (void const   */* __restrict  */)line2,
           tmp___1);
    }
  }
  {
#line 101
  memset((void *)(& save), 0, sizeof(save));
#line 102
  save.tv_usec = (__suseconds_t )500000;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    star[15] = (char )'*';
#line 105
    lcd_write(lcd, line1, (char const   *)(star));
#line 106
    memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& save),
           sizeof(tv));
#line 107
    select(1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 109
    star[15] = (char )' ';
#line 110
    lcd_write(lcd, line1, (char const   *)(star));
#line 111
    memcpy((void */* __restrict  */)(& tv), (void const   */* __restrict  */)(& save),
           sizeof(tv));
#line 112
    select(1, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
           (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void *lcd_open(int const   flags ) 
{ 
  struct lcd_private *lcd ;
  int lcdtype ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 118
  lcdtype = 0;
#line 120
  tmp = calloc((size_t )1, sizeof(struct lcd_private ));
#line 120
  lcd = (struct lcd_private *)tmp;
  }
#line 120
  if ((unsigned long )lcd == (unsigned long )((void *)0)) {
#line 121
    return ((void *)0);
  }
  {
#line 123
  tmp___0 = open("/dev/lcd", (int )flags);
#line 123
  lcd->fd = tmp___0;
  }
#line 123
  if (tmp___0 < 0) {
    {
#line 124
    free((void *)lcd);
    }
#line 125
    return ((void *)0);
  }
  {
#line 128
  lcd->button_debounce = 5000;
#line 129
  lcd->button_sense = 160000;
#line 130
  tmp___1 = ioctl(lcd->fd, 21UL, & lcdtype);
  }
#line 130
  if (tmp___1 == 0) {
#line 130
    if (lcdtype == 3) {
#line 131
      lcd->button_debounce = 3;
#line 132
      lcd->button_sense = 10;
    }
  }
#line 134
  return ((void *)lcd);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void lcd_close(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 138
  lcd = (struct lcd_private *)lcd_private___0;
#line 140
  if (! lcd) {
#line 141
    return;
  }
#line 143
  if (lcd->fd < 0) {
    {
#line 144
    close(lcd->fd);
    }
  }
  {
#line 146
  free((void *)lcd);
  }
#line 147
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
void lcd_reset(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 150
  lcd = (struct lcd_private *)lcd_private___0;
#line 152
  if (! lcd) {
#line 153
    return;
  } else
#line 152
  if (lcd->fd < 0) {
#line 153
    return;
  }
  {
#line 155
  ioctl(lcd->fd, 4UL);
#line 156
  ioctl(lcd->fd, 3UL);
#line 157
  ioctl(lcd->fd, 1UL);
#line 158
  ioctl(lcd->fd, 14UL);
  }
#line 159
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
int lcd_write(void *lcd_private___0 , char const   *line1 , char const   *line2 ) 
{ 
  struct lcd_private *lcd ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 162
  lcd = (struct lcd_private *)lcd_private___0;
#line 164
  if (! lcd) {
#line 165
    return (-1);
  } else
#line 164
  if (lcd->fd < 0) {
#line 165
    return (-1);
  }
#line 167
  if (line1) {
    {
#line 168
    tmp___1 = strlen(line1);
    }
#line 168
    if (tmp___1 < sizeof(lcd->display.line1)) {
      {
#line 168
      tmp___0 = strlen(line1);
#line 168
      lcd->display.size1 = (int )tmp___0;
      }
    } else {
#line 168
      lcd->display.size1 = (int )sizeof(lcd->display.line1);
    }
    {
#line 169
    memcpy((void */* __restrict  */)(lcd->display.line1), (void const   */* __restrict  */)line1,
           (size_t )lcd->display.size1);
    }
  }
#line 172
  if (line2) {
    {
#line 173
    tmp___4 = strlen(line2);
    }
#line 173
    if (tmp___4 < sizeof(lcd->display.line2)) {
      {
#line 173
      tmp___3 = strlen(line2);
#line 173
      lcd->display.size2 = (int )tmp___3;
      }
    } else {
#line 173
      lcd->display.size2 = (int )sizeof(lcd->display.line2);
    }
    {
#line 174
    memcpy((void */* __restrict  */)(lcd->display.line2), (void const   */* __restrict  */)line2,
           (size_t )lcd->display.size2);
    }
  }
  {
#line 177
  ioctl(lcd->fd, 13UL, & lcd->display);
  }
#line 178
  return (0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
int lcd_setleds(void *lcd_private___0 , int const   pattern ) 
{ 
  struct lcd_private *lcd ;
  int tmp ;

  {
  {
#line 182
  lcd = (struct lcd_private *)lcd_private___0;
#line 184
  tmp = ioctl(lcd->fd, 43UL, pattern);
  }
#line 184
  if (tmp == 0) {
#line 185
    return (0);
  }
#line 187
  if (! lcd) {
#line 188
    return (-1);
  } else
#line 187
  if (lcd->fd < 0) {
#line 188
    return (-1);
  } else
#line 187
  if ((pattern & 15) == 15) {
#line 188
    return (-1);
  }
  {
#line 190
  lcd->display.leds = (unsigned char )pattern;
#line 191
  ioctl(lcd->fd, 40UL, & lcd->display);
  }
#line 192
  return (0);
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
int lcd_led_set(void *lcd_private___0 , unsigned int const   pattern ) 
{ 
  struct lcd_private *lcd ;
  int tmp ;

  {
  {
#line 196
  lcd = (struct lcd_private *)lcd_private___0;
#line 198
  tmp = ioctl(lcd->fd, 44UL, pattern);
  }
#line 198
  if (tmp == 0) {
#line 199
    return (0);
  }
#line 201
  if (! lcd) {
#line 202
    return (-1);
  } else
#line 201
  if (lcd->fd < 0) {
#line 202
    return (-1);
  } else
#line 201
  if ((pattern & 15U) == 15U) {
#line 202
    return (-1);
  }
  {
#line 204
  lcd->display.leds = (unsigned char )pattern;
#line 205
  ioctl(lcd->fd, 40UL, & lcd->display);
  }
#line 206
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcddisplay.c"
int lcd_led_clear(void *lcd_private___0 , unsigned int const   pattern ) 
{ 
  struct lcd_private *lcd ;
  int tmp ;

  {
  {
#line 210
  lcd = (struct lcd_private *)lcd_private___0;
#line 212
  tmp = ioctl(lcd->fd, 45UL, pattern);
  }
#line 212
  if (tmp == 0) {
#line 213
    return (0);
  }
#line 215
  if (! lcd) {
#line 216
    return (-1);
  } else
#line 215
  if (lcd->fd < 0) {
#line 216
    return (-1);
  } else
#line 215
  if ((pattern & 15U) == 15U) {
#line 216
    return (-1);
  }
  {
#line 218
  lcd->display.leds = (unsigned char )pattern;
#line 219
  ioctl(lcd->fd, 40UL, & lcd->display);
  }
#line 220
  return (0);
}
}
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 42 "../lcdutils.h"
int lcd_timeout_start(void (*fcn)(int const    ) , int const   seconds ) ;
#line 43
void lcd_timeout_stop(void) ;
#line 44
int lcd_timeout_reset(void) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
int lcd_timeout_start(void (*fcn)(int const    ) , int const   seconds ) 
{ 
  struct sigaction act ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 46
  memset((void *)(& act), 0, sizeof(act));
#line 47
  act.__sigaction_handler.sa_handler = (void (*)(int  ))fcn;
#line 48
  act.sa_flags = 268435456;
#line 49
  tmp = sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 49
  if (tmp < 0) {
#line 50
    return (-1);
  }
  {
#line 52
  memset((void *)(& timeout), 0, sizeof(timeout));
#line 53
  timeout.it_interval.tv_sec = (__time_t )seconds;
#line 54
  timeout.it_value.tv_sec = (__time_t )seconds;
#line 55
  tmp___0 = setitimer(0, (struct itimerval  const  */* __restrict  */)(& timeout),
                      (struct itimerval */* __restrict  */)((void *)0));
  }
#line 55
  if (tmp___0 < 0) {
    {
#line 56
    sigaction(14, (struct sigaction  const  */* __restrict  */)((void *)0), (struct sigaction */* __restrict  */)((void *)0));
    }
#line 57
    return (-1);
  }
#line 60
  return (0);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
void lcd_timeout_stop(void) 
{ 
  struct itimerval zero ;
  struct sigaction act ;

  {
  {
#line 68
  memset((void *)(& zero), 0, sizeof(zero));
#line 69
  memset((void *)(& act), 0, sizeof(act));
#line 70
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& zero), (struct itimerval */* __restrict  */)((void *)0));
#line 71
  act.__sigaction_handler.sa_handler = (void (*)(int  ))0;
#line 72
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 73
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
int lcd_timeout_reset(void) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = setitimer(0, (struct itimerval  const  */* __restrict  */)(& timeout), (struct itimerval */* __restrict  */)((void *)0));
  }
#line 77
  return (tmp);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 38 "../lcdutils.h"
int lcd_button_debounce(void *lcd_private___0 ) ;
#line 39
int lcd_button_sense(void *lcd_private___0 ) ;
#line 58
void lcd_setcursorpos(void *lcd_private___0 , unsigned char address ) ;
#line 59
void lcd_setcursor(void *lcd_private___0 , unsigned char character ) ;
#line 60
int lcd_getcursorpos(void *lcd_private___0 ) ;
#line 61
int lcd_getcursor(void *lcd_private___0 ) ;
#line 69
int lcd_getdisplay(void *lcd_private___0 , char **line1 , char **line2 , int *buttons ) ;
#line 70
int lcd_readbutton(void *lcd_private___0 ) ;
#line 74
void lcd_netcorrect(void *lcd ) ;
#line 75
int lcd_netbutton(void *lcd ) ;
#line 76
void lcd_rev_format(char *in ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
void lcd_rev_format(char *in ) 
{ 
  int one ;
  int two ;
  int three ;
  int four ;

  {
  {
#line 35
  sscanf((char const   */* __restrict  */)in, (char const   */* __restrict  */)"%d.%d.%d.%d",
         & one, & two, & three, & four);
  }
#line 36
  if (one > 255) {
#line 36
    one = 0;
  }
#line 37
  if (two > 255) {
#line 37
    two = 0;
  }
#line 38
  if (three > 255) {
#line 38
    three = 0;
  }
#line 39
  if (four > 255) {
#line 39
    four = 0;
  }
  {
#line 40
  sprintf((char */* __restrict  */)in, (char const   */* __restrict  */)"%03d.%03d.%03d.%03d",
          one, two, three, four);
  }
#line 41
  return;
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
int lcd_netbutton(void *lcd ) 
{ 
  int firstdigit ;
  int button ;
  int i ;
  int ctr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 45
  firstdigit = 0;
#line 46
  ctr = 0;
#line 48
  lcd_set(lcd, (int const   )15);
  }
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 50
    tmp = lcd_readbutton(lcd);
#line 50
    button = tmp & 255;
    }
#line 51
    if (button != 63) {
#line 51
      if (button != 254) {
        {
#line 52
        ctr ++;
#line 53
        tmp___2 = lcd_button_debounce(lcd);
        }
#line 53
        if (ctr == tmp___2) {
          {
#line 56
          if (button == 250) {
#line 56
            goto case_250;
          }
#line 56
          if (button == 59) {
#line 56
            goto case_250;
          }
#line 67
          if (button == 222) {
#line 67
            goto case_222;
          }
#line 67
          if (button == 55) {
#line 67
            goto case_222;
          }
#line 78
          if (button == 246) {
#line 78
            goto case_246;
          }
#line 78
          if (button == 47) {
#line 78
            goto case_246;
          }
#line 93
          if (button == 238) {
#line 93
            goto case_238;
          }
#line 93
          if (button == 31) {
#line 93
            goto case_238;
          }
#line 108
          if (button == 126) {
#line 108
            goto case_126;
          }
#line 108
          if (button == 61) {
#line 108
            goto case_126;
          }
#line 112
          if (button == 190) {
#line 112
            goto case_190;
          }
#line 112
          if (button == 62) {
#line 112
            goto case_190;
          }
#line 54
          goto switch_break;
          case_250: /* CIL Label */ 
          case_59: /* CIL Label */ 
          {
#line 57
          i = lcd_getcursorpos(lcd);
          }
#line 58
          if (i != 64) {
            {
#line 59
            lcd_set(lcd, (int const   )5);
#line 60
            i = lcd_getcursor(lcd);
            }
#line 61
            if (i == 46) {
              {
#line 62
              lcd_set(lcd, (int const   )5);
              }
            }
          }
#line 64
          goto switch_break;
          case_222: /* CIL Label */ 
          case_55: /* CIL Label */ 
          {
#line 68
          i = lcd_getcursorpos(lcd);
          }
#line 69
          if (i != 78) {
            {
#line 70
            lcd_set(lcd, (int const   )6);
#line 71
            i = lcd_getcursor(lcd);
            }
#line 72
            if (i == 46) {
              {
#line 73
              lcd_set(lcd, (int const   )6);
              }
            }
          }
#line 75
          goto switch_break;
          case_246: /* CIL Label */ 
          case_47: /* CIL Label */ 
          {
#line 79
          i = lcd_getcursorpos(lcd);
#line 80
          firstdigit = 0;
          }
#line 81
          if (i == 64) {
#line 81
            tmp___0 = 1;
          } else
#line 81
          if (i == 68) {
#line 81
            tmp___0 = 1;
          } else
#line 81
          if (i == 72) {
#line 81
            tmp___0 = 1;
          } else
#line 81
          if (i == 76) {
#line 81
            tmp___0 = 1;
          } else {
#line 81
            tmp___0 = 0;
          }
          {
#line 81
          firstdigit = tmp___0;
#line 82
          i = lcd_getcursor(lcd);
          }
#line 83
          if (i == 57) {
#line 84
            i = '0';
          } else
#line 85
          if (i == 50) {
#line 85
            if (firstdigit) {
#line 86
              i = '0';
            } else {
#line 88
              i ++;
            }
          } else {
#line 88
            i ++;
          }
          {
#line 89
          lcd_setcursor(lcd, (unsigned char )i);
          }
#line 90
          goto switch_break;
          case_238: /* CIL Label */ 
          case_31: /* CIL Label */ 
          {
#line 94
          i = lcd_getcursorpos(lcd);
#line 95
          firstdigit = 0;
          }
#line 96
          if (i == 64) {
#line 96
            tmp___1 = 1;
          } else
#line 96
          if (i == 68) {
#line 96
            tmp___1 = 1;
          } else
#line 96
          if (i == 72) {
#line 96
            tmp___1 = 1;
          } else
#line 96
          if (i == 76) {
#line 96
            tmp___1 = 1;
          } else {
#line 96
            tmp___1 = 0;
          }
          {
#line 96
          firstdigit = tmp___1;
#line 97
          i = lcd_getcursor(lcd);
          }
#line 98
          if (i == 48) {
#line 98
            if (! firstdigit) {
#line 99
              i = '9';
            } else {
#line 98
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 100
          if (i == 48) {
#line 100
            if (firstdigit) {
#line 101
              i = '2';
            } else {
#line 103
              i --;
            }
          } else {
#line 103
            i --;
          }
          {
#line 104
          lcd_setcursor(lcd, (unsigned char )i);
          }
#line 105
          goto switch_break;
          case_126: /* CIL Label */ 
          case_61: /* CIL Label */ 
#line 109
          goto switch_break;
          case_190: /* CIL Label */ 
          case_62: /* CIL Label */ 
          {
#line 113
          lcd_getdisplay(lcd, (char **)((void *)0), (char **)((void *)0), & i);
          }
#line 114
          return (i);
#line 115
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
          {
#line 117
          lcd_netcorrect(lcd);
          }
        }
        {
#line 119
        tmp___3 = lcd_button_sense(lcd);
        }
#line 119
        if (ctr == tmp___3) {
#line 120
          ctr = 0;
        }
      } else {
#line 124
        ctr = 0;
      }
    } else {
#line 124
      ctr = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
void lcd_netcorrect(void *lcd ) 
{ 
  char last_address ;
  char *line1 ;
  char last_line1[40] ;
  char *line2 ;
  char last_line2[40] ;
  int tmp ;

  {
  {
#line 151
  tmp = lcd_getcursorpos(lcd);
#line 151
  last_address = (char )tmp;
#line 152
  lcd_getdisplay(lcd, & line1, & line2, (int *)((void *)0));
#line 153
  strcpy((char */* __restrict  */)(last_line1), (char const   */* __restrict  */)line1);
#line 154
  strcpy((char */* __restrict  */)(last_line2), (char const   */* __restrict  */)line2);
#line 157
  mangle_num(last_line2);
#line 158
  mangle_num(last_line2 + 4);
#line 159
  mangle_num(last_line2 + 8);
#line 160
  mangle_num(last_line2 + 12);
#line 161
  lcd_write(lcd, (char const   *)(last_line1), (char const   *)(last_line2));
#line 162
  lcd_setcursorpos(lcd, (unsigned char )last_address);
#line 163
  lcd_set(lcd, (int const   )15);
  }
#line 164
  return;
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 71 "../lcdutils.h"
int lcd_getbutton(void *lcd_private___0 ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdread.c"
int lcd_getdisplay(void *lcd_private___0 , char **line1 , char **line2 , int *buttons ) 
{ 
  struct lcd_private *lcd ;

  {
#line 34
  lcd = (struct lcd_private *)lcd_private___0;
#line 36
  if (! lcd) {
#line 37
    return (-1);
  } else
#line 36
  if (lcd->fd < 0) {
#line 37
    return (-1);
  }
  {
#line 39
  ioctl(lcd->fd, 12UL, & lcd->display);
  }
#line 40
  if (line1) {
#line 41
    *line1 = (char *)(lcd->display.line1);
  }
#line 42
  if (line2) {
#line 43
    *line2 = (char *)(lcd->display.line2);
  }
#line 44
  if (buttons) {
#line 45
    *buttons = (int )lcd->display.buttons;
  }
#line 46
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdread.c"
int lcd_readbutton(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 50
  lcd = (struct lcd_private *)lcd_private___0;
#line 52
  if (! lcd) {
#line 53
    return (-1);
  } else
#line 52
  if (lcd->fd < 0) {
#line 53
    return (-1);
  }
  {
#line 55
  ioctl(lcd->fd, 50UL, & lcd->display);
  }
#line 56
  return ((int )lcd->display.buttons);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdread.c"
int lcd_getbutton(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;
  int i ;
  ssize_t tmp ;

  {
#line 61
  lcd = (struct lcd_private *)lcd_private___0;
#line 64
  if (! lcd) {
#line 65
    return (-2);
  } else
#line 64
  if (lcd->fd < 0) {
#line 65
    return (-2);
  }
  {
#line 67
  tmp = read(lcd->fd, (void *)(& i), (size_t )1);
  }
#line 67
  return ((int )tmp);
}
}
#line 49 "../lcdutils.h"
void lcd_wait_no_button(void *lcd_private___0 ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdbutton.c"
int lcd_button_debounce(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 29
  lcd = (struct lcd_private *)lcd_private___0;
#line 30
  return (lcd->button_debounce);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdbutton.c"
int lcd_button_sense(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 34
  lcd = (struct lcd_private *)lcd_private___0;
#line 35
  return (lcd->button_sense);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdbutton.c"
void lcd_wait_no_button(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 40
  lcd = (struct lcd_private *)lcd_private___0;
#line 42
  if (! lcd) {
#line 43
    return;
  } else
#line 42
  if (lcd->fd < 0) {
#line 43
    return;
  }
  {
#line 45
  ioctl(lcd->fd, 50, & lcd->display);
#line 46
  lcd->display.buttons &= 255UL;
  }
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (lcd->display.buttons != 63UL) {
#line 47
      if (! (lcd->display.buttons != 254UL)) {
#line 47
        goto while_break;
      }
    } else {
#line 47
      goto while_break;
    }
    {
#line 48
    ioctl(lcd->fd, 50, & lcd->display);
#line 49
    lcd->display.buttons &= 255UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lcdutils.h"
void lcd_setlocale(void) ;
#line 65
int lcd_checklink(void *lcd_private___0 ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/iflink.c"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/iflink.c"
int main(int argc , char **argv ) 
{ 
  void *lcd ;
  int ctr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 29
  lcd_setlocale();
#line 31
  lcd = lcd_open((int const   )2);
  }
#line 31
  if ((unsigned long )lcd == (unsigned long )((void *)0)) {
    {
#line 32
    tmp = gettext("LCD is not present\n");
#line 32
    printf((char const   */* __restrict  */)tmp);
#line 33
    exit(0);
    }
  }
  {
#line 36
  ctr = lcd_checklink(lcd);
#line 37
  lcd_close(lcd);
  }
#line 39
  if (ctr) {
    {
#line 40
    tmp___0 = gettext("No Link Detected\n");
#line 40
    printf((char const   */* __restrict  */)tmp___0);
#line 41
    exit(0);
    }
  }
  {
#line 44
  tmp___1 = gettext("Link Detected\n");
#line 44
  printf((char const   */* __restrict  */)tmp___1);
#line 45
  exit(1);
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlocale.c"
extern int _nl_msg_cat_cntr ;
#line 41 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlocale.c"
void lcd_setlocale(void) 
{ 
  unsigned char language[32] ;
  FILE *fp ;

  {
  {
#line 45
  fp = fopen((char const   */* __restrict  */)"/etc/cobalt/locale", (char const   */* __restrict  */)"r");
  }
#line 45
  if (fp) {
    {
#line 46
    fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", language);
#line 47
    fclose(fp);
    }
  } else {
    {
#line 49
    strcpy((char */* __restrict  */)(language), (char const   */* __restrict  */)"en_US");
    }
  }
  {
#line 52
  setenv("LANGUAGE", (char const   *)(language), 1);
#line 53
  _nl_msg_cat_cntr ++;
#line 54
  setlocale(6, "");
#line 55
  bindtextdomain("panel-utils", "/usr/share/locale");
#line 56
  textdomain("panel-utils");
  }
#line 57
  return;
}
}
#line 27 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdcursor.c"
void lcd_setcursorpos(void *lcd_private___0 , unsigned char address ) 
{ 
  struct lcd_private *lcd ;

  {
#line 28
  lcd = (struct lcd_private *)lcd_private___0;
#line 30
  if (! lcd) {
#line 31
    return;
  } else
#line 30
  if (lcd->fd < 0) {
#line 31
    return;
  }
  {
#line 33
  lcd->display.cursor_address = address;
#line 34
  ioctl(lcd->fd, 17UL, & lcd->display);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdcursor.c"
void lcd_setcursor(void *lcd_private___0 , unsigned char character ) 
{ 
  struct lcd_private *lcd ;

  {
#line 38
  lcd = (struct lcd_private *)lcd_private___0;
#line 40
  if (! lcd) {
#line 41
    return;
  } else
#line 40
  if (lcd->fd < 0) {
#line 41
    return;
  }
  {
#line 43
  lcd->display.character = character;
#line 44
  ioctl(lcd->fd, 10UL, & lcd->display);
  }
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdcursor.c"
int lcd_getcursorpos(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 48
  lcd = (struct lcd_private *)lcd_private___0;
#line 50
  if (! lcd) {
#line 51
    return (-1);
  } else
#line 50
  if (lcd->fd < 0) {
#line 51
    return (-1);
  }
  {
#line 53
  ioctl(lcd->fd, 16UL, & lcd->display);
  }
#line 54
  return ((int )lcd->display.cursor_address);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdcursor.c"
int lcd_getcursor(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 58
  lcd = (struct lcd_private *)lcd_private___0;
#line 60
  if (! lcd) {
#line 61
    return (-1);
  } else
#line 60
  if (lcd->fd < 0) {
#line 61
    return (-1);
  }
  {
#line 63
  ioctl(lcd->fd, 9UL, & lcd->display);
  }
#line 64
  return ((int )lcd->display.character);
}
}
#line 66 "../lcdutils.h"
int lcd_checklink2(void *lcd_private___0 , int *buttons ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlink.c"
int lcd_checklink(void *lcd_private___0 ) 
{ 
  struct lcd_private *lcd ;

  {
#line 30
  lcd = (struct lcd_private *)lcd_private___0;
#line 32
  if (! lcd) {
#line 33
    return (-1);
  } else
#line 32
  if (lcd->fd < 0) {
#line 33
    return (-1);
  }
  {
#line 35
  lcd->display.buttons = 0UL;
#line 36
  ioctl(lcd->fd, 90UL, & lcd->display);
  }
#line 37
  return ((int )(lcd->display.buttons & 4UL));
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlink.c"
int lcd_checklink2(void *lcd_private___0 , int *buttons ) 
{ 
  struct lcd_private *lcd ;
  int i ;

  {
#line 41
  lcd = (struct lcd_private *)lcd_private___0;
#line 44
  if (! lcd) {
#line 45
    return (-1);
  } else
#line 44
  if (lcd->fd < 0) {
#line 45
    return (-1);
  }
#line 47
  if (buttons) {
#line 47
    lcd->display.buttons = (unsigned long )*buttons;
  } else {
#line 47
    lcd->display.buttons = 0UL;
  }
  {
#line 48
  i = ioctl(lcd->fd, 91UL, & lcd->display);
  }
#line 48
  if (i < 0) {
#line 49
    return (i);
  }
#line 51
  if (buttons) {
#line 52
    *buttons = (int )lcd->display.buttons;
  }
#line 53
  return (0);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 263
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 31 "../lcdutils.h"
int lcd_lock(void) ;
#line 32
void lcd_unlock(void) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd  =    -1;
#line 45 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
int lcd_lock(void) 
{ 
  char buf[16] ;
  struct flock lock ;
  struct stat st1 ;
  struct stat st2 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;

  {
#line 50
  if (lockfd > -1) {
#line 51
    return (-2);
  }
  {
#line 57
  tmp___3 = lstat((char const   */* __restrict  */)"/var/run/.lcdlock", (struct stat */* __restrict  */)(& st1));
  }
#line 57
  if (tmp___3 < 0) {
    {
#line 61
    lockfd = open("/var/run/.lcdlock", 706, 384);
    }
#line 62
    if (lockfd < 0) {
      {
#line 63
      tmp = __errno_location();
#line 63
      tmp___0 = strerror(*tmp);
#line 63
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to open file \'%s\' for write: %s\n",
              "/var/run/.lcdlock", tmp___0);
#line 64
      lockfd = -1;
      }
#line 64
      return (lockfd);
    }
  } else {
#line 71
    if (! ((st1.st_mode & 61440U) == 32768U)) {
      {
#line 72
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: file \'%s\' has invalid mode: %d\n",
              "/var/run/.lcdlock", st1.st_mode);
#line 74
      lockfd = -1;
      }
#line 74
      return (lockfd);
    }
#line 80
    if (st1.st_nlink != 1UL) {
      {
#line 81
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: file \'%s\' has invalid link count: %d != 1\n",
              "/var/run/.lcdlock", st1.st_nlink);
#line 82
      lockfd = -1;
      }
#line 82
      return (lockfd);
    }
    {
#line 88
    lockfd = open("/var/run/.lcdlock", 131586, 384);
    }
#line 89
    if (lockfd < 0) {
      {
#line 90
      tmp___1 = __errno_location();
#line 90
      tmp___2 = strerror(*tmp___1);
#line 90
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to overwrite file \'%s\': %s\n",
              "/var/run/.lcdlock", tmp___2);
#line 92
      lockfd = -1;
      }
#line 92
      return (lockfd);
    }
    {
#line 98
    fstat(lockfd, & st2);
    }
#line 99
    if (st2.st_ino != st1.st_ino) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to verify file \'%s\'\n",
              "/var/run/.lcdlock");
#line 101
      close(lockfd);
#line 102
      lockfd = -1;
      }
#line 102
      return (lockfd);
    } else
#line 99
    if (st2.st_uid != st1.st_uid) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to verify file \'%s\'\n",
              "/var/run/.lcdlock");
#line 101
      close(lockfd);
#line 102
      lockfd = -1;
      }
#line 102
      return (lockfd);
    } else
#line 99
    if (st2.st_nlink != 1UL) {
      {
#line 100
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to verify file \'%s\'\n",
              "/var/run/.lcdlock");
#line 101
      close(lockfd);
#line 102
      lockfd = -1;
      }
#line 102
      return (lockfd);
    }
  }
  {
#line 110
  memset((void *)(& lock), 0, sizeof(lock));
#line 111
  lock.l_type = (short)1;
#line 112
  tmp___4 = fcntl(lockfd, 6, & lock);
  }
#line 112
  if (tmp___4 < 0) {
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to establish fcntl lock on file \'%s\'\n",
            "/var/run/.lcdlock");
#line 114
    close(lockfd);
#line 115
    lockfd = -1;
    }
#line 115
    return (lockfd);
  }
  {
#line 118
  memset((void *)(& buf[0]), 0, sizeof(buf));
#line 119
  tmp___5 = getpid();
#line 119
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d", tmp___5);
#line 120
  tmp___6 = strlen((char const   *)(buf));
#line 120
  tmp___7 = write(lockfd, (void const   *)(buf), tmp___6);
  }
#line 120
  if (tmp___7 < 0L) {
    {
#line 121
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: unable to write PID \'%s\' to file \'%s\'\n",
            buf, "/var/run/.lcdlock");
#line 122
    close(lockfd);
#line 123
    lockfd = -1;
    }
#line 123
    return (lockfd);
  }
#line 125
  return (0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
void lcd_unlock(void) 
{ 


  {
#line 130
  if (lockfd > -1) {
    {
#line 131
    close(lockfd);
#line 132
    lockfd = -1;
    }
  }
  {
#line 134
  unlink("/var/run/.lcdlock");
  }
#line 135
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___0  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___0(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___0  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___1  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___1(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___1  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___2  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___2(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___2  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___3  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___3(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___3  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___4  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___4(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___4  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___5  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___5(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___5  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___6  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___6(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___6  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdtimeout.c"
static struct itimerval timeout___7  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdnet.c"
static void mangle_num___7(char *line ) 
{ 
  char *first ;
  char *second ;

  {
#line 130
  first = line + 1;
#line 130
  second = line + 2;
#line 132
  if ((int )*line == 50) {
#line 133
    if ((int )*first == 57) {
#line 134
      *first = (char )'5';
    } else
#line 135
    if ((int )*first > 53) {
#line 136
      *first = (char )'0';
    } else
#line 137
    if ((int )*first == 53) {
#line 138
      if ((int )*second == 57) {
#line 139
        *second = (char )'5';
      } else
#line 140
      if ((int )*second > 53) {
#line 141
        *second = (char )'0';
      }
    }
  }
#line 144
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lcd-yesno.c"
void timeout_handler(int sig ) 
{ 


  {
  {
#line 29
  exit(3);
  }
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/cobalt-panel-utils-1.0.2/lib/lcdlock.c"
static int lockfd___7  =    -1;
